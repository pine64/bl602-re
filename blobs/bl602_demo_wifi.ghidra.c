#include "bl602_demo_wifi.h"



// WARNING: Removing unreachable block (ram,0x230000d8)

void bl602_start(void)

{
  uint32_t *puVar1;
  undefined4 *puVar2;
  int *piVar3;
  ipc_shared_env_tag *piVar4;
  anon_struct_conflict371 *paVar5;
  anon_struct_conflict372 *paVar6;
  code *pcVar7;
  
  puVar2 = (undefined4 *)(ram_heap + 0x1c40);
  paVar5 = &boot2_partition_table;
  do {
    *(undefined4 *)paVar5 = *puVar2;
    puVar2 = puVar2 + 1;
    paVar5 = (anon_struct_conflict371 *)&paVar5->table;
  } while (paVar5 < &boot2_flashCfg);
  puVar1 = (uint32_t *)hal_boot2_get_flash_addr();
  paVar6 = &boot2_flashCfg;
  do {
    paVar6->magic = *puVar1;
    puVar1 = puVar1 + 1;
    paVar6 = (anon_struct_conflict372 *)&paVar6->flashCfg;
  } while (paVar6 < &count);
  puVar2 = (undefined4 *)&_bl_static_blogfile_code_end;
  pcVar7 = AON_Power_On_BG;
  do {
    *(undefined4 *)pcVar7 = *puVar2;
    puVar2 = puVar2 + 1;
    pcVar7 = (code *)&((anon_struct_conflict371 *)pcVar7)->table;
  } while (pcVar7 < &boot2_partition_table);
  piVar3 = &count;
  do {
    *piVar3 = 0;
    piVar3 = piVar3 + 1;
  } while (piVar3 < &__bss_end);
  piVar4 = &ipc_shared_env;
  do {
    (piVar4->msg_a2e_buf).dummy_word = 0;
    piVar4 = (ipc_shared_env_tag *)(piVar4->msg_a2e_buf).msg;
  } while (piVar4 < (ipc_shared_env_tag *)&_heap_wifi_start);
  DAT_42041ff8 = 0x230000e8;
  bfl_main(0,0);
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



err_t cb_httpc_headers_done_fn
                (httpc_state_t *connection,void *arg,pbuf *hdr,u16_t hdr_len,u32_t content_len)

{
  undefined2 in_register_00002036;
  
  printf("[HTTPC] hdr_len is %u, content_len is %lu\r\n",CONCAT22(in_register_00002036,hdr_len),
         content_len);
  return '\0';
}



void cb_httpc_result(void *arg,httpc_result_t httpc_result,u32_t rx_content_len,u32_t srv_res,
                    err_t err)

{
  printf("[HTTPC] Transfer finished. rx_content_len is %lu\r\n",rx_content_len);
  *(undefined4 *)arg = 0;
  return;
}



err_t cb_altcp_recv_fn(void *arg,altcp_pcb *conn,pbuf *p,err_t err)

{
  int count;
  int iVar1;
  uint uVar2;
  
  puts(".");
  iVar1 = count + 1;
  uVar2 = count & 0x3f;
  count = iVar1;
  if (uVar2 == 0) {
    puts("\r\n");
  }
  altcp_recved(conn,p->tot_len);
  pbuf_free(p);
  return '\0';
}



void cmd_stack_wifi(char *buf,int len,int argc,char **argv)

{
  uint8_t stack_wifi_init;
  uint32_t uVar1;
  
  if (stack_wifi_init == '\x01') {
    puts("Wi-Fi Stack Started already!!!\r\n");
    return;
  }
  stack_wifi_init = '\x01';
  uVar1 = bl_timer_now_us();
  printf("Start Wi-Fi fw @%lums\r\n",uVar1 / 1000);
  hal_wifi_start_firmware_task();
  uVar1 = bl_timer_now_us();
  printf("Start Wi-Fi fw is Done @%lums\r\n",uVar1 / 1000);
  aos_post_event(2,1,0);
  return;
}



void cmd_exception_illegal_ins(char *buf,int len,int argc,char **argv)

{
  bl_irq_exception_trigger(BL_IRQ_EXCEPTION_TYPE_ILLEGAL_INSTRUCTION,(void *)0x22008001);
  return;
}



void cmd_exception_store(char *buf,int len,int argc,char **argv)

{
  bl_irq_exception_trigger(BL_IRQ_EXCEPTION_TYPE_STORE_MISALIGN,(void *)0x22008001);
  return;
}



void cmd_exception_l_illegal(char *buf,int len,int argc,char **argv)

{
  bl_irq_exception_trigger(BL_IRQ_EXCEPTION_TYPE_ACCESS_ILLEGAL,(void *)0x200000);
  return;
}



void cmd_exception_load(char *buf,int len,int argc,char **argv)

{
  bl_irq_exception_trigger(BL_IRQ_EXCEPTION_TYPE_LOAD_MISALIGN,(void *)0x22008001);
  return;
}



void cmd_dma(void)

{
  bl_dma_item *first;
  void *__s;
  void *__s_00;
  TickType_t TVar1;
  
  first = (bl_dma_item *)pvPortMalloc(0x1c);
  __s = pvPortMalloc(0x44);
  __s_00 = pvPortMalloc(0x44);
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_dma < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [TEST] [DMA] first %p, src %p, dst %p\r\n",TVar1,&DAT_2307f16c,
              "bl_dma.c",0x1af,first,__s,__s_00);
  }
  memset(first,0,0x1c);
  memset(__s,1,0x44);
  memset(__s_00,0xff,0x44);
  first->ctrl = 0x8c49b011;
  *(void **)&first->src = __s;
  *(void **)&first->dst = __s_00;
  first->next = 0;
  first->cb = _cb_cmd;
  *(bl_dma_item **)&first->arg = first;
  bl_dma_copy(first);
  while (first->arg != (void *)0x0) {
    vTaskDelay(2);
  }
  vPortFree((void *)first->src);
  vPortFree((void *)first->dst);
  vPortFree(first);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 cmd_cks(void)

{
  ushort uVar1;
  TickType_t TVar2;
  char *format;
  undefined *puVar3;
  undefined4 uVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  undefined2 uStack128;
  ushort uStack126;
  undefined4 uStack124;
  undefined4 uStack120;
  bl_dma_item bStack116;
  undefined auStack88 [4];
  undefined4 uStack84;
  undefined4 uStack80;
  undefined2 *puStack76;
  undefined *puStack72;
  undefined **ppuStack68;
  undefined4 uStack64;
  undefined auStack60 [4];
  undefined4 uStack56;
  undefined4 uStack52;
  undefined *puStack48;
  ushort *puStack44;
  undefined4 uStack40;
  undefined4 uStack36;
  
  puStack76 = &uStack128;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] --->>> case1 test\r\n",TVar2,&DAT_2307f16c,"bl_cks.c",0x137);
  }
  DAT_4000a700 = 1;
  iVar5 = 0;
  do {
    DAT_4000a704 = data_src1_2802[iVar5];
    iVar5 = iVar5 + 1;
  } while (iVar5 != 0x14);
  uVar6 = (uint)_DAT_4000a708;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] CKS result with LE is %04x, should be %02x%02x\r\n",TVar2,
              &DAT_2307f16c,"bl_cks.c",0x40,uVar6,0x61,0xb8);
  }
  DAT_4000a700 = 2;
  iVar5 = 0;
  do {
    DAT_4000a704 = data_src1_2802[iVar5];
    iVar5 = iVar5 + 1;
  } while (iVar5 != 0x14);
  uVar6 = (uint)_DAT_4000a708;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] CKS result with BE is %04x, should be %02x%02x\r\n",TVar2,
              &DAT_2307f16c,"bl_cks.c",0x48,uVar6,0x61,0xb8);
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN))
    {
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] --->>> case2 test\r\n",TVar2,&DAT_2307f16c,"bl_cks.c",0x139);
    }
  }
  DAT_4000a700 = 1;
  DAT_4000a704 = 0x3f;
  uVar6 = (uint)_DAT_4000a708;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] CKS LE result is %04x, %04x\r\n",TVar2,&DAT_2307f16c,"bl_cks.c",
              0x61,uVar6,0xc0e0);
  }
  uVar1 = _DAT_4000a708;
  DAT_4000a700 = 2;
  DAT_4000a704 = 0x3f;
  uVar6 = (uint)_DAT_4000a708;
  if (_fsymc_level_hal_drv < BLOG_LEVEL_WARN) {
    if (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN) {
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] CKS BE result is %04x, %04x\r\n",TVar2,&DAT_2307f16c,"bl_cks.c",
                0x73,uVar6,0xc0e0);
      if (uVar1 != 0xc0e0) goto LAB_2303332e;
      if ((BLOG_LEVEL_INFO < _fsymc_level_hal_drv) || (BLOG_LEVEL_INFO < _fsymf_level_hal_drvbl_cks)
         ) goto LAB_23032c88;
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      uVar6 = 0xc0e0;
      uVar4 = 0x75;
      format = "[%10u][%s: %s:%4d] ====== Success %04X Checksum=====\r\n";
LAB_23032c7a:
      bl_printk(format,TVar2,&DAT_2307f16c,"bl_cks.c",uVar4,uVar6);
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)
         ) {
        if (TrapNetCounter == 0) {
          TVar2 = xTaskGetTickCount();
        }
        else {
          TVar2 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] --->>> case3 test\r\n",TVar2,&DAT_2307f16c,"bl_cks.c",0x13b);
      }
    }
    else {
      if (_DAT_4000a708 != 0xc0e0) goto LAB_23033338;
    }
  }
  else {
    if (_DAT_4000a708 != 0xc0e0) {
LAB_2303332e:
      if (_fsymc_level_hal_drv < BLOG_LEVEL_WARN) {
LAB_23033338:
        if (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN) {
          if (TrapNetCounter == 0) {
            TVar2 = xTaskGetTickCount();
          }
          else {
            TVar2 = xTaskGetTickCountFromISR();
          }
          uVar4 = 0x77;
          format = "[%10u][%s: %s:%4d] ====== Failed %04X Checksum======\r\n";
          goto LAB_23032c7a;
        }
      }
    }
  }
LAB_23032c88:
  DAT_4000a700 = 1;
  iVar5 = 1000;
  do {
    DAT_4000a704 = 0x3f;
    iVar5 = iVar5 + -1;
  } while (iVar5 != 0);
  uVar6 = 0xf69118;
  while (uVar6 >> 0x10 != 0) {
    uVar6 = (uVar6 & 0xffff) + (uVar6 >> 0x10);
  }
  uVar7 = (uint)_DAT_4000a708;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] CKS LE result is %04x, %04x\r\n",TVar2,&DAT_2307f16c,"bl_cks.c",
              0x91,uVar7,~uVar6 & 0xffff);
  }
  DAT_4000a700 = 2;
  iVar5 = 1000;
  do {
    DAT_4000a704 = 0x3f;
    iVar5 = iVar5 + -1;
  } while (iVar5 != 0);
  uVar6 = 0xf69118;
  while (uVar6 >> 0x10 != 0) {
    uVar6 = (uVar6 & 0xffff) + (uVar6 >> 0x10);
  }
  uVar7 = (uint)_DAT_4000a708;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] CKS BE result is %04x, %04x\r\n",TVar2,&DAT_2307f16c,"bl_cks.c",
              0xa3,uVar7,~uVar6 & 0xffff);
  }
  if (uVar7 == (~uVar6 & 0xffff)) {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN))
    {
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      uVar4 = 0xa5;
      puVar3 = &DAT_2307f16c;
      format = "[%10u][%s: %s:%4d] ====== Success %04X Checksum=====\r\n";
LAB_230330f0:
      bl_printk(format,TVar2,puVar3,"bl_cks.c",uVar4,uVar7);
      goto LAB_230330f4;
    }
  }
  else {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
       (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_ASSERT)) {
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      uVar4 = 0xa7;
      puVar3 = &DAT_23072bcc;
      format = "[%10u][%s: %s:%4d] ====== Failed %04X Checksum======\r\n";
      goto LAB_230330f0;
    }
LAB_230330f4:
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN))
    {
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] --->>> case4 test\r\n",TVar2,&DAT_2307f16c,"bl_cks.c",0x13d);
    }
  }
  DAT_4000a700 = 1;
  DAT_4000a704 = 0xa1;
  uVar6 = (uint)_DAT_4000a708;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] CKS LE result is %04x, %04x\r\n",TVar2,&DAT_2307f16c,"bl_cks.c",
              0xc4,uVar6,0xc03f);
  }
  uVar1 = _DAT_4000a708;
  DAT_4000a700 = 2;
  DAT_4000a704 = 0xa1;
  uVar6 = (uint)_DAT_4000a708;
  if (_fsymc_level_hal_drv < BLOG_LEVEL_WARN) {
    if (BLOG_LEVEL_INFO < _fsymf_level_hal_drvbl_cks) {
      if (_DAT_4000a708 == 0xc03f) goto LAB_23032ef6;
      goto LAB_230332e4;
    }
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] CKS BE result is %04x, %04x\r\n",TVar2,&DAT_2307f16c,"bl_cks.c",
              0xd8,uVar6,0xc03f);
    if (uVar1 != 0xc03f) goto LAB_230332da;
    if ((BLOG_LEVEL_INFO < _fsymc_level_hal_drv) || (BLOG_LEVEL_INFO < _fsymf_level_hal_drvbl_cks))
    goto LAB_23032ef6;
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    uVar6 = 0xc03f;
    uVar4 = 0xda;
    puVar3 = &DAT_2307f16c;
    format = "[%10u][%s: %s:%4d] ====== Success %04X Checksum=====\r\n";
LAB_230331c2:
    bl_printk(format,TVar2,puVar3,"bl_cks.c",uVar4,uVar6);
  }
  else {
    if (_DAT_4000a708 == 0xc03f) goto LAB_23032ef6;
LAB_230332da:
    if (_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) {
LAB_230332e4:
      if (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_ASSERT) {
        if (TrapNetCounter == 0) {
          TVar2 = xTaskGetTickCount();
        }
        else {
          TVar2 = xTaskGetTickCountFromISR();
        }
        uVar4 = 0xdc;
        puVar3 = &DAT_23072bcc;
        format = "[%10u][%s: %s:%4d] ====== Failed %04X Checksum======\r\n";
        goto LAB_230331c2;
      }
    }
  }
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] --->>> case5 test\r\n",TVar2,&DAT_2307f16c,"bl_cks.c",0x13f);
  }
LAB_23032ef6:
  bStack116.arg = &bStack116;
  uStack128 = 0x3f1f;
  uStack124 = 1;
  uStack120 = 2;
  uStack126 = 0;
  memset(bStack116.arg,0,0x1c);
  memset(auStack88,0,0x1c);
  memset(auStack60,0,0x1c);
  bStack116.src = &uStack124;
  bStack116.dst = &DAT_4000a700;
  bStack116.next = &puStack76;
  bStack116.ctrl = 0x4480002;
  bStack116.cb = _cb_cmd;
  puStack72 = &DAT_4000a704;
  puStack48 = &DAT_4000a708;
  ppuStack68 = &puStack48;
  puStack44 = &uStack126;
  uStack64 = 0x403e8;
  uStack84 = 0;
  uStack80 = 0;
  uStack40 = 0;
  uStack36 = 0x80240001;
  uStack56 = 0;
  uStack52 = 0;
  bl_dma_copy(bStack116.arg);
  while (bStack116.arg != (bl_dma_item *)0x0) {
    vTaskDelay(2);
  }
  if (uStack126 == 0x6df1) {
    if (BLOG_LEVEL_INFO < _fsymc_level_hal_drv) {
      return 0;
    }
    if (BLOG_LEVEL_INFO < _fsymf_level_hal_drvbl_cks) {
      return 0;
    }
    if (TrapNetCounter == 0) {
      xTaskGetTickCount();
    }
    else {
      xTaskGetTickCountFromISR();
    }
    uVar4 = 0x12f;
    puVar3 = &DAT_2307f16c;
    format = "[%10u][%s: %s:%4d] ====== Success %04X Checksum=====\r\n";
  }
  else {
    if (BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) {
      return 0;
    }
    if (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvbl_cks) {
      return 0;
    }
    if (TrapNetCounter == 0) {
      xTaskGetTickCount();
    }
    else {
      xTaskGetTickCountFromISR();
    }
    uVar4 = 0x131;
    puVar3 = &DAT_23072bcc;
    format = "[%10u][%s: %s:%4d] ====== Failed %04X Checksum======\r\n";
  }
  bl_printk(format,puVar3,"bl_cks.c",uVar4,(uint)uStack126);
  return 0;
}



int cmd_aes(void)

{
  bl_irq_register(0x1d,bl_sec_aes_IRQHandler);
  bl_irq_enable(0x1d);
  bl_printk(
           "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n"
           );
  Sec_Eng_AES_Link_Case_CBC_128(SEC_ENG_AES_ID0);
  bl_printk(
           "####################################################################################\r\n"
           );
  Sec_Eng_AES_Link_Case_CTR_128(SEC_ENG_AES_ID0);
  bl_printk(
           "####################################################################################\r\n"
           );
  Sec_Eng_AES_Link_Case_ECB_128(SEC_ENG_AES_ID0);
  bl_printk(
           "------------------------------------------------------------------------------------\r\n"
           );
  return 0;
}



int cmd_trng(void)

{
  int iVar1;
  
  bl_printk("------------------TRNG TEST---------------------------------\r\n");
  iVar1 = bl_rand();
  bl_printk("**********TRNG TEST rand[%08x]**************\r\n",iVar1);
  iVar1 = bl_rand();
  bl_printk("**********TRNG TEST rand[%08x]**************\r\n",iVar1);
  bl_printk("------------------------------------------------------------\r\n");
  return 0;
}



int cmd_sha(void)

{
  puts("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n");
  puts("^^^^^^^^^^^^^^^^^^^^^^^SHA256 TEST CASE^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n");
  sha256_test_case0();
  puts("------------------------------------------------------------------------------------\r\n");
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void cmd_wifi(void)

{
  uint uVar1;
  undefined *puVar2;
  int iVar3;
  
  uVar1 = _DAT_44b000d8;
  puts("==========================  Keyram Config ========================\r\n");
  printf("  start %02u -->> end %02u; nVAP %02u; max %02u\r\n",uVar1 & 0xff,uVar1 >> 8 & 0xff,
         uVar1 >> 0x10 & 0xff,uVar1 >> 0x18);
  puts("==========================  Keyram Dump =========================\r\n");
  uVar1 = _DAT_44b000d8 >> 8;
  puts("[id]   MAC Address     Key Len  VLan ID  Default      \tKey Hexdump(16Bytes MAX)\r\n");
  iVar3 = 0;
  while (iVar3 < (int)(uVar1 & 0xff)) {
    blmac_encr_cntrl_pack('\x01','\0',(uint16_t)iVar3,'\0','\0','\0','\0','\0');
    do {
    } while ((int)_DAT_44b000c4 < 0);
    printf("[%02d] %02X:%02X:%02X:%02X:%02X:%02X",iVar3,_DAT_44b000bc & 0xff,
           _DAT_44b000bc >> 8 & 0xff,_DAT_44b000bc >> 0x10 & 0xff,_DAT_44b000bc >> 0x18,
           _DAT_44b000c0 & 0xff,_DAT_44b000c0 >> 8 & 0xff);
    puVar2 = &UNK_230743ec;
    if ((_DAT_44b000c4 & 1) == 0) {
      puVar2 = &UNK_230743f4;
    }
    printf(" %s",puVar2);
    iVar3 = iVar3 + 1;
    printf("    %02u",_DAT_44b000c4 >> 4 & 0xf);
    printf("        %u",_DAT_44b000c4 >> 1 & 1);
    printf("     %02X%02X%02X%02X %02X%02X%02X%02X %02X%02X%02X%02X %02X%02X%02X%02X",
           _DAT_44b000ac & 0xff,_DAT_44b000ac >> 8 & 0xff,_DAT_44b000ac >> 0x10 & 0xff,
           _DAT_44b000ac >> 0x18,_DAT_44b000b0 & 0xff,_DAT_44b000b0 >> 8 & 0xff,
           _DAT_44b000b0 >> 0x10 & 0xff);
    puts("\r\n");
  }
  puts("==========================  MAC Address =========================\r\n");
  printf("    MAC %02X:%02X:%02X:%02X:%02X:%02X",_DAT_44b00010 & 0xff,_DAT_44b00010 >> 8 & 0xff,
         _DAT_44b00010 >> 0x10 & 0xff,_DAT_44b00010 >> 0x18,_DAT_44b00014 & 0xff,
         _DAT_44b00014 >> 8 & 0xff);
  printf(" Mask %02X:%02X:%02X:%02X:%02X:%02X",_DAT_44b00018 & 0xff,_DAT_44b00018 >> 8 & 0xff,
         _DAT_44b00018 >> 0x10 & 0xff,_DAT_44b00018 >> 0x18,_DAT_44b0001c & 0xff,
         _DAT_44b0001c >> 8 & 0xff);
  puts("\r\n");
  printf("  BSSID %02X:%02X:%02X:%02X:%02X:%02X",_DAT_44b00020 & 0xff,_DAT_44b00020 >> 8 & 0xff,
         _DAT_44b00020 >> 0x10 & 0xff,_DAT_44b00020 >> 0x18,_DAT_44b00024 & 0xff,
         _DAT_44b00024 >> 8 & 0xff);
  printf(" Mask %02X:%02X:%02X:%02X:%02X:%02X",_DAT_44b00028 >> 8 & 0xff,
         _DAT_44b00028 >> 0x10 & 0xff,_DAT_44b00028 >> 0x18,_DAT_44b0002c & 0xff,
         _DAT_44b0002c >> 8 & 0xff);
  puts("\r\n");
  return;
}



int cmd_pka(void)

{
  bl_irq_register(0x1b,bl_sec_pka_IRQHandler);
  bl_irq_enable(0x1b);
  _pka_test_case2();
  _pka_test_case_xgcd();
  _pka_test_case2();
  return 0;
}



void cmd_aws(char *buf,int len,int argc,char **argv)

{
  xTaskCreate(aws_main_entry,"aws_iot",0x1000,(void *)0x0,10,(TaskHandle_t *)0x0);
  return;
}



void proc_hellow_entry(void *pvParameters)

{
  char "proc_hellow_entry" [18];
  
  vTaskDelay(500);
  do {
    printf("%s: RISC-V rv32imafc\r\n","proc_hellow_entry");
    vTaskDelay(10000);
  } while( true );
}



uchar char_to_hex(char asccode)

{
  char cVar1;
  byte bVar2;
  
  bVar2 = asccode - 0x30;
  if (9 < bVar2) {
    if ((byte)(asccode + 0x9fU) < 6) {
      cVar1 = -0x57;
    }
    else {
      if (5 < (byte)(asccode + 0xbfU)) {
        return '\0';
      }
      cVar1 = -0x37;
    }
    bVar2 = asccode + cVar1;
  }
  return (uchar)bVar2;
}



void cmd_httpc_test(char *buf,int len,int argc,char **argv)

{
  if (req_12703 != 0) {
    printf("[CLI] req is on-going...\r\n");
    return;
  }
  memset(settings_12702,0,0x1c);
  settings_12702._20_4_ = cb_httpc_result;
  settings_12702._24_4_ = cb_httpc_headers_done_fn;
  settings_12702[6] = 0;
  httpc_get_file_dns("nf.cr.dandanman.com",0x50,"/ddm/ContentResource/music/204.mp3",
                     (httpc_connection_t_conflict *)settings_12702,cb_altcp_recv_fn,&req_12703,
                     (httpc_state_t **)&req_12703);
  return;
}



int get_dts_addr(char *name)

{
  TickType_t TVar1;
  
  if (TrapNetCounter == 0) {
    TVar1 = xTaskGetTickCount();
  }
  else {
    TVar1 = xTaskGetTickCountFromISR();
  }
  bl_printk("[%10u][%s: %s:%4d] %s NULL.\r\n",TVar1,&DAT_23072bcc,&UNK_23072bc4,0x322,name);
  return -1;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Could not reconcile some variable overlaps

int client_demo(void)

{
  uint uVar1;
  hostent *phVar2;
  char *__format;
  int s;
  int iVar3;
  TickType_t TVar4;
  void *mem;
  uint uVar5;
  TickType_t TVar6;
  char cVar7;
  ip4_addr_t iStack308;
  uint32_t address;
  sockaddr_in dest;
  char wbuf [111];
  char buffer [128];
  
  phVar2 = lwip_gethostbyname("nf.cr.dandanman.com");
  if (phVar2 == (hostent *)0x0) {
    __format = "gethostbyname Failed\r\n";
  }
  else {
    s = lwip_socket(2,1,0);
    if (s < 0) {
      __format = "Error in socket\r\n";
    }
    else {
      memset(&address,0,0x10);
      address._1_1_ = '\x02';
      address._2_2_ = lwip_htons(0x50);
      iStack308 = (ip4_addr_t)((ip4_addr_t *)((ip4_addr_t *)phVar2->h_addr_list)->addr)->addr;
      dest._0_4_ = iStack308;
      __format = ip4addr_ntoa(&iStack308);
      printf("Server ip Address : %s\r\n",__format);
      iVar3 = lwip_connect(s,(sockaddr *)&address,0x10);
      if (iVar3 == 0) {
        memset(wbuf + 0x6c,0,0x80);
        memcpy(dest.sin_zero + 4,
                              
               "GET /ddm/ContentResource/music/204.mp3 HTTP/1.1\r\nHost: nf.cr.dandanman.com\r\nUser-Agent: wmsdk\r\nAccept: */*\r\n\r\n"
               ,0x6f);
        lwip_write(s,dest.sin_zero + 4,0x6e);
        TVar4 = xTaskGetTickCount();
        mem = pvPortMalloc(0x3000);
        if (mem != (void *)0x0) {
          uVar1 = 0;
          cVar7 = '\0';
          do {
            uVar5 = lwip_read(s,mem,0x3000);
            if (uVar5 == 0) {
              printf("eof\n\r",0);
              goto LAB_230006f2;
            }
            if ((int)uVar5 < 0) {
              __format = "ret = %d, err = %d\n\r";
              uVar1 = errno;
              goto LAB_23000718;
            }
            uVar1 = uVar1 + uVar5;
            if (cVar7 == '\0') {
              printf("total = %d, ret = %d\n\r",uVar1,uVar5);
            }
            cVar7 = cVar7 + '\x01';
          } while ((int)uVar1 < 0x4e3fbd1);
          TVar6 = xTaskGetTickCount();
          uVar5 = (TVar6 - TVar4) / 1000;
          __format = "Download comlete, total time %u s, speed %u Kbps\r\n";
          uVar1 = (uVar1 / uVar5 << 3) / 1000;
LAB_23000718:
          printf(__format,uVar5,uVar1);
LAB_230006f2:
          vPortFree(mem);
        }
        lwip_close(s);
        return 0;
      }
      __format = "Error in connect\r\n";
    }
  }
  printf(__format);
  return -1;
}



// WARNING: Type propagation algorithm not settling

int http_test_cmd(void)

{
  uint uVar1;
  hostent *phVar2;
  char *__format;
  int s;
  int iVar3;
  TickType_t TVar4;
  void *mem;
  uint uVar5;
  TickType_t TVar6;
  char cVar7;
  ip4_addr_t iStack308;
  undefined uStack304;
  sa_family_t sStack303;
  u16_t uStack302;
  ip4_addr_t iStack300;
  undefined auStack288 [112];
  undefined auStack176 [136];
  
  phVar2 = lwip_gethostbyname("nf.cr.dandanman.com");
  if (phVar2 == (hostent *)0x0) {
    __format = "gethostbyname Failed\r\n";
  }
  else {
    s = lwip_socket(2,1,0);
    if (s < 0) {
      __format = "Error in socket\r\n";
    }
    else {
      memset(&uStack304,0,0x10);
      sStack303 = '\x02';
      uStack302 = lwip_htons(0x50);
      iStack308 = (ip4_addr_t)((ip4_addr_t *)((ip4_addr_t *)phVar2->h_addr_list)->addr)->addr;
      iStack300 = iStack308;
      __format = ip4addr_ntoa(&iStack308);
      printf("Server ip Address : %s\r\n",__format);
      iVar3 = lwip_connect(s,(sockaddr *)&uStack304,0x10);
      if (iVar3 == 0) {
        memset(auStack176,0,0x80);
        memcpy(auStack288,
                              
               "GET /ddm/ContentResource/music/204.mp3 HTTP/1.1\r\nHost: nf.cr.dandanman.com\r\nUser-Agent: wmsdk\r\nAccept: */*\r\n\r\n"
               ,0x6f);
        lwip_write(s,auStack288,0x6e);
        TVar4 = xTaskGetTickCount();
        mem = pvPortMalloc(0x3000);
        if (mem != (void *)0x0) {
          uVar1 = 0;
          cVar7 = '\0';
          do {
            uVar5 = lwip_read(s,mem,0x3000);
            if (uVar5 == 0) {
              printf("eof\n\r",0);
              goto LAB_230006f2;
            }
            if ((int)uVar5 < 0) {
              __format = "ret = %d, err = %d\n\r";
              uVar1 = errno;
              goto LAB_23000718;
            }
            uVar1 = uVar1 + uVar5;
            if (cVar7 == '\0') {
              printf("total = %d, ret = %d\n\r",uVar1,uVar5);
            }
            cVar7 = cVar7 + '\x01';
          } while ((int)uVar1 < 0x4e3fbd1);
          TVar6 = xTaskGetTickCount();
          uVar5 = (TVar6 - TVar4) / 1000;
          __format = "Download comlete, total time %u s, speed %u Kbps\r\n";
          uVar1 = (uVar1 / uVar5 << 3) / 1000;
LAB_23000718:
          printf(__format,uVar5,uVar1);
LAB_230006f2:
          vPortFree(mem);
        }
        lwip_close(s);
        return 0;
      }
      __format = "Error in connect\r\n";
    }
  }
  printf(__format);
  return -1;
}



void aos_loop_proc(void *pvParameters)

{
  StackType_t proc_stack_looprt [512];
  StaticTask_t proc_task_looprt;
  void *fdt;
  void *fdt_00;
  int sock;
  aos_poll_call_t *cb;
  void *pvVar1;
  void *pvVar2;
  
  looprt_start((StackType_t *)&ram0x4200f8e0,0x200,(StaticTask_t *)&ram0x420100e0);
  loopset_led_hook_on_looprt();
  easyflash_init();
  vfs_init();
  vfs_device_init();
  fdt = (void *)hal_board_get_factory_addr();
  fdt_00 = (void *)fdt_subnode_offset(fdt,0,"uart");
  if (fdt_00 == (void *)0x0) {
    sock = get_dts_addr("uart");
    fdt = fdt_00;
    pvVar2 = (void *)0x0;
    if (sock != 0) goto LAB_230007c6;
    fdt = (void *)0x0;
  }
  vfs_uart_init(fdt,fdt_00);
  pvVar2 = fdt_00;
LAB_230007c6:
  fdt_00 = (void *)hal_board_get_factory_addr();
  pvVar1 = (void *)fdt_subnode_offset(fdt_00,0,"gpio");
  if ((pvVar1 != (void *)0x0) ||
     (sock = get_dts_addr("gpio"), fdt_00 = fdt, pvVar1 = pvVar2, sock == 0)) {
    hal_gpio_init_from_dts(fdt_00,pvVar1);
  }
  romfs_register();
  aos_loop_init();
  sock = aos_open("/dev/ttyS0",0);
  if (-1 < sock) {
    printf("Init CLI with event Driven\r\n");
    aos_cli_init(0);
    cb = (aos_poll_call_t *)aos_cli_event_cb_read_get();
    aos_poll_read_fd(sock,cb,(void *)0x12345678);
    codex_debug_cli_init();
    easyflash_cli_init();
    network_netutils_iperf_cli_register();
    network_netutils_tcpserver_cli_register();
    network_netutils_tcpclinet_cli_register();
    network_netutils_netstat_cli_register();
    network_netutils_ping_cli_register();
    sntp_cli_init();
    bl_sys_time_cli_init();
    bl_sys_ota_cli_init();
    blfdt_cli_init();
    wifi_mgmr_cli_init();
    bl_wdt_cli_init();
    bl_gpio_cli_init();
    looprt_test_cli_init();
  }
  aos_register_event_filter(2,event_cb_wifi_event,(void *)0x0);
  cmd_stack_wifi((char *)0x0,0,0,(char **)0x0);
  aos_loop_run();
  puts("------------------------------------------\r\n");
  puts("+++++++++Critical Exit From Loop++++++++++\r\n");
  puts("******************************************\r\n");
  vTaskDelete((TaskHandle_t)0x0);
  return;
}



void vApplicationStackOverflowHook(TaskHandle_t xTask,char *pcTaskName)

{
  puts("Stack Overflow checked\r\n");
  printf("Task Name %s\r\n",pcTaskName);
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void vApplicationMallocFailedHook(void)

{
  size_t sVar1;
  
  sVar1 = xPortGetFreeHeapSize();
  printf("Memory Allocate Failed. Current left size is %d bytes\r\n",sVar1);
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void vApplicationIdleHook(void)

{
  return;
}



// WARNING: Variable defined which should be unmapped: sta_info

int check_dts_config(char *ssid,char *password)

{
  int iVar1;
  int iVar2;
  undefined auStack116 [4];
  bl_wifi_ap_info_t sta_info;
  
  iVar2 = bl_wifi_sta_info_get((bl_wifi_ap_info_t *)auStack116);
  iVar1 = -1;
  if (iVar2 == 0) {
    strncpy(ssid,auStack116,0x20);
    ssid[0x1f] = '\0';
    strncpy(password,(char *)(sta_info.ssid + 0x1d),0x40);
    password[0x3f] = '\0';
    iVar1 = iVar2;
  }
  return iVar1;
}



void _connect_wifi(undefined4 param_1)

{
  bool bVar1;
  int iVar2;
  uint8_t *puVar3;
  char *__dest;
  uchar uVar4;
  uchar uVar5;
  wifi_interface_t pvVar6;
  char *password_00;
  size_t ssid_len;
  size_t sVar7;
  size_t sVar8;
  undefined3 extraout_var;
  char *__src;
  uint16_t freq;
  int iVar9;
  uint uVar10;
  int iVar11;
  char *__dest_00;
  longlong lVar12;
  byte abStack340 [4];
  uint8_t mac [6];
  char chan [10];
  char bssid [32];
  char ssid [33];
  char pmk [66];
  char password [66];
  char val_buf [66];
  
  pvVar6 = wifi_mgmr_sta_enable();
  wifi_interface = pvVar6;
  lVar12 = aos_now_ms();
  __dest = ssid + 0x20;
  printf(
         "[APP] [WIFI] [T] %lld\r\n[APP]   Get STA %p from Wi-Fi Mgmr, pmk ptr %p, ssid ptr %p, password %p\r\n"
         ,pvVar6,param_1,wifi_interface,__dest,bssid + 0x1c,pmk + 0x40,(int)lVar12);
  memset(__dest,0,0x42);
  memset(bssid + 0x1c,0,0x21);
  memset(pmk + 0x40,0,0x42);
  __dest_00 = chan + 8;
  memset(__dest_00,0,0x20);
  memset(abStack340,0,6);
  memset(mac + 4,0,10);
  memset(password + 0x40,0,0x42);
  ef_get_env_blob("conf_ap_ssid",password + 0x40,0x41,(size_t *)0x0);
  if (password[64] == '\0') {
    password_00 = pmk + 0x40;
    sVar7 = check_dts_config(bssid + 0x1c,password_00);
    freq = 0;
    if (sVar7 != 0) {
      puts("[APP]    Empty Config\r\n");
      puts("[APP]    Try to set the following ENV with psm_set command, then reboot\r\n");
      puts("[APP]    NOTE: conf_ap_pmk MUST be psm_unset when conf is changed\r\n");
      puts("[APP]    env: conf_ap_ssid\r\n");
      puts("[APP]    env: conf_ap_psk\r\n");
      puts("[APP]    env(optinal): conf_ap_pmk\r\n");
      return;
    }
    goto LAB_23000b88;
  }
  strncpy(bssid + 0x1c,password + 0x40,0x20);
  memset(password + 0x40,0,0x42);
  ef_get_env_blob("conf_ap_psk",password + 0x40,0x41,(size_t *)0x0);
  if (password[64] != '\0') {
    strncpy(pmk + 0x40,password + 0x40,0x41);
  }
  memset(password + 0x40,0,0x42);
  __src = password + 0x40;
  password_00 = (char *)ef_get_env_blob("conf_ap_pmk",__src,0x41,(size_t *)0x0);
  if (password[64] != '\0') {
    __src = password + 0x40;
    password_00 = strncpy(__dest,__src,0x41);
  }
  if (ssid[32] == '\0') {
    lVar12 = aos_now_ms();
    printf("[APP] [WIFI] [T] %lld\r\n",password_00,__src,(int)lVar12);
    puts("[APP]    Re-cal pmk\r\n");
    ssid_len = strlen(bssid + 0x1c);
    wifi_mgmr_psk_cal(pmk + 0x40,bssid + 0x1c,ssid_len,__dest);
    ef_set_env("conf_ap_pmk",__dest);
    ef_save_env();
  }
  memset(password + 0x40,0,0x42);
  ef_get_env_blob("conf_ap_channel",password + 0x40,0x41,(size_t *)0x0);
  if (password[64] == '\0') {
LAB_23000b00:
    freq = 0;
    uVar4 = '\0';
  }
  else {
    strncpy((char *)(mac + 4),password + 0x40,9);
    printf("connect wifi channel = %s\r\n",mac + 4);
    password_00 = strchr((char *)(mac + 4),0x7c);
    if (password_00 + 1 == (char *)0x0) goto LAB_23000b00;
    iVar11 = 1;
    iVar9 = 0;
    uVar4 = char_to_hex(password_00[1]);
    ssid_len = strlen((char *)(mac + 4));
    sVar8 = strlen(password_00 + 1);
    iVar2 = ssid_len - sVar8;
    mac[iVar2 + 3] = '\0';
    uVar10 = 0;
    puVar3 = mac + iVar2 + 4;
    while( true ) {
      freq = (uint16_t)uVar10;
      if (iVar2 + -1 <= iVar9) break;
      iVar9 = iVar9 + 1;
      uVar5 = char_to_hex(puVar3[-2]);
      uVar10 = uVar10 + CONCAT31(extraout_var,uVar5) * iVar11 & 0xffff;
      iVar11 = iVar11 * 10;
      puVar3 = puVar3 + -1;
    }
  }
  memset(password + 0x40,0,0x42);
  password_00 = password + 0x40;
  sVar7 = ef_get_env_blob("conf_ap_bssid",password_00,0x41,(size_t *)0x0);
  bVar1 = password[64] != '\0';
  password[64] = uVar4;
  if (bVar1) {
    strncpy(__dest_00,password + 0x40,0x1f);
    printf("connect wifi bssid = %s\r\n",__dest_00);
    ssid_len = strlen(__dest_00);
    if ((ssid_len & 1) != 0) {
      ssid_len = ssid_len - (int)ssid_len % 2;
    }
    if (ssid_len != 0) {
      uVar10 = 0;
      while ((int)uVar10 < (int)ssid_len) {
        uVar4 = char_to_hex(*__dest_00);
        uVar5 = char_to_hex(__dest_00[1]);
        abStack340[uVar10 >> 1] = uVar4 * '\x10' + uVar5;
        uVar10 = uVar10 + 2;
        __dest_00 = __dest_00 + 2;
      }
    }
    password_00 = (char *)(uint)abStack340[0];
    sVar7 = printf("mac = %02X:%02X:%02X:%02X:%02X:%02X\r\n",(uint)abStack340[1],(uint)abStack340[2]
                   ,(uint)abStack340[3],(uint)mac[0],(uint)mac[1]);
  }
LAB_23000b88:
  aos_now_ms();
  ssid_len = strlen(bssid + 0x1c);
  sVar8 = strlen(pmk + 0x40);
  printf(
         "[APP] [WIFI] [T] %lld\r\n[APP]    SSID %s\r\n[APP]    SSID len %d\r\n[APP]    password %s\r\n[APP]    password len %d\r\n[APP]    pmk %s\r\n[APP]    bssid %s\r\n[APP]    channel band %d\r\n[APP]    channel freq %d\r\n"
         ,sVar7,password_00,bssid + 0x1c,ssid_len,pmk + 0x40,sVar8);
  wifi_mgmr_sta_connect
            ((wifi_interface_t *)wifi_interface,bssid + 0x1c,pmk + 0x40,__dest,abStack340,
             password[64],freq);
  return;
}



void event_cb_wifi_event(input_event_t *event,void *private_data)

{
  ushort uVar1;
  char *password;
  char *ssid;
  ulong *puVar2;
  uint32_t uVar3;
  char *__format;
  size_t sVar4;
  wifi_interface_t *wifi_interface;
  input_event_t *piVar5;
  char *__format_00;
  undefined4 uVar6;
  longlong lVar7;
  
  uVar1 = event->code;
  piVar5 = event;
  switch((uint)uVar1 - 1 & 0xffff) {
  case 0:
    lVar7 = aos_now_ms();
    printf("[APP] [EVT] INIT DONE %lld\r\n",event,private_data,(int)lVar7);
    wifi_mgmr_start_background(&conf);
    return;
  case 1:
    aos_now_ms();
    uVar3 = bl_timer_now_us();
    printf("[APP] [EVT] MGMR DONE %lld, now %lums\r\n",event,private_data,uVar3 / 1000);
    _connect_wifi();
    return;
  case 2:
    lVar7 = aos_now_ms();
    uVar6 = (undefined4)lVar7;
    __format = "[APP] [EVT] Reconnect %lld\r\n";
    break;
  case 3:
  case 5:
    lVar7 = aos_now_ms();
    uVar6 = (undefined4)lVar7;
    __format = "[APP] [EVT] connected %lld\r\n";
    break;
  case 4:
    aos_now_ms();
    __format = wifi_mgmr_status_code_str(*(uint16_t *)&event->value);
    __format_00 = "[APP] [EVT] disconnect %lld, Reason: %s\r\n";
    goto LAB_23000dee;
  case 6:
    lVar7 = aos_now_ms();
    printf("[APP] [EVT] GOT IP %lld\r\n",event,private_data,(int)lVar7);
    sVar4 = xPortGetFreeHeapSize();
    printf("[SYS] Memory left is %d Bytes\r\n",sVar4);
    return;
  case 7:
    lVar7 = aos_now_ms();
    uVar6 = (undefined4)lVar7;
    __format = "[APP] [EVT] Connecting %lld\r\n";
    break;
  case 8:
    lVar7 = aos_now_ms();
    printf("[APP] [EVT] SCAN Done %lld\r\n",event,private_data,(int)lVar7);
    wifi_mgmr_cli_scanlist();
    return;
  case 9:
    lVar7 = aos_now_ms();
    uVar6 = (undefined4)lVar7;
    __format = "[APP] [EVT] SCAN On Join %lld\r\n";
    break;
  default:
    lVar7 = aos_now_ms();
    printf("[APP] [EVT] Unknown code %u, %lld\r\n",(uint)uVar1,event,private_data,(int)lVar7);
    return;
  case 0xc:
    lVar7 = aos_now_ms();
    __format = (char *)event->value;
    if (__format == (char *)0x0) {
      __format = "UNKNOWN";
    }
    printf("[APP] [EVT] [PROV] [SSID] %lld: %s\r\n",piVar5,private_data,__format,(int)lVar7);
    puVar2 = (ulong *)0x4200dc84;
    password = ssid;
    goto LAB_23000eaa;
  case 0xd:
    lVar7 = aos_now_ms();
    __format = (char *)event->value;
    if (__format == (char *)0x0) {
      __format = "UNKNOWN";
    }
    printf("[APP] [EVT] [PROV] [BSSID] %lld: %s\r\n",piVar5,private_data,__format,(int)lVar7);
    if ((void *)event->value == (void *)0x0) {
      return;
    }
    vPortFree((void *)event->value);
    return;
  case 0xe:
    lVar7 = aos_now_ms();
    __format = (char *)event->value;
    if (__format == (char *)0x0) {
      __format = "UNKNOWN";
    }
    printf("[APP] [EVT] [PROV] [PASSWD] %lld: %s\r\n",piVar5,private_data,__format,(int)lVar7);
    puVar2 = (ulong *)0x4200dc7c;
LAB_23000eaa:
    if (password != (char *)0x0) {
      vPortFree(password);
    }
    *puVar2 = event->value;
    return;
  case 0xf:
    lVar7 = aos_now_ms();
    printf("[APP] [EVT] [PROV] [CONNECT] %lld\r\n",event,private_data,(int)lVar7);
    printf("connecting to %s:%s...\r\n",ssid,password);
    wifi_interface = (wifi_interface_t *)wifi_mgmr_sta_enable();
    wifi_mgmr_sta_connect(wifi_interface,ssid,password,(char *)0x0,(uint8_t *)0x0,'\0',0);
    return;
  case 0x10:
    lVar7 = aos_now_ms();
    uVar6 = (undefined4)lVar7;
    __format = "[APP] [EVT] [PROV] [DISCONNECT] %lld\r\n";
    break;
  case 0x13:
    lVar7 = aos_now_ms();
    uVar6 = (undefined4)lVar7;
    __format = "[APP] [EVT] Microwave Denoise is ON %lld\r\n";
    break;
  case 0x14:
    aos_now_ms();
    __format = (char *)event->value;
    __format_00 = "[APP] [EVT] [AP] [ADD] %lld, sta idx is %lu\r\n";
    goto LAB_23000dee;
  case 0x15:
    aos_now_ms();
    __format = (char *)event->value;
    __format_00 = "[APP] [EVT] [AP] [DEL] %lld, sta idx is %lu\r\n";
LAB_23000dee:
    printf(__format_00,piVar5,private_data,__format);
    return;
  case 0x16:
    lVar7 = aos_now_ms();
    printf("[APP] [EVT] EMERGENCY MAC %lld\r\n",event,private_data,(int)lVar7);
    hal_reboot();
    return;
  }
  printf(__format,event,private_data,uVar6);
  return;
}



void vApplicationGetIdleTaskMemory
               (StaticTask_t **ppxIdleTaskTCBBuffer,StackType_t **ppxIdleTaskStackBuffer,
               uint32_t *pulIdleTaskStackSize)

{
  StackType_t uxIdleTaskStack [96];
  StaticTask_t xIdleTaskTCB;
  
  *ppxIdleTaskTCBBuffer = (StaticTask_t *)&ram0x4201091c;
  *ppxIdleTaskStackBuffer = (StackType_t *)&ram0x4201015c;
  *pulIdleTaskStackSize = 0x60;
  return;
}



void vApplicationGetTimerTaskMemory
               (StaticTask_t **ppxTimerTaskTCBBuffer,StackType_t **ppxTimerTaskStackBuffer,
               uint32_t *pulTimerTaskStackSize)

{
  StackType_t uxTimerTaskStack [400];
  StaticTask_t xTimerTaskTCB;
  
  *ppxTimerTaskTCBBuffer = (StaticTask_t *)&ram0x4201097c;
  *ppxTimerTaskStackBuffer = (StackType_t *)&ram0x420102dc;
  *pulTimerTaskStackSize = 400;
  return;
}



// WARNING: Removing unreachable block (ram,0x23001014)

void vAssertCalled(void)

{
  uint32_t ulSetTo1ToExitFunction;
  
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



// WARNING: Variable defined which should be unmapped: chip_feature

void bfl_main(void)

{
  StackType_t aos_loop_proc_stack [1024];
  StaticTask_t aos_loop_proc_task;
  StackType_t proc_hellow_stack [512];
  StaticTask_t proc_hellow_task;
  int iVar1;
  char *pcStack60;
  char *banner;
  char chip_feature [40];
  
  time_main = bl_timer_now_us();
  bl_uart_init('\0','\x10','\a',-1,-1,(uint32_t)&DAT_001e8480);
  puts("Starting bl602 now....\r\n");
  puts("Booting BL602 Chip...\r\n");
  iVar1 = bl_chip_banner(&pcStack60);
  if (iVar1 == 0) {
    puts(pcStack60);
  }
  puts("\r\n");
  puts("\r\n");
  puts("------------------------------------------------------------\r\n");
  puts("RISC-V Core Feature:");
  bl_chip_info((char *)&banner);
  puts((char *)&banner);
  puts("\r\n");
  puts("Build Version: ");
  puts("release_bl_iot_sdk_1.6.11-1-g66bb28da-dirty");
  puts("\r\n");
  puts("PHY   Version: ");
  puts("a0_final-44-geb7fadd");
  puts("\r\n");
  puts("RF    Version: ");
  puts("f76e39a");
  puts("\r\n");
  puts("Build Date: ");
  puts("Oct 30 2020");
  puts("\r\n");
  puts("Build Time: ");
  puts("00:08:24");
  puts("\r\n");
  puts("------------------------------------------------------------\r\n");
  vPortDefineHeapRegions(xHeapRegions);
  printf("Heap %u@%p, %u@%p\r\n",&_heap_size,&__bss_end,0x860,&_heap_wifi_start);
  printf("Boot2 consumed %lums\r\n",time_main / 1000);
  blog_init();
  bl_irq_init();
  bl_sec_init();
  bl_sec_test();
  bl_dma_init();
  hal_boot2_init();
  hal_board_cfg(0);
  puts("[OS] Starting proc_hellow_entry task...\r\n");
  xTaskCreateStatic(proc_hellow_entry,"hellow",0x200,(void *)0x0,0xf,(StackType_t *)&ram0x4200f080,
                    (StaticTask_t *)&ram0x4200f880);
  puts("[OS] Starting aos_loop_proc task...\r\n");
  xTaskCreateStatic(aos_loop_proc,"event_loop",0x400,(void *)0x0,0xf,(StackType_t *)&ram0x4200e020,
                    (StaticTask_t *)&ram0x4200f020);
  puts("[OS] Starting TCP/IP Stack...\r\n");
  tcpip_init((tcpip_init_done_fn)0x0,(void *)0x0);
  puts("[OS] Starting OS Scheduler...\r\n");
  vTaskStartScheduler();
  return;
}



void ShadowUpdateStatusCallback
               (char *pThingName,ShadowActions_t action,Shadow_Ack_Status_t status,
               char *pReceivedJsonDocument,void *pContextData)

{
  char *__format;
  undefined3 in_register_00002031;
  int iVar1;
  
  iVar1 = CONCAT31(in_register_00002031,status);
  shadowUpdateInProgress = false;
  if (iVar1 == 0) {
    __format = "Update timed out\r\n";
  }
  else {
    if (iVar1 == 1) {
      __format = "Update rejected\r\n";
    }
    else {
      if (iVar1 != 2) {
        shadowUpdateInProgress = false;
        return;
      }
      __format = "Update accepted\r\n";
    }
  }
  printf(__format);
  return;
}



void windowActuate_Callback(char *pJsonString,uint32_t JsonStringDataLen,jsonStruct_t *pContext)

{
  if (pContext != (jsonStruct_t *)0x0) {
    printf("Delta - Window state changed to %d\r\n",(uint)*(byte *)pContext->pData);
    return;
  }
  return;
}


/*
Unable to decompile 'aws_main_entry'
Cause: Pcode: XML comms: Invalid storage: Unsupported varnode size: -1
*/


void cmd_coex_dump(char *buf,int len,int argc,char **argv)

{
  coex_dump_pta();
  coex_dump_wifi();
  return;
}



int codex_debug_cli_init(void)

{
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_rx_filter_set(void)

{
  _DAT_44b00060 = mm_env.rx_filter_lmac_enable | mm_env.rx_filter_umac;
  return;
}



int element_notify_status_enabled
              (cfg_element_entry *entry,void *arg1,void *arg2,CFG_ELEMENT_TYPE_OPS ops)

{
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void blmac_ap_setf(uint8_t ap)

{
  undefined3 in_register_00002029;
  
  _DAT_44b0004c = CONCAT31(in_register_00002029,ap) << 1 | _DAT_44b0004c & 0xfffffffd;
  return;
}



uchar ascii_to_hex(char asccode)

{
  char cVar1;
  byte bVar2;
  
  bVar2 = asccode - 0x30;
  if (9 < bVar2) {
    if ((byte)(asccode + 0x9fU) < 6) {
      cVar1 = -0x57;
    }
    else {
      if (5 < (byte)(asccode + 0xbfU)) {
        return '\0';
      }
      cVar1 = -0x37;
    }
    bVar2 = asccode + cVar1;
  }
  return (uchar)bVar2;
}



undefined4 element_notify_time_last_received_set(void)

{
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void blmac_encr_cntrl_pack
               (uint8_t newread,uint8_t newwrite,uint16_t keyindexram,uint8_t ctyperam,
               uint8_t vlanidram,uint8_t sppram,uint8_t usedefkeyram,uint8_t clenram)

{
  uint uVar1;
  undefined3 in_register_00002035;
  undefined3 in_register_00002039;
  undefined3 in_register_0000203d;
  undefined3 in_register_00002041;
  undefined3 in_register_00002045;
  uint uVar2;
  
  uVar2 = CONCAT31(in_register_00002039,vlanidram) << 4;
  if ((uVar2 & 0xffffff0f) != 0) {
    assert_err("(((uint32_t)vlanidram << 4) & ~((uint32_t)0x000000F0)) == 0","module",0x1873);
  }
  uVar1 = CONCAT31(in_register_0000203d,sppram) << 2;
  if ((uVar1 & 0xfffffff3) != 0) {
    assert_err("(((uint32_t)sppram << 2) & ~((uint32_t)0x0000000C)) == 0","module",0x1874);
  }
  _DAT_44b000c4 =
       (uint)newread << 0x1f | CONCAT31(in_register_00002045,clenram) |
       CONCAT31(in_register_00002041,usedefkeyram) << 1 | uVar1 | uVar2 |
       CONCAT31(in_register_00002035,ctyperam) << 8 | (uint)keyindexram << 0x10 |
       (uint)newwrite << 0x1e;
  return;
}



undefined4 element_notify_keepalive_received(void)

{
  return 0;
}



// WARNING: Removing unreachable block (ram,0x23001bd8)
// WARNING: Removing unreachable block (ram,0x23001be2)
// WARNING: Removing unreachable block (ram,0x23001c0a)
// WARNING: Removing unreachable block (ram,0x23001bfe)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t hal_machw_rx_duration(rx_hd *rhd,uint16_t len)

{
  if ((""[rhd->recvec1a >> 0xc & 0xf] & 0x80) != 0) {
    assert_err("(((uint32_t)ppdumcsindex << 0) & ~((uint32_t)0x0000007F)) == 0","module",0x1a99);
  }
  do {
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_env_max_ampdu_duration_set(void)

{
  mm_env.ampdu_max_dur[0] = 0x96;
  if (((_DAT_44b00200 >> 0xc & 0xffff) != 0) && ((_DAT_44b00200 >> 0xc & 0xffff) < 0x97)) {
    mm_env.ampdu_max_dur[0] = (uint16_t)(_DAT_44b00200 >> 0xc);
  }
  mm_env.ampdu_max_dur[1] = 0x96;
  if (((_DAT_44b00204 >> 0xc & 0xffff) != 0) && ((_DAT_44b00204 >> 0xc & 0xffff) < 0x97)) {
    mm_env.ampdu_max_dur[1] = (uint16_t)(_DAT_44b00204 >> 0xc);
  }
  mm_env.ampdu_max_dur[2] = 0x96;
  if (((_DAT_44b00208 >> 0xc & 0xffff) != 0) && ((_DAT_44b00208 >> 0xc & 0xffff) < 0x97)) {
    mm_env.ampdu_max_dur[2] = (uint16_t)(_DAT_44b00208 >> 0xc);
  }
  mm_env.ampdu_max_dur[3] = 0x96;
  if (((_DAT_44b0020c >> 0xc & 0xffff) != 0) && ((_DAT_44b0020c >> 0xc & 0xffff) < 0x97)) {
    mm_env.ampdu_max_dur[3] = (uint16_t)(_DAT_44b0020c >> 0xc);
  }
  mm_env.ampdu_max_dur[4] = mm_env.ampdu_max_dur[3];
  return;
}



void mm_env_init(void)

{
  memset(&mm_env,0,0x2c);
  mm_env._34_2_ = 0x101;
  mm_env._18_2_ = 0;
  mm_env.rx_filter_lmac_enable = 0;
  mm_env.rx_filter_umac = 0x7fffffde;
  mm_rx_filter_set();
  mm_env_max_ampdu_duration_set();
  return;
}



void mm_init(void)

{
  hal_machw_init();
  mm_env_init();
  vif_mgmt_init();
  sta_mgmt_init();
  td_init();
  ps_init();
  txl_cntrl_init();
  rxl_init();
  mm_timer_init();
  scan_init();
  chan_init();
  hal_dma_init();
  mm_bcn_init();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_active(void)

{
  _DAT_44b00038 = 0x30;
  ke_state_set(0,1);
  return;
}



void mm_reset(void)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  
  kVar1 = ke_state_get(0);
  if (CONCAT22(extraout_var,kVar1) == 1) {
    mm_active();
    return;
  }
  ke_state_set(0,0);
  return;
}


/*
Unable to decompile 'mm_tbtt_evt'
Cause: Exception while decompiling 23001d94: Decompiler process died

*/


// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t mm_sec_machwaddr_wr(uint8_t sta_idx,uint8_t inst_nbr)

{
  uint uVar1;
  undefined3 in_register_00002029;
  int iVar2;
  
  iVar2 = CONCAT31(in_register_00002029,sta_idx);
  uVar1 = iVar2 + 8U & 0xff;
  _DAT_44b000bc = *(undefined4 *)sta_info_tab[iVar2].mac_addr.array;
  _DAT_44b000c0 = (uint)sta_info_tab[iVar2].mac_addr.array[2];
  _DAT_44b000ac = 0;
  _DAT_44b000b0 = 0;
  _DAT_44b000b4 = 0;
  _DAT_44b000b8 = 0;
  blmac_encr_cntrl_pack('\0','\x01',(uint16_t)uVar1,'\0',inst_nbr,'\0','\x01','\0');
  do {
  } while (_DAT_44b000c4 << 1 < 0);
  return (uint8_t)uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_sec_keydump(void)

{
  uint uVar1;
  undefined *puVar2;
  int iVar3;
  
  uVar1 = _DAT_44b000d8;
  puts("==========================  Keyram Config ========================\r\n");
  printf("  start %02u -->> end %02u; nVAP %02u; max %02u\r\n",uVar1 & 0xff,uVar1 >> 8 & 0xff,
         uVar1 >> 0x10 & 0xff,uVar1 >> 0x18);
  puts("==========================  Keyram Dump =========================\r\n");
  uVar1 = _DAT_44b000d8 >> 8;
  puts("[id]   MAC Address     Key Len  VLan ID  Default      \tKey Hexdump(16Bytes MAX)\r\n");
  iVar3 = 0;
  while (iVar3 < (int)(uVar1 & 0xff)) {
    blmac_encr_cntrl_pack('\x01','\0',(uint16_t)iVar3,'\0','\0','\0','\0','\0');
    do {
    } while ((int)_DAT_44b000c4 < 0);
    printf("[%02d] %02X:%02X:%02X:%02X:%02X:%02X",iVar3,_DAT_44b000bc & 0xff,
           _DAT_44b000bc >> 8 & 0xff,_DAT_44b000bc >> 0x10 & 0xff,_DAT_44b000bc >> 0x18,
           _DAT_44b000c0 & 0xff,_DAT_44b000c0 >> 8 & 0xff);
    puVar2 = &UNK_230743ec;
    if ((_DAT_44b000c4 & 1) == 0) {
      puVar2 = &UNK_230743f4;
    }
    printf(" %s",puVar2);
    iVar3 = iVar3 + 1;
    printf("    %02u",_DAT_44b000c4 >> 4 & 0xf);
    printf("        %u",_DAT_44b000c4 >> 1 & 1);
    printf("     %02X%02X%02X%02X %02X%02X%02X%02X %02X%02X%02X%02X %02X%02X%02X%02X",
           _DAT_44b000ac & 0xff,_DAT_44b000ac >> 8 & 0xff,_DAT_44b000ac >> 0x10 & 0xff,
           _DAT_44b000ac >> 0x18,_DAT_44b000b0 & 0xff,_DAT_44b000b0 >> 8 & 0xff,
           _DAT_44b000b0 >> 0x10 & 0xff);
    puts("\r\n");
  }
  puts("==========================  MAC Address =========================\r\n");
  printf("    MAC %02X:%02X:%02X:%02X:%02X:%02X",_DAT_44b00010 & 0xff,_DAT_44b00010 >> 8 & 0xff,
         _DAT_44b00010 >> 0x10 & 0xff,_DAT_44b00010 >> 0x18,_DAT_44b00014 & 0xff,
         _DAT_44b00014 >> 8 & 0xff);
  printf(" Mask %02X:%02X:%02X:%02X:%02X:%02X",_DAT_44b00018 & 0xff,_DAT_44b00018 >> 8 & 0xff,
         _DAT_44b00018 >> 0x10 & 0xff,_DAT_44b00018 >> 0x18,_DAT_44b0001c & 0xff,
         _DAT_44b0001c >> 8 & 0xff);
  puts("\r\n");
  printf("  BSSID %02X:%02X:%02X:%02X:%02X:%02X",_DAT_44b00020 & 0xff,_DAT_44b00020 >> 8 & 0xff,
         _DAT_44b00020 >> 0x10 & 0xff,_DAT_44b00020 >> 0x18,_DAT_44b00024 & 0xff,
         _DAT_44b00024 >> 8 & 0xff);
  printf(" Mask %02X:%02X:%02X:%02X:%02X:%02X",_DAT_44b00028 >> 8 & 0xff,
         _DAT_44b00028 >> 0x10 & 0xff,_DAT_44b00028 >> 0x18,_DAT_44b0002c & 0xff,
         _DAT_44b0002c >> 8 & 0xff);
  puts("\r\n");
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t mm_sec_machwkey_wr(mm_key_add_req *param)

{
  byte bVar1;
  byte vlanidram;
  uint16_t keyindexram;
  uint uVar2;
  uint8_t ctyperam;
  uint8_t clenram;
  uint uVar3;
  
  bVar1 = param->sta_idx;
  uVar3 = (uint)bVar1;
  vlanidram = param->inst_nbr;
  if (bVar1 == 0xff) {
    uVar3 = (uint)vlanidram * 4 + (uint)param->key_idx & 0xff;
    keyindexram = (uint16_t)uVar3;
    _DAT_44b000bc = 0xffffffff;
    _DAT_44b000c0 = 0xffffffff;
    vif_mgmt_add_key(param,(uint8_t)uVar3);
  }
  else {
    if (0xb < bVar1) {
      assert_err("sta_idx < STA_MAX","module",0x3e4);
    }
    uVar2 = uVar3 + 8 & 0xff;
    keyindexram = (uint16_t)uVar2;
    sta_mgmt_add_key(param,(uint8_t)uVar2);
    _DAT_44b000bc = *(undefined4 *)sta_info_tab[uVar3].mac_addr.array;
    _DAT_44b000c0 = (uint)sta_info_tab[uVar3].mac_addr.array[2];
  }
  bVar1 = param->cipher_suite;
  if (bVar1 < 4) {
    clenram = *(uint8_t *)((int)&CSWTCH_22 + (uint)bVar1);
    ctyperam = *(uint8_t *)((int)&CSWTCH_23 + (uint)bVar1);
  }
  else {
    assert_err("0","module",0x429);
    ctyperam = '\0';
    clenram = '\x01';
  }
  _DAT_44b000ac = (param->key).array[0];
  _DAT_44b000b0 = (param->key).array[1];
  _DAT_44b000b4 = (param->key).array[2];
  _DAT_44b000b8 = (param->key).array[3];
  blmac_encr_cntrl_pack('\0','\x01',keyindexram,ctyperam,vlanidram,param->spp,'\0',clenram);
  do {
  } while (_DAT_44b000c4 << 1 < 0);
  return (uint8_t)keyindexram;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_sec_machwkey_del(uint8_t hw_key_idx)

{
  undefined3 in_register_00002029;
  uint uVar1;
  uint uVar2;
  
  uVar1 = CONCAT31(in_register_00002029,hw_key_idx);
  if (uVar1 < 8) {
    _DAT_44b000bc = 0xffffffff;
    _DAT_44b000c0 = 0xffffffff;
    vif_mgmt_del_key(vif_info_tab + ((int)uVar1 >> 2),hw_key_idx & 3);
  }
  else {
    uVar2 = uVar1 - 8 & 0xff;
    _DAT_44b000bc = *(undefined4 *)sta_info_tab[uVar2].mac_addr.array;
    _DAT_44b000c0 = (uint)sta_info_tab[uVar2].mac_addr.array[2];
    sta_mgmt_del_key(sta_info_tab + uVar2);
  }
  _DAT_44b000ac = 0;
  _DAT_44b000b0 = 0;
  _DAT_44b000b4 = 0;
  _DAT_44b000b8 = 0;
  blmac_encr_cntrl_pack('\0','\x01',(uint16_t)uVar1,'\0','\0','\0','\0','\0');
  do {
  } while (_DAT_44b000c4 << 1 < 0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_sec_machwaddr_del(uint8_t sta_idx)

{
  _DAT_44b000bc = 0xffffffff;
  _DAT_44b000c0 = 0xffffffff;
  _DAT_44b000ac = 0;
  _DAT_44b000b0 = 0;
  _DAT_44b000b4 = 0;
  _DAT_44b000b8 = 0;
  blmac_encr_cntrl_pack('\0','\x01',(ushort)sta_idx + 8 & 0xff,'\0','\0','\0','\0','\0');
  do {
  } while (_DAT_44b000c4 << 1 < 0);
  return;
}



void mm_hw_idle_evt(int dummy)

{
  ke_evt_clear(0x800000);
  ke_state_set(0,0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_hw_info_set(mac_addr *mac_addr)

{
  blmac_ap_setf('\0');
  _DAT_44b0001c = 0x100;
  _DAT_44b080a4 = 0;
  _DAT_44b080a8 = 0;
  _DAT_44b00010 = *(undefined4 *)mac_addr->array;
  _DAT_44b00014 = (uint)mac_addr->array[2];
  _DAT_44b0004c = _DAT_44b0004c & 0xfffff8ff | 1;
  mm_env.rx_filter_umac = 0x3503858c;
  mm_rx_filter_set();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_hw_ap_info_set(void)

{
  blmac_ap_setf('\x01');
  mm_env.rx_filter_umac = 0x3507a58c;
  mm_rx_filter_set();
  _DAT_44b08070 = 0x40001;
  _DAT_44b08074 = _DAT_44b08074 | 0x40001;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_hw_ap_info_reset(void)

{
  blmac_ap_setf('\0');
  mm_env.rx_filter_umac = 0x3503858c;
  mm_rx_filter_set();
  _DAT_44b08070 = 0x40001;
  _DAT_44b08074 = _DAT_44b08074 & 0xfffbfffe;
  return;
}



void mm_back_to_host_idle(void)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  
  kVar1 = ke_state_get(0);
  if (CONCAT22(extraout_var,kVar1) != 3) {
    assert_err("ke_state_get(TASK_MM) == MM_HOST_BYPASSED","module",0x52a);
  }
  if (mm_env.host_idle == '\0') {
    mm_active();
    return;
  }
  ke_state_set(0,0);
  return;
}


/*
Unable to decompile 'mm_force_idle_req'
Cause: Exception while decompiling 2300251e: Decompiler process died

*/


// WARNING: Type propagation algorithm not settling
// WARNING: Could not reconcile some variable overlaps

uint8_t mm_sta_add(mm_sta_add_req *param,uint8_t *sta_idx,uint8_t *hw_sta_idx)

{
  uint uVar1;
  uint8_t uVar2;
  uint8_t uVar3;
  uchar uVar4;
  uchar uVar5;
  undefined3 extraout_var;
  size_t sVar6;
  int security_mode;
  uint8_t *phrase;
  int iVar7;
  int iVar8;
  _Bool is_pmf_required;
  uint uVar9;
  undefined2 uStack92;
  mm_key_add_req key_add_req;
  
  uVar2 = sta_mgmt_register(param,sta_idx);
  if (CONCAT31(extraout_var,uVar2) != 0) {
    return uVar2;
  }
  uVar1 = (uint)param->inst_nbr;
  uVar3 = mm_sec_machwaddr_wr(*sta_idx,param->inst_nbr);
  *hw_sta_idx = uVar3;
  if (vif_info_tab[uVar1].type != '\0') {
    return uVar2;
  }
  if (vif_info_tab[uVar1].bss_info.is_supplicant_enabled == false) goto LAB_230025a4;
  sta_conn_info.staId = *sta_idx;
  if ((*(uint *)&vif_info_tab[uVar1].bss_info.is_supplicant_enabled & 0x12800) == 0) {
    if ((*(byte *)&vif_info_tab[uVar1].bss_info.wpa_wpa2_wep & 2) != 0) {
      sVar6 = strlen((char *)(sm_env.connect_param)->phrase);
      printf("wep:len:%d,password:%s\n",sVar6,(sm_env.connect_param)->phrase);
      memset(&uStack92,0,0x2c);
      key_add_req.key.array[7]._1_1_ = param->inst_nbr;
      uStack92 = 0xff00;
      sVar6 = strlen((char *)(sm_env.connect_param)->phrase);
      uVar9 = sVar6 & 0xff;
      key_add_req.key_idx = (uint8_t)uVar9;
      if (uVar9 == 5) {
        key_add_req.key.array[7]._0_1_ = '\0';
LAB_230026d8:
        memcpy(&key_add_req.key,(sm_env.connect_param)->phrase,sVar6 & 0xff);
      }
      else {
        if (uVar9 == 0xd) {
          key_add_req.key.array[7]._0_1_ = '\x03';
          goto LAB_230026d8;
        }
        if (uVar9 == 10) {
          key_add_req.key.array[7]._0_1_ = '\0';
        }
        else {
          if (uVar9 != 0x1a) {
            printf("password length is not correct for wep\n");
            sta_mgmt_unregister(*sta_idx);
            return '\x01';
          }
          key_add_req.key.array[7]._0_1_ = '\x03';
        }
        uVar9 = sVar6 & 0xff;
        if ((sVar6 & 1) != 0) {
          uVar9 = sVar6 & 0xfe;
        }
        if (uVar9 != 0) {
          iVar7 = 0;
          phrase = (sm_env.connect_param)->phrase;
          do {
            uVar4 = ascii_to_hex(*phrase);
            uVar5 = ascii_to_hex(phrase[1]);
            (&key_add_req.key.length)[iVar7 >> 1] = uVar4 * '\x10' + uVar5;
            iVar7 = iVar7 + 2;
            phrase = phrase + 2;
          } while (iVar7 < (int)uVar9);
        }
        key_add_req.key_idx = key_add_req.key_idx >> 1;
      }
      wep_hw_keyid = mm_sec_machwkey_wr((mm_key_add_req *)&uStack92);
    }
  }
  else {
    if ((sm_env.connect_param)->phrase_pmk[0] == '\0') {
      phrase = (sm_env.connect_param)->phrase;
    }
    else {
      phrase = (sm_env.connect_param)->phrase_pmk;
    }
    set_psk((char *)vif_info_tab[uVar1].bss_info.ssid.array,vif_info_tab[uVar1].bss_info.ssid.length
            ,(char *)phrase);
  }
  iVar7 = uVar1 * 0x5d8;
  if ((*(uint *)&vif_info_tab[uVar1].bss_info.is_supplicant_enabled & 0x12000) == 0) {
    if ((*(byte *)&vif_info_tab[uVar1].bss_info.wpa_wpa2_wep & 8) != 0) {
      iVar8 = iVar7 + 0x3ec;
      iVar7 = iVar7 + 0x3eb;
      is_pmf_required = vif_info_tab[uVar1].bss_info.is_pmf_required;
      security_mode = 3;
      goto LAB_2300263a;
    }
  }
  else {
    is_pmf_required = vif_info_tab[uVar1].bss_info.is_pmf_required;
    iVar8 = iVar7 + 0x3ee;
    iVar7 = iVar7 + 0x3ed;
    security_mode = 4;
LAB_2300263a:
    supplicantEnable(&sta_conn_info,security_mode,
                     (void *)((int)&vif_info_tab[0].list_hdr.next + iVar7),
                     (void *)((int)&vif_info_tab[0].list_hdr.next + iVar8),is_pmf_required);
  }
  if (vif_info_tab[uVar1].type != '\0') {
    return uVar2;
  }
LAB_230025a4:
  vif_info_tab[uVar1].u[4] = *sta_idx;
  return '\0';
}



void mm_sta_del(uint8_t sta_idx)

{
  uint uVar1;
  undefined3 in_register_00002029;
  undefined *puVar2;
  byte bVar3;
  uint uVar4;
  
  uVar4 = (uint)sta_info_tab[CONCAT31(in_register_00002029,sta_idx)].inst_nbr;
  if (vif_info_tab[uVar4].type == '\0') {
    vif_info_tab[uVar4].u[4] = 0xff;
    if (vif_info_tab[uVar4].bss_info.is_supplicant_enabled != false) {
      if ((*(uint *)&vif_info_tab[uVar4].bss_info.is_supplicant_enabled & 0x12800) == 0) {
        if (((*(byte *)&vif_info_tab[uVar4].bss_info.wpa_wpa2_wep & 2) != 0) && (wep_hw_keyid != -1)
           ) {
          mm_sec_machwkey_del(wep_hw_keyid);
        }
      }
      else {
        mm_sec_machwkey_del(sta_conn_info.ptkHwKeyId);
        mm_sec_machwkey_del(sta_conn_info.gtkHwKeyId);
        mm_sec_machwkey_del(sta_conn_info.mfpHwKeyId);
        supplicantDisable(&sta_conn_info);
        memset(&(sta_conn_info.suppData)->hashSsId,0,0x22);
        remove_psk((char *)vif_info_tab[uVar4].bss_info.ssid.array,
                   vif_info_tab[uVar4].bss_info.ssid.length);
      }
      vif_info_tab[uVar4].bss_info.is_supplicant_enabled = false;
    }
  }
  else {
    if ((sta_info_tab[CONCAT31(in_register_00002029,sta_idx)].ps_state == '\x01') &&
       (bVar3 = vif_info_tab[uVar4].u[0x2ee] - 1, vif_info_tab[uVar4].u[0x2ee] = bVar3, bVar3 == 0))
    {
      uVar1 = (uint)vif_info_tab[uVar4].index + 10 & 0xff;
      puVar2 = (undefined *)ke_msg_alloc(0x49,0xd,0,2);
      sta_info_tab[uVar1].ps_state = '\0';
      *puVar2 = (char)uVar1;
      puVar2[1] = 0;
      ke_msg_send();
      apm_tx_int_ps_clear(vif_info_tab + uVar4,vif_info_tab[uVar4].index + '\n');
    }
  }
  mm_sec_machwaddr_del(sta_idx);
  sta_mgmt_unregister(sta_idx);
  return;
}



void mm_cfg_element_keepalive_timestamp_update(void)

{
  mm_env.keep_alive_time_last_received = xTaskGetTickCount();
  mm_env.keep_alive_packet_counter = mm_env.keep_alive_packet_counter + 1;
  return;
}



void mm_send_connection_loss_ind(vif_info_tag *p_vif_entry)

{
  uint8_t *puVar1;
  
  puVar1 = (uint8_t *)ke_msg_alloc(0x43,6,0,1);
  *puVar1 = p_vif_entry->index;
  ke_msg_send();
  return;
}



void mm_ap_probe_cfm(void *env,uint32_t status)

{
  if ((int)(status << 8) < 0) {
    *(undefined *)((int)env + 0x74) = 0;
    return;
  }
  mm_send_connection_loss_ind((vif_info_tag *)env);
  return;
}



// WARNING: Variable defined which should be unmapped: cur_us
// WARNING: Could not reconcile some variable overlaps

void mm_check_rssi(vif_info_tag *vif_entry,int8_t rssi)

{
  byte bVar1;
  uint8_t uVar2;
  int iVar3;
  uint8_t *puVar4;
  undefined3 in_register_0000202d;
  int iVar5;
  uint uVar6;
  bool bVar7;
  int iVar8;
  uint uStack40;
  longlong cur_us;
  
  iVar5 = CONCAT31(in_register_0000202d,rssi);
  iVar8 = (int)(char)vif_entry->u[0x19];
  iVar3 = (int)(char)vif_entry->u[0x1a];
  bVar1 = vif_entry->u[0x1b];
  bVar7 = (bool)vif_entry->u[0x1c];
  vif_entry->u[0x19] = rssi;
  uStack40 = 0;
  cur_us._0_4_ = 0;
  bl60x_current_time_us((longlong *)&uStack40);
  if (iVar8 != 0) {
    uVar6 = (uint)(uStack40 < uStack40 - (uint)last_us);
    if (((int)(((int)cur_us - last_us._4_4_) - uVar6) < 1) &&
       (((int)cur_us - last_us._4_4_ != uVar6 || (uStack40 - (uint)last_us < 0x1e8481))))
    goto LAB_230029d6;
  }
  puVar4 = (uint8_t *)ke_msg_alloc(0x57,0xd,0,3);
  uVar2 = vif_entry->index;
  *(bool *)(puVar4 + 1) = bVar7;
  puVar4[2] = rssi;
  *puVar4 = uVar2;
  last_us._0_4_ = uStack40;
  last_us._4_4_ = (int)cur_us;
  ke_msg_send();
LAB_230029d6:
  if (iVar3 != 0) {
    if (bVar7 == false) {
      if (iVar5 < iVar8) {
        bVar7 = iVar5 < iVar3 - (char)bVar1;
      }
    }
    else {
      if (iVar8 < iVar5) {
        bVar7 = iVar5 <= iVar3 + (char)bVar1;
      }
    }
    if ((bool)vif_entry->u[0x1c] != bVar7) {
      puVar4 = (uint8_t *)ke_msg_alloc(0x57,0xd,0,3);
      uVar2 = vif_entry->index;
      *(bool *)(puVar4 + 1) = bVar7;
      puVar4[2] = rssi;
      *puVar4 = uVar2;
      ke_msg_send();
    }
    *(bool *)(vif_entry->u + 0x1c) = bVar7;
  }
  return;
}



void mm_send_csa_traffic_ind(uint8_t vif_index,_Bool enable)

{
  uint8_t *puVar1;
  
  puVar1 = (uint8_t *)ke_msg_alloc(0x59,0xd,0,2);
  *puVar1 = vif_index;
  *(_Bool *)(puVar1 + 1) = enable;
  ke_msg_send();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint mm_check_beacon(rx_hd *param_1,vif_info_tag *param_2,int param_3,char **param_4)

{
  ushort len;
  ushort uVar1;
  ushort uVar2;
  uint uVar3;
  int iVar4;
  uint8_t uVar5;
  undefined3 extraout_var;
  uint32_t crc;
  uint32_t uVar6;
  uint32_t uVar7;
  uint uVar8;
  uint uVar9;
  char *pcVar10;
  uint uVar11;
  int iVar12;
  int iVar13;
  uint len_00;
  int iVar14;
  uint uVar15;
  
  len = param_1->frmlen;
  iVar13 = *(int *)(param_1->first_pbd_ptr + 8);
  param_2->u[0x18] = 0;
  beacon_rx_count = beacon_rx_count + 1;
  iVar14 = *(int *)(param_2->u + 0x14);
  if (param_2->u[0x1e] != 0) {
    mm_send_csa_traffic_ind(param_2->index,true);
    param_2->u[0x1e] = 0;
  }
  if ((((30000000 - _DAT_44b00120) + *(int *)(param_2->u + 0x10) < 0) &&
      (mm_env.keep_alive_status_enabled != false)) &&
     (uVar5 = txl_frame_send_null_frame(param_2->u[4],(cfm_func_ptr *)0x0,(void *)0x0),
     CONCAT31(extraout_var,uVar5) == 0)) {
    *(int *)(param_2->u + 0x10) = _DAT_44b00120;
  }
  uVar3 = (uint)len - 0x24;
  mm_check_rssi(param_2,*(int8_t *)((int)&param_1->recvec1c + 3));
  crc = co_crc32(iVar13 + 0x20,4,0);
  pcVar10 = (char *)(iVar13 + 0x24);
  *param_4 = (char *)0x0;
  while (uVar3 = uVar3 & 0xffff, 1 < uVar3) {
    len_00 = (uint)(byte)pcVar10[1];
    if (uVar3 <= len_00 + 1) break;
    if (*pcVar10 == '\x05') {
      *param_4 = pcVar10;
    }
    else {
      crc = co_crc32((uint32_t)(pcVar10 + 2),len_00,crc);
    }
    uVar3 = uVar3 + (-2 - len_00);
    pcVar10 = pcVar10 + 2 + len_00;
  }
  *(uint32_t *)(param_2->u + 0x14) = crc;
  uVar1 = *(ushort *)(param_3 + 0x16);
  uVar2 = *(ushort *)(iVar13 + 0x20);
  uVar3 = *(uint *)(iVar13 + 0x18);
  crc = param_1->tsflo;
  iVar4 = (uint)uVar2 * 0x400;
  iVar13 = *(int *)(iVar13 + 0x1c);
  len_00 = (uint)*(ushort *)param_2->u;
  if (*(ushort *)param_2->u == 0) {
    pcVar10 = *param_4;
    len_00 = 1;
    if ((pcVar10 != (char *)0x0) && (len_00 = (uint)(byte)pcVar10[2], pcVar10[2] == 0)) {
      len_00 = (uint)(byte)pcVar10[3];
    }
  }
  uVar6 = hal_machw_rx_duration(param_1,len);
  uVar7 = hal_machw_rx_duration(param_1,0x18);
  uVar8 = uVar3;
  iVar12 = iVar13;
  __udivdi3();
  uVar11 = uVar3 - uVar7;
  uVar15 = iVar13 - (uint)(uVar3 < uVar11);
  uVar9 = iVar12 * iVar4 + (int)((ulonglong)uVar8 * (ulonglong)uVar2 * 0x400 >> 0x20);
  if ((uVar9 < uVar15) || ((uVar15 == uVar9 && (uVar8 * iVar4 < uVar11)))) {
    uVar11 = uVar8 * iVar4;
  }
  iVar12 = ((uVar11 + len_00 * iVar4) - ((uVar3 - crc) + (uVar6 - uVar7))) - uVar1 * len_00;
  iVar13 = iVar12 + -400;
  if (iVar12 + (-0xc80 - _DAT_44b00120) < 0) {
    iVar13 = iVar13 + iVar4;
  }
  crc = (_DAT_44b00120 - _DAT_44b080a4) + iVar13;
  if (crc != (param_2->tbtt_timer).time) {
    mm_timer_set(&param_2->tbtt_timer,crc);
  }
  return (uint)(*(int *)(param_2->u + 0x14) != iVar14);
}



void mm_sta_tbtt(void *env)

{
  uint32_t value;
  _Bool _Var1;
  undefined3 extraout_var;
  byte bVar2;
  
  if (*(char *)((int)env + 0x58) == '\0') {
    return;
  }
  if (*(char *)((int)env + 0x79) != '\0') {
    bVar2 = *(char *)((int)env + 0x79) - 1;
    *(byte *)((int)env + 0x79) = bVar2;
    if (bVar2 < 2) {
      vif_mgmt_switch_channel((vif_info_tag *)env);
      return;
    }
    if (bVar2 == 2) {
      mm_send_csa_traffic_ind(*(uint8_t *)((int)env + 0x57),false);
    }
  }
  value = sta_info_tab[*(byte *)((int)env + 0x60)].bcn_int + *(int *)((int)env + 0x24);
  mm_timer_set((mm_timer_tag *)((int)env + 0x18),value);
  vif_mgmt_bcn_to_prog((vif_info_tag *)env);
  chan_tbtt_switch_update((vif_info_tag *)env,value);
  _Var1 = chan_is_on_channel((vif_info_tag *)env);
  if (CONCAT31(extraout_var,_Var1) != 0) {
    *(uint *)((int)env + 4) = *(uint *)((int)env + 4) | 1;
    bVar2 = *(char *)((int)env + 0x74) + 1;
    *(byte *)((int)env + 0x74) = bVar2;
    if (100 < bVar2) {
      txl_frame_send_null_frame(*(uint8_t *)((int)env + 0x60),mm_ap_probe_cfm,env);
      return;
    }
    if (bVar2 == 100) {
      chan_bcn_detect_start((vif_info_tag *)env);
      return;
    }
  }
  return;
}



uint16_t mm_get_rsn_wpa_ie(uint8_t sta_id,uint8_t *wpa_ie)

{
  undefined3 in_register_00002029;
  uint uVar1;
  
  uVar1 = (uint)sta_info_tab[CONCAT31(in_register_00002029,sta_id)].inst_nbr;
  memcpy(wpa_ie,vif_info_tab[uVar1].bss_info.rsn_wpa_ie,
         (uint)vif_info_tab[uVar1].bss_info.rsn_wpa_ie_len);
  return (uint16_t)(ushort)vif_info_tab[uVar1].bss_info.rsn_wpa_ie_len;
}



void mm_tim_update_proceed(ushort *param_1)

{
  byte bVar1;
  ushort uVar2;
  uint uVar3;
  uint8_t *puVar4;
  uint uVar5;
  int iVar6;
  uint uVar7;
  int iVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  byte *pbVar12;
  
  uVar2 = *param_1;
  uVar9 = (uint)*(byte *)((int)param_1 + 3);
  if (uVar2 == 0) {
    if (*(char *)(param_1 + 1) == '\0') {
      vif_info_tab[uVar9].u[0x2ea] = 0;
    }
    else {
      vif_info_tab[uVar9].u[0x2ea] = 1;
    }
  }
  else {
    iVar8 = uVar9 * 8;
    uVar10 = (uint)(uVar2 >> 3);
    uVar11 = uVar10 & 0xff;
    puVar4 = txl_tim_bitmap_pool + uVar9 * 0xfc;
    pbVar12 = puVar4 + uVar11;
    bVar1 = *pbVar12;
    uVar7 = 1 << ((uint)uVar2 & 7);
    uVar5 = uVar7 & 0xff;
    uVar3 = uVar5 & bVar1;
    if (*(char *)(param_1 + 1) == '\0') {
      if (uVar3 != 0) {
        *pbVar12 = ~(byte)uVar7 & bVar1;
        uVar3 = (uint)*(ushort *)(vif_info_tab[uVar9].u + 0x2e0) - 1;
        *(short *)(vif_info_tab[uVar9].u + 0x2e0) = (short)(uVar3 * 0x10000 >> 0x10);
        if ((uVar3 & 0xffff) == 0) {
          *(undefined2 *)(vif_info_tab[uVar9].u + 0x2de) = 6;
          *(undefined2 *)(vif_info_tab[uVar9].u + 0x2e8) = 0xff;
          bVar1 = vif_info_tab[uVar9].u[0x2de];
          txl_tim_ie_pool[iVar8 + 4] = '\0';
          txl_tim_ie_pool[iVar8 + 1] = bVar1 - 2;
          txl_tim_desc[uVar9 * 2].dataendptr = iVar8 + 0x42047365;
          *(tx_pbd **)&txl_tim_desc[uVar9 * 2].next = txl_bcn_end_desc + *(byte *)((int)param_1 + 3)
          ;
          *(uint8_t **)&txl_tim_desc[uVar9 * 2 + 1].dataendptr =
               puVar4 + vif_info_tab[uVar9].u[0x2e9];
        }
        else {
          if ((uint)vif_info_tab[uVar9].u[0x2e8] == (uVar10 & 0xfe)) {
            while( true ) {
              bVar1 = vif_info_tab[uVar9].u[0x2e8];
              if ((bVar1 == 0xfb) || (puVar4[(uint)bVar1] != '\0')) break;
              vif_info_tab[uVar9].u[0x2e8] = bVar1 + 1;
            }
            uVar3 = (uint)bVar1 & 0xfe;
            vif_info_tab[uVar9].u[0x2e8] = (byte)uVar3;
            *(uint8_t **)&txl_tim_desc[uVar9 * 2 + 1].datastartptr = puVar4 + uVar3;
          }
          if ((uint)vif_info_tab[uVar9].u[0x2e9] == uVar11) {
            while( true ) {
              bVar1 = vif_info_tab[uVar9].u[0x2e9];
              if ((bVar1 == 0) || (puVar4[bVar1] != '\0')) break;
              vif_info_tab[uVar9].u[0x2e9] = bVar1 - 1;
            }
            *(uint8_t **)&txl_tim_desc[uVar9 * 2 + 1].dataendptr = puVar4 + bVar1;
          }
          iVar6 = (((uint)vif_info_tab[uVar9].u[0x2e9] + 6) - (uint)vif_info_tab[uVar9].u[0x2e8]) *
                  0x10000;
          *(short *)(vif_info_tab[uVar9].u + 0x2de) = (short)((uint)iVar6 >> 0x10);
          txl_tim_ie_pool[iVar8 + 1] = (char)((uint)iVar6 >> 0x10) + -2;
          txl_tim_ie_pool[iVar8 + 4] = vif_info_tab[uVar9].u[0x2e8];
        }
      }
    }
    else {
      if (uVar3 == 0) {
        *pbVar12 = (byte)uVar5 | bVar1;
        bVar1 = vif_info_tab[uVar9].u[0x2e8];
        *(short *)(vif_info_tab[uVar9].u + 0x2e0) = *(short *)(vif_info_tab[uVar9].u + 0x2e0) + 1;
        if (uVar11 < bVar1) {
          vif_info_tab[uVar9].u[0x2e8] = (byte)(uVar10 & 0xfe);
          *(uint8_t **)&txl_tim_desc[uVar9 * 2 + 1].datastartptr = puVar4 + (uVar10 & 0xfe);
        }
        if (vif_info_tab[uVar9].u[0x2e9] < uVar11) {
          vif_info_tab[uVar9].u[0x2e9] = (byte)uVar11;
          *(byte **)&txl_tim_desc[uVar9 * 2 + 1].dataendptr = pbVar12;
        }
        iVar6 = (((uint)vif_info_tab[uVar9].u[0x2e9] + 6) - (uint)vif_info_tab[uVar9].u[0x2e8]) *
                0x10000;
        *(short *)(vif_info_tab[uVar9].u + 0x2de) = (short)((uint)iVar6 >> 0x10);
        txl_tim_ie_pool[iVar8 + 1] = (char)((uint)iVar6 >> 0x10) + -2;
        txl_tim_ie_pool[iVar8 + 4] = vif_info_tab[uVar9].u[0x2e8];
        txl_tim_desc[uVar9 * 2].dataendptr = iVar8 + 0x42047364;
        txl_tim_desc[uVar9 * 2].next = uVar9 * 0x28 + 0x42047aa4;
      }
    }
  }
  ke_msg_send_basic(0x42,param_1[-2],0);
  ke_msg_free(param_1 + -6);
  return;
}



void mm_bcn_init(void)

{
  memset(&mm_bcn_env,0,0x24);
  mm_bcn_env.dma.dma_desc = &bcn_dwnld_desc;
  mm_bcn_env.dma.cb = mm_bcn_updated;
  co_list_init(&mm_bcn_env.tim_list);
  return;
}



void mm_bcn_init_vif(vif_info_tag *vif_entry)

{
  byte bVar1;
  tx_pbd *ptVar2;
  uint uVar3;
  int iVar4;
  
  uVar3 = (uint)vif_entry->index;
  txl_frame_init_desc((txl_frame_desc_tag *)(vif_entry->u + 4),
                      (txl_buffer_tag *)(txl_bcn_pool + uVar3 * 0xd3),txl_bcn_hwdesc_pool + uVar3,
                      txl_bcn_buf_ctrl + uVar3);
  txl_bcn_hwdesc_pool[uVar3].cfm_ptr = txl_bcn_hwdesc_cfms + vif_entry->index;
  uVar3 = (uint)vif_entry->index;
  iVar4 = uVar3 * 8;
  vif_entry->u[0x2e7] = 0;
  *(undefined2 *)(vif_entry->u + 0x2e0) = 0;
  vif_entry->u[0x2ea] = 0;
  *(undefined2 *)(vif_entry->u + 0x2de) = 6;
  *(undefined2 *)(vif_entry->u + 0x2e8) = 0xff;
  txl_tim_desc[uVar3 * 2].dataendptr = iVar4 + 0x42047365;
  txl_tim_desc[uVar3 * 2].upatterntx = 0xcafefade;
  *(uint8_t **)&txl_tim_desc[uVar3 * 2].datastartptr = txl_tim_ie_pool + iVar4;
  txl_tim_desc[uVar3 * 2].bufctrlinfo = 0;
  ptVar2 = txl_bcn_end_desc + uVar3;
  *(tx_pbd **)&txl_tim_desc[uVar3 * 2].next = ptVar2;
  txl_tim_ie_pool[iVar4] = '\x05';
  txl_tim_ie_pool[iVar4 + 1] = '\x04';
  bVar1 = vif_entry->u[0x2e7];
  txl_tim_ie_pool[iVar4 + 4] = '\0';
  txl_tim_ie_pool[iVar4 + 2] = bVar1;
  txl_tim_ie_pool[iVar4 + 3] = '\x01';
  txl_tim_ie_pool[iVar4 + 5] = -1;
  txl_tim_desc[uVar3 * 2 + 1].upatterntx = 0xcafefade;
  bVar1 = vif_entry->u[0x2e9];
  *(tx_pbd **)&txl_tim_desc[uVar3 * 2 + 1].next = ptVar2;
  *(uint8_t **)&txl_tim_desc[uVar3 * 2 + 1].dataendptr = txl_tim_bitmap_pool + uVar3 * 0xfc + bVar1;
  memset(txl_tim_bitmap_pool + uVar3 * 0xfc,0,0xfc);
  ptVar2->upatterntx = 0xcafefade;
  txl_bcn_end_desc[uVar3].next = 0;
  txl_bcn_end_desc[uVar3].bufctrlinfo = 0;
  iVar4 = *(int *)(vif_entry->u + 0x70);
  *(undefined4 *)(iVar4 + 0x24) = 0;
  *(undefined4 *)(iVar4 + 0x3c) = 0;
  *(undefined4 *)(iVar4 + 0x10) = 0;
  *(undefined4 *)(vif_entry->u + 0x2d0) = 0x2300362e;
  *(vif_info_tag **)(vif_entry->u + 0x2d4) = vif_entry;
  return;
}



void mm_tim_update(mm_tim_update_req *param)

{
  if (mm_bcn_env.tx_cfm != 0) {
    co_list_push_back(&mm_bcn_env.tim_list,(co_list_hdr *)(param + -3));
    return;
  }
  mm_tim_update_proceed();
  return;
}



// WARNING: Type propagation algorithm not settling

void mm_bcn_transmit(void)

{
  byte bVar1;
  uint8_t uVar2;
  uint8_t uVar3;
  vif_info_tag *vif;
  txl_frame_desc_tag *frame;
  _Bool _Var4;
  undefined3 extraout_var;
  char *pcVar5;
  undefined3 extraout_var_00;
  uint8_t *puVar6;
  int iVar7;
  byte bVar8;
  uint uVar9;
  char cVar10;
  int iVar11;
  
  vif = (vif_info_tag *)vif_mgmt_env.used_list.first;
  if (mm_bcn_env.tx_cfm != 0) {
    assert_err("!mm_bcn_env.tx_cfm","module",0x339);
  }
  if (mm_bcn_env.update_ongoing == false) {
    mm_bcn_env.tx_pending = false;
    while (vif != (vif_info_tag *)0x0) {
      if (((vif->type == '\x02') && (*(char *)((int)vif->u + 0x2e6) != '\0')) &&
         (*(char *)((int)vif->u + 0x2e5) == *(char *)((int)vif->u + 0x2e4))) {
        iVar7 = *(int *)((int)vif->u + 0x70);
        iVar11 = (uint)vif->index * 8;
        bVar1 = txl_tim_ie_pool[iVar11 + 4];
        *(int *)(iVar7 + 0x1c) =
             (uint)*(ushort *)((int)vif->u + 0x2dc) + (uint)*(ushort *)((int)vif->u + 0x2de) + 4;
        uVar9 = (uint)txl_cntrl_env.seqnbr;
        frame = (txl_frame_desc_tag *)((int)vif->u + 4);
        txl_cntrl_env.seqnbr = (uint16_t)((uVar9 + 1) * 0x10000 >> 0x10);
        *(undefined2 *)(*(int *)(iVar7 + 0x14) + 0x16) = (short)((uVar9 + 1 & 0xffff) << 4);
        uVar2 = *(uint8_t *)((int)vif->u + 0x2e7);
        txl_tim_ie_pool[iVar11 + 2] = uVar2;
        if (uVar2 == '\0') {
          if ((*(char *)((int)vif->u + 0x2ea) != '\0') ||
             (bVar8 = bVar1 & 0xfe, ipc_emb_env.txdesc[ipc_emb_env.txdesc_idx & 3].ready != 0)) {
            bVar8 = bVar1 | 1;
          }
          *(uint8_t *)((int)vif->u + 0x2e7) = txl_tim_ie_pool[iVar11 + 3];
        }
        else {
          bVar8 = bVar1 & 0xfe;
          if ((*(byte *)((int)vif->u + 0x2ea) & 2) != 0) {
            bVar8 = bVar1 | 1;
          }
        }
        txl_tim_ie_pool[iVar11 + 4] = bVar8 | 1;
        *(char *)((int)vif->u + 0x2e7) = *(char *)((int)vif->u + 0x2e7) + -1;
        cVar10 = *(char *)((int)vif->u + 0x2eb);
        if (cVar10 != '\0') {
          bVar1 = *(byte *)((int)vif->u + 0x2ec);
          cVar10 = cVar10 + -1;
          *(char *)((int)vif->u + 0x2eb) = cVar10;
          if (bVar1 != 0) {
            *(char *)(*(int *)(iVar7 + 0x14) + (uint)bVar1) = cVar10;
            bVar1 = *(byte *)((int)vif->u + 0x2ed);
            if (bVar1 != 0) {
              *(undefined *)(*(int *)(iVar7 + 0x14) + (uint)bVar1) =
                   *(undefined *)((int)vif->u + 0x2eb);
            }
          }
          uVar2 = *(uint8_t *)((int)vif->u + 0x2eb);
          if (uVar2 != '\0') {
            uVar3 = vif->index;
            puVar6 = (uint8_t *)ke_msg_alloc(0x4e,0xd,0,2);
            *puVar6 = uVar3;
            puVar6[1] = uVar2;
            ke_msg_send();
            if (*(char *)((int)vif->u + 0x2eb) != '\0') goto LAB_230033a6;
          }
          *(undefined *)((int)vif->u + 0x2eb) = 1;
        }
LAB_230033a6:
        tpc_update_frame_tx_power(vif,frame);
        _Var4 = chan_is_on_operational_channel(vif);
        if (CONCAT31(extraout_var,_Var4) != 0) {
          uVar2 = vif->index;
          pcVar5 = (char *)ke_msg_alloc(0x4a,0xd,0,3);
          *pcVar5 = uVar2 + '\n';
          pcVar5[1] = '\0';
          pcVar5[2] = '\0';
          ke_msg_send();
          *(uint8_t *)((int)vif->u + 0x33) = vif->index;
          *(undefined *)((int)vif->u + 0x34) = 0xff;
          _Var4 = txl_frame_push(frame,'\x04');
          if (CONCAT31(extraout_var_00,_Var4) != 0) {
            mm_bcn_env.tx_cfm = mm_bcn_env.tx_cfm + 1;
          }
          iVar7 = (uint)vif->index + 10;
          if ((sta_info_tab[iVar7].traffic_avail & PS_TRAFFIC_INT) != 0) {
            sta_info_tab[iVar7].ps_service_period = 9;
            sta_mgmt_send_postponed_frame(vif,sta_info_tab + iVar7,0);
            sta_info_tab[iVar7].ps_service_period = 0;
          }
        }
      }
      vif = *(vif_info_tag **)&vif->list_hdr;
    }
  }
  else {
    mm_bcn_env.tx_pending = true;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_bcn_updated(void *env,int dma_queue)

{
  ushort uVar1;
  ushort uVar2;
  mm_bcn_change_req *pmVar3;
  int iVar4;
  uint32_t uVar5;
  int iVar6;
  txl_buffer_control *ptVar7;
  mm_bcn_change_req *mem_ptr;
  int iVar8;
  uint uVar9;
  int iVar10;
  
  mem_ptr = mm_bcn_env.param + -1;
  ke_msg_send_basic(0x40,*(ke_task_id_t *)&mm_bcn_env.param[-1].tim_len,0);
  pmVar3 = mm_bcn_env.param;
  uVar9 = (uint)*(byte *)((int)env + 0x57);
  iVar4 = *(int *)((int)env + 0xcc);
  uVar1 = (mm_bcn_env.param)->tim_oft;
  iVar10 = (uint)(mm_bcn_env.param)->bcn_len - (uint)(mm_bcn_env.param)->tim_len;
  iVar8 = *(int *)(iVar4 + 0x14);
  *(undefined2 *)((int)env + 0x338) = (short)iVar10;
  me_beacon_check(*(byte *)((int)env + 0x57),pmVar3->bcn_len,*(uint32_t *)(iVar4 + 0x14));
  iVar6 = *(int *)(iVar4 + 0x14) + ((uint)pmVar3->tim_oft - 1);
  *(int *)(iVar4 + 0x18) = iVar6;
  uVar5 = (uint)pmVar3->tim_len + 1 + iVar6;
  txl_bcn_end_desc[uVar9].datastartptr = uVar5;
  uVar2 = pmVar3->tim_oft;
  txl_bcn_end_desc[uVar9].bufctrlinfo = 0;
  txl_bcn_end_desc[uVar9].dataendptr = ~(uint)uVar2 + iVar10 + uVar5;
  if (*(char *)(*(int *)((int)env + 0x40) + 4) == '\0') {
    ptVar7 = &txl_buffer_control_24G;
  }
  else {
    ptVar7 = &txl_buffer_control_5G;
  }
  *(uint *)(ptVar7->field_0 + 0x24) = _DAT_44b000a0 & 0xff;
  *(txl_buffer_control **)(iVar4 + 0x28) = ptVar7;
  *(undefined4 *)(iVar4 + 0x24) = 0;
  *(undefined4 *)(iVar4 + 0x3c) = 0;
  *(tx_pbd **)(iVar4 + 0x10) = txl_tim_desc + (uint)*(byte *)((int)env + 0x57) * 2;
  *(undefined *)((int)env + 0x342) = 1;
  txl_tim_ie_pool[uVar9 * 8 + 3] = *(uint8_t *)(iVar8 + (uint)uVar1 + 3);
  pmVar3 = mm_bcn_env.param;
  *(undefined *)((int)env + 0x347) = 0;
  *(uint8_t *)((int)env + 0x348) = pmVar3->csa_oft[0];
  *(uint8_t *)((int)env + 0x349) = pmVar3->csa_oft[1];
  if (pmVar3->csa_oft[0] != 0) {
    *(char *)((int)env + 0x347) =
         *(char *)(*(int *)(*(int *)((int)env + 0xcc) + 0x14) + (uint)pmVar3->csa_oft[0]) + '\x01';
  }
  mm_bcn_env.update_ongoing = false;
  if (mm_bcn_env.tx_pending != false) {
    mm_bcn_transmit();
  }
  mm_bcn_env.param = (mm_bcn_change_req *)0x0;
  ke_msg_free(mem_ptr);
  return;
}



void mm_bcn_update(mm_bcn_change_req *param)

{
  byte bVar1;
  
  bVar1 = param->inst_nbr;
  memcpy(txl_bcn_pool + (uint)bVar1 * 0xd3 + 0x53,param + 1,(uint)param->bcn_len);
  mm_bcn_env.update_pending = false;
  mm_bcn_env.update_ongoing = true;
  mm_bcn_updated(vif_info_tab + (uint)bVar1,0);
  return;
}



void mm_bcn_transmitted(vif_info_tag *param_1)

{
  co_list_hdr *pcVar1;
  
  if (mm_bcn_env.tx_cfm == 0) {
    assert_err("mm_bcn_env.tx_cfm","module",0x244);
  }
  mm_bcn_env.tx_cfm = mm_bcn_env.tx_cfm + -1;
  if (mm_bcn_env.tx_cfm == 0) {
    if (mm_bcn_env.update_pending != false) {
      mm_bcn_update(mm_bcn_env.param);
    }
    while (mm_bcn_env.tim_list.first != (co_list_hdr *)0x0) {
      pcVar1 = co_list_pop_front(&mm_bcn_env.tim_list);
      mm_tim_update_proceed(pcVar1 + 3);
    }
    if (param_1->u[0x2eb] == 1) {
      vif_mgmt_switch_channel(param_1);
      return;
    }
  }
  return;
}



void mm_bcn_change(mm_bcn_change_req *param)

{
  if (mm_bcn_env.tx_cfm != 0) {
    mm_bcn_env.param = param;
    mm_bcn_env.update_pending = true;
    return;
  }
  mm_bcn_env.param = param;
  mm_bcn_update(param);
  return;
}


/*
Unable to decompile 'mm_timer_hw_set'
Cause: Exception while decompiling 230036ce: Decompiler process died

*/


_Bool cmp_abs_time(co_list_hdr *timerA,co_list_hdr *timerB)

{
  return SUB41((uint)((int)timerA[3].next - (int)timerB[3].next) >> 0x1f,0);
}



void mm_timer_init(void)

{
  co_list_init((co_list *)&mm_timer_env);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_timer_set(mm_timer_tag *timer,uint32_t value)

{
  bool bVar1;
  
  if ((int)(value - _DAT_44b00120) < 0) {
    puts("\r\n-------------------[FW] Timer is past due to flash operation. Try to fix\r\n");
    value = _DAT_44b00120 + 3000;
  }
  bVar1 = timer != (mm_timer_tag *)mm_timer_env.prog.first;
  if (bVar1) {
    co_list_extract((co_list *)&mm_timer_env,(co_list_hdr *)timer);
  }
  else {
    co_list_pop_front((co_list *)&mm_timer_env);
  }
  timer->time = value;
  co_list_insert((co_list *)&mm_timer_env,(co_list_hdr *)timer,cmp_abs_time);
  if ((!bVar1) || (timer == (mm_timer_tag *)mm_timer_env.prog.first)) {
    mm_timer_hw_set(mm_timer_env.prog.first);
  }
  if ((int)(value - _DAT_44b00120) < 0) {
    ke_evt_set(0x8000000);
    return;
  }
  return;
}



void mm_timer_clear(mm_timer_tag *timer)

{
  if (timer == (mm_timer_tag *)mm_timer_env.prog.first) {
    co_list_pop_front((co_list *)&mm_timer_env);
    mm_timer_hw_set(mm_timer_env.prog.first);
    return;
  }
  co_list_extract((co_list *)&mm_timer_env,(co_list_hdr *)timer);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_timer_schedule(int dummy)

{
  co_list_hdr *pcVar1;
  
  while( true ) {
    ke_evt_clear(0x8000000);
    pcVar1 = mm_timer_env.prog.first;
    if (mm_timer_env.prog.first == (co_list_hdr *)0x0) {
      mm_timer_hw_set(0);
      return;
    }
    if ((-1 < (int)mm_timer_env.prog.first[3].next + (-0x32 - _DAT_44b00120)) &&
       (mm_timer_hw_set(mm_timer_env.prog.first), -1 < (int)((int)pcVar1[3].next - _DAT_44b00120)))
    break;
    co_list_pop_front((co_list *)&mm_timer_env);
    if (pcVar1[1].next == (co_list_hdr *)0x0) {
      assert_err("timer->cb","module",0xde);
    }
    (*(code *)pcVar1[1].next)(pcVar1[2].next,pcVar1[1].next);
  }
  return;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ps_uapsd_timer_handle(void *env)

{
  vif_info_tag *p_vif_entry;
  _Bool _Var1;
  undefined3 extraout_var;
  int iVar2;
  
  iVar2 = 0;
  p_vif_entry = (vif_info_tag *)vif_mgmt_env.used_list.first;
  while (p_vif_entry != (vif_info_tag *)0x0) {
    if (((p_vif_entry->type == '\0') && (p_vif_entry->active != false)) &&
       (*(char *)((int)p_vif_entry->u + 0xc) != '\0')) {
      _Var1 = chan_is_on_channel(p_vif_entry);
      __Var1 = CONCAT31(extraout_var,_Var1);
      if ((__Var1 != 0) &&
         (iVar2 = __Var1,
         (int)(((ps_env.uapsd_timeout >> 1) - _DAT_44b00120) + *(int *)((int)p_vif_entry->u + 8)) <
         0)) {
        p_vif_entry->prevent_sleep = p_vif_entry->prevent_sleep | 8;
        txl_frame_send_qosnull_frame
                  (*(uint8_t *)((int)p_vif_entry->u + 4),7,(cfm_func_ptr *)0x0,(void *)0x0);
        *(int *)((int)p_vif_entry->u + 8) = _DAT_44b00120;
      }
    }
    p_vif_entry = *(vif_info_tag **)&p_vif_entry->list_hdr;
  }
  if (iVar2 != 0) {
    mm_timer_set(&ps_env.uapsd_timer,_DAT_44b00120 + ps_env.uapsd_timeout);
    return;
  }
  ps_env.uapsd_tmr_on = false;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void blmac_pwr_mgt_setf(uint8_t pwrmgt)

{
  undefined3 in_register_00002029;
  
  _DAT_44b0004c = CONCAT31(in_register_00002029,pwrmgt) << 2 | _DAT_44b0004c & 0xfffffffb;
  return;
}



// WARNING: Type propagation algorithm not settling

void ps_dpsm_update(_Bool pause)

{
  vif_info_tag *p_vif_entry;
  _Bool _Var1;
  undefined3 in_register_00002029;
  undefined3 extraout_var;
  code *UNRECOVERED_JUMPTABLE;
  
  if (CONCAT31(in_register_00002029,pause) == 0) {
    ps_env.dpsm_state = ps_env.dpsm_state | 4;
    ps_env.prevent_sleep = ps_env.prevent_sleep & 0xfffffff7;
    UNRECOVERED_JUMPTABLE = ps_enable_cfm;
  }
  else {
    ps_env.dpsm_state = ps_env.dpsm_state | 2;
    ps_env.prevent_sleep = ps_env.prevent_sleep | 8;
    UNRECOVERED_JUMPTABLE = ps_disable_cfm;
  }
  blmac_pwr_mgt_setf(pause ^ 1);
  ps_env.cfm_cnt = '\0';
  p_vif_entry = (vif_info_tag *)vif_mgmt_env.used_list.first;
  while (p_vif_entry != (vif_info_tag *)0x0) {
    if (((p_vif_entry->type == '\0') && (p_vif_entry->active != false)) &&
       (_Var1 = chan_is_on_channel(p_vif_entry), CONCAT31(extraout_var,_Var1) != 0)) {
      *(undefined *)((int)p_vif_entry->u + 3) = 0;
      ps_env.cfm_cnt = ps_env.cfm_cnt + '\x01';
      txl_frame_send_null_frame
                (*(uint8_t *)((int)p_vif_entry->u + 4),UNRECOVERED_JUMPTABLE,p_vif_entry);
    }
    p_vif_entry = *(vif_info_tag **)&p_vif_entry->list_hdr;
  }
  if (ps_env.cfm_cnt == '\0') {
                    // WARNING: Could not recover jumptable at 0x230039d8. Too many branches
                    // WARNING: Treating indirect jump as call
    (*UNRECOVERED_JUMPTABLE)((void *)0x0,0x800000);
    return;
  }
  return;
}



uint8_t ps_send_pspoll(vif_info_tag *vif_entry)

{
  ushort uVar1;
  txl_frame_desc_tag *frame;
  tx_hw_desc *ptVar2;
  txl_buffer_tag *ptVar3;
  uint uVar4;
  char acStack40 [4];
  phy_channel_info phy_info;
  
  uVar4 = (uint)vif_entry->u[4];
  phy_get_channel((phy_channel_info *)acStack40,'\0');
  frame = txl_frame_get((uint)(acStack40[0] != '\0'),0x10);
  if (frame != (txl_frame_desc_tag *)0x0) {
    tpc_update_frame_tx_power(vif_entry,frame);
    ptVar3 = (frame->txdesc).lmac.buffer;
    *(undefined *)&ptVar3[1].length = 0xa4;
    *(undefined *)((int)&ptVar3[1].length + 1) = 0;
    uVar1 = sta_info_tab[uVar4].aid;
    *(undefined *)((int)&ptVar3[1].length + 2) = (char)uVar1;
    *(byte *)((int)&ptVar3[1].length + 3) = (byte)((uint)uVar1 >> 8) | 0xc0;
    memcpy(&ptVar3[1].lenheader,&sta_info_tab[uVar4].mac_addr,6);
    memcpy((void *)((int)&ptVar3[1].lenpad + 2),&vif_entry->mac_addr,6);
    ptVar2 = (frame->txdesc).lmac.hw_desc;
    (ptVar2->thd).macctrlinfo2 = (ptVar2->thd).macctrlinfo2 | 0x10000053;
    (frame->txdesc).host.vif_idx = sta_info_tab[uVar4].inst_nbr;
    (frame->txdesc).host.staid = sta_info_tab[uVar4].staid;
    txl_frame_push(frame,'\x03');
  }
  return (uint8_t)(frame == (txl_frame_desc_tag *)0x0);
}



void ps_init(void)

{
  memset(&ps_env,0,0x28);
  ps_env.uapsd_timer.cb = ps_uapsd_timer_handle;
  return;
}



// WARNING: Type propagation algorithm not settling

void ps_set_mode(uint8_t mode,ke_task_id_t taskid)

{
  vif_info_tag *p_vif_entry;
  _Bool _Var1;
  undefined3 in_register_00002029;
  undefined3 extraout_var;
  code *UNRECOVERED_JUMPTABLE;
  
  ps_env.taskid = taskid;
  if (((ps_env.dpsm_state & 1) == 0) || ((ps_env.dpsm_state & 6) == 0)) {
    if (CONCAT31(in_register_00002029,mode) == 0) {
      ps_env.dpsm_state = '\0';
      UNRECOVERED_JUMPTABLE = ps_disable_cfm;
      blmac_pwr_mgt_setf(mode);
    }
    else {
      if (CONCAT31(in_register_00002029,mode) == 2) {
        ps_env.dpsm_state = ps_env.dpsm_state | 1;
      }
      blmac_pwr_mgt_setf('\x01');
      UNRECOVERED_JUMPTABLE = ps_enable_cfm;
    }
    ps_env.cfm_cnt = '\0';
    ps_env.uapsd_on = false;
    p_vif_entry = (vif_info_tag *)vif_mgmt_env.used_list.first;
    while (p_vif_entry != (vif_info_tag *)0x0) {
      if (((p_vif_entry->type == '\0') && (p_vif_entry->active != false)) &&
         (_Var1 = chan_is_on_channel(p_vif_entry), CONCAT31(extraout_var,_Var1) != 0)) {
        *(undefined *)((int)p_vif_entry->u + 3) = 0;
        ps_env.cfm_cnt = ps_env.cfm_cnt + '\x01';
        if (*(char *)((int)p_vif_entry->u + 0xc) != '\0') {
          ps_env.uapsd_on = true;
        }
        txl_frame_send_null_frame
                  (*(uint8_t *)((int)p_vif_entry->u + 4),UNRECOVERED_JUMPTABLE,p_vif_entry);
      }
      p_vif_entry = *(vif_info_tag **)&p_vif_entry->list_hdr;
    }
    if (ps_env.cfm_cnt == '\0') {
                    // WARNING: Could not recover jumptable at 0x23003ba6. Too many branches
                    // WARNING: Treating indirect jump as call
      (*UNRECOVERED_JUMPTABLE)((void *)0x0,0x800000);
      return;
    }
  }
  else {
    ps_env.dpsm_state = ps_env.dpsm_state | 0x10;
    ps_env.next_mode = mode;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ps_enable_cfm(void *env,uint32_t status)

{
  co_list_hdr cVar1;
  char cVar2;
  
  if (-1 < (int)(status << 8)) {
    cVar2 = *(char *)((int)env + 0x5f) + '\x01';
    *(char *)((int)env + 0x5f) = cVar2;
    if (cVar2 != '\x03') {
      txl_frame_send_null_frame(*(uint8_t *)((int)env + 0x60),ps_enable_cfm,env);
      return;
    }
    mm_send_connection_loss_ind((vif_info_tag *)env);
  }
  cVar1 = (co_list_hdr)vif_mgmt_env.used_list.first;
  if ((ps_env.cfm_cnt == '\0') || (ps_env.cfm_cnt = ps_env.cfm_cnt + -1, ps_env.cfm_cnt == '\0')) {
    if (ps_env.uapsd_on != false) {
      mm_timer_set(&ps_env.uapsd_timer,_DAT_44b00120 + ps_env.uapsd_timeout);
      ps_env.uapsd_tmr_on = true;
      while (cVar1 != (co_list_hdr)0x0) {
        if (((*(char *)((int)cVar1 + 0x56) == '\0') &&
            (*(char *)&((co_list_hdr *)((int)cVar1 + 0x58))->next != '\0')) &&
           (*(char *)&((co_list_hdr *)((int)cVar1 + 0x68))->next != '\0')) {
          ((co_list_hdr *)((int)cVar1 + 4))->next =
               (co_list_hdr *)((uint)((co_list_hdr *)((int)cVar1 + 4))->next & 0xfffffff7);
        }
        cVar1 = *(co_list_hdr *)cVar1;
      }
    }
    if ((ps_env.dpsm_state & 5) == 5) {
      ps_env.dpsm_state = ps_env.dpsm_state & 0xf3;
    }
    else {
      ps_env.ps_on = true;
      ke_msg_send_basic(0x32,ps_env.taskid,0);
    }
    if ((ps_env.dpsm_state & 0x10) != 0) {
      ps_env.dpsm_state = ps_env.dpsm_state & 0xef;
      ps_set_mode(ps_env.next_mode,ps_env.taskid);
      return;
    }
  }
  return;
}



void ps_disable_cfm(void *env,uint32_t status)

{
  char cVar1;
  
  if (-1 < (int)(status << 8)) {
    cVar1 = *(char *)((int)env + 0x5f) + '\x01';
    *(char *)((int)env + 0x5f) = cVar1;
    if (cVar1 != '\x03') {
      txl_frame_send_null_frame(*(uint8_t *)((int)env + 0x60),ps_disable_cfm,env);
      return;
    }
    mm_send_connection_loss_ind((vif_info_tag *)env);
  }
  if ((ps_env.cfm_cnt == '\0') || (ps_env.cfm_cnt = ps_env.cfm_cnt + -1, ps_env.cfm_cnt == '\0')) {
    mm_timer_clear(&ps_env.uapsd_timer);
    ps_env.uapsd_tmr_on = false;
    if ((ps_env.dpsm_state & 3) == 3) {
      ps_env.dpsm_state = ps_env.dpsm_state & 0xfd | 8;
    }
    else {
      ps_env.ps_on = false;
      ke_msg_send_basic(0x32,ps_env.taskid,0);
    }
    if ((ps_env.dpsm_state & 0x10) != 0) {
      ps_env.dpsm_state = ps_env.dpsm_state & 0xef;
      ps_set_mode(ps_env.next_mode,ps_env.taskid);
      return;
    }
  }
  return;
}



uint8_t ps_polling_frame(vif_info_tag *vif_entry)

{
  ushort uVar1;
  txl_frame_desc_tag *frame;
  tx_hw_desc *ptVar2;
  txl_buffer_tag *ptVar3;
  uint uVar4;
  char acStack40 [16];
  
  uVar4 = (uint)vif_entry->u[4];
  phy_get_channel((phy_channel_info *)acStack40,'\0');
  frame = txl_frame_get((uint)(acStack40[0] != '\0'),0x10);
  if (frame != (txl_frame_desc_tag *)0x0) {
    tpc_update_frame_tx_power(vif_entry,frame);
    ptVar3 = (frame->txdesc).lmac.buffer;
    *(undefined *)&ptVar3[1].length = 0xa4;
    *(undefined *)((int)&ptVar3[1].length + 1) = 0;
    uVar1 = sta_info_tab[uVar4].aid;
    *(undefined *)((int)&ptVar3[1].length + 2) = (char)uVar1;
    *(byte *)((int)&ptVar3[1].length + 3) = (byte)((uint)uVar1 >> 8) | 0xc0;
    memcpy(&ptVar3[1].lenheader,&sta_info_tab[uVar4].mac_addr,6);
    memcpy((void *)((int)&ptVar3[1].lenpad + 2),&vif_entry->mac_addr,6);
    ptVar2 = (frame->txdesc).lmac.hw_desc;
    (ptVar2->thd).macctrlinfo2 = (ptVar2->thd).macctrlinfo2 | 0x10000053;
    (frame->txdesc).host.vif_idx = sta_info_tab[uVar4].inst_nbr;
    (frame->txdesc).host.staid = sta_info_tab[uVar4].staid;
    txl_frame_push(frame,'\x03');
  }
  return (uint8_t)(frame == (txl_frame_desc_tag *)0x0);
}



void ps_check_beacon(int param_1,vif_info_tag *param_2)

{
  ushort uVar1;
  _Bool _Var2;
  uint8_t uVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  uint uVar4;
  uint uVar5;
  uint32_t uVar6;
  byte bVar7;
  
  _Var2 = ps_env.ps_on;
  uVar1 = sta_info_tab[param_2->u[4]].aid;
  uVar5 = param_2->prevent_sleep;
  uVar4 = uVar5 & 0xfffffffe;
  param_2->prevent_sleep = uVar4;
  if (((_Var2 == false) || ((ps_env.dpsm_state & 8) != 0)) || (param_1 == 0)) {
    return;
  }
  if (param_2->u[2] == 0) {
    if ((*(byte *)(param_1 + 4) & 1) == 0) {
      param_2->prevent_sleep = uVar5 & 0xfffffffc;
    }
    else {
      param_2->prevent_sleep = uVar4 | 2;
    }
  }
  uVar5 = (uint)(uVar1 >> 3);
  uVar4 = (uint)*(byte *)(param_1 + 4) & 0xfe;
  bVar7 = param_2->u[0xc] & 0xf;
  if (((uVar4 <= uVar5) && (uVar5 <= ((uint)*(byte *)(param_1 + 1) - 4) + uVar4)) &&
     (((uint)*(byte *)(((uVar5 + param_1) - uVar4) + 5) & 1 << ((uint)uVar1 & 7)) != 0)) {
    if (bVar7 == 0xf) {
      uVar3 = txl_frame_send_qosnull_frame(param_2->u[4],7,(cfm_func_ptr *)0x0,(void *)0x0);
      if (CONCAT31(extraout_var,uVar3) != 0) {
        return;
      }
      uVar6 = param_2->prevent_sleep | 8;
    }
    else {
      uVar3 = ps_send_pspoll(param_2);
      if (CONCAT31(extraout_var_00,uVar3) != 0) {
        return;
      }
      uVar6 = param_2->prevent_sleep | 4;
    }
    param_2->prevent_sleep = uVar6;
    return;
  }
  if (bVar7 == 0xf) {
    uVar6 = param_2->prevent_sleep & 0xfffffff7;
  }
  else {
    uVar6 = param_2->prevent_sleep & 0xfffffffb;
  }
  param_2->prevent_sleep = uVar6;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ps_check_frame(uint8_t *frame,uint32_t statinfo,vif_info_tag *vif_entry)

{
  byte bVar1;
  uint uVar2;
  uint8_t uVar3;
  undefined3 extraout_var;
  uint32_t uVar4;
  _Bool _Var5;
  
  _Var5 = ps_env.uapsd_on;
  if (ps_env.ps_on == false) {
    return;
  }
  uVar2 = (uint)*(ushort *)frame;
  if ((frame[4] & 1) != 0) {
    if (((int)(uVar2 << 0x12) < 0) && (vif_entry->u[2] == 0)) {
      return;
    }
    uVar4 = vif_entry->prevent_sleep & 0xfffffffd;
LAB_23003ee6:
    vif_entry->prevent_sleep = uVar4;
    return;
  }
  if ((statinfo & 0x200) != 0) {
    return;
  }
  if (ps_env.uapsd_on != false) {
    if ((uVar2 & 0x88) == 0x88) {
      if ((uVar2 & 0x300) == 0x300) {
        bVar1 = frame[0x1e];
      }
      else {
        bVar1 = frame[0x18];
      }
      if ((vif_entry->u[0xc] >> ((uint)"\x01"[(uint)bVar1 & 7] & 0x1f) & 1) != 0) {
        *(undefined4 *)(vif_entry->u + 8) = _DAT_44b00120;
        if ((bVar1 & 0x10) == 0) {
          return;
        }
        uVar4 = vif_entry->prevent_sleep & 0xfffffff7;
        goto LAB_23003ee6;
      }
    }
    else {
      if (((*(ushort *)frame & 0xc) == 0) && ((vif_entry->u[0xc] & 8) != 0)) {
        *(undefined4 *)(vif_entry->u + 8) = _DAT_44b00120;
        goto LAB_23003f80;
      }
    }
    _Var5 = false;
  }
LAB_23003f80:
  td_pck_ps_ind(vif_entry->index,true);
  if ((_Var5 == false) &&
     ((-1 < (int)(uVar2 << 0x12) ||
      (((ps_env.dpsm_state & 8) == 0 &&
       (uVar3 = ps_send_pspoll(vif_entry), CONCAT31(extraout_var,uVar3) != 0)))))) {
    vif_entry->prevent_sleep = vif_entry->prevent_sleep & 0xfffffffb;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ps_check_tx_frame(uint8_t staid,uint8_t tid)

{
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  uint uVar1;
  
  if ((((ps_env.ps_on != false) && (CONCAT31(in_register_00002029,staid) != 0xff)) &&
      (CONCAT31(in_register_0000202d,tid) != 0xff)) &&
     ((uVar1 = (uint)sta_info_tab[CONCAT31(in_register_00002029,staid)].inst_nbr,
      vif_info_tab[uVar1].type == '\0' && (vif_info_tab[uVar1].active != false)))) {
    if ((vif_info_tab[uVar1].u[0xc] >> ((uint)"\x01"[CONCAT31(in_register_0000202d,tid)] & 0x1f) & 1
        ) != 0) {
      vif_info_tab[uVar1].prevent_sleep = vif_info_tab[uVar1].prevent_sleep | 8;
      *(undefined4 *)(vif_info_tab[uVar1].u + 8) = _DAT_44b00120;
      return;
    }
    td_pck_ps_ind(vif_info_tab[uVar1].index,false);
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ps_uapsd_set(vif_info_tag *vif_entry,uint8_t hw_queue,_Bool uapsd)

{
  byte bVar1;
  undefined3 in_register_00002031;
  
  bVar1 = (byte)(1 << ((uint)hw_queue & 0x1f));
  if (CONCAT31(in_register_00002031,uapsd) == 0) {
    vif_entry->u[0xc] = vif_entry->u[0xc] & ~bVar1;
  }
  else {
    vif_entry->u[0xc] = vif_entry->u[0xc] | bVar1;
    if ((ps_env.ps_on != false) && (ps_env.uapsd_tmr_on == false)) {
      ps_env.uapsd_on = true;
      mm_timer_set(&ps_env.uapsd_timer,_DAT_44b00120 + ps_env.uapsd_timeout);
      ps_env.uapsd_tmr_on = true;
    }
  }
  return;
}



void ps_traffic_status_update(uint8_t vif_index,uint8_t new_status)

{
  _Bool pause;
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  char cVar1;
  co_list_hdr cVar2;
  
  if (((ps_env.ps_on != false) && ((ps_env.dpsm_state & 1) != 0)) && ((ps_env.dpsm_state & 6) == 0))
  {
    cVar2 = (co_list_hdr)vif_mgmt_env.used_list.first;
    if (CONCAT31(in_register_0000202d,new_status) == 0) {
      while (cVar2 != (co_list_hdr)0x0) {
        if ((((uint)*(byte *)((int)cVar2 + 0x57) != CONCAT31(in_register_00002029,vif_index)) &&
            (cVar1 = *(char *)&((co_list_hdr *)((int)cVar2 + 0x58))->next, cVar1 != '\0')) &&
           ((*(char *)((int)cVar2 + 0x56) == '\0' &&
            ((td_env[(uint)*(byte *)((int)cVar2 + 0x57)].status & 0xc) != 0)))) goto LAB_230040e0;
        cVar2 = *(co_list_hdr *)cVar2;
      }
      cVar1 = '\0';
LAB_230040e0:
      if (cVar1 == '\0') {
        if ((ps_env.dpsm_state & 8) == 0) {
          return;
        }
        pause = false;
        goto LAB_230040e8;
      }
    }
    pause = true;
    if ((ps_env.dpsm_state & 8) == 0) {
LAB_230040e8:
      ps_dpsm_update(pause);
      return;
    }
  }
  return;
}



void mm_ps_change_ind(uint8_t sta_idx,uint8_t ps_state)

{
  undefined3 in_register_00002029;
  uint8_t *puVar1;
  
  puVar1 = (uint8_t *)ke_msg_alloc(0x49,0xd,0,2);
  sta_info_tab[CONCAT31(in_register_00002029,sta_idx)].ps_state = ps_state;
  *puVar1 = sta_idx;
  puVar1[1] = ps_state;
  ke_msg_send();
  return;
}



void rxl_mpdu_transfer(rx_swdesc *swdesc)

{
  rx_pbd *prVar1;
  rx_pbd *prVar2;
  rx_pbd *prVar3;
  rx_dmadesc *prVar4;
  
  prVar4 = swdesc->dma_hdrdesc;
  prVar1 = (rx_pbd *)(prVar4->hd).first_pbd_ptr;
  phy_get_channel(&prVar4->phy_info,'\0');
  prVar4->payl_offset = mac_payload_offset;
  swdesc->pbd_count = '\0';
  prVar3 = (rx_pbd *)0x0;
  do {
    prVar2 = prVar1;
    if ((prVar2->bufstatinfo & 1) != 0) {
      swdesc->spare_pbd = prVar2;
      swdesc->last_pbd = prVar3;
      return;
    }
    prVar1 = (rx_pbd *)prVar2->next;
    swdesc->pbd_count = swdesc->pbd_count + '\x01';
    prVar3 = prVar2;
  } while (prVar1 != (rx_pbd *)0x0);
  assert_rec("pd != NULL","module",0xb4);
  return;
}



void rxl_init(void)

{
  rxl_hwdesc_init(1);
  rx_swdesc_init();
  co_list_init((co_list *)&rxl_cntrl_env);
  rxu_cntrl_init();
  return;
}



void rxl_cntrl_dump(void)

{
  uint32_t uVar1;
  co_list_hdr cVar2;
  
  uVar1 = co_list_cnt((co_list *)&rxl_cntrl_env);
  cVar2 = (co_list_hdr)rxl_cntrl_env.ready.first;
  if (uVar1 != 0) {
    while (cVar2 != (co_list_hdr)0x0) {
      cVar2 = *(co_list_hdr *)cVar2;
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rxl_timer_int_handler(void)

{
  rx_hd *prVar1;
  rx_dmadesc *desc;
  char *condition;
  rx_swdesc *list_hdr;
  int line;
  uint32_t uVar2;
  
  _DAT_44b0807c = 0xa0000;
  do {
    while( true ) {
      if ((rxl_cntrl_env.first == (rx_dmadesc *)0x0) ||
         (-1 < (int)(((rxl_cntrl_env.first)->hd).statinfo << 0x11))) {
        if (rxl_cntrl_env.ready.first != (co_list_hdr *)0x0) {
          ke_evt_set(0x40000);
          return;
        }
        return;
      }
      list_hdr = ((rxl_cntrl_env.first)->hd).swdesc;
      prVar1 = &(rxl_cntrl_env.first)->hd;
      desc = list_hdr->dma_hdrdesc;
      rxl_cntrl_env.first = (rx_dmadesc *)((rxl_cntrl_env.first)->hd).next;
      list_hdr->pd = (rx_payloaddesc *)prVar1->first_pbd_ptr;
      uVar2 = (desc->hd).first_pbd_ptr;
      if ((desc->hd).frmlen == 0) break;
      if (uVar2 == 0) {
        line = 0xd8;
        condition = "pd != NULL";
LAB_23004280:
        assert_rec(condition,"module",line);
      }
      else {
        co_list_push_back((co_list *)&rxl_cntrl_env,(co_list_hdr *)list_hdr);
      }
    }
    if (uVar2 != 0) {
      line = 0xfa;
      condition = "dma_hdrdesc->hd.first_pbd_ptr == 0";
      goto LAB_23004280;
    }
    list_hdr->spare_pbd = (rx_pbd *)0x0;
    list_hdr->last_pbd = (rx_pbd *)0x0;
    rxl_hd_append(desc);
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rxl_timeout_int_handler(void)

{
  _DAT_44b0808c = _DAT_44b0808c & 0xffffffbf;
  return;
}



void rxl_dma_int_handler(void)

{
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rxl_dma_evt(int dummy)

{
  ke_evt_clear(0x100000);
  _DAT_44a00020 = 0x20;
  return;
}



void rxl_frame_release(rx_swdesc *swdesc)

{
  rxl_pd_append((rx_pbd *)(swdesc->dma_hdrdesc->hd).first_pbd_ptr,swdesc->last_pbd,swdesc->spare_pbd
               );
  rxl_hd_append(swdesc->dma_hdrdesc);
  return;
}



void rxl_mpdu_free(rx_swdesc *swdesc)

{
  ushort uVar1;
  rx_pbd *prVar2;
  rx_pbd *prVar3;
  rx_pbd *prVar4;
  
  prVar2 = (rx_pbd *)(swdesc->dma_hdrdesc->hd).first_pbd_ptr;
  vTaskEnterCritical();
  swdesc->use_in_tcpip = '\0';
  swdesc->dma_hdrdesc->use_in_tcpip = 0;
  prVar4 = (rx_pbd *)0x0;
  do {
    prVar3 = prVar2;
    uVar1 = prVar3->bufstatinfo;
    prVar3[1].upattern = 0;
    if ((uVar1 & 1) != 0) {
      swdesc->spare_pbd = prVar3;
      swdesc->last_pbd = prVar4;
      rxl_frame_release(swdesc);
      vTaskExitCritical();
      return;
    }
    prVar2 = (rx_pbd *)prVar3->next;
    prVar4 = prVar3;
  } while ((rx_pbd *)prVar3->next != (rx_pbd *)0x0);
  assert_rec("pd != NULL","module",0x397);
  return;
}


/*
Unable to decompile 'rxl_cntrl_evt'
Cause: Exception while decompiling 23004384: Decompiler process died

*/


void bl60x_firmwre_mpdu_free(void *swdesc_ptr)

{
  rx_swdesc *swdesc;
  
  vTaskEnterCritical();
  rxl_cntrl_env.packet_stack_cnt =
       rxl_cntrl_env.packet_stack_cnt - *(byte *)((int)swdesc_ptr + 0x1d);
  vTaskExitCritical();
  rxl_mpdu_free((rx_swdesc *)swdesc_ptr);
  return;
}



void rxl_reset(void)

{
  rxl_hwdesc_init(0);
  co_list_init((co_list *)&rxl_cntrl_env);
  co_list_init((co_list *)&swdesc);
  return;
}



void rxl_hwdesc_dump(void)

{
  rx_dmadesc *prVar1;
  rx_payloaddesc *prVar2;
  int iVar3;
  int iVar4;
  uint32_t uVar5;
  
  puts("---------- rxl_hwdesc_dump -------\r\n");
  printf("rx_dma_hdrdesc: %d\r\n",0xd);
  iVar3 = 0;
  prVar1 = rx_dma_hdrdesc;
  do {
    printf("  [%2d]@%08lx: upatternrx %08lx next %08lx first_pbd_ptr %08lx, swdesc %p\r\n",iVar3,
           prVar1,(prVar1->hd).upatternrx,(prVar1->hd).next,(prVar1->hd).first_pbd_ptr,
           (prVar1->hd).swdesc);
    iVar3 = iVar3 + 1;
    printf(
           "    datastartptr %08lx dataendptr %08lx, headerctrlinfo %08lx frmlen %4u ampdu_stat_info %04x\r\n"
           ,(prVar1->hd).datastartptr,(prVar1->hd).dataendptr,(prVar1->hd).headerctrlinfo,
           (uint)(prVar1->hd).frmlen,(uint)(prVar1->hd).ampdu_stat_info);
    printf(
           "    tsflo %08lx tsfhi %08lx recvec1b %08lx recvec1c %08lx recvec1d %08lx recvec2a %08lx recvec2b %08lx statinfo %08lx\r\n"
           ,(prVar1->hd).tsflo,(prVar1->hd).tsfhi,(prVar1->hd).recvec1b,(prVar1->hd).recvec1c,
           (prVar1->hd).recvec1d,(prVar1->hd).recvec2a,(prVar1->hd).recvec2b);
    prVar1 = prVar1 + 1;
  } while (iVar3 != 0xd);
  printf("rx_payload_desc: %d\r\n",0xd);
  iVar3 = 0;
  prVar2 = rx_payload_desc;
  do {
    uVar5 = (prVar2->pbd).dataendptr;
    iVar4 = 0;
    if (uVar5 != 0) {
      iVar4 = (uVar5 + 1) - (prVar2->pbd).datastartptr;
    }
    iVar3 = iVar3 + 1;
    printf(
           "  [%2d]@%08lx %3lu Bytes: upatternrx %08lx next %08lx datastartptr %08lx dataendptr %08lx bufstatinfo %04x reserved %04X\r\n"
           ,prVar2,iVar4,(prVar2->pbd).upattern,(prVar2->pbd).next);
    prVar2 = prVar2 + 1;
  } while (iVar3 != 0xd);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rxl_hwdesc_init(int init)

{
  rx_dmadesc *prVar1;
  rx_dmadesc *prVar2;
  txl_buffer_control *ptVar3;
  txl_buffer_control *ptVar4;
  txl_buffer_control *ptVar5;
  int iVar6;
  uint32_t *puVar7;
  int iVar8;
  txl_buffer_control *ptVar9;
  rx_dmadesc *prVar10;
  rx_dmadesc *prVar11;
  rx_dmadesc *prVar12;
  rx_dmadesc *prVar13;
  txl_buffer_control *ptVar14;
  txl_buffer_control *ptVar15;
  
  vTaskEnterCritical();
  prVar13 = (rx_dmadesc *)0x0;
  iVar6 = 0;
  iVar8 = 0;
  prVar1 = (rx_dmadesc *)0x0;
  prVar10 = rx_dma_hdrdesc;
  prVar11 = (rx_dmadesc *)0x0;
  do {
    prVar2 = prVar10;
    prVar10 = prVar2 + 1;
    prVar12 = prVar11;
    if ((init == 0) && (prVar2->use_in_tcpip == 1)) {
      prVar2 = prVar1;
      if (prVar1 != (rx_dmadesc *)0x0) {
        (prVar1->hd).next = 0;
      }
    }
    else {
      if (prVar1 != (rx_dmadesc *)0x0) {
        *(rx_dmadesc **)&(prVar1->hd).next = prVar2;
      }
      (prVar2->hd).datastartptr = 0;
      (prVar2->hd).dataendptr = 0;
      (prVar2->hd).upatternrx = 0xbaadf00d;
      (prVar2->hd).statinfo = 0;
      (prVar2->hd).headerctrlinfo = 0;
      *(rx_dmadesc **)&(prVar2->hd).next = prVar10;
      (prVar2->hd).first_pbd_ptr = 0;
      (prVar2->hd).swdesc = rx_swdesc_tab + iVar8;
      (prVar2->hd).frmlen = 0;
      prVar12 = prVar2;
      if ((iVar6 != 0) && (prVar12 = prVar11, iVar6 == 1)) {
        prVar13 = prVar2;
      }
      iVar6 = iVar6 + 1;
    }
    iVar8 = iVar8 + 1;
    prVar1 = prVar2;
    prVar11 = prVar12;
  } while (iVar8 != 0xd);
  if (iVar6 < 4) {
    printf("No enough DESC %d(%d)\r\n",0xd);
  }
  if (prVar2 != (rx_dmadesc *)0x0) {
    (prVar2->hd).next = 0;
  }
  _DAT_44b08180 = 0x4000000;
  puVar7 = rx_payload_desc_buffer;
  ptVar9 = (txl_buffer_control *)0x0;
  iVar6 = 0;
  ptVar3 = (txl_buffer_control *)0x0;
  ptVar5 = (txl_buffer_control *)rx_payload_desc;
  ptVar14 = (txl_buffer_control *)0x0;
  _DAT_44b081b8 = prVar13;
  do {
    ptVar4 = ptVar5;
    ptVar5 = (txl_buffer_control *)&ptVar4->mac_control_info;
    ptVar15 = ptVar14;
    if ((init == 0) && (*(int *)(ptVar4->field_0 + 0x14) == 1)) {
      ptVar4 = ptVar3;
      if (ptVar3 != (txl_buffer_control *)0x0) {
        *(undefined4 *)ptVar3->field_0 = 0;
      }
    }
    else {
      if (ptVar3 != (txl_buffer_control *)0x0) {
        *(txl_buffer_control **)ptVar3->field_0 = ptVar4;
      }
      *(txl_buffer_control **)ptVar4->field_0 = ptVar5;
      *(undefined4 *)ptVar4->field_0 = 0xc0dedbad;
      *(undefined2 *)ptVar4->field_0 = 0;
      *(uint32_t **)ptVar4->field_0 = puVar7;
      *(int *)ptVar4->field_0 = (int)puVar7 + 0x34f;
      *(uint32_t **)(ptVar4->field_0 + 0x18) = puVar7;
      ptVar15 = ptVar4;
      if ((iVar6 != 0) && (ptVar15 = ptVar14, iVar6 == 1)) {
        ptVar9 = ptVar4;
      }
      iVar6 = iVar6 + 1;
    }
    puVar7 = puVar7 + 0xd4;
    ptVar3 = ptVar4;
    ptVar14 = ptVar15;
  } while (ptVar5 != txl_buffer_control_desc_bcmc);
  if (iVar6 < 4) {
    printf("No enough PBD DESC, %d(%d)\r\n",0xd);
  }
  *(undefined4 *)ptVar4->field_0 = 0;
  _DAT_44b08180 = 0x8000000;
  _DAT_44b081bc = ptVar9;
  if ((((prVar12 == (rx_dmadesc *)0x0) || (prVar13 == (rx_dmadesc *)0x0)) ||
      (prVar2 == (rx_dmadesc *)0x0)) ||
     ((ptVar15 == (txl_buffer_control *)0x0 || (ptVar9 == (txl_buffer_control *)0x0)))) {
    printf("%p:%p%p vs %p:%p:%p\r\n",prVar12,prVar13,prVar2,ptVar15,ptVar4);
  }
  rxl_cntrl_env.first = prVar13;
  rxl_cntrl_env.last = prVar2;
  rxl_cntrl_env.free = prVar12;
  rx_hwdesc_env.last = (rx_pbd *)ptVar4;
  rx_hwdesc_env.free = (rx_pbd *)ptVar15;
  vTaskExitCritical();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rxl_hd_append(rx_dmadesc *desc)

{
  rx_dmadesc *prVar1;
  
  if (desc == (rx_dmadesc *)0x0) {
    assert_err("desc != NULL","module",0xf9);
  }
  prVar1 = desc;
  if (rxl_cntrl_env.free != _DAT_44b08548) {
    prVar1 = rxl_cntrl_env.free;
    rxl_cntrl_env.free = desc;
  }
  (prVar1->hd).next = 0;
  (prVar1->hd).first_pbd_ptr = 0;
  (prVar1->hd).statinfo = 0;
  (prVar1->hd).frmlen = 0;
  *(rx_dmadesc **)&((rxl_cntrl_env.last)->hd).next = prVar1;
  if (rxl_cntrl_env.first == (rx_dmadesc *)0x0) {
    rxl_cntrl_env.first = prVar1;
  }
  rxl_cntrl_env.last = prVar1;
  _DAT_44b08180 = 0x1000000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rxl_pd_append(rx_pbd *first,rx_pbd *last,rx_pbd *spare)

{
  rx_pbd **pprVar1;
  rx_pbd *prVar2;
  rx_pbd *prVar3;
  rx_pbd *prVar4;
  
  if (spare == (rx_pbd *)0x0) {
    assert_err("spare != NULL","module",0x128);
  }
  prVar4 = rx_hwdesc_env.free;
  if (rx_hwdesc_env.free == _DAT_44b0854c) {
    prVar4 = first;
    if (last == (rx_pbd *)0x0) {
      prVar4 = spare;
    }
    spare->bufstatinfo = 0;
  }
  else {
    prVar2 = rx_hwdesc_env.free;
    prVar3 = spare;
    if (last != (rx_pbd *)0x0) {
      pprVar1 = (rx_pbd **)&(rx_hwdesc_env.free)->next;
      rx_hwdesc_env.free = spare;
      *pprVar1 = first;
      prVar2 = last;
      prVar3 = rx_hwdesc_env.free;
    }
    rx_hwdesc_env.free = prVar3;
    spare = prVar2;
    prVar4->bufstatinfo = 0;
  }
  spare->next = 0;
  *(rx_pbd **)&(rx_hwdesc_env.last)->next = prVar4;
  rx_hwdesc_env.last = spare;
  _DAT_44b08180 = 0x2000000;
  return;
}



void scan_search_ds(void)

{
  scan_start_req *param;
  
  DAT_42018f0c = mac_ie_find(0x42047d04,(uint)param->add_ie_len,3);
  return;
}



void scan_init(void)

{
  memset(&scan_env,0,0x1c);
  ke_state_set(2,0);
  DAT_42018efc = &scan_probe_req_ie;
  DAT_42018f00 = dma_cb;
  DAT_42018f04 = 0;
  scan_probe_req_ie.dma_desc.dest = 0x42047d04;
  scan_probe_req_ie.pbd.upatterntx = 0xcafefade;
  scan_probe_req_ie.pbd.next = 0;
  scan_probe_req_ie.pbd.datastartptr = 0x42047d04;
  scan_probe_req_ie.pbd.bufctrlinfo = 0;
  return;
}



void scan_set_channel_request(void)

{
  scan_chan_tag *psVar1;
  uint uVar2;
  undefined uVar3;
  int iVar4;
  
  psVar1 = param->chan + DAT_42018f12;
  chan_scan_req(*(uint8_t *)(&psVar1->freq + 1),psVar1->freq,*(int8_t *)(&psVar1->freq + 2),110000,
                param->vif_idx);
  if (DAT_42018f0c == 0) goto LAB_23004c56;
  uVar2 = (uint)psVar1->freq;
  if (*(char *)(&psVar1->freq + 1) == '\0') {
    uVar3 = 0;
    if (((uVar2 - 0x96c & 0xffff) < 0x49) && (uVar3 = 0xe, psVar1->freq != 0x9b4)) {
      iVar4 = -0x967;
LAB_23004c4a:
      uVar3 = (undefined)((int)(uVar2 + iVar4) / 5);
    }
  }
  else {
    uVar3 = 0;
    if ((*(char *)(&psVar1->freq + 1) == '\x01') && ((uVar2 - 0x138d & 0xffff) < 0x335)) {
      iVar4 = -5000;
      goto LAB_23004c4a;
    }
  }
  *(undefined *)(DAT_42018f0c + 2) = uVar3;
LAB_23004c56:
  ke_state_set(2,2);
  return;
}



void dma_cb(void *env,int dma_queue)

{
  scan_search_ds();
  scan_set_channel_request();
  return;
}



void scan_ie_download(scan_start_req *param)

{
  scan_search_ds();
  scan_set_channel_request();
  scan_probe_req_ie.pbd.dataendptr =
       (scan_probe_req_ie.pbd.datastartptr - 1) + (uint)param->add_ie_len;
  scan_probe_req_ie.pbd.bufctrlinfo = 0;
  return;
}



void scan_probe_req_tx(void)

{
  byte bVar1;
  byte bVar2;
  scan_start_req *psVar3;
  txl_buffer_tag *ptVar4;
  uint type;
  txl_frame_desc_tag *frame;
  int iVar5;
  int iVar6;
  uint uVar7;
  uint8_t *puVar8;
  tx_hw_desc *ptVar9;
  
  psVar3 = param;
  uVar7 = (uint)DAT_42018f12;
  bVar1 = param->vif_idx;
  puVar8 = param->ssid[0].array;
  iVar6 = 0;
  while( true ) {
    if ((int)(uint)psVar3->ssid_cnt <= iVar6) {
      return;
    }
    type = 1;
    if (psVar3->chan[uVar7].band == '\0') {
      type = (uint)psVar3->no_cck;
    }
    frame = txl_frame_get(type,(uint)psVar3->add_ie_len + (uint)puVar8[-1] + 0x1a);
    if (frame == (txl_frame_desc_tag *)0x0) break;
    ptVar4 = (frame->txdesc).lmac.buffer;
    ptVar9 = (frame->txdesc).lmac.hw_desc;
    *(undefined *)&ptVar4[1].length = 0x40;
    *(undefined *)((int)&ptVar4[1].length + 1) = 0;
    *(undefined *)((int)&ptVar4[1].length + 2) = 0;
    *(undefined *)((int)&ptVar4[1].length + 3) = 0;
    memcpy(&ptVar4[1].lenheader,&mac_addr_bcst,6);
    memcpy((void *)((int)&ptVar4[1].lenpad + 2),&vif_info_tab[bVar1].mac_addr,6);
    memcpy(&ptVar4[1].next,&psVar3->bssid,6);
    type = (uint)txl_cntrl_env.seqnbr;
    *(undefined *)&ptVar4[1].dma_desc[0].src = 0;
    txl_cntrl_env.seqnbr = (uint16_t)((type + 1) * 0x10000 >> 0x10);
    iVar5 = (type + 1) * 0x100000;
    *(undefined *)((int)&ptVar4[1].txdesc + 2) = (char)((uint)iVar5 >> 0x10);
    *(undefined *)((int)&ptVar4[1].txdesc + 3) = (char)((uint)iVar5 >> 0x18);
    bVar2 = puVar8[-1];
    *(byte *)((int)&ptVar4[1].dma_desc[0].src + 1) = bVar2;
    type = 0;
    while ((uint)bVar2 != type) {
      *(uint8_t *)((int)&ptVar4[1].dma_desc[0].src + type + 2) = puVar8[type];
      type = type + 1;
    }
    (ptVar9->thd).field_3 = 0x42047cf0;
    (ptVar9->thd).field_5 = (ptVar9->thd).field_5 - (uint)psVar3->add_ie_len;
    (frame->cfm).cfm_func = (cfm_func_ptr *)0x0;
    (frame->cfm).env = (void *)0x0;
    iVar6 = iVar6 + 1;
    puVar8 = puVar8 + 0x22;
    (frame->txdesc).host.vif_idx = psVar3->vif_idx;
    (frame->txdesc).host.staid = -1;
    txl_frame_push(frame,'\x03');
  }
  return;
}



void scan_send_cancel_cfm(uint8_t status,ke_task_id_t dest_id)

{
  uint8_t *puVar1;
  
  puVar1 = (uint8_t *)ke_msg_alloc(0x804,dest_id,2,1);
  *puVar1 = status;
  ke_msg_send();
  return;
}



void sta_mgmt_entry_init(sta_info_tag *sta_entry)

{
  txdesc *txdesc;
  uint16_t *puVar1;
  
  while ((sta_entry->tx_desc_post).first != (co_list_hdr *)0x0) {
    txdesc = (txdesc *)co_list_pop_front(&sta_entry->tx_desc_post);
    txl_frame_release(txdesc,true);
  }
  memset(sta_entry,0,0x1b0);
  puVar1 = (uint16_t *)&sta_entry->ba_info[0].bam_idx_rx;
  do {
    *(uint8_t *)puVar1 = '\x02';
    *(uint8_t *)((int)puVar1 + 1) = '\x02';
    puVar1 = puVar1 + 6;
  } while (puVar1 != sta_entry->rx_qos_last_seqcntl + 3);
  sta_entry->inst_nbr = -1;
  return;
}



void sta_mgmt_init(void)

{
  sta_info_tag *sta_entry;
  sta_info_tag *psVar1;
  
  co_list_init((co_list *)&sta_info_env);
  sta_entry = sta_info_tab;
  do {
    sta_mgmt_entry_init(sta_entry);
    psVar1 = sta_entry + 1;
    co_list_push_back((co_list *)&sta_info_env,(co_list_hdr *)sta_entry);
    sta_entry = psVar1;
  } while (psVar1 != sta_info_tab + 10);
  sta_mgmt_entry_init(sta_info_tab + 10);
  sta_info_tab[10].pol_tbl.buf_ctrl = txl_buffer_control_desc_bcmc;
  sta_info_tab[10].sta_sec_info.cur_key = &vif_info_tab[0].default_key;
  sta_info_tab[10].inst_nbr = '\0';
  sta_info_tab[10].ctrl_port_state = '\0';
  printf("------ set default key %p, key ptr %p\r\n",0x4201a9d0,vif_info_tab[0].default_key);
  sta_mgmt_entry_init(sta_info_tab + 0xb);
  sta_info_tab[11].inst_nbr = '\x01';
  sta_info_tab[11].pol_tbl.buf_ctrl = txl_buffer_control_desc_bcmc + 1;
  sta_info_tab[11].ctrl_port_state = '\0';
  sta_info_tab[11].sta_sec_info.cur_key = &vif_info_tab[1].default_key;
  printf("------ set default key %p, key ptr %p\r\n",vif_info_tab[1].default_key);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t sta_mgmt_register(mm_sta_add_req *param,uint8_t *sta_idx)

{
  uint8_t uVar1;
  co_list_hdr *list_hdr;
  char *__format;
  undefined4 uVar2;
  key_info_tag *pkVar3;
  co_list_hdr *pcVar4;
  byte bVar5;
  co_list_hdr *pcVar6;
  co_list_hdr *pcVar7;
  uint uVar8;
  
  uVar8 = (uint)param->inst_nbr;
  list_hdr = co_list_pop_front((co_list *)&sta_info_env);
  if (list_hdr == (co_list_hdr *)0x0) {
    uVar1 = '\x01';
  }
  else {
    memcpy((void *)((int)&list_hdr[7].next + 2),&param->mac_addr,6);
    bVar5 = param->ampdu_spacing_min;
    if (bVar5 < 0x10) {
      bVar5 = 0x10;
    }
    *(byte *)&list_hdr[5].next = bVar5;
    *(uint16_t *)&list_hdr[3].next = param->ampdu_size_max_ht;
    list_hdr[2].next = (co_list_hdr *)param->ampdu_size_max_vht;
    list_hdr[4].next = (co_list_hdr *)param->paid_gid;
    *(uint8_t *)((int)&list_hdr[6].next + 2) = param->inst_nbr;
    *(int8_t *)&list_hdr[9].next = param->rssi;
    list_hdr[10].next = (co_list_hdr *)param->tsflo;
    list_hdr[0xb].next = (co_list_hdr *)param->tsfhi;
    *(uint8_t *)&list_hdr[0xc].next = param->data_rate;
    uVar1 = (char)((int)(list_hdr + -0x108063c8) >> 4) * '\x13';
    *sta_idx = uVar1;
    *(uint8_t *)((int)&list_hdr[6].next + 3) = uVar1;
    list_hdr[1].next = (co_list_hdr *)0x19000;
    *(undefined2 *)&list_hdr[0x62].next = 0xffff;
    pcVar6 = (co_list_hdr *)((int)&list_hdr[0x62].next + 2);
    do {
      *(undefined2 *)&pcVar6->next = 0xffff;
      pcVar6 = (co_list_hdr *)((int)&pcVar6->next + 2);
    } while (pcVar6 != list_hdr + 0x67);
    bVar5 = *sta_idx;
    *(undefined *)((int)&list_hdr[0xc].next + 1) = 0;
    *(txl_buffer_control **)&list_hdr[0x43].next = txl_buffer_control_desc + bVar5;
    if ((vif_info_tab[uVar8].flags & 8) == 0) {
      list_hdr[0x2b].next = (co_list_hdr *)(uVar8 * 0x5d8 + 0x4201a9d0);
      pkVar3 = vif_info_tab[uVar8].default_key;
      uVar2 = 0x10d;
      __format = "------ %d set default key %p, ptr %p\r\n";
    }
    else {
      pkVar3 = (key_info_tag *)list_hdr[0x2a].next;
      list_hdr[0x2b].next = list_hdr + 0x2a;
      uVar2 = 0x102;
      __format = "------ %d set default key %p, key ptr %p\r\n";
    }
    printf(__format,uVar2,pkVar3);
    pcVar6 = _DAT_44b00120;
    pcVar7 = list_hdr + 0x47;
    pcVar4 = _DAT_44b00120 + -250000;
    do {
      pcVar7->next = pcVar6;
      pcVar7[1].next = pcVar4;
      pcVar7 = pcVar7 + 3;
    } while (pcVar7 != list_hdr + 0x62);
    co_list_push_back(&vif_info_tab[uVar8].sta_list,list_hdr);
    *(undefined *)((int)&list_hdr[7].next + 1) = 1;
    uVar1 = '\0';
  }
  return uVar1;
}



void sta_mgmt_unregister(uint8_t sta_idx)

{
  sta_info_tag *sta_entry;
  undefined3 in_register_00002029;
  
  sta_entry = sta_info_tab + CONCAT31(in_register_00002029,sta_idx);
  co_list_extract(&vif_info_tab[sta_info_tab[CONCAT31(in_register_00002029,sta_idx)].inst_nbr].
                   sta_list,(co_list_hdr *)sta_entry);
  sta_mgmt_entry_init(sta_entry);
  co_list_push_back((co_list *)&sta_info_env,(co_list_hdr *)sta_entry);
  return;
}



void sta_mgmt_add_key(mm_key_add_req *param,uint8_t hw_key_idx)

{
  uint8_t uVar1;
  uint uVar2;
  
  uVar2 = (uint)param->sta_idx;
  sta_info_tab[uVar2].sta_sec_info.key_info.hw_key_idx = hw_key_idx;
  sta_info_tab[uVar2].sta_sec_info.key_info.cipher = param->cipher_suite;
  sta_info_tab[uVar2].sta_sec_info.key_info.key_idx = param->key_idx;
  memset(&sta_info_tab[uVar2].sta_sec_info,0,0x48);
  uVar1 = sta_info_tab[uVar2].sta_sec_info.key_info.cipher;
  if (uVar1 == '\x01') {
    *(undefined4 *)&sta_info_tab[uVar2].sta_sec_info.key_info.tx_pn = 0;
    *(undefined4 *)((int)&sta_info_tab[uVar2].sta_sec_info.key_info.tx_pn + 4) = 0;
    *(uint32_t *)sta_info_tab[uVar2].sta_sec_info.key_info.u = (param->key).array[4];
    *(uint32_t *)(sta_info_tab[uVar2].sta_sec_info.key_info.u + 4) = (param->key).array[5];
    *(uint32_t *)(sta_info_tab[uVar2].sta_sec_info.key_info.u + 8) = (param->key).array[6];
    *(uint32_t *)(sta_info_tab[uVar2].sta_sec_info.key_info.u + 0xc) = (param->key).array[7];
  }
  else {
    if ((uVar1 == '\0') || (uVar1 == '\x03')) {
      next = next * 0x41c64e6d + 0x3039;
      *(ulong *)&sta_info_tab[uVar2].sta_sec_info.key_info.tx_pn = next >> 0x10;
      *(undefined4 *)((int)&sta_info_tab[uVar2].sta_sec_info.key_info.tx_pn + 4) = 0;
    }
    else {
      *(undefined4 *)&sta_info_tab[uVar2].sta_sec_info.key_info.tx_pn = 0;
      *(undefined4 *)((int)&sta_info_tab[uVar2].sta_sec_info.key_info.tx_pn + 4) = 0;
    }
  }
  sta_info_tab[uVar2].sta_sec_info.key_info.valid = true;
  *(sta_mgmt_sec_info **)&sta_info_tab[uVar2].sta_sec_info.pairwise_key =
       &sta_info_tab[uVar2].sta_sec_info;
  return;
}



void sta_mgmt_del_key(sta_info_tag *sta)

{
  (sta->sta_sec_info).key_info.valid = false;
  (sta->sta_sec_info).pairwise_key = (key_info_tag *)0x0;
  sta->ctrl_port_state = '\x01';
  return;
}



int sta_mgmt_send_postponed_frame(vif_info_tag *p_vif_entry,sta_info_tag *p_sta_entry,int limit)

{
  uint8_t access_category;
  int iVar1;
  _Bool _Var2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  txdesc *txdesc;
  int iStack36;
  int stop;
  
  iVar1 = 0;
  while( true ) {
    txdesc = (txdesc *)(p_sta_entry->tx_desc_post).first;
    if (txdesc == (txdesc *)0x0) {
      return iVar1;
    }
    iStack36 = 0;
    _Var2 = txl_cntrl_tx_check(p_vif_entry);
    if (CONCAT31(extraout_var,_Var2) == 0) {
      return iVar1;
    }
    _Var2 = apm_tx_int_ps_check(txdesc);
    if (CONCAT31(extraout_var_00,_Var2) == 0) {
      return iVar1;
    }
    txdesc = apm_tx_int_ps_get_postpone(p_vif_entry,p_sta_entry,&iStack36);
    if (iStack36 != 0) break;
    if (txdesc == (txdesc *)0x0) {
      txdesc = (txdesc *)co_list_pop_front(&p_sta_entry->tx_desc_post);
    }
    access_category = (txdesc->host).tid;
    *(undefined *)((int)&txdesc[1].host.packet_addr + 1) = 0;
    iVar1 = iVar1 + 1;
    txl_cntrl_push_int(txdesc,access_category);
    if ((limit != 0) && (iVar1 == limit)) {
      return iVar1;
    }
  }
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void td_timer_end(void *env)

{
  int iVar1;
  bool bVar2;
  undefined *puVar3;
  undefined *puVar4;
  
  iVar1 = _DAT_44b00120;
  if (*(char *)((int)env + 0x23) != '\0') {
    bVar2 = *(int *)((int)env + 0x10) != 0;
    if (*(int *)((int)env + 0x14) != 0) {
      bVar2 = (bool)(bVar2 | 2);
    }
    if (*(int *)((int)env + 0x18) != 0) {
      bVar2 = (bool)(bVar2 | 4);
    }
    if (*(int *)((int)env + 0x1c) != 0) {
      bVar2 = (bool)(bVar2 | 8);
    }
    if (((*(byte *)((int)env + 0x21) ^ bVar2) & 0xc) != 0) {
      if ((bVar2 & 4U) == 0) {
        puVar3 = &UNK_23074b2c;
      }
      else {
        puVar3 = &UNK_23074b28;
      }
      if ((bVar2 & 8U) == 0) {
        puVar4 = &UNK_23074b2c;
      }
      else {
        puVar4 = &UNK_23074b30;
      }
      printf(&DAT_23074b34,puVar3,puVar4);
      ps_traffic_status_update(*(uint8_t *)((int)env + 0x20),bVar2 & 0xc);
    }
    *(bool *)((int)env + 0x21) = bVar2;
  }
  *(undefined4 *)((int)env + 0x10) = 0;
  *(undefined4 *)((int)env + 0x14) = 0;
  *(undefined4 *)((int)env + 0x18) = 0;
  *(undefined4 *)((int)env + 0x1c) = 0;
  *(bool *)((int)env + 0x23) = vif_info_tab[*(byte *)((int)env + 0x20)].chan_ctxt == DAT_4201d1f8;
  mm_timer_set((mm_timer_tag *)env,iVar1 + 1000000);
  return;
}



void td_reset(uint8_t vif_index)

{
  td_env_tag *__s;
  undefined3 in_register_00002029;
  int iVar1;
  
  iVar1 = CONCAT31(in_register_00002029,vif_index);
  __s = td_env + iVar1;
  printf(&DAT_23074b00,iVar1);
  if (td_env[iVar1].is_on != false) {
    mm_timer_clear((mm_timer_tag *)__s);
  }
  memset(__s,0,0x24);
  td_env[iVar1].td_timer.cb = td_timer_end;
  *(td_env_tag **)&td_env[iVar1].td_timer.env = __s;
  td_env[iVar1].vif_index = vif_index;
  return;
}



void td_init(void)

{
  printf(&DAT_23074af4);
  td_reset('\0');
  td_reset('\x01');
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void td_start(uint8_t vif_index)

{
  int iVar1;
  undefined3 in_register_00002029;
  int iVar2;
  
  iVar1 = _DAT_44b00120;
  iVar2 = CONCAT31(in_register_00002029,vif_index);
  if (td_env[iVar2].is_on == false) {
    printf(&DAT_23074b14,iVar2);
    td_env[iVar2].is_on = true;
    mm_timer_set((mm_timer_tag *)(td_env + iVar2),iVar1 + 1000000);
    return;
  }
  return;
}



void td_pck_ind(uint8_t vif_index,uint8_t sta_index,_Bool rx)

{
  undefined3 in_register_00002029;
  int iVar1;
  undefined3 in_register_00002031;
  
  iVar1 = CONCAT31(in_register_00002029,vif_index);
  if (CONCAT31(in_register_00002031,rx) != 0) {
    td_env[iVar1].pck_cnt_rx = td_env[iVar1].pck_cnt_rx + 1;
    return;
  }
  td_env[iVar1].pck_cnt_tx = td_env[iVar1].pck_cnt_tx + 1;
  return;
}



void td_pck_ps_ind(uint8_t vif_index,_Bool rx)

{
  undefined3 in_register_00002029;
  int iVar1;
  undefined3 in_register_0000202d;
  
  iVar1 = CONCAT31(in_register_00002029,vif_index);
  if (CONCAT31(in_register_0000202d,rx) != 0) {
    td_env[iVar1].pck_cnt_rx_ps = td_env[iVar1].pck_cnt_rx_ps + 1;
    return;
  }
  td_env[iVar1].pck_cnt_tx_ps = td_env[iVar1].pck_cnt_tx_ps + 1;
  return;
}



void bl_tpc_update_power_table(int8_t *power_table)

{
  char cVar1;
  int32_t *piVar2;
  char *pcVar3;
  int iStack72;
  int32_t power_os [14];
  
  trpc_update_power((int8_t (*) [8])power_table);
  pcVar3 = power_table + 0x18;
  piVar2 = &iStack72;
  while (pcVar3 != power_table + 0x26) {
    cVar1 = *pcVar3;
    pcVar3 = pcVar3 + 1;
    *piVar2 = (int)cVar1;
    piVar2 = piVar2 + 1;
  }
  rf_pri_update_power_offset(&iStack72);
  return;
}



void bl_tpc_power_table_get(int8_t *power_table_config)

{
  int iVar1;
  
  trpc_power_get(power_table_config);
  iVar1 = 0x18;
  do {
    power_table_config[iVar1] = '\0';
    iVar1 = iVar1 + 1;
  } while (iVar1 != 0x26);
  return;
}



void bl_tpc_update_power_rate_11b(int8_t *power_rate_table)

{
  int8_t *piVar1;
  int8_t *piVar2;
  int iVar3;
  
  iVar3 = 0;
  do {
    piVar1 = power_rate_table + iVar3;
    piVar2 = txpwr_vs_rate_table + iVar3;
    iVar3 = iVar3 + 1;
    *piVar2 = *piVar1;
  } while (iVar3 != 4);
  return;
}



void bl_tpc_update_power_rate_11g(int8_t *power_rate_table)

{
  int8_t *piVar1;
  int iVar2;
  int8_t *piVar3;
  
  iVar2 = 0;
  piVar3 = txpwr_vs_rate_table;
  do {
    piVar1 = power_rate_table + iVar2;
    iVar2 = iVar2 + 1;
    piVar3[8] = *piVar1;
    piVar3 = piVar3 + 1;
  } while (iVar2 != 8);
  return;
}



void bl_tpc_update_power_rate_11n(int8_t *power_rate_table)

{
  int8_t *piVar1;
  int iVar2;
  int8_t *piVar3;
  
  iVar2 = 0;
  piVar3 = txpwr_vs_rate_table;
  do {
    piVar1 = power_rate_table + iVar2;
    iVar2 = iVar2 + 1;
    piVar3[0x10] = *piVar1;
    piVar3 = piVar3 + 1;
  } while (iVar2 != 8);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void tpc_update_tx_power(int8_t pwr)

{
  uint8_t uVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  
  uVar1 = trpc_get_default_power_idx('\x02','\0');
  _DAT_44b000a0 = CONCAT31(extraout_var,uVar1) | _DAT_44b000a0 & 0xffffff00;
  uVar1 = trpc_get_default_power_idx('\0','\0');
  _DAT_44b000a0 = CONCAT31(extraout_var_00,uVar1) << 8 | _DAT_44b000a0 & 0xffff00ff;
  return;
}



// WARNING: Type propagation algorithm not settling

void tpc_update_vif_tx_power(vif_info_tag *vif,int8_t *pwr,uint8_t *idx)

{
  char cVar1;
  char cVar2;
  _Bool _Var3;
  undefined3 extraout_var;
  int *piVar4;
  
  if (*pwr == '\x7f') {
    return;
  }
  cVar1 = vif->tx_power;
  phy_get_rf_gain_idx(pwr,idx);
  cVar2 = *pwr;
  vif->tx_power = cVar2;
  if (vif->user_tx_power < cVar2) {
    *pwr = vif->user_tx_power;
    phy_get_rf_gain_idx(pwr,idx);
  }
  if (*pwr != cVar1) {
    piVar4 = (int *)(vif->sta_list).first;
    while (piVar4 != (int *)0x0) {
      *(byte *)((int)piVar4 + 0x11a) = *(byte *)((int)piVar4 + 0x11a) | 0x10;
      piVar4 = (int *)*piVar4;
    }
    if (vif->chan_ctxt != (chan_ctxt_tag *)0x0) {
      chan_update_tx_power(vif->chan_ctxt);
      _Var3 = chan_is_on_channel(vif);
      if (CONCAT31(extraout_var,_Var3) != 0) {
        tpc_update_tx_power((vif->chan_ctxt->channel).tx_power);
        return;
      }
    }
  }
  return;
}



uint8_t tpc_get_vif_tx_power_vs_rate(uint32_t rate_config)

{
  uint8_t formatmod;
  byte mcs;
  
  mcs = (byte)rate_config & 0x7f;
  if ((rate_config >> 0xb & 7) == 0) {
    formatmod = (uint8_t)(rate_config & 0x7c);
    if ((rate_config & 0x7c) != 0) {
      mcs = mcs - 4;
      formatmod = '\x01';
    }
  }
  else {
    formatmod = '\x02';
  }
  formatmod = trpc_get_default_power_idx(formatmod,mcs);
  return formatmod;
}



void tpc_update_frame_tx_power(vif_info_tag *vif,txl_frame_desc_tag *frame)

{
  uint32_t uVar1;
  uint8_t uVar2;
  undefined3 extraout_var;
  
  uVar1 = (((frame->txdesc).lmac.hw_desc)->thd).policyentryaddr;
  uVar2 = tpc_get_vif_tx_power_vs_rate(*(uint32_t *)(uVar1 + 0x14));
  *(undefined4 *)(uVar1 + 0x24) = CONCAT31(extraout_var,uVar2);
  return;
}



void txl_int_fake_transfer(txdesc *txdesc,uint8_t access_category)

{
  undefined3 in_register_0000202d;
  int iVar1;
  txl_buffer_tag *ptVar2;
  
  ptVar2 = (txdesc->lmac).buffer;
  (ptVar2->tbd).upatterntx = 0xcafefade;
  iVar1 = CONCAT31(in_register_0000202d,access_category) + 0x16;
  ptVar2->txdesc = txdesc;
  if ((&txl_buffer_env.buf_idx[0].free)[iVar1 * 2] == 0) {
    *(txl_buffer_tag **)(&txl_buffer_env.buf_idx[0].free + iVar1 * 2) = ptVar2;
  }
  else {
    *(txl_buffer_tag **)((&txl_buffer_env.buf_idx[0].free_size)[iVar1 * 2] + 0x10) = ptVar2;
  }
  *(txl_buffer_tag **)(&txl_buffer_env.buf_idx[0].free_size + iVar1 * 2) = ptVar2;
  ptVar2->next = (txl_buffer_tag *)0x0;
  return;
}



void blmac_abs_timer_set(int reg_idx,uint32_t value)

{
  if (9 < reg_idx) {
    assert_err("reg_idx <= 9","module",0x26a0);
  }
  *(uint32_t *)((reg_idx + 0x112c004a) * 4) = value;
  return;
}



void txl_machdr_format(uint32_t machdrptr)

{
  uint uVar1;
  
  if ((*(byte *)(machdrptr + 0x16) & 0xf) == 0) {
    txl_cntrl_env.seqnbr = txl_cntrl_env.seqnbr + 1;
  }
  uVar1 = (uint)txl_cntrl_env.seqnbr;
  *(byte *)(machdrptr + 0x16) = (byte)(uVar1 << 4) | *(byte *)(machdrptr + 0x16) & 0xf;
  *(undefined *)(machdrptr + 0x17) = (char)((uVar1 << 4) >> 8);
  return;
}



void txl_cntrl_init(void)

{
  txl_cntrl_env_tag *ptVar1;
  undefined4 uVar2;
  undefined4 *puVar3;
  
  txl_hwdesc_init();
  txl_buffer_init();
  txl_cfm_init();
  txl_frame_init(false);
  memset(&txl_cntrl_env,0,0x58);
  ptVar1 = &txl_cntrl_env;
  puVar3 = (undefined4 *)&DAT_44a00080;
  do {
    co_list_init(&ptVar1->txlist[0].transmitting);
    ptVar1->txlist[0].last_frame_exch = (tx_hd *)0x0;
    uVar2 = *puVar3;
    ptVar1->txlist[0].chk_state = '\0';
    puVar3 = puVar3 + 1;
    ptVar1->txlist[0].bridgedmacnt = (uint16_t)uVar2;
    ptVar1 = (txl_cntrl_env_tag *)(ptVar1->txlist + 1);
  } while (puVar3 != (undefined4 *)0x44a00094);
  txl_cntrl_env.seqnbr = 0;
  return;
}



_Bool txl_cntrl_tx_check(vif_info_tag *p_vif_entry)

{
  _Bool _Var1;
  
  if (txl_cntrl_env.reset == false) {
    _Var1 = chan_is_tx_allowed(p_vif_entry);
    return _Var1;
  }
  return false;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void txl_cntrl_halt_ac(uint8_t access_category)

{
  undefined3 in_register_00002029;
  
  switch(CONCAT31(in_register_00002029,access_category)) {
  case 0:
    _DAT_44b08180 = 0x10000;
    do {
    } while ((_DAT_44b08188 >> 4 & 3) != 0);
    _DAT_44b08184 = 0x10000;
    break;
  case 1:
    _DAT_44b08180 = 0x20000;
    do {
    } while ((_DAT_44b08188 >> 8 & 3) != 0);
    _DAT_44b08184 = 0x20000;
    break;
  case 2:
    _DAT_44b08180 = 0x40000;
    do {
    } while ((_DAT_44b08188 >> 0xc & 3) != 0);
    _DAT_44b08184 = 0x40000;
    break;
  case 3:
    _DAT_44b08180 = 0x80000;
    do {
    } while ((_DAT_44b08188 >> 0x10 & 3) != 0);
    _DAT_44b08184 = 0x80000;
    break;
  case 4:
    _DAT_44b08180 = 0x8000;
    do {
    } while ((_DAT_44b08188 & 3) != 0);
    _DAT_44b08184 = 0x8000;
    break;
  default:
    assert_err("0","module",0x779);
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void txl_cntrl_flush_ac(uint8_t access_category,uint32_t status)

{
  uint uVar1;
  undefined3 in_register_00002029;
  int iVar2;
  uint uVar3;
  
  uVar1 = _DAT_44b0808c;
  iVar2 = CONCAT31(in_register_00002029,access_category);
  uVar3 = 1 << ((uint)access_category & 0x1f);
  txl_cfm_flush(access_category,txl_cfm_env.cfmlist + iVar2,status);
  txl_cfm_flush(access_category,&txl_cntrl_env.txlist[iVar2].transmitting,status);
  txl_cntrl_env.txlist[iVar2].last_frame_exch = (tx_hd *)0x0;
  txl_buffer_reset(iVar2);
  _DAT_44b08088 = uVar3;
  _DAT_44b0808c = ~uVar3 & uVar1;
  return;
}


/*
Unable to decompile 'txl_cntrl_clear_bcn_ac'
Cause: Exception while decompiling 230058de: Decompiler process died

*/

/*
Unable to decompile 'txl_cntrl_clear_all_ac'
Cause: Exception while decompiling 23005900: Decompiler process died

*/


void txl_cntrl_inc_pck_cnt(void)

{
  txl_cntrl_env.pck_cnt = txl_cntrl_env.pck_cnt + 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void txl_payload_handle(void)

{
  int iVar1;
  
  while ((_DAT_44a00024 & 0x1f) != 0) {
    iVar1 = __clzsi2(_DAT_44a00024 & 0x1f);
    _DAT_44a00020 = 1 << (0x1fU - iVar1 & 0x1f);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void txl_payload_handle_backup(void)

{
  ushort uVar1;
  uint uVar2;
  uint uVar3;
  txl_buffer_tag *ptVar4;
  char *condition;
  int line;
  byte bVar5;
  uint reg_idx;
  tx_hd *ptVar6;
  undefined *puVar7;
  txdesc *txdesc;
  tx_hd *ptVar8;
  txl_buffer_env_tag *ptVar9;
  txl_cntrl_env_tag *ptVar10;
  uint uVar11;
  tx_hw_desc *ptVar12;
  
  ptVar9 = &txl_buffer_env;
  ptVar10 = &txl_cntrl_env;
  uVar3 = 0;
  while (ptVar4 = ptVar9->list[0].first, ptVar4 == (txl_buffer_tag *)0x0) {
LAB_230059f6:
    uVar3 = uVar3 + 1;
    ptVar9 = (txl_buffer_env_tag *)&ptVar9->buf_idx[0].free_size;
    ptVar10 = (txl_cntrl_env_tag *)(ptVar10->txlist + 1);
    if (uVar3 == 5) {
      return;
    }
  }
  uVar2 = uVar3 & 0xff;
  ptVar9->list[0].first = ptVar4->next;
  uVar11 = 1 << (uVar3 & 0x1f);
  do {
    txdesc = ptVar4->txdesc;
    if ((txdesc->host).packet_addr != 0) {
      if (uVar3 == 4) {
        reg_idx = (uint)(txdesc->host).vif_idx;
        if ((*(byte *)((int)&ptVar4[1].length + 1) >> 5 & 1) == 0) {
          bVar5 = vif_info_tab[reg_idx].u[0x2ea] & 0xfd;
        }
        else {
          bVar5 = vif_info_tab[reg_idx].u[0x2ea] | 2;
        }
        vif_info_tab[reg_idx].u[0x2ea] = bVar5;
      }
      if ((txdesc->host).tid == -1) {
        uVar1 = (txdesc->host).flags;
        if ((((uVar1 & 8) != 0) && ((*(byte *)&ptVar4[1].length & 0xdc) == 0x10)) &&
           (*(short *)((int)&ptVar4[1].dma_desc[0].src + 2) == 0)) {
          (txdesc->host).flags = uVar1 | 0x20;
          rxu_cntrl_monitor_pm((mac_addr *)&ptVar4[1].lenheader);
        }
        txl_machdr_format((uint32_t)(ptVar4 + 1));
      }
      ptVar4 = (txdesc->lmac).buffer;
      ptVar12 = (txdesc->lmac).hw_desc;
      if (((txdesc->host).flags & 8) == 0) {
        txu_cntrl_tkip_mic_append(txdesc,(uint8_t)uVar2);
        (ptVar12->thd).macctrlinfo1 = (ptVar4->buffer_control).mac_control_info;
      }
      else {
        (ptVar12->thd).macctrlinfo2 = (ptVar12->thd).macctrlinfo2 & 0xff87ffff;
        bVar5 = *(byte *)&ptVar4[1].lenheader;
        (ptVar12->thd).statinfo = 0;
        (ptVar12->thd).macctrlinfo1 = (uint)((bVar5 & 1) == 0) << 9;
      }
      *(txl_buffer_control **)&(ptVar12->thd).policyentryaddr = &ptVar4->buffer_control;
      (ptVar12->thd).phyctrlinfo = (ptVar4->buffer_control).phy_control_info;
    }
    ptVar10->txlist[0].bridgedmacnt = ptVar10->txlist[0].bridgedmacnt + 1;
    ptVar6 = ptVar10->txlist[0].last_frame_exch;
    ptVar8 = &((txdesc->lmac).hw_desc)->thd;
    if (ptVar6 == (tx_hd *)0x0) {
      reg_idx = uVar3;
      if (uVar2 == 2) {
        if ((_DAT_44b08188 >> 0xc & 3) == 2) {
          line = 0x23c;
          condition = "blmac_tx_ac_2_state_getf() != 2";
          goto LAB_23005bec;
        }
        _DAT_44b08180 = 0x800;
        puVar7 = (undefined *)0x61a80;
        _DAT_44b081a4 = ptVar8;
      }
      else {
        if (2 < uVar2) {
          if (uVar2 == 3) {
            if ((_DAT_44b08188 >> 0x10 & 3) != 2) {
              _DAT_44b08180 = 0x1000;
              _DAT_44b081a8 = ptVar8;
              goto LAB_23005c4c;
            }
            line = 0x236;
            condition = "blmac_tx_ac_3_state_getf() != 2";
          }
          else {
            if (uVar2 != 4) goto LAB_23005b9a;
            if ((_DAT_44b08188 & 3) != 2) {
              _DAT_44b08180 = 0x100;
              reg_idx = 4;
              puVar7 = (undefined *)0xc350;
              _DAT_44b08198 = ptVar8;
              goto LAB_23005c08;
            }
            line = 0x22f;
            condition = "blmac_tx_bcn_state_getf() != 2";
          }
LAB_23005bec:
          assert_rec(condition,"module",line);
          goto LAB_23005b5e;
        }
        if (uVar2 == 1) {
          if ((_DAT_44b08188 >> 8 & 3) == 2) {
            line = 0x242;
            condition = "blmac_tx_ac_1_state_getf() != 2";
            goto LAB_23005bec;
          }
          _DAT_44b08180 = 0x400;
          puVar7 = &DAT_001e8480;
          _DAT_44b081a0 = ptVar8;
        }
        else {
LAB_23005b9a:
          if ((_DAT_44b08188 >> 4 & 3) == 2) {
            line = 0x248;
            condition = "blmac_tx_ac_0_state_getf() != 2";
            goto LAB_23005bec;
          }
          _DAT_44b08180 = 0x200;
          _DAT_44b0819c = ptVar8;
LAB_23005c4c:
          puVar7 = (undefined *)0x30d40;
        }
      }
LAB_23005c08:
      blmac_abs_timer_set(reg_idx,(uint32_t)(puVar7 + _DAT_44b00120));
      _DAT_44b0808c = uVar11 | _DAT_44b0808c;
      _DAT_44b08088 = uVar11;
    }
    else {
      *(tx_hd **)&ptVar6->nextfrmexseq_ptr = ptVar8;
      if (uVar2 == 2) {
        _DAT_44b08180 = 8;
      }
      else {
        if (uVar2 < 3) {
          if (uVar2 == 1) {
            _DAT_44b08180 = 4;
          }
          else {
LAB_23005b26:
            _DAT_44b08180 = 2;
          }
        }
        else {
          if (uVar2 == 3) {
            _DAT_44b08180 = 0x10;
          }
          else {
            if (uVar2 != 4) goto LAB_23005b26;
            _DAT_44b08180 = 1;
          }
        }
      }
    }
LAB_23005b5e:
    ptVar4 = ptVar9->list[0].first;
    ptVar10->txlist[0].last_frame_exch = ptVar8;
    if (ptVar4 == (txl_buffer_tag *)0x0) goto LAB_230059f6;
    ptVar9->list[0].first = ptVar4->next;
  } while( true );
}


/*
Unable to decompile 'txl_cntrl_push_int'
Cause: Exception while decompiling 23005cd2: Decompiler process died

*/

/*
Unable to decompile 'txl_cntrl_push_int_force'
Cause: Exception while decompiling 23005da4: Decompiler process died

*/

/*
Unable to decompile 'txl_cntrl_push'
Cause: Exception while decompiling 23005df2: Decompiler process died

*/


// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void txl_transmit_trigger(void)

{
  uint reg_idx;
  uint uVar1;
  int iVar2;
  uint32_t status;
  tx_hw_desc *ptVar3;
  uint32_t uVar4;
  txdesc *txdesc;
  co_list *list;
  
  if ((_DAT_44b08078 & 0x7c0) == 0) {
    return;
  }
  iVar2 = __clzsi2(_DAT_44b08078 & 0x7c0);
  reg_idx = 0x19U - iVar2 & 0xff;
  if (4 < reg_idx) {
    assert_err("access_category < NX_TXQ_CNT","module",0x90b);
  }
  _DAT_44b0807c = 1 << (reg_idx + 6 & 0x1f);
  list = &txl_cntrl_env.txlist[reg_idx].transmitting;
  uVar1 = ~(1 << (0x19U - iVar2 & 0x1f));
  while( true ) {
    txdesc = (txdesc *)list->first;
    if (txdesc == (txdesc *)0x0) {
      txl_cntrl_env.txlist[reg_idx].last_frame_exch = (tx_hd *)0x0;
      _DAT_44b0808c = uVar1 & _DAT_44b0808c;
      return;
    }
    ptVar3 = (txdesc->lmac).hw_desc;
    status = (ptVar3->thd).statinfo;
    if (-1 < (int)status) break;
    if (((txdesc->host).packet_addr != 0) && ((txdesc->lmac).buffer != (txl_buffer_tag *)0x0)) {
      (txdesc->lmac).buffer = (txl_buffer_tag *)0x0;
    }
    ptVar3->cfm_ptr->status = status;
    uVar4 = (ptVar3->thd).nextfrmexseq_ptr;
    if (uVar4 == 0) {
      txl_cntrl_env.txlist[reg_idx].last_frame_exch = (tx_hd *)0x0;
      _DAT_44b0808c = _DAT_44b0808c & uVar1;
    }
    else {
      if (-1 < *(int *)(uVar4 + 0x3c)) {
        blmac_abs_timer_set(reg_idx,_DAT_44b00120 + TX_TIMEOUT[reg_idx]);
        return;
      }
    }
    co_list_pop_front(list);
    if ((txdesc->host).packet_addr == 0) {
      txl_frame_cfm(txdesc);
    }
    else {
      txl_cfm_push(txdesc,status,(uint8_t)reg_idx);
    }
    blmac_abs_timer_set(reg_idx,_DAT_44b00120 + TX_TIMEOUT[reg_idx]);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void txl_reset(void)

{
  uint8_t access_category;
  uint16_t uVar1;
  txl_cntrl_env_tag *ptVar2;
  undefined4 *puVar3;
  undefined4 uVar4;
  uint uVar5;
  co_list *list;
  txl_cfm_env_tag *list_00;
  
  uVar1 = txl_cntrl_env.seqnbr;
  ke_evt_clear(0x1f000);
  do {
  } while ((_DAT_44a00010 & 0xffff) != 0xffff);
  txl_cntrl_env.reset = true;
  list_00 = &txl_cfm_env;
  list = &txl_cntrl_env.txlist[0].transmitting;
  uVar5 = 0;
  do {
    _DAT_44a00020 = 1 << (uVar5 & 0x1f);
    access_category = (uint8_t)uVar5;
    txl_cfm_flush(access_category,(co_list *)list_00,0x40000000);
    uVar5 = uVar5 + 1;
    txl_cfm_flush(access_category,list,0x40000000);
    list_00 = (txl_cfm_env_tag *)(list_00->cfmlist + 1);
    list = list + 2;
  } while (uVar5 != 5);
  txl_hwdesc_reset();
  txl_buffer_reinit();
  txl_cfm_init();
  memset(&txl_cntrl_env,0,0x58);
  ptVar2 = &txl_cntrl_env;
  puVar3 = (undefined4 *)&DAT_44a00080;
  txl_cntrl_env.seqnbr = uVar1;
  do {
    co_list_init(&ptVar2->txlist[0].transmitting);
    ptVar2->txlist[0].last_frame_exch = (tx_hd *)0x0;
    uVar4 = *puVar3;
    ptVar2->txlist[0].chk_state = '\0';
    puVar3 = puVar3 + 1;
    ptVar2->txlist[0].bridgedmacnt = (uint16_t)uVar4;
    ptVar2 = (txl_cntrl_env_tag *)(ptVar2->txlist + 1);
  } while (puVar3 != (undefined4 *)0x44a00094);
  return;
}



// WARNING: Type propagation algorithm not settling

void txl_cntrl_env_dump(void)

{
  int iVar1;
  uint32_t uVar2;
  int *piVar3;
  int iVar4;
  int *piVar5;
  co_list *list;
  
  iVar1 = 4;
  do {
    list = (co_list *)((int)&txl_cntrl_env.txlist[0].last_frame_exch + iVar1);
    uVar2 = co_list_cnt(list);
    if (uVar2 != 0) {
      piVar5 = (int *)list->first;
      piVar3 = piVar5;
      while (piVar3 != (int *)0x0) {
        piVar3 = (int *)*piVar3;
      }
      while (piVar5 != (int *)0x0) {
        iVar4 = *(int *)(piVar5[0x1b] + 0x10);
        while (iVar4 != 0) {
          iVar4 = *(int *)(iVar4 + 4);
        }
        piVar5 = (int *)*piVar5;
      }
    }
    iVar1 = iVar1 + 0x10;
  } while (iVar1 != 0x54);
  return;
}



void txl_frame_init_desc(txl_frame_desc_tag *frame,txl_buffer_tag *buffer,tx_hw_desc *hwdesc,
                        txl_buffer_control *bufctrl)

{
  memset(frame,0,0x2d8);
  (hwdesc->thd).upatterntx = 0xcafebabe;
  *(txl_buffer_tag **)&(hwdesc->thd).field_4 = buffer + 1;
  (hwdesc->thd).frmlifetime = 0;
  (hwdesc->thd).optlen[0] = 0;
  (hwdesc->thd).optlen[1] = 0;
  (hwdesc->thd).optlen[2] = 0;
  *(undefined4 *)bufctrl->field_0 = 0xbadcab1e;
  (frame->txdesc).lmac.hw_desc = hwdesc;
  (frame->txdesc).lmac.buffer = buffer;
  (frame->txdesc).umac.buf_control = bufctrl;
  frame->type = '\x01';
  return;
}



// WARNING: Type propagation algorithm not settling

void txl_frame_init(_Bool reset)

{
  tx_hw_desc *ptVar1;
  txl_frame_desc_tag *__s;
  uint8_t uVar2;
  byte bVar3;
  undefined3 in_register_00002029;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  txl_buffer_control *ptVar4;
  uint32_t *puVar5;
  int iVar6;
  
  co_list_init((co_list *)&txl_frame_env);
  co_list_init(&txl_frame_env.desc_done);
  __s = txl_frame_desc;
  ptVar1 = txl_frame_hwdesc_pool;
  puVar5 = txl_frame_pool;
  ptVar4 = txl_frame_buf_ctrl;
  iVar6 = 0;
  do {
    if ((CONCAT31(in_register_00002029,reset) == 0) || ((&__s->type)[1] == '\0')) {
      memset(__s,0,0x2d8);
      (ptVar1->thd).upatterntx = 0xcafebabe;
      (ptVar1->thd).frmlifetime = 0;
      (ptVar1->thd).optlen[0] = 0;
      (ptVar1->thd).optlen[1] = 0;
      (ptVar1->thd).optlen[2] = 0;
      *(undefined4 *)ptVar4->field_0 = 0xbadcab1e;
      *(uint32_t **)&(__s->txdesc).lmac.buffer = puVar5;
      (__s->txdesc).umac.buf_control = ptVar4;
      (__s->txdesc).lmac.hw_desc = ptVar1;
      ptVar1->cfm_ptr = txl_frame_hwdesc_cfms + iVar6;
      *(txl_buffer_tag **)&(ptVar1->thd).field_4 = (txl_buffer_tag *)puVar5 + 1;
      __s->type = '\0';
      co_list_push_back((co_list *)&txl_frame_env,(co_list_hdr *)__s);
    }
    iVar6 = iVar6 + 1;
    __s = __s + 1;
    ptVar1 = ptVar1 + 1;
    puVar5 = (uint32_t *)(((txl_buffer_tag *)puVar5)[1].buffer_control.field_0 + 0x10);
    ptVar4 = ptVar4 + 1;
  } while (iVar6 != 4);
  txl_buffer_control_24G.field_0._0_4_ = 0xbadcab1e;
  txl_buffer_control_24G.mac_control_info = 0;
  txl_buffer_control_24G.phy_control_info = 0;
  uVar2 = phy_get_ntx();
  txl_buffer_control_24G.field_0._4_4_ = CONCAT31(extraout_var,uVar2) << 0xe;
  bVar3 = phy_get_ntx();
  txl_buffer_control_24G.field_0._8_4_ = (1 << ((uint)bVar3 + 1 & 0x1f)) + -1;
  txl_buffer_control_24G.field_0._16_4_ = 0xffff0704;
  txl_buffer_control_24G.field_0._20_4_ = 0x400;
  txl_buffer_control_24G.field_0._12_4_ = 0;
  txl_buffer_control_24G.field_0._24_4_ = 0;
  txl_buffer_control_24G.field_0._28_4_ = 0;
  txl_buffer_control_24G.field_0._32_4_ = 0;
  txl_buffer_control_24G.field_0._40_4_ = 0;
  txl_buffer_control_24G.field_0._44_4_ = 0;
  txl_buffer_control_24G.field_0._48_4_ = 0;
  txl_buffer_control_5G.field_0._0_4_ = 0xbadcab1e;
  txl_buffer_control_5G.mac_control_info = 0;
  txl_buffer_control_5G.phy_control_info = 0;
  uVar2 = phy_get_ntx();
  txl_buffer_control_5G.field_0._4_4_ = CONCAT31(extraout_var_00,uVar2) << 0xe;
  bVar3 = phy_get_ntx();
  txl_buffer_control_5G.field_0._8_4_ = (1 << ((uint)bVar3 + 1 & 0x1f)) + -1;
  txl_buffer_control_5G.field_0._12_4_ = 0;
  txl_buffer_control_5G.field_0._16_4_ = 0xffff0704;
  txl_buffer_control_5G.field_0._20_4_ = iVar6;
  txl_buffer_control_5G.field_0._24_4_ = 0;
  txl_buffer_control_5G.field_0._28_4_ = 0;
  txl_buffer_control_5G.field_0._32_4_ = 0;
  txl_buffer_control_5G.field_0._40_4_ = 0;
  txl_buffer_control_5G.field_0._44_4_ = 0;
  txl_buffer_control_5G.field_0._48_4_ = 0;
  return;
}



// WARNING: Type propagation algorithm not settling

txl_frame_desc_tag * txl_frame_get(int type,int len)

{
  txl_frame_desc_tag *ptVar1;
  tx_hw_desc *ptVar2;
  uint8_t uVar3;
  undefined3 extraout_var;
  uint32_t uVar4;
  uint32_t uVar5;
  txl_buffer_control *__src;
  txl_buffer_control *__dest;
  txl_buffer_tag *ptVar6;
  
  ptVar1 = (txl_frame_desc_tag *)co_list_pop_front((co_list *)&txl_frame_env);
  if (ptVar1 == (txl_frame_desc_tag *)0x0) {
    tx_count = tx_count + 1;
    if (tx_count == 10) {
      tx_count = 0;
      rx_count = 2;
      uVar4 = co_list_cnt((co_list *)&txl_frame_env);
      uVar5 = co_list_cnt(&txl_frame_env.desc_done);
      if ((uVar5 | uVar4) == 0) {
        txl_cntrl_clear_all_ac();
      }
    }
  }
  else {
    if (rx_count == 1) {
      rx_count = 0;
      mac_hw_reset = '\x01';
      vTaskEnterCritical();
      assert_rec("MAC HW RESET include tx and rx","tx rx",0x10b);
      vTaskDelay(200);
      ptVar1 = (txl_frame_desc_tag *)0x0;
      vTaskExitCritical();
    }
    else {
      if (rx_count != 0) {
        rx_count = rx_count - 1;
      }
      ptVar2 = (ptVar1->txdesc).lmac.hw_desc;
      ptVar6 = (ptVar1->txdesc).lmac.buffer;
      (ptVar2->thd).frmlen = len + 4;
      (ptVar2->thd).field_5 = (ptVar2->thd).field_4 + len + -1;
      __dest = &ptVar6->buffer_control;
      if (type == 0) {
        __src = &txl_buffer_control_24G;
      }
      else {
        __src = __dest;
        if (type == 1) {
          __src = &txl_buffer_control_5G;
        }
      }
      memcpy(__dest,__src,0x34);
      uVar3 = tpc_get_vif_tx_power_vs_rate(*(uint32_t *)((ptVar6->buffer_control).field_0 + 0x14));
      *(uint *)((ptVar6->buffer_control).field_0 + 0x24) = CONCAT31(extraout_var,uVar3);
      *(txl_buffer_control **)&(ptVar2->thd).policyentryaddr = __dest;
      (ptVar2->thd).phyctrlinfo = 0;
      (ptVar2->thd).macctrlinfo2 = 0;
      (ptVar2->thd).field_3 = 0;
      (ptVar1->cfm).cfm_func = (cfm_func_ptr *)0x0;
      (ptVar1->cfm).env = (void *)0x0;
    }
  }
  return ptVar1;
}



_Bool txl_frame_push(txl_frame_desc_tag *frame,uint8_t ac)

{
  byte bVar1;
  tx_hw_desc *ptVar2;
  _Bool _Var3;
  
  ptVar2 = (frame->txdesc).lmac.hw_desc;
  if (((ptVar2->thd).field_4 & 1) != 0) {
    assert_err("(thd->datastartptr & 0x01) == 0","module",0x182);
  }
  (ptVar2->thd).nextfrmexseq_ptr = 0;
  (ptVar2->thd).nextmpdudesc_ptr = 0;
  (ptVar2->thd).macctrlinfo2 = (ptVar2->thd).macctrlinfo2 & 0xff87ffff;
  bVar1 = *(byte *)((ptVar2->thd).field_4 + 4);
  (ptVar2->thd).statinfo = 0;
  (ptVar2->thd).macctrlinfo1 = (uint)((bVar1 & 1) == 0) << 9;
  _Var3 = txl_cntrl_push_int((txdesc *)frame,ac);
  return _Var3;
}



_Bool txl_frame_push_force(txl_frame_desc_tag *frame,uint8_t ac)

{
  byte bVar1;
  tx_hw_desc *ptVar2;
  _Bool _Var3;
  
  ptVar2 = (frame->txdesc).lmac.hw_desc;
  if (((ptVar2->thd).field_4 & 1) != 0) {
    assert_err("(thd->datastartptr & 0x01) == 0","module",0x1ad);
  }
  (ptVar2->thd).nextfrmexseq_ptr = 0;
  (ptVar2->thd).nextmpdudesc_ptr = 0;
  (ptVar2->thd).macctrlinfo2 = (ptVar2->thd).macctrlinfo2 & 0xff87ffff;
  bVar1 = *(byte *)((ptVar2->thd).field_4 + 4);
  (ptVar2->thd).statinfo = 0;
  (ptVar2->thd).macctrlinfo1 = (uint)((bVar1 & 1) == 0) << 9;
  _Var3 = txl_cntrl_push_int_force((txdesc *)frame,ac);
  return _Var3;
}



void txl_frame_cfm(txdesc *txdesc)

{
  co_list_push_back(&txl_frame_env.desc_done,(co_list_hdr *)txdesc);
  ke_evt_set(0x20000);
  return;
}



void txl_frame_release(txdesc *txdesc,_Bool postponed)

{
  co_list_hdr *UNRECOVERED_JUMPTABLE;
  undefined3 in_register_0000202d;
  
  if (*(char *)&txdesc[1].host.packet_addr == '\0') {
    co_list_push_back((co_list *)&txl_frame_env,(co_list_hdr *)txdesc);
  }
  if ((CONCAT31(in_register_0000202d,postponed) != 0) &&
     (UNRECOVERED_JUMPTABLE = txdesc[1].list_hdr.next, UNRECOVERED_JUMPTABLE != (co_list_hdr *)0x0))
  {
                    // WARNING: Could not recover jumptable at 0x230065c4. Too many branches
                    // WARNING: Treating indirect jump as call
    (*(code *)UNRECOVERED_JUMPTABLE)(txdesc[1].host.pbuf_addr,0);
    return;
  }
  return;
}


/*
Unable to decompile 'txl_frame_evt'
Cause: Exception while decompiling 230065d0: Decompiler process died

*/


uint8_t txl_frame_send_null_frame(uint8_t sta_idx,cfm_func_ptr *cfm,void *env)

{
  byte bVar1;
  uint8_t uVar2;
  txl_buffer_tag *ptVar3;
  undefined3 in_register_00002029;
  int iVar4;
  txl_frame_desc_tag *frame;
  uint uVar5;
  int iVar6;
  char acStack56 [4];
  phy_channel_info phy_info;
  
  iVar4 = CONCAT31(in_register_00002029,sta_idx);
  bVar1 = sta_info_tab[iVar4].inst_nbr;
  phy_get_channel((phy_channel_info *)acStack56,'\0');
  frame = txl_frame_get((uint)(acStack56[0] != '\0'),0x18);
  if (frame != (txl_frame_desc_tag *)0x0) {
    tpc_update_frame_tx_power(vif_info_tab + bVar1,frame);
    ptVar3 = (frame->txdesc).lmac.buffer;
    *(undefined *)&ptVar3[1].length = 0x48;
    *(undefined *)((int)&ptVar3[1].length + 1) = 1;
    *(undefined *)((int)&ptVar3[1].length + 2) = 0;
    *(undefined *)((int)&ptVar3[1].length + 3) = 0;
    memcpy(&ptVar3[1].lenheader,&sta_info_tab[iVar4].mac_addr,6);
    memcpy((void *)((int)&ptVar3[1].lenpad + 2),&vif_info_tab[bVar1].mac_addr,6);
    memcpy(&ptVar3[1].next,&sta_info_tab[iVar4].mac_addr,6);
    uVar5 = (uint)txl_cntrl_env.seqnbr;
    txl_cntrl_env.seqnbr = (uint16_t)((uVar5 + 1) * 0x10000 >> 0x10);
    iVar6 = (uVar5 + 1) * 0x100000;
    *(undefined *)((int)&ptVar3[1].txdesc + 2) = (char)((uint)iVar6 >> 0x10);
    *(undefined *)((int)&ptVar3[1].txdesc + 3) = (char)((uint)iVar6 >> 0x18);
    (frame->cfm).cfm_func = cfm;
    (frame->cfm).env = env;
    uVar2 = sta_info_tab[iVar4].inst_nbr;
    (frame->txdesc).host.staid = sta_idx;
    (frame->txdesc).host.vif_idx = uVar2;
    txl_frame_push(frame,'\x03');
  }
  return (uint8_t)(frame == (txl_frame_desc_tag *)0x0);
}



// WARNING: Variable defined which should be unmapped: phy_info

uint8_t txl_frame_send_qosnull_frame(uint8_t sta_idx,uint16_t qos,cfm_func_ptr *cfm,void *env)

{
  txl_buffer_tag *ptVar1;
  uint8_t uVar2;
  undefined3 in_register_00002029;
  int iVar3;
  txl_frame_desc_tag *frame;
  mac_addr *__src;
  uint uVar4;
  char acStack56 [4];
  phy_channel_info phy_info;
  
  iVar3 = CONCAT31(in_register_00002029,sta_idx);
  uVar4 = (uint)sta_info_tab[iVar3].inst_nbr;
  phy_get_channel((phy_channel_info *)acStack56,'\0');
  frame = txl_frame_get((uint)(acStack56[0] != '\0'),0x1a);
  if (frame == (txl_frame_desc_tag *)0x0) {
    uVar2 = '\x01';
  }
  else {
    tpc_update_frame_tx_power(vif_info_tab + uVar4,frame);
    ptVar1 = (frame->txdesc).lmac.buffer;
    *(undefined *)&ptVar1[1].length = 200;
    *(undefined *)((int)&ptVar1[1].length + 1) = 0;
    *(undefined *)((int)&ptVar1[1].length + 2) = 0;
    *(undefined *)((int)&ptVar1[1].length + 3) = 0;
    memcpy(&ptVar1[1].lenheader,&sta_info_tab[iVar3].mac_addr,6);
    __src = &vif_info_tab[uVar4].mac_addr;
    memcpy((void *)((int)&ptVar1[1].lenpad + 2),__src,6);
    uVar2 = vif_info_tab[uVar4].type;
    *(undefined *)&ptVar1[1].length = 200;
    if (uVar2 == '\0') {
      *(undefined *)((int)&ptVar1[1].length + 1) = 1;
      __src = &sta_info_tab[iVar3].mac_addr;
    }
    else {
      *(undefined *)((int)&ptVar1[1].length + 1) = 2;
    }
    memcpy(&ptVar1[1].next,__src,6);
    *(char *)&ptVar1[1].dma_desc[0].src = (char)qos;
    *(undefined *)((int)&ptVar1[1].txdesc + 2) = 0;
    *(undefined *)((int)&ptVar1[1].txdesc + 3) = 0;
    *(undefined *)((int)&ptVar1[1].dma_desc[0].src + 1) = (char)(qos >> 8);
    (frame->cfm).cfm_func = cfm;
    (frame->cfm).env = env;
    uVar2 = sta_info_tab[iVar3].inst_nbr;
    (frame->txdesc).host.staid = sta_idx;
    (frame->txdesc).host.vif_idx = uVar2;
    txl_frame_push(frame,'\x03');
    uVar2 = '\0';
  }
  return uVar2;
}



uint8_t txl_frame_send_eapol_frame
                  (uint8_t sta_idx,cfm_func_ptr *cfm,void *cfm_env,uint8_t *pBuf,uint32_t pBuf_len)

{
  byte bVar1;
  uint8_t uVar2;
  ushort uVar3;
  undefined2 uVar4;
  txl_buffer_tag *ptVar5;
  undefined3 in_register_00002029;
  txl_frame_desc_tag *frame;
  key_info_tag *pkVar6;
  uint32_t uVar7;
  undefined *puVar8;
  int iVar9;
  tx_hw_desc *ptVar10;
  uint16_t uVar11;
  uint uVar12;
  dma_desc *pdVar13;
  uint uVar14;
  dma_desc *unaff_s8;
  mac_addr *pmVar15;
  mac_addr *pmVar16;
  uint uVar17;
  int iVar18;
  char acStack88 [4];
  phy_channel_info phy_info;
  mic_calc mic;
  
  iVar18 = CONCAT31(in_register_00002029,sta_idx);
  bVar1 = sta_info_tab[iVar18].inst_nbr;
  uVar17 = (uint)bVar1;
  phy_get_channel((phy_channel_info *)acStack88,'\0');
  frame = txl_frame_get((uint)(acStack88[0] != '\0'),0x100);
  if (frame == (txl_frame_desc_tag *)0x0) {
    return '\0';
  }
  (frame->txdesc).host.vif_idx = bVar1;
  (frame->txdesc).host.staid = sta_idx;
  (frame->txdesc).host.tid = '\0';
  uVar3 = sta_info_tab[iVar18].seq_nbr[0];
  sta_info_tab[iVar18].seq_nbr[0] = (ushort)(((uint)uVar3 + 1) * 0x100000 >> 0x14);
  (frame->txdesc).host.ethertype = 0x8e88;
  (frame->txdesc).host.sn = uVar3;
  pmVar15 = &sta_info_tab[iVar18].mac_addr;
  (frame->txdesc).host.eth_dest_addr.array[0] = pmVar15->array[0];
  (frame->txdesc).host.eth_dest_addr.array[1] = sta_info_tab[iVar18].mac_addr.array[1];
  (frame->txdesc).host.eth_dest_addr.array[2] = sta_info_tab[iVar18].mac_addr.array[2];
  pmVar16 = &vif_info_tab[uVar17].mac_addr;
  (frame->txdesc).host.eth_src_addr.array[0] = pmVar16->array[0];
  (frame->txdesc).host.eth_src_addr.array[1] = vif_info_tab[uVar17].mac_addr.array[1];
  (frame->txdesc).host.eth_src_addr.array[2] = vif_info_tab[uVar17].mac_addr.array[2];
  tpc_update_frame_tx_power(vif_info_tab + uVar17,frame);
  ptVar5 = (frame->txdesc).lmac.buffer;
  if ((vif_info_tab[uVar17].bss_info.valid_flags & 1) == 0) {
    *(undefined *)&ptVar5[1].length = 8;
    uVar14 = (uint)txl_cntrl_env.seqnbr;
    *(undefined *)((int)&ptVar5[1].length + 1) = 0;
    pdVar13 = ptVar5[1].dma_desc;
    txl_cntrl_env.seqnbr = (uint16_t)((uVar14 + 1) * 0x10000 >> 0x10);
    iVar9 = (uVar14 + 1) * 0x100000;
    *(undefined *)((int)&ptVar5[1].txdesc + 2) = (char)((uint)iVar9 >> 0x10);
    *(undefined *)((int)&ptVar5[1].txdesc + 3) = (char)((uint)iVar9 >> 0x18);
    uVar14 = pBuf_len + 0x20;
  }
  else {
    *(undefined *)&ptVar5[1].length = 0x88;
    *(undefined *)((int)&ptVar5[1].length + 1) = 0;
    pdVar13 = (dma_desc *)((int)&ptVar5[1].dma_desc[0].src + 2);
    uVar14 = pBuf_len + 0x22;
    iVar9 = (uint)(frame->txdesc).host.sn << 0x14;
    *(undefined *)((int)&ptVar5[1].txdesc + 2) = (char)((uint)iVar9 >> 0x10);
    *(undefined *)((int)&ptVar5[1].txdesc + 3) = (char)((uint)iVar9 >> 0x18);
    uVar2 = (frame->txdesc).host.tid;
    *(undefined *)((int)&ptVar5[1].dma_desc[0].src + 1) = 0;
    *(uint8_t *)&ptVar5[1].dma_desc[0].src = uVar2;
  }
  if (0x100 < uVar14) {
    assert_err("length<=NX_TXFRAME_LEN","module",0x591);
  }
  uVar4 = *(undefined2 *)&ptVar5[1].length;
  bVar1 = 1;
  if (vif_info_tab[uVar17].type == '\x02') {
    bVar1 = 2;
  }
  *(char *)&ptVar5[1].length = (char)uVar4;
  *(byte *)((int)&ptVar5[1].length + 1) = (byte)((ushort)uVar4 >> 8) | bVar1;
  *(undefined *)((int)&ptVar5[1].length + 2) = 0;
  *(undefined *)((int)&ptVar5[1].length + 3) = 0;
  *(uint16_t *)&ptVar5[1].lenheader = pmVar15->array[0];
  *(uint16_t *)((int)&ptVar5[1].lenheader + 2) = sta_info_tab[iVar18].mac_addr.array[1];
  *(uint16_t *)&ptVar5[1].lenpad = sta_info_tab[iVar18].mac_addr.array[2];
  *(uint16_t *)((int)&ptVar5[1].lenpad + 2) = pmVar16->array[0];
  *(uint16_t *)&ptVar5[1].flags = vif_info_tab[uVar17].mac_addr.array[1];
  *(uint16_t *)((int)&ptVar5[1].flags + 2) = vif_info_tab[uVar17].mac_addr.array[2];
  if (vif_info_tab[uVar17].type == '\x02') {
    *(uint16_t *)&ptVar5[1].next = pmVar16->array[0];
    *(uint16_t *)((int)&ptVar5[1].next + 2) = vif_info_tab[uVar17].mac_addr.array[1];
    uVar11 = vif_info_tab[uVar17].mac_addr.array[2];
  }
  else {
    *(uint16_t *)&ptVar5[1].next = pmVar15->array[0];
    *(uint16_t *)((int)&ptVar5[1].next + 2) = sta_info_tab[iVar18].mac_addr.array[1];
    uVar11 = sta_info_tab[iVar18].mac_addr.array[2];
  }
  *(uint16_t *)&ptVar5[1].txdesc = uVar11;
  iVar18 = 0;
  if ((vif_info_tab[(frame->txdesc).host.vif_idx].type != '\0') ||
     (uVar17 = (uint)(frame->txdesc).host.staid, sta_info_tab[uVar17].ctrl_port_state != '\x02'))
  goto LAB_23006b64;
  pkVar6 = *sta_info_tab[uVar17].sta_sec_info.cur_key;
  uVar2 = pkVar6->cipher;
  if (uVar2 == '\x01') {
    uVar17 = *(uint *)&pkVar6->tx_pn + 1;
    *(int *)((int)&pkVar6->tx_pn + 4) =
         (uint)(uVar17 < *(uint *)&pkVar6->tx_pn) + *(int *)((int)&pkVar6->tx_pn + 4);
    *(uint *)&pkVar6->tx_pn = uVar17;
    memcpy((frame->txdesc).host.pn,&pkVar6->tx_pn,6);
    iVar9 = 0xc;
LAB_23006cbc:
    iVar18 = 8;
  }
  else {
    if (uVar2 == '\0') {
LAB_23006a9e:
      uVar17 = *(uint *)&pkVar6->tx_pn + 1;
      *(int *)((int)&pkVar6->tx_pn + 4) =
           (uint)(uVar17 < *(uint *)&pkVar6->tx_pn) + *(int *)((int)&pkVar6->tx_pn + 4);
      *(uint *)&pkVar6->tx_pn = uVar17;
      memcpy((frame->txdesc).host.pn,&pkVar6->tx_pn,4);
      iVar9 = 4;
      iVar18 = 4;
    }
    else {
      if (uVar2 == '\x02') {
        uVar17 = *(uint *)&pkVar6->tx_pn + 1;
        *(int *)((int)&pkVar6->tx_pn + 4) =
             (uint)(uVar17 < *(uint *)&pkVar6->tx_pn) + *(int *)((int)&pkVar6->tx_pn + 4);
        *(uint *)&pkVar6->tx_pn = uVar17;
        memcpy((frame->txdesc).host.pn,&pkVar6->tx_pn,6);
        iVar9 = 8;
        goto LAB_23006cbc;
      }
      if (uVar2 == '\x03') goto LAB_23006a9e;
      iVar9 = 0;
      iVar18 = 0;
    }
  }
  iVar18 = iVar18 + iVar9;
  if (iVar18 == 0) goto LAB_23006b64;
  uVar3 = *(ushort *)&ptVar5[1].length;
  uVar14 = uVar14 + iVar18;
  *(char *)&ptVar5[1].length = (char)uVar3;
  *(byte *)((int)&ptVar5[1].length + 1) = (byte)((uint)uVar3 >> 8) | 0x40;
  uVar17 = (uint)vif_info_tab[(frame->txdesc).host.vif_idx].type;
  if (vif_info_tab[(frame->txdesc).host.vif_idx].type == 0) {
    uVar12 = (uint)(frame->txdesc).host.staid;
    if (sta_info_tab[uVar12].ctrl_port_state == '\x02') {
      pkVar6 = *sta_info_tab[uVar12].sta_sec_info.cur_key;
      uVar7 = (((frame->txdesc).lmac.hw_desc)->thd).policyentryaddr;
      uVar2 = pkVar6->cipher;
      if (uVar2 == '\x01') {
        uVar3 = (frame->txdesc).host.pn[0];
        *(ushort *)&pdVar13->src = uVar3 & 0x7f00 | 0x2000 | uVar3 >> 8;
        uVar3 = (ushort)*(byte *)(frame->txdesc).host.pn | (ushort)pkVar6->key_idx << 0xe;
LAB_23006d14:
        *(ushort *)((int)&pdVar13->src + 2) = uVar3 | 0x2000;
        uVar17 = 8;
        *(uint16_t *)&pdVar13->dest = (frame->txdesc).host.pn[1];
        *(uint16_t *)((int)&pdVar13->dest + 2) = (frame->txdesc).host.pn[2];
      }
      else {
        if (uVar2 == '\0') {
LAB_23006b32:
          *(uint16_t *)&pdVar13->src = (frame->txdesc).host.pn[0];
          *(ushort *)((int)&pdVar13->src + 2) =
               (ushort)pkVar6->key_idx << 0xe | (frame->txdesc).host.pn[1];
          uVar17 = 4;
        }
        else {
          if (uVar2 == '\x02') {
            *(uint16_t *)&pdVar13->src = (frame->txdesc).host.pn[0];
            uVar3 = (ushort)pkVar6->key_idx << 0xe;
            goto LAB_23006d14;
          }
          if (uVar2 == '\x03') goto LAB_23006b32;
        }
      }
      *(uint *)(uVar7 + 0xc) = *(uint *)(uVar7 + 0xc) & 0xffc00 | (uint)pkVar6->hw_key_idx;
    }
  }
  else {
    uVar17 = 0;
  }
  pdVar13 = (dma_desc *)((int)&pdVar13->src + uVar17);
  unaff_s8 = pdVar13;
LAB_23006b64:
  *(undefined2 *)&pdVar13->src = 0xaaaa;
  *(undefined2 *)((int)&pdVar13->src + 2) = 3;
  *(undefined2 *)&pdVar13->dest = 0;
  *(uint16_t *)((int)&pdVar13->dest + 2) = (frame->txdesc).host.ethertype;
  memcpy(&pdVar13->length,pBuf,pBuf_len);
  if ((iVar18 != 0) &&
     (pkVar6 = *sta_info_tab[(frame->txdesc).host.staid].sta_sec_info.cur_key,
     pkVar6->cipher == '\x01')) {
    me_mic_init((mic_calc *)&phy_info.info2,(uint32_t *)pkVar6->u,
                &(frame->txdesc).host.eth_dest_addr,&(frame->txdesc).host.eth_src_addr,
                (frame->txdesc).host.tid);
    me_mic_calc((mic_calc *)&phy_info.info2,(uint32_t)unaff_s8,pBuf_len + 8);
    me_mic_end((mic_calc *)&phy_info.info2);
    iVar18 = 0;
    do {
      puVar8 = (undefined *)((int)&phy_info.info2 + iVar18);
      iVar9 = iVar18 + pBuf_len + 8;
      iVar18 = iVar18 + 1;
      *(undefined *)((int)&unaff_s8->length + iVar9 + -8) = *puVar8;
    } while (iVar18 != 8);
  }
  ptVar10 = (frame->txdesc).lmac.hw_desc;
  (ptVar10->thd).field_5 = (ptVar10->thd).field_4 + -1 + uVar14;
  (ptVar10->thd).frmlen = uVar14 + 4;
  if (cfm != (cfm_func_ptr *)0x0) {
    (frame->cfm).cfm_func = cfm;
    (frame->cfm).env = cfm_env;
  }
  txl_frame_push(frame,"\x01"[(frame->txdesc).host.tid]);
  return '\0';
}



void txl_frame_dump(void)

{
  uint32_t uVar1;
  co_list_hdr cVar2;
  co_list_hdr cVar3;
  
  uVar1 = co_list_cnt((co_list *)&txl_frame_env);
  cVar2 = (co_list_hdr)txl_frame_env.desc_free.first;
  if (uVar1 != 0) {
    while (cVar3 = (co_list_hdr)txl_frame_env.desc_done.first, cVar2 != (co_list_hdr)0x0) {
      cVar2 = *(co_list_hdr *)cVar2;
    }
    while (cVar3 != (co_list_hdr)0x0) {
      cVar3 = *(co_list_hdr *)cVar3;
    }
  }
  return;
}



void txl_hwdesc_init(void)

{
  return;
}



void txl_hwdesc_reset(void)

{
  return;
}



void vif_mgmt_bcn_to_evt(void *env)

{
  if (*(int *)((int)env + 0x40) != 0) {
    chan_bcn_to_evt((vif_info_tag *)env);
    return;
  }
  return;
}



void vif_mgmt_init(void)

{
  memset(&vif_mgmt_env,0,0x14);
  co_list_init((co_list *)&vif_mgmt_env);
  co_list_init(&vif_mgmt_env.used_list);
  memset(vif_info_tab,0,0x5d8);
  vif_info_tab[0].type = '\x04';
  vif_info_tab[0].tx_power = '\x7f';
  vif_info_tab[0].user_tx_power = '\x7f';
  vif_info_tab[0].tmr_bcn_to.cb = vif_mgmt_bcn_to_evt;
  vif_info_tab[0].tmr_bcn_to.env = vif_info_tab;
  co_list_push_back((co_list *)&vif_mgmt_env,(co_list_hdr *)vif_info_tab);
  memset(vif_info_tab + 1,0,0x5d8);
  vif_info_tab[1].type = '\x04';
  vif_info_tab[1].tx_power = '\x7f';
  vif_info_tab[1].user_tx_power = '\x7f';
  vif_info_tab[1].tmr_bcn_to.cb = vif_mgmt_bcn_to_evt;
  vif_info_tab[1].tmr_bcn_to.env = vif_info_tab + 1;
  co_list_push_back((co_list *)&vif_mgmt_env,(co_list_hdr *)(vif_info_tab + 1));
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t vif_mgmt_register(mac_addr *mac_addr,uint8_t vif_type,_Bool p2p,uint8_t *vif_idx)

{
  uint8_t uVar1;
  vif_info_tag *vif_entry;
  undefined3 in_register_0000202d;
  
  if (vif_mgmt_env.free_list.first == (co_list_hdr *)0x0) {
    uVar1 = '\x01';
  }
  else {
    if (vif_mgmt_env.used_list.first == (co_list_hdr *)0x0) {
      mm_hw_info_set(mac_addr);
    }
    else {
      if (*(int *)mac_addr->array != _DAT_44b00010) {
        return '\x01';
      }
      if (((mac_addr->array[2] ^ _DAT_44b00014) & ~_DAT_44b0001c) != 0) {
        return '\x01';
      }
      mm_env.rx_filter_lmac_enable = mm_env.rx_filter_lmac_enable | 0x10;
      _DAT_44b00060 = mm_env.rx_filter_lmac_enable | mm_env.rx_filter_umac;
    }
    vif_entry = (vif_info_tag *)co_list_pop_front((co_list *)&vif_mgmt_env);
    vif_entry->type = vif_type;
    memcpy(&vif_entry->mac_addr,mac_addr,6);
    uVar1 = (char)((int)&vif_entry[-0xb4b94].key_info[1].tx_pn >> 3) * 's';
    vif_entry->txq_params[1] = 0xa43;
    vif_entry->txq_params[2] = 0x5e432;
    vif_entry->index = uVar1;
    vif_entry->txq_params[0] = 0xa47;
    vif_entry->txq_params[3] = 0x2f322;
    vif_entry->chan_ctxt = (chan_ctxt_tag *)0x0;
    (vif_entry->tbtt_switch).vif_index = uVar1;
    if (CONCAT31(in_register_0000202d,vif_type) == 0) {
      *(vif_info_tag **)&(vif_entry->tbtt_timer).env = vif_entry;
      vif_entry->u[0x1d] = 0;
      vif_mgmt_env.vif_sta_cnt = vif_mgmt_env.vif_sta_cnt + '\x01';
      (vif_entry->tbtt_timer).cb = mm_sta_tbtt;
      vif_entry->u[4] = 0xff;
      vif_entry->u[0x1e] = 0;
    }
    else {
      if (CONCAT31(in_register_0000202d,vif_type) == 2) {
        if (vif_mgmt_env.vif_ap_cnt == '\0') {
          mm_hw_ap_info_set();
        }
        vif_mgmt_env.vif_ap_cnt = vif_mgmt_env.vif_ap_cnt + '\x01';
        mm_bcn_init_vif(vif_entry);
      }
    }
    td_start(vif_entry->index);
    *vif_idx = vif_entry->index;
    co_list_push_back(&vif_mgmt_env.used_list,(co_list_hdr *)vif_entry);
    uVar1 = '\0';
  }
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void vif_mgmt_unregister(uint8_t vif_idx)

{
  vif_info_tag *__s;
  undefined3 in_register_00002029;
  int iVar1;
  
  iVar1 = CONCAT31(in_register_00002029,vif_idx);
  __s = vif_info_tab + iVar1;
  co_list_extract(&vif_mgmt_env.used_list,(co_list_hdr *)__s);
  if (vif_info_tab[iVar1].type == '\0') {
    vif_mgmt_env.vif_sta_cnt = vif_mgmt_env.vif_sta_cnt + -1;
  }
  else {
    if (vif_info_tab[iVar1].type == '\x02') {
      vif_mgmt_env.vif_ap_cnt = vif_mgmt_env.vif_ap_cnt + -1;
      if (vif_mgmt_env.vif_ap_cnt == '\0') {
        mm_hw_ap_info_reset();
      }
    }
  }
  if ((uint)vif_mgmt_env.vif_ap_cnt + (uint)vif_mgmt_env.vif_sta_cnt == 1) {
    mm_env.rx_filter_lmac_enable = mm_env.rx_filter_lmac_enable & 0xffffffef;
    _DAT_44b00060 = mm_env.rx_filter_lmac_enable | mm_env.rx_filter_umac;
    _DAT_44b00020 = vif_mgmt_env.used_list.first[0xe].next;
    _DAT_44b00024 = (uint)*(ushort *)&vif_mgmt_env.used_list.first[0xf].next;
  }
  if (vif_info_tab[iVar1].type == '\x02') {
    txl_cntrl_clear_bcn_ac();
  }
  mm_timer_clear(&vif_info_tab[iVar1].tbtt_timer);
  mm_timer_clear(&vif_info_tab[iVar1].tmr_bcn_to);
  td_reset(vif_info_tab[iVar1].index);
  memset(__s,0,0x5d8);
  vif_info_tab[iVar1].type = '\x04';
  vif_info_tab[iVar1].tx_power = '\x7f';
  vif_info_tab[iVar1].user_tx_power = '\x7f';
  vif_info_tab[iVar1].tmr_bcn_to.cb = vif_mgmt_bcn_to_evt;
  *(vif_info_tag **)&vif_info_tab[iVar1].tmr_bcn_to.env = __s;
  co_list_push_back((co_list *)&vif_mgmt_env,(co_list_hdr *)__s);
  return;
}



void vif_mgmt_add_key(mm_key_add_req *param,uint8_t hw_key_idx)

{
  uint8_t uVar1;
  uint uVar2;
  uint uVar3;
  
  uVar3 = (uint)param->inst_nbr;
  uVar2 = (uint)param->key_idx;
  vif_info_tab[uVar3].key_info[uVar2].hw_key_idx = hw_key_idx;
  vif_info_tab[uVar3].key_info[uVar2].cipher = param->cipher_suite;
  vif_info_tab[uVar3].key_info[uVar2].key_idx = param->key_idx;
  memset(vif_info_tab[uVar3].key_info + uVar2,0,0x48);
  uVar1 = vif_info_tab[uVar3].key_info[uVar2].cipher;
  if (uVar1 == '\x01') {
    *(undefined4 *)&vif_info_tab[uVar3].key_info[uVar2].tx_pn = 0;
    *(undefined4 *)((int)&vif_info_tab[uVar3].key_info[uVar2].tx_pn + 4) = 0;
    *(uint32_t *)vif_info_tab[uVar3].key_info[uVar2].u = (param->key).array[4];
    *(uint32_t *)(vif_info_tab[uVar3].key_info[uVar2].u + 4) = (param->key).array[5];
    *(uint32_t *)(vif_info_tab[uVar3].key_info[uVar2].u + 8) = (param->key).array[6];
    *(uint32_t *)(vif_info_tab[uVar3].key_info[uVar2].u + 0xc) = (param->key).array[7];
  }
  else {
    if ((uVar1 == '\0') || (uVar1 == '\x03')) {
      next = next * 0x41c64e6d + 0x3039;
      *(ulong *)&vif_info_tab[uVar3].key_info[uVar2].tx_pn = next >> 0x10;
      *(undefined4 *)((int)&vif_info_tab[uVar3].key_info[uVar2].tx_pn + 4) = 0;
    }
    else {
      *(undefined4 *)&vif_info_tab[uVar3].key_info[uVar2].tx_pn = 0;
      *(undefined4 *)((int)&vif_info_tab[uVar3].key_info[uVar2].tx_pn + 4) = 0;
    }
  }
  vif_info_tab[uVar3].key_info[uVar2].valid = true;
  vif_info_tab[uVar3].default_key = vif_info_tab[uVar3].key_info + uVar2;
  return;
}



void vif_mgmt_del_key(vif_info_tag *vif,uint8_t keyid)

{
  undefined3 in_register_0000202d;
  _Bool *p_Var1;
  int iVar2;
  
  vif->key_info[CONCAT31(in_register_0000202d,keyid)].valid = false;
  if (vif->default_key == vif->key_info + CONCAT31(in_register_0000202d,keyid)) {
    vif->default_key = (key_info_tag *)0x0;
    p_Var1 = &vif->key_info[0].valid;
    iVar2 = 0;
    do {
      if (*p_Var1 != false) {
        vif->default_key = vif->key_info + iVar2;
        return;
      }
      iVar2 = iVar2 + 1;
      p_Var1 = p_Var1 + 0x68;
    } while (iVar2 != 4);
  }
  return;
}



// WARNING: Type propagation algorithm not settling

void vif_mgmt_send_postponed_frame(vif_info_tag *p_vif_entry)

{
  sta_info_tag *p_sta_entry;
  
  p_sta_entry = (sta_info_tag *)(p_vif_entry->sta_list).first;
  while (p_sta_entry != (sta_info_tag *)0x0) {
    sta_mgmt_send_postponed_frame(p_vif_entry,p_sta_entry,0);
    p_sta_entry = *(sta_info_tag **)&p_sta_entry->list_hdr;
  }
  return;
}



// WARNING: Type propagation algorithm not settling

void vif_mgmt_reset(void)

{
  vif_info_tag *p_vif_entry;
  
  p_vif_entry = (vif_info_tag *)vif_mgmt_env.used_list.first;
  while (p_vif_entry != (vif_info_tag *)0x0) {
    vif_mgmt_send_postponed_frame(p_vif_entry);
    p_vif_entry = *(vif_info_tag **)&p_vif_entry->list_hdr;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void vif_mgmt_bcn_to_prog(vif_info_tag *p_vif_entry)

{
  mm_timer_set(&p_vif_entry->tmr_bcn_to,_DAT_44b00120 + 10000);
  return;
}



void vif_mgmt_bcn_recv(vif_info_tag *p_vif_entry)

{
  if (((ps_env.ps_on != false) && ((ps_env.prevent_sleep & 8) == 0)) &&
     (p_vif_entry->prevent_sleep == 0)) {
    mm_timer_clear(&p_vif_entry->tmr_bcn_to);
    vif_mgmt_bcn_to_evt(p_vif_entry);
    return;
  }
  return;
}


/*
Unable to decompile 'vif_mgmt_set_ap_bcn_int'
Cause: Exception while decompiling 230072dc: Decompiler process died

*/


// WARNING: Variable defined which should be unmapped: chan_idx
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void vif_mgmt_switch_channel(vif_info_tag *p_vif_entry)

{
  byte bVar1;
  uint16_t freq;
  uint8_t uVar2;
  void *pvVar3;
  scan_chan_tag *psVar4;
  undefined3 extraout_var;
  uint8_t chan_idx_00;
  uint8_t local_11 [4];
  uint8_t chan_idx;
  
  pvVar3 = ke_msg_alloc(0x58,0xd,0,3);
  local_11[0] = -1;
  chan_ctxt_unlink(p_vif_entry->index);
  freq = (p_vif_entry->csa_channel).prim20_freq;
  chan_idx_00 = (uint8_t)freq;
  psVar4 = me_freq_to_chan_ptr((p_vif_entry->csa_channel).band,freq);
  freq = (p_vif_entry->csa_channel).center1_freq;
  (p_vif_entry->bss_info).chan = psVar4;
  (p_vif_entry->bss_info).center_freq1 = freq;
  (p_vif_entry->bss_info).center_freq2 = (p_vif_entry->csa_channel).center2_freq;
  uVar2 = (p_vif_entry->csa_channel).type;
  (p_vif_entry->bss_info).phy_bw = uVar2;
  if (uVar2 == '\x04') {
    uVar2 = '\x03';
  }
  (p_vif_entry->bss_info).bw = uVar2;
  if (psVar4 == (scan_chan_tag *)0x0) {
    ebreak();
  }
  else {
    (p_vif_entry->csa_channel).tx_power = psVar4->tx_power;
    uVar2 = chan_ctxt_add(&p_vif_entry->csa_channel,local_11);
    psVar4 = (scan_chan_tag *)CONCAT31(extraout_var,uVar2);
    *(uint8_t *)((int)pvVar3 + 1) = uVar2;
    *(uint8_t *)((int)pvVar3 + 2) = local_11[0];
    chan_idx_00 = local_11[0];
    if (p_vif_entry->type != '\0') {
      if ((p_vif_entry->type == '\x02') &&
         (p_vif_entry->u[0x2eb] = 0, psVar4 == (scan_chan_tag *)0x0)) {
        chan_ctxt_link(p_vif_entry->index,local_11[0]);
        mm_bcn_env.update_ongoing = true;
      }
      goto LAB_2300745a;
    }
  }
  p_vif_entry->u[0x1d] = 0;
  if (psVar4 == (scan_chan_tag *)0x0) {
    bVar1 = p_vif_entry->u[4];
    chan_ctxt_link(p_vif_entry->index,chan_idx_00);
    mm_timer_clear(&p_vif_entry->tmr_bcn_to);
    mm_timer_set(&p_vif_entry->tbtt_timer,_DAT_44b00120 + sta_info_tab[bVar1].bcn_int);
    p_vif_entry->u[0x18] = 0;
    p_vif_entry->u[0x1e] = 1;
  }
  else {
    mm_send_connection_loss_ind(p_vif_entry);
  }
LAB_2300745a:
  ke_msg_send(pvVar3);
  return;
}



vif_info_tag * vif_mgmt_get_first_ap_inf(void)

{
  co_list_hdr cVar1;
  co_list_hdr cVar2;
  
  cVar1 = (co_list_hdr)vif_mgmt_env.used_list.first;
  cVar2 = (co_list_hdr)0x0;
  if (vif_mgmt_env.vif_ap_cnt != '\0') {
    while ((cVar2 = cVar1, cVar1 != (co_list_hdr)0x0 && (*(char *)((int)cVar1 + 0x56) != '\x02'))) {
      cVar1 = *(co_list_hdr *)cVar1;
    }
  }
  return (vif_info_tag *)cVar2;
}



void me_init(void)

{
  memset(&me_env,0,0x134);
  ke_state_set(5,0);
  scanu_init();
  apm_init();
  sm_init();
  bam_init();
  return;
}



scan_chan_tag * me_freq_to_chan_ptr(uint8_t band,uint16_t freq)

{
  int iVar1;
  byte bVar2;
  ushort *puVar3;
  undefined3 in_register_00002029;
  scan_chan_tag *psVar4;
  undefined2 in_register_0000202e;
  scan_chan_tag *psVar5;
  scan_chan_tag *psVar6;
  
  if (CONCAT31(in_register_00002029,band) == 0) {
    iVar1 = 4;
    bVar2 = me_env.chan.chan2G4_cnt;
  }
  else {
    iVar1 = 0x58;
    bVar2 = me_env.chan.chan5G_cnt;
  }
  psVar5 = (scan_chan_tag *)((int)&me_env.tx_lft + iVar1);
  psVar6 = psVar5;
  do {
    if (psVar6 == psVar5 + bVar2) {
      return (scan_chan_tag *)0x0;
    }
    psVar4 = psVar6;
    puVar3 = &psVar6->freq;
    psVar6 = psVar6 + 1;
  } while ((uint)*puVar3 != CONCAT22(in_register_0000202e,freq));
  return psVar4;
}



void michael_block(mic_calc *mic_calc_ptr,uint32_t block)

{
  uint uVar1;
  uint uVar2;
  
  uVar1 = block ^ mic_calc_ptr->mic_key_least;
  uVar2 = mic_calc_ptr->mic_key_most ^ (uVar1 >> 0xf | uVar1 << 0x11);
  uVar1 = uVar1 + uVar2;
  uVar2 = (uVar1 >> 8 & 0xff00ff | uVar1 * 0x100 & 0xff00ff00) ^ uVar2;
  uVar1 = uVar1 + uVar2;
  uVar2 = (uVar1 * 8 | uVar1 >> 0x1d) ^ uVar2;
  uVar1 = uVar1 + uVar2;
  uVar2 = (uVar1 >> 2 | uVar1 * 0x40000000) ^ uVar2;
  mic_calc_ptr->mic_key_most = uVar2;
  mic_calc_ptr->mic_key_least = uVar1 + uVar2;
  return;
}



void me_mic_init(mic_calc *mic_calc_ptr,uint32_t *mic_key_ptr,mac_addr *da,mac_addr *sa,uint8_t tid)

{
  uint32_t block;
  uint16_t uVar1;
  uint16_t uVar2;
  uint32_t block_00;
  undefined3 in_register_00002039;
  uint32_t uVar3;
  uint32_t block_01;
  
  block = *(uint32_t *)da->array;
  block_01 = (uint)tid & 7;
  uVar1 = sa->array[0];
  uVar2 = da->array[2];
  block_00 = *(uint32_t *)(sa->array + 1);
  if (CONCAT31(in_register_00002039,tid) == 0xff) {
    block_01 = 0;
  }
  mic_calc_ptr->mic_key_least = *mic_key_ptr;
  uVar3 = mic_key_ptr[1];
  mic_calc_ptr->last_m_i = 0;
  mic_calc_ptr->mic_key_most = uVar3;
  mic_calc_ptr->last_m_i_len = '\0';
  michael_block(mic_calc_ptr,block);
  michael_block(mic_calc_ptr,CONCAT22(uVar1,uVar2));
  michael_block(mic_calc_ptr,block_00);
  michael_block(mic_calc_ptr,block_01);
  return;
}



void me_mic_calc(mic_calc *mic_calc_ptr,uint32_t start_ptr,uint32_t data_len)

{
  uint8_t uVar1;
  uint block;
  uint block_00;
  uint uVar2;
  uint uVar3;
  uint *puVar4;
  uint uVar5;
  uint uVar6;
  uint *puVar7;
  uint uVar8;
  
  puVar7 = (uint *)(start_ptr & 0xfffffffc) + 1;
  block = 4 - (start_ptr & 3) & 0xff;
  uVar3 = (uint)mic_calc_ptr->last_m_i_len;
  uVar2 = *(uint *)(start_ptr & 0xfffffffc) >> ((start_ptr & 3) << 3);
  uVar8 = data_len - block;
  if (data_len < block) {
    uVar2 = uVar2 & 0xffffffffU >> ((4 - data_len) * 8 & 0x1f);
    block = data_len & 0xff;
    uVar8 = 0;
  }
  block = block + uVar3;
  block_00 = uVar2 << ((uVar3 & 3) << 3) | mic_calc_ptr->last_m_i;
  uVar6 = block_00;
  if (3 < block) {
    uVar3 = (4 - uVar3) * 8;
    uVar6 = 0;
    if (uVar3 != 0x20) {
      uVar6 = uVar2 >> (uVar3 & 0x1f);
    }
    block = block - 4;
    michael_block(mic_calc_ptr,block_00);
  }
  uVar1 = (uint8_t)block;
  uVar2 = (4 - block) * 8;
  uVar3 = 0;
  puVar4 = puVar7;
  while (uVar8 >> 2 != uVar3) {
    uVar5 = *puVar4;
    puVar4 = puVar4 + 1;
    block_00 = uVar5 << (block << 3 & 0x1f) | uVar6;
    uVar6 = 0;
    if (uVar2 != 0x20) {
      uVar6 = uVar5 >> (uVar2 & 0x1f);
    }
    michael_block(mic_calc_ptr,block_00);
    uVar3 = uVar3 + 1;
  }
  if ((uVar8 & 0xfffffffc) < uVar8) {
    block_00 = (4 - (uVar8 & 3)) * 8;
    uVar3 = 0;
    if (block_00 != 0x20) {
      uVar3 = 0xffffffff >> (block_00 & 0x1f);
    }
    uVar3 = *(uint *)((int)puVar7 + (uVar8 & 0xfffffffc)) & uVar3;
    uVar8 = block + (uVar8 & 3);
    uVar1 = (uint8_t)uVar8;
    block = uVar6 | uVar3 << (block << 3 & 0x1f);
    uVar6 = block;
    if (3 < uVar8) {
      uVar6 = 0;
      if (uVar2 != 0x20) {
        uVar6 = uVar3 >> (uVar2 & 0x1f);
      }
      uVar1 = uVar1 + -4;
      michael_block(mic_calc_ptr,block);
    }
  }
  mic_calc_ptr->last_m_i_len = uVar1;
  mic_calc_ptr->last_m_i = uVar6;
  return;
}



void me_mic_end(mic_calc *mic_calc_ptr)

{
  uint uVar1;
  
  uVar1 = mic_calc_ptr->last_m_i;
  if (3 < mic_calc_ptr->last_m_i_len) {
    assert_err("mic_calc_ptr->last_m_i_len < 4","module",0x13e);
  }
  michael_block(mic_calc_ptr,0x5a << (((uint)mic_calc_ptr->last_m_i_len & 3) << 3) | uVar1);
  michael_block(mic_calc_ptr,0);
  return;
}



_Bool me_set_sta_ht_vht_param(sta_info_tag *sta,mac_bss_info *bss)

{
  ushort uVar1;
  uint uVar2;
  uint uVar3;
  uint8_t uVar4;
  uint uVar5;
  
  uVar1 = (sta->info).ht_cap.ht_capa_info;
  uVar3 = (uint)(uVar1 >> 1) & 1;
  uVar2 = (int)(uint)uVar1 >> 8 & 3;
  if ((uint)me_env.phy_bw_max < uVar3) {
    uVar3 = (uint)me_env.phy_bw_max;
  }
  (sta->info).phy_bw_max = (uint8_t)uVar3;
  uVar5 = (uint)bss->phy_bw;
  if (bss->phy_bw == 4) {
    uVar5 = 2;
  }
  uVar4 = (uint8_t)uVar5;
  if (uVar3 < uVar5) {
    uVar4 = (uint8_t)uVar3;
  }
  (sta->info).bw_cur = uVar4;
  uVar4 = me_env.stbc_nss;
  if (uVar2 < me_env.stbc_nss) {
    uVar4 = (uint8_t)uVar2;
  }
  (sta->info).stbc_nss = uVar4;
  return (_Bool)(((uint)uVar1 & 0xc) != 0xc);
}



uint8_t me_11n_nss_max(uint8_t *mcs_set)

{
  uint8_t uVar1;
  
  if (mcs_set[3] == '\0') {
    uVar1 = '\x02';
    if ((mcs_set[2] == '\0') && (uVar1 = mcs_set[1], uVar1 != '\0')) {
      uVar1 = '\x01';
    }
  }
  else {
    uVar1 = '\x03';
  }
  return uVar1;
}



uint8_t me_legacy_ridx_min(uint16_t rate_map)

{
  undefined2 in_register_0000202a;
  uint uVar1;
  
  uVar1 = 0;
  do {
    if ((CONCAT22(in_register_0000202a,rate_map) >> (uVar1 & 0x1f) & 1U) != 0) {
      return (uint8_t)uVar1;
    }
    uVar1 = uVar1 + 1;
  } while (uVar1 != 0xc);
  return '\f';
}



uint8_t me_legacy_ridx_max(uint16_t rate_map)

{
  undefined2 in_register_0000202a;
  char cVar1;
  uint uVar2;
  
  if (CONCAT22(in_register_0000202a,rate_map) == 0) {
    return '\f';
  }
  uVar2 = 0xb;
  do {
    cVar1 = '\v' - (char)uVar2;
    if ((CONCAT22(in_register_0000202a,rate_map) >> (uVar2 & 0x1f) & 1U) != 0) goto LAB_23007860;
    uVar2 = uVar2 - 1;
  } while (uVar2 != 0xffffffff);
  cVar1 = '\f';
LAB_23007860:
  return '\v' - cVar1;
}



uint8_t me_rate_translate(uint8_t rate)

{
  uint8_t uVar1;
  byte bVar2;
  byte bVar3;
  
  bVar3 = rate & 0x7f;
  if (bVar3 == 0x16) {
    uVar1 = '\x03';
  }
  else {
    if (bVar3 < 0x17) {
      if (bVar3 == 0xb) {
        return '\x02';
      }
      if (bVar3 < 0xc) {
        if (bVar3 == 2) {
          return '\0';
        }
        bVar2 = 4;
        uVar1 = '\x01';
      }
      else {
        if (bVar3 == 0xc) {
          return '\x04';
        }
        bVar2 = 0x12;
        uVar1 = '\x05';
      }
    }
    else {
      if (bVar3 == 0x30) {
        return '\b';
      }
      if (bVar3 < 0x31) {
        if (bVar3 == 0x18) {
          return '\x06';
        }
        bVar2 = 0x24;
        uVar1 = '\a';
      }
      else {
        if (bVar3 == 0x60) {
          return '\n';
        }
        if (bVar3 == 0x6c) {
          return '\v';
        }
        bVar2 = 0x48;
        uVar1 = '\t';
      }
    }
    if (bVar3 != bVar2) {
      return -1;
    }
  }
  return uVar1;
}



void me_get_basic_rates(mac_rateset *rateset,mac_rateset *basic_ratest)

{
  byte bVar1;
  int iVar2;
  
  basic_ratest->length = '\0';
  iVar2 = 0;
  while (iVar2 < (int)(uint)rateset->length) {
    if ((char)rateset->array[iVar2] < '\0') {
      bVar1 = basic_ratest->length;
      basic_ratest->array[bVar1] = rateset->array[iVar2];
      basic_ratest->length = bVar1 + 1;
    }
    iVar2 = iVar2 + 1;
  }
  return;
}



uint16_t me_legacy_rate_bitfield_build(mac_rateset *rateset,_Bool basic_only)

{
  uint uVar1;
  int iVar2;
  byte bVar3;
  undefined3 extraout_var;
  undefined3 in_register_0000202d;
  
  uVar1 = 0;
  iVar2 = 0;
  while (iVar2 < (int)(uint)rateset->length) {
    if ((CONCAT31(in_register_0000202d,basic_only) == 0) || ((char)rateset->array[iVar2] < '\0')) {
      bVar3 = me_rate_translate(rateset->array[iVar2]);
      if (CONCAT31(extraout_var,bVar3) < 0xc) {
        uVar1 = uVar1 | 1 << ((uint)bVar3 & 0x1f) & 0xffffU;
      }
      else {
        assert_warn("bit_pos < MAC_RATESET_LEN","module",0x1c6);
      }
    }
    iVar2 = iVar2 + 1;
  }
  return (uint16_t)uVar1;
}



uint16_t me_build_capability(uint8_t vif_idx)

{
  ushort uVar1;
  undefined3 in_register_00002029;
  int iVar2;
  ushort uVar3;
  
  iVar2 = CONCAT31(in_register_00002029,vif_idx);
  uVar3 = 0x11;
  if (((vif_info_tab[iVar2].type != '\0') && (uVar3 = 1, vif_info_tab[iVar2].type == '\x02')) &&
     ((*(uint *)&vif_info_tab[iVar2].bss_info.is_supplicant_enabled & 0x12a00) != 0)) {
    uVar3 = 0x11;
  }
  uVar1 = uVar3 | 0x520;
  if ((vif_info_tab[iVar2].bss_info.chan)->band != '\x01') {
    uVar1 = uVar3 | 0x420;
  }
  return (uint16_t)uVar1;
}



void me_init_bcmc_rate(sta_info_tag *sta_entry)

{
  byte bVar1;
  byte rate;
  uint8_t basic_rate_idx;
  int iVar2;
  
  if ((sta_entry->info).rate_set.length == '\0') {
    assert_err("rates->length != 0","module",0x229);
  }
  iVar2 = 0;
  rate = 0;
  while (iVar2 < (int)(uint)(sta_entry->info).rate_set.length) {
    bVar1 = (sta_entry->info).rate_set.array[iVar2];
    if (rate < (bVar1 & 0x7f)) {
      rate = bVar1 & 0x7f;
    }
    iVar2 = iVar2 + 1;
  }
  basic_rate_idx = me_rate_translate(rate);
  rc_init_bcmc_rate(sta_entry,basic_rate_idx);
  (sta_entry->pol_tbl).upd_field = '\0';
  return;
}



void me_tx_cfm_singleton(txdesc *txdesc)

{
  uint8_t sta_idx;
  uint uVar1;
  uint uVar2;
  
  uVar1 = ((txdesc->lmac).hw_desc)->cfm_ptr->status;
  uVar2 = uVar1 & 0x10000;
  uVar1 = uVar1 >> 8 & 0xff;
  if (uVar2 == 0) {
    sta_idx = (txdesc->host).staid;
  }
  else {
    rf_dump_status();
    sta_idx = (txdesc->host).staid;
  }
  rc_update_counters(sta_idx,uVar1 + 1,uVar1 + (uVar2 != 0),false,false);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void me_check_rc(uint8_t sta_idx,_Bool *tx_ampdu)

{
  ushort uVar1;
  ushort uVar2;
  ushort rate_config;
  ushort rate_config_00;
  uint16_t uVar3;
  bool bVar4;
  rc_sta_stats *rc_ss;
  uint uVar5;
  _Bool _Var6;
  uint8_t uVar7;
  uint8_t uVar8;
  undefined3 in_register_00002029;
  uint uVar9;
  undefined3 extraout_var;
  uint uVar10;
  uint32_t uVar11;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  uint32_t uVar12;
  byte bVar13;
  uint32_t *puVar14;
  uint uVar15;
  int iVar16;
  uint uVar17;
  uint uVar18;
  
  uVar9 = CONCAT31(in_register_00002029,sta_idx);
  if (9 < uVar9) {
    return;
  }
  rc_ss = sta_info_tab[uVar9].pol_tbl.sta_stats;
  if (rc_ss == (rc_sta_stats *)0x0) {
    assert_err("rc_ss != NULL","module",0x826);
  }
  iVar16 = 0;
  if ((int)((100000 - _DAT_44b00120) + rc_ss->last_rc_time) < 0) {
    _Var6 = rc_update_stats(rc_ss,false);
    iVar16 = CONCAT31(extraout_var,_Var6);
    rc_ss->trial_status = '\0';
    rc_ss->sw_retry_step = '\0';
    rc_ss->info = rc_ss->info & 0xef;
    rc_ss->last_rc_time = _DAT_44b00120;
  }
  if (rc_ss->trial_status == '\x01') {
    if ((rc_ss->info & 0x40) == 0) {
      bVar13 = rc_ss->format_mod;
      uVar1 = rc_ss->retry[0].idx;
      uVar15 = (uint)uVar1;
      if (bVar13 < 2) {
        if ((ushort)(rc_ss->rate_stats[uVar15].probability + 0xe667) < 0xd99b) {
          uVar7 = '\n';
        }
        else {
          uVar7 = '\x05';
        }
      }
      else {
        uVar7 = ((char)*(undefined2 *)((int)&rc_ss->avg_ampdu_len + 2) + '\b') * '\x02';
      }
      rc_ss->sample_wait = uVar7;
      next = next * 0x41c64e6d + 0x3039;
      uVar5 = (next >> 0x10) % (uint)rc_ss->no_samples;
      if (uVar5 != uVar15) {
        uVar2 = rc_ss->retry[1].idx;
        if (((uVar5 != (uint)uVar2) && (uVar18 = (uint)rc_ss->retry[2].idx, uVar5 != uVar18)) &&
           (puVar14 = &rc_ss->last_rc_time + uVar5 * 3, *(ushort *)(puVar14 + 2) < 0xf334)) {
          rate_config = *(ushort *)((int)puVar14 + 10);
          uVar10 = rc_get_duration((uint)rate_config);
          rate_config_00 = rc_ss->rate_stats[uVar15].rate_config;
          if (bVar13 < 2) {
            uVar15 = rc_get_duration((uint)rate_config_00);
            if (uVar15 < uVar10) {
              uVar11 = 0;
              bVar4 = 0x13 < *(byte *)(puVar14 + 3);
            }
            else {
              uVar11 = 0;
              bVar4 = true;
            }
          }
          else {
            uVar17 = 0x20;
            uVar15 = rc_get_duration((uint)rc_ss->rate_stats[(uint)uVar2].rate_config);
            if (*(char *)((int)puVar14 + 0xd) == '\0') {
              uVar17 = (uint)*(ushort *)((int)&rc_ss->avg_ampdu_len + 2);
            }
            if (uVar15 <= uVar10) {
              uVar7 = rc_get_nss(rate_config_00);
              uVar8 = rc_get_nss(rate_config);
              if ((CONCAT31(extraout_var_00,uVar7) - 1U < CONCAT31(extraout_var_01,uVar8)) ||
                 (uVar15 = rc_get_duration((uint)rc_ss->rate_stats[uVar18].rate_config),
                 uVar15 <= uVar10)) {
                if (uVar17 <= *(byte *)(puVar14 + 3)) {
                  bVar13 = rc_ss->sample_slow + 1;
                  rc_ss->sample_slow = bVar13;
                  if (bVar13 < 3) goto LAB_2300964c;
                  if (0xf < bVar13) {
                    rc_ss->sample_slow = '\x0f';
                  }
                }
                goto LAB_23009626;
              }
            }
LAB_2300964c:
            uVar11 = rc_calc_tp(rc_ss,(uint8_t)uVar5);
            bVar4 = true;
            if ((*(byte *)((int)puVar14 + 0xe) & 0xf) < 10) {
              bVar4 = uVar17 <= *(byte *)(puVar14 + 3);
            }
          }
          uVar12 = rc_ss->retry[1].tp;
          (rc_ss->max_tp_2_trial).idx = uVar2;
          (rc_ss->max_tp_2_trial).tp = uVar12;
          if (bVar4) {
            uVar12 = rc_ss->retry[0].tp;
            rc_ss->info = rc_ss->info & 0xfd;
            rc_ss->retry[1].tp = uVar12;
            rc_ss->retry[1].idx = uVar1;
            rc_ss->retry[0].tp = uVar11;
            rc_ss->retry[0].idx = (uint16_t)uVar5;
          }
          else {
            rc_ss->info = rc_ss->info | 2;
            rc_ss->retry[1].tp = uVar11;
            rc_ss->retry[1].idx = (uint16_t)uVar5;
          }
          rc_ss->trial_status = '\x02';
          goto LAB_2300958c;
        }
      }
    }
LAB_23009626:
    rc_ss->trial_status = '\0';
  }
  else {
    if (rc_ss->trial_status == '\x03') {
      if ((rc_ss->info & 2) == 0) {
        rc_ss->retry[0].idx = rc_ss->retry[1].idx;
        rc_ss->retry[0].tp = rc_ss->retry[1].tp;
      }
      uVar3 = (rc_ss->max_tp_2_trial).idx;
      rc_ss->trial_status = '\0';
      rc_ss->retry[1].idx = uVar3;
      uVar11 = (rc_ss->max_tp_2_trial).tp;
      (rc_ss->max_tp_2_trial).tp = 0;
      rc_ss->retry[1].tp = uVar11;
      (rc_ss->max_tp_2_trial).idx = 0xff;
      goto LAB_2300958c;
    }
  }
  if (iVar16 == 0) {
    return;
  }
LAB_2300958c:
  sta_info_tab[uVar9].pol_tbl.upd_field = sta_info_tab[uVar9].pol_tbl.upd_field | 1;
  return;
}


/*
Unable to decompile 'me_update_buffer_control'
Cause: Exception while decompiling 23007ab2: Decompiler process died

*/


void me_init_rate(sta_info_tag *sta_entry)

{
  rc_init(sta_entry);
  me_update_buffer_control(sta_entry);
  return;
}



void me_bw_check(int param_1,int param_2)

{
  short sVar1;
  short sVar2;
  byte bVar3;
  
  sVar2 = **(short **)(param_2 + 0x4c);
  bVar3 = 0;
  if ((param_1 != 0) && (bVar3 = me_env.phy_bw_max, me_env.phy_bw_max != '\0')) {
    bVar3 = *(byte *)(param_1 + 3) & 3;
    if ((*(byte *)(param_1 + 3) & 3) != 0) {
      sVar1 = 10;
      if (bVar3 != 1) {
        sVar1 = -10;
      }
      sVar2 = sVar2 + sVar1;
      bVar3 = 1;
    }
  }
  *(byte *)(param_2 + 0x82) = bVar3;
  *(byte *)(param_2 + 0x83) = bVar3;
  *(short *)(param_2 + 0x50) = sVar2;
  *(undefined2 *)(param_2 + 0x52) = 0;
  return;
}



void me_beacon_check(uint8_t vif_idx,uint16_t length,uint32_t bcn_addr)

{
  byte bVar1;
  uint8_t uVar2;
  uint8_t uVar3;
  undefined3 in_register_00002029;
  int iVar4;
  int iVar5;
  undefined4 uVar6;
  uint8_t *puVar7;
  undefined2 in_register_0000202e;
  uint uVar8;
  uint16_t uVar9;
  scan_chan_tag *psVar10;
  uint uVar11;
  byte bVar12;
  char cStack51;
  int8_t iStack50;
  uint8_t auStack49 [2];
  uint8_t csa_mode;
  int8_t pwr;
  uint8_t idx;
  
  iVar4 = CONCAT31(in_register_00002029,vif_idx);
  psVar10 = vif_info_tab[iVar4].bss_info.chan;
  vif_info_tab[iVar4].bss_info.prot_status = 0;
  uVar8 = CONCAT22(in_register_0000202e,length) - 0x24;
  bVar1 = vif_info_tab[iVar4].bss_info.phy_bw;
  uVar2 = vif_info_tab[iVar4].bss_info.power_constraint;
  bcn_addr = bcn_addr + 0x24;
  uVar11 = uVar8 & 0xffff;
  if ((psVar10->band == '\0') && (iVar5 = mac_ie_find(bcn_addr,uVar11,0x2a), iVar5 != 0)) {
    bVar12 = *(byte *)(iVar5 + 2);
    uVar9 = vif_info_tab[iVar4].bss_info.prot_status & 0xfff8;
    if ((bVar12 & 1) != 0) {
      uVar9 = uVar9 | 1;
    }
    vif_info_tab[iVar4].bss_info.prot_status = uVar9;
    if ((bVar12 & 2) != 0) {
      vif_info_tab[iVar4].bss_info.prot_status = vif_info_tab[iVar4].bss_info.prot_status | 2;
    }
    if ((bVar12 & 4) != 0) {
      vif_info_tab[iVar4].bss_info.prot_status = vif_info_tab[iVar4].bss_info.prot_status | 4;
    }
  }
  uVar6 = 0;
  if (me_env.ht_supported != false) {
    uVar6 = mac_ie_find(bcn_addr,uVar11,0x3d);
  }
  me_bw_check(uVar6,0,&vif_info_tab[iVar4].bss_info);
  uVar11 = me_extract_csa(bcn_addr,uVar11,&cStack51,iVar4 * 0x5d8 + 0x4201a9d8);
  if ((uVar11 & 0xff) != 0) {
    bVar12 = (byte)(uVar11 & 0xff);
    if (vif_info_tab[iVar4].type == '\0') {
      if ((vif_info_tab[iVar4].u[0x1d] == 0) && (cStack51 == '\x01')) {
        mm_send_csa_traffic_ind(vif_info_tab[iVar4].index,false);
      }
      vif_info_tab[iVar4].u[0x1d] = bVar12;
    }
    else {
      if (vif_info_tab[iVar4].type == '\x02') {
        vif_info_tab[iVar4].u[0x2eb] = bVar12;
      }
    }
  }
  me_extract_power_constraint
            (bcn_addr,(uint16_t)(uVar8 * 0x10000 >> 0x10),&vif_info_tab[iVar4].bss_info);
  uVar3 = vif_info_tab[iVar4].bss_info.power_constraint;
  if (uVar3 != uVar2) {
    iStack50 = (vif_info_tab[iVar4].bss_info.chan)->tx_power - uVar3;
    tpc_update_vif_tx_power(vif_info_tab + iVar4,&iStack50,auStack49);
  }
  if (bVar1 < vif_info_tab[iVar4].bss_info.phy_bw) {
    puVar7 = (uint8_t *)ke_msg_alloc(0x3b,0,5,0xc);
    if (vif_info_tab[iVar4].chan_ctxt == (chan_ctxt_tag *)0x0) {
      assert_err("vif->chan_ctxt != NULL","module",0x39);
    }
    *puVar7 = (vif_info_tab[iVar4].chan_ctxt)->idx;
    puVar7[1] = (vif_info_tab[iVar4].bss_info.chan)->band;
    puVar7[2] = vif_info_tab[iVar4].bss_info.phy_bw;
    *(uint16_t *)(puVar7 + 4) = (vif_info_tab[iVar4].bss_info.chan)->freq;
    *(uint16_t *)(puVar7 + 6) = vif_info_tab[iVar4].bss_info.center_freq1;
    *(uint16_t *)(puVar7 + 8) = vif_info_tab[iVar4].bss_info.center_freq2;
    puVar7[10] = ((vif_info_tab[iVar4].chan_ctxt)->channel).tx_power;
    ke_msg_send(puVar7);
  }
  return;
}



void me_sta_bw_nss_max_upd(uint8_t sta_idx,uint8_t bw,uint8_t nss)

{
  byte bVar1;
  byte bVar2;
  uint8_t sta_idx_00;
  uint8_t nss_max;
  uint8_t bw_max;
  undefined3 in_register_00002029;
  int iVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 in_register_0000202d;
  uint uVar4;
  undefined3 in_register_00002031;
  uint uVar5;
  
  iVar3 = CONCAT31(in_register_00002029,sta_idx);
  bVar1 = sta_info_tab[iVar3].inst_nbr;
  if (me_env.ht_supported == false) {
    assert_err("me_env.ht_supported","module",0x429);
  }
  nss_max = me_11n_nss_max(sta_info_tab[iVar3].info.ht_cap.mcs_rate);
  bw_max = me_11n_nss_max(me_env.ht_cap.mcs_rate);
  uVar5 = CONCAT31(extraout_var_00,bw_max);
  if (CONCAT31(extraout_var,nss_max) < CONCAT31(extraout_var_00,bw_max)) {
    uVar5 = CONCAT31(extraout_var,nss_max);
  }
  nss_max = (uint8_t)uVar5;
  if (CONCAT31(in_register_00002031,nss) < uVar5) {
    nss_max = nss;
  }
  bVar2 = sta_info_tab[iVar3].info.phy_bw_max;
  uVar5 = (uint)bVar2;
  if (bVar2 == 4) {
    uVar5 = 3;
  }
  uVar4 = (uint)vif_info_tab[bVar1].bss_info.bw;
  if (CONCAT31(in_register_0000202d,bw) < uVar4) {
    uVar4 = CONCAT31(in_register_0000202d,bw);
  }
  bw_max = (uint8_t)uVar4;
  if (uVar5 < uVar4) {
    bw_max = (uint8_t)uVar5;
  }
  sta_idx_00 = sta_info_tab[iVar3].staid;
  sta_info_tab[iVar3].info.bw_cur = bw_max;
  rc_update_bw_nss_max(sta_idx_00,bw_max,nss_max);
  sta_info_tab[iVar3].pol_tbl.upd_field = sta_info_tab[iVar3].pol_tbl.upd_field | 8;
  return;
}



// WARNING: Could not reconcile some variable overlaps

uint8_t me_add_chan_ctx(uint8_t *p_chan_idx,scan_chan_tag *p_chan,uint32_t center_freq1,
                       uint32_t center_freq2,uint8_t ch_width)

{
  uint8_t uVar1;
  uint8_t uStack28;
  uint8_t uStack27;
  uint16_t uStack26;
  mm_chan_ctxt_add_req req;
  
  uStack28 = p_chan->band;
  req._0_2_ = (uint16_t)center_freq1;
  uStack26 = p_chan->freq;
  req.prim20_freq = (uint16_t)center_freq2;
  req.center1_freq._0_1_ = p_chan->tx_power;
  uStack27 = ch_width;
  uVar1 = chan_ctxt_add((mm_chan_ctxt_add_req *)&uStack28,p_chan_idx);
  return uVar1;
}



uint8_t rc_get_nss(uint16_t rate_config)

{
  undefined2 in_register_0000202a;
  
  if ((CONCAT22(in_register_0000202a,rate_config) >> 0xb & 7U) - 2 < 2) {
    return (uint8_t)((byte)(CONCAT22(in_register_0000202a,rate_config) >> 3) & 3);
  }
  return '\0';
}



uint8_t rc_get_mcs_index(uint16_t rate_config)

{
  undefined2 in_register_0000202a;
  byte bVar1;
  uint uVar2;
  
  uVar2 = CONCAT22(in_register_0000202a,rate_config) >> 0xb & 7;
  if (uVar2 < 2) {
    bVar1 = (byte)rate_config & 0x7f;
  }
  else {
    bVar1 = 0;
    if (uVar2 < 4) {
      bVar1 = (byte)rate_config & 7;
    }
  }
  return (uint8_t)bVar1;
}



uint16_t rc_set_previous_mcs_index(rc_sta_stats *rc_ss,uint16_t rate_config)

{
  uint uVar1;
  uint8_t uVar2;
  undefined3 extraout_var;
  undefined2 in_register_0000202e;
  
  uVar2 = rc_get_mcs_index(rate_config);
  _uVar2 = CONCAT31(extraout_var,uVar2);
  uVar1 = CONCAT22(in_register_0000202e,rate_config) >> 0xb & 7;
  if (uVar1 < 2) {
    if (rc_ss->r_idx_min < _uVar2) {
      rate_config = rate_config & 0xff80 | (short)_uVar2 - 1U;
    }
  }
  else {
    if ((uVar1 < 4) && (_uVar2 != 0)) {
      rate_config = rate_config & 0xfff8 | (short)_uVar2 - 1U;
      if (rc_ss->short_gi != '\0') {
        rate_config = rate_config | 0x200;
      }
    }
  }
  return rate_config;
}



uint16_t rc_set_next_mcs_index(rc_sta_stats *rc_ss,uint16_t rate_config)

{
  uint8_t uVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined2 in_register_0000202e;
  uint uVar2;
  
  uVar1 = rc_get_mcs_index(rate_config);
  _uVar1 = CONCAT31(extraout_var,uVar1);
  uVar2 = CONCAT22(in_register_0000202e,rate_config) >> 0xb & 7;
  if (uVar2 < 2) {
    if ((_uVar1 < rc_ss->r_idx_max) && ((rc_ss->rate_map_l >> (_uVar1 + 1 & 0x1f) & 1) != 0)) {
      rate_config = rate_config & 0xff80 | (ushort)(_uVar1 + 1);
    }
  }
  else {
    if ((uVar2 < 4) && (_uVar1 < rc_ss->mcs_max)) {
      uVar1 = rc_get_nss(rate_config);
      if ((*(byte *)((int)&rc_ss->rate_map + CONCAT31(extraout_var_00,uVar1)) >> (_uVar1 + 1 & 0x1f)
          & 1) != 0) {
        rate_config = rate_config & 0xfff8 | (ushort)(_uVar1 + 1);
        if (rc_ss->short_gi != '\0') {
          rate_config = rate_config | 0x200;
        }
      }
    }
  }
  return rate_config;
}



_Bool is_cck_group(uint16_t rate_config)

{
  uint8_t uVar1;
  undefined3 extraout_var;
  
  if ((rate_config & 0x3000) == 0) {
    uVar1 = rc_get_mcs_index(rate_config);
    return (_Bool)(CONCAT31(extraout_var,uVar1) < 4);
  }
  return false;
}



void rc_update_retry_chain(rc_sta_stats *rc_ss,uint32_t *cur_tp)

{
  ushort uVar1;
  ushort uVar2;
  int iVar3;
  uint uVar4;
  _Bool _Var5;
  ushort uVar6;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  ushort *puVar7;
  int iVar8;
  uint32_t uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  
  uVar6 = rc_ss->no_samples;
  uVar13 = (uint)uVar6;
  if (((rc_ss->info & 4) == 0) && (cur_tp[uVar13 - 1] < *cur_tp)) {
    rc_ss->retry[0].idx = 0;
    rc_ss->retry[0].tp = 0;
    uVar4 = 1;
  }
  else {
    rc_ss->retry[0].idx = uVar6 - 1;
    uVar4 = 2;
    rc_ss->retry[0].tp = cur_tp[uVar13 - 1];
  }
  uVar1 = rc_ss->retry[0].idx;
  _Var5 = is_cck_group(*(uint16_t *)((int)(&rc_ss->last_rc_time + (uint)uVar1 * 3) + 10));
  if (CONCAT31(extraout_var,_Var5) == 0) {
    uVar12 = 0;
    while ((int)uVar12 < (int)(uVar13 - 1)) {
      _Var5 = is_cck_group(*(uint16_t *)((int)(&rc_ss->last_rc_time + uVar12 * 3) + 10));
      if (CONCAT31(extraout_var_00,_Var5) != 0) {
        *(undefined *)((int)(&rc_ss->last_rc_time + uVar12 * 3) + 0xf) = 0;
      }
      uVar12 = uVar12 + 1 & 0xffff;
    }
    *(undefined *)((int)(&rc_ss->last_rc_time + (uint)uVar1 * 3) + 0xf) = 1;
  }
  uVar9 = rc_ss->retry[0].tp;
  rc_ss->retry[1].idx = uVar1;
  rc_ss->retry[1].tp = uVar9;
  iVar3 = uVar13 - uVar4;
  do {
    iVar8 = iVar3;
    uVar12 = uVar4;
    uVar4 = uVar12 + 1 & 0xffff;
    if (uVar13 <= uVar12) goto LAB_230081c4;
    iVar3 = iVar8 + -1;
  } while (rc_ss->rate_stats[iVar8].rate_allowed == false);
  rc_ss->retry[1].idx = uVar6 - (short)uVar12;
  rc_ss->retry[1].tp = cur_tp[iVar8];
LAB_230081c4:
  uVar12 = (uint)rc_ss->retry[1].idx;
  uVar4 = uVar13 - uVar4;
  do {
    uVar10 = uVar4;
    uVar11 = uVar12;
    if (uVar13 <= (uVar13 - uVar10 & 0xffff)) break;
    uVar4 = uVar10 - 1;
    uVar11 = uVar10;
  } while (rc_ss->rate_stats[uVar10].rate_allowed == false);
  uVar13 = cur_tp[uVar11];
  puVar7 = &rc_ss->rate_stats[0].probability;
  uVar6 = rc_ss->rate_stats[uVar11].probability;
  uVar4 = 0;
  do {
    if (uVar12 <= (uVar4 & 0xffff)) {
      rc_ss->retry[2].idx = (uint16_t)uVar11;
      uVar9 = cur_tp[uVar11];
      rc_ss->retry[3].idx = 0;
      rc_ss->retry[2].tp = uVar9;
      rc_ss->retry[3].tp = *cur_tp;
      return;
    }
    if ((*(char *)((int)puVar7 + 7) != '\0') && ((uVar4 & 0xffff) != (uint)uVar1)) {
      uVar2 = *puVar7;
      if (uVar2 < 0xf333) {
        if (uVar6 <= uVar2) {
          uVar9 = cur_tp[uVar4];
          goto LAB_230082a8;
        }
      }
      else {
        uVar9 = cur_tp[uVar4];
        if (uVar13 <= uVar9) {
LAB_230082a8:
          uVar13 = uVar9;
          uVar11 = uVar4;
          uVar6 = uVar2;
        }
      }
    }
    uVar4 = uVar4 + 1;
    puVar7 = puVar7 + 6;
  } while( true );
}



uint16_t rc_get_lowest_rate_config(rc_sta_stats *rc_ss)

{
  byte bVar1;
  uint16_t uVar2;
  
  bVar1 = rc_ss->format_mod;
  if (bVar1 < 2) {
    uVar2 = (uint16_t)rc_ss->r_idx_min;
    if (rc_ss->r_idx_min == 0) {
      return 0x400;
    }
  }
  else {
    if (3 < bVar1) {
      return 0;
    }
    if (rc_ss->r_idx_min == '\0') {
      return 0x400;
    }
    uVar2 = (ushort)bVar1 << 0xb;
  }
  return uVar2;
}



// WARNING: Variable defined which should be unmapped: rc_ss_tmp

void rc_sort_samples_tp(rc_sta_stats *rc_ss,uint32_t *cur_tp)

{
  ushort uVar1;
  uint32_t *puVar2;
  ushort uVar3;
  uint32_t uVar4;
  ushort uVar5;
  rc_rate_stats *__src;
  ushort uVar6;
  rc_rate_stats *__src_00;
  undefined auStack44 [4];
  rc_rate_stats rc_ss_tmp;
  
  uVar5 = rc_ss->no_samples;
  uVar1 = uVar5 - 1;
  while (uVar6 = uVar1, uVar5 != 0) {
    puVar2 = cur_tp + 1;
    uVar5 = 0;
    uVar3 = 1;
    __src = rc_ss->rate_stats + 1;
    while (uVar1 = uVar5, uVar3 < uVar6) {
      __src_00 = __src + 1;
      if (puVar2[1] < *puVar2) {
        memmove(auStack44,__src,0xc);
        memmove(__src,__src_00,0xc);
        memmove(__src_00,auStack44,0xc);
        uVar4 = puVar2[1];
        puVar2[1] = *puVar2;
        *puVar2 = uVar4;
        uVar5 = uVar3;
      }
      uVar3 = uVar3 + 1;
      puVar2 = puVar2 + 1;
      __src = __src_00;
    }
  }
  return;
}



uint16_t rc_get_initial_rate_config(rc_sta_stats *rc_ss)

{
  byte bVar1;
  byte bVar2;
  ushort uVar3;
  int iVar4;
  ushort uVar5;
  
  bVar1 = rc_ss->format_mod;
  if (bVar1 < 2) {
    uVar3 = (ushort)rc_ss->r_idx_max;
    uVar5 = (ushort)bVar1 << 0xb | (ushort)rc_ss->p_type << 10;
  }
  else {
    if (3 < bVar1) {
      return 0;
    }
    bVar2 = rc_ss->no_ss;
    iVar4 = __clzsi2((uint)*(byte *)((int)&rc_ss->rate_map + (uint)bVar2));
    uVar5 = (ushort)rc_ss->short_gi << 9 | (ushort)bVar1 << 0xb | (ushort)rc_ss->bw_max << 7 |
            (ushort)bVar2 << 3;
    uVar3 = 0x1fU - (short)iVar4 & 0xff;
  }
  return (uint16_t)(uVar5 | uVar3);
}



void rc_calc_prob_ewma(rc_rate_stats *rc_rs)

{
  ushort uVar1;
  uint uVar2;
  uint uVar3;
  
  uVar1 = rc_rs->attempts;
  if (uVar1 != 0) {
    rc_rs->sample_skipped = '\0';
    uVar3 = (uint)rc_rs->success << 0x10;
    uVar2 = uVar3 / uVar1;
    if (rc_rs->old_prob_available == false) {
      if (uVar3 < uVar1) {
        rc_rs->probability = 0;
      }
      else {
        rc_rs->probability = (short)uVar2 - 1;
      }
    }
    else {
      rc_rs->probability = (uint16_t)((uint)rc_rs->probability * 0x60 + uVar2 * 0x20 >> 7);
    }
    rc_rs->old_prob_available = true;
    return;
  }
  if (rc_rs->sample_skipped != -1) {
    rc_rs->sample_skipped = rc_rs->sample_skipped + '\x01';
  }
  return;
}



_Bool rc_check_valid_rate(rc_sta_stats *rc_ss,uint16_t rate_config)

{
  uint8_t uVar1;
  byte bVar2;
  undefined3 extraout_var;
  undefined2 in_register_0000202e;
  uint uVar3;
  
  uVar3 = CONCAT22(in_register_0000202e,rate_config) >> 0xb & 7;
  if (uVar3 < 2) {
    bVar2 = rc_get_mcs_index(rate_config);
    uVar3 = (uint)rc_ss->rate_map_l;
  }
  else {
    if (3 < uVar3) {
      return true;
    }
    uVar1 = rc_get_nss(rate_config);
    bVar2 = rc_get_mcs_index(rate_config);
    uVar3 = (uint)*(byte *)((int)&rc_ss->rate_map + CONCAT31(extraout_var,uVar1));
  }
  return (_Bool)((byte)(uVar3 >> ((uint)bVar2 & 0x1f)) & 1);
}



uint16_t rc_new_random_rate(rc_sta_stats *rc_ss)

{
  byte bVar1;
  byte bVar2;
  uint uVar3;
  int iVar4;
  uint16_t uVar5;
  uint uVar6;
  ushort uVar7;
  uint uVar8;
  
  bVar1 = rc_ss->bw_max;
  uVar8 = 0;
  next = next * 0x41c64e6d + 0x3039;
  bVar2 = rc_ss->format_mod;
  uVar6 = next >> 0x10;
  uVar5 = (uint16_t)(((uint)bVar2 << 0x1b) >> 0x10);
  if (bVar1 != 0) {
    uVar8 = (uint)bVar1 - 1 & 0xff;
  }
  uVar7 = (ushort)(next >> 0x10);
  if (bVar2 < 2) {
    uVar8 = (int)(uVar6 & 0x7f) % (((uint)rc_ss->r_idx_max - (uint)rc_ss->r_idx_min) + 1) +
            (uint)rc_ss->r_idx_min;
    uVar6 = uVar8 & 0xff;
    if ((rc_ss->rate_map_l >> (uVar8 & 0x1f) & 1) == 0) {
      uVar6 = (uint)rc_ss->r_idx_max;
    }
    uVar5 = uVar5 | (ushort)uVar6;
    if (uVar6 == 0) {
      uVar5 = uVar5 | 0x400;
    }
    else {
      if ((uVar6 - 1 & 0xff) < 3) {
        uVar5 = uVar5 | uVar7 & 0x400 | (ushort)rc_ss->p_type << 10;
      }
    }
  }
  else {
    if (bVar2 < 4) {
      bVar2 = rc_ss->r_idx_min;
      if ((bVar2 < 4) && ((int)(uVar6 << 0x14) < 0)) {
        uVar8 = (int)(uVar6 & 0x7f) % (((uint)rc_ss->r_idx_max - (uint)bVar2) + 1) + (uint)bVar2;
        uVar6 = uVar8 & 0xff;
        if ((rc_ss->rate_map_l >> (uVar8 & 0x1f) & 1) == 0) {
          uVar6 = (uint)rc_ss->r_idx_max;
        }
        uVar5 = 0x400;
        if (uVar6 != 0) {
          uVar5 = (ushort)rc_ss->p_type << 10 | uVar7 & 0x400 | (ushort)uVar6;
        }
      }
      else {
        uVar7 = (ushort)rc_ss->mcs_max;
        iVar4 = (int)((int)uVar6 >> 3 & 3U) % ((uint)rc_ss->no_ss + 1);
        uVar3 = (int)(uVar6 & 7) % ((uint)rc_ss->mcs_max + 1);
        if ((*(byte *)((int)&rc_ss->rate_map + iVar4) >> (uVar3 & 0x1f) & 1) != 0) {
          uVar7 = (ushort)uVar3 & 0xff;
        }
        uVar5 = uVar5 | (ushort)((int)((int)uVar6 >> 9 & 1U) % ((uint)rc_ss->short_gi + 1) << 9) |
                        (ushort)(iVar4 << 3) |
                ((short)((int)((int)uVar6 >> 7 & 3U) % (((uint)bVar1 - uVar8) + 1)) + (short)uVar8)
                * 0x80 | uVar7;
      }
    }
  }
  return uVar5;
}



void rc_update_counters(uint8_t sta_idx,uint32_t attempts,uint32_t failures,_Bool tx_ampdu,
                       _Bool retry_required)

{
  short sVar1;
  rc_sta_stats *prVar2;
  undefined3 in_register_00002029;
  uint uVar3;
  uint8_t uVar4;
  uint32_t *puVar5;
  ushort *puVar6;
  
  uVar3 = CONCAT31(in_register_00002029,sta_idx);
  if (9 < uVar3) {
    return;
  }
  if (sta_info_tab[uVar3].inst_nbr != -1) {
    prVar2 = sta_info_tab[uVar3].pol_tbl.sta_stats;
    if (prVar2 == (rc_sta_stats *)0x0) {
      assert_err("rc_ss != NULL","module",0x7ce);
    }
    puVar6 = &prVar2->retry[0].idx;
    prVar2->ampdu_packets = prVar2->ampdu_packets + 1;
    prVar2->ampdu_len = prVar2->ampdu_len + 1;
    do {
      if (attempts == 0) break;
      puVar5 = &prVar2->last_rc_time + (uint)*puVar6 * 3;
      if (failures < 4) {
        *(short *)(puVar5 + 1) = *(short *)(puVar5 + 1) + (short)attempts;
        sVar1 = (short)failures;
        failures = 0;
        *(short *)((int)puVar5 + 6) = ((short)attempts - sVar1) + *(short *)((int)puVar5 + 6);
        attempts = 0;
      }
      else {
        *(short *)(puVar5 + 1) = *(short *)(puVar5 + 1) + 4;
        attempts = attempts - 4;
        failures = failures - 4;
      }
      if (*(ushort *)(puVar5 + 1) < *(ushort *)((int)puVar5 + 6)) {
        assert_err("rc_rs->attempts >= rc_rs->success","module",0x7fa);
      }
      puVar6 = puVar6 + 4;
    } while (puVar6 != &(prVar2->max_tp_2_trial).idx);
    if (prVar2->trial_status == '\0') {
      if (prVar2->sample_wait != '\0') {
        prVar2->sample_wait = prVar2->sample_wait + -1;
        return;
      }
      uVar4 = '\x01';
    }
    else {
      if (prVar2->trial_status != '\x02') {
        return;
      }
      if ((sta_info_tab[uVar3].pol_tbl.upd_field & 1) != 0) {
        return;
      }
      uVar4 = '\x03';
    }
    prVar2->trial_status = uVar4;
  }
  return;
}



uint32_t rc_get_duration(uint param_1)

{
  uint8_t uVar1;
  undefined3 extraout_var;
  uint32_t uVar2;
  undefined3 extraout_var_00;
  uint uVar3;
  
  uVar1 = rc_get_mcs_index((uint16_t)param_1);
  _uVar1 = CONCAT31(extraout_var,uVar1);
  uVar3 = (int)param_1 >> 0xb & 7;
  if (uVar3 < 2) {
    if (_uVar1 < 4) {
      uVar2 = rc_duration_cck[(int)param_1 >> 10 & 1U | _uVar1 << 1];
    }
    else {
      uVar2 = rc_duration_non_ht[_uVar1 - 4];
    }
  }
  else {
    uVar2 = 0;
    if (uVar3 < 4) {
      uVar1 = rc_get_nss((uint16_t)param_1);
      uVar2 = rc_duration_ht_ampdu[_uVar1 << 3 | param_1 >> 9 & 1 | param_1 >> 6 & 6] /
              (CONCAT31(extraout_var_00,uVar1) + 1U);
    }
  }
  return uVar2;
}



void rc_update_bw_nss_max(uint8_t sta_idx,uint8_t bw_max,uint8_t nss_max)

{
  ushort uVar1;
  rc_sta_stats *rc_ss;
  uint16_t uVar2;
  undefined3 in_register_00002029;
  int iVar3;
  undefined2 extraout_var;
  undefined3 in_register_0000202d;
  undefined3 in_register_00002031;
  uint32_t *puVar4;
  uint uVar5;
  ushort *puVar6;
  uint16_t *puVar7;
  uint uVar8;
  uint32_t local_48;
  uint32_t cur_tp [10];
  
  iVar3 = CONCAT31(in_register_00002029,sta_idx);
  rc_ss = sta_info_tab[iVar3].pol_tbl.sta_stats;
  if (rc_ss == (rc_sta_stats *)0x0) {
    assert_err("rc_ss != NULL","module",0x969);
  }
  if (((uint)rc_ss->bw_max != CONCAT31(in_register_0000202d,bw_max)) ||
     ((uint)rc_ss->no_ss != CONCAT31(in_register_00002031,nss_max))) {
    rc_ss->bw_max = bw_max;
    if (3 < CONCAT31(in_register_0000202d,bw_max)) {
      assert_err("rc_ss->bw_max <= BW_160MHZ","module",0x96f);
    }
    rc_ss->no_ss = nss_max;
    if (7 < CONCAT31(in_register_00002031,nss_max)) {
      assert_err("rc_ss->no_ss < 8","module",0x971);
    }
    if (rc_ss->fixed_rate_cfg == 0xffff) {
      uVar2 = rc_get_lowest_rate_config(rc_ss);
      rc_ss->rate_stats[0].rate_config = uVar2;
      uVar2 = rc_get_initial_rate_config(rc_ss);
      rc_ss->rate_stats[(uint)rc_ss->no_samples - 1].rate_config = uVar2;
      uVar5 = 1;
LAB_230088ac:
      uVar1 = rc_ss->no_samples;
      if ((int)uVar5 < (int)((uint)uVar1 - 1)) {
        do {
          uVar2 = rc_new_random_rate(rc_ss);
          uVar8 = 0;
          puVar6 = &rc_ss->rate_stats[0].rate_config;
          while( true ) {
            if (rc_ss->no_samples <= uVar8) {
              rc_ss->rate_stats[uVar5].rate_config = uVar2;
              uVar5 = uVar5 + 1 & 0xffff;
              goto LAB_230088ac;
            }
            if ((uint)*puVar6 == CONCAT22(extraout_var,uVar2)) break;
            uVar8 = uVar8 + 1;
            puVar6 = puVar6 + 6;
          }
        } while( true );
      }
      puVar7 = &rc_ss->rate_stats[0].probability;
      uVar5 = 0;
      puVar4 = &local_48;
      while ((uint)uVar1 != uVar5) {
        *(undefined *)(puVar7 + 3) = 0;
        *(undefined *)((int)puVar7 + 7) = 1;
        *puVar7 = 0;
        *(undefined *)((int)puVar7 + 5) = 0;
        *puVar4 = 0;
        uVar5 = uVar5 + 1 & 0xffff;
        puVar7 = puVar7 + 6;
        puVar4 = puVar4 + 1;
      }
      rc_sort_samples_tp(rc_ss,&local_48);
      rc_update_retry_chain(rc_ss,&local_48);
      sta_info_tab[iVar3].pol_tbl.upd_field = sta_info_tab[iVar3].pol_tbl.upd_field | 1;
    }
  }
  return;
}



void rc_init_bcmc_rate(sta_info_tag *sta_entry,uint8_t basic_rate_idx)

{
  undefined3 in_register_0000202d;
  txl_buffer_control *ptVar1;
  uint uVar2;
  
  ptVar1 = (sta_entry->pol_tbl).buf_ctrl;
  uVar2 = 0;
  if (CONCAT31(in_register_0000202d,basic_rate_idx) < 4) {
    uVar2 = SEXT24((short)((sta_entry->pol_tbl).ppdu_tx_cfg & 0x400));
  }
  uVar2 = CONCAT31(in_register_0000202d,basic_rate_idx) | uVar2 | 0x20000000;
  *(uint *)(ptVar1->field_0 + 0x14) = uVar2;
  *(uint *)(ptVar1->field_0 + 0x18) = uVar2;
  *(uint *)(ptVar1->field_0 + 0x1c) = uVar2;
  *(uint *)(ptVar1->field_0 + 0x20) = uVar2;
  return;
}



_Bool rc_check_fixed_rate_config(rc_sta_stats *rc_ss,uint16_t fixed_rate_config)

{
  uint8_t uVar1;
  _Bool _Var2;
  undefined3 extraout_var;
  undefined2 in_register_0000202e;
  uint uVar3;
  uint uVar4;
  
  uVar4 = (uint)rc_ss->format_mod;
  uVar3 = ((uint)fixed_rate_config & 0x3800) >> 0xb;
  if (uVar4 < uVar3) {
    return false;
  }
  if (rc_ss->format_mod == 4) {
    if (uVar3 != uVar4) {
      return false;
    }
LAB_2300899e:
    if ((fixed_rate_config & 0x3000) == 0) {
LAB_230089f6:
      if (((CONCAT22(in_register_0000202e,fixed_rate_config) >> 10 & 1U) == 0) &&
         (rc_ss->p_type == '\x01')) {
        return false;
      }
      goto LAB_230089d0;
    }
  }
  else {
    if (1 < (uVar4 - 2 & 0xff)) goto LAB_2300899e;
    if ((fixed_rate_config & 0x3000) == 0) {
      if (3 < rc_ss->r_idx_min) {
        return false;
      }
      goto LAB_230089f6;
    }
  }
  if (((((fixed_rate_config & 0x200) != 0) && (rc_ss->short_gi == '\0')) ||
      ((uint)rc_ss->bw_max < (CONCAT22(in_register_0000202e,fixed_rate_config) >> 7 & 3U))) ||
     (uVar1 = rc_get_nss(fixed_rate_config), (uint)rc_ss->no_ss < CONCAT31(extraout_var,uVar1))) {
    return false;
  }
LAB_230089d0:
  _Var2 = rc_check_valid_rate(rc_ss,fixed_rate_config);
  return _Var2;
}



uint32_t rc_calc_tp(rc_sta_stats *rc_ss,uint8_t sample_idx)

{
  ushort uVar1;
  ushort rate_config;
  uint uVar2;
  _Bool _Var3;
  undefined3 extraout_var;
  int iVar4;
  uint32_t uVar5;
  undefined3 in_register_0000202d;
  
  uVar1 = *(ushort *)(&rc_ss->last_rc_time + CONCAT31(in_register_0000202d,sample_idx) * 3 + 2);
  if (uVar1 < 0x1999) {
    uVar5 = 0;
  }
  else {
    rate_config = *(ushort *)
                   ((int)(&rc_ss->last_rc_time + CONCAT31(in_register_0000202d,sample_idx) * 3) + 10
                   );
    uVar2 = 0;
    _Var3 = is_cck_group(rate_config);
    if (CONCAT31(extraout_var,_Var3) == 0) {
      uVar2 = 0x35390 / (uint)*(ushort *)((int)&rc_ss->avg_ampdu_len + 2);
    }
    iVar4 = rc_get_duration((uint)rate_config);
    uVar5 = (((uint)uVar1 * 1000) / (iVar4 + uVar2)) * 1000000 >> 0x10;
  }
  return uVar5;
}



_Bool rc_update_stats(rc_sta_stats *rc_ss,_Bool init)

{
  byte bVar1;
  ushort rate_config;
  _Bool _Var2;
  uint16_t rate_config_00;
  uint32_t uVar3;
  undefined2 extraout_var_03;
  undefined3 extraout_var;
  undefined2 extraout_var_04;
  undefined3 extraout_var_00;
  undefined2 extraout_var_05;
  undefined3 extraout_var_01;
  undefined2 extraout_var_06;
  undefined3 extraout_var_02;
  uint uVar4;
  undefined3 in_register_0000202d;
  rc_rate_stats *prVar5;
  uint32_t *cur_tp_00;
  uint32_t *puVar6;
  uint uVar7;
  ushort rate_config_01;
  uint16_t uVar8;
  uint8_t *puVar9;
  uint16_t *puVar10;
  uint16_t *puVar11;
  uint uVar12;
  char cVar13;
  uint16_t uStack148;
  ushort uStack146;
  uint16_t new_rate_cfg_array [6];
  step old_retry [4];
  uint32_t cur_tp [10];
  
  memcpy(new_rate_cfg_array + 4,rc_ss->retry,0x20);
  if (rc_ss->ampdu_packets != 0) {
    rate_config = rc_ss->ampdu_len;
    *(undefined4 *)&rc_ss->ampdu_len = 0;
    rc_ss->avg_ampdu_len =
         ((int)((uint)rate_config << 0x10) / (int)(uint)rc_ss->ampdu_packets) * 0x20 +
         rc_ss->avg_ampdu_len * 0x60 >> 7;
  }
  rate_config = rc_ss->no_samples;
  cur_tp_00 = (uint32_t *)&old_retry[3].idx;
  rc_ss->sample_slow = '\0';
  puVar9 = &rc_ss->rate_stats[0].n_retry;
  uVar7 = 0;
  puVar6 = cur_tp_00;
  while ((uint)rate_config != uVar7) {
    *puVar6 = 0;
    *puVar9 = '\0';
    puVar9[1] = '\x01';
    uVar7 = uVar7 + 1 & 0xffff;
    puVar6 = puVar6 + 1;
    puVar9 = puVar9 + 0xc;
  }
  rate_config_00 = rc_ss->fixed_rate_cfg;
  uVar12 = 0;
  if (rate_config_00 == 0xffff) {
    while (uVar12 < rc_ss->no_samples) {
      rc_calc_prob_ewma(rc_ss->rate_stats + uVar12);
      uVar3 = rc_calc_tp(rc_ss,(uint8_t)uVar12);
      *(uint32_t *)(&old_retry[3].idx + uVar12 * 2) = uVar3;
      uVar12 = uVar12 + 1 & 0xffff;
    }
    rc_sort_samples_tp(rc_ss,cur_tp_00);
    rc_update_retry_chain(rc_ss,cur_tp_00);
    if (CONCAT31(in_register_0000202d,init) == 0) {
      rate_config = rc_ss->no_samples;
      if (9 < rate_config) {
        cVar13 = '\0';
        rate_config = rc_ss->rate_stats[rc_ss->retry[0].idx].rate_config;
        uVar7 = (uint)rate_config;
        rate_config_01 = rc_ss->rate_stats[rc_ss->retry[1].idx].rate_config;
        memset(&uStack148,-1,0xc);
        do {
          switch(cVar13) {
          case '\x01':
            if ((((int)uVar7 >> 0xb & 6U) != 0) && (rc_ss->short_gi == '\x01')) {
              if ((rate_config & 0x200) == 0) {
                uStack146 = rate_config | 0x200;
              }
              else {
                uStack146 = rate_config & 0xfdff;
              }
            }
            break;
          case '\x02':
            rate_config_00 = rc_set_next_mcs_index(rc_ss,rate_config);
            if ((uVar7 != CONCAT22(extraout_var_03,rate_config_00)) &&
               (_Var2 = rc_check_valid_rate(rc_ss,rate_config_00), CONCAT31(extraout_var,_Var2) != 0
               )) {
              new_rate_cfg_array[0] = rate_config_00;
            }
            break;
          case '\x03':
            rate_config_00 = rc_set_previous_mcs_index(rc_ss,rate_config);
            if ((uVar7 != CONCAT22(extraout_var_04,rate_config_00)) &&
               (_Var2 = rc_check_valid_rate(rc_ss,rate_config_00),
               CONCAT31(extraout_var_00,_Var2) != 0)) {
              new_rate_cfg_array[1] = rate_config_00;
            }
            break;
          case '\x04':
            rate_config_00 = rc_set_next_mcs_index(rc_ss,rate_config_01);
            if (((uint)rate_config_01 != CONCAT22(extraout_var_05,rate_config_00)) &&
               (_Var2 = rc_check_valid_rate(rc_ss,rate_config_00),
               CONCAT31(extraout_var_01,_Var2) != 0)) {
              new_rate_cfg_array[2] = rate_config_00;
            }
            break;
          case '\x05':
            rate_config_00 = rc_set_previous_mcs_index(rc_ss,rate_config_01);
            if (((uint)rate_config_01 != CONCAT22(extraout_var_06,rate_config_00)) &&
               (_Var2 = rc_check_valid_rate(rc_ss,rate_config_00),
               CONCAT31(extraout_var_02,_Var2) != 0)) {
              new_rate_cfg_array[3] = rate_config_00;
            }
            break;
          default:
            uStack148 = rc_new_random_rate(rc_ss);
          }
          cVar13 = cVar13 + '\x01';
        } while (cVar13 != '\x06');
        rate_config = rc_ss->no_samples;
        uVar12 = 1;
        uVar7 = 0;
        while (uVar12 < rate_config) {
          puVar6 = &rc_ss->last_rc_time + uVar12 * 3;
          if ((((*(short *)(puVar6 + 2) < 0) && (*(byte *)(puVar6 + 3) < 0xb)) ||
              ((uint)rc_ss->retry[0].idx == uVar12)) ||
             ((((uint)rc_ss->retry[1].idx == uVar12 || ((uint)rc_ss->retry[2].idx == uVar12)) ||
              (5 < uVar7)))) {
            uVar12 = uVar12 + 1 & 0xffff;
          }
          else {
            rate_config_00 = (&uStack148)[uVar7];
            if (rate_config_00 != 0xffff) {
              uVar4 = 0;
              puVar11 = &rc_ss->rate_stats[0].rate_config;
              while (uVar4 < rate_config) {
                if (*puVar11 == rate_config_00) goto LAB_23008d8e;
                uVar4 = uVar4 + 1;
                puVar11 = puVar11 + 6;
              }
              *(uint16_t *)((int)puVar6 + 10) = rate_config_00;
              *(undefined2 *)(puVar6 + 2) = 0;
              *(undefined *)((int)puVar6 + 0xd) = 0;
              uVar12 = uVar12 + 1 & 0xffff;
            }
LAB_23008d8e:
            uVar7 = uVar7 + 1;
          }
          *(undefined2 *)(puVar6 + 1) = 0;
          *(undefined2 *)((int)puVar6 + 6) = 0;
        }
        *(undefined4 *)rc_ss->rate_stats = 0;
        goto LAB_23008c54;
      }
      prVar5 = rc_ss->rate_stats;
      rate_config_01 = 0;
      while (rate_config != rate_config_01) {
        rate_config_01 = rate_config_01 + 1;
        prVar5->attempts = 0;
        prVar5->success = 0;
        prVar5 = prVar5 + 1;
      }
    }
  }
  else {
    bVar1 = rc_ss->info;
    uVar12 = 0;
    if ((bVar1 & 0x20) != 0) {
      while (uVar8 = (uint16_t)uVar12, uVar12 < uVar7) {
        if (rc_ss->rate_stats[uVar12].rate_config == rate_config_00) goto LAB_23008de8;
        uVar12 = uVar12 + 1 & 0xff;
      }
      if (uVar7 == uVar12) {
        uVar12 = uVar12 - 1 & 0xff;
        uVar8 = (uint16_t)uVar12;
        *(uint16_t *)((int)(&rc_ss->last_rc_time + uVar12 * 3) + 10) = rate_config_00;
        *(undefined2 *)(&rc_ss->last_rc_time + uVar12 * 3 + 2) = 0;
      }
LAB_23008de8:
      rc_ss->retry[0].idx = uVar8;
      rc_ss->retry[1].idx = uVar8;
      rc_ss->retry[2].idx = uVar8;
      rc_ss->retry[0].tp = 0;
      rc_ss->retry[1].tp = 0;
      rc_ss->retry[2].tp = 0;
      prVar5 = rc_ss->rate_stats;
      uVar12 = 0;
      while (uVar7 != uVar12) {
        prVar5->attempts = 0;
        prVar5->success = 0;
        uVar12 = uVar12 + 1 & 0xffff;
        prVar5 = prVar5 + 1;
      }
      rc_ss->info = bVar1 & 0x9f | 0x40;
      init = true;
      goto LAB_23008c54;
    }
    uVar7 = (uint)*(byte *)&rc_ss->retry[0].idx;
    rc_calc_prob_ewma(rc_ss->rate_stats + uVar7);
    *(undefined2 *)(&rc_ss->last_rc_time + uVar7 * 3 + 1) = 0;
    *(undefined2 *)((int)(&rc_ss->last_rc_time + uVar7 * 3) + 6) = 0;
    *(undefined4 *)rc_ss->rate_stats = 0;
  }
  init = false;
LAB_23008c54:
  puVar10 = &rc_ss->retry[0].idx;
  puVar11 = new_rate_cfg_array;
  do {
    if (puVar11[6] != *puVar10) {
      return true;
    }
    puVar10 = puVar10 + 4;
    puVar11 = puVar11 + 4;
  } while (puVar10 != &(rc_ss->max_tp_2_trial).idx);
  return init;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rc_init(sta_info_tag *sta_entry)

{
  byte bVar1;
  ushort uVar2;
  uint uVar3;
  step *psVar4;
  uint8_t uVar5;
  uint8_t uVar6;
  _Bool _Var7;
  byte bVar8;
  uint16_t rate_map;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  undefined3 extraout_var_05;
  undefined3 extraout_var_06;
  undefined2 extraout_var_07;
  int iVar9;
  short sVar10;
  uint *puVar11;
  uint *puVar12;
  uint uVar13;
  ushort *puVar14;
  uint uVar15;
  uint uVar16;
  rc_sta_stats *__s;
  txl_buffer_control *ptVar17;
  uint uVar18;
  rc_sta_stats *rc_ss;
  uint uVar19;
  uint8_t *mcs_set;
  ushort *puVar20;
  
  bVar8 = sta_entry->staid;
  ptVar17 = (sta_entry->pol_tbl).buf_ctrl;
  if (9 < bVar8) {
    assert_err("sta_entry->staid < NX_REMOTE_STA_MAX","module",0x85f);
  }
  uVar16 = (uint)sta_entry->staid;
  __s = sta_stats + uVar16;
  (sta_entry->pol_tbl).sta_stats = __s;
  uVar5 = phy_get_ntx();
  uVar18 = CONCAT31(extraout_var,uVar5) << 0xe;
  memset(__s,0,200);
  if (((sta_entry->info).capa_flags & 2) == 0) {
    rate_map = me_legacy_rate_bitfield_build((mac_rateset *)&sta_entry->info,false);
    sta_stats[uVar16].rate_map_l = rate_map;
    uVar5 = me_legacy_ridx_min(rate_map);
    sta_stats[uVar16].r_idx_min = uVar5;
    if (0xb < CONCAT31(extraout_var_05,uVar5)) {
      assert_err("rc_ss->r_idx_min < MAC_RATESET_LEN","module",0x8f4);
    }
    uVar5 = me_legacy_ridx_max(sta_stats[uVar16].rate_map_l);
    sta_stats[uVar16].r_idx_max = uVar5;
    if (0xb < CONCAT31(extraout_var_06,uVar5)) {
      assert_err("rc_ss->r_idx_max < MAC_RATESET_LEN","module",0x8f6);
    }
    sta_stats[uVar16].mcs_max = -1;
    uVar5 = (sta_entry->info).bw_cur;
    sta_stats[uVar16].bw_max = uVar5;
    if (uVar5 != '\0') {
      assert_err("rc_ss->bw_max == BW_20MHZ","module",0x8f9);
    }
    sta_stats[uVar16].p_type = (byte)((int)(uint)(sta_entry->pol_tbl).ppdu_tx_cfg >> 10) & 1;
  }
  else {
    rate_map = me_legacy_rate_bitfield_build((mac_rateset *)&sta_entry->info,false);
    mcs_set = (sta_entry->info).ht_cap.mcs_rate;
    sta_stats[uVar16].format_mod = '\x02';
    sta_stats[uVar16].rate_map_l = rate_map;
    uVar5 = me_11n_nss_max(mcs_set);
    uVar6 = me_11n_nss_max(me_env.ht_cap.mcs_rate);
    uVar19 = CONCAT31(extraout_var_00,uVar5);
    if (CONCAT31(extraout_var_01,uVar6) < CONCAT31(extraout_var_00,uVar5)) {
      uVar19 = CONCAT31(extraout_var_01,uVar6);
    }
    sta_stats[uVar16].no_ss = (uint8_t)uVar19;
    if (3 < uVar19) {
      assert_err("rc_ss->no_ss <= 3","module",0x8a6);
    }
    memcpy(&sta_stats[uVar16].rate_map,mcs_set,4);
    rate_map = sta_stats[uVar16].rate_map_l;
    *(undefined *)&sta_stats[uVar16].rate_map = 0xff;
    sta_stats[uVar16].mcs_max = '\a';
    uVar5 = me_legacy_ridx_min(rate_map);
    sta_stats[uVar16].r_idx_min = uVar5;
    if (0xc < CONCAT31(extraout_var_02,uVar5)) {
      assert_err("(rc_ss->r_idx_min <= HW_RATE_54MBPS) || (rc_ss->r_idx_min == MAC_RATESET_LEN)",
                 "module",0x8b8);
    }
    uVar5 = me_legacy_ridx_max(sta_stats[uVar16].rate_map_l);
    sta_stats[uVar16].r_idx_max = uVar5;
    if (0xc < CONCAT31(extraout_var_03,uVar5)) {
      assert_err("(rc_ss->r_idx_max <= HW_RATE_54MBPS) || (rc_ss->r_idx_max == MAC_RATESET_LEN)",
                 "module",0x8be);
    }
    sta_stats[uVar16].p_type = (byte)((int)(uint)(sta_entry->pol_tbl).ppdu_tx_cfg >> 10) & 1;
    _Var7 = phy_ldpc_tx_supported();
    uVar2 = (sta_entry->info).ht_cap.ht_capa_info;
    if ((CONCAT31(extraout_var_04,_Var7) != 0) && ((uVar2 & 1) != 0)) {
      uVar18 = uVar18 | 0x40;
    }
    if ((int)((uint)uVar2 << 0x14) < 0) {
      sVar10 = 0x2000;
    }
    else {
      sVar10 = 0x1000;
    }
    sta_stats[uVar16].max_amsdu_len = sVar10 - 0x101;
    bVar1 = (sta_entry->info).bw_cur;
    sta_stats[uVar16].bw_max = bVar1;
    if (3 < bVar1) {
      assert_err("rc_ss->bw_max <= BW_160MHZ","module",0x8d5);
    }
    uVar5 = (sta_entry->info).bw_cur;
    if (uVar5 == '\0') {
      if (((sta_entry->info).ht_cap.ht_capa_info & 0x20) != 0) {
        uVar5 = '\x01';
        goto LAB_2300909a;
      }
    }
    else {
      if ((uVar5 == '\x01') && (((sta_entry->info).ht_cap.ht_capa_info & 0x40) != 0)) {
LAB_2300909a:
        sta_stats[uVar16].short_gi = uVar5;
      }
    }
  }
  if (sta_stats[uVar16].format_mod < 2) {
    uVar19 = (uint)sta_stats[uVar16].rate_map_l;
    uVar15 = 1 - (uint)sta_stats[uVar16].p_type;
    uVar13 = (((int)uVar19 >> 1 & 1U) + ((int)uVar19 >> 2 & 1U) << (uVar15 & 0x1f)) + (uVar19 & 1) +
             (((int)uVar19 >> 3 & 1U) << (uVar15 & 0x1f)) & 0xffff;
    uVar15 = 4;
    do {
      uVar3 = uVar15 & 0x1f;
      uVar15 = uVar15 + 1;
      uVar13 = uVar13 + ((int)uVar19 >> uVar3 & 1U) & 0xffff;
    } while (uVar15 != 0xc);
LAB_230091b4:
    if (10 < uVar13) {
      sta_stats[uVar16].no_samples = 10;
      goto LAB_230091c8;
    }
    sta_stats[uVar16].no_samples = (uint16_t)uVar13;
    if (uVar13 != 0) goto LAB_230091c8;
  }
  else {
    if (sta_stats[uVar16].format_mod < 4) {
      uVar19 = (uint)*(byte *)&sta_stats[uVar16].rate_map;
      iVar9 = 8;
      uVar15 = 0;
      do {
        uVar13 = uVar19 & 1;
        iVar9 = iVar9 + -1;
        uVar19 = uVar19 >> 1;
        uVar15 = uVar15 + (1 << ((uint)sta_stats[uVar16].short_gi & 0x1f)) * uVar13 & 0xffff;
      } while (iVar9 != 0);
      uVar13 = (uint)sta_stats[uVar16].rate_map_l;
      uVar19 = 1 - (uint)sta_stats[uVar16].p_type;
      uVar13 = uVar15 + (((int)uVar13 >> 1 & 1U) + ((int)uVar13 >> 2 & 1U) << (uVar19 & 0x1f)) +
                        (uVar13 & 1) + (((int)uVar13 >> 3 & 1U) << (uVar19 & 0x1f)) & 0xffff;
      goto LAB_230091b4;
    }
    sta_stats[uVar16].no_samples = 0;
  }
  assert_err("rc_ss->no_samples >= 1","module",0x8ff);
  if (10 < sta_stats[uVar16].no_samples) {
    assert_err("rc_ss->no_samples <= RC_MAX_N_SAMPLE","module",0x900);
  }
LAB_230091c8:
  rc_ss = sta_info_tab[sta_entry->staid].pol_tbl.sta_stats;
  if (rc_ss == (rc_sta_stats *)0x0) {
    assert_err("rc_ss != NULL","module",0x6e4);
  }
  uVar2 = rc_ss->no_samples;
  puVar20 = &rc_ss->rate_stats[0].rate_config;
  uVar19 = 0;
  puVar14 = puVar20;
  while (uVar19 != (uint)uVar2) {
    *puVar14 = 0xffff;
    uVar19 = uVar19 + 1 & 0xffff;
    puVar14 = puVar14 + 6;
  }
  rate_map = rc_get_lowest_rate_config(rc_ss);
  rc_ss->rate_stats[0].rate_config = rate_map;
  rate_map = rc_get_initial_rate_config(rc_ss);
  rc_ss->rate_stats[uVar19 - 1].rate_config = rate_map;
  uVar19 = 1;
LAB_23009232:
  do {
    uVar2 = rc_ss->no_samples;
    if ((int)((uint)uVar2 - 1) <= (int)uVar19) {
      rc_ss->retry[0].idx = (uint16_t)((uint)uVar2 - 1);
      rc_ss->retry[2].idx = uVar2 - 3;
      rc_ss->avg_ampdu_len = 0x10000;
      rc_ss->retry[1].idx = uVar2 - 2;
      rc_ss->fixed_rate_cfg = 0xffff;
      rc_ss->retry[0].tp = 0;
      rc_ss->retry[1].tp = 0;
      rc_ss->retry[2].tp = 0;
      rc_ss->retry[3].idx = 0;
      rc_ss->retry[3].tp = 0;
      rc_ss->info = '\0';
      rc_update_stats(rc_ss,true);
      rc_ss->sample_wait = '\x05';
      puVar11 = (uint *)(ptVar17->field_0 + 0x14);
      do {
        psVar4 = __s->retry;
        puVar12 = puVar11 + 1;
        __s = (rc_sta_stats *)&__s->rate_stats[0].probability;
        *puVar11 = (uint)sta_stats[uVar16].rate_stats[*(byte *)&psVar4->idx].rate_config |
                   0x80000000;
        puVar11 = puVar12;
      } while (puVar12 != (uint *)(ptVar17->field_0 + 0x24));
      sta_stats[uVar16].last_rc_time = _DAT_44b00120;
      *(undefined4 *)ptVar17->field_0 = 0xbadcab1e;
      *(uint *)(ptVar17->field_0 + 0xc) = ((uint)bVar8 + 8 & 0xff) << 10;
      *(undefined4 *)(ptVar17->field_0 + 0x10) = 0xffff0704;
      *(uint *)(ptVar17->field_0 + 4) = uVar18;
      bVar8 = phy_get_ntx();
      *(int *)(ptVar17->field_0 + 8) = (1 << ((uint)bVar8 + 1 & 0x1f)) + -1;
      ((sta_entry->pol_tbl).buf_ctrl)->mac_control_info = 0x2200;
      ((sta_entry->pol_tbl).buf_ctrl)->phy_control_info = sta_entry->paid_gid;
      (sta_entry->pol_tbl).upd_field = (sta_entry->pol_tbl).upd_field | 0x11;
      return;
    }
    rate_map = rc_new_random_rate(rc_ss);
    uVar15 = 0;
    puVar14 = puVar20;
    while (uVar15 < rc_ss->no_samples) {
      if ((uint)*puVar14 == CONCAT22(extraout_var_07,rate_map)) goto LAB_23009232;
      uVar15 = uVar15 + 1;
      puVar14 = puVar14 + 6;
    }
    rc_ss->rate_stats[uVar19].rate_config = rate_map;
    uVar19 = uVar19 + 1 & 0xffff;
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rc_check(uint8_t sta_idx,_Bool *tx_ampdu)

{
  ushort uVar1;
  ushort uVar2;
  ushort rate_config;
  ushort rate_config_00;
  uint16_t uVar3;
  bool bVar4;
  rc_sta_stats *rc_ss;
  uint uVar5;
  _Bool _Var6;
  uint8_t uVar7;
  uint8_t uVar8;
  undefined3 in_register_00002029;
  uint uVar9;
  undefined3 extraout_var;
  uint uVar10;
  uint32_t uVar11;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  uint32_t uVar12;
  byte bVar13;
  uint32_t *puVar14;
  uint uVar15;
  int iVar16;
  uint uVar17;
  uint uVar18;
  
  uVar9 = CONCAT31(in_register_00002029,sta_idx);
  if (9 < uVar9) {
    return;
  }
  rc_ss = sta_info_tab[uVar9].pol_tbl.sta_stats;
  if (rc_ss == (rc_sta_stats *)0x0) {
    assert_err("rc_ss != NULL","module",0x826);
  }
  iVar16 = 0;
  if ((int)((100000 - _DAT_44b00120) + rc_ss->last_rc_time) < 0) {
    _Var6 = rc_update_stats(rc_ss,false);
    iVar16 = CONCAT31(extraout_var,_Var6);
    rc_ss->trial_status = '\0';
    rc_ss->sw_retry_step = '\0';
    rc_ss->info = rc_ss->info & 0xef;
    rc_ss->last_rc_time = _DAT_44b00120;
  }
  if (rc_ss->trial_status == '\x01') {
    if ((rc_ss->info & 0x40) == 0) {
      bVar13 = rc_ss->format_mod;
      uVar1 = rc_ss->retry[0].idx;
      uVar15 = (uint)uVar1;
      if (bVar13 < 2) {
        if ((ushort)(rc_ss->rate_stats[uVar15].probability + 0xe667) < 0xd99b) {
          uVar7 = '\n';
        }
        else {
          uVar7 = '\x05';
        }
      }
      else {
        uVar7 = ((char)*(undefined2 *)((int)&rc_ss->avg_ampdu_len + 2) + '\b') * '\x02';
      }
      rc_ss->sample_wait = uVar7;
      next = next * 0x41c64e6d + 0x3039;
      uVar5 = (next >> 0x10) % (uint)rc_ss->no_samples;
      if (uVar5 != uVar15) {
        uVar2 = rc_ss->retry[1].idx;
        if (((uVar5 != (uint)uVar2) && (uVar18 = (uint)rc_ss->retry[2].idx, uVar5 != uVar18)) &&
           (puVar14 = &rc_ss->last_rc_time + uVar5 * 3, *(ushort *)(puVar14 + 2) < 0xf334)) {
          rate_config = *(ushort *)((int)puVar14 + 10);
          uVar10 = rc_get_duration((uint)rate_config);
          rate_config_00 = rc_ss->rate_stats[uVar15].rate_config;
          if (bVar13 < 2) {
            uVar15 = rc_get_duration((uint)rate_config_00);
            if (uVar15 < uVar10) {
              uVar11 = 0;
              bVar4 = 0x13 < *(byte *)(puVar14 + 3);
            }
            else {
              uVar11 = 0;
              bVar4 = true;
            }
          }
          else {
            uVar17 = 0x20;
            uVar15 = rc_get_duration((uint)rc_ss->rate_stats[(uint)uVar2].rate_config);
            if (*(char *)((int)puVar14 + 0xd) == '\0') {
              uVar17 = (uint)*(ushort *)((int)&rc_ss->avg_ampdu_len + 2);
            }
            if (uVar15 <= uVar10) {
              uVar7 = rc_get_nss(rate_config_00);
              uVar8 = rc_get_nss(rate_config);
              if ((CONCAT31(extraout_var_00,uVar7) - 1U < CONCAT31(extraout_var_01,uVar8)) ||
                 (uVar15 = rc_get_duration((uint)rc_ss->rate_stats[uVar18].rate_config),
                 uVar15 <= uVar10)) {
                if (uVar17 <= *(byte *)(puVar14 + 3)) {
                  bVar13 = rc_ss->sample_slow + 1;
                  rc_ss->sample_slow = bVar13;
                  if (bVar13 < 3) goto LAB_2300964c;
                  if (0xf < bVar13) {
                    rc_ss->sample_slow = '\x0f';
                  }
                }
                goto LAB_23009626;
              }
            }
LAB_2300964c:
            uVar11 = rc_calc_tp(rc_ss,(uint8_t)uVar5);
            bVar4 = true;
            if ((*(byte *)((int)puVar14 + 0xe) & 0xf) < 10) {
              bVar4 = uVar17 <= *(byte *)(puVar14 + 3);
            }
          }
          uVar12 = rc_ss->retry[1].tp;
          (rc_ss->max_tp_2_trial).idx = uVar2;
          (rc_ss->max_tp_2_trial).tp = uVar12;
          if (bVar4) {
            uVar12 = rc_ss->retry[0].tp;
            rc_ss->info = rc_ss->info & 0xfd;
            rc_ss->retry[1].tp = uVar12;
            rc_ss->retry[1].idx = uVar1;
            rc_ss->retry[0].tp = uVar11;
            rc_ss->retry[0].idx = (uint16_t)uVar5;
          }
          else {
            rc_ss->info = rc_ss->info | 2;
            rc_ss->retry[1].tp = uVar11;
            rc_ss->retry[1].idx = (uint16_t)uVar5;
          }
          rc_ss->trial_status = '\x02';
          goto LAB_2300958c;
        }
      }
    }
LAB_23009626:
    rc_ss->trial_status = '\0';
  }
  else {
    if (rc_ss->trial_status == '\x03') {
      if ((rc_ss->info & 2) == 0) {
        rc_ss->retry[0].idx = rc_ss->retry[1].idx;
        rc_ss->retry[0].tp = rc_ss->retry[1].tp;
      }
      uVar3 = (rc_ss->max_tp_2_trial).idx;
      rc_ss->trial_status = '\0';
      rc_ss->retry[1].idx = uVar3;
      uVar11 = (rc_ss->max_tp_2_trial).tp;
      (rc_ss->max_tp_2_trial).tp = 0;
      rc_ss->retry[1].tp = uVar11;
      (rc_ss->max_tp_2_trial).idx = 0xff;
      goto LAB_2300958c;
    }
  }
  if (iVar16 == 0) {
    return;
  }
LAB_2300958c:
  sta_info_tab[uVar9].pol_tbl.upd_field = sta_info_tab[uVar9].pol_tbl.upd_field | 1;
  return;
}



uint8_t rxu_cntrl_machdr_len_get(uint16_t frame_cntl)

{
  uint8_t uVar1;
  
  uVar1 = '\x18';
  if ((frame_cntl & 0x300) == 0x300) {
    uVar1 = '\x1e';
  }
  if ((frame_cntl & 0xfc) == 0x88) {
    uVar1 = uVar1 + '\x02';
  }
  if ((short)frame_cntl < 0) {
    uVar1 = uVar1 + '\x04';
  }
  return uVar1;
}



_Bool rxu_cntrl_protected_handle(uint8_t *frame,uint32_t statinfo)

{
  ushort *puVar1;
  uint uVar2;
  vif_info_tag *pvVar3;
  int iVar4;
  
  uVar2 = statinfo & 0x1c;
  puVar1 = (ushort *)(frame + DAT_4201b9d0);
  if (uVar2 == 0x18) {
    DAT_4201b9d0 = DAT_4201b9d0 + 8;
    DAT_4201b9dc = (uint)puVar1[3];
    DAT_4201b9d8 = (uint)puVar1[2] << 0x10 | (uint)*(byte *)(puVar1 + 1) |
                   ((uint)*puVar1 & 0xff) << 8;
    DAT_4201b9f8 = DAT_4201b9f8 | 3;
    if ((statinfo & 0x400) == 0) {
      iVar4 = (uint)DAT_4201b9d1 * 0x1b0 + 0x40;
      pvVar3 = (vif_info_tag *)sta_info_tab;
    }
    else {
      iVar4 = (uint)(puVar1[1] >> 0xe) * 0x68 + (uint)DAT_4201b9d2 * 0x5d8 + 0x420;
      pvVar3 = vif_info_tab;
    }
    key = (key_info_tag *)((int)&(pvVar3->list_hdr).next + iVar4);
  }
  else {
    if (uVar2 == 0x1c) {
      if ((statinfo & 0x400) == 0) {
        iVar4 = (uint)DAT_4201b9d1 * 0x1b0 + 0x40;
        pvVar3 = (vif_info_tag *)sta_info_tab;
      }
      else {
        iVar4 = (uint)(puVar1[1] >> 0xe) * 0x68 + (uint)DAT_4201b9d2 * 0x5d8 + 0x420;
        pvVar3 = vif_info_tab;
      }
      key = (key_info_tag *)((int)&(pvVar3->list_hdr).next + iVar4);
      DAT_4201b9d0 = DAT_4201b9d0 + 8;
      DAT_4201b9dc = (uint)puVar1[3];
      DAT_4201b9d8 = CONCAT22(puVar1[2],*puVar1);
      DAT_4201b9f8 = DAT_4201b9f8 | 2;
    }
    else {
      if (uVar2 != 0x14) {
        return false;
      }
      DAT_4201b9d0 = DAT_4201b9d0 + 4;
    }
  }
  return true;
}


/*
Unable to decompile 'rxu_mpdu_upload_and_indicate'
Cause: Exception while decompiling 23009828: Decompiler process died

*/


undefined4 rxu_mgt_frame_check(rx_swdesc *param_1,uint param_2)

{
  char cVar1;
  ushort length;
  bool bVar2;
  ushort uVar3;
  int8_t iVar4;
  ushort *bcn_addr;
  ushort uVar5;
  _Bool _Var6;
  ke_state_t kVar7;
  undefined3 extraout_var;
  undefined2 extraout_var_01;
  undefined2 extraout_var_02;
  undefined3 extraout_var_00;
  undefined2 *puVar8;
  byte sta_idx;
  byte bw;
  uint8_t nss;
  co_list_hdr cVar9;
  char *pcVar10;
  uint uVar11;
  uint uVar12;
  ke_task_id_t dest_id;
  rx_dmadesc *prVar13;
  uint uVar14;
  vif_info_tag *vif;
  int8_t iStack73;
  phy_channel_info apStack72 [2];
  
  sta_idx = (byte)param_2;
  prVar13 = param_1->dma_hdrdesc;
  iStack73 = '\0';
  bcn_addr = *(ushort **)((prVar13->hd).first_pbd_ptr + 0x18);
  length = *bcn_addr;
  if ((length & 0x400) != 0) {
    return 1;
  }
  if ((*(byte *)(bcn_addr + 0xb) & 0xf) != 0) {
    return 1;
  }
  if ((param_2 == 0xff) && (DAT_4201b9d2 = 0xff, ((prVar13->hd).statinfo & 0x600) == 0)) {
    cVar9 = (co_list_hdr)vif_mgmt_env.used_list.first;
    if (((length == 0xb0) || (bVar2 = true, length == 0)) &&
       ((((bVar2 = true, *(char *)(bcn_addr + 2) == *(char *)(bcn_addr + 8) &&
          (*(char *)((int)bcn_addr + 5) == *(char *)((int)bcn_addr + 0x11))) &&
         (*(char *)(bcn_addr + 3) == *(char *)(bcn_addr + 9))) &&
        ((*(char *)((int)bcn_addr + 7) == *(char *)((int)bcn_addr + 0x13) &&
         (*(char *)(bcn_addr + 4) == *(char *)(bcn_addr + 10))))))) {
      bVar2 = *(char *)((int)bcn_addr + 9) != *(char *)((int)bcn_addr + 0x15);
    }
    while (DAT_4201b9d2 = sta_idx, cVar9 != (co_list_hdr)0x0) {
      if (((*(char *)&((co_list_hdr *)((int)cVar9 + 0x50))->next == *(char *)(bcn_addr + 2)) &&
          (*(char *)((int)cVar9 + 0x51) == *(char *)((int)bcn_addr + 5))) &&
         ((*(char *)((int)cVar9 + 0x52) == *(char *)(bcn_addr + 3) &&
          (((*(char *)((int)cVar9 + 0x53) == *(char *)((int)bcn_addr + 7) &&
            (*(char *)&((co_list_hdr *)((int)cVar9 + 0x54))->next == *(char *)(bcn_addr + 4))) &&
           (*(char *)((int)cVar9 + 0x55) == *(char *)((int)bcn_addr + 9))))))) {
        if (*(char *)((int)cVar9 + 0x56) == '\0') {
          if (bVar2) {
LAB_23009a66:
            DAT_4201b9d2 = *(byte *)((int)cVar9 + 0x57);
            break;
          }
        }
        else {
          if ((*(char *)((int)cVar9 + 0x56) == '\x02') && (!bVar2)) goto LAB_23009a66;
        }
      }
      cVar9 = *(co_list_hdr *)cVar9;
    }
  }
  phyif_utils_decode((phyif_utils_recvtable_t *)&(prVar13->hd).recvec1a,&iStack73);
  iVar4 = iStack73;
  bw = DAT_4201b9d0;
  uVar3 = *bcn_addr;
  uVar14 = (uint)DAT_4201b9d0;
  uVar11 = (uint)DAT_4201b9d2;
  length = (prVar13->hd).frmlen;
  uVar12 = (uint)length;
  if (DAT_4201b9d2 == 0xff) {
    if (param_2 != uVar11) {
      DAT_4201b9d2 = sta_info_tab[param_2].inst_nbr;
      uVar11 = (uint)DAT_4201b9d2;
      goto LAB_23009ab4;
    }
    nss = '\x04';
    vif = (vif_info_tag *)0x0;
  }
  else {
LAB_23009ab4:
    vif = vif_info_tab + uVar11;
    nss = vif_info_tab[uVar11].type;
  }
  uVar5 = uVar3 & 0xfc;
  if (uVar5 == 0x50) {
    if (vif == (vif_info_tag *)0x0) goto LAB_23009af0;
    bVar2 = true;
    dest_id = 4;
    goto LAB_23009c10;
  }
  if (uVar5 < 0x51) {
    if (uVar5 == 0x20) {
LAB_23009b3e:
      _Var6 = apm_embedded_enabled(vif);
      if (CONCAT31(extraout_var,_Var6) == 0) {
LAB_23009af0:
        rxu_mpdu_upload_and_indicate(param_1);
        return 1;
      }
LAB_23009c0c:
      bVar2 = true;
      dest_id = 7;
      goto LAB_23009c10;
    }
    if (uVar5 < 0x21) {
      if ((uVar3 & 0xfc) == 0) goto LAB_23009b3e;
      if (uVar5 != 0x10) goto LAB_23009af0;
    }
    else {
      if (uVar5 != 0x30) {
        if (uVar5 != 0x40) goto LAB_23009af0;
        goto LAB_23009b3e;
      }
    }
    if (nss != '\0') goto LAB_23009af0;
  }
  else {
    if (uVar5 != 0xb0) {
      if (0xb0 < uVar5) {
        if (uVar5 != 0xc0) {
          if ((uVar5 != 0xd0) || (pcVar10 = (char *)((int)bcn_addr + uVar14), param_2 == 0xff))
          goto LAB_23009af0;
          cVar1 = *pcVar10;
          if (cVar1 == '\a') {
            if (pcVar10[1] == '\0') {
              if ((sta_info_tab[param_2].info.capa_flags & 2) == 0) {
                return 0;
              }
              bw = pcVar10[2];
              nss = -1;
              if (1 < bw) {
                return 0;
              }
            }
            else {
              if (pcVar10[1] != '\x01') goto LAB_23009af0;
              if ((sta_info_tab[param_2].info.capa_flags & 2) == 0) {
                return 0;
              }
              nss = -1;
              if ((pcVar10[2] & 1U) != 0) {
                nss = '\0';
              }
              bw = 0xff;
            }
            me_sta_bw_nss_max_upd(sta_idx,bw,nss);
            return 0;
          }
          if (cVar1 == '\b') {
            if ((int)(uVar12 - uVar14) < 4) {
              return 0;
            }
            if ((DAT_4201b9d2 == 0xff) ||
               ((byte)(vif_info_tab[DAT_4201b9d2].type | pcVar10[1]) != 0)) goto LAB_23009af0;
            dest_id = 6;
          }
          else {
            if (cVar1 != '\x03') goto LAB_23009af0;
            dest_id = 8;
          }
          bVar2 = false;
          goto LAB_23009c10;
        }
LAB_23009b64:
        if (param_2 == 0xff) {
          return 0;
        }
        goto LAB_23009b6e;
      }
      if (uVar5 != 0x80) {
        if (uVar5 != 0xa0) goto LAB_23009af0;
        goto LAB_23009b64;
      }
      kVar7 = ke_state_get(4);
      bVar2 = CONCAT22(extraout_var_01,kVar7) != 1;
      if (bVar2) {
        dest_id = 0xff;
      }
      else {
        dest_id = 4;
      }
      bVar2 = !bVar2;
      if (param_2 != 0xff) {
        if (vif->active != false) {
          me_beacon_check(DAT_4201b9d2,length,(uint32_t)bcn_addr);
        }
LAB_23009be6:
        if (dest_id != 0xff) goto LAB_23009c10;
        goto LAB_23009af0;
      }
      kVar7 = ke_state_get(4);
      if ((CONCAT22(extraout_var_02,kVar7) == 1) ||
         (_Var6 = apm_embedded_enabled(vif), CONCAT31(extraout_var_00,_Var6) == 0))
      goto LAB_23009be6;
      goto LAB_23009c0c;
    }
LAB_23009b6e:
    if (nss != '\0') goto LAB_23009b3e;
  }
  bVar2 = false;
  dest_id = 6;
LAB_23009c10:
  puVar8 = (undefined2 *)
           ke_msg_alloc(0x2c00,dest_id,0xb,(uint16_t)((uVar12 + 0x1c) * 0x10000 >> 0x10));
  if (puVar8 != (undefined2 *)0x0) {
    phy_get_channel(apStack72,'\0');
    if (!bVar2) {
      if ((bw & 1) != 0) {
        assert_warn("(machdr_length & 0x1) == 0","module",0x64d);
      }
      uVar12 = uVar12 - uVar14 & 0xffff;
      bcn_addr = (ushort *)((int)bcn_addr + uVar14);
    }
    *puVar8 = (short)uVar12;
    uVar11 = 0;
    while (bw = DAT_4201b9d2, (uVar12 + 3 & 0xfffffffc) != uVar11) {
      *(undefined4 *)((int)puVar8 + uVar11 + 0x1c) = *(undefined4 *)((int)bcn_addr + uVar11);
      uVar11 = uVar11 + 4;
    }
    puVar8[1] = uVar3;
    *(byte *)((int)puVar8 + 7) = sta_idx;
    *(byte *)(puVar8 + 4) = bw;
    *(int8_t *)(puVar8 + 0xd) = iVar4;
    *(int8_t *)((int)puVar8 + 0x19) = iVar4;
    puVar8[2] = (short)(apStack72[0].info1 >> 0x10);
    *(char *)(puVar8 + 3) = (char)apStack72[0].info1;
    *(undefined *)(puVar8 + 0xc) = *(undefined *)((int)&(prVar13->hd).recvec1c + 3);
    if ((dest_id == 7) && ((uVar3 & 0xfc) == 0)) {
      *(uint32_t *)(puVar8 + 8) = (prVar13->hd).tsflo;
      *(uint32_t *)(puVar8 + 10) = (prVar13->hd).tsfhi;
      *(byte *)((int)puVar8 + 0x1b) = (byte)((prVar13->hd).recvec1a >> 0xc) & 0xf;
    }
    ke_msg_send(puVar8);
  }
  return 0;
}



void rxu_cntrl_init(void)

{
  co_list_init((co_list *)&swdesc);
  co_list_init((co_list *)&DAT_4201ba00);
  co_list_init((co_list *)&DAT_4201ba14);
  co_list_init((co_list *)&DAT_4201ba1c);
  DAT_4201ba2a = 0xffff;
  return;
}


/*
Unable to decompile 'rxu_cntrl_frame_handle'
Cause: Exception while decompiling 23009dea: Decompiler process died

*/


// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rxu_cntrl_monitor_pm(mac_addr *addr)

{
  if (DAT_4201ba37 == '\0') {
    _DAT_4201ba30 = addr->array[0];
    _DAT_4201ba32 = addr->array[1];
    _DAT_4201ba34 = addr->array[2];
    _DAT_4201ba36 = 0x100;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t rxu_cntrl_get_pm(void)

{
  _DAT_4201ba36 = 0;
  return DAT_4201ba36;
}



void rxu_cntrl_evt(int dummy)

{
  ke_evt_clear(0x80000);
  if (swdesc != (rx_swdesc *)0x0) {
    ke_evt_set(0x20000000);
    return;
  }
  return;
}



// WARNING: Variable defined which should be unmapped: pkt

void rxu_swdesc_upload_evt(int arg)

{
  rx_swdesc *swdesc;
  uint uVar1;
  int iVar2;
  uint32_t uVar3;
  uint32_t *puVar4;
  uint32_t *puVar5;
  uint32_t uVar6;
  uint32_t local_48;
  wifi_pkt pkt;
  
  ke_evt_clear(0x20000000);
  swdesc = (rx_swdesc *)co_list_pop_front((co_list *)&swdesc);
  while (swdesc != (rx_swdesc *)0x0) {
    uVar1 = (uint)(swdesc->dma_hdrdesc->hd).frmlen;
    memset(&local_48,0,0x28);
    puVar4 = (uint32_t *)&local_48;
    uVar6 = (swdesc->dma_hdrdesc->hd).first_pbd_ptr;
    puVar5 = puVar4;
    while ((uVar1 != 0 && (puVar5 != pkt.pkt + 3))) {
      swdesc->pbd_count = swdesc->pbd_count + '\x01';
      uVar3 = *(uint32_t *)(uVar6 + 8);
      *puVar5 = uVar3;
      *(short *)(puVar4 + 8) = ((short)*(undefined4 *)(uVar6 + 0xc) + 1) - (short)uVar3;
      puVar5[4] = uVar6 + 0x1c;
      *(undefined4 *)(uVar6 + 0x14) = 1;
      if (uVar1 < 0x350) {
        uVar1 = 0;
      }
      else {
        uVar1 = uVar1 - 0x350;
      }
      uVar6 = *(uint32_t *)(uVar6 + 4);
      puVar5 = puVar5 + 1;
      puVar4 = (uint32_t *)((int)puVar4 + 2);
    }
    swdesc->use_in_tcpip = '\x01';
    swdesc->dma_hdrdesc->use_in_tcpip = 1;
    iVar2 = tcpip_stack_input(swdesc,swdesc->status,&(swdesc->dma_hdrdesc->hd).frmlen,
                              swdesc->dma_hdrdesc->payl_offset,(wifi_pkt *)&local_48);
    if (iVar2 == 0) {
      vTaskEnterCritical();
      rxl_cntrl_env.packet_stack_cnt = rxl_cntrl_env.packet_stack_cnt + swdesc->pbd_count;
      vTaskExitCritical();
    }
    else {
      rxl_mpdu_free(swdesc);
    }
    swdesc = (rx_swdesc *)co_list_pop_front((co_list *)&swdesc);
  }
  return;
}



void scanu_confirm(uint8_t status)

{
  uint8_t *puVar1;
  uint8_t *puVar2;
  
  if (scanu_env.joining == false) {
    puVar2 = (uint8_t *)ke_msg_alloc(0x1001,scanu_env.src_id,4,1);
    puVar1 = (uint8_t *)0x0;
  }
  else {
    puVar2 = (uint8_t *)ke_msg_alloc(0x1003,scanu_env.src_id,4,1);
    puVar1 = (uint8_t *)ke_msg_alloc(0x1003,0xd,4,1);
  }
  *puVar2 = status;
  ke_msg_free(&scanu_env.param[-1].add_ies);
  scanu_env.param = (scanu_start_req *)0x0;
  ke_msg_send(puVar2);
  if (puVar1 != (uint8_t *)0x0) {
    *puVar1 = status;
    ke_msg_send(puVar1);
  }
  ke_state_set(4,0);
  return;
}



void scanu_raw_send_cfm(uint8_t status,ke_task_id_t dst_id)

{
  undefined3 in_register_00002029;
  undefined4 *puVar1;
  
  puVar1 = (undefined4 *)ke_msg_alloc(0x1006,dst_id,4,4);
  *puVar1 = CONCAT31(in_register_00002029,status);
  ke_msg_send();
  return;
}



void scanu_init(void)

{
  ke_state_set(4,0);
  memset(&scanu_env,0,0x194);
  scanu_env.dma_desc.dma_desc = &scanu_add_ie;
  scanu_env.dma_desc.cb = scanu_dma_cb;
  scanu_env.dma_desc.env = (void *)0x0;
  scanu_add_ie.dma_desc.dest = 0x42047ddc;
  return;
}



mac_scan_result * scanu_find_result(mac_addr *bssid_ptr,_Bool allocate)

{
  undefined3 in_register_0000202d;
  mac_scan_result *pmVar1;
  
  pmVar1 = scanu_env.scan_result;
  do {
    if (pmVar1->valid_flag == false) {
      if (CONCAT31(in_register_0000202d,allocate) != 0) {
        return pmVar1;
      }
    }
    else {
      if ((((*(char *)(pmVar1->bssid).array == *(char *)bssid_ptr->array) &&
           (*(char *)((int)(pmVar1->bssid).array + 1) == *(char *)((int)bssid_ptr->array + 1))) &&
          (*(char *)((pmVar1->bssid).array + 1) == *(char *)(bssid_ptr->array + 1))) &&
         (((*(char *)((int)(pmVar1->bssid).array + 3) == *(char *)((int)bssid_ptr->array + 3) &&
           (*(char *)((pmVar1->bssid).array + 2) == *(char *)(bssid_ptr->array + 2))) &&
          (*(char *)((int)(pmVar1->bssid).array + 5) == *(char *)((int)bssid_ptr->array + 5))))) {
        return pmVar1;
      }
    }
    pmVar1 = pmVar1 + 1;
    if (pmVar1 == (mac_scan_result *)&scanu_env.src_id) {
      return (mac_scan_result *)0x0;
    }
  } while( true );
}



// WARNING: Restarted to delay deadcode elimination for space: ram

undefined4 scanu_frame_handler(ushort *param_1)

{
  undefined uVar1;
  uint8_t band;
  _Bool _Var2;
  ushort uVar3;
  scanu_start_req *psVar4;
  sm_connect_req *psVar5;
  uchar uVar6;
  ke_state_t kVar7;
  uint16_t uVar8;
  int iVar9;
  undefined2 extraout_var;
  mac_scan_result *pmVar10;
  scan_chan_tag *psVar11;
  void *__src;
  byte bVar12;
  uint16_t freq;
  uint __n;
  undefined *puVar13;
  uint8_t *puVar14;
  undefined *puVar15;
  uint8_t *rsn_ie;
  SecurityMode_t *security_mode;
  char cVar16;
  uint uVar17;
  uint uVar18;
  mac_bss_info *bss;
  int iVar19;
  Cipher_t *mcstCipher;
  Cipher_t *mcstCipher_00;
  Cipher_t *ucstCipher;
  uint32_t uVar20;
  mac_ssid *pmVar21;
  uint uVar22;
  ushort *buffer;
  mac_rateset *mac_rate_set_ptr;
  Cipher_t *ucstCipher_00;
  undefined uStack100;
  undefined local_63 [47];
  
  psVar4 = scanu_env.param;
  buffer = param_1 + 0x20;
  uVar22 = (uint)(scanu_env.param)->vif_idx;
  iVar9 = mac_ie_find(buffer,(uint)*param_1 - 0x24 & 0xffff,0);
  if (iVar9 != 0) {
    bVar12 = *(byte *)(iVar9 + 1);
    uVar17 = (uint)bVar12;
    if (bVar12 < 0x21) {
      if (bVar12 == 0) goto LAB_2300a9ca;
    }
    else {
      uVar17 = 0x20;
    }
    puVar13 = (undefined *)(iVar9 + 2);
    if (*(char *)(iVar9 + 2) != '\0') {
      uStack100 = (undefined)uVar17;
      puVar15 = &uStack100;
      uVar18 = uVar17;
      while( true ) {
        uVar18 = uVar18 - 1;
        puVar15 = puVar15 + 1;
        if (uVar18 == 0xffffffff) break;
        uVar1 = *puVar13;
        puVar13 = puVar13 + 1;
        *puVar15 = uVar1;
      }
      local_63[uVar17] = 0;
    }
  }
LAB_2300a9ca:
  kVar7 = ke_state_get(4);
  if (((CONCAT22(extraout_var,kVar7) != 1) ||
      (pmVar10 = scanu_find_result((mac_addr *)(param_1 + 0x16),true),
      pmVar10 == (mac_scan_result *)0x0)) ||
     ((((byte)scanu_env.bssid.array[0] & 1) == 0 &&
      (((((*(byte *)(param_1 + 0x16) != (byte)scanu_env.bssid.array[0] ||
          (*(char *)((int)param_1 + 0x2d) != scanu_env.bssid.array[0]._1_1_)) ||
         (*(char *)(param_1 + 0x17) != (char)scanu_env.bssid.array[1])) ||
        ((*(char *)((int)param_1 + 0x2f) != scanu_env.bssid.array[1]._1_1_ ||
         (*(char *)(param_1 + 0x18) != (char)scanu_env.bssid.array[2])))) ||
       (*(char *)((int)param_1 + 0x31) != scanu_env.bssid.array[2]._1_1_)))))) goto LAB_2300b100;
  (pmVar10->bssid).array[0] = param_1[0x16];
  (pmVar10->bssid).array[1] = param_1[0x17];
  (pmVar10->bssid).array[2] = param_1[0x18];
  pmVar10->beacon_period = param_1[0x1e];
  uVar3 = param_1[0x1f];
  pmVar10->cap_info = uVar3;
  freq = uVar3 & 1;
  if ((uVar3 & 1) == 0) {
    freq = 2;
  }
  pmVar10->bsstype = freq;
  uVar3 = *param_1;
  uVar17 = (uint)uVar3 - 0x24 & 0xffff;
  iVar9 = mac_ie_find(buffer,uVar17,0);
  if (iVar9 == 0) {
    (pmVar10->ssid).length = '\0';
  }
  else {
    bVar12 = *(byte *)(iVar9 + 1);
    uVar18 = (uint)bVar12;
    if (bVar12 < 0x21) {
      if (bVar12 == 0) goto LAB_2300aa9e;
    }
    else {
      uVar18 = 0x20;
    }
    rsn_ie = (uint8_t *)(iVar9 + 2);
    if (*(char *)(iVar9 + 2) != '\0') {
      (pmVar10->ssid).length = (uint8_t)uVar18;
      puVar14 = (pmVar10->ssid).array;
      while (uVar18 = uVar18 - 1, uVar18 != 0xffffffff) {
        band = *rsn_ie;
        rsn_ie = rsn_ie + 1;
        *puVar14 = band;
        puVar14 = puVar14 + 1;
      }
    }
  }
LAB_2300aa9e:
  pmVar10->ppm_rel = *(int8_t *)(param_1 + 0xd);
  pmVar10->ppm_abs = *(int8_t *)((int)param_1 + 0x19);
  if (psVar4->ssid_cnt != '\0') {
    uVar18 = 0;
    pmVar21 = psVar4->ssid;
    while ((int)uVar18 < (int)(uint)psVar4->ssid_cnt) {
      if (pmVar21->length == 0) goto LAB_2300ab3c;
      __n = (uint)(pmVar10->ssid).length;
      if ((__n == (uint)pmVar21->length) &&
         (iVar9 = memcmp(pmVar21->array,(pmVar10->ssid).array,__n), iVar9 == 0)) break;
      uVar18 = uVar18 + 1;
      pmVar21 = pmVar21 + 1;
    }
    if ((uint)psVar4->ssid_cnt == uVar18) goto LAB_2300b100;
  }
LAB_2300ab3c:
  iVar9 = mac_ie_find(buffer,uVar17,3);
  if (iVar9 == 0) {
    if (pmVar10->rssi < *(char *)(param_1 + 0xc)) {
      psVar11 = me_freq_to_chan_ptr(*(uint8_t *)(param_1 + 3),param_1[2]);
      pmVar10->chan = psVar11;
      cVar16 = *(char *)(param_1 + 0xc);
      goto LAB_2300ab8c;
    }
  }
  else {
    bVar12 = *(byte *)(iVar9 + 2);
    band = *(uint8_t *)(param_1 + 3);
    if (band == '\0') {
      if ((uint)bVar12 - 1 < 0xe) {
        if (bVar12 == 0xe) {
          freq = 0x9b4;
        }
        else {
          freq = (ushort)bVar12 * 5 + 0x967;
        }
      }
      else {
LAB_2300afea:
        freq = 0xffff;
      }
    }
    else {
      if ((band != '\x01') || (0xa4 < (uint)bVar12 - 1)) goto LAB_2300afea;
      freq = (ushort)bVar12 * 5 + 5000;
    }
    psVar11 = me_freq_to_chan_ptr(band,freq);
    pmVar10->chan = psVar11;
    cVar16 = *(char *)(param_1 + 0xc);
    if (pmVar10->rssi < cVar16) {
LAB_2300ab8c:
      pmVar10->rssi = cVar16;
    }
  }
  if (scanu_env.joining != false) {
    bss = &vif_info_tab[uVar22].bss_info;
    vif_info_tab[uVar22].bss_info.bsstype = pmVar10->bsstype;
    mac_rate_set_ptr = &vif_info_tab[uVar22].bss_info.rate_set;
    *(undefined4 *)vif_info_tab[uVar22].bss_info.bssid.array = *(undefined4 *)(pmVar10->bssid).array
    ;
    vif_info_tab[uVar22].bss_info.bssid.array[2] = (pmVar10->bssid).array[2];
    vif_info_tab[uVar22].bss_info.cap_info = pmVar10->cap_info;
    vif_info_tab[uVar22].bss_info.beacon_period = pmVar10->beacon_period;
    memcpy(&vif_info_tab[uVar22].bss_info.ssid,&pmVar10->ssid,0x22);
    psVar11 = pmVar10->chan;
    vif_info_tab[uVar22].bss_info.valid_flags = 0;
    vif_info_tab[uVar22].bss_info.chan = psVar11;
    vif_info_tab[uVar22].bss_info.ppm_rel = pmVar10->ppm_rel;
    vif_info_tab[uVar22].bss_info.ppm_abs = pmVar10->ppm_abs;
    freq = (uint16_t)(((uint)uVar3 - 0x24) * 0x10000 >> 0x10);
    me_extract_rate_set((uint32_t)buffer,freq,mac_rate_set_ptr);
    if (pmVar10->chan->band == '\0') {
      uVar8 = me_legacy_rate_bitfield_build(mac_rate_set_ptr,true);
      if ((uVar8 & 0xf) == 0) {
        vif_info_tab[uVar22].bss_info.high_11b_rate = '\x01';
      }
      else {
        iVar9 = __clzsi2((uint)uVar8 & 0xf);
        vif_info_tab[uVar22].bss_info.high_11b_rate = '\x1f' - (char)iVar9;
      }
    }
    iVar9 = mac_vsie_find(buffer,uVar17,&DAT_230750d0,5);
    if (iVar9 == 0) {
      vif_info_tab[uVar22].bss_info.edca_param.ac_param[0] = 0xa43;
      vif_info_tab[uVar22].bss_info.edca_param.ac_param[1] = 0xa43;
      vif_info_tab[uVar22].bss_info.edca_param.ac_param[2] = 0xa43;
      vif_info_tab[uVar22].bss_info.edca_param.ac_param[3] = 0xa43;
    }
    else {
      vif_info_tab[uVar22].bss_info.edca_param.qos_info = *(uint8_t *)(iVar9 + 8);
      vif_info_tab[uVar22].bss_info.cap_info = vif_info_tab[uVar22].bss_info.cap_info | 0x200;
      uVar18 = *(uint *)(iVar9 + 10);
      bVar12 = (byte)(uVar18 >> 3) & 2;
      vif_info_tab[uVar22].bss_info.edca_param.acm = bVar12;
      vif_info_tab[uVar22].bss_info.edca_param.ac_param[1] = uVar18 & 0xf | (uVar18 >> 8) << 4;
      uVar18 = *(uint *)(iVar9 + 0xe);
      bVar12 = (byte)(uVar18 >> 4) & 1 | bVar12;
      vif_info_tab[uVar22].bss_info.edca_param.acm = bVar12;
      vif_info_tab[uVar22].bss_info.edca_param.ac_param[0] = uVar18 & 0xf | (uVar18 >> 8) << 4;
      uVar18 = *(uint *)(iVar9 + 0x12);
      bVar12 = bVar12 | (byte)(uVar18 >> 2) & 4;
      vif_info_tab[uVar22].bss_info.edca_param.acm = bVar12;
      vif_info_tab[uVar22].bss_info.edca_param.ac_param[2] = uVar18 & 0xf | (uVar18 >> 8) << 4;
      uVar18 = *(uint *)(iVar9 + 0x16);
      vif_info_tab[uVar22].bss_info.edca_param.acm = bVar12 | (byte)(uVar18 >> 1) & 8;
      __n = vif_info_tab[uVar22].bss_info.valid_flags;
      vif_info_tab[uVar22].bss_info.edca_param.ac_param[3] = uVar18 & 0xf | (uVar18 >> 8) << 4;
      vif_info_tab[uVar22].bss_info.valid_flags = __n | 1;
    }
    uVar18 = 0;
    if (me_env.ht_supported != false) {
      uVar18 = vif_info_tab[uVar22].bss_info.valid_flags & 1;
      if (uVar18 != 0) {
        iVar9 = mac_ie_find(buffer,uVar17,0x2d);
        if (iVar9 != 0) {
          vif_info_tab[uVar22].bss_info.ht_cap.ht_capa_info = *(uint16_t *)(iVar9 + 2);
          vif_info_tab[uVar22].bss_info.ht_cap.a_mpdu_param = *(uint8_t *)(iVar9 + 4);
          iVar19 = 0;
          do {
            vif_info_tab[uVar22].bss_info.ht_cap.mcs_rate[iVar19] = *(uint8_t *)(iVar9 + 5 + iVar19)
            ;
            iVar19 = iVar19 + 1;
          } while (iVar19 != 0x10);
          vif_info_tab[uVar22].bss_info.ht_cap.ht_extended_capa = *(uint16_t *)(iVar9 + 0x15);
          vif_info_tab[uVar22].bss_info.ht_cap.tx_beamforming_capa = (uint)*(ushort *)(iVar9 + 0x17)
          ;
          vif_info_tab[uVar22].bss_info.ht_cap.asel_capa = *(uint8_t *)(iVar9 + 0x1b);
          vif_info_tab[uVar22].bss_info.valid_flags = vif_info_tab[uVar22].bss_info.valid_flags | 2;
        }
        uVar18 = mac_ie_find(buffer,uVar17,0x3d);
      }
    }
    _Var2 = (sm_env.connect_param)->is_supplicant_enabled;
    vif_info_tab[uVar22].bss_info.is_supplicant_enabled = _Var2;
    if ((_Var2 != false) && (-1 < (int)vif_info_tab[uVar22].bss_info.valid_flags)) {
      security_mode = &vif_info_tab[uVar22].bss_info.wpa_wpa2_wep;
      memset(security_mode,0,2);
      mcstCipher = &vif_info_tab[uVar22].bss_info.rsn_mcstCipher;
      ucstCipher_00 = &vif_info_tab[uVar22].bss_info.rsn_ucstCipher;
      memset(mcstCipher,0,1);
      memset(ucstCipher_00,0,1);
      mcstCipher_00 = &vif_info_tab[uVar22].bss_info.wpa_mcstCipher;
      memset(mcstCipher_00,0,1);
      ucstCipher = &vif_info_tab[uVar22].bss_info.wpa_ucstCipher;
      memset(ucstCipher,0,1);
      vif_info_tab[uVar22].bss_info.rsn_wpa_ie_len = '\0';
      vif_info_tab[uVar22].bss_info.is_pmf_required = false;
      vif_info_tab[uVar22].bss_info.is_wpa2_prefered = false;
      __src = (void *)mac_ie_find(buffer,uVar17,0x30);
      rsn_ie = vif_info_tab[uVar22].bss_info.rsn_wpa_ie;
      if (__src != (void *)0x0) {
        __n = (uint)*(byte *)((int)__src + 1) + 2 & 0xff;
        vif_info_tab[uVar22].bss_info.rsn_wpa_ie_len = (uint8_t)__n;
        memcpy(rsn_ie,__src,__n);
        uVar6 = process_rsn_ie(rsn_ie,mcstCipher,ucstCipher_00,
                               &vif_info_tab[uVar22].bss_info.is_pmf_required,security_mode,
                               *(_Bool *)(uVar22 * 0x5d8 + 0x4201a800));
        __n = *(uint *)&vif_info_tab[uVar22].bss_info.wpa_ucstCipher;
        vif_info_tab[uVar22].bss_info.rsn_wpa_ie_len = uVar6;
        printf("wpa2/wpa3 pairwise ccmp:%d,tkip:%d,wep104:%d,wep:40:%d\r\n",__n >> 0x13 & 1,
               __n >> 0x12 & 1,__n >> 0x11 & 1,__n >> 0x10 & 1);
        __n = *(uint *)&vif_info_tab[uVar22].bss_info.wpa_ucstCipher;
        printf("wpa2/wpa3 group ccmp:%d,tkip:%d,wep104:%d,wep:40:%d\r\n",__n >> 0xb & 1,
               __n >> 10 & 1,__n >> 9 & 1,__n >> 8 & 1);
        printf("wpa2/wpa3 is_pmf_required:%d\r\n",
               (uint)vif_info_tab[uVar22].bss_info.is_pmf_required);
      }
      __src = (void *)mac_vsie_find(buffer,uVar17,&DAT_230750d8,4);
      if (__src != (void *)0x0) {
        *(byte *)&vif_info_tab[uVar22].bss_info.wpa_wpa2_wep =
             *(byte *)&vif_info_tab[uVar22].bss_info.wpa_wpa2_wep | 8;
        if (vif_info_tab[uVar22].bss_info.rsn_wpa_ie_len == '\0') {
          __n = (uint)*(byte *)((int)__src + 1) + 2 & 0xff;
          vif_info_tab[uVar22].bss_info.rsn_wpa_ie_len = (uint8_t)__n;
          memcpy(rsn_ie,__src,__n);
          uVar6 = process_wpa_ie(rsn_ie,mcstCipher_00,ucstCipher);
          vif_info_tab[uVar22].bss_info.rsn_wpa_ie_len = uVar6;
        }
      }
      psVar5 = sm_env.connect_param;
      (sm_env.connect_param)->flags = 0;
      if ((*(uint *)&vif_info_tab[uVar22].bss_info.is_supplicant_enabled & 0x12800) == 0) {
        if ((vif_info_tab[uVar22].bss_info.cap_info & 0x10) == 0) {
          uVar20 = 2;
          goto LAB_2300afbc;
        }
        *(byte *)&vif_info_tab[uVar22].bss_info.wpa_wpa2_wep =
             *(byte *)&vif_info_tab[uVar22].bss_info.wpa_wpa2_wep | 2;
        psVar5->auth_type = '\x01';
      }
      else {
        uVar20 = 9;
LAB_2300afbc:
        psVar5->flags = uVar20;
      }
      memcpy(psVar5->ie_buf,rsn_ie,(uint)vif_info_tab[uVar22].bss_info.rsn_wpa_ie_len);
      (sm_env.connect_param)->ie_len = (ushort)vif_info_tab[uVar22].bss_info.rsn_wpa_ie_len;
      __n = *(uint *)&vif_info_tab[uVar22].bss_info.is_supplicant_enabled;
      printf("AP Security mode: wep:%d,wpa:%d,wpa2:%d,wpa3:%d\r\n",__n >> 9 & 1,__n >> 0xb & 1,
             __n >> 0xd & 1,__n >> 0x10 & 1);
    }
    me_bw_check(uVar18,0,bss);
    me_extract_power_constraint((uint32_t)buffer,freq,bss);
    me_extract_country_reg(buffer,uVar17,bss);
    me_extract_mobility_domain((uint32_t)buffer,freq,bss);
    vif_info_tab[uVar22].bss_info.valid_flags =
         vif_info_tab[uVar22].bss_info.valid_flags | 0x80000000;
  }
  if (pmVar10->valid_flag == false) {
    scanu_env.result_cnt = scanu_env.result_cnt + 1;
  }
  if (psVar4->ssid_cnt != '\0') {
    pmVar10->valid_flag = true;
  }
LAB_2300b100:
  ke_msg_forward_and_change_id(param_1,0x1004,0xd,4);
  return 1;
}



mac_scan_result * scanu_search_by_bssid(mac_addr *bssid)

{
  mac_scan_result *pmVar1;
  
  pmVar1 = scanu_find_result(bssid,false);
  return pmVar1;
}



mac_scan_result * scanu_search_by_ssid(mac_ssid *ssid,int *idx)

{
  scanu_env_tag *psVar1;
  int iVar2;
  int iVar3;
  mac_scan_result *pmVar4;
  int8_t iVar5;
  
  pmVar4 = (mac_scan_result *)0x0;
  if (ssid->length != '\0') {
    psVar1 = &scanu_env;
    iVar3 = 0;
    pmVar4 = (mac_scan_result *)0x0;
    iVar5 = -0x80;
    do {
      if (psVar1->scan_result[0].valid_flag == false) {
        return pmVar4;
      }
      if (((iVar5 < psVar1->scan_result[0].rssi) &&
          ((uint)ssid->length == (uint)psVar1->scan_result[0].ssid.length)) &&
         (iVar2 = memcmp(psVar1->scan_result[0].ssid.array,ssid->array,(uint)ssid->length),
         iVar2 == 0)) {
        iVar5 = psVar1->scan_result[0].rssi;
        pmVar4 = psVar1->scan_result;
        *idx = iVar3;
      }
      iVar3 = iVar3 + 1;
      psVar1 = (scanu_env_tag *)(psVar1->scan_result[0].ssid.array + 0x19);
    } while (iVar3 != 6);
  }
  return pmVar4;
}



void scanu_rm_exist_ssid(mac_ssid *ssid,int index)

{
  int iVar1;
  
  if ((index < 0) || (ssid == (mac_ssid *)0x0)) {
    return;
  }
  if (((scanu_env.scan_result[index].valid_flag != false) &&
      ((uint)ssid->length == (uint)scanu_env.scan_result[index].ssid.length)) &&
     (iVar1 = memcmp(scanu_env.scan_result[index].ssid.array,ssid->array,(uint)ssid->length),
     iVar1 == 0)) {
    memset(scanu_env.scan_result + index,0,0x38);
    return;
  }
  return;
}



void scanu_scan_next(void)

{
  byte bVar1;
  int iVar2;
  scanu_start_req *psVar3;
  uint uVar4;
  void *pvVar5;
  uint uVar6;
  uint8_t *puVar7;
  undefined *puVar8;
  undefined *puVar9;
  uint32_t *puVar10;
  me_env_tag *pmVar11;
  short sVar12;
  int iVar13;
  undefined *puVar14;
  int iVar15;
  scanu_add_ie_tag *psVar16;
  uint8_t *puVar17;
  uint uVar18;
  int iVar19;
  int iVar20;
  
  psVar3 = scanu_env.param;
  while( true ) {
    if (1 < scanu_env.band) {
      scanu_confirm('\0');
      return;
    }
    uVar18 = 0;
    puVar7 = &(scanu_env.param)->chan[0].band;
    while ((int)uVar18 < (int)(uint)(scanu_env.param)->chan_cnt) {
      if (*puVar7 == scanu_env.band) goto LAB_2300b27a;
      uVar18 = uVar18 + 1;
      puVar7 = puVar7 + 6;
    }
    if ((uint)(scanu_env.param)->chan_cnt != uVar18) break;
    scanu_env.band = scanu_env.band + '\x01';
  }
LAB_2300b27a:
  pvVar5 = ke_msg_alloc(0x800,2,4,0x154);
  *(uint8_t *)((int)pvVar5 + 0x14e) = psVar3->vif_idx;
  *(undefined4 *)((int)pvVar5 + 0x140) = *(undefined4 *)(psVar3->bssid).array;
  *(uint16_t *)((int)pvVar5 + 0x144) = (psVar3->bssid).array[2];
  *(uint8_t *)((int)pvVar5 + 0x150) = psVar3->ssid_cnt;
  *(_Bool *)((int)pvVar5 + 0x151) = psVar3->no_cck;
  while ((int)uVar18 < (int)(uint)psVar3->chan_cnt) {
    if (*(uint8_t *)(&psVar3->chan[uVar18].freq + 1) == scanu_env.band) {
      bVar1 = *(byte *)((int)pvVar5 + 0x14f);
      memcpy((void *)((uint)bVar1 * 6 + (int)pvVar5),psVar3->chan + uVar18,6);
      *(char *)((int)pvVar5 + 0x14f) = bVar1 + 1;
    }
    uVar18 = uVar18 + 1;
  }
  iVar19 = 0xfc;
  iVar20 = 0;
  while (iVar20 < (int)(uint)psVar3->ssid_cnt) {
    memcpy((void *)((int)pvVar5 + iVar19),(void *)((int)&psVar3->chan[0].freq + iVar19),0x22);
    iVar20 = iVar20 + 1;
    iVar19 = iVar19 + 0x22;
  }
  uVar18 = (uint)(scanu_env.param)->add_ie_len;
  puVar10 = scanu_add_ie.buf;
  if (200 < (scanu_env.param)->add_ie_len) {
    uVar18 = 0;
  }
  if ((scanu_env.band == '\x01') || ((scanu_env.param)->no_cck != false)) {
    iVar19 = 4;
    iVar20 = 8;
  }
  else {
    iVar19 = 0;
    iVar20 = 0xc;
  }
  scan_probe_req_ie.buf[0]._0_1_ = 1;
  scan_probe_req_ie.buf[0]._1_1_ = 8;
  iVar13 = 0;
  do {
    iVar15 = iVar19 + iVar13;
    iVar2 = iVar13 + 2;
    iVar13 = iVar13 + 1;
    *(uint8_t *)((int)scan_probe_req_ie.buf + iVar2) = mac_id2rate[iVar15];
  } while (iVar13 != 8);
  puVar14 = (undefined *)((int)scan_probe_req_ie.buf + 10);
  if ((uVar18 != 0) && ((char)scanu_add_ie.buf[0] == '\n')) {
    uVar6 = (uint)scanu_add_ie.buf[0]._1_1_ + 2 & 0xff;
    uVar4 = uVar6;
    psVar16 = &scanu_add_ie;
    while( true ) {
      uVar4 = uVar4 - 1;
      if (uVar4 == 0xffffffff) break;
      *puVar14 = *(undefined *)psVar16->buf;
      psVar16 = (scanu_add_ie_tag *)((int)&(psVar16->dma_desc).src + 1);
      puVar14 = puVar14 + 1;
    }
    puVar14 = (undefined *)((int)scan_probe_req_ie.buf + uVar6 + 10);
    puVar10 = (uint32_t *)((int)scanu_add_ie.buf + uVar6);
    uVar18 = uVar18 - uVar6 & 0xffff;
  }
  if (iVar20 != 8) {
    uVar4 = iVar20 - 8U & 0xff;
    *puVar14 = 0x32;
    puVar14[1] = (char)uVar4;
    iVar19 = uVar4 + 2;
    puVar7 = mac_id2rate;
    puVar17 = puVar14 + 2;
    while( true ) {
      uVar4 = uVar4 - 1;
      if (uVar4 == 0xffffffff) break;
      *puVar17 = puVar7[8];
      puVar7 = puVar7 + 1;
      puVar17 = puVar17 + 1;
    }
    puVar14 = puVar14 + iVar19;
  }
  if (scanu_env.band == '\0') {
    *puVar14 = 3;
    puVar14[1] = 1;
    puVar14 = puVar14 + 3;
  }
  if ((uVar18 != 0) && (*(char *)puVar10 == ';')) {
    uVar4 = 0;
    uVar6 = (uint)*(byte *)((int)puVar10 + 1) + 2 & 0xff;
    while (uVar6 != uVar4) {
      puVar8 = (undefined *)((int)puVar10 + uVar4);
      puVar9 = puVar14 + uVar4;
      uVar4 = uVar4 + 1;
      *puVar9 = *puVar8;
    }
    puVar14 = puVar14 + uVar6;
    puVar10 = (uint32_t *)((int)puVar10 + uVar6);
    uVar18 = uVar18 - uVar6 & 0xffff;
  }
  if (me_env.ht_supported != false) {
    *puVar14 = 0x2d;
    puVar14[1] = 0x1a;
    puVar8 = puVar14 + 0x1c;
    pmVar11 = &me_env;
    puVar14 = puVar14 + 2;
    while (puVar8 != puVar14) {
      *puVar14 = *(undefined *)&(pmVar11->ht_cap).ht_capa_info;
      pmVar11 = (me_env_tag *)((int)&pmVar11->active_vifs + 1);
      puVar14 = puVar14 + 1;
    }
  }
  sVar12 = (short)puVar14;
  if (uVar18 != 0) {
    uVar4 = 0;
    do {
      puVar8 = (undefined *)((int)puVar10 + uVar4);
      puVar9 = puVar14 + uVar4;
      uVar4 = uVar4 + 1;
      *puVar9 = *puVar8;
    } while (uVar18 != uVar4);
    sVar12 = sVar12 + (short)uVar18;
  }
  *(short *)((int)pvVar5 + 0x14c) = sVar12 + -0x7d04;
  *(undefined4 *)((int)pvVar5 + 0x148) = 0;
  ke_msg_send(pvVar5);
  return;
}



void scanu_dma_cb(void)

{
  byte bVar1;
  int iVar2;
  scanu_start_req *psVar3;
  uint uVar4;
  void *pvVar5;
  uint uVar6;
  uint8_t *puVar7;
  undefined *puVar8;
  undefined *puVar9;
  uint32_t *puVar10;
  me_env_tag *pmVar11;
  short sVar12;
  int iVar13;
  undefined *puVar14;
  int iVar15;
  scanu_add_ie_tag *psVar16;
  uint8_t *puVar17;
  uint uVar18;
  int iVar19;
  int iVar20;
  
  psVar3 = scanu_env.param;
  while( true ) {
    if (1 < scanu_env.band) {
      scanu_confirm('\0');
      return;
    }
    uVar18 = 0;
    puVar7 = &(scanu_env.param)->chan[0].band;
    while ((int)uVar18 < (int)(uint)(scanu_env.param)->chan_cnt) {
      if (*puVar7 == scanu_env.band) goto LAB_2300b27a;
      uVar18 = uVar18 + 1;
      puVar7 = puVar7 + 6;
    }
    if ((uint)(scanu_env.param)->chan_cnt != uVar18) break;
    scanu_env.band = scanu_env.band + '\x01';
  }
LAB_2300b27a:
  pvVar5 = ke_msg_alloc(0x800,2,4,0x154);
  *(uint8_t *)((int)pvVar5 + 0x14e) = psVar3->vif_idx;
  *(undefined4 *)((int)pvVar5 + 0x140) = *(undefined4 *)(psVar3->bssid).array;
  *(uint16_t *)((int)pvVar5 + 0x144) = (psVar3->bssid).array[2];
  *(uint8_t *)((int)pvVar5 + 0x150) = psVar3->ssid_cnt;
  *(_Bool *)((int)pvVar5 + 0x151) = psVar3->no_cck;
  while ((int)uVar18 < (int)(uint)psVar3->chan_cnt) {
    if (*(uint8_t *)(&psVar3->chan[uVar18].freq + 1) == scanu_env.band) {
      bVar1 = *(byte *)((int)pvVar5 + 0x14f);
      memcpy((void *)((uint)bVar1 * 6 + (int)pvVar5),psVar3->chan + uVar18,6);
      *(char *)((int)pvVar5 + 0x14f) = bVar1 + 1;
    }
    uVar18 = uVar18 + 1;
  }
  iVar19 = 0xfc;
  iVar20 = 0;
  while (iVar20 < (int)(uint)psVar3->ssid_cnt) {
    memcpy((void *)((int)pvVar5 + iVar19),(void *)((int)&psVar3->chan[0].freq + iVar19),0x22);
    iVar20 = iVar20 + 1;
    iVar19 = iVar19 + 0x22;
  }
  uVar18 = (uint)(scanu_env.param)->add_ie_len;
  puVar10 = scanu_add_ie.buf;
  if (200 < (scanu_env.param)->add_ie_len) {
    uVar18 = 0;
  }
  if ((scanu_env.band == '\x01') || ((scanu_env.param)->no_cck != false)) {
    iVar19 = 4;
    iVar20 = 8;
  }
  else {
    iVar19 = 0;
    iVar20 = 0xc;
  }
  scan_probe_req_ie.buf[0]._0_1_ = 1;
  scan_probe_req_ie.buf[0]._1_1_ = 8;
  iVar13 = 0;
  do {
    iVar15 = iVar19 + iVar13;
    iVar2 = iVar13 + 2;
    iVar13 = iVar13 + 1;
    *(uint8_t *)((int)scan_probe_req_ie.buf + iVar2) = mac_id2rate[iVar15];
  } while (iVar13 != 8);
  puVar14 = (undefined *)((int)scan_probe_req_ie.buf + 10);
  if ((uVar18 != 0) && ((char)scanu_add_ie.buf[0] == '\n')) {
    uVar6 = (uint)scanu_add_ie.buf[0]._1_1_ + 2 & 0xff;
    uVar4 = uVar6;
    psVar16 = &scanu_add_ie;
    while( true ) {
      uVar4 = uVar4 - 1;
      if (uVar4 == 0xffffffff) break;
      *puVar14 = *(undefined *)psVar16->buf;
      psVar16 = (scanu_add_ie_tag *)((int)&(psVar16->dma_desc).src + 1);
      puVar14 = puVar14 + 1;
    }
    puVar14 = (undefined *)((int)scan_probe_req_ie.buf + uVar6 + 10);
    puVar10 = (uint32_t *)((int)scanu_add_ie.buf + uVar6);
    uVar18 = uVar18 - uVar6 & 0xffff;
  }
  if (iVar20 != 8) {
    uVar4 = iVar20 - 8U & 0xff;
    *puVar14 = 0x32;
    puVar14[1] = (char)uVar4;
    iVar19 = uVar4 + 2;
    puVar7 = mac_id2rate;
    puVar17 = puVar14 + 2;
    while( true ) {
      uVar4 = uVar4 - 1;
      if (uVar4 == 0xffffffff) break;
      *puVar17 = puVar7[8];
      puVar7 = puVar7 + 1;
      puVar17 = puVar17 + 1;
    }
    puVar14 = puVar14 + iVar19;
  }
  if (scanu_env.band == '\0') {
    *puVar14 = 3;
    puVar14[1] = 1;
    puVar14 = puVar14 + 3;
  }
  if ((uVar18 != 0) && (*(char *)puVar10 == ';')) {
    uVar4 = 0;
    uVar6 = (uint)*(byte *)((int)puVar10 + 1) + 2 & 0xff;
    while (uVar6 != uVar4) {
      puVar8 = (undefined *)((int)puVar10 + uVar4);
      puVar9 = puVar14 + uVar4;
      uVar4 = uVar4 + 1;
      *puVar9 = *puVar8;
    }
    puVar14 = puVar14 + uVar6;
    puVar10 = (uint32_t *)((int)puVar10 + uVar6);
    uVar18 = uVar18 - uVar6 & 0xffff;
  }
  if (me_env.ht_supported != false) {
    *puVar14 = 0x2d;
    puVar14[1] = 0x1a;
    puVar8 = puVar14 + 0x1c;
    pmVar11 = &me_env;
    puVar14 = puVar14 + 2;
    while (puVar8 != puVar14) {
      *puVar14 = *(undefined *)&(pmVar11->ht_cap).ht_capa_info;
      pmVar11 = (me_env_tag *)((int)&pmVar11->active_vifs + 1);
      puVar14 = puVar14 + 1;
    }
  }
  sVar12 = (short)puVar14;
  if (uVar18 != 0) {
    uVar4 = 0;
    do {
      puVar8 = (undefined *)((int)puVar10 + uVar4);
      puVar9 = puVar14 + uVar4;
      uVar4 = uVar4 + 1;
      *puVar9 = *puVar8;
    } while (uVar18 != uVar4);
    sVar12 = sVar12 + (short)uVar18;
  }
  *(short *)((int)pvVar5 + 0x14c) = sVar12 + -0x7d04;
  *(undefined4 *)((int)pvVar5 + 0x148) = 0;
  ke_msg_send(pvVar5);
  return;
}



void scanu_start(void)

{
  scanu_env_tag *psVar1;
  
  if (scanu_env.joining == false) {
    psVar1 = &scanu_env;
    do {
      psVar1->scan_result[0].valid_flag = false;
      psVar1->scan_result[0].rssi = -0x80;
      psVar1 = (scanu_env_tag *)(psVar1->scan_result[0].ssid.array + 0x19);
    } while (psVar1 != (scanu_env_tag *)0x4201bb94);
    scanu_env.result_cnt = 0;
  }
  ke_state_set(4,1);
  if ((scanu_env.param)->add_ies != 0) {
    if ((scanu_env.param)->add_ie_len < 0xc9) {
      scanu_add_ie.dma_desc.src = (scanu_env.param)->add_ies;
      scanu_add_ie.dma_desc.length = (scanu_env.param)->add_ie_len;
      hal_dma_push(&scanu_env.dma_desc,0);
      return;
    }
  }
  scanu_scan_next();
  return;
}



uint16_t txl_get_seq_ctrl(void)

{
  uint uVar1;
  
  uVar1 = (uint)txl_cntrl_env.seqnbr;
  txl_cntrl_env.seqnbr = (uint16_t)((uVar1 + 1) * 0x10000 >> 0x10);
  return (uint16_t)((uVar1 + 1) * 0x100000 >> 0x10);
}



void sm_delete_resources(vif_info_tag *vif)

{
  undefined *puVar1;
  undefined *puVar2;
  void *pvVar3;
  byte *pbVar4;
  
  puVar1 = (undefined *)ke_msg_alloc(0x1413,5,6,2);
  puVar2 = (undefined *)ke_msg_alloc(0x1411,5,6,2);
  *puVar1 = 0;
  puVar1[1] = vif->index;
  ke_msg_send(puVar1);
  if (vif->active != false) {
    pvVar3 = ke_msg_alloc(0x1e,0,6,4);
    *(undefined *)((int)pvVar3 + 2) = 0;
    *(uint8_t *)((int)pvVar3 + 3) = vif->index;
    ke_msg_send();
  }
  if (vif->u[4] != 0xff) {
    pbVar4 = (byte *)ke_msg_alloc(0xc,0,6,1);
    *pbVar4 = vif->u[4];
    ke_msg_send();
  }
  if (vif->chan_ctxt != (chan_ctxt_tag *)0x0) {
    chan_ctxt_unlink(vif->index);
  }
  *puVar2 = 0;
  puVar2[1] = vif->index;
  ke_msg_send(puVar2);
  (vif->bss_info).valid_flags = 0;
  return;
}



void sm_frame_tx_cfm_handler(void *env,uint32_t status)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  
  kVar1 = ke_state_get(6);
  if (((status & 0x40030000) != 0) && (CONCAT22(extraout_var,kVar1) - 5U < 2)) {
    txl_frame_push((txl_frame_desc_tag *)env,'\x03');
    *(undefined *)((int)env + 0x2d6) = 1;
  }
  return;
}



void sm_init(void)

{
  sm_env.connect_param = (sm_connect_req *)0x0;
  ke_state_set(6,0);
  return;
}



void sm_get_bss_params(mac_addr **bssid,scan_chan_tag **chan)

{
  byte bVar1;
  sm_connect_req *ssid;
  int iVar2;
  int iVar3;
  mac_scan_result *pmVar4;
  mac_addr *bssid_00;
  mac_addr *pmVar5;
  int local_34;
  int index;
  
  ssid = sm_env.connect_param;
  *bssid = (mac_addr *)0x0;
  *chan = (scan_chan_tag *)0x0;
  bssid_00 = &ssid->bssid;
  local_34 = -1;
  printf("===start sm_get_bss_params===\r\n");
  iVar2 = 0;
  pmVar5 = bssid_00;
  do {
    iVar3 = iVar2 + 1;
    printf("bssid[%d] = 0x%x\r\n",iVar2,(uint)pmVar5->array[0]);
    pmVar5 = (mac_addr *)(pmVar5->array + 1);
    iVar2 = iVar3;
  } while (iVar3 != 3);
  bVar1 = *(byte *)(ssid->bssid).array;
  if (((bVar1 & 1) == 0) &&
     ((((bVar1 != 0 || (*(char *)((int)(ssid->bssid).array + 1) != '\0')) ||
       (*(char *)((ssid->bssid).array + 1) != '\0')) ||
      (((*(char *)((int)(ssid->bssid).array + 3) != '\0' ||
        (*(char *)((ssid->bssid).array + 2) != '\0')) ||
       (*(char *)((int)(ssid->bssid).array + 5) != '\0')))))) {
    printf("search bssid \r\n ");
    *bssid = bssid_00;
    pmVar4 = scanu_search_by_bssid(bssid_00);
    if (pmVar4 == (mac_scan_result *)0x0) goto LAB_2300b794;
  }
  else {
    printf("search ssid = %s\r\n",(ssid->ssid).array);
    pmVar4 = scanu_search_by_ssid((mac_ssid *)ssid,&local_34);
    printf("result ssid index = %d\r\n",local_34);
    if (pmVar4 == (mac_scan_result *)0x0) {
LAB_2300b794:
      if ((ssid->chan).freq != 0xffff) {
        *chan = &ssid->chan;
      }
      goto LAB_2300b756;
    }
    if (-1 < local_34) {
      *(mac_scan_result **)bssid = pmVar4;
      sm_env.exist_ssid_idx = local_34;
    }
  }
  *chan = pmVar4->chan;
LAB_2300b756:
  printf("===end sm_get_bss_params===\r\n");
  return;
}



// WARNING: Could not reconcile some variable overlaps

void sm_scan_bss(mac_addr *bssid,scan_chan_tag *chan_1)

{
  uint8_t uVar1;
  byte bVar2;
  undefined2 uVar3;
  sm_connect_req *__src;
  int iVar4;
  void *__dest;
  void *__src_00;
  undefined2 *puVar5;
  int *piVar6;
  undefined2 local_2c;
  undefined2 uStack42;
  uint8_t chan_cnt [2];
  scan_chan_tag *chan [2];
  
  __src = sm_env.connect_param;
  __dest = ke_msg_alloc(0x1000,4,6,0x154);
  uVar1 = __src->vif_idx;
  *(undefined4 *)((int)__dest + 0x148) = 0;
  *(uint8_t *)((int)__dest + 0x14e) = uVar1;
  *(undefined2 *)((int)__dest + 0x14c) = 0;
  memcpy((void *)((int)__dest + 0xfc),__src,0x22);
  *(undefined *)((int)__dest + 0x150) = 1;
  if (bssid == (mac_addr *)0x0) {
    bssid = &mac_addr_bcst;
  }
  memcpy((void *)((int)__dest + 0x140),bssid,6);
  uVar3 = me_env.chan._252_2_;
  if (chan_1 == (scan_chan_tag *)0x0) {
    _chan_cnt = 0x4201b004;
    *(undefined *)((int)__dest + 0x14f) = 0;
    puVar5 = &local_2c;
    local_2c = uVar3;
    piVar6 = (int *)chan_cnt;
    do {
      iVar4 = 0;
      while (iVar4 < (int)(uint)*(byte *)puVar5) {
        __src_00 = (void *)(iVar4 * 6 + *piVar6);
        if ((*(byte *)((int)__src_00 + 3) & 2) == 0) {
          bVar2 = *(byte *)((int)__dest + 0x14f);
          *(char *)((int)__dest + 0x14f) = bVar2 + 1;
          memcpy((void *)((uint)bVar2 * 6 + (int)__dest),__src_00,6);
        }
        iVar4 = iVar4 + 1;
      }
      puVar5 = (undefined2 *)((int)puVar5 + 1);
      piVar6 = piVar6 + 1;
    } while (puVar5 != &uStack42);
  }
  else {
    memcpy(__dest,chan_1,6);
    *(undefined *)((int)__dest + 0x14f) = 1;
  }
  ke_msg_send(__dest);
  ke_state_set(6,1);
  return;
}



void sm_join_bss(mac_addr *bssid,scan_chan_tag *chan,_Bool passive)

{
  sm_connect_req *__src;
  void *__dest;
  undefined3 in_register_00002031;
  
  __src = sm_env.connect_param;
  __dest = ke_msg_alloc(0x1002,4,6,0x154);
  memcpy(__dest,chan,6);
  *(undefined *)((int)__dest + 0x14f) = 1;
  memcpy((void *)((int)__dest + 0xfc),__src,0x22);
  *(undefined *)((int)__dest + 0x150) = 1;
  *(undefined2 *)((int)__dest + 0x14c) = 0;
  *(undefined4 *)((int)__dest + 0x148) = 0;
  *(uint8_t *)((int)__dest + 0x14e) = __src->vif_idx;
  memcpy((void *)((int)__dest + 0x140),bssid,6);
  if (CONCAT31(in_register_00002031,passive) != 0) {
    *(byte *)((int)__dest + 3) = *(byte *)((int)__dest + 3) | 1;
  }
  sm_env.join_passive = passive;
  ke_msg_send(__dest);
  ke_state_set(6,2);
  return;
}



// WARNING: Could not reconcile some variable overlaps

uint8_t sm_add_chan_ctx(uint8_t *p_chan_idx)

{
  uint8_t uVar1;
  scan_chan_tag *psVar2;
  uint uVar3;
  uint8_t uStack28;
  uint8_t uStack27;
  uint16_t uStack26;
  mm_chan_ctxt_add_req req;
  
  uVar3 = (uint)(sm_env.connect_param)->vif_idx;
  psVar2 = vif_info_tab[uVar3].bss_info.chan;
  uStack27 = vif_info_tab[uVar3].bss_info.phy_bw;
  uStack28 = psVar2->band;
  uStack26 = psVar2->freq;
  req._0_4_ = *(undefined4 *)&vif_info_tab[uVar3].bss_info.center_freq1;
  req.center1_freq._0_1_ = psVar2->tx_power;
  uVar1 = chan_ctxt_add((mm_chan_ctxt_add_req *)&uStack28,p_chan_idx);
  return uVar1;
}



void sm_send_next_bss_param(void)

{
  co_list_hdr *pcVar1;
  
  pcVar1 = co_list_pop_front(&sm_env.bss_config);
  if (pcVar1 == (co_list_hdr *)0x0) {
    assert_err("msg != NULL","module",0x1a0);
  }
  ke_msg_send(pcVar1 + 3);
  return;
}



void sm_set_bss_param(void)

{
  sm_connect_req *psVar1;
  vif_info_tag *pvVar2;
  uint16_t uVar3;
  undefined *puVar4;
  void *__dest;
  undefined4 *puVar5;
  uint16_t *puVar6;
  undefined *puVar7;
  undefined2 extraout_var;
  uint32_t *puVar8;
  bool bVar9;
  uint32_t uVar10;
  uint uVar11;
  int iVar12;
  
  psVar1 = sm_env.connect_param;
  uVar11 = (uint)(sm_env.connect_param)->vif_idx;
  puVar4 = (undefined *)ke_msg_alloc(0x1413,5,6,2);
  __dest = ke_msg_alloc(0x18,0,6,7);
  puVar5 = (undefined4 *)ke_msg_alloc(0x16,0,6,8);
  puVar6 = (uint16_t *)ke_msg_alloc(0x14,0,6,4);
  puVar7 = (undefined *)ke_msg_alloc(0x1411,5,6,2);
  co_list_init(&sm_env.bss_config);
  *puVar4 = 1;
  puVar4[1] = psVar1->vif_idx;
  co_list_push_back(&sm_env.bss_config,(co_list_hdr *)(puVar4 + -0xc));
  pvVar2 = vif_info_tab + uVar11;
  memcpy(__dest,&vif_info_tab[uVar11].bss_info.bssid,6);
  *(uint8_t *)((int)__dest + 6) = psVar1->vif_idx;
  co_list_push_back(&sm_env.bss_config,(co_list_hdr *)((int)__dest + -0xc));
  *(uint8_t *)((int)puVar5 + 5) = (vif_info_tab[uVar11].bss_info.chan)->band;
  uVar3 = me_legacy_rate_bitfield_build(&vif_info_tab[uVar11].bss_info.rate_set,true);
  *puVar5 = CONCAT22(extraout_var,uVar3);
  *(uint8_t *)(puVar5 + 1) = psVar1->vif_idx;
  co_list_push_back(&sm_env.bss_config,(co_list_hdr *)(puVar5 + -3));
  *puVar6 = vif_info_tab[uVar11].bss_info.beacon_period;
  iVar12 = 0;
  *(uint8_t *)(puVar6 + 1) = psVar1->vif_idx;
  co_list_push_back(&sm_env.bss_config,(co_list_hdr *)(puVar6 + -6));
  do {
    puVar8 = (uint32_t *)ke_msg_alloc(0x1a,0,6,8);
    uVar10 = (pvVar2->bss_info).edca_param.ac_param[0];
    *(undefined *)((int)puVar8 + 5) = (char)iVar12;
    *puVar8 = uVar10;
    *(uint8_t *)((int)puVar8 + 6) = psVar1->vif_idx;
    bVar9 = false;
    if ((ps_env.uapsd_timeout != 0) &&
       ((char)vif_info_tab[uVar11].bss_info.edca_param.qos_info < '\0')) {
      bVar9 = (mac_ac2uapsd[iVar12] & psVar1->uapsd_queues) != 0;
    }
    *(bool *)(puVar8 + 1) = bVar9;
    iVar12 = iVar12 + 1;
    co_list_push_back(&sm_env.bss_config,(co_list_hdr *)(puVar8 + -3));
    pvVar2 = (vif_info_tag *)&pvVar2->prevent_sleep;
  } while (iVar12 != 4);
  *puVar7 = 1;
  puVar7[1] = psVar1->vif_idx;
  co_list_push_back(&sm_env.bss_config,(co_list_hdr *)(puVar7 + -0xc));
  sm_send_next_bss_param();
  ke_state_set(6,4);
  return;
}



void sm_disconnect_process(vif_info_tag *vif,uint16_t reason)

{
  uint16_t *puVar1;
  
  puVar1 = (uint16_t *)ke_msg_alloc(0x1805,0xd,6,4);
  sm_delete_resources(vif);
  *puVar1 = reason;
  *(uint8_t *)(puVar1 + 1) = vif->index;
  if (sm_env.ft_over_ds != false) {
    *(undefined *)((int)puVar1 + 3) = 1;
  }
  ke_msg_send(puVar1);
  return;
}



void sm_deauth_cfm(void *env,uint32_t status)

{
  sm_disconnect_process((vif_info_tag *)env,0);
  return;
}



void sm_disconnect(uint8_t vif_index,uint16_t reason_code)

{
  byte bVar1;
  _Bool _Var2;
  uint16_t uVar3;
  undefined3 in_register_00002029;
  int iVar4;
  txl_frame_desc_tag *frame;
  undefined2 extraout_var_00;
  undefined3 extraout_var;
  vif_info_tag *vif;
  tx_hw_desc *ptVar5;
  txl_buffer_tag *ptVar6;
  
  iVar4 = CONCAT31(in_register_00002029,vif_index);
  vif = vif_info_tab + iVar4;
  if ((vif_info_tab[iVar4].type == '\0') && (vif_info_tab[iVar4].active != false)) {
    bVar1 = vif_info_tab[iVar4].u[4];
    ke_state_set(6,8);
    frame = txl_frame_get((uint)((vif_info_tab[iVar4].bss_info.chan)->band != '\0'),0x100);
    if (frame != (txl_frame_desc_tag *)0x0) {
      tpc_update_frame_tx_power(vif,frame);
      ptVar6 = (frame->txdesc).lmac.buffer;
      *(undefined *)&ptVar6[1].length = 0xc0;
      *(undefined *)((int)&ptVar6[1].length + 1) = 0;
      *(undefined *)((int)&ptVar6[1].length + 2) = 0;
      *(undefined *)((int)&ptVar6[1].length + 3) = 0;
      memcpy(&ptVar6[1].lenheader,&sta_info_tab[bVar1].mac_addr,6);
      memcpy((void *)((int)&ptVar6[1].lenpad + 2),&vif_info_tab[iVar4].mac_addr,6);
      memcpy(&ptVar6[1].next,&sta_info_tab[bVar1].mac_addr,6);
      uVar3 = txl_get_seq_ctrl();
      *(undefined *)((int)&ptVar6[1].txdesc + 2) = (char)uVar3;
      *(undefined *)((int)&ptVar6[1].txdesc + 3) = (char)(uVar3 >> 8);
      (frame->cfm).cfm_func = sm_deauth_cfm;
      *(vif_info_tag **)&(frame->cfm).env = vif;
      (frame->txdesc).host.vif_idx = vif_index;
      (frame->txdesc).host.staid = vif_info_tab[iVar4].u[4];
      uVar3 = me_build_deauthenticate((uint32_t)ptVar6[1].dma_desc,reason_code);
      ptVar5 = (frame->txdesc).lmac.hw_desc;
      (ptVar5->thd).frmlen = CONCAT22(extraout_var_00,uVar3) + 0x1c;
      (ptVar5->thd).field_5 = (ptVar5->thd).field_4 + 0x17 + CONCAT22(extraout_var_00,uVar3);
      _Var2 = txl_frame_push(frame,'\x03');
      if (CONCAT31(extraout_var,_Var2) != 0) {
        return;
      }
      vif = (vif_info_tag *)(frame->cfm).env;
    }
    sm_disconnect_process(vif,0);
    return;
  }
  return;
}



void sm_connect_ind(uint16_t status)

{
  sm_connect_req *ssid;
  sm_connect_ind *psVar1;
  int index;
  undefined2 in_register_0000202a;
  uint8_t uVar2;
  uint uVar3;
  chan_ctxt_tag *pcVar4;
  uint uVar5;
  
  index = sm_env.exist_ssid_idx;
  psVar1 = sm_env.connect_ind;
  ssid = sm_env.connect_param;
  uVar5 = (uint)(sm_env.connect_param)->vif_idx;
  (sm_env.connect_ind)->vif_idx = (sm_env.connect_param)->vif_idx;
  memcpy(&psVar1->bssid,&vif_info_tab[uVar5].bss_info.bssid,6);
  psVar1->ap_idx = vif_info_tab[uVar5].u[4];
  printf("ind ix %p, chan_ctxt is %p\r\n",psVar1,vif_info_tab[uVar5].chan_ctxt);
  pcVar4 = vif_info_tab[uVar5].chan_ctxt;
  psVar1->ch_idx = '\0';
  if (pcVar4 == (chan_ctxt_tag *)0x0) {
    psVar1->band = '\0';
    psVar1->center_freq = 0;
    psVar1->center_freq1 = 0;
    psVar1->center_freq2 = 0;
    psVar1->width = '\0';
  }
  else {
    psVar1->band = ((vif_info_tab[uVar5].chan_ctxt)->channel).band;
    psVar1->center_freq = ((vif_info_tab[uVar5].chan_ctxt)->channel).prim20_freq;
    psVar1->center_freq1 = (uint)((vif_info_tab[uVar5].chan_ctxt)->channel).center1_freq;
    psVar1->center_freq2 = (uint)((vif_info_tab[uVar5].chan_ctxt)->channel).center2_freq;
    psVar1->width = ((vif_info_tab[uVar5].chan_ctxt)->channel).type;
  }
  uVar2 = '\0';
  uVar3 = vif_info_tab[uVar5].bss_info.valid_flags & 1;
  psVar1->qos = SUB41(uVar3,0);
  if (uVar3 != 0) {
    uVar2 = vif_info_tab[uVar5].bss_info.edca_param.acm;
  }
  psVar1->acm = uVar2;
  psVar1->roamed = false;
  if (CONCAT22(in_register_0000202a,status) == 0) {
    ke_state_set(6,0);
  }
  else {
    ke_state_set(6,8);
    printf("connect failure, ssid = %s, index = %d\r\n",(ssid->ssid).array,index);
    if (-1 < index) {
      printf("from sm_connect_ind to scanu_rm_exist_ssid\r\n");
      scanu_rm_exist_ssid((mac_ssid *)ssid,index);
      sm_env.exist_ssid_idx = -1;
    }
    sm_delete_resources(vif_info_tab + uVar5);
  }
  ke_msg_free(sm_env.connect_param[-1].phrase_pmk + 0x37);
  sm_env.connect_param = (sm_connect_req *)0x0;
  sm_env.ft_over_ds = false;
  psVar1->status_code = status;
  ke_msg_send(psVar1);
  sm_env.connect_ind = (sm_connect_ind *)0x0;
  return;
}



void sm_supplicant_deauth_cfm(void *env,uint32_t status)

{
  if (-1 < (int)(status << 8)) {
    printf("sm deauth frame transmit failure\r\n");
  }
  sm_connect_ind(8);
  return;
}



void sm_auth_send(uint16_t auth_seq,uint32_t *challenge)

{
  byte bVar1;
  sm_connect_req *psVar2;
  txl_buffer_tag *ptVar3;
  uint16_t uVar4;
  undefined2 in_register_0000202a;
  txl_frame_desc_tag *frame;
  undefined2 extraout_var;
  tx_hw_desc *ptVar5;
  uint uVar6;
  int iVar7;
  
  psVar2 = sm_env.connect_param;
  uVar6 = (uint)(sm_env.connect_param)->vif_idx;
  bVar1 = vif_info_tab[uVar6].u[4];
  frame = txl_frame_get((uint)((vif_info_tab[uVar6].bss_info.chan)->band != '\0'),0x100);
  if (frame != (txl_frame_desc_tag *)0x0) {
    tpc_update_frame_tx_power(vif_info_tab + uVar6,frame);
    ptVar3 = (frame->txdesc).lmac.buffer;
    *(undefined *)&ptVar3[1].length = 0xb0;
    *(undefined *)((int)&ptVar3[1].length + 1) = 0;
    *(undefined *)((int)&ptVar3[1].length + 2) = 0;
    *(undefined *)((int)&ptVar3[1].length + 3) = 0;
    memcpy(&ptVar3[1].lenheader,&sta_info_tab[bVar1].mac_addr,6);
    memcpy((void *)((int)&ptVar3[1].lenpad + 2),&vif_info_tab[uVar6].mac_addr,6);
    memcpy(&ptVar3[1].next,&sta_info_tab[bVar1].mac_addr,6);
    uVar4 = txl_get_seq_ctrl();
    *(undefined *)((int)&ptVar3[1].txdesc + 2) = (char)uVar4;
    *(undefined *)((int)&ptVar3[1].txdesc + 3) = (char)(uVar4 >> 8);
    (frame->txdesc).host.vif_idx = vif_info_tab[uVar6].index;
    bVar1 = vif_info_tab[uVar6].u[4];
    (frame->txdesc).umac.head_len = '\0';
    (frame->txdesc).umac.tail_len = '\0';
    (frame->txdesc).host.staid = bVar1;
    iVar7 = 0x18;
    if ((psVar2->auth_type == '\x01') && (CONCAT22(in_register_0000202a,auth_seq) == 3)) {
      txu_cntrl_protect_mgmt_frame((txdesc *)frame,(uint32_t)(ptVar3 + 1),0x18);
      iVar7 = (uint)(frame->txdesc).umac.head_len + 0x18;
    }
    uVar4 = me_build_authenticate
                      ((int)&ptVar3[1].length + iVar7,(ushort)psVar2->auth_type,auth_seq,0,challenge
                      );
    bVar1 = (frame->txdesc).umac.tail_len;
    ptVar5 = (frame->txdesc).lmac.hw_desc;
    *(txl_frame_desc_tag **)&(frame->cfm).env = frame;
    iVar7 = CONCAT22(extraout_var,uVar4) + (uint)bVar1 + iVar7;
    (frame->cfm).cfm_func = sm_frame_tx_cfm_handler;
    (ptVar5->thd).frmlen = iVar7 + 4;
    (ptVar5->thd).field_5 = (ptVar5->thd).field_4 + -1 + iVar7;
    txl_frame_push(frame,'\x03');
    ke_timer_set(0x1806,6,0x32000);
    ke_state_set(6,5);
    return;
  }
  sm_connect_ind(1);
  return;
}



// WARNING: Variable defined which should be unmapped: ie_addr
// WARNING: Could not reconcile some variable overlaps

void sm_assoc_req_send(void)

{
  byte bVar1;
  sm_connect_req *con_par;
  sm_connect_ind *psVar2;
  txl_buffer_tag *ptVar3;
  uint16_t uVar4;
  txl_frame_desc_tag *frame;
  undefined2 extraout_var;
  tx_hw_desc *ptVar5;
  _Bool _Var6;
  sm_connect_ind *psVar7;
  uint uVar8;
  mac_addr *old_ap_addr_ptr;
  uint16_t uStack54;
  uint16_t ie_len;
  uint32_t uStack52;
  uint32_t ie_addr;
  
  con_par = sm_env.connect_param;
  uVar8 = (uint)(sm_env.connect_param)->vif_idx;
  bVar1 = vif_info_tab[uVar8].u[4];
  frame = txl_frame_get((uint)((vif_info_tab[uVar8].bss_info.chan)->band != '\0'),0x100);
  psVar2 = sm_env.connect_ind;
  if (frame == (txl_frame_desc_tag *)0x0) {
    sm_connect_ind(4);
  }
  else {
    tpc_update_frame_tx_power(vif_info_tab + uVar8,frame);
    ptVar3 = (frame->txdesc).lmac.buffer;
    old_ap_addr_ptr = (mac_addr *)0x0;
    _Var6 = sm_env.ft_over_ds;
    if (sm_env.ft_over_ds != false) {
      _Var6 = true;
      old_ap_addr_ptr = &sm_env.ft_old_bssid;
    }
    *(_Bool *)&ptVar3[1].length = _Var6;
    *(undefined *)((int)&ptVar3[1].length + 1) = 0;
    *(undefined *)((int)&ptVar3[1].length + 2) = 0;
    *(undefined *)((int)&ptVar3[1].length + 3) = 0;
    memcpy(&ptVar3[1].lenheader,&sta_info_tab[bVar1].mac_addr,6);
    memcpy((void *)((int)&ptVar3[1].lenpad + 2),&vif_info_tab[uVar8].mac_addr,6);
    memcpy(&ptVar3[1].next,&sta_info_tab[bVar1].mac_addr,6);
    uVar4 = txl_get_seq_ctrl();
    *(undefined *)((int)&ptVar3[1].txdesc + 2) = (char)uVar4;
    *(undefined *)((int)&ptVar3[1].txdesc + 3) = (char)(uVar4 >> 8);
    uVar4 = me_build_associate_req
                      ((uint32_t)ptVar3[1].dma_desc,&vif_info_tab[uVar8].bss_info,old_ap_addr_ptr,
                       vif_info_tab[uVar8].index,(uint32_t *)&stack0xffffffcc,&uStack54,con_par);
    ptVar5 = (frame->txdesc).lmac.hw_desc;
    (frame->txdesc).host.vif_idx = vif_info_tab[uVar8].index;
    bVar1 = vif_info_tab[uVar8].u[4];
    *(txl_frame_desc_tag **)&(frame->cfm).env = frame;
    (frame->txdesc).host.staid = bVar1;
    (frame->cfm).cfm_func = sm_frame_tx_cfm_handler;
    (ptVar5->thd).field_5 = (ptVar5->thd).field_4 + 0x17 + CONCAT22(extraout_var,uVar4);
    (ptVar5->thd).frmlen = CONCAT22(extraout_var,uVar4) + 0x1c;
    psVar7 = psVar2;
    while (psVar7 != (sm_connect_ind *)((int)&psVar2->status_code + (uint)uStack54)) {
      *(undefined *)psVar7->assoc_ie_buf = *(undefined *)((uStack52 - (int)psVar2) + (int)psVar7);
      psVar7 = (sm_connect_ind *)((int)&psVar7->status_code + 1);
    }
    psVar2->assoc_req_ie_len = uStack54;
    txl_frame_push(frame,'\x03');
    ke_timer_set(0x1806,6,0x32000);
    ke_state_set(6,6);
  }
  return;
}



void sm_assoc_done(uint16_t aid)

{
  sm_connect_req *psVar1;
  uint16_t *puVar2;
  
  psVar1 = sm_env.connect_param;
  puVar2 = (uint16_t *)ke_msg_alloc(0x1e,0,6,4);
  *puVar2 = aid;
  *(undefined *)(puVar2 + 1) = 1;
  *(uint8_t *)((int)puVar2 + 3) = psVar1->vif_idx;
  ke_msg_send();
  ke_state_set(6,7);
  return;
}



void sm_auth_handler(rxu_mgt_ind *param)

{
  uint16_t auth_seq;
  uint32_t *challenge;
  
  ke_timer_clear(0x1806,6);
  if (param[1].center_freq != 0) {
    if (((sm_env.connect_param)->auth_type != '\x01') ||
       ((sm_env.connect_param)->is_supplicant_enabled == false)) {
      printf("Authentication failure, Wlan802.11 status code = %d\r\n");
      sm_connect_ind(2);
      return;
    }
    (sm_env.connect_param)->auth_type = '\0';
    challenge = (uint32_t *)0x0;
    auth_seq = 1;
LAB_2300c2aa:
    sm_auth_send(auth_seq,challenge);
    return;
  }
  if (param[1].length != 0) {
    if (param[1].length != 1) {
      return;
    }
    if (param[1].framectrl != 4) {
      if (param[1].framectrl != 2) {
        sm_connect_ind(3);
        assert_warn("0","module",0x374);
        return;
      }
      if (param->length < 0x88) {
        printf("Drop illegal auth packet length %u\r\n");
        return;
      }
      challenge = (uint32_t *)&param[1].inst_nbr;
      auth_seq = 3;
      goto LAB_2300c2aa;
    }
  }
  sm_assoc_req_send();
  return;
}



void sm_assoc_rsp_handler(rxu_mgt_ind *param)

{
  uint8_t *puVar1;
  byte bVar2;
  ushort uVar3;
  int iVar4;
  sm_connect_ind *psVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint8_t uStack50;
  int8_t aiStack49 [3];
  uint8_t idx;
  int8_t pwr;
  
  psVar5 = sm_env.connect_ind;
  uVar8 = (uint)(sm_env.connect_param)->vif_idx;
  uStack50 = '\0';
  bVar2 = vif_info_tab[uVar8].u[4];
  ke_timer_clear(0x1806,6);
  uVar6 = (uint)param[1].framectrl;
  if (param[1].framectrl == 0) {
    if (5 < param->length) {
      uVar6 = (uint)param->length - 6 & 0xffff;
    }
    sm_assoc_done((ushort)(((uint)param[1].center_freq << 0x12) >> 0x12));
    me_init_rate(sta_info_tab + bVar2);
    aiStack49[0] = (vif_info_tab[uVar8].bss_info.chan)->tx_power -
                   vif_info_tab[uVar8].bss_info.power_constraint;
    tpc_update_vif_tx_power(vif_info_tab + uVar8,aiStack49,&uStack50);
    uVar3 = psVar5->assoc_req_ie_len;
    uVar7 = 0;
    while (uVar6 != uVar7) {
      puVar1 = &param[1].band + uVar7;
      iVar4 = uVar7 + uVar3;
      uVar7 = uVar7 + 1;
      *(uint8_t *)((int)psVar5->assoc_ie_buf + iVar4) = *puVar1;
    }
    psVar5->assoc_rsp_ie_len = (uint16_t)uVar6;
    if ((*(uint *)&vif_info_tab[uVar8].bss_info.is_supplicant_enabled & 0x12a00) != 0) {
      supplicantInitSession
                (&sta_conn_info,(CHAR *)vif_info_tab[uVar8].bss_info.ssid.array,
                 (ushort)vif_info_tab[uVar8].bss_info.ssid.length,
                 (CHAR *)&vif_info_tab[uVar8].bss_info.bssid,(UINT8 *)&vif_info_tab[uVar8].mac_addr)
      ;
    }
  }
  else {
    printf("Association failure, Wlan802.11 status code = %d\r\n",uVar6);
    sm_connect_ind(5);
  }
  return;
}



int sm_deauth_handler(rxu_mgt_ind *param)

{
  byte bVar1;
  ushort reason;
  sm_connect_req *psVar2;
  ke_state_t kVar3;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  
  psVar2 = sm_env.connect_param;
  bVar1 = param->inst_nbr;
  kVar3 = ke_state_get(6);
  if (CONCAT22(extraout_var,kVar3) != 8) {
    kVar3 = ke_state_get(6);
    if (CONCAT22(extraout_var_00,kVar3) == 0) {
      if (vif_info_tab[bVar1].active == false) {
        return 0;
      }
      reason = param[1].length;
      ke_state_set(6,8);
      printf("Deauth by AP, Wlan802.11 reason code = %d\r\n",(uint)reason);
      sm_disconnect_process(vif_info_tab + bVar1,reason);
      return 0;
    }
    if (psVar2->vif_idx == param->inst_nbr) {
      sm_connect_ind(6);
      return 0;
    }
  }
  return 2;
}



void sm_handle_supplicant_result(uint8_t sta_id,uint16_t reason_code)

{
  byte bVar1;
  txl_buffer_tag *ptVar2;
  _Bool _Var3;
  uint16_t status;
  undefined3 in_register_00002029;
  int iVar4;
  txl_frame_desc_tag *frame;
  undefined2 extraout_var_00;
  undefined3 extraout_var;
  undefined2 in_register_0000202e;
  tx_hw_desc *ptVar5;
  uint uVar6;
  
  iVar4 = CONCAT31(in_register_00002029,sta_id);
  bVar1 = sta_info_tab[iVar4].inst_nbr;
  uVar6 = (uint)bVar1;
  if (CONCAT22(in_register_0000202e,reason_code) == 0) {
    sta_info_tab[iVar4].ctrl_port_state = '\x02';
    status = 0;
  }
  else {
    if (CONCAT22(in_register_0000202e,reason_code) == 0xf) {
      printf(
            "4-way handshake timeout failure, wlan 802.11 reason code = %u,                try to transmit deauth frame\r\n"
            );
    }
    frame = txl_frame_get((uint)((vif_info_tab[uVar6].bss_info.chan)->band != '\0'),0x100);
    if (frame == (txl_frame_desc_tag *)0x0) {
      status = 10;
    }
    else {
      tpc_update_frame_tx_power(vif_info_tab + uVar6,frame);
      ptVar2 = (frame->txdesc).lmac.buffer;
      *(undefined *)&ptVar2[1].length = 0xc0;
      *(undefined *)((int)&ptVar2[1].length + 1) = 0;
      *(undefined *)((int)&ptVar2[1].length + 2) = 0;
      *(undefined *)((int)&ptVar2[1].length + 3) = 0;
      memcpy(&ptVar2[1].lenheader,&sta_info_tab[iVar4].mac_addr,6);
      memcpy((void *)((int)&ptVar2[1].lenpad + 2),&vif_info_tab[uVar6].mac_addr,6);
      memcpy(&ptVar2[1].next,&sta_info_tab[iVar4].mac_addr,6);
      status = txl_get_seq_ctrl();
      *(undefined *)((int)&ptVar2[1].txdesc + 2) = (char)status;
      *(undefined *)((int)&ptVar2[1].txdesc + 3) = (char)(status >> 8);
      (frame->cfm).cfm_func = sm_supplicant_deauth_cfm;
      *(vif_info_tag **)&(frame->cfm).env = vif_info_tab + uVar6;
      (frame->txdesc).host.vif_idx = bVar1;
      (frame->txdesc).host.staid = sta_id;
      status = me_build_deauthenticate((uint32_t)ptVar2[1].dma_desc,reason_code);
      ptVar5 = (frame->txdesc).lmac.hw_desc;
      (ptVar5->thd).frmlen = CONCAT22(extraout_var_00,status) + 0x1c;
      (ptVar5->thd).field_5 = (ptVar5->thd).field_4 + 0x17 + CONCAT22(extraout_var_00,status);
      _Var3 = txl_frame_push(frame,'\x03');
      if (CONCAT31(extraout_var,_Var3) != 0) {
        return;
      }
      status = 9;
    }
  }
  sm_connect_ind(status);
  return;
}



undefined2 * txu_cntrl_sec_hdr_append(int param_1,undefined2 *param_2,int param_3)

{
  uint8_t uVar1;
  ushort uVar2;
  undefined2 *puVar3;
  int iVar4;
  key_info_tag *pkVar5;
  
  pkVar5 = *sta_info_tab[*(byte *)(param_1 + 0x30)].sta_sec_info.cur_key;
  if (pkVar5 == (key_info_tag *)0x0) {
    return param_2;
  }
  if (((vif_info_tab[*(byte *)(param_1 + 0x2f)].flags & 2) != 0) &&
     ((uint)sta_info_tab[*(byte *)(param_1 + 0x30)].ctrl_port_ethertype ==
      (((uint)*(ushort *)(param_1 + 0x20) & 0xff) << 8 | (uint)(*(ushort *)(param_1 + 0x20) >> 8))))
  {
    return param_2;
  }
  uVar1 = pkVar5->cipher;
  if (uVar1 == '\x01') {
    param_2[-4] = *(ushort *)(param_1 + 0x22) & 0x7f00 | 0x2000 | *(ushort *)(param_1 + 0x22) >> 8;
    uVar2 = (ushort)*(byte *)(param_1 + 0x22) | (ushort)pkVar5->key_idx << 0xe;
LAB_2300c744:
    puVar3 = param_2 + -4;
    param_2[-3] = uVar2 | 0x2000;
    param_2[-2] = *(undefined2 *)(param_1 + 0x24);
    param_2[-1] = *(undefined2 *)(param_1 + 0x26);
  }
  else {
    if (uVar1 != '\0') {
      if (uVar1 == '\x02') {
        param_2[-4] = *(undefined2 *)(param_1 + 0x22);
        uVar2 = (ushort)pkVar5->key_idx << 0xe;
        goto LAB_2300c744;
      }
      puVar3 = param_2;
      if (uVar1 != '\x03') goto LAB_2300c6f6;
    }
    puVar3 = param_2 + -2;
    *puVar3 = *(undefined2 *)(param_1 + 0x22);
    param_2[-1] = (ushort)pkVar5->key_idx << 0xe | *(ushort *)(param_1 + 0x24);
  }
LAB_2300c6f6:
  if (param_3 == 0) {
    iVar4 = *(int *)(param_1 + 0x68) + 0xf0;
  }
  else {
    iVar4 = *(int *)(param_1 + 0x54);
  }
  *(uint *)(iVar4 + 0xc) = (uint)pkVar5->hw_key_idx | *(uint *)(iVar4 + 0xc) & 0xffc00;
  return puVar3;
}



int txu_cntrl_sechdr_len_compute(txdesc *txdesc,int *tail_len)

{
  byte bVar1;
  uint8_t uVar2;
  ushort uVar3;
  int iVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  key_info_tag *pkVar8;
  
  bVar1 = (txdesc->host).vif_idx;
  pkVar8 = *sta_info_tab[(txdesc->host).staid].sta_sec_info.cur_key;
  *tail_len = 0;
  if (pkVar8 == (key_info_tag *)0x0) {
    return 0;
  }
  if (((vif_info_tab[bVar1].flags & 2) != 0) &&
     (uVar3 = (txdesc->host).ethertype,
     (uint)sta_info_tab[(txdesc->host).staid].ctrl_port_ethertype ==
     (((uint)uVar3 & 0xff) << 8 | (uint)(uVar3 >> 8)))) {
    return 0;
  }
  uVar2 = pkVar8->cipher;
  if (uVar2 == '\x01') {
    iVar4 = 0xc;
LAB_2300c83a:
    *tail_len = iVar4;
    if (((txdesc->host).flags & 1) == 0) {
      uVar7 = *(uint *)&pkVar8->tx_pn;
      iVar4 = *(int *)((int)&pkVar8->tx_pn + 4);
      uVar6 = uVar7 + 1;
      *(uint *)&pkVar8->tx_pn = uVar6;
      *(int *)((int)&pkVar8->tx_pn + 4) = (uint)(uVar6 < uVar7) + iVar4;
      memcpy((txdesc->host).pn,&pkVar8->tx_pn,6);
    }
    iVar4 = 8;
  }
  else {
    if (uVar2 != '\0') {
      if (uVar2 == '\x02') {
        iVar4 = 8;
        goto LAB_2300c83a;
      }
      if (uVar2 != '\x03') {
        return 0;
      }
    }
    *tail_len = 4;
    iVar4 = 4;
    if (((txdesc->host).flags & 1) == 0) {
      uVar7 = *(uint *)&pkVar8->tx_pn;
      iVar5 = *(int *)((int)&pkVar8->tx_pn + 4);
      uVar6 = uVar7 + 1;
      *(uint *)&pkVar8->tx_pn = uVar6;
      *(int *)((int)&pkVar8->tx_pn + 4) = (uint)(uVar6 < uVar7) + iVar5;
      memcpy((txdesc->host).pn,&pkVar8->tx_pn,4);
    }
  }
  return iVar4;
}



void txu_cntrl_frame_build(txdesc *txdesc,uint32_t buf)

{
  uint8_t uVar1;
  byte bVar2;
  int iVar3;
  ushort *puVar4;
  ushort *puVar5;
  uint uVar6;
  ushort uVar7;
  ushort uVar8;
  ushort *puVar9;
  uint uVar10;
  key_info_tag *pkVar11;
  
  uVar8 = (txdesc->host).ethertype;
  if (0x5ff < (((uint)uVar8 & 0xff) << 8 | (uint)(uVar8 >> 8))) {
    *(undefined2 *)(buf - 8) = 0xaaaa;
    *(undefined2 *)(buf - 6) = 3;
    *(undefined2 *)(buf - 4) = 0;
    *(uint16_t *)(buf - 2) = (txdesc->host).ethertype;
  }
  iVar3 = txu_cntrl_sec_hdr_append(txdesc,1);
  uVar6 = (uint)(txdesc->host).staid;
  uVar1 = (txdesc->host).tid;
  uVar10 = (uint)(txdesc->host).vif_idx;
  pkVar11 = *sta_info_tab[uVar6].sta_sec_info.cur_key;
  puVar9 = (ushort *)(iVar3 + -0x1a);
  if (uVar1 == -1) {
    puVar9 = (ushort *)(iVar3 + -0x18);
  }
  puVar4 = puVar9 + 0xc;
  puVar5 = (ushort *)0x0;
  if (((txdesc->host).flags & 0x100) != 0) {
    puVar5 = puVar9 + -3;
    puVar9 = puVar5;
  }
  if (uVar1 == -1) {
    *(undefined *)puVar9 = 0;
    *(undefined *)((int)puVar9 + 1) = 0;
    *(undefined *)(puVar9 + 0xb) = 0;
    *(undefined *)((int)puVar9 + 0x17) = 0;
  }
  else {
    *(undefined *)puVar9 = 0x80;
    *(undefined *)((int)puVar9 + 1) = 0;
    *puVar4 = (ushort)(txdesc->host).tid;
    iVar3 = (uint)(txdesc->host).sn << 0x14;
    *(char *)(puVar9 + 0xb) = (char)((uint)iVar3 >> 0x10);
    *(undefined *)((int)puVar9 + 0x17) = (char)((uint)iVar3 >> 0x18);
    if (((txdesc->host).flags & 0x200) != 0) {
      *puVar4 = *puVar4 | 0x10;
    }
  }
  uVar7 = *puVar9;
  *(byte *)puVar9 = (byte)uVar7 | 8;
  *(undefined *)((int)puVar9 + 1) = (char)((uint)uVar7 >> 8);
  uVar8 = (txdesc->host).flags;
  if ((int)((uint)uVar8 << 0x14) < 0) {
    uVar7 = uVar7 & 0xfcff | 8;
LAB_2300c97c:
    *(char *)puVar9 = (char)uVar7;
    *(undefined *)((int)puVar9 + 1) = (char)(uVar7 >> 8);
  }
  else {
    if ((uVar8 & 0x100) != 0) {
      uVar7 = uVar7 | 0x308;
      goto LAB_2300c97c;
    }
    if (vif_info_tab[uVar10].type == '\0') {
      uVar7 = uVar7 | 0x108;
      goto LAB_2300c97c;
    }
    if (vif_info_tab[uVar10].type == '\x02') {
      uVar7 = uVar7 | 0x208;
      goto LAB_2300c97c;
    }
  }
  if (((txdesc->host).flags & 4) != 0) {
    uVar8 = *puVar9;
    *(char *)puVar9 = (char)uVar8;
    *(byte *)((int)puVar9 + 1) = (byte)((uint)uVar8 >> 8) | 0x20;
  }
  puVar9[5] = vif_info_tab[uVar10].mac_addr.array[0];
  puVar9[6] = vif_info_tab[uVar10].mac_addr.array[1];
  puVar9[7] = vif_info_tab[uVar10].mac_addr.array[2];
  bVar2 = *(byte *)((int)puVar9 + 1) & 3;
  if (bVar2 == 1) {
    puVar9[2] = sta_info_tab[uVar6].mac_addr.array[0];
    puVar9[3] = sta_info_tab[uVar6].mac_addr.array[1];
    puVar9[4] = sta_info_tab[uVar6].mac_addr.array[2];
    puVar9[8] = (txdesc->host).eth_dest_addr.array[0];
    puVar9[9] = (txdesc->host).eth_dest_addr.array[1];
    uVar8 = (txdesc->host).eth_dest_addr.array[2];
  }
  else {
    if (bVar2 == 2) {
      puVar9[2] = (txdesc->host).eth_dest_addr.array[0];
      puVar9[3] = (txdesc->host).eth_dest_addr.array[1];
      puVar9[4] = (txdesc->host).eth_dest_addr.array[2];
      puVar9[8] = (txdesc->host).eth_src_addr.array[0];
      puVar9[9] = (txdesc->host).eth_src_addr.array[1];
      uVar8 = (txdesc->host).eth_src_addr.array[2];
    }
    else {
      if (bVar2 != 0) {
        puVar5[2] = sta_info_tab[uVar6].mac_addr.array[0];
        puVar5[3] = sta_info_tab[uVar6].mac_addr.array[1];
        puVar5[4] = sta_info_tab[uVar6].mac_addr.array[2];
        puVar5[8] = (txdesc->host).eth_dest_addr.array[0];
        puVar5[9] = (txdesc->host).eth_dest_addr.array[1];
        puVar5[10] = (txdesc->host).eth_dest_addr.array[2];
        puVar5[0xc] = (txdesc->host).eth_src_addr.array[0];
        puVar5[0xd] = (txdesc->host).eth_src_addr.array[1];
        puVar5[0xe] = (txdesc->host).eth_src_addr.array[2];
        goto LAB_2300ca20;
      }
      puVar9[2] = (txdesc->host).eth_dest_addr.array[0];
      puVar9[3] = (txdesc->host).eth_dest_addr.array[1];
      puVar9[4] = (txdesc->host).eth_dest_addr.array[2];
      puVar9[8] = vif_info_tab[uVar10].bss_info.bssid.array[0];
      puVar9[9] = vif_info_tab[uVar10].bss_info.bssid.array[1];
      uVar8 = vif_info_tab[uVar10].bss_info.bssid.array[2];
    }
  }
  puVar9[10] = uVar8;
LAB_2300ca20:
  if ((pkVar11 != (key_info_tag *)0x0) &&
     (((vif_info_tab[uVar10].flags & 2) == 0 ||
      (uVar8 = (txdesc->host).ethertype,
      (uint)sta_info_tab[(txdesc->host).staid].ctrl_port_ethertype !=
      (((uint)uVar8 & 0xff) << 8 | (uint)(uVar8 >> 8)))))) {
    uVar8 = *puVar9;
    *(char *)puVar9 = (char)uVar8;
    *(byte *)((int)puVar9 + 1) = (byte)((uint)uVar8 >> 8) | 0x40;
  }
  return;
}


/*
Unable to decompile 'txu_cntrl_push'
Cause: Exception while decompiling 2300cb86: Decompiler process died

*/


void txu_cntrl_tkip_mic_append(txdesc *txdesc,uint8_t ac)

{
  uint8_t uVar1;
  byte bVar2;
  byte bVar3;
  txl_buffer_tag *ptVar4;
  uint32_t uVar5;
  int iVar6;
  key_info_tag *pkVar7;
  int iVar8;
  tx_pbd *ptVar9;
  undefined *puVar10;
  undefined *puVar11;
  tx_pbd *ptVar12;
  txl_buffer_tag *ptVar13;
  undefined auStack48 [4];
  mic_calc mic;
  
  pkVar7 = *sta_info_tab[(txdesc->host).staid].sta_sec_info.cur_key;
  if (pkVar7 != (key_info_tag *)0x0) {
    uVar1 = pkVar7->cipher;
    ptVar4 = (txdesc->lmac).buffer;
    if (uVar1 != '\x01') {
      if ((uVar1 == '\0') || (uVar1 == '\x03')) {
        ptVar9 = &ptVar4->tbd;
        do {
          ptVar12 = ptVar9;
          ptVar9 = (tx_pbd *)ptVar12->next;
        } while (ptVar9 != (tx_pbd *)0x0);
        *(tx_pbd **)&ptVar12->next = &ptVar4->tkip_mic_icv_pbd;
        *(uint8_t **)&(ptVar4->tkip_mic_icv_pbd).datastartptr = ptVar4->tkip_mic_icv;
        *(uint8_t **)&(ptVar4->tkip_mic_icv_pbd).dataendptr = ptVar4->tkip_mic_icv + 3;
        (ptVar4->tkip_mic_icv_pbd).upatterntx = 0xcafefade;
        (ptVar4->tkip_mic_icv_pbd).bufctrlinfo = 0;
        (ptVar4->tkip_mic_icv_pbd).next = 0;
      }
      return;
    }
    ptVar9 = &ptVar4->tbd;
    do {
      ptVar12 = ptVar9;
      ptVar9 = (tx_pbd *)ptVar12->next;
    } while (ptVar9 != (tx_pbd *)0x0);
    bVar2 = (txdesc->umac).head_len;
    bVar3 = (txdesc->umac).hdr_len_802_2;
    *(tx_pbd **)&ptVar12->next = &ptVar4->tkip_mic_icv_pbd;
    *(uint8_t **)&(ptVar4->tkip_mic_icv_pbd).datastartptr = ptVar4->tkip_mic_icv;
    *(uint8_t **)&(ptVar4->tkip_mic_icv_pbd).dataendptr = ptVar4->tkip_mic_icv + 0xb;
    (ptVar4->tkip_mic_icv_pbd).upatterntx = 0xcafefade;
    (ptVar4->tkip_mic_icv_pbd).bufctrlinfo = 0;
    (ptVar4->tkip_mic_icv_pbd).next = 0;
    ptVar13 = (txdesc->lmac).buffer;
    me_mic_init((mic_calc *)auStack48,(uint32_t *)pkVar7->u,&(txdesc->host).eth_dest_addr,
                &(txdesc->host).eth_src_addr,(txdesc->host).tid);
    me_mic_calc((mic_calc *)auStack48,(int)ptVar4 + (uint)bVar2 + (0x14c - (uint)bVar3),
                (uint)(txdesc->umac).hdr_len_802_2);
    uVar5 = (ptVar13->tbd).next;
    while (uVar5 != 0) {
      iVar6 = *(int *)(uVar5 + 4);
      if (iVar6 == 0) {
        me_mic_end((mic_calc *)auStack48);
        iVar8 = *(int *)(uVar5 + 8);
        do {
          puVar10 = auStack48 + iVar6;
          puVar11 = (undefined *)(iVar8 + iVar6);
          iVar6 = iVar6 + 1;
          *puVar11 = *puVar10;
        } while (iVar6 != 8);
        return;
      }
      me_mic_calc((mic_calc *)auStack48,*(uint32_t *)(uVar5 + 8),
                  (*(int *)(uVar5 + 0xc) + 1) - *(uint32_t *)(uVar5 + 8));
      uVar5 = *(uint32_t *)(uVar5 + 4);
    }
    me_mic_end((mic_calc *)auStack48);
    ebreak();
  }
  return;
}



void txu_cntrl_cfm(txdesc *txdesc)

{
  ushort uVar1;
  tx_cfm_tag *ptVar2;
  uint32_t *puVar3;
  
  puVar3 = (uint32_t *)(txdesc->host).status_addr;
  ptVar2 = ((txdesc->lmac).hw_desc)->cfm_ptr;
  uVar1 = (txdesc->host).flags;
  if ((uVar1 & 8) == 0) {
    if ((uVar1 & 0x200) == 0) goto LAB_2300cefc;
  }
  else {
    if (((uVar1 & 0x20) != 0) && (-1 < (int)(ptVar2->status << 8))) {
      rxu_cntrl_get_pm();
    }
    if (((txdesc->host).flags & 0x200) == 0) goto LAB_2300cefc;
    if ((txdesc->host).staid == -1) {
      assert_err("txdesc->host.staid != INVALID_STA_IDX","module",0x3a9);
    }
    txl_frame_send_qosnull_frame((txdesc->host).staid,0x17,(cfm_func_ptr *)0x0,(void *)0x0);
  }
  sta_info_tab[(txdesc->host).staid].ps_service_period = 0;
LAB_2300cefc:
  ptVar2->status = ptVar2->status | 1;
  *(undefined2 *)&ptVar2->credits = 0x101;
  txdesc[-1].buf[0x6b] = 0;
  *puVar3 = ptVar2->status;
  return;
}



void txu_cntrl_protect_mgmt_frame(txdesc *txdesc,uint32_t frame,uint16_t hdr_len)

{
  byte bVar1;
  ushort uVar2;
  uint uVar3;
  undefined2 in_register_00002032;
  uint uStack20;
  int tail_len;
  
  bVar1 = (txdesc->umac).head_len;
  uVar3 = (uint)bVar1;
  if (bVar1 == 0) {
    uVar3 = txu_cntrl_sechdr_len_compute(txdesc,(int *)&uStack20);
    (txdesc->umac).head_len = (uint8_t)uVar3;
    (txdesc->umac).tail_len = (uint8_t)uStack20;
  }
  else {
    uStack20 = (uint)(txdesc->umac).tail_len;
  }
  uVar2 = *(ushort *)frame;
  *(undefined *)frame = *(undefined *)frame;
  *(byte *)(frame + 1) = (byte)((uint)uVar2 >> 8) | 0x40;
  txu_cntrl_sec_hdr_append(txdesc,CONCAT22(in_register_00002032,hdr_len) + frame + uVar3,0);
  return;
}



int _aid_list_delete(uint8_t *mac)

{
  int iVar1;
  int iVar2;
  apm *paVar3;
  
  paVar3 = &apm_env;
  iVar1 = 0;
  do {
    if (paVar3->aid_list[0].used != '\0') {
      iVar2 = memcmp(paVar3->aid_list,mac,6);
      if (iVar2 == 0) {
        memset(paVar3->aid_list,0,6);
        apm_env.aid_list[iVar1].used = '\0';
        return 0;
      }
    }
    iVar1 = iVar1 + 1;
    paVar3 = (apm *)((int)&(paVar3->bss_config).first + 3);
  } while (iVar1 != 10);
  return -1;
}



void apm_sta_delete(uint8_t sta_idx,uint8_t *mac)

{
  uint8_t *puVar1;
  uint8_t *puVar2;
  
  puVar1 = (uint8_t *)ke_msg_alloc(0x1409,5,7,2);
  puVar2 = (uint8_t *)ke_msg_alloc(0x1c09,0xd,7,1);
  _aid_list_delete(mac);
  mm_sec_machwkey_del(sta_idx + '\b');
  apm_env.assoc_sta_count = apm_env.assoc_sta_count + -1;
  *puVar2 = sta_idx;
  ke_msg_send(puVar2);
  *puVar1 = sta_idx;
  puVar1[1] = '\0';
  ke_msg_send(puVar1);
  return;
}



void apm_tx_cfm_handler(uint8_t *param_1,int param_2)

{
  if (-1 < param_2 << 8) {
    _aid_list_delete(param_1);
    ke_msg_free(param_1 + -0xc);
    printf("apm mlme assoc rsp send failed:%d,aid:%d\n",(uint)*(ushort *)(param_1 + 0x44));
    apm_env.assoc_sta_count = apm_env.assoc_sta_count + -1;
    return;
  }
  if (*(short *)(param_1 + 0x44) != 0) {
    ke_msg_send();
    return;
  }
  ke_msg_free(param_1 + -0xc);
  return;
}



void apm_init(void)

{
  memset(&apm_env,0,0x60);
  apm_env.aging_sta_idx = '\0';
  apm_env._22_2_ = 0xc00;
  ke_state_set(7,0);
  return;
}



void apm_start_cfm(int param_1)

{
  byte bVar1;
  uint16_t uVar2;
  apm_start_req *__src;
  undefined *puVar3;
  void *pvVar4;
  uint uVar5;
  int iVar6;
  
  __src = apm_env.param;
  puVar3 = (undefined *)ke_msg_alloc(0x1c01,0xd,7,4);
  if (param_1 == 0) {
    uVar5 = (uint)__src->vif_idx;
    pvVar4 = ke_msg_alloc(0x1e,0,7,4);
    iVar6 = uVar5 + 10;
    *(undefined *)((int)pvVar4 + 2) = 1;
    *(uint8_t *)((int)pvVar4 + 3) = vif_info_tab[uVar5].index;
    ke_msg_send();
    vif_info_tab[uVar5].flags = __src->flags;
    uVar2 = __src->ctrl_port_ethertype;
    vif_info_tab[uVar5].u[0x2ee] = 0;
    *(uint16_t *)(vif_info_tab[uVar5].u + 0x2f0) = uVar2;
    puVar3[2] = (vif_info_tab[uVar5].chan_ctxt)->idx;
    puVar3[3] = __src->vif_idx + '\n';
    memcpy(&sta_info_tab[iVar6].info,__src,0xd);
    sta_info_tab[iVar6].ctrl_port_state = '\x02';
    me_init_bcmc_rate(sta_info_tab + iVar6);
    bVar1 = sta_info_tab[iVar6].pol_tbl.upd_field;
    sta_info_tab[iVar6].mac_addr.array[0] = 1;
    sta_info_tab[iVar6].pol_tbl.upd_field = bVar1 | 0x10;
    sta_info_tab[iVar6].staid = __src->vif_idx + '\n';
  }
  *puVar3 = (char)param_1;
  puVar3[1] = __src->vif_idx;
  ke_timer_set(0x1c0a,7,5000000);
  ke_msg_send(puVar3);
  ke_msg_free(__src[-1].phrase + 0x35);
  apm_env.param = (apm_start_req *)0x0;
  ke_state_set(7,0);
  return;
}



void apm_send_next_bss_param(void)

{
  co_list_hdr *pcVar1;
  
  pcVar1 = co_list_pop_front(&apm_env.bss_config);
  if (pcVar1 == (co_list_hdr *)0x0) {
    assert_err("msg != NULL","module",0xbf);
  }
  ke_msg_send(pcVar1 + 3);
  return;
}



void apm_set_bss_param(void)

{
  byte bVar1;
  apm_start_req *rateset;
  uint16_t uVar2;
  undefined *puVar3;
  void *__dest;
  undefined4 *puVar4;
  uint16_t *puVar5;
  undefined *puVar6;
  undefined2 extraout_var;
  
  rateset = apm_env.param;
  bVar1 = (apm_env.param)->vif_idx;
  puVar3 = (undefined *)ke_msg_alloc(0x1413,5,7,2);
  __dest = ke_msg_alloc(0x18,0,7,7);
  puVar4 = (undefined4 *)ke_msg_alloc(0x16,0,7,8);
  puVar5 = (uint16_t *)ke_msg_alloc(0x14,0,7,4);
  puVar6 = (undefined *)ke_msg_alloc(0x1411,5,7,2);
  *puVar3 = 1;
  puVar3[1] = vif_info_tab[bVar1].index;
  co_list_push_back(&apm_env.bss_config,(co_list_hdr *)(puVar3 + -0xc));
  memcpy(__dest,&vif_info_tab[bVar1].mac_addr,6);
  *(uint8_t *)((int)__dest + 6) = rateset->vif_idx;
  co_list_push_back(&apm_env.bss_config,(co_list_hdr *)((int)__dest + -0xc));
  *(uint8_t *)((int)puVar4 + 5) = (rateset->chan).band;
  uVar2 = me_legacy_rate_bitfield_build((mac_rateset *)rateset,true);
  *puVar4 = CONCAT22(extraout_var,uVar2);
  *(uint8_t *)(puVar4 + 1) = rateset->vif_idx;
  co_list_push_back(&apm_env.bss_config,(co_list_hdr *)(puVar4 + -3));
  *puVar5 = rateset->bcn_int;
  *(uint8_t *)(puVar5 + 1) = rateset->vif_idx;
  co_list_push_back(&apm_env.bss_config,(co_list_hdr *)(puVar5 + -6));
  *puVar6 = 1;
  puVar6[1] = rateset->vif_idx;
  co_list_push_back(&apm_env.bss_config,(co_list_hdr *)(puVar6 + -0xc));
  apm_send_next_bss_param();
  ke_state_set(7,1);
  return;
}



void apm_stop(vif_info_tag *vif)

{
  undefined *puVar1;
  undefined *puVar2;
  void *pvVar3;
  
  puVar1 = (undefined *)ke_msg_alloc(0x1413,5,7,2);
  puVar2 = (undefined *)ke_msg_alloc(0x1411,5,7,2);
  ke_timer_clear(0x1c0a,7);
  *puVar1 = 0;
  puVar1[1] = vif->index;
  ke_msg_send(puVar1);
  if (vif->active != false) {
    pvVar3 = ke_msg_alloc(0x1e,0,7,4);
    *(undefined *)((int)pvVar3 + 2) = 0;
    *(uint8_t *)((int)pvVar3 + 3) = vif->index;
    ke_msg_send();
  }
  if (vif->chan_ctxt != (chan_ctxt_tag *)0x0) {
    chan_ctxt_unlink(vif->index);
  }
  *puVar2 = 0;
  puVar2[1] = vif->index;
  ke_msg_send(puVar2);
  return;
}



_Bool apm_tx_int_ps_check(txdesc *txdesc)

{
  byte bVar1;
  undefined uVar2;
  
  if (vif_info_tab[(txdesc->host).vif_idx].type == '\x02') {
    bVar1 = (txdesc->host).staid;
    uVar2 = 1;
    if (((bVar1 < 0xc) && (sta_info_tab[bVar1].ps_state == '\x01')) &&
       ((sta_info_tab[bVar1].ps_service_period & 3U) == 0)) {
      (txdesc->host).flags = (txdesc->host).flags | 0x1000;
      uVar2 = 0;
    }
  }
  else {
    uVar2 = 1;
  }
  return (_Bool)uVar2;
}



void apm_tx_int_ps_postpone(txdesc *txdesc,sta_info_tag *sta)

{
  byte bVar1;
  sta_ps_traffic sVar2;
  sta_ps_traffic sVar3;
  uint16_t *puVar4;
  
  if ((int)((uint)(txdesc->host).flags << 0x13) < 0) {
    bVar1 = (sta->info).uapsd_queues;
    sVar2 = sta->traffic_avail;
    if ((mac_ac2uapsd[(txdesc->host).tid] & bVar1) == 0) {
      if ((sVar2 & PS_TRAFFIC_INT) != 0) {
        return;
      }
      sVar3 = PS_TRAFFIC_INT;
    }
    else {
      sVar3 = UAPSD_TRAFFIC_INT;
      if ((sVar2 & UAPSD_TRAFFIC_INT) != 0) {
        return;
      }
    }
    sta->traffic_avail = sVar2 | sVar3;
    if (((mac_ac2uapsd[(txdesc->host).tid] & bVar1) == 0) || (bVar1 == 0xf)) {
      puVar4 = (uint16_t *)ke_msg_alloc(0x41,0,5,4);
      *puVar4 = sta->aid;
      *(uint8_t *)((int)puVar4 + 3) = sta->inst_nbr;
      *(undefined *)(puVar4 + 1) = 1;
      ke_msg_send();
      return;
    }
  }
  return;
}



// WARNING: Type propagation algorithm not settling

txdesc * apm_tx_int_ps_get_postpone(vif_info_tag *vif,sta_info_tag *sta,int *stop)

{
  uint8_t uVar1;
  ushort uVar2;
  co_list_hdr cVar3;
  co_list_hdr element;
  uint16_t *puVar4;
  co_list_hdr *pcVar5;
  uint uVar6;
  int *piVar7;
  sta_ps_traffic sVar8;
  sta_ps_traffic sVar9;
  co_list_hdr prev_element;
  
  sVar8 = vif->type;
  if ((sVar8 == PS_TRAFFIC_INT) && (uVar6 = sta->ps_service_period, uVar6 != 0)) {
    sVar9 = PS_TRAFFIC_HOST;
    if ((uVar6 & 1) == 0) {
      sVar9 = UAPSD_TRAFFIC_HOST;
      sVar8 = UAPSD_TRAFFIC_INT;
    }
    if ((sVar8 & sta->traffic_avail) != 0) {
      cVar3 = (co_list_hdr)(sta->tx_desc_post).first;
      prev_element = (co_list_hdr)(co_list_hdr *)0x0;
      while( true ) {
        element = cVar3;
        if (element == (co_list_hdr)0x0) {
          assert_warn("txdesc","module",0x16f);
          *stop = 1;
          return (txdesc *)0x0;
        }
        if (((mac_ac2uapsd[*(byte *)((int)element + 0x2e)] & (sta->info).uapsd_queues) == 0) !=
            (uVar6 == 2)) break;
        cVar3 = *(co_list_hdr *)element;
        prev_element = element;
      }
      co_list_remove(&sta->tx_desc_post,(co_list_hdr *)prev_element,(co_list_hdr *)element);
      *(char *)((int)element + 0x2e) = ((sta->ps_service_period & 8U) != 0) + '\x03';
      if (prev_element == (co_list_hdr)0x0) {
        piVar7 = (int *)(sta->tx_desc_post).first;
      }
      else {
        piVar7 = (int *)((co_list_hdr *)prev_element)->next;
      }
      while (piVar7 != (int *)0x0) {
        if (((mac_ac2uapsd[*(byte *)((int)piVar7 + 0x2e)] & (sta->info).uapsd_queues) == 0) !=
            (sta->ps_service_period == 2)) goto LAB_2300d610;
        piVar7 = (int *)*piVar7;
      }
      sVar8 = ~sVar8 & sta->traffic_avail;
      sta->traffic_avail = sVar8;
      if ((sVar8 & sVar9) == 0) {
        puVar4 = (uint16_t *)ke_msg_alloc(0x41,0,5,4);
        *puVar4 = sta->aid;
        uVar1 = sta->inst_nbr;
        *(undefined *)(puVar4 + 1) = 0;
        *(uint8_t *)((int)puVar4 + 3) = uVar1;
        ke_msg_send();
      }
      else {
LAB_2300d610:
        pcVar5 = ((co_list_hdr *)((int)element + 0x68))->next;
        uVar2 = *(ushort *)&pcVar5[0x53].next;
        *(char *)&pcVar5[0x53].next = (char)uVar2;
        *(byte *)((int)&pcVar5[0x53].next + 1) = (byte)((uint)uVar2 >> 8) | 0x20;
      }
      return (txdesc *)element;
    }
    *stop = 1;
  }
  else {
    *stop = 0;
  }
  return (txdesc *)0x0;
}



void apm_tx_int_ps_clear(vif_info_tag *vif,uint8_t sta_idx)

{
  sta_ps_traffic sVar1;
  uint8_t uVar2;
  uint16_t *puVar3;
  undefined3 in_register_0000202d;
  int iVar4;
  
  iVar4 = CONCAT31(in_register_0000202d,sta_idx);
  if (vif->type != '\x02') {
    return;
  }
  sta_mgmt_send_postponed_frame(vif,sta_info_tab + iVar4,0);
  sVar1 = sta_info_tab[iVar4].traffic_avail;
  if (((sVar1 & (PS_TRAFFIC_INT|UAPSD_TRAFFIC_INT)) != 0) &&
     (sta_info_tab[iVar4].traffic_avail = sVar1 & ~(PS_TRAFFIC_INT|UAPSD_TRAFFIC_INT),
     (sVar1 & ~(PS_TRAFFIC_INT|UAPSD_TRAFFIC_INT)) == 0)) {
    puVar3 = (uint16_t *)ke_msg_alloc(0x41,0,5,4);
    *puVar3 = sta_info_tab[iVar4].aid;
    uVar2 = sta_info_tab[iVar4].inst_nbr;
    *(undefined *)(puVar3 + 1) = 0;
    *(uint8_t *)((int)puVar3 + 3) = uVar2;
    ke_msg_send();
    return;
  }
  return;
}



void apm_sta_fw_delete(uint8_t sta_idx)

{
  undefined3 in_register_00002029;
  
  apm_sta_delete(sta_idx,(uint8_t *)&sta_info_tab[CONCAT31(in_register_00002029,sta_idx)].mac_addr);
  return;
}



void apm_sta_add(uint8_t sta_idx)

{
  undefined3 in_register_00002029;
  int iVar1;
  uint32_t *puVar2;
  
  iVar1 = CONCAT31(in_register_00002029,sta_idx);
  puVar2 = (uint32_t *)ke_msg_alloc(0x1c08,0xd,7,0x1c);
  sta_info_tab[iVar1].ctrl_port_state = '\x02';
  *puVar2 = sta_info_tab[iVar1].info.capa_flags;
  memcpy(puVar2 + 1,&sta_info_tab[iVar1].mac_addr,6);
  *(uint8_t *)((int)puVar2 + 0xb) = sta_info_tab[iVar1].staid;
  *(uint8_t *)((int)puVar2 + 10) = sta_info_tab[iVar1].inst_nbr;
  *(int8_t *)(puVar2 + 3) = sta_info_tab[iVar1].rssi;
  puVar2[4] = sta_info_tab[iVar1].tsflo;
  puVar2[5] = sta_info_tab[iVar1].tsfhi;
  *(uint8_t *)(puVar2 + 6) = sta_info_tab[iVar1].data_rate;
  ke_msg_send(puVar2);
  return;
}



void apm_send_mlme(vif_info_tag *vif,uint16_t fctl,mac_addr *ra,cfm_func_ptr *cfm_func,void *env,
                  uint16_t status_code)

{
  uint8_t uVar1;
  txl_buffer_tag *ptVar2;
  uint16_t uVar3;
  txl_frame_desc_tag *frame;
  undefined2 in_register_0000202e;
  uint uVar4;
  int iVar5;
  tx_hw_desc *ptVar6;
  
  _uVar3 = CONCAT22(in_register_0000202e,fctl);
  frame = txl_frame_get((uint)(((vif->bss_info).chan)->band != '\0'),0x100);
  if (frame == (txl_frame_desc_tag *)0x0) {
    return;
  }
  ptVar2 = (frame->txdesc).lmac.buffer;
  *(undefined *)((int)&ptVar2[1].length + 1) = (char)(fctl >> 8);
  *(char *)&ptVar2[1].length = (char)fctl;
  *(undefined *)((int)&ptVar2[1].length + 2) = 0;
  *(undefined *)((int)&ptVar2[1].length + 3) = 0;
  memcpy(&ptVar2[1].lenheader,ra,6);
  memcpy((void *)((int)&ptVar2[1].lenpad + 2),&vif->mac_addr,6);
  memcpy(&ptVar2[1].next,&vif->mac_addr,6);
  uVar4 = (uint)txl_cntrl_env.seqnbr;
  txl_cntrl_env.seqnbr = (uint16_t)((uVar4 + 1) * 0x10000 >> 0x10);
  iVar5 = (uVar4 + 1) * 0x100000;
  *(undefined *)((int)&ptVar2[1].txdesc + 2) = (char)((uint)iVar5 >> 0x10);
  *(undefined *)((int)&ptVar2[1].txdesc + 3) = (char)((uint)iVar5 >> 0x18);
  if (_uVar3 == 0xb0) {
    uVar3 = me_build_authenticate((uint32_t)ptVar2[1].dma_desc,0,2,0,(uint32_t *)0x0);
    _uVar3 = (uint)uVar3;
  }
  else {
    if (_uVar3 == 0xc0) {
      uVar3 = me_build_deauthenticate((uint32_t)ptVar2[1].dma_desc,status_code);
      _uVar3 = (uint)uVar3;
    }
    else {
      if (_uVar3 == 0x50) {
        uVar3 = me_build_probe_rsp((uint32_t)ptVar2[1].dma_desc,vif->index);
        _uVar3 = (uint)uVar3;
      }
      else {
        uVar4 = 0x18;
        if ((_uVar3 & 0xffffffdf) != 0x10) goto LAB_2300d868;
        uVar3 = me_build_associate_rsp
                          ((uint32_t)ptVar2[1].dma_desc,vif->index,status_code,(me_sta_add_req *)env
                          );
        _uVar3 = (uint)uVar3;
      }
    }
  }
  uVar4 = _uVar3 + 0x18 & 0xffff;
LAB_2300d868:
  ptVar6 = (frame->txdesc).lmac.hw_desc;
  (ptVar6->thd).frmlen = uVar4 + 4;
  (ptVar6->thd).field_5 = (ptVar6->thd).field_4 + -1 + uVar4;
  uVar1 = vif->index;
  (frame->txdesc).umac.head_len = '\0';
  (frame->txdesc).umac.tail_len = '\0';
  (frame->txdesc).host.vif_idx = uVar1;
  (frame->txdesc).host.staid = -1;
  (frame->cfm).cfm_func = cfm_func;
  (frame->cfm).env = env;
  txl_frame_push(frame,'\x03');
  return;
}



_Bool apm_embedded_enabled(vif_info_tag *vif)

{
  _Bool _Var1;
  
  if (vif != (vif_info_tag *)0x0) {
    _Var1 = false;
    if (vif->type == '\x02') {
      _Var1 = apm_env.apm_emb_enabled;
    }
    return (_Bool)(_Var1 & 1);
  }
  return apm_env.apm_emb_enabled;
}



void apm_bcn_set(void)

{
  byte bVar1;
  apm_start_req *paVar2;
  _Bool _Var3;
  uint32_t *puVar4;
  undefined3 extraout_var;
  
  paVar2 = apm_env.param;
  puVar4 = (uint32_t *)
           ke_msg_alloc(0x3f,0,7,(uint16_t)
                                 (((uint)(apm_env.param)->bcn_len + 0xc) * 0x10000 >> 0x10));
  *puVar4 = paVar2->bcn_addr;
  *(uint16_t *)(puVar4 + 1) = paVar2->bcn_len;
  *(uint16_t *)((int)puVar4 + 6) = paVar2->tim_oft;
  *(uint8_t *)(puVar4 + 2) = paVar2->tim_len;
  bVar1 = paVar2->vif_idx;
  *(byte *)((int)puVar4 + 9) = bVar1;
  _Var3 = apm_embedded_enabled(vif_info_tab + bVar1);
  if (CONCAT31(extraout_var,_Var3) == 0) {
    memcpy(puVar4 + 3,(void *)&paVar2->field_0xa7,(uint)paVar2->bcn_len);
  }
  else {
    memcpy(puVar4 + 3,apm_env.bcn_buf,(uint)paVar2->bcn_len);
    ke_free(apm_env.bcn_buf);
    apm_env.bcn_buf = (uint8_t *)0x0;
  }
  ke_msg_send(puVar4);
  ke_state_set(7,2);
  return;
}



void apm_probe_req_handler(ushort *param_1)

{
  uint8_t uVar1;
  ushort uVar2;
  int iVar3;
  vif_info_tag *vif;
  uint __n;
  scan_chan_tag *psVar4;
  int iVar5;
  uint uVar6;
  
  if (*(byte *)(param_1 + 4) == 0xff) {
    vif = vif_mgmt_get_first_ap_inf();
    if (vif == (vif_info_tag *)0x0) {
      return;
    }
  }
  else {
    vif = vif_info_tab + *(byte *)(param_1 + 4);
  }
  iVar3 = mac_ie_find(param_1 + 0x1a,(uint)*param_1 - 0x18 & 0xffff,0);
  if ((iVar3 == 0) || (*(byte *)(iVar3 + 1) == 0)) {
    if (apm_env.hidden_ssid != '\0') {
      return;
    }
  }
  else {
    __n = (uint)(vif->bss_info).ssid.length;
    if (__n != (uint)*(byte *)(iVar3 + 1)) {
      return;
    }
    iVar3 = memcmp((void *)(iVar3 + 2),(vif->bss_info).ssid.array,__n);
    if (iVar3 != 0) {
      return;
    }
  }
  iVar3 = mac_ie_find(param_1 + 0x1a,(uint)*param_1 - 0x18 & 0xffff,3);
  if (iVar3 == 0) goto LAB_2300da50;
  psVar4 = (vif->bss_info).chan;
  uVar1 = psVar4->band;
  uVar2 = psVar4->freq;
  __n = (uint)uVar2;
  if (uVar1 == '\0') {
    uVar6 = 0;
    if (((__n - 0x96c & 0xffff) < 0x49) && (uVar6 = 0xe, uVar2 != 0x9b4)) {
      iVar5 = -0x967;
LAB_2300dac6:
      uVar6 = (int)(__n + iVar5) / 5;
    }
  }
  else {
    uVar6 = 0;
    if ((uVar1 == '\x01') && (uVar6 = 0, (__n - 0x138d & 0xffff) < 0x335)) {
      iVar5 = -5000;
      goto LAB_2300dac6;
    }
  }
  if ((uint)*(byte *)(iVar3 + 2) != uVar6) {
    return;
  }
LAB_2300da50:
  apm_send_mlme(vif,0x50,(mac_addr *)(param_1 + 0x13),(cfm_func_ptr *)0x0,(void *)0x0,0);
  return;
}



void apm_auth_handler(rxu_mgt_ind *param)

{
  byte bVar1;
  mac_addr *addr;
  uint8_t sta_idx;
  undefined3 extraout_var;
  
  bVar1 = param->inst_nbr;
  if (bVar1 != 0xff) {
    addr = (mac_addr *)(param[1].sa + 1);
    sta_idx = hal_machw_search_addr(addr);
    if (CONCAT31(extraout_var,sta_idx) != 0xff) {
      apm_sta_delete(sta_idx,(uint8_t *)addr);
    }
    apm_send_mlme(vif_info_tab + bVar1,0xb0,addr,(cfm_func_ptr *)0x0,(void *)0x0,0);
    return;
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

void apm_assoc_req_handler(ushort *param_1,int param_2)

{
  uint8_t uVar1;
  IEEEtypes_Addr_t IVar2;
  uint8_t uVar3;
  ushort *puVar4;
  byte bVar5;
  uint16_t status_code;
  IEEEtypes_MacAddr_t *peerMacAddr;
  int iVar6;
  int iVar7;
  undefined2 extraout_var;
  uint8_t *puVar8;
  int iVar9;
  uint16_t fctl;
  uint __n;
  mac_rateset *pmVar10;
  IEEEtypes_Addr_t *pIVar11;
  IEEEtypes_Addr_t *pIVar12;
  uint uVar13;
  apm *paVar14;
  mac_addr *ra;
  short sVar15;
  uint uVar16;
  Cipher_t aCStack84 [4];
  undefined2 uStack80;
  
  uVar16 = (uint)*(byte *)(param_1 + 4);
  if (*(byte *)(param_1 + 4) == 0xff) {
    return;
  }
  peerMacAddr = (IEEEtypes_MacAddr_t *)ke_msg_alloc(0x1407,5,7,0x58);
  ra = (mac_addr *)(param_1 + 0x13);
  memset(peerMacAddr,0,0x58);
  memcpy(peerMacAddr,ra,6);
  (peerMacAddr + 0xc)[1] = *(IEEEtypes_Addr_t *)(param_1 + 4);
  *(undefined4 *)(peerMacAddr + 0xc + 4) = *(undefined4 *)(param_1 + 8);
  *(undefined4 *)(peerMacAddr + 0xd + 2) = *(undefined4 *)(param_1 + 10);
  (peerMacAddr + 0xe)[0] = *(IEEEtypes_Addr_t *)(param_1 + 0xc);
  (peerMacAddr + 0xe)[1] = *(IEEEtypes_Addr_t *)((int)param_1 + 0x1b);
  if (param_2 == 0) {
    puVar4 = param_1 + 0x1c;
    uVar13 = (uint)*param_1 - 0x1c;
  }
  else {
    puVar4 = param_1 + 0x1f;
    uVar13 = (uint)*param_1 - 0x22;
  }
  status_code = 0x33;
  if (param_1[0x1b] <= vif_info_tab[uVar16].bss_info.max_listen_interval) {
    uVar13 = uVar13 & 0xffff;
    iVar6 = mac_ie_find(puVar4,uVar13,0);
    if (((iVar6 == 0) ||
        (__n = (uint)vif_info_tab[uVar16].bss_info.ssid.length, __n != (uint)*(byte *)(iVar6 + 1)))
       || (iVar6 = memcmp((void *)(iVar6 + 2),vif_info_tab[uVar16].bss_info.ssid.array,__n),
          iVar6 != 0)) {
      status_code = 1;
    }
    else {
      iVar7 = mac_ie_find(puVar4,uVar13,1);
      status_code = 0x12;
      if (iVar7 != 0) {
        __n = (uint)*(byte *)(iVar7 + 1);
        puVar8 = (uint8_t *)(iVar7 + 2);
        uStack80 = uStack80 & 0xff00 | (ushort)*(byte *)(iVar7 + 1);
        pmVar10 = (mac_rateset *)&uStack80;
        while( true ) {
          __n = __n - 1;
          pmVar10 = (mac_rateset *)pmVar10->array;
          if (__n == 0xffffffff) break;
          uVar1 = *puVar8;
          puVar8 = puVar8 + 1;
          pmVar10->length = uVar1;
        }
        iVar7 = mac_ie_find(puVar4,uVar13,0x32);
        if (iVar7 != 0) {
          bVar5 = *(byte *)(iVar7 + 1);
          __n = 0;
          while ((uint)bVar5 != __n) {
            *(undefined *)((int)&uStack80 + (byte)uStack80 + __n + 1) =
                 *(undefined *)(iVar7 + 2 + __n);
            __n = __n + 1;
          }
          uStack80 = uStack80 & 0xff00 | (ushort)(byte)(bVar5 + (byte)uStack80);
        }
        status_code = me_legacy_rate_bitfield_build((mac_rateset *)&uStack80,false);
        (peerMacAddr + 1)[0] = '\0';
        __n = 0;
        while (__n < vif_info_tab[uVar16].bss_info.rate_set.length) {
          iVar7 = (int)&vif_info_tab[uVar16].list_hdr.next + __n;
          bVar5 = me_rate_translate(*(uint8_t *)(iVar7 + 0x3b1));
          if ((CONCAT22(extraout_var,status_code) >> ((uint)bVar5 & 0x1f) & 1U) == 0) {
            if (*(char *)(iVar7 + 0x3b1) < '\0') {
              status_code = 0x12;
              goto fail;
            }
          }
          else {
            bVar5 = (peerMacAddr + 1)[0];
            (peerMacAddr + 1)[(uint)bVar5 + 1] = *(IEEEtypes_Addr_t *)(iVar7 + 0x3b1);
            (peerMacAddr + 1)[0] = bVar5 + 1;
          }
          __n = __n + 1 & 0xff;
        }
        iVar7 = mac_ie_find(puVar4,uVar13,0x2d);
        if (iVar7 != 0) {
          *(undefined2 *)(peerMacAddr + 3 + 2) = *(undefined2 *)(iVar7 + 2);
          pIVar11 = (IEEEtypes_Addr_t *)(iVar7 + 5);
          (peerMacAddr + 3)[4] = *(IEEEtypes_Addr_t *)(iVar7 + 4);
          pIVar12 = peerMacAddr + 3 + 5;
          while (pIVar12 != peerMacAddr + 6 + 3) {
            IVar2 = *pIVar11;
            pIVar11 = pIVar11 + 1;
            *pIVar12 = IVar2;
            pIVar12 = pIVar12 + 1;
          }
          *(undefined2 *)(peerMacAddr + 6 + 4) = *(undefined2 *)(iVar7 + 0x15);
          *(uint *)(peerMacAddr + 7 + 2) = (uint)*(ushort *)(iVar7 + 0x17);
          (peerMacAddr + 8)[0] = *(IEEEtypes_Addr_t *)(iVar7 + 0x1b);
          *(uint *)(peerMacAddr + 10 + 4) = *(uint *)(peerMacAddr + 10 + 4) | 2;
        }
        iVar7 = mac_vsie_find(puVar4,uVar13,&DAT_23075444,4);
        if (iVar7 != 0) {
          bVar5 = *(byte *)(iVar7 + 8);
          *(uint *)(peerMacAddr + 10 + 4) = *(uint *)(peerMacAddr + 10 + 4) | 1;
          (peerMacAddr + 0xb)[4] = bVar5 & 0xf;
          (peerMacAddr + 0xb)[5] = bVar5 >> 4 & 6;
        }
        memset((mac_rateset *)&uStack80,0,2);
        memset(aCStack84,0,1);
        iVar7 = mac_ie_find(puVar4,uVar13,0x30);
        if (iVar7 == 0) {
          iVar7 = mac_vsie_find(puVar4,uVar13,&DAT_2307544c,4);
          if (iVar7 != 0) {
            uStack80 = uStack80 | 8;
            aCStack84[0] = (Cipher_t)((byte)aCStack84[0] | 4);
          }
        }
        else {
          uStack80 = uStack80 | 0x20;
          aCStack84[0] = (Cipher_t)((byte)aCStack84[0] | 8);
        }
        if (uap_conn_info != (cm_ConnectionInfo_t *)0x0) {
          status_code = 0x2e;
          if ((uStack80 & 0x28) == 0) goto fail;
          InitStaKeyInfo(uap_conn_info,(SecurityMode_t *)(mac_rateset *)&uStack80,aCStack84,0,'\0');
          cm_SetPeerAddr(uap_conn_info,(IEEEtypes_MacAddr_t *)0x0,peerMacAddr);
        }
        uVar3 = apm_env.max_sta_supported;
        uVar1 = apm_env.assoc_sta_count;
        *(undefined2 *)(peerMacAddr + 0xb + 2) = 0;
        if (uVar1 < uVar3) {
          paVar14 = &apm_env;
          iVar7 = -1;
          do {
            sVar15 = (short)iVar6;
            if (paVar14->aid_list[0].used == '\0') {
              if (iVar7 == -1) {
                iVar7 = iVar6;
              }
            }
            else {
              iVar9 = memcmp(paVar14->aid_list,ra,6);
              if (iVar9 == 0) {
                apm_env.aid_list[iVar6].used = '\x01';
                goto LAB_2300dee6;
              }
            }
            sVar15 = (short)iVar7;
            iVar6 = iVar6 + 1;
            paVar14 = (apm *)((int)&(paVar14->bss_config).first + 3);
          } while (iVar6 != 10);
          if (iVar7 != -1) {
            memcpy(apm_env.aid_list + iVar7,ra,6);
            apm_env.aid_list[iVar7].used = '\x01';
LAB_2300dee6:
            *(short *)(peerMacAddr + 0xb + 2) = sVar15 + 1;
            apm_env.assoc_sta_count = apm_env.assoc_sta_count + '\x01';
            status_code = 0;
            goto fail;
          }
        }
        status_code = 0x11;
      }
    }
  }
fail:
  fctl = 0x30;
  if (param_2 == 0) {
    fctl = 0x10;
  }
  apm_send_mlme(vif_info_tab + uVar16,fctl,ra,apm_tx_cfm_handler,peerMacAddr,status_code);
  return;
}



void apm_deauth_handler(rxu_mgt_ind *param)

{
  if ((param->inst_nbr != -1) && (param->sta_idx != -1)) {
    apm_sta_delete(param->sta_idx,param[1].sa + 1);
    return;
  }
  return;
}



void apm_disassoc_handler(rxu_mgt_ind *param)

{
  byte bVar1;
  
  bVar1 = param->inst_nbr;
  if ((bVar1 != 0xff) && (param->sta_idx != -1)) {
    apm_sta_delete(param->sta_idx,(uint8_t *)(mac_addr *)(param[1].sa + 1));
    apm_send_mlme(vif_info_tab + bVar1,0xc0,(mac_addr *)(param[1].sa + 1),(cfm_func_ptr *)0x0,
                  (void *)0x0,2);
    return;
  }
  return;
}



void apm_beacon_handler(rxu_mgt_ind *param)

{
  return;
}



void apm_sta_remove(uint8_t vif_idx,uint8_t sta_idx)

{
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  
  apm_send_mlme(vif_info_tab + CONCAT31(in_register_00002029,vif_idx),0xc0,
                &sta_info_tab[CONCAT31(in_register_0000202d,sta_idx)].mac_addr,(cfm_func_ptr *)0x0,
                (void *)0x0,2);
  apm_sta_delete(sta_idx,(uint8_t *)&sta_info_tab[CONCAT31(in_register_0000202d,sta_idx)].mac_addr);
  return;
}



char * cfg_api_element_dump(void *val,CFG_ELEMENT_TYPE type,char *strs)

{
  int iVar1;
  char *pcVar2;
  
  switch((uint)type - 1 & 0xff) {
  case 0:
    if (*(char *)val == '\0') {
      pcVar2 = "False";
    }
    else {
      pcVar2 = "True";
    }
    iVar1 = snprintf(strs,0xf,"%s",pcVar2);
    if (iVar1 < 0) {
      iVar1 = 0;
    }
    strs[iVar1] = '\0';
    pcVar2 = "Boolean";
    break;
  case 1:
    iVar1 = snprintf(strs,0xf,"%d",(int)*(char *)val);
    if (iVar1 < 0) {
      iVar1 = 0;
    }
    strs[iVar1] = '\0';
    pcVar2 = "SINT8";
    break;
  case 2:
    iVar1 = snprintf(strs,0xf,"%u",(uint)*(byte *)val);
    if (iVar1 < 0) {
      iVar1 = 0;
    }
    strs[iVar1] = '\0';
    pcVar2 = "UINT8";
    break;
  case 3:
    iVar1 = snprintf(strs,0xf,"%d",(int)*(short *)val);
    if (iVar1 < 0) {
      iVar1 = 0;
    }
    strs[iVar1] = '\0';
    pcVar2 = "SINT16";
    break;
  case 4:
    iVar1 = snprintf(strs,0xf,"%u",(uint)*(ushort *)val);
    if (iVar1 < 0) {
      iVar1 = 0;
    }
    strs[iVar1] = '\0';
    pcVar2 = "UINT16";
    break;
  case 5:
    iVar1 = snprintf(strs,0xf,"%ld",*(undefined4 *)val);
    if (iVar1 < 0) {
      iVar1 = 0;
    }
    strs[iVar1] = '\0';
    pcVar2 = "SINT32";
    break;
  case 6:
    iVar1 = snprintf(strs,0xf,"%lu",*(undefined4 *)val);
    if (iVar1 < 0) {
      iVar1 = 0;
    }
    strs[iVar1] = '\0';
    pcVar2 = "UINT32";
    break;
  case 7:
    iVar1 = snprintf(strs,0xf,"%lu",*(undefined4 *)val);
    if (iVar1 < 0) {
      iVar1 = 0;
    }
    strs[iVar1] = '\0';
    pcVar2 = "STRING";
    break;
  default:
    return (char *)0x0;
  }
  return pcVar2;
}



int cfg_api_element_general_set(cfg_element_entry *entry,void *arg1,void *arg2)

{
  undefined uVar1;
  undefined2 uVar2;
  uint uVar3;
  undefined4 *puVar4;
  
  printf("  updating element: %s\r\n",entry->name);
  uVar3 = (uint)entry->type - 1 & 0xffff;
  if (6 < uVar3) {
    return 0;
  }
  puVar4 = (undefined4 *)entry->val;
  switch(uVar3) {
  default:
    uVar1 = *(undefined *)arg1;
    break;
  case 1:
    uVar1 = *(undefined *)arg1;
    break;
  case 3:
    uVar2 = *(undefined2 *)arg1;
    goto LAB_2300e1dc;
  case 4:
    uVar2 = *(undefined2 *)arg1;
LAB_2300e1dc:
    *(undefined2 *)puVar4 = uVar2;
    return 0;
  case 5:
  case 6:
    *puVar4 = *(undefined4 *)arg1;
    return 0;
  }
  *(undefined *)puVar4 = uVar1;
  return 0;
}



int cfg_api_element_general_get(cfg_element_entry *entry,void *arg1,void *arg2)

{
  return 0;
}



int cfg_api_element_set(uint32_t task,uint32_t element,uint32_t type,void *arg1,void *arg2)

{
  cfg_element_entry *pcVar1;
  
  pcVar1 = cfg_entrys_mm;
  while (pcVar1 < &_fsymc_info_bloop) {
    if ((pcVar1->task == task) && ((uint)pcVar1->element == element)) {
      if ((uint)pcVar1->type == type) goto LAB_2300e244;
      printf("type %lu NOT matched on element: %lu %lu %u\r\n",type,task,element);
    }
    pcVar1 = pcVar1 + 1;
  }
  if (pcVar1 != (cfg_element_entry *)&_fsymc_info_bloop) {
LAB_2300e244:
    (*pcVar1->set)(pcVar1,arg1,arg2);
  }
  return 0;
}



void co_list_init(co_list *list)

{
  list->first = (co_list_hdr *)0x0;
  list->last = (co_list_hdr *)0x0;
  return;
}



void co_list_push_back(co_list *list,co_list_hdr *list_hdr)

{
  if (list_hdr == (co_list_hdr *)0x0) {
    assert_err("list_hdr != NULL","module",0x47);
  }
  if (list->first == (co_list_hdr *)0x0) {
    list->first = list_hdr;
  }
  else {
    list->last->next = list_hdr;
  }
  list->last = list_hdr;
  list_hdr->next = (co_list_hdr *)0x0;
  return;
}



void co_list_push_front(co_list *list,co_list_hdr *list_hdr)

{
  if (list_hdr == (co_list_hdr *)0x0) {
    assert_err("list_hdr != NULL","module",0x5e);
  }
  if (list->first == (co_list_hdr *)0x0) {
    list->last = list_hdr;
  }
  list_hdr->next = list->first;
  list->first = list_hdr;
  return;
}



co_list_hdr * co_list_pop_front(co_list *list)

{
  co_list_hdr *pcVar1;
  
  pcVar1 = list->first;
  if (pcVar1 != (co_list_hdr *)0x0) {
    list->first = pcVar1->next;
  }
  return pcVar1;
}



// WARNING: Type propagation algorithm not settling

void co_list_extract(co_list *list,co_list_hdr *list_hdr)

{
  co_list_hdr cVar1;
  co_list_hdr cVar2;
  
  if (list == (co_list *)0x0) {
    assert_err("list != NULL","module",0x81);
  }
  cVar1 = (co_list_hdr)list->first;
  if (cVar1 != (co_list_hdr)0x0) {
    if (cVar1 == (co_list_hdr)list_hdr) {
      list->first = list_hdr->next;
    }
    else {
      do {
        cVar2 = cVar1;
        cVar1 = *(co_list_hdr *)cVar2;
        if (cVar1 == (co_list_hdr)0x0) {
          return;
        }
      } while (cVar1 != (co_list_hdr)list_hdr);
      if (list->last == list_hdr) {
        *(co_list_hdr *)&((co_list_hdr *)&list->last)->next = cVar2;
      }
      *(co_list_hdr **)cVar2 = list_hdr->next;
    }
  }
  return;
}



// WARNING: Type propagation algorithm not settling

uint32_t co_list_cnt(co_list *list)

{
  uint32_t uVar1;
  int *piVar2;
  
  piVar2 = (int *)list->first;
  uVar1 = 0;
  while (piVar2 != (int *)0x0) {
    uVar1 = uVar1 + 1;
    piVar2 = (int *)*piVar2;
  }
  return uVar1;
}



// WARNING: Type propagation algorithm not settling

void co_list_insert(co_list *list,co_list_hdr *element,
                   anon_subr__Bool_co_list_hdr_ptr_co_list_hdr_ptr *cmp)

{
  co_list_hdr cVar1;
  co_list_hdr cVar2;
  _Bool _Var3;
  undefined3 extraout_var;
  co_list_hdr cVar4;
  
  cVar1 = (co_list_hdr)list->first;
  cVar4 = (co_list_hdr)(co_list_hdr *)0x0;
  while (cVar2 = cVar1, cVar2 != (co_list_hdr)0x0) {
    _Var3 = (*cmp)(element,(co_list_hdr *)cVar2);
    if (CONCAT31(extraout_var,_Var3) != 0) goto LAB_2300e398;
    cVar1 = *(co_list_hdr *)cVar2;
    cVar4 = cVar2;
  }
  list->last = element;
LAB_2300e398:
  *(co_list_hdr *)&element->next = cVar2;
  if (cVar4 == (co_list_hdr)0x0) {
    list->first = element;
  }
  else {
    ((co_list_hdr *)cVar4)->next = element;
  }
  return;
}



// WARNING: Type propagation algorithm not settling

void co_list_insert_after(co_list *list,co_list_hdr *prev_element,co_list_hdr *element)

{
  co_list_hdr cVar1;
  
  cVar1 = (co_list_hdr)list->first;
  if (prev_element == (co_list_hdr *)0x0) {
    co_list_push_front(list,element);
    return;
  }
  while( true ) {
    if (cVar1 == (co_list_hdr)0x0) {
      return;
    }
    if (cVar1 == (co_list_hdr)prev_element) break;
    cVar1 = *(co_list_hdr *)cVar1;
  }
  element->next = *(co_list_hdr **)cVar1;
  *(co_list_hdr **)cVar1 = element;
  if (element->next != (co_list_hdr *)0x0) {
    return;
  }
  list->last = element;
  return;
}



void co_list_remove(co_list *list,co_list_hdr *prev_element,co_list_hdr *element)

{
  if (list == (co_list *)0x0) {
    assert_err("list != NULL","module",0x168);
  }
  if (prev_element == (co_list_hdr *)0x0) {
    if (element == (co_list_hdr *)0x0) goto LAB_2300e43c;
LAB_2300e456:
    list->first = element->next;
  }
  else {
    if (prev_element->next != element) {
      assert_err("(prev_element == NULL) || (prev_element->next == element)","module",0x169);
    }
    if (element == (co_list_hdr *)0x0) {
LAB_2300e43c:
      assert_err("element != NULL","module",0x16a);
      if (prev_element == (co_list_hdr *)0x0) goto LAB_2300e456;
    }
    prev_element->next = element->next;
    if (list->last == element) {
      list->last = prev_element;
    }
  }
  element->next = (co_list_hdr *)0x0;
  return;
}



uint32_t co_crc32(uint32_t addr,uint32_t len,uint32_t crc)

{
  uint32_t uVar1;
  byte *pbVar2;
  
  uVar1 = 0;
  while (uVar1 != len) {
    pbVar2 = (byte *)(uVar1 + addr);
    uVar1 = uVar1 + 1;
    crc = crc << 8 ^ crc_tab[crc >> 0x18 ^ (uint)*pbVar2];
  }
  return crc;
}


/*
Unable to decompile 'ke_evt_set'
Cause: Exception while decompiling 2300e49c: Decompiler process died

*/

/*
Unable to decompile 'ke_evt_clear'
Cause: Exception while decompiling 2300e4b4: Decompiler process died

*/


void bl_event_handle(int param)

{
  ke_evt_clear(0x40000000);
  bl_main_event_handle();
  return;
}


/*
Unable to decompile 'bl_fw_statistic_dump'
Cause: Exception while decompiling 2300e4e4: Decompiler process died

*/


void bl60x_fw_dump_statistic(int forced)

{
  if (forced != 0) {
    bl_fw_statistic_dump(0);
    return;
  }
  ke_evt_set(0x20);
  return;
}



void ke_evt_schedule(void)

{
  int iVar1;
  evt_ptr_t *peVar2;
  
  while (ke_env.evt_field != 0) {
    iVar1 = __clzsi2(ke_env.evt_field);
    peVar2 = ke_evt_hdlr[iVar1].func;
    if ((0x1a < iVar1) || (peVar2 == (evt_ptr_t *)0x0)) {
      assert_err("(event < KE_EVT_MAX) && ke_evt_hdlr[event].func","module",0xdd);
    }
    (*peVar2)(ke_evt_hdlr[iVar1].param);
  }
  return;
}



void ke_init(void)

{
  ke_env.mblock_first = ke_mem_init();
  ke_env.queue_saved.first = (co_list_hdr *)0x0;
  ke_env.queue_saved.last = (co_list_hdr *)0x0;
  ke_env.queue_sent.first = (co_list_hdr *)0x0;
  ke_env.queue_sent.last = (co_list_hdr *)0x0;
  ke_env.queue_timer.first = (co_list_hdr *)0x0;
  ke_env.queue_timer.last = (co_list_hdr *)0x0;
  ke_evt_clear(0xffffffff);
  return;
}


/*
Unable to decompile 'ke_mem_init'
Cause: Exception while decompiling 2300e5dc: Decompiler process died

*/

/*
Unable to decompile 'ke_malloc'
Cause: Exception while decompiling 2300e602: Decompiler process died

*/

/*
Unable to decompile 'ke_free'
Cause: Exception while decompiling 2300e696: Decompiler process died

*/


void * ke_msg_alloc(ke_msg_id_t id,ke_task_id_t dest_id,ke_task_id_t src_id,uint16_t param_len)

{
  undefined4 *puVar1;
  undefined2 in_register_00002036;
  
  puVar1 = (undefined4 *)ke_malloc(CONCAT22(in_register_00002036,param_len) + 0xc);
  if (puVar1 == (undefined4 *)0x0) {
    assert_err("msg != NULL","module",0x50);
  }
  *(ke_msg_id_t *)(puVar1 + 1) = id;
  *(ke_task_id_t *)((int)puVar1 + 6) = dest_id;
  *(ke_task_id_t *)(puVar1 + 2) = src_id;
  *(uint16_t *)((int)puVar1 + 10) = param_len;
  *puVar1 = 0;
  memset(puVar1 + 3,0,CONCAT22(in_register_00002036,param_len));
  return puVar1 + 3;
}



void ke_msg_send(int param_1)

{
  if (*(byte *)(param_1 + -6) < 0xf) {
    if (*(byte *)(param_1 + -6) < 0xd) {
      co_list_push_back(&ke_env.queue_sent,(co_list_hdr *)(param_1 + -0xc));
      ke_evt_set(0x1000000);
      return;
    }
  }
  else {
    assert_err("id <= TASK_MAX","module",0xb6);
  }
  bl_rx_e2a_handler((void *)(param_1 + -8));
  ke_free((co_list_hdr *)(param_1 + -0xc));
  return;
}



void ke_msg_send_basic(ke_msg_id_t id,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_msg_alloc(id,dest_id,src_id,0);
  ke_msg_send();
  return;
}



void ke_msg_forward_and_change_id
               (void *param_ptr,ke_msg_id_t msg_id,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  *(ke_msg_id_t *)((int)param_ptr + -8) = msg_id;
  *(ke_task_id_t *)((int)param_ptr + -6) = dest_id;
  *(ke_task_id_t *)((int)param_ptr + -4) = src_id;
  ke_msg_send();
  return;
}


/*
Unable to decompile 'ke_msg_free'
Cause: Exception while decompiling 2300e860: Decompiler process died

*/


_Bool cmp_dest_id(co_list_hdr *msg,uint32_t dest_id)

{
  return (_Bool)((uint)*(ushort *)((int)&msg[1].next + 2) == dest_id);
}



_Bool ke_task_local(ke_task_id_t id)

{
  undefined2 in_register_0000202a;
  
  if (0xe < CONCAT22(in_register_0000202a,id)) {
    assert_err("id <= TASK_MAX","module",0xb6);
  }
  return (_Bool)(CONCAT22(in_register_0000202a,id) < 0xd);
}



ke_msg_func_t * ke_handler_search(ke_msg_id_t msg_id,ke_state_handler *state_handler)

{
  undefined2 in_register_0000202a;
  int iVar1;
  
  iVar1 = (uint)state_handler->msg_cnt - 1;
  if (iVar1 == -1) {
    return (ke_msg_func_t *)0x0;
  }
  do {
    if ((uint)state_handler->msg_table[iVar1].id == CONCAT22(in_register_0000202a,msg_id)) {
      if (state_handler->msg_table[iVar1].func == (ke_msg_func_t *)0x0) {
        assert_err("state_handler->msg_table[i].func","module",0xf4);
      }
      return state_handler->msg_table[iVar1].func;
    }
    iVar1 = iVar1 + -1;
  } while (iVar1 != -1);
  return (ke_msg_func_t *)0x0;
}


/*
Unable to decompile 'ke_state_set'
Cause: Exception while decompiling 2300e902: Decompiler process died

*/


ke_state_t ke_state_get(ke_task_id_t id)

{
  uint uVar1;
  _Bool _Var2;
  undefined2 in_register_0000202a;
  undefined3 extraout_var;
  uint uVar3;
  
  uVar1 = (uint)id & 0xff;
  uVar3 = CONCAT22(in_register_0000202a,id) >> 8;
  if (0xd < uVar1) {
    assert_err("type < TASK_MAX","module",0xd7);
  }
  _Var2 = ke_task_local((ke_task_id_t)uVar1);
  if (CONCAT31(extraout_var,_Var2) == 0) {
    assert_err("ke_task_local(type)","module",0xd8);
  }
  if (TASK_DESC[uVar1].idx_max <= uVar3) {
    assert_err("idx < TASK_DESC[type].idx_max","module",0xd9);
  }
  return TASK_DESC[uVar1].state[uVar3];
}


/*
Unable to decompile 'ke_task_schedule'
Cause: Exception while decompiling 2300ea9a: Decompiler process died

*/


int ke_msg_discard(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  return 0;
}



int ke_msg_save(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  return 2;
}


/*
Unable to decompile 'ke_timer_hw_set'
Cause: Exception while decompiling 2300ec08: Decompiler process died

*/


_Bool cmp_abs_time(co_list_hdr *timerA,co_list_hdr *timerB)

{
  return (_Bool)((co_list_hdr *)0x11e1a300 <
                (co_list_hdr *)((int)timerA[2].next - (int)timerB[2].next));
}



_Bool cmp_timer_id(co_list_hdr *timer,uint32_t timer_task)

{
  if ((uint)*(ushort *)&timer[1].next == timer_task >> 0x10) {
    return (_Bool)((uint)*(ushort *)((int)&timer[1].next + 2) == (timer_task & 0xffff));
  }
  return false;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ke_timer_set(ke_msg_id_t timer_id,ke_task_id_t task_id,uint32_t delay)

{
  bool bVar1;
  co_list_hdr *pcVar2;
  undefined2 in_register_0000202a;
  char *condition;
  co_list_hdr *element;
  undefined2 in_register_0000202e;
  int line;
  
  if (delay == 0) {
    line = 0x8c;
    condition = "delay > 0";
  }
  else {
    if (delay < 300000000) goto LAB_2300ecb6;
    line = 0x8d;
    condition = "delay < KE_TIMER_DELAY_MAX";
  }
  assert_err(condition,"module",line);
LAB_2300ecb6:
  bVar1 = false;
  if ((ke_env.queue_timer.first != (co_list_hdr *)0x0) &&
     ((uint)*(ushort *)&ke_env.queue_timer.first[1].next == CONCAT22(in_register_0000202a,timer_id))
     ) {
    bVar1 = (uint)*(ushort *)((int)&ke_env.queue_timer.first[1].next + 2) ==
            CONCAT22(in_register_0000202e,task_id);
  }
  element = ke_queue_extract(&ke_env.queue_timer,cmp_timer_id,
                             CONCAT22(in_register_0000202a,timer_id) << 0x10 |
                             CONCAT22(in_register_0000202e,task_id));
  if (element == (co_list_hdr *)0x0) {
    element = (co_list_hdr *)ke_malloc(0xc);
    if (element == (co_list_hdr *)0x0) {
      assert_err("timer","module",0x9d);
    }
    *(ke_msg_id_t *)&element[1].next = timer_id;
    *(ke_task_id_t *)((int)&element[1].next + 2) = task_id;
  }
  pcVar2 = (co_list_hdr *)(delay + _DAT_44b00120);
  element[2].next = pcVar2;
  co_list_insert(&ke_env.queue_timer,element,cmp_abs_time);
  if ((bVar1) || (ke_env.queue_timer.first == element)) {
    ke_timer_hw_set(ke_env.queue_timer.first);
  }
  if ((int)((int)pcVar2 - _DAT_44b00120) < 0) {
    ke_evt_set(0x4000000);
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ke_timer_clear(ke_msg_id_t timer_id,ke_task_id_t task_id)

{
  co_list_hdr *pcVar1;
  undefined2 in_register_0000202a;
  co_list_hdr *mem_ptr;
  undefined2 in_register_0000202e;
  
  mem_ptr = ke_env.queue_timer.first;
  if (ke_env.queue_timer.first == (co_list_hdr *)0x0) {
    return;
  }
  if (((uint)*(ushort *)&ke_env.queue_timer.first[1].next == CONCAT22(in_register_0000202a,timer_id)
      ) && ((uint)*(ushort *)((int)&ke_env.queue_timer.first[1].next + 2) ==
            CONCAT22(in_register_0000202e,task_id))) {
    co_list_pop_front(&ke_env.queue_timer);
    pcVar1 = ke_env.queue_timer.first;
    ke_timer_hw_set(ke_env.queue_timer.first);
    if ((pcVar1 != (co_list_hdr *)0x0) && ((int)((int)pcVar1[2].next - _DAT_44b00120) < 0)) {
      assert_err("!first || !ke_time_past(first->time)","module",0xd7);
    }
  }
  else {
    mem_ptr = ke_queue_extract(&ke_env.queue_timer,cmp_timer_id,
                               CONCAT22(in_register_0000202a,timer_id) << 0x10 |
                               CONCAT22(in_register_0000202e,task_id));
    if (mem_ptr == (co_list_hdr *)0x0) {
      return;
    }
  }
  ke_free(mem_ptr);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ke_timer_schedule(int dummy)

{
  co_list_hdr *mem_ptr;
  
  while( true ) {
    ke_evt_clear(0x4000000);
    mem_ptr = ke_env.queue_timer.first;
    if (ke_env.queue_timer.first == (co_list_hdr *)0x0) {
      ke_timer_hw_set(0);
      return;
    }
    if ((-1 < (int)ke_env.queue_timer.first[2].next + (-0x32 - _DAT_44b00120)) &&
       (ke_timer_hw_set(ke_env.queue_timer.first), -1 < (int)((int)mem_ptr[2].next - _DAT_44b00120))
       ) break;
    mem_ptr = co_list_pop_front(&ke_env.queue_timer);
    ke_msg_send_basic(*(ke_msg_id_t *)&mem_ptr[1].next,*(ke_task_id_t *)((int)&mem_ptr[1].next + 2),
                      0xff);
    ke_free(mem_ptr);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void bl60x_current_time_us(longlong *time_now)

{
  undefined4 uVar1;
  
  uVar1 = _DAT_44b080a8;
  *(undefined4 *)time_now = _DAT_44b080a4;
  *(undefined4 *)((int)time_now + 4) = uVar1;
  return;
}



byte * mac_ie_find(byte *param_1,int param_2,uint param_3)

{
  byte *pbVar1;
  
  pbVar1 = param_1 + param_2;
  while( true ) {
    if (pbVar1 <= param_1) {
      return (byte *)0;
    }
    if ((uint)*param_1 == param_3) break;
    param_1 = param_1 + (uint)param_1[1] + 2;
  }
  return param_1;
}



char * mac_vsie_find(char *param_1,int param_2,int param_3,int param_4)

{
  int iVar1;
  char *pcVar2;
  int iVar3;
  
  pcVar2 = param_1 + param_2;
  while (param_1 < pcVar2) {
    if (*param_1 == -0x23) {
      iVar3 = 0;
      do {
        if (param_4 == iVar3) {
          return param_1;
        }
        iVar1 = iVar3 + 2;
        iVar3 = iVar3 + 1;
      } while (*(char *)(param_3 + iVar3 + -1) == param_1[iVar1]);
    }
    param_1 = param_1 + (uint)(byte)param_1[1] + 2;
  }
  if (param_1 != pcVar2) {
    puts("--->>> addr != end\r\n");
    return (char *)0;
  }
  return (char *)0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BufferDesc_t *
GetTxEAPOLBuffer(cm_ConnectionInfo_t *connPtr,EAPOL_KeyMsg_Tx_t **ppTxEapol,BufferDesc_t *pBufDesc)

{
  char "GetTxEAPOLBuffer" [17];
  void *pvVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"GetTxEAPOLBuffer");
  if (pBufDesc == (BufferDesc_t *)0x0) {
    pBufDesc = (BufferDesc_t *)ke_malloc(0xc);
    if (pBufDesc != (BufferDesc_t *)0x0) {
      memset(pBufDesc,0,0xc);
      pvVar1 = ke_malloc(0x200);
      pBufDesc->Buffer = pvVar1;
      if (pvVar1 != (void *)0x0) goto LAB_2300efca;
    }
    pBufDesc = (BufferDesc_t *)0x0;
  }
  else {
LAB_2300efca:
    *(cm_ConnectionInfo_t **)&pBufDesc->intf = connPtr;
    *ppTxEapol = (EAPOL_KeyMsg_Tx_t *)pBufDesc->Buffer;
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23075db0);
  }
  return pBufDesc;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void UpdateEAPOLWcbLenAndTransmit(BufferDesc_t *pBufDesc,UINT16 frameLen)

{
  char "UpdateEAPOLWcbLenAndTransmit" [29];
  undefined2 in_register_0000202e;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"UpdateEAPOLWcbLenAndTransmit");
  txl_frame_send_eapol_frame
            (*(uint8_t *)(pBufDesc->intf + 1),(cfm_func_ptr *)0x0,(void *)0x0,
             (uint8_t *)((int)pBufDesc->Buffer + 0xe),CONCAT22(in_register_0000202e,frameLen) + 4);
  ke_free(pBufDesc->Buffer);
  ke_free(pBufDesc);
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23075dd8);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BOOLEAN keyMgmtProcessMsgExt(keyMgmtInfoSta_t *pKeyMgmtInfoSta,EAPOL_KeyMsg_t *pKeyMsg)

{
  char "keyMgmtProcessMsgExt" [21];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"keyMgmtProcessMsgExt");
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23075df8);
  return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void KeyMgmtInitSta(cm_ConnectionInfo_t *connPtr)

{
  char "KeyMgmtInitSta" [15];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmtInitSta");
  KeyMgmtSta_InitSession(&connPtr->suppData->keyMgmtInfoSta);
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23075e10);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void keyMgmtSta_StartSession(cm_ConnectionInfo_t *connPtr,CHAR *pBssid,UINT8 *pStaAddr)

{
  char "keyMgmtSta_StartSession" [24];
  supplicantData *psVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"keyMgmtSta_StartSession");
  psVar1 = connPtr->suppData;
  *(cm_ConnectionInfo_t **)&(psVar1->keyMgmtInfoSta).connPtr = connPtr;
  memcpy(connPtr->suppData->localStaAddr,pStaAddr,6);
  memcpy(connPtr->suppData->localBssid,pBssid,6);
  keyMgmtSta_StartSession_internal(&psVar1->keyMgmtInfoSta,10000000);
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23075ebc);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void init_customApp_mibs(supplicantData_t *suppData)

{
  char "init_customApp_mibs" [20];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"init_customApp_mibs");
  memset(&suppData->customMIB_RSNStats,0,3);
  memset(&suppData->customMIB_RSNConfig,0,0x1c);
  *(ushort *)&(suppData->customMIB_RSNConfig).wpaType =
       (ushort)(suppData->customMIB_RSNConfig).wpaType | 1;
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23075eec);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

UINT8 supplicantIsEnabled(void *connectionPtr)

{
  byte bVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantIsEnabled");
  bVar1 = 0;
  if (*(int *)((int)connectionPtr + 8) != 0) {
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"supplicantIsEnabled");
    bVar1 = (byte)((uint)*(undefined4 *)(*(int *)((int)connectionPtr + 8) + 0x34) >> 8) & 1;
  }
  return (UINT8)bVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void supplicantInitSession
               (cm_ConnectionInfo_t *connPtr,CHAR *pSsid,UINT16 len,CHAR *pBssid,UINT8 *pStaAddr)

{
  char "supplicantInitSession" [22];
  UINT8 UVar1;
  undefined3 extraout_var;
  undefined2 in_register_00002032;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantInitSession");
  UVar1 = supplicantIsEnabled(connPtr);
  if (CONCAT31(extraout_var,UVar1) != 0) {
    KeyMgmtInitSta(connPtr);
    memcpy((connPtr->suppData->hashSsId).SsId,pSsid,CONCAT22(in_register_00002032,len));
    (connPtr->suppData->hashSsId).Len = (IEEEtypes_Len_t)len;
    keyMgmtSta_StartSession(connPtr,pBssid,pStaAddr);
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23075ed4);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void supplicantDisable(cm_ConnectionInfo_t *connPtr)

{
  char "supplicantDisable" [18];
  UINT8 UVar1;
  undefined3 extraout_var;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantDisable");
  UVar1 = supplicantIsEnabled(connPtr);
  if (CONCAT31(extraout_var,UVar1) != 0) {
    mm_timer_clear(&(connPtr->suppData->keyMgmtInfoSta).rsnTimer);
    *(byte *)&connPtr->suppData->customMIB_RSNConfig =
         *(byte *)&connPtr->suppData->customMIB_RSNConfig & 0xfe;
    init_customApp_mibs((supplicantData_t *)connPtr->suppData);
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23075f14);
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void supplicantEnable(void *connectionPtr,int security_mode,void *mcstCipher,void *ucstCipher,
                     _Bool is_pmf_required)

{
  char "supplicantEnable" [17];
  int iVar1;
  UINT8 *__src;
  undefined3 in_register_00002039;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantEnable");
  *(byte *)(*(int *)((int)connectionPtr + 8) + 0x35) =
       *(byte *)(*(int *)((int)connectionPtr + 8) + 0x35) | 1;
  if (security_mode - 4U < 3) {
    *(ushort *)(*(int *)((int)connectionPtr + 8) + 0x36) =
         *(ushort *)(*(int *)((int)connectionPtr + 8) + 0x36) | 0x20;
    *(byte *)(*(int *)((int)connectionPtr + 8) + 0x35) =
         *(byte *)(*(int *)((int)connectionPtr + 8) + 0x35) | 4;
    *(ushort *)(*(int *)((int)connectionPtr + 8) + 0x4e) =
         *(ushort *)(*(int *)((int)connectionPtr + 8) + 0x4e) | 1;
    memcpy((void *)(*(int *)((int)connectionPtr + 8) + 0x38),mcstCipher,1);
    memcpy((void *)(*(int *)((int)connectionPtr + 8) + 0x39),ucstCipher,1);
    if (CONCAT31(in_register_00002039,is_pmf_required) == 0) {
      *(undefined *)(*(int *)((int)connectionPtr + 8) + 0x3d) = 2;
    }
    else {
      *(undefined *)(*(int *)((int)connectionPtr + 8) + 0x3d) = 6;
    }
    iVar1 = *(int *)((int)connectionPtr + 8);
    __src = "";
  }
  else {
    if (security_mode != 3) goto LAB_2300f482;
    *(ushort *)(*(int *)((int)connectionPtr + 8) + 0x36) =
         *(ushort *)(*(int *)((int)connectionPtr + 8) + 0x36) | 8;
    memcpy((void *)(*(int *)((int)connectionPtr + 8) + 0x38),mcstCipher,1);
    memcpy((void *)(*(int *)((int)connectionPtr + 8) + 0x39),ucstCipher,1);
    *(undefined *)(*(int *)((int)connectionPtr + 8) + 0x3d) = 2;
    iVar1 = *(int *)((int)connectionPtr + 8);
    __src = "";
  }
  memcpy((void *)(iVar1 + 0x3a),__src,3);
LAB_2300f482:
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23075f28);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

UINT16 keyMgmtFormatWpaRsnIe
                 (cm_ConnectionInfo_t *connPtr,UINT8 *pos,IEEEtypes_MacAddr_t *pBssid,
                 IEEEtypes_MacAddr_t *pStaAddr,UINT8 *pPmkid,BOOLEAN addPmkid)

{
  char "keyMgmtFormatWpaRsnIe" [22];
  uint16_t uVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"keyMgmtFormatWpaRsnIe");
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23075f3c);
  uVar1 = mm_get_rsn_wpa_ie(connPtr->staId,pos);
  return (UINT16)uVar1;
}



// WARNING: Variable defined which should be unmapped: pTxEapol
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

Status_e GeneratePWKMsg2(BufferDesc_t *pEAPoLBufDesc,UINT8 *pSNonce,UINT8 *pEAPOLMICKey,
                        UINT8 forceKeyDescVersion)

{
  EAPOL_KeyMsg_Tx_t *pEVar1;
  char "GeneratePWKMsg2" [16];
  cm_ConnectionInfo_t *connPtr;
  Status_e SVar2;
  UINT16 frameLen;
  BufferDesc_t *pBufDesc;
  EAPOL_KeyMsg_t *pRxEapol;
  EAPOL_KeyMsg_Tx_t *pEStack36;
  EAPOL_KeyMsg_Tx_t *pTxEapol;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"GeneratePWKMsg2");
  connPtr = (cm_ConnectionInfo_t *)pEAPoLBufDesc->intf;
  pRxEapol = (EAPOL_KeyMsg_t *)pEAPoLBufDesc->Buffer;
  pBufDesc = GetTxEAPOLBuffer(connPtr,&pEStack36,(BufferDesc_t *)0x0);
  if (pBufDesc == (BufferDesc_t *)0x0) {
    SVar2 = FAIL;
  }
  else {
    KeyMgmtSta_PrepareEAPOLFrame
              (pEStack36,pRxEapol,(IEEEtypes_MacAddr_t *)connPtr->suppData->localBssid,
               (IEEEtypes_MacAddr_t *)connPtr->suppData->localStaAddr,pSNonce);
    pEVar1 = pEStack36;
    if ((pEStack36->keyMsg).desc_type != '\x01') {
      frameLen = keyMgmtFormatWpaRsnIe
                           (connPtr,(pEStack36->keyMsg).key_data,
                            (IEEEtypes_MacAddr_t *)connPtr->suppData->localBssid,
                            (IEEEtypes_MacAddr_t *)connPtr->suppData->localStaAddr,(UINT8 *)0x0,0);
      *(char *)&(pEVar1->keyMsg).key_material_len = (char)frameLen;
      *(undefined *)((int)&(pEVar1->keyMsg).key_material_len + 1) = (char)(frameLen >> 8);
    }
    frameLen = KeyMgmtSta_PopulateEAPOLLengthMic(pEStack36,pEAPOLMICKey,'\x01',forceKeyDescVersion);
    UpdateEAPOLWcbLenAndTransmit(pBufDesc,frameLen);
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23075e20);
    SVar2 = FW_SUCCESS;
  }
  return SVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BOOLEAN KeyMgmtStaHsk_Recvd_PWKMsg1
                  (BufferDesc_t *pEAPoLBufDesc,IEEEtypes_MacAddr_t *sa,IEEEtypes_MacAddr_t *da)

{
  char "KeyMgmtStaHsk_Recvd_PWKMsg1" [28];
  int iVar1;
  int iVar2;
  Status_e SVar3;
  EAPOL_KeyMsg_t *pEVar4;
  BOOLEAN BVar5;
  UINT8 *pPMK;
  undefined3 extraout_var;
  int iVar6;
  keyMgmtInfoSta_t *pKeyMgmtInfoSta;
  BOOLEAN in_fa0;
  
  iVar6 = pEAPoLBufDesc->intf;
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmtStaHsk_Recvd_PWKMsg1");
  iVar1 = *(int *)(iVar6 + 8);
  pKeyMgmtInfoSta = (keyMgmtInfoSta_t *)(iVar1 + 0x54);
  pEVar4 = GetKeyMsgNonceFromEAPOL(pEAPoLBufDesc,pKeyMgmtInfoSta);
  if (pEVar4 == (EAPOL_KeyMsg_t *)0x0) {
LAB_2300f69e:
    iVar2 = 0;
  }
  else {
    iVar2 = supplicantAkmIsWpaWpa2((AkmSuite_t *)(*(int *)(iVar6 + 8) + 0x3a));
    if (iVar2 != 0) {
      BVar5 = supplicantAkmIsWpaWpa2Psk((AkmSuite_t *)(*(int *)(iVar6 + 8) + 0x3a));
      if ((BVar5 == 0) ||
         (pPMK = pmkCacheFindPSK((UINT8 *)(*(int *)(iVar6 + 8) + 6),
                                 *(UINT8 *)(*(int *)(iVar6 + 8) + 5)), pPMK == (UINT8 *)0x0))
      goto LAB_2300f69e;
      supplicantAkmUsesKdf((AkmSuite_t *)(*(int *)(iVar6 + 8) + 0x3a));
      KeyMgmtSta_DeriveKeys
                (pPMK,da,sa,(UINT8 *)pKeyMgmtInfoSta,(UINT8 *)(iVar1 + 0x74),(UINT8 *)(iVar1 + 0x94)
                 ,(UINT8 *)(iVar1 + 0xa4),(KeyData_t *)(iVar1 + 0x128),in_fa0);
      iVar2 = 1;
    }
    SVar3 = GeneratePWKMsg2(pEAPoLBufDesc,(UINT8 *)(iVar1 + 0x74),(UINT8 *)(iVar1 + 0x94),'\0');
    if (CONCAT31(extraout_var,SVar3) == 0) {
      if (iVar2 == 1) {
        updateApReplayCounter(pKeyMgmtInfoSta,(UINT8 *)pEVar4->replay_cnt);
        *(undefined4 *)(iVar1 + 0xcc) = 0;
      }
    }
    else {
      iVar2 = 0;
    }
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23075e50);
  }
  return iVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void supplicantInit(supplicantData_t *suppData)

{
  char "supplicantInit" [15];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantInit");
  init_customApp_mibs(suppData);
  memset(&suppData->currParams,0xff,4);
  memset(&suppData->keyMgmtInfoSta,0,0x144);
  (suppData->keyMgmtInfoSta).sta_MIC_Error.disableStaAsso = 0;
  (suppData->keyMgmtInfoSta).sta_MIC_Error.MICCounterMeasureEnabled = 1;
  (suppData->keyMgmtInfoSta).sta_MIC_Error.status = NO_MIC_FAILURE;
  KeyMgmtResetCounter(&suppData->keyMgmtInfoSta);
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23075f54);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void allocSupplicantData(void *connectionPtr)

{
  char "allocSupplicantData" [20];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"allocSupplicantData");
  if (*(int *)((int)connectionPtr + 8) == 0) {
    if ((*(char *)connectionPtr == '\0') && (keyMgmt_SuppData[0].inUse == 0)) {
      keyMgmt_SuppData[0].inUse = 1;
      supplicantInit(keyMgmt_SuppData);
      *(undefined4 *)((int)connectionPtr + 8) = 0x4201153c;
    }
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23075dc4);
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

UINT16 keyMgmtGetKeySize(cm_ConnectionInfo_t *connPtr,UINT8 isPairwise)

{
  char "keyMgmtGetKeySize" [18];
  UINT16 UVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"keyMgmtGetKeySize");
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23075f64);
  UVar1 = keyMgmtGetKeySize_internal(&connPtr->suppData->customMIB_RSNConfig,isPairwise);
  return UVar1;
}



// WARNING: Variable defined which should be unmapped: key_add_req
// WARNING: Could not reconcile some variable overlaps

uint8_t add_key_to_mac(cm_ConnectionInfo_t *connPtr,UINT8 pairwise)

{
  uint32_t uVar1;
  uint32_t uVar2;
  size_t __n;
  uint8_t uVar3;
  UINT16 UVar4;
  apInfo_t *paVar5;
  undefined3 in_register_0000202d;
  int iVar6;
  KeyData_t *__src;
  byte bStack60;
  byte bStack59;
  mm_key_add_req key_add_req;
  
  iVar6 = CONCAT31(in_register_0000202d,pairwise);
  __n = 0x10;
  if (connPtr->conType == '\0') {
    UVar4 = keyMgmtGetKeySize(connPtr,pairwise);
    __n = (uint)UVar4 & 0xff;
  }
  memset(&bStack60,0,0x2c);
  key_add_req.key.array[7]._3_1_ = iVar6 != 0;
  key_add_req.key.array[7]._1_1_ = connPtr->instNbr;
  if (iVar6 == 0) {
    bStack59 = 0xff;
    if (connPtr->conType == '\0') {
      __src = &(connPtr->suppData->keyMgmtInfoSta).GRKey;
      bStack60 = (byte)(connPtr->suppData->keyMgmtInfoSta).GRKey.KeyIndex;
    }
    else {
      paVar5 = cm_GetApInfo(connPtr);
      __src = &(paVar5->bssData).grpKeyData;
      bStack60 = (byte)(paVar5->bssData).grpKeyData.KeyIndex;
    }
  }
  else {
    bStack59 = connPtr->staId;
    if (connPtr->conType == '\0') {
      __src = &(connPtr->suppData->keyMgmtInfoSta).PWKey;
    }
    else {
      __src = (KeyData_t *)((connPtr->TxRxCipherKeyBuf).cipher_key.ckd + 0x20);
    }
  }
  memcpy(&key_add_req.key,__src,__n);
  uVar2 = key_add_req.key.array[6];
  uVar1 = key_add_req.key.array[3];
  key_add_req.key_idx = (uint8_t)__n;
  if (__n == 0x10) {
    key_add_req.key.array[7]._0_1_ = 2;
  }
  else {
    if (__n == 0x20) {
      key_add_req.key.array[7]._0_1_ = 1;
      if (iVar6 != 0) {
        key_add_req.key.array[3] = key_add_req.key.array[5];
        key_add_req.key.array[5] = uVar1;
        key_add_req.key.array[6] = key_add_req.key.array[4];
        key_add_req.key.array[4] = uVar2;
      }
    }
    else {
      if (__n == 0xd) {
        key_add_req.key.array[7]._0_1_ = 3;
      }
      else {
        if (__n == 5) {
          key_add_req.key.array[7]._0_1_ = 0;
        }
        else {
          assert_err("0","module",0x783);
        }
      }
    }
  }
  printf("set key:sta_idx:%d, inst_nbr:%d, key_idx:%d,cipher_suite:%d,key_len:%d\r\n",(uint)bStack59
         ,(uint)key_add_req.key.array[7]._1_1_,(uint)bStack60,(uint)(byte)key_add_req.key.array[7],
         (uint)key_add_req.key_idx);
  uVar3 = mm_sec_machwkey_wr((mm_key_add_req *)&bStack60);
  return uVar3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BufferReturnNotify_t * keyMgmtKeyGroupTxDone(void)

{
  cm_ConnectionInfo_t *connPtr;
  uint8_t uVar1;
  cm_ConnectionInfo_t **in_a0;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"keyMgmtKeyGroupTxDone");
  connPtr = *in_a0;
  if (connPtr->gtkHwKeyId != -1) {
    mm_sec_machwkey_del(connPtr->gtkHwKeyId);
  }
  uVar1 = add_key_to_mac(connPtr,'\0');
  connPtr->gtkHwKeyId = uVar1;
  (connPtr->suppData->keyMgmtInfoSta).RSNDataTrafficEnabled = 1;
  if ((connPtr->suppData->keyMgmtInfoSta).RSNSecured == 0) {
    (connPtr->suppData->keyMgmtInfoSta).RSNSecured = 1;
    sm_handle_supplicant_result(connPtr->staId,0);
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"keyMgmtKeyGroupTxDone");
  return (BufferReturnNotify_t *)0x0;
}



// WARNING: Variable defined which should be unmapped: pTxEapol
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

Status_e GenerateGrpMsg2(BufferDesc_t *pEAPoLBufDesc,keyMgmtInfoSta_t *pKeyMgmtInfoSta)

{
  char "GenerateGrpMsg2" [16];
  UINT16 frameLen_00;
  BufferDesc_t *pBufDesc;
  supplicantData *psVar1;
  cm_ConnectionInfo_t *connPtr;
  EAPOL_KeyMsg_t *pRxEapol;
  UINT16 frameLen;
  EAPOL_KeyMsg_Tx_t *pEStack36;
  EAPOL_KeyMsg_Tx_t *pTxEapol;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"GenerateGrpMsg2");
  connPtr = (cm_ConnectionInfo_t *)pEAPoLBufDesc->intf;
  pRxEapol = (EAPOL_KeyMsg_t *)pEAPoLBufDesc->Buffer;
  pBufDesc = GetTxEAPOLBuffer(connPtr,&pEStack36,(BufferDesc_t *)0x0);
  if (pBufDesc != (BufferDesc_t *)0x0) {
    psVar1 = connPtr->suppData;
    KeyMgmtSta_PrepareEAPOLFrame
              (pEStack36,pRxEapol,(IEEEtypes_MacAddr_t *)psVar1->localBssid,
               (IEEEtypes_MacAddr_t *)psVar1->localStaAddr,(UINT8 *)0x0);
    frameLen_00 = KeyMgmtSta_PopulateEAPOLLengthMic
                            (pEStack36,pKeyMgmtInfoSta->EAPOL_MIC_Key,'\x01','\0');
    keyMgmtKeyGroupTxDone();
    UpdateEAPOLWcbLenAndTransmit(pBufDesc,frameLen_00);
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23075e40);
  }
  return (Status_e)(pBufDesc == (BufferDesc_t *)0x0);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

EAPOL_KeyMsg_t * KeyMgmtStaHsk_Recvd_GrpMsg1(BufferDesc_t *pEAPoLBufDesc)

{
  char "KeyMgmtStaHsk_Recvd_GrpMsg1" [28];
  keyMgmtInfoSta_t *pKeyMgmtInfoSta;
  Status_e SVar1;
  EAPOL_KeyMsg_t *pEVar2;
  undefined3 extraout_var;
  
  pKeyMgmtInfoSta = (keyMgmtInfoSta_t *)(*(int *)(pEAPoLBufDesc->intf + 8) + 0x54);
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmtStaHsk_Recvd_GrpMsg1");
  pEVar2 = ProcessRxEAPOL_GrpMsg1(pEAPoLBufDesc,pKeyMgmtInfoSta);
  if ((pEVar2 == (EAPOL_KeyMsg_t *)0x0) ||
     (SVar1 = GenerateGrpMsg2(pEAPoLBufDesc,pKeyMgmtInfoSta), CONCAT31(extraout_var,SVar1) != 0)) {
    pEVar2 = (EAPOL_KeyMsg_t *)0x0;
  }
  else {
    updateApReplayCounter(pKeyMgmtInfoSta,(UINT8 *)pEVar2->replay_cnt);
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23075e88);
  }
  return pEVar2;
}



// WARNING: Variable defined which should be unmapped: key_add_req
// WARNING: Could not reconcile some variable overlaps

uint8_t add_mfp_key_to_mac(cm_ConnectionInfo_t *connPtr,UINT8 pairwise)

{
  uint8_t uVar1;
  UINT16 UVar2;
  undefined3 extraout_var;
  undefined3 in_register_0000202d;
  KeyData_t *__src;
  undefined2 uStack60;
  mm_key_add_req key_add_req;
  
  UVar2 = keyMgmtGetKeySize(connPtr,pairwise);
  memset(&uStack60,0,0x2c);
  key_add_req.key.array[7]._1_1_ = connPtr->instNbr;
  key_add_req.key_idx = (uint8_t)((uint)UVar2 & 0xff);
  key_add_req.key.array[7]._0_1_ = 5;
  uStack60 = 0xff04;
  if (CONCAT31(in_register_0000202d,pairwise) == 0) {
    if (connPtr->conType != '\0') goto LAB_2300fc4a;
    __src = &(connPtr->suppData->keyMgmtInfoSta).GRKey;
  }
  else {
    if (connPtr->conType != '\0') goto LAB_2300fc4a;
    __src = &(connPtr->suppData->keyMgmtInfoSta).PWKey;
  }
  memcpy(&key_add_req.key,__src,(uint)UVar2 & 0xff);
LAB_2300fc4a:
  printf("set mfp key:sta_idx:%d, inst_nbr:%d, key_idx:%d,cipher_suite:%d,key_len:%d\r\n",
         (uint)uStack60._1_1_,(uint)key_add_req.key.array[7]._1_1_,(uint)(byte)uStack60,
         (uint)(byte)key_add_req.key.array[7],(uint)key_add_req.key_idx);
  uVar1 = mm_sec_machwkey_wr((mm_key_add_req *)&uStack60);
  printf("mfp hw id: %d\n",CONCAT31(extraout_var,uVar1));
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void keyMgmtPlumbPairwiseKey(cm_ConnectionInfo_t *connPtr)

{
  char "keyMgmtPlumbPairwiseKey" [24];
  uint8_t uVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"keyMgmtPlumbPairwiseKey");
  memcpy(&(connPtr->suppData->keyMgmtInfoSta).PWKey,&(connPtr->suppData->keyMgmtInfoSta).newPWKey,
         0x28);
  uVar1 = add_key_to_mac(connPtr,'\x01');
  connPtr->ptkHwKeyId = uVar1;
  if ((connPtr->suppData->customMIB_RSNConfig).AKM.akmType == AKM_SHA256_PSK) {
    uVar1 = add_mfp_key_to_mac(connPtr,'\x01');
    connPtr->mfpHwKeyId = uVar1;
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23075f78);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BufferReturnNotify_t * keyMgmtKeyPairwiseTxDone(void)

{
  cm_ConnectionInfo_t **in_a0;
  cm_ConnectionInfo_t *connPtr;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"keyMgmtKeyPairwiseTxDone");
  connPtr = *in_a0;
  keyMgmtPlumbPairwiseKey(connPtr);
  (connPtr->suppData->keyMgmtInfoSta).pwkHandshakeComplete = 1;
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"keyMgmtKeyPairwiseTxDone");
  return (BufferReturnNotify_t *)0x0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

Status_e GeneratePWKMsg4(BufferDesc_t *pEAPoLBufDesc,keyMgmtInfoSta_t *pKeyMgmtInfoSta,
                        BOOLEAN groupKeyReceived)

{
  char "GeneratePWKMsg4" [16];
  Status_e SVar1;
  UINT16 frameLen;
  BufferDesc_t *pBufDesc;
  supplicantData *psVar2;
  cm_ConnectionInfo_t *connPtr;
  EAPOL_KeyMsg_t *pRxEapol;
  EAPOL_KeyMsg_Tx_t *pEStack52;
  EAPOL_KeyMsg_Tx_t *pTxEapol;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"GeneratePWKMsg4");
  connPtr = (cm_ConnectionInfo_t *)pEAPoLBufDesc->intf;
  pRxEapol = (EAPOL_KeyMsg_t *)pEAPoLBufDesc->Buffer;
  pBufDesc = GetTxEAPOLBuffer(connPtr,&pEStack52,(BufferDesc_t *)0x0);
  if (pBufDesc == (BufferDesc_t *)0x0) {
    SVar1 = FAIL;
  }
  else {
    psVar2 = connPtr->suppData;
    KeyMgmtSta_PrepareEAPOLFrame
              (pEStack52,pRxEapol,(IEEEtypes_MacAddr_t *)psVar2->localBssid,
               (IEEEtypes_MacAddr_t *)psVar2->localStaAddr,(UINT8 *)0x0);
    frameLen = KeyMgmtSta_PopulateEAPOLLengthMic
                         (pEStack52,pKeyMgmtInfoSta->EAPOL_MIC_Key,'\x01','\0');
    UpdateEAPOLWcbLenAndTransmit(pBufDesc,frameLen);
    if (groupKeyReceived == 0) {
      keyMgmtKeyPairwiseTxDone();
    }
    else {
      dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"keyMgmtKeyPairAndGroupTxDone");
      keyMgmtKeyPairwiseTxDone();
      keyMgmtKeyGroupTxDone();
      dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"keyMgmtKeyPairAndGroupTxDone");
    }
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23075e30);
    SVar1 = FW_SUCCESS;
  }
  return SVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

EAPOL_KeyMsg_t * KeyMgmtStaHsk_Recvd_PWKMsg3(BufferDesc_t *pEAPoLBufDesc)

{
  char "KeyMgmtStaHsk_Recvd_PWKMsg3" [28];
  int iVar1;
  keyMgmtInfoSta_t *pKeyMgmtInfoSta;
  Status_e SVar2;
  EAPOL_KeyMsg_t *pEVar3;
  undefined3 extraout_var;
  
  iVar1 = pEAPoLBufDesc->intf;
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmtStaHsk_Recvd_PWKMsg3");
  pKeyMgmtInfoSta = (keyMgmtInfoSta_t *)(*(int *)(iVar1 + 8) + 0x54);
  pEVar3 = ProcessRxEAPOL_PwkMsg3(pEAPoLBufDesc,pKeyMgmtInfoSta);
  if ((pEVar3 != (EAPOL_KeyMsg_t *)0x0) &&
     (SVar2 = GeneratePWKMsg4(pEAPoLBufDesc,pKeyMgmtInfoSta,(uint)(pEVar3->desc_type == '\x02')),
     CONCAT31(extraout_var,SVar2) == 0)) {
    updateApReplayCounter(pKeyMgmtInfoSta,(UINT8 *)pEVar3->replay_cnt);
    pEVar3 = (EAPOL_KeyMsg_t *)0x0;
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23075e6c);
  }
  return pEVar3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ProcessKeyMgmtDataSta(BufferDesc_t *pBufDesc,IEEEtypes_MacAddr_t *sa,IEEEtypes_MacAddr_t *da)

{
  char "ProcessKeyMgmtDataSta" [22];
  void *pvVar1;
  
  pvVar1 = pBufDesc->Buffer;
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"ProcessKeyMgmtDataSta");
  if ((*(byte *)((int)pvVar1 + 6) & 8) == 0) {
    KeyMgmtStaHsk_Recvd_GrpMsg1(pBufDesc);
  }
  else {
    if ((*(byte *)((int)pvVar1 + 5) & 1) == 0) {
      KeyMgmtStaHsk_Recvd_PWKMsg1(pBufDesc,sa,da);
    }
    else {
      KeyMgmtStaHsk_Recvd_PWKMsg3(pBufDesc);
    }
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23075ea4);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

UINT8 ProcessEAPoLPkt(BufferDesc_t *bufDesc,IEEEtypes_MacAddr_t *sa,IEEEtypes_MacAddr_t *da)

{
  char "ProcessEAPoLPkt" [16];
  UINT8 UVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"ProcessEAPoLPkt");
  if (*(char *)((int)bufDesc->Buffer + 1) == '\x03') {
    dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"ProcessEAPoLKeyPkt");
    if (*(char *)bufDesc->intf == '\x02') {
      ProcessKeyMgmtDataAp(bufDesc);
    }
    else {
      ProcessKeyMgmtDataSta(bufDesc,sa,da);
    }
    UVar1 = '\x01';
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"ProcessEAPoLKeyPkt");
  }
  else {
    UVar1 = '\0';
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23075da0);
  return UVar1;
}



uchar process_rsn_ie(uint8_t *rsn_ie,Cipher_t *mcstCipher,Cipher_t *ucstCipher,
                    _Bool *is_pmf_required,SecurityMode_t *security_mode,_Bool wpa2_prefered)

{
  int iVar1;
  UINT8 *__s2;
  Cipher_t CVar2;
  undefined3 in_register_0000203d;
  uint uVar3;
  uint8_t *__s1;
  uint8_t *__dest;
  ushort auStack66 [2];
  uint16_t akmp_count;
  
  __s1 = rsn_ie + 0xe;
  __dest = rsn_ie + 10;
  if (*(short *)(rsn_ie + 8) == 2) {
    rsn_ie[9] = '\0';
    rsn_ie[1] = rsn_ie[1] + -4;
    rsn_ie[8] = '\x01';
    iVar1 = memcmp(__s1,"",4);
    if (iVar1 == 0) {
      memcpy(__dest,__s1,4);
    }
    memcpy(__s1,rsn_ie + 0x12,0xc);
  }
  memcpy(auStack66,__s1,2);
  uVar3 = 0;
  while (uVar3 < auStack66[0]) {
    iVar1 = memcmp(__dest + (uVar3 + 1) * 4 + 2,"",4);
    if (iVar1 == 0) {
      *(byte *)security_mode = *(byte *)security_mode | 0x20;
    }
    else {
      iVar1 = memcmp(__dest + (uVar3 + 1) * 4 + 2,"",4);
      if (iVar1 == 0) {
        *(byte *)&security_mode->field_0x1 = *(byte *)&security_mode->field_0x1 | 1;
      }
    }
    uVar3 = uVar3 + 1 & 0xff;
  }
  if (auStack66[0] == 2) {
    rsn_ie[1] = '\x14';
    auStack66[0] = 1;
    memcpy(__s1,auStack66,2);
    __s1 = rsn_ie + 0x14;
    if (CONCAT31(in_register_0000203d,wpa2_prefered) == 0) {
      __s2 = "";
    }
    else {
      __s2 = "";
    }
    iVar1 = memcmp(__s1,__s2,4);
    if (iVar1 == 0) {
      memcpy(rsn_ie + 0x10,__s1,6);
    }
    memcpy(__s1,rsn_ie + 0x18,2);
  }
  if (((*(byte *)&security_mode->field_0x1 & 1) != 0) &&
     (((*(byte *)security_mode & 0x20) == 0 || (CONCAT31(in_register_0000203d,wpa2_prefered) == 0)))
     ) {
    *is_pmf_required = true;
    rsn_ie[0x14] = -0x40;
    rsn_ie[0x16] = '\0';
    rsn_ie[1] = rsn_ie[1] + '\x02';
    rsn_ie[0x17] = '\0';
    memcpy(rsn_ie + 0x18,"",4);
    rsn_ie[1] = rsn_ie[1] + '\x04';
  }
  iVar1 = memcmp(__dest,"",4);
  if (iVar1 == 0) {
    CVar2 = (Cipher_t)((byte)*ucstCipher | 8);
LAB_230101f8:
    *ucstCipher = CVar2;
  }
  else {
    iVar1 = memcmp(__dest,"",4);
    if (iVar1 == 0) {
      CVar2 = (Cipher_t)((byte)*ucstCipher | 4);
      goto LAB_230101f8;
    }
  }
  __s1 = rsn_ie + 4;
  iVar1 = memcmp(__s1,"",4);
  if (iVar1 == 0) {
    CVar2 = (Cipher_t)((byte)*mcstCipher | 8);
  }
  else {
    iVar1 = memcmp(__s1,"",4);
    if (iVar1 == 0) {
      CVar2 = (Cipher_t)((byte)*mcstCipher | 4);
    }
    else {
      iVar1 = memcmp(__s1,"",4);
      if (iVar1 == 0) {
        CVar2 = (Cipher_t)((byte)*mcstCipher | 2);
      }
      else {
        iVar1 = memcmp(__s1,"",4);
        if (iVar1 != 0) goto LAB_2301021a;
        CVar2 = (Cipher_t)((byte)*mcstCipher | 1);
      }
    }
  }
  *mcstCipher = CVar2;
LAB_2301021a:
  return (uchar)(rsn_ie[1] + '\x02');
}



uchar process_wpa_ie(uint8_t *wpa_ie,Cipher_t *mcstCipher,Cipher_t *ucstCipher)

{
  int iVar1;
  Cipher_t CVar2;
  uint8_t *__dest;
  uint8_t *__s1;
  
  __dest = wpa_ie + 0xe;
  if (*(short *)(wpa_ie + 0xc) == 2) {
    wpa_ie[1] = '\x16';
    __s1 = wpa_ie + 0x12;
    wpa_ie[0xc] = '\x01';
    wpa_ie[0xd] = '\0';
    iVar1 = memcmp(__s1,"",4);
    if (iVar1 == 0) {
      memcpy(__dest,__s1,4);
    }
    memcpy(__s1,wpa_ie + 0x16,8);
  }
  iVar1 = memcmp(__dest,"",4);
  if (iVar1 == 0) {
    CVar2 = (Cipher_t)((byte)*ucstCipher | 8);
LAB_23010382:
    *ucstCipher = CVar2;
  }
  else {
    iVar1 = memcmp(__dest,"",4);
    if (iVar1 == 0) {
      CVar2 = (Cipher_t)((byte)*ucstCipher | 4);
      goto LAB_23010382;
    }
  }
  __dest = wpa_ie + 8;
  iVar1 = memcmp(__dest,"",4);
  if (iVar1 == 0) {
    CVar2 = (Cipher_t)((byte)*mcstCipher | 8);
  }
  else {
    iVar1 = memcmp(__dest,"",4);
    if (iVar1 == 0) {
      CVar2 = (Cipher_t)((byte)*mcstCipher | 4);
    }
    else {
      iVar1 = memcmp(__dest,"",4);
      if (iVar1 == 0) {
        CVar2 = (Cipher_t)((byte)*mcstCipher | 2);
      }
      else {
        iVar1 = memcmp(__dest,"",4);
        if (iVar1 != 0) goto LAB_230103a4;
        CVar2 = (Cipher_t)((byte)*mcstCipher | 1);
      }
    }
  }
  *mcstCipher = CVar2;
LAB_230103a4:
  return (uchar)(wpa_ie[1] + '\x02');
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void keyMgmtStaRsnSecuredTimeoutHandler(void *env)

{
  char "keyMgmtStaRsnSecuredTimeoutHandler" [35];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"keyMgmtStaRsnSecuredTimeoutHandler");
  if ((env != (void *)0x0) && (*(int *)((int)env + 0x78) == 0)) {
    sm_handle_supplicant_result(*(uint8_t *)(*(int *)((int)env + 0x118) + 1),0xf);
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x230762f8);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void supplicantGenerateRand(UINT8 *dataOut,UINT32 length)

{
  char "supplicantGenerateRand" [23];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantGenerateRand");
  bl_rand_stream(dataOut,length);
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x230760a8);
  return;
}



void ComputeEAPOL_MIC(EAPOL_KeyMsg_t *pKeyMsg,UINT16 data_length,UINT8 *MIC_Key,UINT8 MIC_Key_length
                     ,UINT8 micKeyDescVersion)

{
  undefined2 in_register_0000202e;
  undefined3 in_register_00002035;
  undefined3 in_register_00002039;
  uint uVar1;
  uchar *output;
  int iStack24;
  int len;
  UINT8 *pMicData;
  
  uVar1 = CONCAT31(in_register_00002039,micKeyDescVersion);
  iStack24 = CONCAT22(in_register_0000202e,data_length);
  if (uVar1 == 0) {
    uVar1 = (uint)*(byte *)&(pKeyMsg->key_info).field_0x1 & 7;
  }
  output = pKeyMsg->key_MIC;
  len = (int)pKeyMsg;
  if (uVar1 == 1) {
    Bl_hmac_md5((UINT8 *)pKeyMsg,iStack24,MIC_Key,CONCAT31(in_register_00002035,MIC_Key_length),
                output);
  }
  else {
    if (uVar1 == 2) {
      Bl_hmac_sha1((uchar **)&len,&iStack24,1,MIC_Key,CONCAT31(in_register_00002035,MIC_Key_length),
                   output,0x10);
    }
    else {
      bl_aes_cmac(MIC_Key,(UINT8 *)pKeyMsg,iStack24,output);
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

UINT16 keyMgmtGetKeySize_internal(RSNConfig_t *pRsnConfig,UINT8 isPairwise)

{
  Cipher_t CVar1;
  char "keyMgmtGetKeySize_internal" [27];
  UINT16 UVar2;
  undefined3 in_register_0000202d;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"keyMgmtGetKeySize_internal");
  if (CONCAT31(in_register_0000202d,isPairwise) == 0) {
    CVar1 = pRsnConfig->mcstCipher;
    UVar2 = 0x10;
    if (((((byte)CVar1 & 8) == 0) && (UVar2 = 0xd, ((byte)CVar1 & 2) == 0)) &&
       (UVar2 = 0x20, ((byte)CVar1 & 1) != 0)) {
      UVar2 = 5;
    }
  }
  else {
    UVar2 = 0x20;
    if (((byte)pRsnConfig->ucstCipher & 8) != 0) {
      UVar2 = 0x10;
    }
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x230760c0);
  return UVar2;
}



// WARNING: Variable defined which should be unmapped: tmpLo
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int isApReplayCounterFresh(keyMgmtInfoSta_t *pKeyMgmtInfoSta,UINT8 *pRxReplayCount)

{
  char "isApReplayCounterFresh" [23];
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uStack24;
  UINT32 tmpHi;
  UINT32 tmpLo;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"isApReplayCounterFresh");
  memcpy(&uStack24,pRxReplayCount,4);
  memcpy(&tmpHi,pRxReplayCount + 4,4);
  uVar3 = uStack24 * 0x1000000 + (uStack24 >> 0x18) + (uStack24 & 0xff00) * 0x100 +
          (uStack24 >> 8 & 0xff00);
  uVar2 = pKeyMgmtInfoSta->apCounterHi;
  uVar1 = 1;
  if ((uVar3 <= uVar2) && (uVar1 = 0, uVar2 == uVar3)) {
    uVar1 = 1;
    uVar4 = tmpHi * 0x1000000 + (tmpHi >> 0x18) + (tmpHi & 0xff00) * 0x100 + (tmpHi >> 8 & 0xff00);
    uVar3 = pKeyMgmtInfoSta->apCounterLo;
    if ((uVar4 <= uVar3) && ((uVar1 = 0, uVar3 == uVar4 && ((uVar2 | uVar3) == 0)))) {
      uVar1 = (uint)(pKeyMgmtInfoSta->apCounterZeroDone == 0);
    }
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x230760dc);
  return uVar1;
}



// WARNING: Variable defined which should be unmapped: tmpLo
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void updateApReplayCounter(keyMgmtInfoSta_t *pKeyMgmtStaInfo,UINT8 *pRxReplayCount)

{
  char "updateApReplayCounter" [22];
  uint uVar1;
  uint uVar2;
  uint uStack24;
  UINT32 tmpHi;
  UINT32 tmpLo;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"updateApReplayCounter");
  memcpy(&uStack24,pRxReplayCount,4);
  memcpy(&tmpHi,pRxReplayCount + 4,4);
  uVar2 = uStack24 * 0x1000000 + (uStack24 >> 0x18) + (uStack24 & 0xff00) * 0x100 +
          (uStack24 >> 8 & 0xff00);
  uVar1 = tmpHi * 0x1000000 + (tmpHi >> 0x18) + (tmpHi & 0xff00) * 0x100 + (tmpHi >> 8 & 0xff00);
  pKeyMgmtStaInfo->apCounterHi = uVar2;
  pKeyMgmtStaInfo->apCounterLo = uVar1;
  if ((uVar2 | uVar1) == 0) {
    pKeyMgmtStaInfo->apCounterZeroDone = 1;
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x230760f4);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void formEAPOLEthHdr(EAPOL_KeyMsg_Tx_t *pTxEapol,IEEEtypes_MacAddr_t *da,IEEEtypes_MacAddr_t *sa)

{
  char "formEAPOLEthHdr" [16];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"formEAPOLEthHdr");
  memcpy(pTxEapol,da,6);
  memcpy((pTxEapol->ethHdr).sa,sa,6);
  *(undefined *)&(pTxEapol->ethHdr).type = 0x88;
  *(undefined *)((int)&(pTxEapol->ethHdr).type + 1) = 0x8e;
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307610c);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BOOLEAN IsEAPOL_MICValid(EAPOL_KeyMsg_t *pKeyMsg,UINT8 *pMICKey)

{
  UINT8 *__src;
  int iVar1;
  undefined auStack48 [4];
  UINT8 msgMIC [16];
  
  __src = pKeyMsg->key_MIC;
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"IsEAPOL_MICValid");
  memcpy(auStack48,__src,0x10);
  memset(__src,0,0x10);
  ComputeEAPOL_MIC(pKeyMsg,(UINT16)(((uint)CONCAT21((pKeyMsg->hdr_8021x).pckt_body_len,
                                                    *(undefined *)
                                                     ((int)&(pKeyMsg->hdr_8021x).pckt_body_len + 1))
                                    + 4) * 0x10000 >> 0x10),pMICKey,'\x10','\0');
  iVar1 = memcmp(__src,auStack48,0x10);
  if (iVar1 == 0) {
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"IsEAPOL_MICValid");
  }
  return (uint)(iVar1 == 0);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

UINT16 KeyMgmtSta_PopulateEAPOLLengthMic
                 (EAPOL_KeyMsg_Tx_t *pTxEapol,UINT8 *pEAPOLMICKey,UINT8 eapolProtocolVersion,
                 UINT8 forceKeyDescVersion)

{
  undefined uVar1;
  ushort uVar2;
  char "KeyMgmtSta_PopulateEAPOLLengthMic" [34];
  UINT16 UVar3;
  uint uVar4;
  
  UVar3 = 0;
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmtSta_PopulateEAPOLLengthMic");
  if (pTxEapol != (EAPOL_KeyMsg_Tx_t *)0x0) {
    uVar1 = *(undefined *)((int)&(pTxEapol->keyMsg).key_material_len + 1);
    uVar2 = (pTxEapol->keyMsg).key_material_len;
    uVar4 = (uint)uVar2 + 0x5f & 0xffff;
    UVar3 = (UINT16)uVar4;
    (pTxEapol->keyMsg).hdr_8021x.pckt_type = IEEE_8021X_PACKET_TYPE_EAPOL_KEY;
    *(char *)&(pTxEapol->keyMsg).hdr_8021x.pckt_body_len = (char)(uVar4 >> 8);
    *(undefined *)((int)&(pTxEapol->keyMsg).hdr_8021x.pckt_body_len + 1) = (char)uVar4;
    *(undefined *)&(pTxEapol->keyMsg).key_material_len = uVar1;
    (pTxEapol->keyMsg).hdr_8021x.protocol_ver = eapolProtocolVersion;
    *(undefined *)((int)&(pTxEapol->keyMsg).key_material_len + 1) =
         (char)((uint)CONCAT21(uVar2,uVar1) >> 8);
    ComputeEAPOL_MIC(&pTxEapol->keyMsg,(UINT16)(((uint)uVar2 + 99) * 0x10000 >> 0x10),pEAPOLMICKey,
                     '\x10',forceKeyDescVersion);
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23076130);
  }
  return UVar3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

KDE_t * parseKeyKDE(IEEEtypes_InfoElementHdr_t *pIe)

{
  char "parseKeyKDE" [12];
  int iVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"parseKeyKDE");
  if (((pIe->ElementId != ELEM_ID_VENDOR_SPECIFIC) || (pIe->Len < 8)) ||
     (iVar1 = memcmp(pIe + 1,"",3), iVar1 != 0)) {
    pIe = (IEEEtypes_InfoElementHdr_t *)0x0;
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23076154);
  }
  return (KDE_t *)pIe;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

KDE_t * parseKeyKDE_DataType(UINT8 *pData,SINT32 dataLen,IEEEtypes_KDEDataType_e KDEDataType)

{
  KDE_t *pKVar1;
  undefined3 in_register_00002031;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"parseKeyKDE_DataType");
  if (pData != (UINT8 *)0x0) {
    while (2 < dataLen) {
      if (((IEEEtypes_InfoElementHdr_t *)pData)->ElementId == ELEM_ID_VENDOR_SPECIFIC) {
        pKVar1 = parseKeyKDE((IEEEtypes_InfoElementHdr_t *)pData);
        if ((pKVar1 != (KDE_t *)0x0) &&
           ((uint)pKVar1->dataType == CONCAT31(in_register_00002031,KDEDataType))) {
          return pKVar1;
        }
        if (((IEEEtypes_InfoElementHdr_t *)pData)->Len == '\0') {
          dataLen = 2;
        }
      }
      dataLen = dataLen + (-2 - (uint)((IEEEtypes_InfoElementHdr_t *)pData)->Len);
      pData = (UINT8 *)(&((IEEEtypes_InfoElementHdr_t *)pData)[1].ElementId +
                       (uint)((IEEEtypes_InfoElementHdr_t *)pData)->Len);
    }
    pData = (UINT8 *)0x0;
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"parseKeyKDE_DataType");
  }
  return (KDE_t *)pData;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

KDE_t * parseKeyDataGTK(UINT8 *pKey,UINT16 len,KeyData_t *pGRKey)

{
  char "parseKeyDataGTK" [16];
  KDE_t *pKVar1;
  undefined2 in_register_0000202e;
  undefined auStack40 [4];
  UINT8 buf [8];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"parseKeyDataGTK");
  pKVar1 = parseKeyKDE_DataType(pKey,CONCAT22(in_register_0000202e,len),KDE_DATA_TYPE_GTK);
  if (pKVar1 != (KDE_t *)0x0) {
    memcpy(pGRKey,&pKVar1[1].length,(uint)pKVar1->length - 6);
    pGRKey->KeyIndex = (ushort)pKVar1->data[0] & 3;
    memcpy(auStack40,pGRKey->TxMICKey,8);
    memcpy(pGRKey->TxMICKey,pGRKey->RxMICKey,8);
    memcpy(pGRKey->RxMICKey,auStack40,8);
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23076178);
  return pKVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void KeyMgmtSta_ApplyKEK(EAPOL_KeyMsg_t *pKeyMsg,KeyData_t *pGRKey,UINT8 *EAPOL_Encr_Key)

{
  byte bVar1;
  undefined uVar2;
  uint3 uVar3;
  char "KeyMgmtSta_ApplyKEK" [20];
  UINT8 *cipher;
  uint uVar4;
  int iVar5;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmtSta_ApplyKEK");
  bVar1 = pKeyMsg->key_RSC[1];
  cipher = pKeyMsg->key_data;
  pGRKey->TxIV16 = (ushort)bVar1 << 8;
  pGRKey->TxIV16 = CONCAT11(bVar1,pKeyMsg->key_RSC[0]);
  pGRKey->TxIV32 = 0xffffffff;
  uVar2 = *(undefined *)((int)&pKeyMsg->key_material_len + 1);
  uVar3 = CONCAT21(pKeyMsg->key_material_len,uVar2);
  uVar4 = (uint)uVar3 & 0xffff;
  *(undefined *)((int)&pKeyMsg->key_material_len + 1) = (char)(uVar4 >> 8);
  bVar1 = *(byte *)&(pKeyMsg->key_info).field_0x1;
  *(undefined *)&pKeyMsg->key_material_len = uVar2;
  if ((bVar1 & 7) == 1) {
    RC4_Encrypt(EAPOL_Encr_Key,pKeyMsg->EAPOL_key_IV,0x10,cipher,(ushort)uVar3,0x100);
  }
  else {
    BL_AesUnWrap(EAPOL_Encr_Key,'\x02',(uVar4 >> 3) - 1,cipher,(UINT8 *)0x0,cipher);
    iVar5 = (uint)pKeyMsg->key_material_len - 8;
    *(char *)&pKeyMsg->key_material_len = (char)((uint)(iVar5 * 0x10000) >> 0x10);
    *(undefined *)((int)&pKeyMsg->key_material_len + 1) = (char)((uint)iVar5 >> 8);
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23076188);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BOOLEAN KeyMgmtSta_IsRxEAPOLValid(keyMgmtInfoSta_t *pKeyMgmtInfoSta,EAPOL_KeyMsg_t *pKeyMsg)

{
  BOOLEAN BVar1;
  int iVar2;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmtSta_IsRxEAPOLValid");
  if ((((pKeyMgmtInfoSta == (keyMgmtInfoSta_t *)0x0) || (pKeyMsg == (EAPOL_KeyMsg_t *)0x0)) ||
      (iVar2 = isApReplayCounterFresh(pKeyMgmtInfoSta,(UINT8 *)pKeyMsg->replay_cnt), iVar2 == 0)) ||
     (((*(byte *)&pKeyMsg->key_info & 1) != 0 &&
      ((((*(byte *)&(pKeyMsg->key_info).field_0x1 & 8) != 0 &&
        (iVar2 = memcmp(pKeyMsg->key_nonce,pKeyMgmtInfoSta,0x20), iVar2 != 0)) ||
       (BVar1 = IsEAPOL_MICValid(pKeyMsg,pKeyMgmtInfoSta->EAPOL_MIC_Key), BVar1 == 0)))))) {
    BVar1 = 0;
  }
  else {
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"KeyMgmtSta_IsRxEAPOLValid");
    BVar1 = 1;
  }
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void KeyMgmtSta_PrepareEAPOLFrame
               (EAPOL_KeyMsg_Tx_t *pTxEapol,EAPOL_KeyMsg_t *pRxEapol,IEEEtypes_MacAddr_t *da,
               IEEEtypes_MacAddr_t *sa,UINT8 *pSNonce)

{
  byte bVar1;
  byte bVar2;
  UINT32 UVar3;
  char "KeyMgmtSta_PrepareEAPOLFrame" [29];
  byte bVar4;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmtSta_PrepareEAPOLFrame");
  if ((pTxEapol != (EAPOL_KeyMsg_Tx_t *)0x0) && (pRxEapol != (EAPOL_KeyMsg_t *)0x0)) {
    memset(pTxEapol,0,0x72);
    formEAPOLEthHdr(pTxEapol,da,sa);
    (pTxEapol->keyMsg).desc_type = pRxEapol->desc_type;
    bVar4 = *(byte *)&(pRxEapol->key_info).field_0x1 & 8;
    bVar1 = *(byte *)&(pTxEapol->keyMsg).key_info.field_0x1;
    bVar2 = *(byte *)&(pTxEapol->keyMsg).key_info;
    *(byte *)&(pTxEapol->keyMsg).key_info.field_0x1 = bVar1 & 0xf7 | bVar4;
    *(byte *)&(pTxEapol->keyMsg).key_info = bVar2 | 1;
    *(byte *)&(pTxEapol->keyMsg).key_info = bVar2 & 0xfd | 1 | *(byte *)&pRxEapol->key_info & 2;
    UVar3 = pRxEapol->replay_cnt[0];
    *(char *)(pTxEapol->keyMsg).replay_cnt = (char)*(undefined3 *)pRxEapol->replay_cnt;
    *(undefined *)((int)(pTxEapol->keyMsg).replay_cnt + 1) = (char)(UVar3 >> 8);
    *(undefined *)((int)(pTxEapol->keyMsg).replay_cnt + 2) = (char)(UVar3 >> 0x10);
    *(undefined *)((int)(pTxEapol->keyMsg).replay_cnt + 3) = (char)(UVar3 >> 0x18);
    UVar3 = pRxEapol->replay_cnt[1];
    *(char *)((pTxEapol->keyMsg).replay_cnt + 1) = (char)*(undefined3 *)(pRxEapol->replay_cnt + 1);
    *(undefined *)((int)(pTxEapol->keyMsg).replay_cnt + 5) = (char)(UVar3 >> 8);
    *(undefined *)((int)(pTxEapol->keyMsg).replay_cnt + 6) = (char)(UVar3 >> 0x10);
    *(undefined *)((int)(pTxEapol->keyMsg).replay_cnt + 7) = (char)(UVar3 >> 0x18);
    *(byte *)&(pTxEapol->keyMsg).key_info.field_0x1 =
         bVar1 & 0xf0 | bVar4 | *(byte *)&(pRxEapol->key_info).field_0x1 & 7;
    if (pSNonce != (UINT8 *)0x0) {
      memcpy((pTxEapol->keyMsg).key_nonce,pSNonce,0x20);
    }
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x230761b8);
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BOOLEAN supplicantAkmIsWpaWpa2(AkmSuite_t *pAkm)

{
  int iVar1;
  BOOLEAN BVar2;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantAkmIsWpaWpa2");
  iVar1 = memcmp(pAkm,"",3);
  if ((iVar1 == 0) || (iVar1 = memcmp(pAkm,"",3), iVar1 == 0)) {
    BVar2 = 1;
  }
  else {
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"supplicantAkmIsWpaWpa2");
    BVar2 = 0;
  }
  return BVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BOOLEAN supplicantAkmIsWpa2(AkmSuite_t *pAkm)

{
  int iVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantAkmIsWpa2");
  iVar1 = memcmp(pAkm,"",3);
  if (iVar1 != 0) {
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"supplicantAkmIsWpa2");
  }
  return (uint)(iVar1 == 0);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BOOLEAN supplicantAkmIsWpaWpa2Psk(AkmSuite_t *pAkm)

{
  char "supplicantAkmIsWpaWpa2Psk" [26];
  uint uVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantAkmIsWpaWpa2Psk");
  uVar1 = supplicantAkmIsWpaWpa2(pAkm);
  if (uVar1 == 0) {
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23076204);
  }
  else {
    uVar1 = 1;
    if ((pAkm->akmType & 0xfb) != 2) {
      uVar1 = (uint)(pAkm->akmType == AKM_FT_PSK);
    }
  }
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BOOLEAN supplicantAkmUsesKdf(AkmSuite_t *pAkm)

{
  char "supplicantAkmUsesKdf" [21];
  BOOLEAN BVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantAkmUsesKdf");
  BVar1 = supplicantAkmIsWpa2(pAkm);
  if ((BVar1 == 0) || (BVar1 = 1, 3 < (byte)(pAkm->akmType + ~AKM_WPA_MAX))) {
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23076220);
    BVar1 = 0;
  }
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void supplicantConstructContext
               (IEEEtypes_MacAddr_t *pAddr1,IEEEtypes_MacAddr_t *pAddr2,UINT8 *pNonce1,
               UINT8 *pNonce2,UINT8 *pContext)

{
  char "supplicantConstructContext" [27];
  int iVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantConstructContext");
  iVar1 = memcmp(pAddr1,pAddr2,6);
  if (iVar1 < 0) {
    memcpy(pContext,pAddr1,6);
    pAddr1 = pAddr2;
  }
  else {
    memcpy(pContext,pAddr2,6);
  }
  memcpy(pContext + 6,pAddr1,6);
  iVar1 = memcmp(pNonce1,pNonce2,0x20);
  if (iVar1 < 0) {
    memcpy(pContext + 0xc,pNonce1,0x20);
    pNonce1 = pNonce2;
  }
  else {
    memcpy(pContext + 0xc,pNonce2,0x20);
  }
  memcpy(pContext + 0x2c,pNonce1,0x20);
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23076238);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void KeyMgmt_DerivePTK(IEEEtypes_MacAddr_t *pAddr1,IEEEtypes_MacAddr_t *pAddr2,UINT8 *pNonce1,
                      UINT8 *pNonce2,UINT8 *pPTK,UINT8 *pPMK,BOOLEAN use_kdf)

{
  char "KeyMgmt_DerivePTK" [18];
  UINT8 *pContext;
  
  pContext = pPTK + 200;
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmt_DerivePTK");
  supplicantConstructContext(pAddr1,pAddr2,pNonce1,pNonce2,pContext);
  if (use_kdf == 0) {
    Bl_PRF(pPMK,0x20,(uchar *)"Pairwise key expansion",0x16,pContext,0x4c,pPTK,0x40);
  }
  else {
    bl_sha256_crypto_kdf(pPMK,' ',"Pairwise key expansion",'\x16',pContext,0x4c,pPTK,0x180);
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23076254);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void KeyMgmtSta_DeriveKeys
               (UINT8 *pPMK,IEEEtypes_MacAddr_t *da,IEEEtypes_MacAddr_t *sa,UINT8 *ANonce,
               UINT8 *SNonce,UINT8 *EAPOL_MIC_Key,UINT8 *EAPOL_Encr_Key,KeyData_t *newPWKey,
               BOOLEAN use_kdf)

{
  char "KeyMgmtSta_DeriveKeys" [22];
  BOOLEAN in_stack_00000000;
  UINT8 aUStack548 [4];
  UINT8 pBuf [500];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmtSta_DeriveKeys");
  if (((pPMK != (UINT8 *)0x0) && (EAPOL_MIC_Key != (UINT8 *)0x0)) && (newPWKey != (KeyData_t *)0x0))
  {
    KeyMgmt_DerivePTK(sa,da,ANonce,SNonce,aUStack548,pPMK,in_stack_00000000);
    memcpy(EAPOL_MIC_Key,aUStack548,0x10);
    memcpy(EAPOL_Encr_Key,pBuf + 0xc,0x10);
    memcpy(newPWKey,pBuf + 0x1c,0x10);
    memcpy(newPWKey->RxMICKey,pBuf + 0x2c,8);
    memcpy(newPWKey->TxMICKey,pBuf + 0x34,8);
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23076268);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SetEAPOLKeyDescTypeVersion
               (EAPOL_KeyMsg_Tx_t *pTxEapol,BOOLEAN isWPA2,BOOLEAN isKDF,BOOLEAN nonTKIP)

{
  byte bVar1;
  char "SetEAPOLKeyDescTypeVersion" [27];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"SetEAPOLKeyDescTypeVersion");
  bVar1 = *(byte *)&(pTxEapol->keyMsg).key_info.field_0x1;
  (pTxEapol->keyMsg).desc_type = '\x02';
  *(byte *)&(pTxEapol->keyMsg).key_info.field_0x1 = bVar1 & 0xf8 | (isKDF != 0) + 2U;
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23076280);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

EAPOL_KeyMsg_t *
GetKeyMsgNonceFromEAPOL(BufferDesc_t *pEAPoLBufDesc,keyMgmtInfoSta_t *pKeyMgmtInfoSta)

{
  char "GetKeyMsgNonceFromEAPOL" [24];
  EAPOL_KeyMsg_t *pKeyMsg;
  BOOLEAN BVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"GetKeyMsgNonceFromEAPOL");
  pKeyMsg = (EAPOL_KeyMsg_t *)pEAPoLBufDesc->Buffer;
  BVar1 = KeyMgmtSta_IsRxEAPOLValid(pKeyMgmtInfoSta,pKeyMsg);
  if (BVar1 == 0) {
    pKeyMsg = (EAPOL_KeyMsg_t *)0x0;
  }
  else {
    if ((*(byte *)&pKeyMsg->key_info & 1) == 0) {
      memcpy(pKeyMgmtInfoSta,pKeyMsg->key_nonce,0x20);
      supplicantGenerateRand(pKeyMgmtInfoSta->SNonce,0x20);
    }
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307629c);
  }
  return pKeyMsg;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

EAPOL_KeyMsg_t *
ProcessRxEAPOL_PwkMsg3(BufferDesc_t *pEAPoLBufDesc,keyMgmtInfoSta_t *pKeyMgmtInfoSta)

{
  char "ProcessRxEAPOL_PwkMsg3" [23];
  EAPOL_KeyMsg_t *pKeyMsg;
  BOOLEAN BVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"ProcessRxEAPOL_PwkMsg3");
  pKeyMsg = GetKeyMsgNonceFromEAPOL(pEAPoLBufDesc,pKeyMgmtInfoSta);
  if (pKeyMsg == (EAPOL_KeyMsg_t *)0x0) {
LAB_2301145c:
    pKeyMsg = (EAPOL_KeyMsg_t *)0x0;
  }
  else {
    (pKeyMgmtInfoSta->newPWKey).TxIV16 = 1;
    (pKeyMgmtInfoSta->newPWKey).TxIV32 = 0;
    if ((*(byte *)&pKeyMsg->key_info & 0x10) != 0) {
      mm_timer_clear(&pKeyMgmtInfoSta->rsnTimer);
      KeyMgmtSta_ApplyKEK(pKeyMsg,&pKeyMgmtInfoSta->GRKey,pKeyMgmtInfoSta->EAPOL_Encr_Key);
      BVar1 = keyMgmtProcessMsgExt(pKeyMgmtInfoSta,pKeyMsg);
      if (BVar1 == 0) goto LAB_2301145c;
      parseKeyDataGTK(pKeyMsg->key_data,pKeyMsg->key_material_len,&pKeyMgmtInfoSta->GRKey);
    }
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x230762b4);
  }
  return pKeyMsg;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

EAPOL_KeyMsg_t *
ProcessRxEAPOL_GrpMsg1(BufferDesc_t *pEAPoLBufDesc,keyMgmtInfoSta_t *pKeyMgmtInfoSta)

{
  char "ProcessRxEAPOL_GrpMsg1" [23];
  EAPOL_KeyMsg_t *pKeyMsg;
  BOOLEAN BVar1;
  KeyData_t *pGRKey;
  UINT8 *__src;
  UINT8 *__src_00;
  undefined auStack40 [4];
  UINT8 buf [8];
  
  pKeyMsg = GetKeyMsgNonceFromEAPOL(pEAPoLBufDesc,pKeyMgmtInfoSta);
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"ProcessRxEAPOL_GrpMsg1");
  if (pKeyMsg == (EAPOL_KeyMsg_t *)0x0) {
LAB_23011518:
    pKeyMsg = (EAPOL_KeyMsg_t *)0x0;
  }
  else {
    pGRKey = &pKeyMgmtInfoSta->GRKey;
    KeyMgmtSta_ApplyKEK(pKeyMsg,pGRKey,pKeyMgmtInfoSta->EAPOL_Encr_Key);
    pKeyMgmtInfoSta->RSNDataTrafficEnabled = 1;
    mm_timer_clear(&pKeyMgmtInfoSta->rsnTimer);
    if (pKeyMsg->desc_type == '\x02') {
      parseKeyDataGTK(pKeyMsg->key_data,pKeyMsg->key_material_len,pGRKey);
      BVar1 = keyMgmtProcessMsgExt(pKeyMgmtInfoSta,pKeyMsg);
      if (BVar1 == 0) goto LAB_23011518;
    }
    else {
      memcpy(pGRKey,pKeyMsg->key_data,(uint)pKeyMsg->key_material_len);
      __src_00 = (pKeyMgmtInfoSta->GRKey).TxMICKey;
      memcpy(auStack40,__src_00,8);
      __src = (pKeyMgmtInfoSta->GRKey).RxMICKey;
      memcpy(__src_00,__src,8);
      memcpy(__src,auStack40,8);
      (pKeyMgmtInfoSta->GRKey).KeyIndex = (ushort)(*(byte *)&(pKeyMsg->key_info).field_0x1 >> 4) & 3
      ;
    }
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x230762cc);
  }
  return pKeyMsg;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void KeyMgmtResetCounter(keyMgmtInfoSta_t *pKeyMgmtInfo)

{
  char "KeyMgmtResetCounter" [20];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmtResetCounter");
  if (pKeyMgmtInfo != (keyMgmtInfoSta_t *)0x0) {
    pKeyMgmtInfo->staCounterHi = 0;
    pKeyMgmtInfo->staCounterLo = 0;
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x230762e4);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void keyMgmtSta_StartSession_internal(keyMgmtInfoSta_t *pKeyMgmtInfoSta,UINT32 expiry)

{
  char "keyMgmtSta_StartSession_internal" [33];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"keyMgmtSta_StartSession_internal");
  if ((pKeyMgmtInfoSta->sta_MIC_Error).disableStaAsso == 0) {
    mm_timer_set(&pKeyMgmtInfoSta->rsnTimer,_DAT_44b00120 + expiry);
  }
  pKeyMgmtInfoSta->apCounterLo = 0;
  pKeyMgmtInfoSta->apCounterHi = 0;
  pKeyMgmtInfoSta->apCounterZeroDone = 0;
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307631c);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void KeyMgmtSta_InitSession(keyMgmtInfoSta_t *pKeyMgmtInfoSta)

{
  char "KeyMgmtSta_InitSession" [23];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmtSta_InitSession");
  pKeyMgmtInfoSta->RSNDataTrafficEnabled = 0;
  pKeyMgmtInfoSta->RSNSecured = 0;
  pKeyMgmtInfoSta->pRxDecryptKey = (cipher_key_t *)0x0;
  pKeyMgmtInfoSta->pwkHandshakeComplete = 0;
  (pKeyMgmtInfoSta->rsnTimer).cb = keyMgmtStaRsnSecuredTimeoutHandler;
  *(keyMgmtInfoSta_t **)&(pKeyMgmtInfoSta->rsnTimer).env = pKeyMgmtInfoSta;
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23076340);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void set_psk(char *pSsid,UINT8 ssidLen,char *phrase)

{
  char "set_psk" [8];
  size_t sVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"set_psk");
  memset(&nohostParams,0xff,0x43);
  sVar1 = strlen(phrase);
  pmkCacheSetPassphrase((UINT8 *)pSsid,ssidLen,(UINT8 *)phrase,(UINT8)sVar1);
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2308ddc4);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void remove_psk(char *pSsid,UINT8 ssidLen)

{
  char "remove_psk" [11];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"remove_psk");
  pmkCacheDeletePSK((UINT8 *)pSsid,ssidLen);
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23076358);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void bl_sha256_crypto_kdf
               (UINT8 *pKey,UINT8 key_len,char *label,UINT8 label_len,UINT8 *pContext,
               UINT16 context_len,UINT8 *pOutput,UINT16 output_len)

{
  UINT8 *mac;
  undefined3 in_register_0000202d;
  undefined2 in_register_0000203e;
  undefined2 in_register_00002046;
  ushort auStack114 [8];
  ushort uStack98;
  UINT16 i;
  ushort *puStack96;
  UINT8 *vectors [4];
  size_t vectLen [4];
  
  uStack98 = 1;
  mac = pContext + CONCAT22(in_register_0000203e,context_len);
  auStack114[0] = output_len;
  while ((uint)uStack98 <= (CONCAT22(in_register_00002046,output_len) + 0xff >> 8 & 0xffU)) {
    vectors[3] = (UINT8 *)0x2;
    puStack96 = &uStack98;
    vectors[0] = (UINT8 *)label;
    vectors[1] = pContext;
    vectors[2] = (UINT8 *)auStack114;
    hmac_sha256_vector(pKey,CONCAT31(in_register_0000202d,key_len),4,(UINT8 **)&stack0xffffffa0,
                       (size_t *)(vectors + 3),mac);
    mac = mac + 0x20;
    uStack98 = uStack98 + 1;
  }
  memcpy(pOutput,pContext + CONCAT22(in_register_0000203e,context_len),(uint)(auStack114[0] >> 3));
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

UINT8 * pmkCacheFindPSK(UINT8 *pSsid,UINT8 ssidLen)

{
  char "pmkCacheFindPSK" [16];
  pmkElement_t *pPSK;
  size_t sVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"pmkCacheFindPSK");
  pPSK = pmkCacheFindPSKElement(pSsid,ssidLen);
  if (pPSK == (pmkElement_t *)0x0) {
    if (PSKPassPhrase != '\0') {
      pmkCacheAddPSK(pSsid,ssidLen,(UINT8 *)0x0,'\0');
      pPSK = pmkCacheFindPSKElement(pSsid,ssidLen);
      sVar1 = strlen((char *)PSKPassPhrase);
      pPSK = (pmkElement_t *)pPSK->PMK;
      pmkCacheGeneratePSK(pSsid,ssidLen,PSKPassPhrase,(UINT8)sVar1,(UINT8 *)pPSK);
    }
  }
  else {
    pPSK = (pmkElement_t *)pPSK->PMK;
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23076364);
  return (UINT8 *)pPSK;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void pmkCacheSetPassphrase(UINT8 *pSsid,UINT8 ssidLen,UINT8 *pPassphrase,UINT8 PassphraseLen)

{
  char "pmkCacheSetPassphrase" [22];
  pmkElement_t *pSsid_00;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"pmkCacheSetPassphrase");
  if (pPassphrase != (UINT8 *)0x0) {
    memcpy(PSKPassPhrase,pPassphrase,0x40);
    pmkCacheAddPSK(pSsid,ssidLen,pPassphrase,PassphraseLen);
    pSsid_00 = pmkCacheFindPSKElement(pSsid,ssidLen);
    pmkCacheGeneratePSK((UINT8 *)pSsid_00,pSsid_00->length,PSKPassPhrase,PassphraseLen,pSsid_00->PMK
                       );
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23076374);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void pmkCacheInit(void)

{
  char "pmkCacheInit" [13];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"pmkCacheInit");
  memset(pmkCache,0,0x86);
  memset(PSKPassPhrase,0,0x40);
  replacementRankMax = '\0';
  dbg_test_print("%dms : Leave: %s\n",0x2307638c);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void pmkCacheRomInit(void)

{
  char "pmkCacheRomInit" [16];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"pmkCacheRomInit");
  ramHook_MAX_PMK_CACHE_ENTRIES = 2;
  ramHook_pmkCache = pmkCache;
  ramHook_PSKPassPhrase = PSKPassPhrase;
  dbg_test_print("%dms : Leave: %s\n",0x2307639c);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

pmkElement_t * pmkCacheNewElement(void)

{
  char "pmkCacheNewElement" [19];
  uint uVar1;
  pmkElement_t *__s;
  pmkElement_t *ppVar2;
  
  ppVar2 = (pmkElement_t *)0x0;
  uVar1 = 0;
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"pmkCacheNewElement");
  while ((int)uVar1 < ramHook_MAX_PMK_CACHE_ENTRIES) {
    if ((int)replacementRankMax == ramHook_MAX_PMK_CACHE_ENTRIES) {
      ramHook_pmkCache[uVar1].replacementRank = ramHook_pmkCache[uVar1].replacementRank + -1;
    }
    if (ppVar2 == (pmkElement_t *)0x0) {
      __s = ramHook_pmkCache + uVar1;
      if (__s->replacementRank == '\0') {
        memset(__s,0,0x43);
        if (replacementRankMax < ramHook_MAX_PMK_CACHE_ENTRIES) {
          replacementRankMax = replacementRankMax + '\x01';
        }
        ramHook_pmkCache[uVar1].replacementRank = replacementRankMax;
        ppVar2 = __s;
      }
    }
    uVar1 = uVar1 + 1 & 0xff;
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x230763ac);
  return ppVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void pmkCacheUpdateReplacementRank(pmkElement_t *pPMKElement)

{
  char cVar1;
  SINT8 SVar2;
  pmkElement_t *ppVar3;
  SINT32 SVar4;
  char "pmkCacheUpdateReplacementRank" [30];
  uint uVar5;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"pmkCacheUpdateReplacementRank");
  SVar4 = ramHook_MAX_PMK_CACHE_ENTRIES;
  ppVar3 = ramHook_pmkCache;
  SVar2 = replacementRankMax;
  if ((pPMKElement != (pmkElement_t *)0x0) && (pPMKElement->replacementRank != replacementRankMax))
  {
    uVar5 = 0;
    while ((int)uVar5 < SVar4) {
      cVar1 = ppVar3[uVar5].replacementRank;
      if (pPMKElement->replacementRank < cVar1) {
        ppVar3[uVar5].replacementRank = cVar1 + -1;
      }
      uVar5 = uVar5 + 1 & 0xff;
    }
    pPMKElement->replacementRank = SVar2;
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x230763c0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

pmkElement_t * pmkCacheFindPSKElement(UINT8 *pSsid,UINT8 ssidLen)

{
  char "pmkCacheFindPSKElement" [23];
  uint uVar1;
  pmkElement_t *pPMKElement;
  pmkElement_t *__s1;
  int iVar2;
  undefined3 in_register_0000202d;
  
  pPMKElement = (pmkElement_t *)0x0;
  uVar1 = 0;
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"pmkCacheFindPSKElement");
  while ((int)uVar1 < ramHook_MAX_PMK_CACHE_ENTRIES) {
    __s1 = ramHook_pmkCache + uVar1;
    if (((__s1->replacementRank != '\0') &&
        ((uint)__s1->length == CONCAT31(in_register_0000202d,ssidLen))) &&
       (iVar2 = memcmp(__s1,pSsid,CONCAT31(in_register_0000202d,ssidLen)), iVar2 == 0)) {
      pPMKElement = ramHook_pmkCache + uVar1;
    }
    uVar1 = uVar1 + 1 & 0xff;
  }
  pmkCacheUpdateReplacementRank(pPMKElement);
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x230763e0);
  return pPMKElement;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void pmkCacheAddPSK(UINT8 *pSsid,UINT8 ssidLen,UINT8 *pPSK,UINT8 pPSKLen)

{
  char "pmkCacheAddPSK" [15];
  pmkElement_t *__dest;
  undefined3 in_register_0000202d;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"pmkCacheAddPSK");
  __dest = pmkCacheFindPSKElement(pSsid,ssidLen);
  if (__dest == (pmkElement_t *)0x0) {
    __dest = pmkCacheNewElement();
    memcpy(__dest,pSsid,CONCAT31(in_register_0000202d,ssidLen));
    __dest->length = ssidLen;
  }
  if (pPSK != (UINT8 *)0x0) {
    memcpy(__dest->PMK,pPSK,0x20);
    __dest->psk_length = pPSKLen;
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x230763f8);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void pmkCacheDeletePSK(UINT8 *pSsid,UINT8 ssidLen)

{
  char "pmkCacheDeletePSK" [18];
  pmkElement_t *__s;
  
  __s = pmkCacheFindPSKElement(pSsid,ssidLen);
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"pmkCacheDeletePSK");
  if (__s != (pmkElement_t *)0x0) {
    memset(__s,0,0x43);
    replacementRankMax = replacementRankMax + -1;
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23076408);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

UINT8 pmkCacheGetHexNibble(UINT8 nibble)

{
  undefined3 in_register_00002029;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"pmkCacheGetHexNibble");
  if (CONCAT31(in_register_00002029,nibble) < 0x61) {
    if (CONCAT31(in_register_00002029,nibble) < 0x41) {
      nibble = nibble + -0x30;
      dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"pmkCacheGetHexNibble");
    }
    else {
      nibble = nibble + -0x37;
    }
  }
  else {
    nibble = nibble + -0x57;
  }
  return nibble;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void pmkCacheGeneratePSK(UINT8 *pSsid,UINT8 ssidLen,UINT8 *pPassphrase,UINT8 PassphraseLen,
                        UINT8 *pPSK)

{
  char "pmkCacheGeneratePSK" [20];
  UINT8 UVar1;
  byte bVar2;
  undefined3 in_register_0000202d;
  undefined3 in_register_00002035;
  int iVar3;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"pmkCacheGeneratePSK");
  if ((pPSK != (UINT8 *)0x0) && (pPassphrase != (UINT8 *)0x0)) {
    if (CONCAT31(in_register_00002035,PassphraseLen) - 8U < 0x38) {
      utils_wifi_psk_cal_fast_bin
                ((char *)pPassphrase,pSsid,CONCAT31(in_register_0000202d,ssidLen),pPSK);
    }
    else {
      if (CONCAT31(in_register_00002035,PassphraseLen) == 0x40) {
        iVar3 = 0;
        do {
          UVar1 = pmkCacheGetHexNibble(*pPassphrase);
          bVar2 = pmkCacheGetHexNibble(pPassphrase[1]);
          pPSK[iVar3 >> 1] = bVar2 | UVar1 << 4;
          iVar3 = iVar3 + 2;
          pPassphrase = pPassphrase + 2;
        } while (iVar3 != 0x40);
      }
    }
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23076434);
  return;
}



void prepare_key(uchar *key_data_ptr,int key_data_len,rc4_key *key)

{
  byte bVar1;
  uchar *puVar2;
  rc4_key *prVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  
  iVar5 = 0;
  do {
    key->state[iVar5] = (uchar)iVar5;
    iVar5 = iVar5 + 1;
  } while (iVar5 != 0x100);
  key->x = '\0';
  key->y = '\0';
  uVar7 = 0;
  uVar4 = 0;
  prVar3 = key;
  do {
    bVar1 = prVar3->state[0];
    puVar2 = prVar3->state;
    uVar6 = (uint)key_data_ptr[uVar4] + (uint)bVar1 + uVar7;
    uVar7 = uVar6 & 0xff;
    prVar3->state[0] = key->state[uVar6 & 0xff];
    key->state[uVar6 & 0xff] = bVar1;
    uVar4 = (int)(uVar4 + 1) % key_data_len & 0xff;
    prVar3 = (rc4_key *)(puVar2 + 1);
  } while ((rc4_key *)&key->x != (rc4_key *)(puVar2 + 1));
  return;
}



void rc4(uchar *buffer_ptr,int buffer_len,int skip,rc4_key *key)

{
  byte bVar1;
  byte bVar2;
  byte *pbVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  byte *pbVar7;
  uint uVar8;
  
  bVar1 = key->x;
  uVar4 = (uint)key->y;
  iVar5 = 0;
  while (uVar8 = (uint)bVar1 + iVar5 & 0xff, iVar5 < skip) {
    bVar2 = key->state[uVar8 + 1 & 0xff];
    uVar4 = uVar4 + bVar2 & 0xff;
    iVar5 = (iVar5 + 1) * 0x10000 >> 0x10;
    key->state[uVar8 + 1 & 0xff] = key->state[uVar4];
    key->state[uVar4] = bVar2;
  }
  iVar5 = 0;
  while (uVar6 = uVar8 + iVar5 & 0xff, iVar5 < buffer_len) {
    pbVar7 = key->state + (uVar6 + 1 & 0xff);
    bVar1 = *pbVar7;
    uVar4 = uVar4 + (uint)bVar1 & 0xff;
    *pbVar7 = key->state[uVar4];
    key->state[uVar4] = bVar1;
    pbVar3 = buffer_ptr + iVar5;
    iVar5 = (iVar5 + 1) * 0x10000 >> 0x10;
    *pbVar3 = key->state[(uint)bVar1 + (uint)*pbVar7 & 0xff] ^ *pbVar3;
  }
  key->x = (uchar)uVar6;
  key->y = (uchar)uVar4;
  return;
}



void RC4_Encrypt(uchar *Encr_Key,uchar *IV,ushort iv_length,uchar *Data,ushort data_length,
                ushort skipBytes)

{
  undefined2 in_register_00002032;
  size_t __n;
  undefined2 in_register_0000203a;
  undefined2 in_register_0000203e;
  uchar auStack64 [4];
  uchar key [32];
  
  __n = CONCAT22(in_register_00002032,iv_length);
  if ((int)(__n + 0x10) < 0x21) {
    memcpy(auStack64,IV,__n);
    memcpy(auStack64 + __n,Encr_Key,0x10);
    prepare_key(auStack64,__n + 0x10,&rc4key);
    rc4(Data,CONCAT22(in_register_0000203a,data_length),CONCAT22(in_register_0000203e,skipBytes),
        &rc4key);
  }
  return;
}



int sha256_compress(sha256_state *md,UINT8 *msgBuf,UINT8 *pScratchMem)

{
  UINT32 *pUVar1;
  UINT32 *pUVar2;
  int iVar3;
  uint uVar4;
  uint *puVar5;
  uint uVar6;
  int *piVar7;
  int *piVar8;
  int iVar9;
  int iVar10;
  uint uVar11;
  int *__dest;
  ushort *puVar12;
  ushort *puVar13;
  uint uVar14;
  uint uVar15;
  uint uVar16;
  
  __dest = (int *)(pScratchMem + 0x100);
  memcpy(__dest,md->state,0x20);
  puVar5 = (uint *)pScratchMem;
  puVar12 = (ushort *)msgBuf;
  do {
    puVar13 = puVar12 + 2;
    *puVar5 = (((uint)(*puVar12 >> 8) | ((uint)*puVar12 & 0xff) << 8) << 8 |
              (uint)*(byte *)(puVar12 + 1)) << 8 | (uint)*(byte *)((int)puVar12 + 3);
    puVar5 = puVar5 + 1;
    puVar12 = puVar13;
  } while (puVar13 != (ushort *)(msgBuf + 0x40));
  piVar7 = (int *)(pScratchMem + 0x40);
  do {
    uVar6 = piVar7[-2];
    uVar4 = piVar7[-0xf];
    piVar8 = piVar7 + 1;
    *piVar7 = ((uVar6 << 0xf | uVar6 >> 0x11) ^ (uVar6 << 0xd | uVar6 >> 0x13) ^ uVar6 >> 10) +
              piVar7[-7] + piVar7[-0x10] +
              ((uVar4 >> 7 | uVar4 << 0x19) ^ (uVar4 << 0xe | uVar4 >> 0x12) ^ uVar4 >> 3);
    piVar7 = piVar8;
  } while (__dest != piVar8);
  iVar3 = 0;
  do {
    uVar4 = *(uint *)(pScratchMem + 0x110);
    uVar14 = *(uint *)(pScratchMem + 0x118);
    uVar15 = *(uint *)(pScratchMem + 0x114);
    uVar6 = *(uint *)(pScratchMem + 0x100);
    iVar9 = *(int *)((int)K + iVar3);
    uVar11 = *(uint *)(pScratchMem + 0x104);
    uVar16 = *(uint *)(pScratchMem + 0x108);
    iVar10 = *(int *)(pScratchMem + iVar3);
    *(uint *)(pScratchMem + 0x114) = uVar4;
    iVar10 = ((uVar4 >> 6 | uVar4 << 0x1a) ^ (uVar4 >> 0xb | uVar4 << 0x15) ^
             (uVar4 << 7 | uVar4 >> 0x19)) + ((uVar14 ^ uVar15) & uVar4 ^ uVar14) +
             *(int *)(pScratchMem + 0x11c) + iVar9 + iVar10;
    *(int *)(pScratchMem + 0x110) = *(int *)(pScratchMem + 0x10c) + iVar10;
    *(uint *)(pScratchMem + 0x104) = uVar6;
    *(uint *)(pScratchMem + 0x11c) = uVar14;
    *(uint *)(pScratchMem + 0x118) = uVar15;
    *(uint *)(pScratchMem + 0x10c) = uVar16;
    *(uint *)(pScratchMem + 0x108) = uVar11;
    *(uint *)(pScratchMem + 0x100) =
         iVar10 + ((uVar6 >> 2 | uVar6 << 0x1e) ^ (uVar6 >> 0xd | uVar6 << 0x13) ^
                  (uVar6 << 10 | uVar6 >> 0x16)) + (uVar6 & uVar11 | (uVar6 | uVar11) & uVar16);
    iVar3 = iVar3 + 4;
  } while (iVar3 != 0x100);
  pUVar1 = md->state;
  do {
    iVar3 = *__dest;
    pUVar2 = pUVar1 + 1;
    __dest = __dest + 1;
    *pUVar1 = *pUVar1 + iVar3;
    pUVar1 = pUVar2;
  } while (&md->curlen != pUVar2);
  return 0;
}



void sha256_init(sha256_state *md)

{
  *(undefined4 *)&md->length = 0;
  md->state[0] = 0x6a09e667;
  md->state[1] = 0xbb67ae85;
  md->state[2] = 0x3c6ef372;
  md->state[3] = 0xa54ff53a;
  md->state[4] = 0x510e527f;
  md->state[5] = 0x9b05688c;
  md->state[6] = 0x1f83d9ab;
  md->curlen = 0;
  *(undefined4 *)((int)&md->length + 4) = 0;
  md->state[7] = 0x5be0cd19;
  return;
}



void sha256_vector(size_t num_elem,UINT8 **addr,size_t *len,UINT8 *mac,UINT8 *pScratchMem)

{
  int iVar1;
  uint uVar2;
  uint __n;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 *puVar5;
  uint uVar6;
  UINT8 *msgBuf;
  UINT8 *pScratchMem_00;
  int iVar7;
  
  pScratchMem_00 = pScratchMem + 0x70;
  sha256_init((sha256_state *)pScratchMem);
  iVar7 = 0;
  do {
    __n = *(uint *)(pScratchMem + 0x28);
    if (iVar7 == num_elem << 2) {
      if (__n < 0x40) {
        uVar2 = __n * 8 + *(uint *)pScratchMem;
        *(uint *)(pScratchMem + 4) =
             (uint)(uVar2 < *(uint *)pScratchMem) + *(int *)(pScratchMem + 4);
        *(uint *)pScratchMem = uVar2;
        *(uint *)(pScratchMem + 0x28) = __n + 1;
        pScratchMem[__n + 0x2c] = -0x80;
        if (0x38 < __n + 1) {
          while (__n = *(uint *)(pScratchMem + 0x28), __n < 0x40) {
            *(uint *)(pScratchMem + 0x28) = __n + 1;
            pScratchMem[__n + 0x2c] = '\0';
          }
          sha256_compress((sha256_state *)pScratchMem,pScratchMem + 0x2c,pScratchMem_00);
          *(undefined4 *)(pScratchMem + 0x28) = 0;
        }
        while (__n = *(uint *)(pScratchMem + 0x28), __n < 0x38) {
          *(uint *)(pScratchMem + 0x28) = __n + 1;
          pScratchMem[__n + 0x2c] = '\0';
        }
        uVar3 = *(undefined4 *)pScratchMem;
        pScratchMem[0x68] = (UINT8)((uint)uVar3 >> 0x18);
        pScratchMem[0x69] = (UINT8)((uint)uVar3 >> 0x10);
        pScratchMem[0x6b] = (UINT8)uVar3;
        uVar4 = *(undefined4 *)(pScratchMem + 4);
        pScratchMem[0x6a] = (UINT8)((uint)uVar3 >> 8);
        pScratchMem[100] = (UINT8)((uint)uVar4 >> 0x18);
        pScratchMem[0x65] = (UINT8)((uint)uVar4 >> 0x10);
        pScratchMem[0x67] = (UINT8)uVar4;
        pScratchMem[0x66] = (UINT8)((uint)uVar4 >> 8);
        sha256_compress((sha256_state *)pScratchMem,pScratchMem + 0x2c,pScratchMem_00);
        puVar5 = (undefined4 *)(pScratchMem + 8);
        do {
          puVar5 = puVar5 + 1;
          uVar3 = *puVar5;
          *mac = (UINT8)((uint)uVar3 >> 0x18);
          mac[1] = (UINT8)((uint)uVar3 >> 0x10);
          mac[2] = (UINT8)((uint)uVar3 >> 8);
          mac[3] = (UINT8)uVar3;
          puVar5 = puVar5;
          mac = mac + 4;
        } while (puVar5 != (undefined4 *)(pScratchMem + 0x28));
      }
      return;
    }
    msgBuf = *(UINT8 **)((int)addr + iVar7);
    uVar2 = *(uint *)((int)len + iVar7);
    if (__n < 0x41) {
      while (iVar1 = *(int *)(pScratchMem + 0x28), uVar2 != 0) {
        if ((iVar1 == 0) && (0x3f < uVar2)) {
          iVar1 = sha256_compress((sha256_state *)pScratchMem,msgBuf,pScratchMem_00);
          if (iVar1 < 0) break;
          uVar6 = *(uint *)pScratchMem;
          msgBuf = msgBuf + 0x40;
          __n = uVar6 + 0x200;
          *(uint *)pScratchMem = __n;
          *(uint *)(pScratchMem + 4) = (uint)(__n < uVar6) + *(int *)(pScratchMem + 4);
          uVar2 = uVar2 - 0x40;
        }
        else {
          __n = 0x40U - iVar1;
          if (uVar2 < 0x40U - iVar1) {
            __n = uVar2;
          }
          memcpy(pScratchMem + 0x2c + iVar1,msgBuf,__n);
          iVar1 = *(int *)(pScratchMem + 0x28);
          msgBuf = msgBuf + __n;
          uVar2 = uVar2 - __n;
          *(uint *)(pScratchMem + 0x28) = iVar1 + __n;
          if (iVar1 + __n == 0x40) {
            iVar1 = sha256_compress((sha256_state *)pScratchMem,pScratchMem + 0x2c,pScratchMem_00);
            if (iVar1 < 0) break;
            uVar6 = *(uint *)pScratchMem;
            *(undefined4 *)(pScratchMem + 0x28) = 0;
            __n = uVar6 + 0x200;
            *(uint *)pScratchMem = __n;
            *(uint *)(pScratchMem + 4) = (uint)(__n < uVar6) + *(int *)(pScratchMem + 4);
          }
        }
      }
    }
    iVar7 = iVar7 + 4;
  } while( true );
}



// WARNING: Variable defined which should be unmapped: pScratchMem

void hmac_sha256_vector(UINT8 *key,size_t key_len,size_t num_elem,UINT8 **addr,size_t *len,
                       UINT8 *mac)

{
  size_t *mac_00;
  UINT8 **ppUVar1;
  size_t **ppsVar2;
  UINT8 **len_00;
  UINT8 **ppUVar3;
  size_t *psVar4;
  int iVar5;
  size_t *psVar6;
  size_t sStack600;
  uint *apuStack596 [4];
  size_t *psStack580;
  UINT8 *_addr [6];
  size_t _len [6];
  UINT8 pScratchMem [500];
  
  mac_00 = (size_t *)(pScratchMem + 0x3c);
  sStack600 = key_len;
  apuStack596[0] = (uint *)key;
  if (0x40 < key_len) {
    apuStack596[0] = (uint *)key;
    sha256_vector(1,(UINT8 **)apuStack596,&sStack600,(UINT8 *)mac_00,pScratchMem + 0x5c);
    sStack600 = 0x20;
    apuStack596[0] = mac_00;
  }
  memset(_len + 5,0,0x40);
  memcpy(_len + 5,apuStack596[0],sStack600);
  psVar6 = _len + 5;
  do {
    psVar4 = psVar6 + 1;
    *psVar6 = *psVar6 ^ 0x36363636;
    psVar6 = psVar4;
  } while (psVar4 != mac_00);
  psStack580 = _len + 5;
  len_00 = _addr + 5;
  _addr[5] = (UINT8 *)0x40;
  iVar5 = 0;
  ppsVar2 = &psStack580;
  ppUVar3 = len_00;
  while( true ) {
    ppsVar2 = ppsVar2 + 1;
    ppUVar3 = ppUVar3 + 1;
    if (iVar5 == num_elem << 2) break;
    *ppsVar2 = *(size_t **)((int)addr + iVar5);
    ppUVar1 = (UINT8 **)((int)len + iVar5);
    iVar5 = iVar5 + 4;
    *ppUVar3 = *ppUVar1;
  }
  sha256_vector(num_elem + 1,(UINT8 **)&psStack580,(size_t *)len_00,mac,pScratchMem + 0x5c);
  memset(_len + 5,0,0x40);
  memcpy(_len + 5,apuStack596[0],sStack600);
  psVar6 = _len + 5;
  do {
    psVar4 = psVar6 + 1;
    *psVar6 = *psVar6 ^ 0x5c5c5c5c;
    psVar6 = psVar4;
  } while (psVar4 != mac_00);
  psStack580 = _len + 5;
  _addr[5] = (UINT8 *)0x40;
  _len[0] = 0x20;
  _addr[0] = mac;
  sha256_vector(2,(UINT8 **)&psStack580,(size_t *)len_00,mac,pScratchMem + 0x5c);
  return;
}



void KeyMgmtInit(cm_ConnectionInfo_t *connPtr)

{
  UINT8 ssidLen;
  apInfo_t *paVar1;
  size_t sVar2;
  UINT8 *pPassphrase;
  
  paVar1 = cm_GetApInfo(connPtr);
  ROM_InitGTK(&(paVar1->bssData).grpKeyData,(paVar1->bssData).GNonce,connPtr->localMacAddr);
  if ((paVar1->bssData).updatePassPhrase == 1) {
    ssidLen = (connPtr->comData).SsIdLen;
    pPassphrase = (paVar1->bssConfig).RsnConfig.PSKPassPhrase;
    sVar2 = strlen((char *)pPassphrase);
    pmkCacheGeneratePSK((UINT8 *)&connPtr->comData,ssidLen,pPassphrase,(UINT8)sVar2,
                        (paVar1->bssConfig).RsnConfig.PSKValue);
    (paVar1->bssData).updatePassPhrase = 0;
  }
  return;
}



BufferDesc_t *
PrepDefaultEapolMsg(cm_ConnectionInfo_t *connPtr,EAPOL_KeyMsg_Tx_t **pTxEapolPtr,
                   BufferDesc_t *pBufDesc)

{
  apSpecificData_t *paVar1;
  apInfo_t *paVar2;
  BufferDesc_t *pBVar3;
  uint nonTKIP;
  EAPOL_KeyMsg_Tx_t *pEStack36;
  EAPOL_KeyMsg_Tx_t *tx_eapol_ptr;
  
  paVar1 = cm_GetApData(connPtr);
  paVar2 = cm_GetApInfo(connPtr);
  pBVar3 = GetTxEAPOLBuffer(connPtr,&pEStack36,pBufDesc);
  if (pBVar3 != (BufferDesc_t *)0x0) {
    memset(pEStack36,0,0x72);
    formEAPOLEthHdr(pEStack36,(IEEEtypes_MacAddr_t *)connPtr->peerMacAddr,
                    (IEEEtypes_MacAddr_t *)connPtr->localMacAddr);
    nonTKIP = 1;
    if (((byte)(paVar1->staData).keyMgmtInfo.rom.staUcstCipher & 8) == 0) {
      nonTKIP = (uint)((byte)(paVar2->bssConfig).RsnConfig.mcstCipher >> 3) & 1;
    }
    SetEAPOLKeyDescTypeVersion
              (pEStack36,*(uint *)&(paVar1->staData).keyMgmtInfo.rom >> 0x15 & 1,0,nonTKIP);
    *pTxEapolPtr = pEStack36;
  }
  return pBVar3;
}



// WARNING: Variable defined which should be unmapped: replay_cnt

Status_e GeneratePWKMsg1(cm_ConnectionInfo_t *connPtr,BufferDesc_t *pBufDesc)

{
  Status_e SVar1;
  apSpecificData_t *paVar2;
  BufferDesc_t *pBufDesc_00;
  uint uVar3;
  uint uVar4;
  UINT32 UVar5;
  EAPOL_KeyMsg_Tx_t *pEStack28;
  EAPOL_KeyMsg_Tx_t *tx_eapol_ptr;
  UINT32 replay_cnt [2];
  
  paVar2 = cm_GetApData(connPtr);
  pBufDesc_00 = PrepDefaultEapolMsg(connPtr,&pEStack28,pBufDesc);
  if (pBufDesc_00 == (BufferDesc_t *)0x0) {
    SVar1 = FAIL;
  }
  else {
    UVar5 = (paVar2->staData).keyMgmtInfo.counterLo + 1;
    (paVar2->staData).keyMgmtInfo.counterLo = UVar5;
    if (UVar5 == 0) {
      (paVar2->staData).keyMgmtInfo.counterHi = (paVar2->staData).keyMgmtInfo.counterHi + 1;
    }
    tx_eapol_ptr = (EAPOL_KeyMsg_Tx_t *)(paVar2->staData).keyMgmtInfo.counterHi;
    supplicantGenerateRand((UINT8 *)&connPtr->TxRxCipherKeyBuf,0x20);
    PopulateKeyMsg(pEStack28,&(paVar2->staData).keyMgmtInfo.rom.staUcstCipher,0x800,
                   (UINT32 *)&tx_eapol_ptr,(UINT8 *)&connPtr->TxRxCipherKeyBuf);
    uVar3 = (uint)(pEStack28->keyMsg).key_material_len + 0x5f;
    uVar4 = uVar3 & 0xffff;
    (pEStack28->keyMsg).hdr_8021x.protocol_ver = (paVar2->staData).keyMgmtInfo.EAPOLProtoVersion;
    (pEStack28->keyMsg).hdr_8021x.pckt_type = IEEE_8021X_PACKET_TYPE_EAPOL_KEY;
    *(char *)&(pEStack28->keyMsg).hdr_8021x.pckt_body_len = (char)(uVar4 >> 8);
    *(undefined *)((int)&(pEStack28->keyMsg).hdr_8021x.pckt_body_len + 1) = (char)uVar4;
    UpdateEAPOLWcbLenAndTransmit(pBufDesc_00,(UINT16)(uVar3 * 0x10000 >> 0x10));
    SVar1 = FW_SUCCESS;
  }
  return SVar1;
}



Status_e GeneratePWKMsg3(cm_ConnectionInfo_t *connPtr,BufferDesc_t *pBufDesc)

{
  SecurityMode_t SVar1;
  UINT16 frameLen;
  BufferDesc_t *pBufDesc_00;
  apSpecificData_t *paVar2;
  apInfo_t *paVar3;
  BOOLEAN BVar4;
  uint8_t *pWPA2;
  UINT32 UVar5;
  Cipher_t *Cipher;
  EAPOL_KeyMsg_Tx_t *pEStack44;
  EAPOL_KeyMsg_Tx_t *tx_eapol_ptr;
  UINT32 replay_cnt [2];
  
  pBufDesc_00 = PrepDefaultEapolMsg(connPtr,&pEStack44,pBufDesc);
  if (pBufDesc_00 != (BufferDesc_t *)0x0) {
    paVar2 = cm_GetApData(connPtr);
    paVar3 = cm_GetApInfo(connPtr);
    UVar5 = (paVar2->staData).keyMgmtInfo.counterLo + 1;
    (paVar2->staData).keyMgmtInfo.counterLo = UVar5;
    if (UVar5 == 0) {
      (paVar2->staData).keyMgmtInfo.counterHi = (paVar2->staData).keyMgmtInfo.counterHi + 1;
    }
    tx_eapol_ptr = (EAPOL_KeyMsg_Tx_t *)(paVar2->staData).keyMgmtInfo.counterHi;
    Cipher = &(paVar2->staData).keyMgmtInfo.rom.staUcstCipher;
    PopulateKeyMsg(pEStack44,Cipher,
                   ((ushort)(paVar2->staData).keyMgmtInfo.rom.staSecType & 0x20) << 10 | 0x880,
                   (UINT32 *)&tx_eapol_ptr,(UINT8 *)&connPtr->TxRxCipherKeyBuf);
    SVar1 = (paVar2->staData).keyMgmtInfo.rom.staSecType;
    pWPA2 = (uint8_t *)0x0;
    if ((((ushort)SVar1 & 8) == 0) && (((ushort)SVar1 & 0x20) != 0)) {
      pWPA2 = int_rsn_ie;
    }
    BVar4 = KeyData_UpdateKeyMaterial
                      (pEStack44,&(paVar2->staData).keyMgmtInfo.rom.staSecType,(void *)0x0,pWPA2);
    if (BVar4 != 0) {
      if (((ushort)(paVar2->staData).keyMgmtInfo.rom.staSecType & 0x20) == 0) {
LAB_230128b6:
        frameLen = KeyMgmtSta_PopulateEAPOLLengthMic
                             (pEStack44,(paVar2->staData).keyMgmtInfo.EAPOL_MIC_Key,
                              (paVar2->staData).keyMgmtInfo.EAPOLProtoVersion,
                              *(byte *)&(pEStack44->keyMsg).key_info.field_0x1 & 7);
        UpdateEAPOLWcbLenAndTransmit(pBufDesc_00,frameLen);
        return FW_SUCCESS;
      }
      prepareKDE(pEStack44,&(paVar3->bssData).grpKeyData,(Cipher_t *)&(paVar3->bssConfig).RsnConfig)
      ;
      BVar4 = Encrypt_keyData(pEStack44,(paVar2->staData).keyMgmtInfo.EAPOL_Encr_Key,Cipher);
      if (BVar4 != 0) goto LAB_230128b6;
    }
    vPortFree(pBufDesc_00->Buffer);
    vPortFree(pBufDesc_00);
  }
  return FAIL;
}



Status_e ProcessPWKMsg4(BufferDesc_t *pBufDesc)

{
  SecurityMode_t SVar1;
  cm_ConnectionInfo_t *connPtr;
  Status_e SVar2;
  apSpecificData_t *paVar3;
  BOOLEAN BVar4;
  
  connPtr = (cm_ConnectionInfo_t *)pBufDesc->intf;
  paVar3 = cm_GetApData(connPtr);
  BVar4 = IsEAPOL_MICValid((EAPOL_KeyMsg_t *)pBufDesc->Buffer,
                           (paVar3->staData).keyMgmtInfo.EAPOL_MIC_Key);
  if (BVar4 == 0) {
    SVar2 = FAIL;
  }
  else {
    (connPtr->TxRxCipherKeyBuf).cipher_key.ckd[0x44] = 1;
    (connPtr->TxRxCipherKeyBuf).cipher_key.ckd[0x45] = 0;
    (connPtr->TxRxCipherKeyBuf).cipher_key.ckd[0x40] = 0;
    (connPtr->TxRxCipherKeyBuf).cipher_key.ckd[0x41] = 0;
    (connPtr->TxRxCipherKeyBuf).cipher_key.ckd[0x42] = 0;
    (connPtr->TxRxCipherKeyBuf).cipher_key.ckd[0x43] = 0;
    add_key_to_mac(connPtr,'\x01');
    apm_sta_add(connPtr->staId);
    SVar1 = (paVar3->staData).keyMgmtInfo.rom.staSecType;
    (paVar3->staData).keyMgmtInfo.numHskTries = '\0';
    SVar2 = FW_SUCCESS;
    if (((ushort)SVar1 & 0x20) != 0) {
      (paVar3->staData).keyMgmtInfo.rom.keyMgmtState = HSK_END;
    }
  }
  return SVar2;
}



Status_e GenerateApEapolMsg(cm_ConnectionInfo_t *connPtr,keyMgmtState_e msgState,
                           BufferDesc_t *pBufDesc)

{
  IEEEtypes_PwrMgmtMode_e IVar1;
  uint uVar2;
  Status_e SVar3;
  apSpecificData_t *paVar4;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 in_register_0000202d;
  
  uVar2 = CONCAT31(in_register_0000202d,msgState);
  paVar4 = cm_GetApData(connPtr);
  if ((msgState & 1) == 0) {
    uVar2 = uVar2 - 1 & 0xff;
  }
  IVar1 = (paVar4->staData).pwrSaveInfo.mode;
  (paVar4->staData).keyMgmtInfo.rom.keyMgmtState = (keyMgmtState_e)uVar2;
  if (IVar1 != PWR_MODE_PWR_SAVE) {
    if (uVar2 == 1) {
      SVar3 = GeneratePWKMsg1(connPtr,pBufDesc);
      _SVar3 = CONCAT31(extraout_var,SVar3);
    }
    else {
      if (uVar2 != 3) {
        if (pBufDesc == (BufferDesc_t *)0x0) {
          return FAIL;
        }
        vPortFree(pBufDesc->Buffer);
        vPortFree(pBufDesc);
        return FAIL;
      }
      SVar3 = GeneratePWKMsg3(connPtr,pBufDesc);
      _SVar3 = CONCAT31(extraout_var_00,SVar3);
    }
    if (_SVar3 != 0) {
      return (Status_e)_SVar3;
    }
    (paVar4->staData).keyMgmtInfo.rom.keyMgmtState =
         (paVar4->staData).keyMgmtInfo.rom.keyMgmtState + MSG1_PENDING;
  }
  (paVar4->staData).keyMgmtInfo.numHskTries = (paVar4->staData).keyMgmtInfo.numHskTries + '\x01';
  return FW_SUCCESS;
}



Status_e ProcessPWKMsg2(BufferDesc_t *pBufDesc)

{
  cm_ConnectionInfo_t *connPtr;
  EAPOL_KeyMsg_t *pKeyMsg;
  Status_e SVar1;
  apSpecificData_t *paVar2;
  apInfo_t *paVar3;
  BOOLEAN BVar4;
  UINT8 *EAPOL_MIC_Key;
  BOOLEAN in_fa0;
  
  connPtr = (cm_ConnectionInfo_t *)pBufDesc->intf;
  paVar2 = cm_GetApData(connPtr);
  paVar3 = cm_GetApInfo(connPtr);
  pKeyMsg = (EAPOL_KeyMsg_t *)pBufDesc->Buffer;
  EAPOL_MIC_Key = (paVar2->staData).keyMgmtInfo.EAPOL_MIC_Key;
  KeyMgmtAp_DerivePTK((paVar3->bssConfig).RsnConfig.PSKValue,
                      (IEEEtypes_MacAddr_t *)connPtr->peerMacAddr,
                      (IEEEtypes_MacAddr_t *)(connPtr->comData).BssId,
                      (UINT8 *)&connPtr->TxRxCipherKeyBuf,pKeyMsg->key_nonce,EAPOL_MIC_Key,
                      (paVar2->staData).keyMgmtInfo.EAPOL_Encr_Key,
                      (KeyData_t *)((connPtr->TxRxCipherKeyBuf).cipher_key.ckd + 0x20),in_fa0);
  BVar4 = IsEAPOL_MICValid(pKeyMsg,EAPOL_MIC_Key);
  if (BVar4 != 0) {
    (paVar2->staData).keyMgmtInfo.numHskTries = '\0';
    rsn_len = pKeyMsg[1].hdr_8021x.protocol_ver + '\x02';
    SVar1 = GenerateApEapolMsg(connPtr,MSG3_PENDING,(BufferDesc_t *)0x0);
    return SVar1;
  }
  return FAIL;
}



BOOLEAN SendEAPOLMsgUsingBufDesc(cm_ConnectionInfo_t *connPtr,BufferDesc_t *pBufDesc)

{
  keyMgmtState_e msgState;
  bool bVar1;
  apSpecificData_t *paVar2;
  
  paVar2 = cm_GetApData(connPtr);
  msgState = (paVar2->staData).keyMgmtInfo.rom.keyMgmtState;
  bVar1 = (msgState & 1) != 0;
  if (bVar1) {
    GenerateApEapolMsg(connPtr,msgState,pBufDesc);
  }
  return (uint)bVar1;
}



// WARNING: Variable defined which should be unmapped: rxCounterLo

Status_e ProcessKeyMgmtDataAp(BufferDesc_t *pBufDesc)

{
  keyMgmtState_e kVar1;
  Status_e SVar2;
  apSpecificData_t *paVar3;
  void *pvVar4;
  uint uStack24;
  UINT32 rxCounterHi;
  UINT32 rxCounterLo;
  
  paVar3 = cm_GetApData((cm_ConnectionInfo_t *)pBufDesc->intf);
  pvVar4 = pBufDesc->Buffer;
  if ((*(byte *)((int)pvVar4 + 5) & 4) == 0) {
    memcpy(&uStack24,(void *)((int)pvVar4 + 9),4);
    memcpy(&rxCounterHi,(void *)((int)pvVar4 + 0xd),4);
    if (((paVar3->staData).keyMgmtInfo.counterHi ==
         (uStack24 >> 8 & 0xff00) +
         (uStack24 & 0xff00) * 0x100 + uStack24 * 0x1000000 + (uStack24 >> 0x18)) &&
       ((paVar3->staData).keyMgmtInfo.counterLo ==
        (rxCounterHi >> 8 & 0xff00) +
        rxCounterHi * 0x1000000 + (rxCounterHi >> 0x18) + (rxCounterHi & 0xff00) * 0x100)) {
      kVar1 = (paVar3->staData).keyMgmtInfo.rom.keyMgmtState;
      if (kVar1 == WAITING_4_MSG2) {
        SVar2 = ProcessPWKMsg2(pBufDesc);
        return SVar2;
      }
      if (kVar1 == WAITING_4_MSG4) {
        SVar2 = ProcessPWKMsg4(pBufDesc);
        return SVar2;
      }
    }
  }
  return FAIL;
}



void InitStaKeyInfo(void *pConn,SecurityMode_t *secType,Cipher_t *pwCipher,UINT16 staRsnCap,
                   UINT8 akmType)

{
  apKeyMgmtInfoSta_t *__s;
  apSpecificData_t *paVar1;
  
  paVar1 = cm_GetApData((cm_ConnectionInfo_t *)pConn);
  __s = &(paVar1->staData).keyMgmtInfo;
  memset(__s,0,0x48);
  InitKeyMgmtInfo((apKeyMgmtInfoStaRom_t *)__s,secType,pwCipher,staRsnCap,akmType);
  (paVar1->staData).keyMgmtInfo.EAPOLProtoVersion = '\x01';
  return;
}



void RemoveAPKeyInfo(void *pConn)

{
  if (*(uint8_t *)((int)pConn + 3) != -1) {
    mm_sec_machwkey_del(*(uint8_t *)((int)pConn + 3));
    return;
  }
  return;
}



void InitGroupKey(cm_ConnectionInfo_t *connPtr)

{
  uint8_t uVar1;
  apInfo_t *paVar2;
  int iVar3;
  undefined3 extraout_var;
  UINT32 UVar4;
  
  paVar2 = cm_GetApInfo(connPtr);
  (paVar2->bssData).grpRekeyBcnCntConfigured = 0;
  (paVar2->bssData).grpRekeyBcnCntRemaining = 0;
  KeyMgmtInit(connPtr);
  UVar4 = (paVar2->bssConfig).RsnConfig.GrpReKeyTime;
  if (UVar4 != 0) {
    iVar3 = UVar4 * 0x1e848 + -0x7d;
    __udivdi3();
    (paVar2->bssData).grpRekeyBcnCntConfigured = iVar3 + 1U;
    (paVar2->bssData).grpRekeyBcnCntRemaining = iVar3 + 1U;
  }
  uVar1 = add_key_to_mac(connPtr,'\0');
  connPtr->gtkHwKeyId = uVar1;
  printf("gtkHwKeyId is %d\r\n",CONCAT31(extraout_var,uVar1));
  return;
}



// WARNING: Variable defined which should be unmapped: inp_data

void GenerateGTK_internal(KeyData_t *grpKeyData,UINT8 *nonce,IEEEtypes_Addr_t *StaMacAddr)

{
  size_t prefix_len;
  uchar auStack140 [4];
  UINT8 prefix [20];
  UINT8 GTK [32];
  UINT8 grpMasterKey [32];
  UINT8 inp_data [38];
  
  memcpy(auStack140,"Group key expansion",0x14);
  if ((grpKeyData != (KeyData_t *)0x0) && (nonce != (UINT8 *)0x0)) {
    memcpy(grpMasterKey + 0x1c,StaMacAddr,6);
    supplicantGenerateRand(nonce,0x20);
    memcpy(inp_data + 2,nonce,0x20);
    supplicantGenerateRand(GTK + 0x1c,0x20);
    prefix_len = strlen((char *)auStack140);
    Bl_PRF(GTK + 0x1c,0x20,auStack140,prefix_len,grpMasterKey + 0x1c,0x26,prefix + 0x10,0x20);
    memcpy(grpKeyData,prefix + 0x10,0x10);
    memcpy(grpKeyData->TxMICKey,GTK + 0xc,8);
    memcpy(grpKeyData->RxMICKey,GTK + 0x14,8);
  }
  return;
}



void PopulateKeyMsg(EAPOL_KeyMsg_Tx_t *tx_eapol_ptr,Cipher_t *Cipher,UINT16 Type,UINT32 *replay_cnt,
                   UINT8 *Nonce)

{
  byte bVar1;
  undefined2 in_register_00002032;
  int iVar2;
  undefined uVar3;
  byte bVar4;
  uint uVar5;
  
  uVar5 = CONCAT22(in_register_00002032,Type);
  if ((tx_eapol_ptr == (EAPOL_KeyMsg_Tx_t *)0x0) || (Cipher == (Cipher_t *)0x0)) {
    return;
  }
  if (((byte)*Cipher & 4) == 0) {
    if (((byte)*Cipher & 8) != 0) {
      *(undefined *)&(tx_eapol_ptr->keyMsg).key_length = 0;
      uVar3 = 0x10;
      goto LAB_23012cc4;
    }
  }
  else {
    *(undefined *)&(tx_eapol_ptr->keyMsg).key_length = 0;
    uVar3 = 0x20;
LAB_23012cc4:
    *(undefined *)((int)&(tx_eapol_ptr->keyMsg).key_length + 1) = uVar3;
  }
  bVar1 = *(byte *)&(tx_eapol_ptr->keyMsg).key_info.field_0x1;
  *(byte *)&(tx_eapol_ptr->keyMsg).key_info.field_0x1 = bVar1 | 0x80;
  if ((int)(uVar5 << 0x14) < 0) {
    *(byte *)&(tx_eapol_ptr->keyMsg).key_info.field_0x1 = bVar1 | 0x88;
    if ((Type & 0x80) == 0) goto LAB_23012d0e;
    bVar4 = *(byte *)&(tx_eapol_ptr->keyMsg).key_info;
    *(byte *)&(tx_eapol_ptr->keyMsg).key_info.field_0x1 = bVar1 | 200;
    bVar4 = bVar4 & 0xed | 1 | (byte)((uVar5 >> 0xf) << 1);
    bVar1 = (byte)((uVar5 >> 0xf) << 4);
  }
  else {
    bVar1 = (byte)((uVar5 >> 0xf) << 4);
    bVar4 = *(byte *)&(tx_eapol_ptr->keyMsg).key_info & 0xec | 3;
  }
  *(byte *)&(tx_eapol_ptr->keyMsg).key_info = bVar1 | bVar4;
LAB_23012d0e:
  uVar5 = *replay_cnt;
  iVar2 = uVar5 * 0x1000000 + (uVar5 >> 0x18) + (uVar5 & 0xff00) * 0x100 + (uVar5 >> 8 & 0xff00);
  *(char *)(tx_eapol_ptr->keyMsg).replay_cnt = (char)iVar2;
  *(undefined *)((int)(tx_eapol_ptr->keyMsg).replay_cnt + 1) = (char)((uint)iVar2 >> 8);
  *(undefined *)((int)(tx_eapol_ptr->keyMsg).replay_cnt + 2) = (char)((uint)iVar2 >> 0x10);
  *(undefined *)((int)(tx_eapol_ptr->keyMsg).replay_cnt + 3) = (char)((uint)iVar2 >> 0x18);
  uVar5 = replay_cnt[1];
  iVar2 = uVar5 * 0x1000000 + (uVar5 >> 0x18) + (uVar5 & 0xff00) * 0x100 + (uVar5 >> 8 & 0xff00);
  *(char *)((tx_eapol_ptr->keyMsg).replay_cnt + 1) = (char)iVar2;
  *(undefined *)((int)(tx_eapol_ptr->keyMsg).replay_cnt + 5) = (char)((uint)iVar2 >> 8);
  *(undefined *)((int)(tx_eapol_ptr->keyMsg).replay_cnt + 6) = (char)((uint)iVar2 >> 0x10);
  *(undefined *)((int)(tx_eapol_ptr->keyMsg).replay_cnt + 7) = (char)((uint)iVar2 >> 0x18);
  memcpy((tx_eapol_ptr->keyMsg).key_nonce,Nonce,0x20);
  return;
}



void prepareKDE(EAPOL_KeyMsg_Tx_t *tx_eapol_ptr,KeyData_t *grKey,Cipher_t *cipher)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  UINT8 *pUVar4;
  UINT8 *__dest;
  
  if (tx_eapol_ptr != (EAPOL_KeyMsg_Tx_t *)0x0) {
    if ((grKey != (KeyData_t *)0x0) && (cipher != (Cipher_t *)0x0)) {
      pUVar4 = (tx_eapol_ptr->keyMsg).key_data + *(byte *)&(tx_eapol_ptr->keyMsg).key_material_len;
      *pUVar4 = -0x23;
      pUVar4[1] = '\x16';
      pUVar4[2] = '\0';
      pUVar4[3] = '\x0f';
      pUVar4[4] = -0x54;
      pUVar4[5] = '\x01';
      pUVar4[6] = pUVar4[6] & 0xfc | 1;
      memcpy(pUVar4 + 8,grKey,0x10);
      __dest = pUVar4 + 0x18;
      if (((byte)*cipher & 4) != 0) {
        pUVar4[1] = pUVar4[1] + '\x10';
        memcpy(__dest,grKey->TxMICKey,8);
        memcpy(pUVar4 + 0x20,grKey->RxMICKey,8);
        __dest = pUVar4 + 0x28;
      }
      uVar1 = (uint)(tx_eapol_ptr->keyMsg).key_material_len + 2 + (uint)pUVar4[1];
      uVar2 = uVar1 & 0xffff;
      *(char *)&(tx_eapol_ptr->keyMsg).key_material_len = (char)(uVar1 * 0x10000 >> 0x10);
      *(undefined *)((int)&(tx_eapol_ptr->keyMsg).key_material_len + 1) = (char)(uVar2 >> 8);
      uVar1 = -uVar2 & 7;
      if (uVar1 != 0) {
        *__dest = -0x23;
        memset(__dest + 1,0,uVar1 - 1);
        iVar3 = uVar1 + (tx_eapol_ptr->keyMsg).key_material_len;
        *(char *)&(tx_eapol_ptr->keyMsg).key_material_len = (char)((uint)(iVar3 * 0x10000) >> 0x10);
        *(undefined *)((int)&(tx_eapol_ptr->keyMsg).key_material_len + 1) = (char)((uint)iVar3 >> 8)
        ;
      }
    }
    return;
  }
  return;
}



BOOLEAN Encrypt_keyData(EAPOL_KeyMsg_Tx_t *tx_eapol_ptr,UINT8 *EAPOL_Encr_Key,Cipher_t *cipher)

{
  void *pv;
  UINT8 *cipher_00;
  uint uVar1;
  uint __n;
  UINT8 *plain;
  UINT8 aUStack48 [4];
  UINT8 key [16];
  
  if (((tx_eapol_ptr != (EAPOL_KeyMsg_Tx_t *)0x0) && (EAPOL_Encr_Key != (UINT8 *)0x0)) &&
     (cipher != (Cipher_t *)0x0)) {
    if (((byte)*cipher & 8) == 0) {
      return (uint)((byte)*cipher >> 2) & 1;
    }
    pv = pvPortMalloc(0xc);
    if (pv != (void *)0x0) {
      cipher_00 = (UINT8 *)pvPortMalloc(400);
      *(UINT8 **)((int)pv + 8) = cipher_00;
      if (cipher_00 != (UINT8 *)0x0) {
        memcpy(aUStack48,EAPOL_Encr_Key,0x10);
        plain = (tx_eapol_ptr->keyMsg).key_data;
        BL_AesWrap(aUStack48,'\x02',(uint)((tx_eapol_ptr->keyMsg).key_material_len >> 3),plain,
                   (UINT8 *)0x0,cipher_00);
        uVar1 = (uint)(tx_eapol_ptr->keyMsg).key_material_len + 8;
        __n = uVar1 & 0xffff;
        *(char *)&(tx_eapol_ptr->keyMsg).key_material_len = (char)(uVar1 * 0x10000 >> 0x10);
        *(undefined *)((int)&(tx_eapol_ptr->keyMsg).key_material_len + 1) = (char)(__n >> 8);
        memcpy(plain,cipher_00,__n);
        vPortFree(*(void **)((int)pv + 8));
        vPortFree(pv);
        return 1;
      }
    }
    return 0;
  }
  return 0;
}



void KeyMgmtAp_DerivePTK(UINT8 *pPMK,IEEEtypes_MacAddr_t *da,IEEEtypes_MacAddr_t *sa,UINT8 *ANonce,
                        UINT8 *SNonce,UINT8 *EAPOL_MIC_Key,UINT8 *EAPOL_Encr_Key,KeyData_t *newPWKey
                        ,BOOLEAN use_kdf)

{
  undefined auStack24 [4];
  UINT8 tmp [8];
  
  KeyMgmtSta_DeriveKeys(pPMK,da,sa,ANonce,SNonce,EAPOL_MIC_Key,EAPOL_Encr_Key,newPWKey,use_kdf);
  memcpy(auStack24,newPWKey->RxMICKey,8);
  memcpy(newPWKey->RxMICKey,newPWKey->TxMICKey,8);
  memcpy(newPWKey->TxMICKey,auStack24,8);
  return;
}



BOOLEAN KeyData_CopyWPAWP2(EAPOL_KeyMsg_Tx_t *pTxEAPOL,void *pIe)

{
  size_t __n;
  
  if (pIe != (void *)0x0) {
    __n = (uint)*(byte *)((int)pIe + 1) + 2;
    *(char *)&(pTxEAPOL->keyMsg).key_material_len = (char)__n;
    *(undefined *)((int)&(pTxEAPOL->keyMsg).key_material_len + 1) = (char)(__n >> 8);
    memcpy((pTxEAPOL->keyMsg).key_data,pIe,__n);
    return 1;
  }
  return 0;
}



BOOLEAN KeyData_UpdateKeyMaterial
                  (EAPOL_KeyMsg_Tx_t *pTxEAPOL,SecurityMode_t *pSecType,void *pWPA,void *pWPA2)

{
  BOOLEAN BVar1;
  uint uVar2;
  
  if (((*(byte *)pSecType & 0x18) != 0) ||
     (uVar2 = 1, pWPA = pWPA2, (*(byte *)pSecType & 0x20) != 0)) {
    BVar1 = KeyData_CopyWPAWP2(pTxEAPOL,pWPA);
    uVar2 = (uint)(BVar1 != 0);
  }
  return uVar2;
}



void ROM_InitGTK(KeyData_t *grpKeyData,UINT8 *nonce,IEEEtypes_Addr_t *StaMacAddr)

{
  grpKeyData->TxIV32 = 0;
  *(undefined4 *)&grpKeyData->TxIV16 = 0x10001;
  GenerateGTK_internal(grpKeyData,nonce,StaMacAddr);
  return;
}



void InitKeyMgmtInfo(apKeyMgmtInfoStaRom_t *pKeyMgmtInfo,SecurityMode_t *secType,Cipher_t *pwCipher,
                    UINT16 staRsnCap,UINT8 akmType)

{
  pKeyMgmtInfo->keyMgmtState = MSG1_PENDING;
  memcpy(&pKeyMgmtInfo->staSecType,secType,2);
  memcpy(&pKeyMgmtInfo->staUcstCipher,pwCipher,1);
  pKeyMgmtInfo->staAkmType = akmType;
  if ((*(byte *)secType & 0x20) != 0) {
    pKeyMgmtInfo->staRsnCap = staRsnCap;
  }
  return;
}



apInfo_t * cm_GetApInfo(cm_ConnectionInfo_t *connPtr)

{
  if (connPtr != (cm_ConnectionInfo_t *)0x0) {
    if (connPtr->conType == '\x02') {
      return *(apInfo_t **)connPtr->specDat;
    }
    connPtr = (cm_ConnectionInfo_t *)0x0;
  }
  return (apInfo_t *)connPtr;
}



apSpecificData_t * cm_GetApData(cm_ConnectionInfo_t *connPtr)

{
  if (connPtr != (cm_ConnectionInfo_t *)0x0) {
    if (connPtr->conType == '\x02') {
      return (apSpecificData_t *)connPtr->specDat;
    }
    connPtr = (cm_ConnectionInfo_t *)0x0;
  }
  return (apSpecificData_t *)connPtr;
}



Status_e cm_AllocAPResources(cm_ConnectionInfo_t *connPtr)

{
  apSpecificData_t *paVar1;
  BufferDesc_t *pBVar2;
  void *pvVar3;
  
  paVar1 = cm_GetApData(connPtr);
  if (paVar1->apInfoBuffDesc == (BufferDesc_t *)0x0) {
    pBVar2 = (BufferDesc_t *)pvPortMalloc(0xc);
    if (pBVar2 == (BufferDesc_t *)0x0) {
      return FAIL;
    }
    pvVar3 = pvPortMalloc(0x120);
    pBVar2->Buffer = pvVar3;
    paVar1->apInfoBuffDesc = pBVar2;
    paVar1->apInfo = (apInfo_t *)pBVar2->Buffer;
    InitializeAp(connPtr);
  }
  return FW_SUCCESS;
}



Status_e cm_AllocResources(cm_ConnectionInfo_t *connPtr)

{
  Status_e SVar1;
  
  if (connPtr->conType == '\x02') {
    SVar1 = cm_AllocAPResources(connPtr);
    return SVar1;
  }
  return FW_SUCCESS;
}



cm_ConnectionInfo_t *
cm_InitConnection(UINT8 conType,UINT8 bssType,UINT8 bssNum,IEEEtypes_MacAddr_t *bssId,
                 IEEEtypes_MacAddr_t *peerMacAddr,UINT8 channel,unkbyte0 *hostMdev)

{
  cm_ConnectionInfo_t *connPtr;
  Status_e SVar1;
  undefined3 extraout_var;
  IEEEtypes_Addr_t *__s;
  
  connPtr = (cm_ConnectionInfo_t *)pvPortMalloc(0xec);
  if (connPtr != (cm_ConnectionInfo_t *)0x0) {
    memset(connPtr,0,0xec);
    connPtr->conType = conType;
    SVar1 = cm_AllocResources(connPtr);
    if (CONCAT31(extraout_var,SVar1) == 1) {
      vPortFree(connPtr);
      connPtr = (cm_ConnectionInfo_t *)0x0;
    }
    else {
      if (peerMacAddr != (IEEEtypes_MacAddr_t *)0x0) {
        memcpy(connPtr->peerMacAddr,peerMacAddr,6);
      }
      __s = (connPtr->comData).BssId;
      memset(__s,0,6);
      memset(&connPtr->comData,0,0x20);
      (connPtr->comData).SsIdLen = '\0';
      if (bssId != (IEEEtypes_MacAddr_t *)0x0) {
        memcpy(__s,bssId,6);
        memcpy(connPtr->localMacAddr,bssId,6);
      }
    }
  }
  return connPtr;
}



void cm_DeleteConnection(cm_ConnectionInfo_t *connPtr)

{
  apSpecificData_t *paVar1;
  
  if (connPtr->conType == '\x02') {
    paVar1 = cm_GetApData(connPtr);
    if (paVar1->apInfoBuffDesc != (BufferDesc_t *)0x0) {
      vPortFree(paVar1->apInfoBuffDesc->Buffer);
      vPortFree(paVar1->apInfoBuffDesc);
      paVar1->apInfoBuffDesc = (BufferDesc_t *)0x0;
      paVar1->apInfo = (apInfo_t *)0x0;
    }
  }
  vPortFree(connPtr);
  return;
}



void cm_SetPeerAddr(cm_ConnectionInfo_t *connPtr,IEEEtypes_MacAddr_t *bssId,
                   IEEEtypes_MacAddr_t *peerMacAddr)

{
  if (bssId != (IEEEtypes_MacAddr_t *)0x0) {
    memcpy((connPtr->comData).BssId,bssId,6);
  }
  if (peerMacAddr != (IEEEtypes_MacAddr_t *)0x0) {
    memcpy(connPtr->peerMacAddr,peerMacAddr,6);
    return;
  }
  return;
}



void cm_SetComData(cm_ConnectionInfo_t *connPtr,char *ssid)

{
  byte bVar1;
  size_t sVar2;
  
  if (ssid != (char *)0x0) {
    sVar2 = strlen(ssid);
    (connPtr->comData).SsIdLen = (IEEEtypes_Len_t)sVar2;
    memcpy(&connPtr->comData,ssid,0x20);
    bVar1 = (connPtr->comData).SsIdLen;
    if (bVar1 < 0x20) {
      (connPtr->comData).SsId[bVar1] = '\0';
    }
    return;
  }
  return;
}


/*
Unable to decompile 'assert_rec'
Cause: Exception while decompiling 2301323e: Decompiler process died

*/


void assert_err(char *condition,char *file,int line)

{
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void assert_warn(char *condition,char *file,int line)

{
  return;
}



void coex_dump_pta(void)

{
  return;
}



void coex_dump_wifi(void)

{
  return;
}



void coex_wifi_rf_forece_enable(int enable)

{
  if (enable != 0) {
    enable = 1;
  }
  rfc_coex_force_to(enable,0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void coex_wifi_pti_forece_enable(int enable)

{
  if (enable == 0) {
    _DAT_44b00400 = _DAT_44b00400 & 0xffffffef;
  }
  else {
    _DAT_44b00400 = _DAT_44b00400 | 0xf0000010;
  }
  if ((int)(_DAT_44b00400 << 4) < 0) {
    _DAT_44b00400 = _DAT_44b00400 & 0xfbffffff;
  }
  else {
    _DAT_44b00400 = _DAT_44b00400 & 0xfbffffff | 0x4000000;
  }
  return;
}


/*
Unable to decompile 'coex_wifi_pta_forece_enable'
Cause: Exception while decompiling 230132f8: Decompiler process died

*/


// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void wifi_main(void)

{
  int iVar1;
  uint uVar2;
  
  rfc_init(40000000);
  _DAT_44b00400 = _DAT_44b00400 | 1;
  mpif_clk_init();
  sysctrl_init();
  intc_init();
  ipc_emb_init();
  bl_init();
  _DAT_44b00404 = 0x24f037;
  _DAT_44b00400 = 0x49;
  _DAT_44920004 = 0x5010001f;
  do {
    if (_DAT_44b00120 << 0xc < 0) {
      _DAT_44900084 = _DAT_44900084 | 1;
    }
    else {
      _DAT_44900084 = _DAT_44900084 & 0xfffffffe;
    }
    if (ke_env.evt_field == 0) {
      ipc_emb_wait();
    }
    if ((packets_num_12624 & 0xf) == 0) {
      uVar2 = _DAT_40007018 >> 0x18 & 7;
      if (uVar2 != 0) {
        if (uVar2 != 3) {
          _DAT_40000014 = _DAT_40000014 | 0x40000;
        }
        if ((uVar2 != 0) && (uVar2 != 3)) {
          _DAT_40002040 = _DAT_40002040 & 0xfffffffc;
          _DAT_40002044 = _DAT_40002044 & 0xfffffffe;
        }
      }
      if ((_DAT_40007018 >> 0x18 & 4) != 0) {
        _DAT_40000014 = _DAT_40000014 | 0x5c2000;
        _DAT_4000f90c = _DAT_4000f90c & 0xfffffffe | 4;
      }
    }
    packets_num_12624 = packets_num_12624 + 1;
    ke_evt_schedule();
    iVar1 = bl_sleep();
    coex_wifi_pta_forece_enable((uint)(iVar1 == 0));
  } while( true );
}



void ipc_emb_notify(void)

{
  BaseType_t BStack20;
  BaseType_t xHigherPriorityTaskWoken;
  
  if (xTaskToNotify == (TaskHandle_t)0x0) {
    assert_err("NULL != xTaskToNotify","module",0x93);
  }
  if (TrapNetCounter == 0) {
    xTaskGenericNotify(xTaskToNotify,0,eIncrement,(uint32_t *)0x0);
  }
  else {
    vTaskNotifyGiveFromISR(xTaskToNotify,&BStack20);
    if (BStack20 != 0) {
      vTaskSwitchContext();
    }
  }
  return;
}



void ipc_emb_wait(void)

{
  ulTaskNotifyTake(1,0xffffffff);
  ipc_emb_counter = ipc_emb_counter + 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_emb_init(void)

{
  xTaskToNotify = xTaskGetCurrentTaskHandle();
  memset(&ipc_emb_env,0,0x20);
  ipc_emb_env.txdesc = ipc_shared_env.txdesc0;
  if (_DAT_44800140 != 0x49504332) {
    assert_err("ipc_emb_signature_get() == IPC_EMB_SIGNATURE_RESET","module",0xbb);
  }
  _DAT_4480010c = 0x1f03;
  _DAT_44800114 = 0x3ff2a04;
  _DAT_44800118 = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_emb_tx_irq(void)

{
  uint uVar1;
  
  uVar1 = _DAT_4480011c & 0x1f00;
  if (uVar1 != 0) {
    ke_evt_set(uVar1 >> 1);
    _DAT_44800108 = uVar1;
    _DAT_44800110 = uVar1;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_emb_tx_evt(int queue_idx)

{
  txdesc_host *ptVar1;
  txdesc_host *ptVar2;
  hostdesc *phVar3;
  hostdesc *phVar4;
  uint event;
  hostdesc *__s;
  
  event = ipc_emb_evt_bit[queue_idx];
  ke_evt_clear(event);
  ptVar1 = ipc_emb_env.txdesc;
  while( true ) {
    ptVar2 = ptVar1 + (ipc_emb_env.txdesc_idx & 3);
    if (ptVar2->ready != 0xffffffff) {
      _DAT_4480010c = 0x100;
      return;
    }
    if (((event & 0x800) == 0) && ((ke_env.evt_field & 0x440800) != 0)) break;
    __s = (hostdesc *)ptVar2->pad_txdesc;
    _DAT_44800108 = 0x100;
    memset(__s,0,0x2cc);
    *(uint32_t **)(ptVar2->pad_txdesc + 0x1c) = ptVar2->pad_txdesc + 0x2e;
    *(uint32_t **)(ptVar2->pad_txdesc + 0x1b) = ptVar2->pad_txdesc + 0x1c;
    phVar3 = &ptVar2->host;
    do {
      phVar4 = (hostdesc *)&phVar3->packet_addr;
      phVar3[1].packet_addr = phVar3->pbuf_addr;
      phVar3 = phVar4;
    } while (__s != phVar4);
    ptVar2->pad_txdesc[0x19] = 0;
    *(undefined4 *)(*(int *)ptVar2->pad_txdesc[0x1b] + 0x10) = 0;
    ptVar2->pad_txdesc[0x27] = 0;
    ptVar2->pad_txdesc[0x28] = 0;
    ptVar2->pad_txdesc[0x29] = 0;
    ptVar2->pad_txdesc[0x15] = 0;
    txu_cntrl_push(__s,0);
    ptVar2->ready = 1;
    ipc_emb_env.txdesc_idx = ipc_emb_env.txdesc_idx + 1;
  }
  ke_evt_set(event);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_emb_cfmback_irq(void)

{
  uint uVar1;
  
  uVar1 = _DAT_4480011c;
  if ((_DAT_4480011c & 0x20) != 0) {
    _DAT_44800110 = 0x20;
    _DAT_44800108 = 0x20;
    ke_evt_set(0x40000);
  }
  if ((uVar1 & 0x10) != 0) {
    _DAT_44800110 = 0x10;
    _DAT_44800108 = 0x10;
    ke_evt_set(0x80000);
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_emb_txcfm_ind(uint32_t queue_bits)

{
  _DAT_44800100 = queue_bits << 7;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_emb_msg_irq(void)

{
  if ((_DAT_4480011c & 2) != 0) {
    ke_evt_set(0x2000000);
    _DAT_44800110 = 2;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_emb_msg_evt(void)

{
  undefined4 *puVar1;
  uint8_t uVar2;
  undefined4 *puVar3;
  undefined4 *puVar4;
  int iVar5;
  
  do {
    if ((_DAT_44800104 & 2) == 0) {
      ke_evt_clear(0x2000000);
      _DAT_4480010c = 2;
      return;
    }
    _DAT_44800108 = 2;
    puVar1 = (undefined4 *)ke_malloc((uint)ipc_shared_env.msg_a2e_buf.msg[1]._2_2_ + 0xc);
    if (puVar1 == (undefined4 *)0x0) {
      assert_err("kmsg_dst != NULL","module",0x1d9);
    }
    *puVar1 = 0;
    *(undefined2 *)(puVar1 + 1) = (undefined2)ipc_shared_env.msg_a2e_buf.msg[0];
    *(undefined2 *)((int)puVar1 + 6) = ipc_shared_env.msg_a2e_buf.msg[0]._2_2_;
    *(undefined2 *)(puVar1 + 2) = 0xd;
    *(ushort *)((int)puVar1 + 10) = ipc_shared_env.msg_a2e_buf.msg[1]._2_2_;
    iVar5 = 0xc;
    while (iVar5 + -0xc < (int)(uint)*(ushort *)((int)puVar1 + 10)) {
      puVar3 = (undefined4 *)((int)&ipc_shared_env.msg_a2e_buf.dummy_word + iVar5);
      puVar4 = (undefined4 *)((int)puVar1 + iVar5);
      iVar5 = iVar5 + 4;
      *puVar4 = *puVar3;
    }
    uVar2 = ipc_emb_env.ipc_msgacke2a_cnt + '\x01';
    ipc_shared_env.msg_a2e_buf.msg[1]._0_2_ = (ushort)ipc_emb_env.ipc_msgacke2a_cnt;
    ipc_emb_env.ipc_msgacke2a_cnt = uVar2;
    if (*(ushort *)((int)puVar1 + 6) < 0xf) {
      if (0xc < *(ushort *)((int)puVar1 + 6)) goto LAB_2301395c;
    }
    else {
      assert_err("id <= TASK_MAX","module",0xb6);
LAB_2301395c:
      assert_err("ke_task_local(kmsg_dst->dest_id)","module",0x1ed);
    }
    _DAT_44800100 = 4;
    ke_msg_send(puVar1 + 3);
  } while( true );
}



void ipc_emb_msg_dma_int_handler(void)

{
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_emb_dbg_dma_int_handler(void)

{
  _DAT_44800100 = 1;
  _DAT_44a00020 = 0x80;
  return;
}



void ipc_emb_dump(void)

{
  return;
}



void rf_set_channel(uint8_t bandwidth,uint16_t channel_freq)

{
  undefined2 in_register_0000202e;
  
  rfc_config_channel(CONCAT22(in_register_0000202e,channel_freq));
  return;
}



void rf_dump_status(void)

{
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mdm_txcbwmax_setf(uint8_t txcbwmax)

{
  if ((txcbwmax & 0xfc) != 0) {
    assert_err("(((uint32_t)txcbwmax << 24) & ~((uint32_t)0x03000000)) == 0","module",0xb58);
  }
  _DAT_44c00824 = _DAT_44c00824 & 0xfcffffff | (uint)txcbwmax << 0x18;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void phy_config_rxgain(int offset)

{
  if ((int)rxgain_offset_vs_temperature != offset) {
    rxgain_offset_vs_temperature = (int8_t)offset;
    _DAT_44c0c080 =
         ((int)rxgain_offset_vs_temperature + 0x19) * 0x1000000 |
         ((int)rxgain_offset_vs_temperature + 0x12) * 0x10000 & 0xff0000U |
         ((int)rxgain_offset_vs_temperature + 0xb) * 0x100 & 0xffffU |
         (int)rxgain_offset_vs_temperature + 3U & 0xff;
    _DAT_44c0c084 =
         ((int)rxgain_offset_vs_temperature + 0x35) * 0x1000000 |
         ((int)rxgain_offset_vs_temperature + 0x2d) * 0x10000 & 0xff0000U |
         ((int)rxgain_offset_vs_temperature + 0x27) * 0x100 & 0xffffU |
         (int)rxgain_offset_vs_temperature + 0x20U & 0xff;
    _DAT_44c0c088 = (int)rxgain_offset_vs_temperature + 0x3bU & 0xff | _DAT_44c0c088 & 0xffffff00;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void agc_config(void)

{
  _ACG_RWNXAGCCNTL = _ACG_RWNXAGCCNTL & 0xfffefbff;
  _DAT_44c0b3a4 = _DAT_44c0b3a4 & 0xffff0000;
  _DAT_44c0b394 = _DAT_44c0b394 & 0xff00ffff | 0xf80000;
  _DAT_44c0b398 = _DAT_44c0b398 & 0xffff00ff | 0x9e00;
  _DAT_44c0b3c4 = _DAT_44c0b3c4 & 0xffffff00 | 0xce;
  _DAT_44c0b364 = _DAT_44c0b364 & 0xe0c0c0c0 | 0x83c3839;
  _DAT_44c0b368 = _DAT_44c0b368 & 0xffc00c00 | 0x70070;
  _DAT_44c0b36c = _DAT_44c0b36c & 0xf800f800 | 0x7280512;
  _DAT_44c0b370 = _DAT_44c0b370 & 0xff80ffff | 0x580000;
  _DAT_44c0b3c0 = _DAT_44c0b3c0 & 0xffffff | 0x18000000;
  _DAT_44c0b380 = _DAT_44c0b380 & 0x3ff | 0x77f8400;
  _DAT_44c0b384 = _DAT_44c0b384 & 0x3ff | 0xe7750800;
  _DAT_44c0b388 = _DAT_44c0b388 & 0x3ff | 0x3d7a9400;
  _DAT_44c0b38c = _DAT_44c0b38c & 0x23ff | 0x64038800;
  _DAT_44c0c830 = _DAT_44c0c830 & 0x23ff | 0xfc1d9400;
  _DAT_44c0c814 = _DAT_44c0c814 & 0xffffffc0 | 8;
  _DAT_44c0c040 = _DAT_44c0c040 & 0xfe007fff | 0xc18000;
  _DAT_44c0c044 = _DAT_44c0c044 & 0xffff0000 | 0x800;
  phy_config_rxgain(0);
  _DAT_44c0b3a0 = _DAT_44c0b3a0 & 0xffffff00 | 0x9e;
  _DAT_44c0b3c0 = _DAT_44c0b3c0 & 0xffff0000 | 0xa3a4;
  _DAT_44c0c82c = _DAT_44c0c82c & 0xff007700 | 0x2009b5;
  _DAT_44c0c838 = _DAT_44c0c838 & 0x7ff80000 | 0x80000100;
  _DAT_44c0c83c = _DAT_44c0c83c & 0x7ff00000 | 0x8000017c;
  _DAT_44c0c840 = _DAT_44c0c840 & 0x7fc00000 | 0x80000100;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mdm_reset(void)

{
  _DAT_44c00888 = 0;
  return;
}



void phy_powroffset_set(int8_t *power_offset)

{
  int8_t *piVar1;
  int8_t *piVar2;
  int iVar3;
  
  iVar3 = 0;
  do {
    piVar1 = power_offset + iVar3;
    piVar2 = poweroffset + iVar3;
    iVar3 = iVar3 + 1;
    *piVar2 = *piVar1;
  } while (iVar3 != 0xe);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void phy_hw_set_channel(uint8_t band,uint16_t freq,uint16_t freq1,uint8_t chantype)

{
  uint8_t channel;
  undefined3 in_register_00002029;
  int iVar1;
  undefined2 in_register_0000202e;
  int iVar2;
  undefined3 in_register_00002035;
  
  iVar2 = CONCAT22(in_register_0000202e,freq);
  iVar1 = CONCAT31(in_register_00002029,band);
  if (CONCAT31(in_register_00002035,chantype) != 0) {
    assert_err("chantype == PHY_CHNL_BW_20","module",0x144);
  }
  if (iVar1 != 0) {
    assert_err("band == PHY_BAND_2G4","module",0x145);
  }
  _ACG_RWNXAGCCNTL = _ACG_RWNXAGCCNTL & 0xfffffeff;
  __DATA_44c00820 = __DATA_44c00820 | 1;
  __DATA_44c00800 = 0;
  mdm_reset();
  _DAT_44c00838 = 0xb4;
  _DAT_44c0088c = 0x1c13;
  _DAT_44c00898 = 0x2d00438;
  _DAT_44c00858 = _DAT_44c00858 & 0xffffff00;
  _DAT_44c0081c = 0xf07;
  _DAT_44c00834 = _DAT_44c00834 & 0xffffff | 0x6000000;
  _DAT_44c00818 = 0x1880c06;
  _DAT_44c00860 = 0x7f03;
  _DAT_44c0b340 = 0;
  _DAT_44c0b344 = 0;
  _DAT_44c0b348 = 0;
  mdm_txcbwmax_setf(chantype);
  if (_DAT_44c0b000 << 10 < 0) {
    _DAT_44c0b118 = 1;
  }
  rf_set_channel(chantype,freq1);
  if (iVar1 == 0) {
    channel = '\0';
    if ((0x48 < (iVar2 - 0x96cU & 0xffff)) || (channel = '\x0e', iVar2 == 0x9b4)) goto LAB_230140e2;
    iVar1 = -0x967;
  }
  else {
    channel = '\0';
    if ((iVar1 != 1) || (channel = '\0', 0x334 < (iVar2 - 0x138dU & 0xffff))) goto LAB_230140e2;
    iVar1 = -5000;
  }
  channel = (uint8_t)((iVar2 + iVar1) / 5);
LAB_230140e2:
  rfc_apply_tx_power_offset(channel,poweroffset);
  trpc_update_vs_channel((int8_t)freq1);
  return;
}



void phy_get_channel(phy_channel_info *info,uint8_t index)

{
  info->info1 = (uint)phy_env[0].chnl_type << 8 | (uint)phy_env[0].chnl_prim20_freq << 0x10 |
                (uint)phy_env[0].band;
  info->info2 = phy_env[0]._6_4_;
  return;
}



void phy_set_channel(uint8_t band,uint8_t type,uint16_t prim20_freq,uint16_t center1_freq,
                    uint16_t center2_freq,uint8_t index)

{
  undefined3 in_register_00002029;
  
  if ((((ushort)(center1_freq - 0x96c) < 0x49) || (CONCAT31(in_register_00002029,band) != 0)) &&
     (CONCAT31(in_register_00002029,band) < 2)) {
    phy_hw_set_channel(band,prim20_freq,center1_freq,type);
    phy_env[0].chnl_prim20_freq = prim20_freq;
    phy_env[0].chnl_center1_freq = center1_freq;
    phy_env[0].band = band;
    phy_env[0].chnl_type = type;
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void phy_get_version(uint32_t *version_1,uint32_t *version_2)

{
  *version_1 = __DATA_44c00000;
  *version_2 = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

_Bool phy_vht_supported(void)

{
  byte bVar1;
  
  bVar1 = 1;
  if (-1 < __DATA_44c00000 << 9) {
    bVar1 = (byte)((uint)__DATA_44c00000 >> 0x19) & 1;
  }
  return (_Bool)bVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void phy_init(phy_cfg_tag *config)

{
  uint uVar1;
  _Bool _Var2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  uint32_t uVar3;
  uint32_t *puVar4;
  uint32_t *puVar5;
  uint32_t *puVar6;
  
  __DATA_44c00800 = 0;
  mdm_reset();
  __DATA_44c00820 = 0x20d;
  uVar1 = ((__DATA_44c00000 >> 8 & 0xf) - 1 & 0xff) << 4;
  if ((uVar1 & 0xffffff8f) != 0) {
    assert_err("(((uint32_t)rxnssmax << 4) & ~((uint32_t)0x00000070)) == 0","module",0xa09);
  }
  __DATA_44c00820 = uVar1 | __DATA_44c00820 & 0xffffff8f;
  uVar1 = ((__DATA_44c00000 >> 0xc & 0xf) - 1 & 0xff) << 0xc;
  if ((uVar1 & 0xf8000) != 0) {
    assert_err("(((uint32_t)rxndpnstsmax << 12) & ~((uint32_t)0x00007000)) == 0","module",0x987);
  }
  __DATA_44c00820 = __DATA_44c00000 >> 0x13 & 0x100 | uVar1 | __DATA_44c00820 & 0xffff8eff;
  _Var2 = phy_vht_supported();
  __DATA_44c00820 =
       (__DATA_44c00000 >> 0x1e & 1) << 0x14 |
       (__DATA_44c00000 >> 0x1e & 1) << 0x10 |
       (CONCAT31(extraout_var,_Var2) << 1 | __DATA_44c00820 & 0xfffffffd) & 0xffeeffff;
  _DAT_44c03024 = _DAT_44c03024 & 0xffc0ffff | 0x2d0000;
  _DAT_44c0089c = 0xffffffff;
  _DAT_44c00824 = 0x20d;
  uVar1 = ((__DATA_44c00000 >> 8 & 0xf) - 1 & 0xff) << 4;
  if ((uVar1 & 0xffffff8f) != 0) {
    assert_err("(((uint32_t)txnssmax << 4) & ~((uint32_t)0x00000070)) == 0","module",0xc0e);
  }
  _DAT_44c00824 = uVar1 | _DAT_44c00824 & 0xffffff8f;
  uVar1 = ((__DATA_44c00000 >> 4 & 0xf) - 1 & 0xff) << 0x14;
  if ((uVar1 & 0xf800000) != 0) {
    assert_err("(((uint32_t)ntxmax << 20) & ~((uint32_t)0x00700000)) == 0","module",0xb72);
  }
  _DAT_44c00824 = uVar1 | _DAT_44c00824 & 0xff8fffff;
  mdm_txcbwmax_setf((byte)(__DATA_44c00000 >> 0x18) & 3);
  _DAT_44c00824 = __DATA_44c00000 >> 0x12 & 0x100 | _DAT_44c00824 & 0xfffffeff;
  _Var2 = phy_vht_supported();
  _DAT_44c00824 =
       (__DATA_44c00000 >> 0x1f) << 0x10 |
       (CONCAT31(extraout_var_00,_Var2) << 1 | _DAT_44c00824 & 0xfffffffd) & 0xfffeffff;
  _DAT_44c00834 = _DAT_44c00834 | 1;
  _DAT_44c00818 = _DAT_44c00818 & 0xfffbffff;
  _DAT_44c00830 = _DAT_44c00830 & 0xffff0000 | 0x1b0f;
  _DAT_44c0083c = 0x4920492;
  _DAT_44c00874 = _DAT_44c00874 & 0xf7ffffff | 0x8000000;
  _DAT_44c0b500 = _DAT_44c0b500 & 0xffffcfff | 0x2000;
  if (_DAT_44c0b000 << 10 < 0) {
    _DAT_44c0b110 = _DAT_44c0b110 & 0xfffffff0;
    _DAT_44c0b118 = 0;
  }
  _DAT_44c0b004 = 1;
  _ACG_RWNXAGCCNTL = _ACG_RWNXAGCCNTL & 0xfffffffc | 1;
  _DAT_44c0b3bc = 4000000;
  _DAT_44c0b414 = _DAT_44c0b414 | 0x100;
  agc_config();
  _ACG_RWNXAGCCNTL = _ACG_RWNXAGCCNTL & 0xffffefff | 0x1000;
  _DAT_44c00874 = _DAT_44c00874 & 0xdfffffff | 0x20000000;
  puVar6 = agcmem;
  puVar4 = (uint32_t *)&DAT_54c0a000;
  do {
    uVar3 = *puVar6;
    puVar5 = puVar4 + 1;
    puVar6 = puVar6 + 1;
    *puVar4 = uVar3;
    puVar4 = puVar5;
  } while (puVar5 != (uint32_t *)0x54c0a800);
  _DAT_44c00874 = _DAT_44c00874 & 0xdfffffff;
  _ACG_RWNXAGCCNTL = _ACG_RWNXAGCCNTL & 0xffffefff;
  _DAT_44c0c020 = _DAT_44c0c020 & 0xfc00ffff | 0x140000;
  phy_env[0].cfg = config->parameters;
  phy_env[0]._4_4_ = 0xff00ff;
  phy_env[0]._8_4_ = 0x50000ff;
  trpc_init();
  pa_init();
  phy_tcal_reset();
  phy_tcal_start();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t phy_get_nss(void)

{
  return (uint8_t)(((byte)((uint)__DATA_44c00000 >> 8) & 0xf) - 1);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t phy_get_ntx(void)

{
  return (uint8_t)(((byte)(__DATA_44c00000 >> 4) & 0xf) - 1);
}



void phy_stop(void)

{
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

_Bool phy_ldpc_tx_supported(void)

{
  return (_Bool)((byte)((uint)__DATA_44c00000 >> 0x1a) & 1);
}



uint8_t phy_get_mac_freq(void)

{
  return '(';
}



void phy_get_rf_gain_idx(int8_t *power,uint8_t *idx)

{
  uint32_t uVar1;
  
  uVar1 = rfc_get_power_level(2,(int)*power * 10);
  *idx = (uint8_t)uVar1;
  return;
}



void phy_get_rf_gain_capab(int8_t *max,int8_t *min)

{
  int8_t iVar1;
  
  iVar1 = trpc_get_rf_max_power();
  *max = iVar1;
  iVar1 = trpc_get_rf_min_power();
  *min = iVar1;
  return;
}



void mpif_clk_init(void)

{
  return;
}



void phy_mdm_isr(void)

{
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void phy_rc_isr(void)

{
  _DAT_44c0b420 = _DAT_44c0b41c;
  if ((_DAT_44c0b41c & 0x100) != 0) {
    mdm_reset();
    return;
  }
  _DAT_44c0b420 = _DAT_44c0b41c;
  return;
}



void pa_init(void)

{
  int iVar1;
  pa_state_t *ppVar2;
  pa_state_t *ppVar3;
  
  ppVar3 = pa_env;
  do {
    ppVar3->rss_state = '\0';
    ppVar3->rss_count = 0;
    ppVar3->last_update = 0;
    ppVar3->input_buffer_ptr = '\0';
    ppVar3->ce_state = '\0';
    ppVar3->ce = 0.00000000;
    ppVar3->ce_num_up_cmds = '\0';
    ppVar3->ce_num_dn_cmds = '\0';
    iVar1 = 8;
    ppVar2 = ppVar3;
    do {
      ppVar2->input_buffer[0].new = '\0';
      ppVar2->input_buffer[0].rssi = '\0';
      ppVar2->input_buffer[0].lna = '\0';
      ppVar2->input_buffer[0].ppm = 0.00000000;
      iVar1 = iVar1 + -1;
      ppVar2 = (pa_state_t *)&ppVar2->input_buffer[0].ppm;
    } while (iVar1 != 0);
    ppVar3 = ppVar3 + 1;
  } while (ppVar3 != (pa_state_t *)&tcal_env);
  return;
}



// WARNING: Control flow encountered bad instruction data

void pa_input(uint8_t id,rx_hd *rhd)

{
  undefined3 in_register_00002029;
  uint uVar1;
  int iVar2;
  
  uVar1 = CONCAT31(in_register_00002029,id);
  if (uVar1 < 4) {
    iVar2 = (int)pa_env[uVar1].input_buffer_ptr;
    pa_env[uVar1].last_update = rhd->tsflo;
    pa_env[uVar1].input_buffer[iVar2].new = '\x01';
    pa_env[uVar1].input_buffer[iVar2].rssi = *(int8_t *)((int)&rhd->recvec1c + 3);
    pa_env[uVar1].input_buffer[iVar2].lna = (char)((int)(rhd->recvec1d << 0x14) >> 0x1c);
    if (((rhd->recvec1b & 0x70000) == 0) && ((rhd->recvec1a >> 0xc & 0xf) < 4)) {
      __floatsidf((int)*(char *)((int)&rhd->recvec2a + 3));
      __muldf3();
    }
    else {
      __floatsidf(-(int)*(short *)((int)&rhd->recvec2a + 3));
      __muldf3();
      __divdf3();
    }
    __truncdfsf2();
                    // WARNING: Bad instruction - Truncating control flow here
    halt_baddata();
  }
  return;
}


/*
Unable to decompile 'pa_adapt'
Cause: Exception while decompiling 23014776: Decompiler process died

*/


// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t hal_get_capcode(void)

{
  return (uint8_t)((byte)(_DAT_4000f884 >> 0x16) & 0x3f);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void hal_set_capcode(uint32_t capcode)

{
  _DAT_4000f884 = capcode << 0x10 | capcode << 0x16 | _DAT_4000f884 & 0xf000ffff;
  return;
}



_Bool hal_get_temperature(int16_t *temperature)

{
  *temperature = hal_env.temperature;
  return true;
}



void hal_set_temperature(int16_t temperature)

{
  hal_env.temperature = temperature;
  return;
}



void trpc_update_power(int8_t (*power_rate_table) [8])

{
  int iVar1;
  int iVar2;
  int iVar3;
  int8_t *piVar4;
  int8_t *piVar5;
  
  piVar4 = txpwr_vs_rate_table;
  iVar2 = 0;
  do {
    iVar3 = 0;
    do {
      iVar1 = iVar3 + iVar2;
      piVar5 = piVar4 + iVar3;
      iVar3 = iVar3 + 1;
      *piVar5 = (*power_rate_table)[iVar1];
    } while (iVar3 != 8);
    iVar2 = iVar2 + 8;
    piVar4 = piVar4 + 8;
  } while (iVar2 != 0x18);
  return;
}



void trpc_power_get(int8_t *power_rate_table)

{
  memcpy(power_rate_table,txpwr_vs_rate_table,0x18);
  return;
}



void trpc_update_power_11b(int8_t *power_rate_table)

{
  int8_t *piVar1;
  int8_t *piVar2;
  int iVar3;
  
  iVar3 = 0;
  do {
    piVar1 = power_rate_table + iVar3;
    piVar2 = txpwr_vs_rate_table + iVar3;
    iVar3 = iVar3 + 1;
    *piVar2 = *piVar1;
  } while (iVar3 != 4);
  return;
}



void trpc_update_power_11g(int8_t *power_rate_table)

{
  int8_t *piVar1;
  int iVar2;
  int8_t *piVar3;
  
  iVar2 = 0;
  piVar3 = txpwr_vs_rate_table;
  do {
    piVar1 = power_rate_table + iVar2;
    iVar2 = iVar2 + 1;
    piVar3[8] = *piVar1;
    piVar3 = piVar3 + 1;
  } while (iVar2 != 8);
  return;
}



void trpc_update_power_11n(int8_t *power_rate_table)

{
  int8_t *piVar1;
  int iVar2;
  int8_t *piVar3;
  
  iVar2 = 0;
  piVar3 = txpwr_vs_rate_table;
  do {
    piVar1 = power_rate_table + iVar2;
    iVar2 = iVar2 + 1;
    piVar3[0x10] = *piVar1;
    piVar3 = piVar3 + 1;
  } while (iVar2 != 8);
  return;
}



void trpc_init(void)

{
  int32_t iVar1;
  
  DAT_4201d148 = 0x98a;
  iVar1 = rf_pri_get_txgain_max();
  trpc_env = (undefined)iVar1;
  iVar1 = rf_pri_get_txgain_min();
  pwr_dbm_bottom = (int8_t)iVar1;
  DAT_4201d146 = 0x1e;
  DAT_4201d14a = 0x19;
  return;
}



int8_t trpc_get_rf_max_power(void)

{
  return trpc_env;
}



int8_t trpc_get_rf_min_power(void)

{
  return pwr_dbm_bottom;
}



uint8_t trpc_get_power_idx(uint8_t formatmod,uint8_t mcs,int8_t pwr_dbm)

{
  int8_t pwr_dbm_bottom;
  undefined3 in_register_00002029;
  uint uVar1;
  undefined3 in_register_0000202d;
  int iVar2;
  undefined3 in_register_00002031;
  char cVar3;
  uint uVar4;
  char cVar5;
  int iVar6;
  
  uVar1 = CONCAT31(in_register_00002029,formatmod);
  uVar4 = 2;
  if (uVar1 < 3) {
    uVar4 = (uint)formatmod;
  }
  iVar6 = 3;
  if (uVar1 != 0) {
    iVar6 = 7;
  }
  cVar5 = DAT_4201d146;
  if ((int)trpc_env < (int)DAT_4201d146) {
    cVar5 = trpc_env;
  }
  if (CONCAT31(in_register_00002031,pwr_dbm) < (int)cVar5) {
    cVar5 = pwr_dbm;
  }
  iVar2 = CONCAT31(in_register_0000202d,mcs);
  if (iVar6 < CONCAT31(in_register_0000202d,mcs)) {
    iVar2 = iVar6;
  }
  cVar3 = txpwr_vs_rate_table[iVar2 + uVar4 * 8];
  if (cVar5 < txpwr_vs_rate_table[iVar2 + uVar4 * 8]) {
    cVar3 = cVar5;
  }
  if (pwr_dbm_bottom < cVar3) {
    pwr_dbm_bottom = cVar3;
  }
  __floatsidf(((int)pwr_dbm_bottom * -0x1fe + (int)trpc_env) / 0x200);
  __adddf3();
  uVar4 = __fixdfsi();
  iVar6 = 3;
  if (uVar1 != 0) {
    iVar6 = 0;
  }
  uVar4 = iVar6 + (uVar4 & 0xff) & 0xff;
  if (0xf < uVar4) {
    uVar4 = 0xf;
  }
  return (uint8_t)(uVar4 << 2);
}



uint8_t trpc_get_default_power_idx(uint8_t formatmod,uint8_t mcs)

{
  uint8_t uVar1;
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  int iVar2;
  uint uVar3;
  int iVar4;
  
  uVar3 = (uint)formatmod;
  if (2 < CONCAT31(in_register_00002029,formatmod)) {
    uVar3 = 2;
  }
  iVar4 = 3;
  if (CONCAT31(in_register_00002029,formatmod) != 0) {
    iVar4 = 7;
  }
  iVar2 = CONCAT31(in_register_0000202d,mcs);
  if (iVar4 < CONCAT31(in_register_0000202d,mcs)) {
    iVar2 = iVar4;
  }
  uVar1 = trpc_get_power_idx((uint8_t)uVar3,(uint8_t)iVar2,txpwr_vs_rate_table[iVar2 + uVar3 * 8]);
  return uVar1;
}



void trpc_update_vs_channel(int8_t channel_MHz)

{
  undefined3 in_register_00002029;
  int32_t iVar1;
  
  DAT_4201d148 = (undefined2)CONCAT31(in_register_00002029,channel_MHz);
  iVar1 = rf_pri_get_txgain_max();
  trpc_env = (undefined)iVar1;
  iVar1 = rf_pri_get_txgain_min();
  pwr_dbm_bottom = (int8_t)iVar1;
  return;
}



void trpc_update_vs_temperature(int8_t temperature)

{
  int32_t iVar1;
  
  DAT_4201d14a._0_1_ = temperature;
  iVar1 = rf_pri_get_txgain_max();
  trpc_env = (undefined)iVar1;
  iVar1 = rf_pri_get_txgain_min();
  pwr_dbm_bottom = (int8_t)iVar1;
  return;
}



void phy_tcal_reset(void)

{
  memset(&tcal_env,0,0x38);
  tcal_env.prev_temperature = 0x19;
  tcal_env.last_action_temperature[0] = 0x19;
  tcal_env.last_action_temperature[1] = 0x19;
  tcal_env.last_action_temperature[2] = 0x19;
  tcal_env.last_action_temperature[3] = 0x19;
  tcal_env.enabled = true;
  return;
}



void phy_tcal_start(void)

{
  tcal_env.enabled = true;
  return;
}



void phy_tcal_txpwr(int16_t curr_temperature)

{
  undefined2 in_register_0000202a;
  
  rf_pri_tx_gain_comp(CONCAT22(in_register_0000202a,curr_temperature));
  trpc_update_vs_temperature((int8_t)curr_temperature);
  return;
}


/*
Unable to decompile 'phy_tcal_handle'
Cause: Exception while decompiling 23014d24: Decompiler process died

*/


void phy_tcal_callback(int16_t temperature)

{
  hal_set_temperature(temperature);
  if (tcal_env.enabled != false) {
    phy_tcal_handle();
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_fsm_ctrl_en_setf(uint32_t x)

{
  _DAT_40001004 = x << 1 | _DAT_40001004 & 0xfffffffd;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_fsm_st_dbg_en_setf(uint32_t x)

{
  _DAT_4000126c = x << 3 | _DAT_4000126c & 0xfffffff7;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc3_setf(uint32_t x)

{
  _DAT_40001630 = (x & 0x7f) << 0x18 | _DAT_40001630 & 0x80ffffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc2_setf(uint32_t x)

{
  _DAT_40001630 = (x & 0x7f) << 0x10 | _DAT_40001630 & 0xff80ffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc1_setf(uint32_t x)

{
  _DAT_40001630 = (x & 0x7f) << 8 | _DAT_40001630 & 0xffff80ff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc0_setf(uint32_t x)

{
  _DAT_40001630 = x & 0x7f | _DAT_40001630 & 0xffffff80;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc7_setf(uint32_t x)

{
  _DAT_40001634 = (x & 0x7f) << 0x18 | _DAT_40001634 & 0x80ffffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc6_setf(uint32_t x)

{
  _DAT_40001634 = (x & 0x7f) << 0x10 | _DAT_40001634 & 0xff80ffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc5_setf(uint32_t x)

{
  _DAT_40001634 = (x & 0x7f) << 8 | _DAT_40001634 & 0xffff80ff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc4_setf(uint32_t x)

{
  _DAT_40001634 = x & 0x7f | _DAT_40001634 & 0xffffff80;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc11_setf(uint32_t x)

{
  _DAT_40001638 = (x & 0x7f) << 0x18 | _DAT_40001638 & 0x80ffffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc10_setf(uint32_t x)

{
  _DAT_40001638 = (x & 0x7f) << 0x10 | _DAT_40001638 & 0xff80ffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc9_setf(uint32_t x)

{
  _DAT_40001638 = (x & 0x7f) << 8 | _DAT_40001638 & 0xffff80ff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc8_setf(uint32_t x)

{
  _DAT_40001638 = x & 0x7f | _DAT_40001638 & 0xffffff80;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc15_setf(uint32_t x)

{
  _DAT_4000163c = (x & 0x7f) << 0x18 | _DAT_4000163c & 0x80ffffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc14_setf(uint32_t x)

{
  _DAT_4000163c = (x & 0x7f) << 0x10 | _DAT_4000163c & 0xff80ffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc13_setf(uint32_t x)

{
  _DAT_4000163c = (x & 0x7f) << 8 | _DAT_4000163c & 0xffff80ff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc12_setf(uint32_t x)

{
  _DAT_4000163c = x & 0x7f | _DAT_4000163c & 0xffffff80;
  return;
}



void wait_us(uint32_t us)

{
  bool bVar1;
  uint32_t n;
  int iStack4;
  
  iStack4 = us << 4;
  do {
    bVar1 = iStack4 != 0;
    iStack4 = iStack4 + -1;
  } while (bVar1);
  return;
}



void _print_channel_info(void)

{
  int iVar1;
  
  iVar1 = 8;
  do {
    iVar1 = iVar1 + -1;
    wait_us(1000);
  } while (iVar1 != 0);
  iVar1 = 8;
  do {
    iVar1 = iVar1 + -1;
    wait_us(1000);
  } while (iVar1 != 0);
  return;
}



// WARNING: Control flow encountered bad instruction data

void rfc_init(uint32_t xtalfreq_hz)

{
  uint32_t rfg_index;
  uint32_t dg;
  
                    // WARNING: Bad instruction - Truncating control flow here
  halt_baddata();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rfc_rxdfe_set_notch0(uint8_t en,uint8_t alpha,int8_t nrmfc)

{
  _DAT_40001700 =
       ((uint)en & 1) << 6 | (uint)(byte)nrmfc << 8 | (uint)alpha & 7 | _DAT_40001700 & 0xffff00b8;
  return;
}



// WARNING: Variable defined which should be unmapped: ncf_freq_hz
// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rfc_config_channel(uint32_t channel_freq)

{
  SItype SVar1;
  uint8_t uStack21;
  uint8_t ncf_on;
  SItype SStack20;
  int32_t ncf_freq_hz;
  
  _DAT_40001228 = _DAT_40001228 | 8;
  _DAT_4000100c = _DAT_4000100c | 0x241;
  _DAT_40001264 = channel_freq & 0xfff | _DAT_40001264 & 0xfffff000;
  _DAT_40001268 = _DAT_40001268 & 0xfffdffff | 0x20000;
  wait_us(10);
  _DAT_40001268 = _DAT_40001268 & 0xfffdffff;
  wait_us(10);
  rf_fsm_ctrl_en_setf(0);
  wait_us(10);
  rf_fsm_ctrl_en_setf(1);
  wait_us(10);
  _DAT_4000126c = _DAT_4000126c & 0xfffffff8 | 1;
  wait_us(10);
  rf_fsm_st_dbg_en_setf(1);
  wait_us(10);
  _DAT_4000126c = _DAT_4000126c & 0xfffffff8 | 2;
  wait_us(100);
  rf_fsm_st_dbg_en_setf(0);
  wait_us(10);
  _print_channel_info();
  rf_pri_update_param(channel_freq);
  rf_pri_get_notch_param(channel_freq,&uStack21,(int32_t *)&stack0xffffffec);
  __floatsidf(SStack20);
  __divdf3();
  __muldf3();
  __adddf3();
  SVar1 = __fixdfsi();
  rfc_rxdfe_set_notch0(uStack21,'\x01',(int8_t)SVar1);
  _DAT_40001228 = _DAT_40001228 & 0xfffffff7;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rfc_coex_force_to(uint32_t force_enable,uint32_t bbmode)

{
  rf_fsm_ctrl_en_setf(0);
  wait_us(10);
  _DAT_40001220 =
       (uint)(force_enable != 0) << 0x1b | (bbmode & 1) << 0x1a | _DAT_40001220 & 0xf3ffffff;
  wait_us(10);
  rf_fsm_ctrl_en_setf(1);
  return;
}



uint32_t rfc_get_power_level(uint32_t formatmod,int32_t power)

{
  uint32_t mode;
  
  mode = 0;
  if ((formatmod != 0) && (mode = 1, formatmod != 1)) {
    mode = 2;
  }
  mode = rf_pri_get_txgain_index(power,mode);
  return mode << 2;
}



void rfc_apply_tx_dvga(int8_t *dvga_qdb)

{
  rf_tx_dvga_gain_qdb_gc0_setf((int)*dvga_qdb);
  rf_tx_dvga_gain_qdb_gc1_setf((int)dvga_qdb[1]);
  rf_tx_dvga_gain_qdb_gc2_setf((int)dvga_qdb[2]);
  rf_tx_dvga_gain_qdb_gc3_setf((int)dvga_qdb[3]);
  rf_tx_dvga_gain_qdb_gc4_setf((int)dvga_qdb[4]);
  rf_tx_dvga_gain_qdb_gc5_setf((int)dvga_qdb[5]);
  rf_tx_dvga_gain_qdb_gc6_setf((int)dvga_qdb[6]);
  rf_tx_dvga_gain_qdb_gc7_setf((int)dvga_qdb[7]);
  rf_tx_dvga_gain_qdb_gc8_setf((int)dvga_qdb[8]);
  rf_tx_dvga_gain_qdb_gc9_setf((int)dvga_qdb[9]);
  rf_tx_dvga_gain_qdb_gc10_setf((int)dvga_qdb[10]);
  rf_tx_dvga_gain_qdb_gc11_setf((int)dvga_qdb[0xb]);
  rf_tx_dvga_gain_qdb_gc12_setf((int)dvga_qdb[0xc]);
  rf_tx_dvga_gain_qdb_gc13_setf((int)dvga_qdb[0xd]);
  rf_tx_dvga_gain_qdb_gc14_setf((int)dvga_qdb[0xe]);
  rf_tx_dvga_gain_qdb_gc15_setf((int)dvga_qdb[0xf]);
  return;
}



// WARNING: Variable defined which should be unmapped: dg
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rfc_apply_tx_power_offset(uint8_t channel,int8_t *power_offset)

{
  uint32_t uStack56;
  uint32_t rfg_index;
  uint32_t dg;
  
  rf_pri_update_tx_power_offset(channel,power_offset);
  rf_pri_query_txgain_table(0,&uStack56,&rfg_index);
  _DAT_40001640 = uStack56 & 7 | _DAT_40001640 & 0xfffffff8;
  rf_tx_dvga_gain_qdb_gc0_setf(rfg_index);
  rf_pri_query_txgain_table(1,&uStack56,&rfg_index);
  _DAT_40001640 = (uStack56 & 7) << 4 | _DAT_40001640 & 0xffffff8f;
  rf_tx_dvga_gain_qdb_gc1_setf(rfg_index);
  rf_pri_query_txgain_table(2,&uStack56,&rfg_index);
  _DAT_40001640 = (uStack56 & 7) << 8 | _DAT_40001640 & 0xfffff8ff;
  rf_tx_dvga_gain_qdb_gc2_setf(rfg_index);
  rf_pri_query_txgain_table(3,&uStack56,&rfg_index);
  _DAT_40001640 = (uStack56 & 7) << 0xc | _DAT_40001640 & 0xffff8fff;
  rf_tx_dvga_gain_qdb_gc3_setf(rfg_index);
  rf_pri_query_txgain_table(4,&uStack56,&rfg_index);
  _DAT_40001640 = (uStack56 & 7) << 0x10 | _DAT_40001640 & 0xfff8ffff;
  rf_tx_dvga_gain_qdb_gc4_setf(rfg_index);
  rf_pri_query_txgain_table(5,&uStack56,&rfg_index);
  _DAT_40001640 = (uStack56 & 7) << 0x14 | _DAT_40001640 & 0xff8fffff;
  rf_tx_dvga_gain_qdb_gc5_setf(rfg_index);
  rf_pri_query_txgain_table(6,&uStack56,&rfg_index);
  _DAT_40001640 = (uStack56 & 7) << 0x18 | _DAT_40001640 & 0xf8ffffff;
  rf_tx_dvga_gain_qdb_gc6_setf(rfg_index);
  rf_pri_query_txgain_table(7,&uStack56,&rfg_index);
  _DAT_40001640 = (uStack56 & 7) << 0x1c | _DAT_40001640 & 0x8fffffff;
  rf_tx_dvga_gain_qdb_gc7_setf(rfg_index);
  rf_pri_query_txgain_table(8,&uStack56,&rfg_index);
  _DAT_40001644 = uStack56 & 7 | _DAT_40001644 & 0xfffffff8;
  rf_tx_dvga_gain_qdb_gc8_setf(rfg_index);
  rf_pri_query_txgain_table(9,&uStack56,&rfg_index);
  _DAT_40001644 = (uStack56 & 7) << 4 | _DAT_40001644 & 0xffffff8f;
  rf_tx_dvga_gain_qdb_gc9_setf(rfg_index);
  rf_pri_query_txgain_table(10,&uStack56,&rfg_index);
  _DAT_40001644 = (uStack56 & 7) << 8 | _DAT_40001644 & 0xfffff8ff;
  rf_tx_dvga_gain_qdb_gc10_setf(rfg_index);
  rf_pri_query_txgain_table(0xb,&uStack56,&rfg_index);
  _DAT_40001644 = (uStack56 & 7) << 0xc | _DAT_40001644 & 0xffff8fff;
  rf_tx_dvga_gain_qdb_gc11_setf(rfg_index);
  rf_pri_query_txgain_table(0xc,&uStack56,&rfg_index);
  _DAT_40001644 = (uStack56 & 7) << 0x10 | _DAT_40001644 & 0xfff8ffff;
  rf_tx_dvga_gain_qdb_gc12_setf(rfg_index);
  rf_pri_query_txgain_table(0xd,&uStack56,&rfg_index);
  _DAT_40001644 = (uStack56 & 7) << 0x14 | _DAT_40001644 & 0xff8fffff;
  rf_tx_dvga_gain_qdb_gc13_setf(rfg_index);
  rf_pri_query_txgain_table(0xe,&uStack56,&rfg_index);
  _DAT_40001644 = (uStack56 & 7) << 0x18 | _DAT_40001644 & 0xf8ffffff;
  rf_tx_dvga_gain_qdb_gc14_setf(rfg_index);
  rf_pri_query_txgain_table(0xf,&uStack56,&rfg_index);
  _DAT_40001644 = (uStack56 & 7) << 0x1c | _DAT_40001644 & 0x8fffffff;
  rf_tx_dvga_gain_qdb_gc15_setf(rfg_index);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_set_gain_table_regs(void)

{
  _DAT_40001118 =
       ((tx_pwr_table[12][2] << 0x18 |
        (tx_pwr_table[12][3] << 0x10 |
        (tx_pwr_table[14][0] << 0xe |
        (tx_pwr_table[14][1] << 0xc |
        (tx_pwr_table[14][2] << 8 | (_DAT_40001118 & 0xffffffe0 | tx_pwr_table[14][3]) & 0xfffff8ff)
        & 0xffffcfff) & 0xffff3fff) & 0xffe0ffff) & 0xf8ffffff) & 0xcfffffff |
       tx_pwr_table[12][1] << 0x1c) & 0x3fffffff | tx_pwr_table[12][0] << 0x1e;
  _DAT_4000111c =
       (tx_pwr_table[8][1] << 0x1c |
       (tx_pwr_table[8][2] << 0x18 |
       (tx_pwr_table[8][3] << 0x10 |
       (tx_pwr_table[10][0] << 0xe |
       (tx_pwr_table[10][1] << 0xc |
       (tx_pwr_table[10][2] << 8 | (_DAT_4000111c & 0xffffffe0 | tx_pwr_table[10][3]) & 0xfffff8ff)
       & 0xffffcfff) & 0xffff3fff) & 0xffe0ffff) & 0xf8ffffff) & 0xcfffffff) & 0x3fffffff |
       tx_pwr_table[8][0] << 0x1e;
  _DAT_40001120 =
       tx_pwr_table[4][0] << 0x1e |
       (tx_pwr_table[4][1] << 0x1c |
       (tx_pwr_table[4][2] << 0x18 |
       (tx_pwr_table[4][3] << 0x10 |
       (tx_pwr_table[6][0] << 0xe |
       (tx_pwr_table[6][1] << 0xc |
       (tx_pwr_table[6][2] << 8 | (_DAT_40001120 & 0xffffffe0 | tx_pwr_table[6][3]) & 0xfffff8ff) &
       0xffffcfff) & 0xffff3fff) & 0xffe0ffff) & 0xf8ffffff) & 0xcfffffff) & 0x3fffffff;
  _DAT_40001124 =
       (tx_pwr_table[0][1] << 0x1c |
       ((tx_pwr_table[0][3] << 0x10 |
        (tx_pwr_table[2][0] << 0xe |
        ((tx_pwr_table[2][2] << 8 | (_DAT_40001124 & 0xffffffe0 | tx_pwr_table[2][3]) & 0xfffff8ff)
         & 0xffffcfff | tx_pwr_table[2][1] << 0xc) & 0xffff3fff) & 0xffe0ffff) & 0xf8ffffff |
       tx_pwr_table[0][2] << 0x18) & 0xcfffffff) & 0x3fffffff | tx_pwr_table[0][0] << 0x1e;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_manu_pu(uint32_t mode)

{
  int iVar1;
  uint uVar2;
  
  if (mode == 5) {
    _DAT_40001030 = _DAT_40001030 & 0xcefff8ff;
    iVar1 = -0x39009000;
  }
  else {
    if (5 < mode) {
      if (7 < mode) goto LAB_23015d76;
      _DAT_40001030 = _DAT_40001030 & 0x8f090ff;
      uVar2 = 0xf00000;
      goto LAB_23015daa;
    }
    if (mode != 4) {
LAB_23015d76:
      _DAT_40001004 = _DAT_40001004 & 0xfffffffd;
      _DAT_4000100c = 0;
      _DAT_40001030 = _DAT_40001030 & 0x2df0feff | 0x25f06e00;
      return;
    }
    _DAT_40001030 = _DAT_40001030 & 0x2cf8f8ff;
    iVar1 = 0x24f87000;
  }
  uVar2 = iVar1 - 0x800;
LAB_23015daa:
  _DAT_40001004 = _DAT_40001004 & 0xfffffffd;
  _DAT_4000100c = 0;
  _DAT_40001030 = _DAT_40001030 | uVar2;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_save_state_for_cal(void)

{
  state_adda1 = _DAT_4000108c;
  state_dfe_ctrl_0 = _DAT_40001600;
  state_dfe_ctrl_3 = _DAT_4000160c;
  state_dfe_ctrl_6 = _DAT_40001618;
  state_dfe_ctrl_7 = _DAT_4000161c;
  state_fbdv = _DAT_400010b8;
  state_pa1 = _DAT_40001064;
  state_pucr1 = _DAT_40001030;
  state_rbb3 = _DAT_40001084;
  state_rf_fsm_ctrl_hw = _DAT_40001004;
  state_rf_resv_reg_1 = _DAT_400010f0;
  state_rfcal_ctrlen = _DAT_4000101c;
  state_rfctrl_hw_en = _DAT_4000100c;
  state_rfif_dfe_ctrl0 = _DAT_40001220;
  state_sdm1 = _DAT_400010c0;
  state_sdm2 = _DAT_400010c4;
  state_singen_ctrl0 = _DAT_4000120c;
  state_singen_ctrl2 = _DAT_40001214;
  state_singen_ctrl3 = _DAT_40001218;
  state_sram_ctrl0 = _DAT_4000123c;
  state_sram_ctrl1 = _DAT_40001240;
  state_sram_ctrl2 = _DAT_40001244;
  state_tbb = _DAT_40001070;
  state_ten_ac = _DAT_40001058;
  state_trx_gain1 = _DAT_40001048;
  state_vco2 = _DAT_400010a4;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_restore_state_for_cal(void)

{
  _DAT_40001004 = state_rf_fsm_ctrl_hw;
  _DAT_4000100c = state_rfctrl_hw_en;
  _DAT_4000101c = state_rfcal_ctrlen;
  _DAT_40001030 = state_pucr1;
  _DAT_40001048 = state_trx_gain1;
  _DAT_40001058 = state_ten_ac;
  _DAT_40001064 = state_pa1;
  _DAT_40001070 = state_tbb;
  _DAT_40001084 = state_rbb3;
  _DAT_4000108c = state_adda1;
  _DAT_400010a4 = state_vco2;
  _DAT_400010b8 = state_fbdv;
  _DAT_400010c0 = state_sdm1;
  _DAT_400010c4 = state_sdm2;
  _DAT_400010f0 = state_rf_resv_reg_1;
  _DAT_4000120c = state_singen_ctrl0;
  _DAT_40001214 = state_singen_ctrl2;
  _DAT_40001218 = state_singen_ctrl3;
  _DAT_40001220 = state_rfif_dfe_ctrl0;
  _DAT_4000123c = state_sram_ctrl0;
  _DAT_40001240 = state_sram_ctrl1;
  _DAT_40001244 = state_sram_ctrl2;
  _DAT_40001600 = state_dfe_ctrl_0;
  _DAT_4000160c = state_dfe_ctrl_3;
  _DAT_40001618 = state_dfe_ctrl_6;
  _DAT_4000161c = state_dfe_ctrl_7;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_singen_start(void)

{
  _DAT_4000120c = _DAT_4000120c & 0x7fffffff | 0x80000000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t rf_pri_pm_pwr(void)

{
  int iVar1;
  int iVar2;
  
  do {
  } while (-1 < (int)((_DAT_40001618 & 0xdfefffff | 0x20100000) << 3));
  iVar1 = (_DAT_40001620 << 7) >> 0x10;
  iVar2 = (_DAT_40001624 << 7) >> 0x10;
  _DAT_40001618 = _DAT_40001618 & 0xdfefffff;
  return iVar1 * iVar1 + iVar2 * iVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_start_txdfe(void)

{
  _DAT_40001220 = _DAT_40001220 & 0xffffe67f | 0x1182;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int32_t rf_pri_pm_pwr_avg(uint32_t iq,uint32_t acc_len)

{
  int iVar1;
  
  do {
  } while (-1 < (int)((_DAT_40001618 & 0xdfefffff) << 3));
  iVar1 = _DAT_40001624;
  if (iq != 0) {
    iVar1 = _DAT_40001620;
  }
  _DAT_40001618 = _DAT_40001618 & 0xdfefffff;
  _DAT_4000161c = acc_len << 0x10 | _DAT_4000161c & 0xffff;
  return (iVar1 << 7) >> 7;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_txcal_config_hw(void)

{
  _DAT_40001180 =
       (*(uint *)(rf_calib_data->txcal + 1) >> 6 & 0x3f) << 0x18 |
       (*(uint *)rf_calib_data->txcal >> 6 & 0x3f) << 8 |
       *(uint *)rf_calib_data->txcal & 0x3f | _DAT_40001180 & 0xc0c0c0c0 |
       (*(uint *)(rf_calib_data->txcal + 1) & 0x3f) << 0x10;
  _DAT_40001184 =
       (*(uint *)(rf_calib_data->txcal + 3) >> 6 & 0x3f) << 0x18 |
       (*(uint *)(rf_calib_data->txcal + 2) >> 6 & 0x3f) << 8 |
       *(uint *)(rf_calib_data->txcal + 2) & 0x3f | _DAT_40001184 & 0xc0c0c0c0 |
       (*(uint *)(rf_calib_data->txcal + 3) & 0x3f) << 0x10;
  _DAT_40001188 =
       (*(uint *)(rf_calib_data->txcal + 5) >> 6 & 0x3f) << 0x18 |
       (*(uint *)(rf_calib_data->txcal + 4) >> 6 & 0x3f) << 8 |
       *(uint *)(rf_calib_data->txcal + 4) & 0x3f | _DAT_40001188 & 0xc0c0c0c0 |
       (*(uint *)(rf_calib_data->txcal + 5) & 0x3f) << 0x10;
  _DAT_4000118c =
       (*(uint *)(rf_calib_data->txcal + 7) >> 6 & 0x3f) << 0x18 |
       (*(uint *)(rf_calib_data->txcal + 6) >> 6 & 0x3f) << 8 |
       *(uint *)(rf_calib_data->txcal + 6) & 0x3f | _DAT_4000118c & 0xc0c0c0c0 |
       (*(uint *)(rf_calib_data->txcal + 7) & 0x3f) << 0x10;
  _DAT_40001190 =
       (*(uint *)rf_calib_data->txcal >> 0xc & 0x7ff) << 0x10 | _DAT_40001190 & 0xf800fc00 |
       *(uint *)&rf_calib_data->txcal[0].field_0x4 & 0x3ff;
  _DAT_40001194 =
       (*(uint *)(rf_calib_data->txcal + 1) >> 0xc & 0x7ff) << 0x10 | _DAT_40001194 & 0xf800fc00 |
       *(uint *)&rf_calib_data->txcal[1].field_0x4 & 0x3ff;
  _DAT_40001198 =
       (*(uint *)(rf_calib_data->txcal + 2) >> 0xc & 0x7ff) << 0x10 | _DAT_40001198 & 0xf800fc00 |
       *(uint *)&rf_calib_data->txcal[2].field_0x4 & 0x3ff;
  _DAT_4000119c =
       (*(uint *)(rf_calib_data->txcal + 3) >> 0xc & 0x7ff) << 0x10 | _DAT_4000119c & 0xf800fc00 |
       *(uint *)&rf_calib_data->txcal[3].field_0x4 & 0x3ff;
  _DAT_400011a0 =
       (*(uint *)(rf_calib_data->txcal + 4) >> 0xc & 0x7ff) << 0x10 | _DAT_400011a0 & 0xf800fc00 |
       *(uint *)&rf_calib_data->txcal[4].field_0x4 & 0x3ff;
  _DAT_400011a4 =
       (*(uint *)(rf_calib_data->txcal + 5) >> 0xc & 0x7ff) << 0x10 | _DAT_400011a4 & 0xf800fc00 |
       *(uint *)&rf_calib_data->txcal[5].field_0x4 & 0x3ff;
  _DAT_400011a8 =
       (*(uint *)(rf_calib_data->txcal + 6) >> 0xc & 0x7ff) << 0x10 | _DAT_400011a8 & 0xf800fc00 |
       *(uint *)&rf_calib_data->txcal[6].field_0x4 & 0x3ff;
  _DAT_400011ac =
       (*(uint *)(rf_calib_data->txcal + 7) >> 0xc & 0x7ff) << 0x10 | _DAT_400011ac & 0xf800fc00 |
       *(uint *)&rf_calib_data->txcal[7].field_0x4 & 0x3ff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint16_t rf_pri_fcal_meas(uint32_t cw)

{
  _DAT_400010a0 = cw | _DAT_400010a0 & 0xffffff00;
  BL602_Delay_US(100);
  do {
  } while (-1 < (int)((_DAT_400010ac | 0x10) << 0xb));
  _DAT_400010ac = _DAT_400010ac & 0xffffffef;
  return (uint16_t)((uint)_DAT_400010a8 >> 0x10);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_rccal_config(uint32_t rbb_fc)

{
  _DAT_40001080 = rbb_fc << 8 | rbb_fc << 0x18 | _DAT_40001080 & 0xc0ffc0ff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_rccal_config(uint32_t iq,uint32_t rbb_fc)

{
  if (iq != 0) {
    rf_pri_rccal_config(rbb_fc);
    return;
  }
  _DAT_40001080 = rbb_fc << 0x10 | _DAT_40001080 & 0xffc0ffc0 | rbb_fc;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_txcal_config(uint32_t param_ind,int32_t val)

{
  uint uVar1;
  
  if (param_ind == 2) {
    _DAT_40001600 = val << 0xc | _DAT_40001600 & 0xff800fff | 0x800000;
    return;
  }
  if (param_ind != 3) {
    if (param_ind == 0) {
      _DAT_40001070 = _DAT_40001070 & 0xc0ffffff;
      uVar1 = val << 0x18;
    }
    else {
      if (param_ind != 1) {
        return;
      }
      _DAT_40001070 = _DAT_40001070 & 0xffc0ffff;
      uVar1 = val << 0x10;
    }
    _DAT_40001070 = uVar1 | _DAT_40001070;
    return;
  }
  if (val < 0) {
    val = val + 0x400;
  }
  _DAT_40001600 = val | _DAT_40001600 & 0xfffffc00 | 0x400;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int32_t rf_pri_txcal_search_core
                  (uint32_t param_ind,uint32_t center,uint32_t delta,uint32_t meas_freq)

{
  uint32_t val;
  uint32_t val_00;
  uint32_t uVar1;
  uint uVar2;
  uint32_t uVar3;
  
  rf_pri_txcal_config(param_ind,center);
  BL602_Delay_US(10);
  _DAT_40001618 = meas_freq << 10 | _DAT_40001618 & 0xfff00000;
  uVar1 = rf_pri_pm_pwr();
  do {
    val = center - delta;
    val_00 = center + delta;
    if (param_ind < 2) {
      if ((int)val < 0) {
        val = 0;
      }
      if (0x3f < (int)val_00) {
        val_00 = 0x3f;
      }
    }
    else {
      if (param_ind == 2) {
        if ((int)val < 0) {
          val = 0;
        }
        if (0x7ff < (int)val_00) {
          val_00 = 0x7ff;
        }
      }
      else {
        if ((int)val < -0x200) {
          val = 0xfffffe00;
        }
        if (0x1ff < (int)val_00) {
          val_00 = 0x1ff;
        }
      }
    }
    rf_pri_txcal_config(param_ind,val);
    delta = (int)delta >> 1;
    BL602_Delay_US(10);
    uVar2 = rf_pri_pm_pwr();
    if (uVar1 <= uVar2) {
      rf_pri_txcal_config(param_ind,val_00);
      BL602_Delay_US(10);
      uVar3 = rf_pri_pm_pwr();
      val = center;
      uVar2 = uVar1;
      if (uVar3 < uVar1) {
        val = val_00;
        uVar2 = uVar3;
      }
    }
    center = val;
    uVar1 = uVar2;
  } while (delta != 0);
  return val;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_singen_config(uint32_t fcw)

{
  _DAT_4000120c = fcw << 0x10 | _DAT_4000120c & 0xfc00ffff;
  _DAT_40001214 = _DAT_40001214 & 0x3fffff;
  _DAT_40001218 = _DAT_40001218 & 0x3fffff | 0xc0000000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t rf_pri_rccal_iq(uint32_t iq)

{
  uint uVar1;
  uint32_t i;
  USItype UVar2;
  uint32_t uVar3;
  uint uVar4;
  int iVar5;
  undefined4 uVar6;
  
  if (iq == 0) {
    _DAT_4000160c = _DAT_4000160c & 0xfbffffff | 0x400;
  }
  else {
    _DAT_4000160c = _DAT_4000160c & 0xfffffbff | 0x4000000;
  }
  _DAT_40001048 = _DAT_40001048 & 0xffff8cff | 0x3100;
  rf_pri_singen_config(3);
  _DAT_40001214 = _DAT_40001214 & 0xfffff800 | 0x3ff;
  _DAT_40001218 = _DAT_40001218 & 0xfffff800 | 0x3ff;
  uVar6 = rf_pri_singen_start();
  rf_pri_start_txdfe(uVar6);
  _DAT_40001618 = _DAT_40001618 & 0xfff00000 | 0xc00;
  rf_pri_pm_pwr_avg(iq,0x400);
  i = rf_pri_pm_pwr();
  __floatunsidf(i);
  __muldf3();
  UVar2 = __fixunsdfsi();
  _DAT_40001048 = _DAT_40001048 & 0xffff8cff | 0x6200;
  rf_pri_singen_config(0xb5);
  uVar6 = rf_pri_singen_start();
  rf_pri_start_txdfe(uVar6);
  _DAT_40001618 = _DAT_40001618 & 0xfff00000 | 0x2d400;
  i = 0;
  uVar1 = 6;
  uVar4 = 0x20;
  do {
    rf_pri_rccal_config(iq,uVar4 + i);
    uVar3 = rf_pri_pm_pwr();
    if (UVar2 < uVar3) {
      i = uVar4 + i;
    }
    uVar1 = uVar1 - 1;
    uVar4 = uVar4 >> 1;
  } while (uVar1 != 0);
  iVar5 = 0x3f;
  do {
    rf_pri_rccal_config(iq,i);
    uVar3 = rf_pri_pm_pwr();
    if (UVar2 < uVar3) {
      uVar1 = uVar1 * 2 + 1 & 0xf;
      i = i + 1;
      if (uVar1 == 5) {
        return 3;
      }
    }
    else {
      uVar1 = uVar1 * 2 & 0xf;
      i = i - 1;
      if (uVar1 == 10) {
        return 3;
      }
    }
    iVar5 = iVar5 + -1;
  } while (iVar5 != 0);
  return 2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_config_channel(void)

{
  _DAT_400010a0 =
       ((uint)((ushort)rf_calib_data->lo[9] >> 8) & 0x1f) << 0x10 |
       (uint)(ushort)rf_calib_data->lo[9] & 0xff | _DAT_400010a0 & 0xffe0ff00;
  _DAT_400010bc =
       (((uint)(ushort)rf_calib_data->lo[9] & 0xff) >> 4) << 0x14 | _DAT_400010bc & 0xff0fffff;
  _DAT_400010c4 = _DAT_400010c4 & 0xc0000000 | channel_div_table[9];
  _DAT_400010c0 = _DAT_400010c0 & 0xffffefff;
  while( true ) {
    _DAT_400010b8 = _DAT_400010b8 | 0x10000;
    BL602_Delay_US(10);
    _DAT_400010b8 = _DAT_400010b8 & 0xfffeffff;
    BL602_Delay_US(0x32);
    _DAT_400010b0 = _DAT_400010b0 | 0x10000000;
    BL602_Delay_US(10);
    _DAT_400010b0 = _DAT_400010b0 & 0xefffffff;
    BL602_Delay_US(0x32);
    if ((_DAT_400010b4 & 0x1100000) == 0) break;
    printf(".");
  }
  printf("LO locked %ld %ld\r\n",(uint)(ushort)rf_calib_data->lo[9] & 0xff);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t rf_pri_roscal_iq(uint32_t iq)

{
  uint uVar1;
  int32_t iVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  
  uVar1 = 6;
  uVar3 = 0;
  uVar4 = 0x20;
  do {
    uVar6 = uVar4 + uVar3;
    if (iq == 0) {
      _DAT_4000107c = uVar6 | _DAT_4000107c & 0xffffffc0;
    }
    else {
      _DAT_4000107c = uVar6 * 0x100 | _DAT_4000107c & 0xffffc0ff;
    }
    iVar2 = rf_pri_pm_pwr_avg(iq,0x400);
    if (iVar2 < 1) {
      uVar3 = uVar6;
    }
    uVar1 = uVar1 - 1;
    uVar4 = uVar4 >> 1;
  } while (uVar1 != 0);
  iVar5 = 0x3f;
  do {
    if (iq == 0) {
      _DAT_4000107c = _DAT_4000107c & 0xffffffc0 | uVar3;
    }
    else {
      _DAT_4000107c = uVar3 << 8 | _DAT_4000107c & 0xffffc0ff;
    }
    iVar2 = rf_pri_pm_pwr_avg(iq,0x400);
    if (iVar2 < 1) {
      uVar1 = uVar1 * 2 & 0xf;
      uVar3 = uVar3 + 1;
      if (uVar1 == 10) {
        return uVar3;
      }
    }
    else {
      uVar1 = uVar1 * 2 + 1 & 0xf;
      uVar3 = uVar3 - 1;
      if (uVar1 == 5) {
        return uVar3;
      }
    }
    iVar5 = iVar5 + -1;
  } while (iVar5 != 0);
  return uVar3;
}



void rf_pri_chipv(uint8_t chipv)

{
  regs_to_opti *prVar1;
  undefined3 in_register_00002029;
  undefined4 *puVar2;
  undefined4 *puVar3;
  int iVar4;
  uint32_t *puVar5;
  void_fn **ppvVar6;
  int iVar7;
  uint32_t *puVar8;
  uint32_t *puVar9;
  int iVar10;
  void_fn **ppvVar11;
  void_fn **ppvVar12;
  
  if (CONCAT31(in_register_00002029,chipv) == 0) {
    tmxcss._0_4_ = 0x60003;
    tmxcss[2] = 6;
    iVar4 = 0x1c;
    do {
      iVar7 = iVar4 + -0x1c;
      do {
        *(undefined4 *)((int)tx_pwr_table + iVar7) = *(undefined4 *)((int)tx_pwr_table_a0 + iVar7);
        *(undefined4 *)((int)tx_pwr_table_origin + iVar7) =
             *(undefined4 *)((int)tx_pwr_table_a0 + iVar7);
        iVar7 = iVar7 + 4;
      } while (iVar4 != iVar7);
      iVar4 = iVar4 + 0x1c;
    } while (iVar4 != 0x1dc);
    iVar4 = 0;
    do {
      puVar2 = (undefined4 *)((int)tx_pwr_ch_os_a0 + iVar4);
      puVar3 = (undefined4 *)((int)tx_pwr_ch_os + iVar4);
      iVar4 = iVar4 + 4;
      *puVar3 = *puVar2;
    } while (iVar4 != 0x38);
    puVar5 = txcal_para;
    puVar8 = txcal_para_a0;
    do {
      puVar9 = puVar8 + 4;
      *puVar5 = *puVar8;
      puVar5[1] = puVar8[1];
      puVar5[2] = puVar8[2];
      puVar5[3] = puVar8[3];
      puVar5 = puVar5 + 4;
      puVar8 = puVar9;
    } while (puVar9 != txcal_para_a1);
    opti_regs->vbcore = 10;
    prVar1 = opti_regs;
    opti_regs->iet = 3;
    prVar1->vbcore_11n = 10;
    prVar1->iet_11n = 3;
    prVar1->vbcore_11g = 10;
    prVar1->iet_11g = 3;
    prVar1->vbcore_11b = 10;
    prVar1->iet_11b = 3;
    prVar1->lo_fbdv_halfstep_en = 0;
    prVar1->lo_fbdv_halfstep_en_tx = 0;
    prVar1->lo_fbdv_halfstep_en_tx = 0;
    prVar1->clkpll_reset_postdiv = 0;
    prVar1->clkpll_dither_sel = 0;
    return;
  }
  if (CONCAT31(in_register_00002029,chipv) == 1) {
    tmxcss._0_4_ = 0x50005;
    tmxcss[2] = 5;
    iVar4 = 0x1c;
    do {
      iVar7 = iVar4 + -0x1c;
      do {
        iVar10 = iVar7;
        *(undefined4 *)((int)tx_pwr_table + iVar10) = *(undefined4 *)((int)tx_pwr_table_a1 + iVar10)
        ;
        *(undefined4 *)((int)tx_pwr_table_origin + iVar10) =
             *(undefined4 *)((int)tx_pwr_table_a1 + iVar10);
        iVar7 = iVar10 + 4;
      } while (iVar10 + 4 != iVar4);
      iVar4 = iVar10 + 0x20;
    } while (iVar4 != 0x1dc);
    iVar4 = 0;
    do {
      puVar2 = (undefined4 *)((int)tx_pwr_ch_os_a1 + iVar4);
      puVar3 = (undefined4 *)((int)tx_pwr_ch_os + iVar4);
      iVar4 = iVar4 + 4;
      *puVar3 = *puVar2;
    } while (iVar4 != 0x38);
    ppvVar6 = (void_fn **)txcal_para;
    ppvVar11 = (void_fn **)txcal_para_a1;
    do {
      ppvVar12 = ppvVar11 + 4;
      *ppvVar6 = *ppvVar11;
      ppvVar6[1] = ppvVar11[1];
      ppvVar6[2] = ppvVar11[2];
      ppvVar6[3] = ppvVar11[3];
      ppvVar6 = ppvVar6 + 4;
      ppvVar11 = ppvVar12;
    } while (ppvVar12 != intc_irq_handlers);
    opti_regs->vbcore = 0xc;
    prVar1 = opti_regs;
    opti_regs->iet = 5;
    prVar1->vbcore_11n = 0xc;
    prVar1->iet_11n = 5;
    prVar1->vbcore_11g = 0xc;
    prVar1->iet_11g = 5;
    prVar1->vbcore_11b = 0xc;
    prVar1->iet_11b = 5;
    prVar1->lo_fbdv_halfstep_en = 1;
    prVar1->lo_fbdv_halfstep_en_tx = 1;
    prVar1->lo_fbdv_halfstep_en_tx = 1;
    prVar1->clkpll_reset_postdiv = 1;
    prVar1->clkpll_dither_sel = 2;
  }
  return;
}



void rf_pri_update_tx_power_offset(uint8_t channel,int8_t *power_offset)

{
  char cVar1;
  undefined3 in_register_00002029;
  int32_t *piVar2;
  int32_t *piVar3;
  
  cVar1 = power_offset[CONCAT31(in_register_00002029,channel)];
  memcpy(tx_pwr_table,tx_pwr_table_origin,0x1c0);
  piVar2 = tx_pwr_table;
  do {
    piVar3 = piVar2 + 7;
    piVar2[5] = piVar2[5] + (int)cVar1 % 4;
    piVar2[6] = piVar2[6] + ((int)cVar1 / 4) * -10;
    piVar2 = piVar3;
  } while (piVar3 != tx_pwr_table_origin);
  rf_pri_set_gain_table_regs();
  return;
}



void rf_pri_get_notch_param(uint32_t chanfreq_MHz,uint8_t *ncf_on,int32_t *ncf_freq_Hz)

{
  uint uVar1;
  int32_t iVar2;
  
  uVar1 = 0xd;
  if (chanfreq_MHz < 0x9a9) {
    uVar1 = (chanfreq_MHz - 0x96c) / 5;
  }
  iVar2 = rx_notch_para_40M[uVar1 * 2 + 1];
  *ncf_on = (uint8_t)rx_notch_para_40M[uVar1 * 2];
  *ncf_freq_Hz = iVar2;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_update_param(uint32_t chanfreq_MHz)

{
  ushort uVar1;
  int iVar2;
  int32_t *piVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int32_t iVar7;
  int iVar8;
  uint32_t uVar9;
  int32_t *piVar10;
  
  index_os_pre = 0;
  index_os_pre_mdb = 0;
  dvga_os_pre = 0;
  up_dn = 0;
  if ((chanfreq_MHz < 0x96c) || (chanfreq_MHz < 0x971)) {
    iVar5 = 0;
  }
  else {
    if (chanfreq_MHz < 0x97b) {
      iVar5 = 1;
    }
    else {
      if (chanfreq_MHz < 0x98a) {
        iVar5 = 2;
      }
      else {
        if (chanfreq_MHz < 0x999) {
          iVar5 = 3;
        }
        else {
          iVar4 = 8;
          iVar5 = 7;
          if (0x9a7 < chanfreq_MHz) goto LAB_23016d38;
          iVar5 = 4;
        }
      }
    }
  }
  uVar9 = Tchannels[iVar5];
  iVar8 = 0;
  if (uVar9 != chanfreq_MHz) {
    iVar8 = chanfreq_MHz - uVar9;
  }
  iVar6 = iVar5 + 1;
  iVar4 = (uint)((Tchannel_os[iVar6] - Tchannel_os[iVar5]) * iVar8) / (Tchannels[iVar6] - uVar9) +
          Tchannel_os[iVar5];
  iVar5 = (uint)((Tchannel_os_low[iVar6] - Tchannel_os_low[iVar5]) * iVar8) /
          (Tchannels[iVar6] - uVar9) + Tchannel_os_low[iVar5];
LAB_23016d38:
  piVar3 = temps;
  piVar10 = temps;
  iVar8 = 0;
  iVar6 = 10;
  do {
    iVar2 = (piVar10[4] + iVar8) - (0x14 - iVar5);
    iVar8 = 0;
    if (iVar6 < iVar2) {
      iVar8 = iVar2 - iVar6;
      iVar2 = iVar6;
    }
    piVar10[3] = iVar2;
    iVar6 = iVar6 + -5;
    piVar10 = piVar10 + -1;
  } while (iVar6 != -10);
  iVar8 = 0x38;
  iVar5 = 0;
  do {
    iVar7 = (piVar3[5] - iVar5) + (0x14 - iVar4);
    if (0x5f < iVar7) {
      iVar7 = iVar7 + (5 - iVar4 / 4);
    }
    piVar3[6] = iVar7;
    iVar6 = piVar3[6];
    iVar5 = 0;
    if (iVar6 < iVar8) {
      iVar5 = iVar8 - iVar6;
      iVar6 = iVar8;
    }
    piVar3[6] = iVar6;
    iVar8 = iVar8 + 5;
    piVar3 = piVar3 + 1;
  } while (iVar8 != 0x5b);
  uVar1 = tmxcss[2];
  if (chanfreq_MHz < 0x986) {
    uVar1 = tmxcss[1];
  }
  _DAT_4000106c = (uint)uVar1 | _DAT_4000106c & 0xfffffff8;
  tx_pwr_os = tx_pwr_ch_os[6];
  if (chanfreq_MHz != 0x98a) {
    if (chanfreq_MHz < 0x98b) {
      tx_pwr_os = tx_pwr_ch_os[2];
      if (chanfreq_MHz != 0x976) {
        if (chanfreq_MHz < 0x977) {
          tx_pwr_os = tx_pwr_ch_os[0];
          if ((chanfreq_MHz != 0x96c) && (tx_pwr_os = tx_pwr_ch_os[1], chanfreq_MHz != 0x971)) {
            temps[4] = 0xf;
            temps[5] = 0x33;
            tx_pwr_os = 0;
            return;
          }
        }
        else {
          tx_pwr_os = tx_pwr_ch_os[4];
          if (((chanfreq_MHz != 0x980) && (tx_pwr_os = tx_pwr_ch_os[5], chanfreq_MHz != 0x985)) &&
             (tx_pwr_os = tx_pwr_ch_os[3], chanfreq_MHz != 0x97b)) {
            temps[4] = 0xf;
            temps[5] = 0x33;
            tx_pwr_os = 0;
            return;
          }
        }
      }
    }
    else {
      tx_pwr_os = tx_pwr_ch_os[10];
      if (chanfreq_MHz != 0x99e) {
        if (chanfreq_MHz < 0x99f) {
          tx_pwr_os = tx_pwr_ch_os[8];
          if (((chanfreq_MHz != 0x994) && (tx_pwr_os = tx_pwr_ch_os[9], chanfreq_MHz != 0x999)) &&
             (tx_pwr_os = tx_pwr_ch_os[7], chanfreq_MHz != 0x98f)) {
            temps[4] = 0xf;
            temps[5] = 0x33;
            tx_pwr_os = 0;
            return;
          }
        }
        else {
          tx_pwr_os = tx_pwr_ch_os[12];
          if (((chanfreq_MHz != 0x9a8) && (tx_pwr_os = tx_pwr_ch_os[13], chanfreq_MHz != 0x9b4)) &&
             (tx_pwr_os = tx_pwr_ch_os[11], chanfreq_MHz != 0x9a3)) {
            temps[4] = 0xf;
            temps[5] = 0x33;
            tx_pwr_os = 0;
            return;
          }
        }
      }
    }
  }
  temps[4] = 0xf;
  temps[5] = 0x33;
  return;
}



void rf_pri_xtalfreq(uint32_t xtalfreq)

{
  if (xtalfreq == 0) {
    channel_div_table[0] = 0x21638e39;
    channel_div_table[1] = 0x2171c71c;
    channel_div_table[2] = 0x21800000;
    channel_div_table[3] = 0x218e38e4;
    channel_div_table[4] = 0x219c71c7;
    channel_div_table[5] = 0x21aaaaab;
    channel_div_table[6] = 0x21b8e38e;
    channel_div_table[7] = 0x21c71c72;
    channel_div_table[8] = 0x21d55555;
    channel_div_table[9] = 0x21e38e39;
    channel_div_table[10] = 0x21f1c71c;
    channel_div_table[11] = 0x22000000;
    channel_div_table[12] = 0x220e38e4;
    channel_div_table[13] = 0x221c71c7;
    channel_div_table[14] = 0x222aaaab;
    channel_div_table[15] = 0x2238e38e;
    channel_div_table[16] = 0x22471c72;
    channel_div_table[17] = 0x22555555;
    channel_div_table[18] = 0x22638e39;
    channel_div_table[19] = 0x2271c71c;
    channel_div_table[20] = 0x22800000;
    fcal_div = 0x500;
    rx_notch_para_40M[4][0] = 1;
    rx_notch_para_40M[6][0] = 1;
    rx_notch_para_40M[7][0] = 1;
    rx_notch_para_40M[12][0] = 1;
    rx_notch_para_40M[1][1] = 7000000;
    rx_notch_para_40M[2][1] = (int32_t)&DAT_001e8480;
    rx_notch_para_40M[3][1] = -3000000;
    rx_notch_para_40M[4][1] = -8000000;
    rx_notch_para_40M[6][1] = 6000000;
    rx_notch_para_40M[7][1] = 1000000;
    rx_notch_para_40M[8][1] = -4000000;
    rx_notch_para_40M[9][1] = -9000000;
    rx_notch_para_40M[0][0] = 0;
    rx_notch_para_40M[10][0] = 0;
    rx_notch_para_40M[0][1] = 0;
    rx_notch_para_40M[10][1] = 0;
    rx_notch_para_40M[11][1] = 5000000;
LAB_2301713a:
    channel_cnt_range[2] = 0xace7;
    channel_cnt_range._0_4_ = 0xa6e7a6a7;
    rx_notch_para_40M[11][0] = 1;
    rx_notch_para_40M[9][0] = 1;
    rx_notch_para_40M[5][1] = 0;
    rx_notch_para_40M[5][0] = 0;
    rx_notch_para_40M[3][0] = 1;
    rx_notch_para_40M[2][0] = 1;
    rx_notch_para_40M[1][0] = 1;
    channel_cnt_table[20] = 0xac80;
    channel_cnt_table._36_4_ = 0xac39abf2;
    channel_cnt_table._32_4_ = 0xababab64;
    channel_cnt_table._28_4_ = 0xab1caad5;
    channel_cnt_table._24_4_ = 0xaa8eaa47;
    channel_cnt_table._20_4_ = 0xaa00a9b9;
    channel_cnt_table._16_4_ = 0xa972a92b;
    channel_cnt_table._12_4_ = 0xa8e4a89c;
    channel_cnt_table._8_4_ = 0xa855a80e;
    channel_cnt_table._4_4_ = 0xa7c7a780;
    channel_cnt_table._0_4_ = 0xa739a6f2;
LAB_2301713c:
    rx_notch_para_40M[8][0] = 1;
    rx_notch_para_40M[12][1] = 0;
  }
  else {
    if (xtalfreq == 1) {
      channel_div_table[0] = 0x1ed20d21;
      channel_div_table[1] = 0x1edf2df3;
      channel_div_table[2] = 0x1eec4ec5;
      channel_div_table[3] = 0x1ef96f97;
      channel_div_table[4] = 0x1f069069;
      channel_div_table[5] = 0x1f13b13b;
      channel_div_table[6] = 0x1f20d20d;
      channel_div_table[7] = 0x1f2df2df;
      channel_div_table[8] = 0x1f3b13b1;
      channel_div_table[9] = 0x1f483483;
      channel_div_table[10] = 0x1f555555;
      channel_div_table[11] = 0x1f627627;
      channel_div_table[12] = 0x1f6f96f9;
      channel_div_table[13] = 0x1f7cb7cb;
      channel_div_table[14] = 0x1f89d89e;
      channel_div_table[15] = 0x1f96f970;
      channel_div_table[16] = 0x1fa41a42;
      channel_div_table[17] = 0x1fb13b14;
      channel_div_table[18] = 0x1fbe5be6;
      channel_div_table[19] = 0x1fcb7cb8;
      channel_div_table[20] = 0x1fd89d8a;
      channel_cnt_table._0_4_ = 0xa743a6fc;
      channel_cnt_table._4_4_ = 0xa7d1a78a;
      channel_cnt_table._8_4_ = 0xa860a819;
      channel_cnt_table._12_4_ = 0xa8eea8a7;
      channel_cnt_table._16_4_ = 0xa97ca935;
      channel_cnt_table._20_4_ = 0xaa0aa9c3;
      channel_cnt_table._24_4_ = 0xaa99aa52;
      channel_cnt_table._28_4_ = 0xab27aae0;
      channel_cnt_table._32_4_ = 0xabb5ab6e;
      channel_cnt_table._36_4_ = 0xac43abfc;
      channel_cnt_table[20] = 0xac8b;
      channel_cnt_range._0_4_ = 0xa6f1a6b1;
      channel_cnt_range[2] = 0xacf2;
      fcal_div = 0x56b;
      rx_notch_para_40M[0][1] = 6000000;
      rx_notch_para_40M[1][1] = 1000000;
      rx_notch_para_40M[2][1] = -4000000;
      rx_notch_para_40M[3][1] = -9000000;
      rx_notch_para_40M[5][1] = 7000000;
      rx_notch_para_40M[6][1] = (int32_t)&DAT_001e8480;
      rx_notch_para_40M[7][1] = -3000000;
      rx_notch_para_40M[8][1] = -8000000;
      rx_notch_para_40M[10][1] = 8000000;
      rx_notch_para_40M[11][1] = 3000000;
      rx_notch_para_40M[4][0] = 0;
      rx_notch_para_40M[9][0] = 0;
      rx_notch_para_40M[9][1] = 0;
      rx_notch_para_40M[12][1] = -2000000;
      rx_notch_para_40M[8][0] = xtalfreq;
      rx_notch_para_40M[12][0] = xtalfreq;
    }
    else {
      if (xtalfreq != 2) {
        if (xtalfreq == 3) {
          channel_div_table[0] = 0x14de38e4;
          channel_div_table[1] = 0x14e71c72;
          channel_div_table[2] = 0x14f00000;
          channel_div_table[3] = 0x14f8e38e;
          channel_div_table[4] = 0x1501c71c;
          channel_div_table[5] = 0x150aaaab;
          channel_div_table[6] = 0x15138e39;
          channel_div_table[7] = 0x151c71c7;
          channel_div_table[8] = 0x15255555;
          channel_div_table[9] = 0x152e38e4;
          channel_div_table[10] = 0x15371c72;
          channel_div_table[11] = 0x15400000;
          channel_div_table[12] = 0x1548e38e;
          channel_div_table[13] = 0x1551c71c;
          channel_div_table[14] = 0x155aaaab;
          channel_div_table[15] = 0x15638e39;
          channel_div_table[16] = 0x156c71c7;
          channel_div_table[17] = 0x15755555;
          channel_div_table[18] = 0x157e38e4;
          channel_div_table[19] = 0x15871c72;
          channel_div_table[20] = 0x15900000;
          fcal_div = 0x800;
          rx_notch_para_40M[0][0] = 1;
          rx_notch_para_40M[10][0] = 1;
          rx_notch_para_40M[0][1] = 7200000;
          rx_notch_para_40M[1][1] = 2200000;
          rx_notch_para_40M[2][1] = -2800000;
          rx_notch_para_40M[3][1] = -7800000;
          rx_notch_para_40M[8][1] = 5600000;
          rx_notch_para_40M[9][1] = 600000;
          rx_notch_para_40M[10][1] = -4400000;
          rx_notch_para_40M[4][0] = 0;
          rx_notch_para_40M[6][0] = 0;
          rx_notch_para_40M[7][0] = 0;
          rx_notch_para_40M[12][0] = 0;
          rx_notch_para_40M[4][1] = 0;
          rx_notch_para_40M[6][1] = 0;
          rx_notch_para_40M[7][1] = 0;
          rx_notch_para_40M[11][1] = -9400000;
          goto LAB_2301713a;
        }
        if (xtalfreq == 4) {
          channel_cnt_table._0_4_ = 0xa732a6eb;
          channel_cnt_table._4_4_ = 0xa7c0a779;
          channel_cnt_table._8_4_ = 0xa84fa808;
          channel_cnt_table._12_4_ = 0xa8dda896;
          channel_cnt_table._16_4_ = 0xa96ba924;
          channel_cnt_table._20_4_ = 0xa9f9a9b2;
          channel_cnt_table._24_4_ = 0xaa87aa40;
          channel_cnt_table._28_4_ = 0xab16aacf;
          channel_cnt_table._32_4_ = 0xaba4ab5d;
          channel_cnt_table._36_4_ = 0xac32abeb;
          channel_cnt_table[20] = 0xac79;
          channel_div_table[0] = 0x14088889;
          channel_div_table[1] = 0x14111111;
          channel_div_table[2] = 0x1419999a;
          channel_div_table[3] = 0x14222222;
          channel_div_table[4] = 0x142aaaab;
          channel_div_table[5] = 0x14333333;
          channel_div_table[6] = 0x143bbbbc;
          channel_div_table[7] = 0x14444444;
          channel_div_table[8] = 0x144ccccd;
          channel_div_table[9] = 0x14555555;
          channel_div_table[10] = 0x145dddde;
          channel_div_table[11] = 0x14666666;
          channel_div_table[12] = 0x146eeeef;
          channel_div_table[13] = 0x14777777;
          channel_div_table[14] = 0x14800000;
          channel_div_table[15] = 0x14888889;
          channel_div_table[16] = 0x14911111;
          channel_div_table[17] = 0x1499999a;
          channel_div_table[18] = 0x14a22222;
          channel_div_table[19] = 0x14aaaaab;
          channel_div_table[20] = 0x14b33333;
          rx_notch_para_40M[0][0] = 0;
          rx_notch_para_40M[0][1] = 0;
          rx_notch_para_40M[1][0] = 0;
          rx_notch_para_40M[1][1] = 0;
          rx_notch_para_40M[2][0] = 0;
          rx_notch_para_40M[2][1] = 0;
          rx_notch_para_40M[3][0] = 0;
          rx_notch_para_40M[3][1] = 0;
          rx_notch_para_40M[4][0] = 1;
          rx_notch_para_40M[4][1] = 8000000;
          rx_notch_para_40M[5][0] = 1;
          rx_notch_para_40M[5][1] = 3000000;
          rx_notch_para_40M[6][0] = 1;
          rx_notch_para_40M[6][1] = -2000000;
          rx_notch_para_40M[7][0] = 1;
          rx_notch_para_40M[7][1] = -7000000;
          rx_notch_para_40M[8][0] = 0;
          rx_notch_para_40M[8][1] = 0;
          rx_notch_para_40M[9][0] = 0;
          rx_notch_para_40M[9][1] = 0;
          rx_notch_para_40M[10][0] = 0;
          rx_notch_para_40M[10][1] = 0;
          rx_notch_para_40M[11][0] = 0;
          rx_notch_para_40M[11][1] = 0;
          rx_notch_para_40M[12][0] = 1;
          rx_notch_para_40M[12][1] = 8000000;
          rx_notch_para_40M[13][0] = 1;
          rx_notch_para_40M[13][1] = -4000000;
          channel_cnt_range._0_4_ = 0xa6e0a6a0;
          channel_cnt_range[2] = 0xace0;
          fcal_div = 0x855;
          return;
        }
        if (xtalfreq != 5) {
          return;
        }
        channel_div_table[0] = 0xf690690;
        channel_div_table[1] = 0xf6f96f9;
        channel_div_table[2] = 0xf762762;
        channel_div_table[3] = 0xf7cb7cb;
        channel_div_table[4] = 0xf834835;
        channel_div_table[5] = 0xf89d89e;
        channel_div_table[6] = 0xf906907;
        channel_div_table[7] = 0xf96f970;
        channel_div_table[8] = 0xf9d89d9;
        channel_div_table[9] = 0xfa41a42;
        channel_div_table[10] = 0xfaaaaab;
        channel_div_table[11] = 0xfb13b14;
        channel_div_table[12] = 0xfb7cb7d;
        channel_div_table[13] = 0xfbe5be6;
        channel_div_table[14] = 0xfc4ec4f;
        channel_div_table[15] = 0xfcb7cb8;
        channel_div_table[16] = 0xfd20d21;
        channel_div_table[17] = 0xfd89d8a;
        channel_div_table[18] = 0xfdf2df3;
        channel_div_table[19] = 0xfe5be5c;
        channel_div_table[20] = 0xfec4ec5;
        channel_cnt_table._0_4_ = 0xa734a6ed;
        channel_cnt_table._4_4_ = 0xa7c2a77b;
        channel_cnt_table._8_4_ = 0xa850a809;
        channel_cnt_table._12_4_ = 0xa8dea897;
        channel_cnt_table._16_4_ = 0xa96da925;
        channel_cnt_table._20_4_ = 0xa9fba9b4;
        channel_cnt_table._24_4_ = 0xaa89aa42;
        channel_cnt_table._28_4_ = 0xab17aad0;
        channel_cnt_table._32_4_ = 0xaba5ab5e;
        channel_cnt_table._36_4_ = 0xac34abec;
        channel_cnt_table[20] = 0xac7b;
        channel_cnt_range._0_4_ = 0xa6e2a6a2;
        channel_cnt_range[2] = 0xace2;
        fcal_div = 0xad5;
        rx_notch_para_40M[5][0] = 1;
        rx_notch_para_40M[6][0] = 1;
        rx_notch_para_40M[7][0] = 1;
        rx_notch_para_40M[5][1] = 7000000;
        rx_notch_para_40M[6][1] = (int32_t)&DAT_001e8480;
        rx_notch_para_40M[7][1] = -3000000;
        rx_notch_para_40M[0][0] = 0;
        rx_notch_para_40M[1][0] = 0;
        rx_notch_para_40M[2][0] = 0;
        rx_notch_para_40M[3][0] = 0;
        rx_notch_para_40M[4][0] = 0;
        rx_notch_para_40M[9][0] = 0;
        rx_notch_para_40M[10][0] = 0;
        rx_notch_para_40M[11][0] = 0;
        rx_notch_para_40M[12][0] = 0;
        rx_notch_para_40M[0][1] = 0;
        rx_notch_para_40M[1][1] = 0;
        rx_notch_para_40M[2][1] = 0;
        rx_notch_para_40M[3][1] = 0;
        rx_notch_para_40M[4][1] = 0;
        rx_notch_para_40M[8][1] = -8000000;
        rx_notch_para_40M[9][1] = 0;
        rx_notch_para_40M[10][1] = 0;
        rx_notch_para_40M[11][1] = 0;
        goto LAB_2301713c;
      }
      channel_div_table[0] = 0x190aaaab;
      channel_div_table[1] = 0x19155555;
      channel_div_table[2] = 0x19200000;
      channel_div_table[3] = 0x192aaaab;
      channel_div_table[4] = 0x19355555;
      channel_div_table[5] = 0x19400000;
      channel_div_table[6] = 0x194aaaab;
      channel_div_table[7] = 0x19555555;
      channel_div_table[8] = 0x19600000;
      channel_div_table[9] = 0x196aaaab;
      channel_div_table[10] = 0x19755555;
      channel_div_table[11] = 0x19800000;
      channel_div_table[12] = 0x198aaaab;
      channel_div_table[13] = 0x19955555;
      channel_div_table[14] = 0x19a00000;
      channel_div_table[15] = 0x19aaaaab;
      channel_div_table[16] = 0x19b55555;
      channel_div_table[17] = 0x19c00000;
      channel_div_table[18] = 0x19caaaab;
      channel_div_table[19] = 0x19d55555;
      channel_div_table[20] = 0x19e00000;
      channel_cnt_table._0_4_ = 0xa741a6fa;
      channel_cnt_table._4_4_ = 0xa7d0a788;
      channel_cnt_table._8_4_ = 0xa85ea817;
      channel_cnt_table._12_4_ = 0xa8eca8a5;
      channel_cnt_table._16_4_ = 0xa97aa933;
      channel_cnt_table._20_4_ = 0xaa09a9c1;
      channel_cnt_table._24_4_ = 0xaa97aa50;
      channel_cnt_table._28_4_ = 0xab25aade;
      channel_cnt_table._32_4_ = 0xabb3ab6c;
      channel_cnt_table._36_4_ = 0xac42abfa;
      channel_cnt_table[20] = 0xac89;
      channel_cnt_range._0_4_ = 0xa6efa6af;
      channel_cnt_range[2] = 0xacf0;
      fcal_div = 0x6ab;
      rx_notch_para_40M[4][0] = 1;
      rx_notch_para_40M[9][0] = 1;
      rx_notch_para_40M[12][0] = 1;
      rx_notch_para_40M[2][1] = 10000000;
      rx_notch_para_40M[3][1] = 5000000;
      rx_notch_para_40M[5][1] = -5000000;
      rx_notch_para_40M[6][1] = -10000000;
      rx_notch_para_40M[9][1] = 7000000;
      rx_notch_para_40M[10][1] = (int32_t)&DAT_001e8480;
      rx_notch_para_40M[11][1] = -3000000;
      rx_notch_para_40M[8][0] = 0;
      rx_notch_para_40M[0][1] = 0;
      rx_notch_para_40M[1][1] = 0;
      rx_notch_para_40M[7][1] = 0;
      rx_notch_para_40M[8][1] = 0;
      rx_notch_para_40M[12][1] = -8000000;
    }
    rx_notch_para_40M[4][1] = 0;
    rx_notch_para_40M[0][0] = rx_notch_para_40M[8][0];
    rx_notch_para_40M[1][0] = rx_notch_para_40M[8][0];
    rx_notch_para_40M[2][0] = rx_notch_para_40M[12][0];
    rx_notch_para_40M[3][0] = rx_notch_para_40M[12][0];
    rx_notch_para_40M[5][0] = rx_notch_para_40M[12][0];
    rx_notch_para_40M[6][0] = rx_notch_para_40M[12][0];
    rx_notch_para_40M[7][0] = rx_notch_para_40M[8][0];
    rx_notch_para_40M[10][0] = rx_notch_para_40M[12][0];
    rx_notch_para_40M[11][0] = rx_notch_para_40M[12][0];
  }
  rx_notch_para_40M[13][0] = 0;
  rx_notch_para_40M[13][1] = 0;
  return;
}



uint32_t rf_pri_get_vco_freq_cw(uint32_t chanfreq_MHz)

{
  int iVar1;
  
  __floatunsidf(chanfreq_MHz - 0x964 >> 2);
  __adddf3();
  iVar1 = __fixdfsi();
  if (0x14 < iVar1) {
    iVar1 = 0x14;
  }
  return (uint)*(ushort *)(&(rf_calib_data->cal).field_0x8 + (iVar1 + 8) * 2) & 0xff;
}



uint32_t rf_pri_get_vco_idac_cw(uint32_t chanfreq_MHz)

{
  int iVar1;
  
  __floatunsidf(chanfreq_MHz - 0x964 >> 2);
  __adddf3();
  iVar1 = __fixdfsi();
  if (0x14 < iVar1) {
    iVar1 = 0x14;
  }
  return (uint)(*(ushort *)(&(rf_calib_data->cal).field_0x8 + (iVar1 + 8) * 2) >> 8) & 0x1f;
}



int32_t rf_pri_get_txgain_max(void)

{
  return tx_pwr_os_temperature + tx_pwr_table[0][6] + tx_pwr_os;
}



int32_t rf_pri_get_txgain_min(void)

{
  return tx_pwr_os_temperature + tx_pwr_table[15][6] + tx_pwr_os;
}



uint32_t rf_pri_get_txgain_index(int32_t pwr,uint32_t mode)

{
  int32_t *piVar1;
  uint32_t uVar2;
  
  if (mode == 0) {
    pwr = pwr + -0x1e;
  }
  piVar1 = tx_pwr_table;
  uVar2 = 0;
  do {
    if (piVar1[6] + tx_pwr_os + tx_pwr_os_temperature <= pwr) {
      return uVar2;
    }
    uVar2 = uVar2 + 1;
    piVar1 = piVar1 + 7;
  } while (uVar2 != 0x10);
  return 0xf;
}



void rf_pri_query_txgain_table(uint32_t index,uint32_t *rfg_index,uint32_t *dg)

{
  if (0xf < index) {
    index = 0xf;
  }
  *rfg_index = 7 - (index >> 1);
  *dg = tx_pwr_table[index * 7 + 5];
  return;
}



void rf_pri_update_dvga_os(int8_t dvga_os)

{
  int iVar1;
  int32_t *piVar2;
  int8_t *piVar3;
  
  piVar2 = tx_pwr_table;
  iVar1 = 0;
  do {
    piVar3 = temps_dvga + iVar1;
    iVar1 = iVar1 + 1;
    *piVar3 = (char)piVar2[5] + dvga_os;
    piVar2 = piVar2 + 7;
  } while (iVar1 != 0x10);
  return;
}



void rf_pri_tx_gain_comp(int32_t Tsens)

{
  int iVar1;
  int iVar2;
  int32_t *piVar3;
  uint uVar4;
  
  if (up_dn == 1) {
    if ((Tthr <= Tsens) || (Tsens <= Tthr + -5)) {
LAB_23017d2a:
      piVar3 = temps;
      iVar2 = 0xc;
      do {
        if (piVar3[0xc] <= Tsens) break;
        iVar2 = iVar2 + -1;
        piVar3 = piVar3 + -1;
      } while (iVar2 != -1);
      if (iVar2 < 0) {
        iVar2 = 0;
      }
      uVar4 = iVar2 - 4;
      iVar1 = temps[iVar2];
      Tthr = iVar1;
      if (Tsens < 0x23) {
        if (iVar1 < Tsens) {
          Tthr = temps[iVar2 + 1];
          if (0x22 < temps[iVar2 + 1]) {
            Tthr = iVar1;
          }
        }
        else {
          uVar4 = iVar2 - 5;
        }
      }
      else {
        if (iVar1 < 0x24) {
          Tthr = temps[iVar2 + 1];
        }
      }
      if (index_os_pre_mdb < (int)uVar4) {
        up_dn = 1;
      }
      else {
        if ((int)uVar4 < index_os_pre_mdb) {
          up_dn = -1;
        }
      }
      if ((int)uVar4 < 1) {
        dvga_os_pre = 0;
        index_os_pre = uVar4;
        if (uVar4 != 0) {
          dvga_os_pre = 0xffffffff;
          if ((uVar4 & 1) != 0) {
            dvga_os_pre = 1;
          }
          index_os_pre = (int)(uVar4 - 1) / 2;
        }
      }
      else {
        dvga_os_pre = uVar4 + 1 & 1;
        if (dvga_os_pre == 0) {
          dvga_os_pre = 0xffffffff;
        }
        index_os_pre = (int)(uVar4 + 1) >> 1;
      }
      tx_pwr_os_temperature = index_os_pre * -10;
      index_os_pre_mdb = uVar4;
      goto LAB_23017cfe;
    }
  }
  else {
    if (((up_dn != -1) || (Tsens <= Tthr)) || (Tthr + 5 <= Tsens)) goto LAB_23017d2a;
  }
  tx_pwr_os_temperature = index_os_pre * -10;
LAB_23017cfe:
  rf_pri_update_dvga_os((int8_t)dvga_os_pre);
  rfc_apply_tx_dvga(temps_dvga);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_txcal(void)

{
  int32_t val;
  uint32_t center;
  uint val_00;
  uint val_01;
  uint32_t *puVar1;
  int iVar2;
  uint32_t *puVar3;
  int32_t *piVar4;
  uint val_02;
  uint uVar5;
  int iVar6;
  
  _DAT_40001014 = _DAT_40001014 & 0xff0fffff | 0x500000;
  rf_pri_save_state_for_cal();
  rf_pri_manu_pu(5);
  rf_pri_config_channel();
  _DAT_4000101c = _DAT_4000101c | 0x3000;
  _DAT_40001084 = _DAT_40001084 | 0x80000000;
  _DAT_40001064 = _DAT_40001064 | 0x400000;
  iVar2 = 7;
  _DAT_4000106c = (uint)tmxcss[0] | _DAT_4000106c & 0xfffffff8;
  rf_pri_singen_config(0x3d);
  puVar3 = txcal_para;
  piVar4 = tx_pwr_table;
  do {
    _DAT_40001064 = *puVar3 << 0x1c | _DAT_40001064 & 0xfc3ffff | puVar3[2] << 0x12;
    _DAT_40001058 = puVar3[1] << 0x10 | _DAT_40001058 & 0xfff8ffff;
    _DAT_40001048 = *piVar4 << 0x1c | _DAT_40001048 & 0xce08ffff | piVar4[3] << 0x14 | 0x70000;
    BL602_Delay_US(10);
    val_02 = puVar3[3];
    uVar5 = val_02;
    do {
      uVar5 = uVar5 >> 1;
      _DAT_40001214 = val_02 | _DAT_40001214 & 0xfffff800;
      _DAT_40001218 = val_02 | _DAT_40001218 & 0xfffff800;
      rf_pri_singen_start();
      rf_pri_start_txdfe();
      BL602_Delay_US(10);
      val = rf_pri_pm_pwr_avg(1,0x400);
      iVar6 = val >> 10;
      printf("amp=%ld,step=%ld,adc_mean_i=%ld\r\n",val_02,uVar5,iVar6);
      if (iVar6 < 0x141) {
        val_00 = uVar5;
        if (0xbf < iVar6) break;
      }
      else {
        val_00 = -uVar5;
      }
      val_02 = val_02 + val_00;
    } while (uVar5 != 0);
    rf_pri_pm_pwr_avg(1,0x1000);
    center = rf_pri_txcal_search_core(0,0x20,0x10,0x3d);
    rf_pri_txcal_config(0,center);
    uVar5 = rf_pri_txcal_search_core(1,0x20,0x10,0x3d);
    _DAT_40001070 = uVar5 << 0x10 | _DAT_40001070 & 0xffc0ffff;
    val_02 = rf_pri_txcal_search_core(0,center,2,0x3d);
    rf_pri_txcal_config(0,val_02);
    center = rf_pri_txcal_search_core(2,0x400,0x80,0x7a);
    rf_pri_txcal_config(2,center);
    val = rf_pri_txcal_search_core(3,0,0x40,0x7a);
    rf_pri_txcal_config(3,val);
    val_00 = rf_pri_txcal_search_core(2,center,0x40,0x7a);
    rf_pri_txcal_config(2,val_00);
    val_01 = rf_pri_txcal_search_core(3,0,0x20,0x7a);
    rf_pri_txcal_config(3,val_01);
    puVar1 = &rf_calib_data->inited + (iVar2 + 0xc) * 2;
    puVar1[2] = puVar1[2] & 0xffffffc0 | val_02 & 0x3f;
    puVar1[2] = puVar1[2] & 0xfffff03f | (uVar5 & 0x3f) << 6;
    puVar1[2] = puVar1[2] & 0xff800fff | (val_00 & 0x7ff) << 0xc;
    puVar1[3] = puVar1[3] & 0xfffffc00 | val_01 & 0x3ff;
    printf("tosdac_i=%ld,tosdac_q=%ld,tx_iq_gain_comp=%ld,tx_iq_phase_comp=%ld\r\n",val_02,uVar5,
           val_00);
    iVar2 = iVar2 + -1;
    puVar3 = puVar3 + 4;
    piVar4 = piVar4 + 0xe;
    if (iVar2 == -1) {
      rf_pri_txcal_config_hw();
      _DAT_4000101c = _DAT_4000101c & 0xffffcfff;
      rf_pri_restore_state_for_cal();
      _DAT_40001014 = _DAT_40001014 | 0xf00000;
      _DAT_40001070 =
           (*(uint *)(rf_calib_data->txcal + 3) >> 6 & 0x3f) << 0x10 |
           (*(uint *)(rf_calib_data->txcal + 3) & 0x3f) << 0x18 | _DAT_40001070 & 0xc0c0ffff;
      _DAT_40001600 =
           *(uint *)&rf_calib_data->txcal[3].field_0x4 & 0x3ff |
           *(uint *)(rf_calib_data->txcal + 3) & 0x7ff000 | _DAT_40001600 & 0xff800c00;
      return;
    }
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_roscal(void)

{
  uint32_t uVar1;
  uint uVar2;
  
  _DAT_40001014 = _DAT_40001014 & 0xffff3fff;
  if ((_DAT_40001020 & 0x100) != 0) {
    _DAT_40001014 = _DAT_40001014 | 0x4000;
    rf_pri_save_state_for_cal();
    rf_pri_manu_pu(3);
    _DAT_4000101c = _DAT_4000101c | 0x200;
    rf_pri_config_channel();
    _DAT_40001048 = _DAT_40001048 & 0xffff8fff | 0x6300;
    uVar1 = rf_pri_roscal_iq(1);
    uVar2 = uVar1 & 0x3f;
    *(uint *)(rf_calib_data->rxcal + 3) = *(uint *)(rf_calib_data->rxcal + 3) & 0xffffffc0 | uVar2;
    _DAT_4000116c = _DAT_4000116c & 0xffc0ffff | uVar1 << 0x10;
    printf("rosdac_i_gc3=%ld\r\n",uVar1);
    *(uint *)(rf_calib_data->rxcal + 2) = *(uint *)(rf_calib_data->rxcal + 2) & 0xffffffc0 | uVar2;
    _DAT_4000116c = uVar1 | _DAT_4000116c & 0xffffffc0;
    printf("rosdac_i_gc2=%ld\r\n",uVar1);
    *(uint *)(rf_calib_data->rxcal + 1) = *(uint *)(rf_calib_data->rxcal + 1) & 0xffffffc0 | uVar2;
    _DAT_40001168 = uVar1 << 0x10 | _DAT_40001168 & 0xffc0ffff;
    printf("rosdac_i_gc1=%ld\r\n",uVar1);
    *(uint *)rf_calib_data->rxcal = *(uint *)rf_calib_data->rxcal & 0xffffffc0 | uVar2;
    _DAT_40001168 = uVar1 | _DAT_40001168 & 0xffffffc0;
    printf("rosdac_i_gc0=%ld\r\n",uVar1);
    uVar1 = rf_pri_roscal_iq(0);
    uVar2 = (uVar1 & 0x3f) << 6;
    *(uint *)(rf_calib_data->rxcal + 3) = *(uint *)(rf_calib_data->rxcal + 3) & 0xfffff03f | uVar2;
    _DAT_4000116c = _DAT_4000116c & 0xc0ffffff | uVar1 << 0x18;
    printf("rosdac_q_gc3=%ld\r\n",uVar1);
    *(uint *)(rf_calib_data->rxcal + 2) = *(uint *)(rf_calib_data->rxcal + 2) & 0xfffff03f | uVar2;
    _DAT_4000116c = _DAT_4000116c & 0xffffc0ff | uVar1 << 8;
    printf("rosdac_q_gc2=%ld\r\n",uVar1);
    *(uint *)(rf_calib_data->rxcal + 1) = *(uint *)(rf_calib_data->rxcal + 1) & 0xfffff03f | uVar2;
    _DAT_40001168 = uVar1 << 0x18 | _DAT_40001168 & 0xc0ffffff;
    printf("rosdac_q_gc1=%ld\r\n",uVar1);
    *(uint *)rf_calib_data->rxcal = *(uint *)rf_calib_data->rxcal & 0xfffff03f | uVar2;
    _DAT_40001168 = uVar1 << 8 | _DAT_40001168 & 0xffffc0ff;
    printf("rosdac_q_gc0=%ld\r\n",uVar1);
    rf_pri_restore_state_for_cal();
    _DAT_40001014 = _DAT_40001014 | 0xc000;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_rccal(void)

{
  rf_calib_data_tag *prVar1;
  uint32_t uVar2;
  uint32_t uVar3;
  uint uVar4;
  uint uVar5;
  
  _DAT_40001014 = _DAT_40001014 & 0xfff3ffff;
  if ((_DAT_40001020 & 0x400) != 0) {
    _DAT_40001014 = _DAT_40001014 | 0x40000;
    rf_pri_save_state_for_cal();
    rf_pri_manu_pu(4);
    _DAT_40001084 = _DAT_40001084 & 0xfcffffff | 0x2000000;
    _DAT_4000108c = _DAT_4000108c | 0x1000;
    _DAT_4000101c = _DAT_4000101c | 0x800;
    uVar2 = rf_pri_rccal_iq(1);
    uVar3 = rf_pri_rccal_iq(0);
    prVar1 = rf_calib_data;
    uVar5 = _DAT_40001080;
    *(uint *)&(rf_calib_data->cal).field_0x4 =
         *(uint *)&(rf_calib_data->cal).field_0x4 & 0xffffffc0 | _DAT_40001080 >> 0x18 & 0x3f;
    *(uint *)&(prVar1->cal).field_0x4 =
         *(uint *)&(prVar1->cal).field_0x4 & 0xfffff03f | (uVar5 >> 0x10 & 0x3f) << 6;
    *(uint *)&(prVar1->cal).field_0x4 =
         *(uint *)&(prVar1->cal).field_0x4 & 0xfffc0fff | (uVar5 >> 8 & 0x3f) << 0xc;
    *(uint *)&(prVar1->cal).field_0x4 =
         (uVar5 & 0x3f) << 0x12 | *(uint *)&(prVar1->cal).field_0x4 & 0xff03ffff;
    printf("rbb_cap1_fc_i=%ld,rbb_cap2_fc_i=%ld,rbb_cap1_fc_q=%ld,rbb_cap2_fc_q=%ld\r\n",
           *(uint *)&(prVar1->cal).field_0x4 & 0x3f,*(uint *)&(prVar1->cal).field_0x4 >> 0xc & 0x3f,
           *(uint *)&(prVar1->cal).field_0x4 >> 6 & 0x3f,
           *(uint *)&(prVar1->cal).field_0x4 >> 0x12 & 0x3f);
    prVar1 = rf_calib_data;
    uVar5 = *(uint *)&(rf_calib_data->cal).field_0x4 & 0x3f;
    if (uVar5 < (*(uint *)&(rf_calib_data->cal).field_0x4 >> 6 & 0x3f)) {
      uVar5 = *(uint *)&(rf_calib_data->cal).field_0x4 >> 6 & 0x3f;
    }
    if (uVar5 < (*(uint *)&(rf_calib_data->cal).field_0x4 >> 0xc & 0x3f)) {
      uVar5 = *(uint *)&(rf_calib_data->cal).field_0x4 >> 0xc & 0x3f;
    }
    if (uVar5 < (*(uint *)&(rf_calib_data->cal).field_0x4 >> 0x12 & 0x3f)) {
      uVar5 = *(uint *)&(rf_calib_data->cal).field_0x4 >> 0x12 & 0x3f;
    }
    uVar4 = 0x18;
    if (0x27 < uVar5) {
      uVar4 = 0x3f - uVar5;
    }
    uVar4 = uVar4 & 0xff;
    *(uint *)&(rf_calib_data->cal).field_0x4 =
         *(uint *)&(rf_calib_data->cal).field_0x4 & 0xffffffc0 |
         *(int *)&(rf_calib_data->cal).field_0x4 + uVar4 & 0x3f;
    *(uint *)&(prVar1->cal).field_0x4 =
         ((*(uint *)&(prVar1->cal).field_0x4 >> 6) + uVar4 & 0x3f) << 6 |
         *(uint *)&(prVar1->cal).field_0x4 & 0xfffff03f;
    *(uint *)&(prVar1->cal).field_0x4 =
         ((*(uint *)&(prVar1->cal).field_0x4 >> 0xc) + uVar4 & 0x3f) << 0xc |
         *(uint *)&(prVar1->cal).field_0x4 & 0xfffc0fff;
    *(uint *)&(prVar1->cal).field_0x4 =
         ((*(uint *)&(prVar1->cal).field_0x4 >> 0x12) + uVar4 & 0x3f) << 0x12 |
         *(uint *)&(prVar1->cal).field_0x4 & 0xff03ffff;
    rf_pri_rccal_config(*(uint *)&(prVar1->cal).field_0x4 & 0x3f);
    rf_pri_rccal_config(0,*(uint *)&(rf_calib_data->cal).field_0x4 >> 6 & 0x3f);
    printf("new rbb_cap1_fc_i=%ld,rbb_cap2_fc_i=%ld,rbb_cap1_fc_q=%ld,rbb_cap2_fc_q=%ld\r\n",
           *(uint *)&(rf_calib_data->cal).field_0x4 & 0x3f,
           *(uint *)&(rf_calib_data->cal).field_0x4 >> 0xc & 0x3f,
           *(uint *)&(rf_calib_data->cal).field_0x4 >> 6 & 0x3f,
           *(uint *)&(rf_calib_data->cal).field_0x4 >> 0x12 & 0x3f);
    rf_pri_restore_state_for_cal();
    if ((uVar2 == 2) || (uVar3 == 2)) {
      _DAT_40001014 = _DAT_40001014 & 0xfff3ffff | 0x80000;
    }
    else {
      _DAT_40001014 = _DAT_40001014 | 0xc0000;
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_lo_acal(void)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  uint32_t *puVar4;
  uint32_t *puVar5;
  uint uVar6;
  
  _DAT_40001014 = _DAT_40001014 & 0xffffff3f | 0x40;
  rf_pri_save_state_for_cal();
  rf_pri_manu_pu(6);
  puVar4 = channel_div_table;
  iVar3 = 0;
  do {
    _DAT_4000101c = _DAT_4000101c | 0x10;
    _DAT_400010a4 = _DAT_400010a4 & 0xfffff8ff | 0x400;
    uVar6 = 3;
    uVar1 = 0x10;
    _DAT_400010a0 =
         (uint)*(ushort *)(&(rf_calib_data->cal).field_0x8 + (iVar3 + 8) * 2) & 0xff |
         _DAT_400010a0 & 0xffe0ff00 | 0x100000;
    _DAT_400010c4 = *puVar4;
    BL602_Delay_US(1);
    while (_DAT_400010a0 = _DAT_400010a0 & 0xffe0ffff | uVar1 << 0x10, uVar6 != 0xffffffff) {
      BL602_Delay_US(1);
      iVar2 = 1 << (uVar6 & 0x1f);
      if ((int)(_DAT_400010a4 << 0x13) < 0) {
        iVar2 = -iVar2;
      }
      uVar1 = uVar1 + iVar2;
      uVar6 = uVar6 - 1;
    }
    BL602_Delay_US(1);
    if ((-1 < (int)(_DAT_400010a4 << 0x13)) && (uVar1 < 0x1f)) {
      uVar1 = uVar1 + 1;
    }
    puVar5 = (uint32_t *)((int)&rf_calib_data->inited + (iVar3 + 8) * 2);
    *(ushort *)(puVar5 + 3) = *(ushort *)(puVar5 + 3) & 0xe0ff | (ushort)((uVar1 & 0x1f) << 8);
    printf("%ldth channel,vco_idac_cw=%ld\r\n",iVar3,uVar1);
    iVar3 = iVar3 + 1;
    puVar4 = puVar4 + 1;
  } while (iVar3 != 0x15);
  rf_pri_restore_state_for_cal();
  _DAT_40001014 = _DAT_40001014 | 0xc0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_fcal(void)

{
  uint cw;
  uint16_t uVar1;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  int iVar2;
  uint32_t *puVar3;
  uint uVar4;
  uint uVar5;
  uint cw_00;
  uint16_t *puVar6;
  uint uVar7;
  
  cw_00 = (uint)channel_cnt_range[0];
  uVar7 = (uint)channel_cnt_range[1];
  uVar5 = (uint)channel_cnt_range[2];
  _DAT_40001014 = _DAT_40001014 & 0xffffffcf | 0x10;
  rf_pri_save_state_for_cal();
  rf_pri_manu_pu(7);
  _DAT_4000101c = _DAT_4000101c | 8;
  _DAT_400010a0 = _DAT_400010a0 & 0xffffff00 | 0x80;
  _DAT_400010a8 = (uint)fcal_div | _DAT_400010a8 & 0xffff0000;
  _DAT_400010c4 = 0x1000000;
  _DAT_400010c0 = _DAT_400010c0 & 0xfffeffff | 0x1000;
  _DAT_400010b8 = _DAT_400010b8 & 0xffffcfff | 0x10000;
  BL602_Delay_US(10);
  _DAT_400010c0 = _DAT_400010c0 | 0x10000;
  _DAT_400010b8 = _DAT_400010b8 & 0xfffeffff;
  BL602_Delay_US(0x32);
  _DAT_400010a4 = _DAT_400010a4 & 0xfffffffc | 2;
  BL602_Delay_US(0x32);
  do {
    uVar4 = 6;
    cw = 0x80;
    while (uVar4 != 0xffffffff) {
      uVar1 = rf_pri_fcal_meas(cw);
      if (CONCAT22(extraout_var,uVar1) < cw_00) {
        iVar2 = -(1 << (uVar4 & 0x1f));
      }
      else {
        if (CONCAT22(extraout_var,uVar1) <= uVar7) break;
        iVar2 = 1 << (uVar4 & 0x1f);
      }
      cw = cw + iVar2 & 0xffff;
      uVar4 = uVar4 - 1;
    }
    if (0xe < cw) break;
    printf("Unexpected cw %ld\r\n",cw);
    _DAT_400010c0 = _DAT_400010c0 & 0xfffeffff;
    _DAT_400010b8 = _DAT_400010b8 | 0x10000;
    BL602_Delay_US(0x32);
    _DAT_400010c0 = _DAT_400010c0 | 0x10000;
    _DAT_400010b8 = _DAT_400010b8 & 0xfffeffff;
    BL602_Delay_US(0x32);
  } while( true );
  cw_00 = cw + 1 & 0xffff;
  channel_cnt_opt_table[0] = rf_pri_fcal_meas(cw_00);
  puVar6 = channel_cnt_opt_table;
  do {
    cw_00 = cw_00 - 1 & 0xffff;
    uVar1 = rf_pri_fcal_meas(cw_00);
    puVar6[1] = uVar1;
    if (uVar5 < CONCAT22(extraout_var_00,uVar1)) break;
    puVar6 = puVar6 + 1;
  } while (cw_00 != (cw - 0x26 & 0xffff));
  iVar2 = 0;
  uVar5 = 0;
  puVar6 = channel_cw_table;
  do {
    while (cw_00 = uVar5 & 0xffff,
          channel_cnt_opt_table[uVar5] < *(ushort *)((int)channel_cnt_table + iVar2)) {
      uVar5 = (int)((cw_00 + 1) * 0x10000) >> 0x10;
    }
    *(short *)((int)channel_cw_table + iVar2) = ((short)cw + 2) - (short)cw_00;
    if ((int)uVar5 < 1) {
      uVar5 = 0;
    }
    else {
      uVar5 = (int)((cw_00 - 1) * 0x10000) >> 0x10;
    }
    iVar2 = iVar2 + 2;
  } while (iVar2 != 0x2a);
  rf_pri_restore_state_for_cal();
  iVar2 = 0;
  do {
    puVar3 = (uint32_t *)((int)&rf_calib_data->inited + (iVar2 + 8) * 2);
    iVar2 = iVar2 + 1;
    *(ushort *)(puVar3 + 3) = *(ushort *)(puVar3 + 3) & 0xff00 | *puVar6 & 0xff;
    printf("%ldth channel,lo_vco_freq_cw=%ld\r\n");
    puVar6 = puVar6 + 1;
  } while (iVar2 != 0x15);
  _DAT_40001014 = _DAT_40001014 | 0x30;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_full_cal(void)

{
  _DAT_40001220 = _DAT_40001220 & 0xffffff9f | 0x61;
  rf_pri_start_txdfe();
  rf_pri_fcal();
  rf_pri_lo_acal();
  rf_pri_roscal();
  rf_pri_rccal();
  rf_pri_txcal();
  _DAT_4000100c = _DAT_4000100c | 6;
  _DAT_40001220 = _DAT_40001220 & 0xffffe61c;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_restore_cal_reg(void)

{
  _DAT_40001168 =
       (*(uint *)(rf_calib_data->rxcal + 1) >> 6 & 0x3f) << 0x18 |
       (*(uint *)rf_calib_data->rxcal >> 6 & 0x3f) << 8 |
       *(uint *)rf_calib_data->rxcal & 0x3f | _DAT_40001168 & 0xc0c0c0c0 |
       (*(uint *)(rf_calib_data->rxcal + 1) & 0x3f) << 0x10;
  _DAT_4000116c =
       (*(uint *)(rf_calib_data->rxcal + 3) >> 6 & 0x3f) << 0x18 |
       (*(uint *)(rf_calib_data->rxcal + 2) >> 6 & 0x3f) << 8 |
       *(uint *)(rf_calib_data->rxcal + 2) & 0x3f | _DAT_4000116c & 0xc0c0c0c0 |
       (*(uint *)(rf_calib_data->rxcal + 3) & 0x3f) << 0x10;
  _DAT_40001080 =
       (*(uint *)&(rf_calib_data->cal).field_0x4 >> 6 & 0x3f) << 0x10 |
       (*(uint *)&(rf_calib_data->cal).field_0x4 >> 0xc & 0x3f) << 8 |
       (*(uint *)&(rf_calib_data->cal).field_0x4 & 0x3f) << 0x18 | _DAT_40001080 & 0xc0c0c0c0 |
       *(uint *)&(rf_calib_data->cal).field_0x4 >> 0x12 & 0x3f;
  rf_pri_txcal_config_hw();
  _DAT_40001070 =
       (*(uint *)(rf_calib_data->txcal + 3) >> 6 & 0x3f) << 0x10 |
       (*(uint *)(rf_calib_data->txcal + 3) & 0x3f) << 0x18 | _DAT_40001070 & 0xc0c0ffff;
  _DAT_40001600 =
       *(uint *)(rf_calib_data->txcal + 3) & 0x7ff000 | _DAT_40001600 & 0xff800c00 |
       *(uint *)&rf_calib_data->txcal[3].field_0x4 & 0x3ff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_init(uint8_t reset,uint8_t chipv)

{
  undefined3 in_register_00002029;
  int iVar1;
  
  iVar1 = CONCAT31(in_register_00002029,reset);
  rf_pri_chipv(chipv);
  init_fast = (uint32_t)(iVar1 == 0);
  _DAT_4000f814 = _DAT_4000f814 & 0xfffff0ff | 0x300;
  _DAT_4000f030 = _DAT_4000f030 & 0xf0ffffff | 0x8000000;
  _DAT_40001030 = _DAT_40001030 | 0x1001;
  _DAT_4000f884 = _DAT_4000f884 | 4;
  if (iVar1 != 0) {
    BL602_Delay_MS(10);
  }
  _DAT_40001064 = _DAT_40001064 & 0xffff8008 | opti_regs->vbcore << 8 | opti_regs->iet << 4 | 0x4002
  ;
  _DAT_40001128 =
       _DAT_40001128 & 0xff800fff | opti_regs->vbcore_11n << 0x10 | opti_regs->iet_11n << 0xc |
       0x400000;
  _DAT_4000112c =
       (_DAT_4000112c & 0xfffff800 | opti_regs->vbcore_11g << 4 | opti_regs->iet_11g) & 0xff800fff |
       0x400 | opti_regs->vbcore_11b << 0x10 | opti_regs->iet_11b << 0xc | 0x400000;
  _DAT_40001090 = _DAT_40001090 | 0x10000;
  _DAT_400010b8 = opti_regs->lo_fbdv_halfstep_en << 4 | _DAT_400010b8 & 0xffffffef;
  _DAT_40001138 =
       (_DAT_40001138 & 0xfffffffc | opti_regs->lo_fbdv_halfstep_en_tx << 1 |
       opti_regs->lo_fbdv_halfstep_en_tx) & 0xfffcfff7 | 0x300;
  _DAT_40001130 = _DAT_40001130 & 0xfffefffe;
  _DAT_4000e400 = opti_regs->clkpll_reset_postdiv << 1 | _DAT_4000e400 & 0xfffffffd;
  _DAT_4000e418 = opti_regs->clkpll_dither_sel << 0x18 | _DAT_4000e418 & 0xfcffffff;
  _DAT_4000108c = _DAT_4000108c & 0xfffffffc | 2;
  _DAT_4000f030 = _DAT_4000f030 & 0xfff0ffff | 0xc0000;
  rf_pri_set_gain_table_regs();
  _DAT_4000e404 = _DAT_4000e404 | 0x10000;
  _DAT_4000e41c = _DAT_4000e41c | 0xff;
  if (iVar1 == 0) {
    rf_pri_restore_cal_reg();
    return;
  }
  rf_pri_full_cal();
  return;
}



void rf_pri_update_power_offset(int32_t *power_offset)

{
  undefined4 uVar1;
  int iVar2;
  
  iVar2 = 0;
  do {
    uVar1 = *(undefined4 *)((int)power_offset + iVar2);
    *(undefined4 *)((int)tx_pwr_ch_os_a1 + iVar2) = uVar1;
    *(undefined4 *)((int)tx_pwr_ch_os + iVar2) = uVar1;
    iVar2 = iVar2 + 4;
  } while (iVar2 != 0x38);
  return;
}



int phyif_utils_decode(phyif_utils_recvtable_t *vec,int8_t *ppm)

{
  char cVar1;
  int8_t iVar2;
  SItype SVar3;
  
  cVar1 = *(char *)((int)&vec->recvtable5 + 3);
  if (((*(ushort *)((int)&vec->recvtable2 + 2) & 7) < 2) && ((vec->recvtable1 >> 0xc & 0xf) < 4)) {
    __floatsidf(-(int)cVar1);
    __muldf3();
    SVar3 = __fixdfsi();
    iVar2 = (int8_t)SVar3;
  }
  else {
    iVar2 = (int8_t)((int)CONCAT11(*(undefined *)&vec->recvtable6,cVar1) / 0x7a);
  }
  *ppm = iVar2;
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void sysctrl_init(void)

{
  _DAT_44900068 = 0x8000000c;
  _DAT_449000e0 = _DAT_449000e0 | 0x1ff00;
  return;
}



void intc_spurious(void)

{
  assert_err("0","module",0x36);
  return;
}



void intc_enable_irq(int index)

{
  *(int *)(((index >> 5) + 0x11244004) * 4) = 1 << (index & 0x1fU);
  return;
}



void intc_init(void)

{
  intc_enable_irq(0x3f);
  intc_enable_irq(0x3e);
  intc_enable_irq(0x3d);
  intc_enable_irq(0x18);
  intc_enable_irq(0x19);
  intc_enable_irq(0x1a);
  intc_enable_irq(0x1b);
  intc_enable_irq(0x1c);
  intc_enable_irq(0x1d);
  intc_enable_irq(0x1e);
  intc_enable_irq(0x1f);
  intc_enable_irq(0x20);
  intc_enable_irq(0x21);
  intc_enable_irq(0x23);
  intc_enable_irq(0x37);
  intc_enable_irq(0x35);
  intc_enable_irq(0x32);
  intc_enable_irq(0x34);
  intc_enable_irq(0x36);
  intc_enable_irq(10);
  intc_enable_irq(0xb);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mac_irq(void)

{
  void_fn *pvVar1;
  
  if ((_DAT_44910000 == 0) && (_DAT_44910004 == 0)) {
    return;
  }
  pvVar1 = intc_irq_handlers[_DAT_44910040];
  if (pvVar1 == (void_fn *)0x0) {
    assert_err("intc_irq_handlers[irq_idx] != NULL","module",0x9d);
  }
  (*pvVar1)();
  ipc_emb_notify();
  return;
}



void bl_irq_handler(void)

{
  ipc_host_disable_irq_e2a();
  ke_evt_set(0x40000000);
  ipc_emb_notify();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void blmac_pwr_mgt_setf(uint8_t pwrmgt)

{
  uint uVar1;
  undefined3 in_register_00002029;
  
  uVar1 = CONCAT31(in_register_00002029,pwrmgt) << 2;
  if ((uVar1 & 0xfffffffb) != 0) {
    assert_err("(((uint32_t)pwrmgt << 2) & ~((uint32_t)0x00000004)) == 0","module",0x952);
  }
  _DAT_44b0004c = _DAT_44b0004c & 0xfffffffb | uVar1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

chan_ctxt_tag * chan_get_next_chan(void)

{
  int iVar1;
  int iVar2;
  chan_ctxt_tag *pcVar3;
  uint uVar4;
  ushort uVar5;
  
  iVar2 = _DAT_44b00120;
  iVar1 = DAT_4201d1e8;
  if (DAT_4201d1f8 != (chan_ctxt_tag *)0x0) {
    if ((DAT_4201d1e8 != 0) && (*(char *)(DAT_4201d1e8 + 10) == '\x02')) {
      return DAT_4201d1f8;
    }
    if (-1 < (_DAT_44b00120 + 0x1400) - DAT_4201d21c) {
      return DAT_4201d1f8;
    }
    if (DAT_4201d1f8->status == '\x04') {
      return DAT_4201d1f8;
    }
  }
  pcVar3 = DAT_4201d1f8;
  if ((DAT_4201d1e8 != 0) && (*(int *)(DAT_4201d1e8 + 4) - DAT_4201d21c < 0)) {
    pcVar3 = vif_info_tab[*(byte *)(DAT_4201d1e8 + 8)].chan_ctxt;
    if (pcVar3 == (chan_ctxt_tag *)0x0) {
      assert_err("p_next_chan_entry","module",0x129);
    }
    if (-1 < (iVar2 + 0x1400) - *(int *)(iVar1 + 4)) goto LAB_230190f4;
    uVar4 = 0;
    if (pcVar3->nb_res_slots < pcVar3->nb_rem_slots) {
      uVar4 = (uint)(ushort)(pcVar3->nb_rem_slots - pcVar3->nb_res_slots);
    }
    if (((uint)(*(int *)(iVar1 + 4) - iVar2) >> 10 & 0xffff) <= uVar4) {
      return pcVar3;
    }
  }
  uVar5 = 0;
  if (chan_ctxt_pool[0].status != '\0') {
    pcVar3 = chan_ctxt_pool;
    uVar5 = chan_ctxt_pool[0].nb_rem_slots;
  }
  if ((chan_ctxt_pool[1].status != '\0') && (uVar5 <= chan_ctxt_pool[1].nb_rem_slots)) {
    pcVar3 = chan_ctxt_pool + 1;
    uVar5 = chan_ctxt_pool[1].nb_rem_slots;
  }
  if ((chan_ctxt_pool[2].status != '\0') && (uVar5 <= chan_ctxt_pool[2].nb_rem_slots)) {
    return chan_ctxt_pool + 2;
  }
LAB_230190f4:
  if (pcVar3 == (chan_ctxt_tag *)0x0) {
    assert_err("p_next_chan_entry","module",0x175);
  }
  return pcVar3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void chan_conn_less_delay_prog(void)

{
  DAT_4201d248 = DAT_4201d248 | 0x10;
  mm_timer_set((mm_timer_tag *)&DAT_4201d230,_DAT_44b00120 + 30000);
  return;
}



void chan_upd_nb_rem_slots(uint32_t current_time)

{
  ushort uVar1;
  ushort uVar2;
  int in_a1;
  uint uVar3;
  
  uVar1 = *(ushort *)current_time;
  uVar3 = (uint)(in_a1 - DAT_4201d244) >> 10 & 0xffff;
  uVar2 = (ushort)uVar3;
  if (uVar1 < uVar3) {
    uVar2 = uVar1;
  }
  *(ushort *)current_time = uVar1 - uVar2;
  return;
}



_Bool chan_tbtt_detect_conflict(void)

{
  byte bVar1;
  int in_a0;
  int in_a1;
  
  if (((in_a0 - in_a1 < 0) || (bVar1 = 1, (in_a1 + 0x2800) - in_a0 < 0)) &&
     (bVar1 = 0, -1 < in_a1 - in_a0)) {
    bVar1 = ~(byte)((uint)((in_a0 - in_a1) + 0x2800) >> 0x18) >> 7;
  }
  return (_Bool)bVar1;
}



void chan_tbtt_insert(chan_tbtt_tag *p_tbtt_entry)

{
  bool bVar1;
  co_list_hdr list_hdr;
  char cVar2;
  _Bool _Var3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  co_list_hdr cVar4;
  uint uVar5;
  uint uVar6;
  co_list_hdr prev_element;
  co_list_hdr cVar7;
  
  list_hdr = (co_list_hdr)0x0;
  cVar2 = '\0';
  cVar4 = DAT_4201d1e8;
  prev_element = (co_list_hdr)0x0;
  while (cVar4 != (co_list_hdr)0x0) {
    if (cVar4 == (co_list_hdr)p_tbtt_entry) {
      assert_err("p_elem != p_tbtt_entry","module",0x668);
    }
    uVar5 = p_tbtt_entry->time;
    uVar6 = *(uint *)((int)cVar4 + 4);
    cVar7 = cVar4;
    if (*(char *)((int)cVar4 + 10) == '\x02') {
      if ((uVar5 < uVar6) ||
         (_Var3 = chan_tbtt_detect_conflict(), CONCAT31(extraout_var_00,_Var3) != 0)) {
LAB_23019264:
        cVar2 = '\x01';
        bVar1 = false;
        list_hdr = (co_list_hdr)p_tbtt_entry;
        goto LAB_230192ac;
      }
    }
    else {
      _Var3 = chan_tbtt_detect_conflict();
      if (CONCAT31(extraout_var,_Var3) == 0) {
        if (uVar5 < uVar6) break;
      }
      else {
        if (p_tbtt_entry->priority <= *(byte *)((int)cVar4 + 9)) goto LAB_23019264;
        if (list_hdr == (co_list_hdr)0x0) {
          list_hdr = cVar4;
        }
        cVar2 = cVar2 + '\x01';
        cVar7 = prev_element;
      }
    }
    cVar4 = *(co_list_hdr *)cVar4;
    prev_element = cVar7;
  }
  bVar1 = true;
LAB_230192ac:
  while (cVar2 = cVar2 + -1, cVar2 != -1) {
    if (list_hdr == (co_list_hdr)0x0) {
      assert_err("p_delay_elem","module",0x6b1);
    }
    if (list_hdr != (co_list_hdr)p_tbtt_entry) {
      if (*(char *)((int)list_hdr + 10) == '\x01') {
        mm_timer_clear((mm_timer_tag *)&DAT_4201d200);
        *(undefined *)((int)list_hdr + 10) = 0;
      }
      co_list_extract((co_list *)&DAT_4201d1e8,(co_list_hdr *)list_hdr);
    }
    co_list_push_back((co_list *)&DAT_4201d1f0,(co_list_hdr *)list_hdr);
    list_hdr = *(co_list_hdr *)list_hdr;
  }
  if (!bVar1) {
    return;
  }
  co_list_insert_after
            ((co_list *)&DAT_4201d1e8,(co_list_hdr *)prev_element,(co_list_hdr *)p_tbtt_entry);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void chan_upd_ctxt_status(chan_ctxt_tag *p_chan_entry,uint8_t next_status)

{
  undefined3 in_register_0000202d;
  int iVar1;
  ushort uVar2;
  int iVar3;
  uint32_t value;
  
  iVar1 = CONCAT31(in_register_0000202d,next_status);
  if (iVar1 == 2) {
    value = 0;
    if (2 < p_chan_entry->idx) goto LAB_23019324;
    iVar3 = 4000;
  }
  else {
    value = 0;
    if (iVar1 != 4) goto LAB_23019324;
    if (p_chan_entry->idx < 3) {
      if (1 < DAT_4201d24a) {
        if ((p_chan_entry->nb_res_slots < p_chan_entry->nb_rem_slots) &&
           (uVar2 = p_chan_entry->nb_rem_slots - p_chan_entry->nb_res_slots, 4 < uVar2)) {
          iVar3 = (uint)uVar2 << 10;
          DAT_4201d244 = _DAT_44b00120;
          goto LAB_23019322;
        }
      }
      iVar1 = 5;
      value = 0;
      goto LAB_23019324;
    }
    iVar3 = (uint)p_chan_entry->nb_rem_slots << 10;
  }
LAB_23019322:
  value = iVar3 + _DAT_44b00120;
LAB_23019324:
  p_chan_entry->status = (uint8_t)iVar1;
  if (value != 0) {
    DAT_4201d228 = p_chan_entry;
    mm_timer_set((mm_timer_tag *)&DAT_4201d220,value);
    return;
  }
  if (iVar1 != 3) {
    mm_timer_clear((mm_timer_tag *)&DAT_4201d220);
    return;
  }
  return;
}



void chan_switch_start(chan_ctxt_tag *p_chan_entry)

{
  undefined4 *puVar1;
  
  if (DAT_4201d1f8 == p_chan_entry) {
    if ((1 < DAT_4201d24a) && (DAT_4201d1f8->idx < 3)) {
      chan_upd_ctxt_status(p_chan_entry,'\x04');
      return;
    }
  }
  else {
    if (DAT_4201d1fc == (chan_ctxt_tag *)0x0) {
      DAT_4201d1fc = p_chan_entry;
      chan_upd_ctxt_status(p_chan_entry,'\x02');
      puVar1 = (undefined4 *)ke_msg_alloc(0x60,0,0xff,4);
      *puVar1 = 0x230199ec;
      ke_msg_send();
      return;
    }
  }
  return;
}



void chan_conn_less_delay_evt(void *env)

{
  chan_ctxt_tag *p_chan_entry;
  
  if ((DAT_4201d248 & 1) == 0) {
    if ((DAT_4201d248 & 2) == 0) {
      return;
    }
    if ((DAT_4201d248 & 8) != 0) {
      assert_err("(chan_env.status & CO_BIT(CHAN_ENV_SCAN_BIT)) == 0","module",0x2ce);
    }
    p_chan_entry = chan_ctxt_pool + 3;
    DAT_4201d248 = DAT_4201d248 & 0xfd | 8;
  }
  else {
    if ((DAT_4201d248 & 4) != 0) {
      assert_err("(chan_env.status & CO_BIT(CHAN_ENV_ROC_BIT)) == 0","module",0x2c0);
    }
    p_chan_entry = chan_ctxt_pool + 4;
    DAT_4201d248 = DAT_4201d248 & 0xfe | 4;
  }
  if (DAT_4201d1fc != 0) {
    return;
  }
  chan_switch_start(p_chan_entry);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void chan_tbtt_switch_evt(void *env)

{
  ushort uVar1;
  undefined4 uVar2;
  ushort uVar3;
  chan_ctxt_tag *p_chan_entry;
  
  uVar2 = _DAT_44b00120;
  if ((1 < DAT_4201d24a) && ((DAT_4201d248 & 0xc) == 0)) {
    p_chan_entry = vif_info_tab[*(byte *)((int)env + 8)].chan_ctxt;
    if ((DAT_4201d1fc == (chan_ctxt_tag *)0x0) || (DAT_4201d1fc == p_chan_entry)) {
      *(undefined *)((int)env + 9) = 0;
      chan_upd_nb_rem_slots(DAT_4201d1f8 + 0x12);
      uVar1 = p_chan_entry->nb_res_slots;
      uVar3 = uVar1;
      if (10 < uVar1) {
        uVar3 = 10;
      }
      p_chan_entry->nb_res_slots = uVar1 - uVar3;
      DAT_4201d244 = uVar2;
      *(undefined *)((int)env + 10) = 2;
      if (DAT_4201d1fc == (chan_ctxt_tag *)0x0) {
        chan_switch_start(p_chan_entry);
        return;
      }
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void chan_tbtt_schedule(chan_tbtt_tag *p_tbtt_entry)

{
  void *pvVar1;
  chan_tbtt_tag *p_tbtt_entry_00;
  uint uVar2;
  uint32_t uVar3;
  
  if (p_tbtt_entry != (chan_tbtt_tag *)0x0) {
    chan_tbtt_insert(p_tbtt_entry);
    while (DAT_4201d1f0 != 0) {
      p_tbtt_entry_00 = (chan_tbtt_tag *)co_list_pop_front((co_list *)&DAT_4201d1f0);
      uVar2 = (uint)p_tbtt_entry_00->vif_index;
      if (vif_info_tab[uVar2].type == '\0') {
        uVar3 = sta_info_tab[vif_info_tab[uVar2].u[4]].bcn_int;
      }
      else {
        uVar3 = (uint)*(ushort *)(vif_info_tab[uVar2].u + 0x2e2) << 10;
      }
      p_tbtt_entry_00->time = uVar3 + p_tbtt_entry_00->time;
      if (p_tbtt_entry_00->priority < 5) {
        p_tbtt_entry_00->priority = p_tbtt_entry_00->priority + 1;
      }
      chan_tbtt_insert(p_tbtt_entry_00);
    }
  }
  pvVar1 = DAT_4201d1e8;
  if ((DAT_4201d1e8 != (void *)0x0) && (*(char *)((int)DAT_4201d1e8 + 10) == '\0')) {
    if ((*(int *)((int)DAT_4201d1e8 + 4) - _DAT_44b00120) + -2000 < 0) {
      chan_tbtt_switch_evt(DAT_4201d1e8);
      return;
    }
    DAT_4201d208 = DAT_4201d1e8;
    *(undefined *)((int)DAT_4201d1e8 + 10) = 1;
    mm_timer_set((mm_timer_tag *)&DAT_4201d200,*(uint32_t *)((int)pvVar1 + 4));
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void chan_cde_evt(void *env)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  chan_ctxt_tag *p_chan_entry;
  int iVar4;
  co_list_hdr *pcVar5;
  co_list_hdr cVar6;
  undefined2 uVar7;
  ushort uVar8;
  uint uVar9;
  
  iVar4 = _DAT_44b00120;
  p_chan_entry = DAT_4201d1fc;
  if ((1 < DAT_4201d24a) && (uVar2 = (uint)DAT_4201d248 & 0x2c, (DAT_4201d248 & 0x2c) == 0)) {
    mm_timer_set((mm_timer_tag *)&DAT_4201d210,DAT_4201d240 + _DAT_44b00120);
    DAT_4201d244 = iVar4;
    uVar9 = 0;
    cVar6 = (co_list_hdr)vif_mgmt_env.used_list.first;
    while (cVar6 != (co_list_hdr)0x0) {
      pcVar5 = ((co_list_hdr *)((int)cVar6 + 0x40))->next;
      if (pcVar5 != (co_list_hdr *)0x0) {
        uVar2 = uVar2 + 1 & 0xff;
        if (((td_env[*(byte *)((int)cVar6 + 0x57)].status & 3) != 0) ||
           (*(char *)&((co_list_hdr *)((int)cVar6 + 0x58))->next == '\0')) {
          uVar9 = uVar9 + 1 & 0xff;
        }
        *(undefined2 *)&pcVar5[4].next = 0;
        *(undefined2 *)&pcVar5[5].next = 0;
      }
      cVar6 = *(co_list_hdr *)cVar6;
    }
    if (uVar2 != DAT_4201d240 / 0xc800) {
      assert_warn("nb_vifs == (chan_env.cde_dur_us / (CHAN_VIF_NB_SLOTS * CHAN_SLOT_DURATION_US))",
                  "module",0x268);
    }
    if ((uVar9 == 0) || (uVar2 == uVar9)) {
      iVar3 = 0;
      iVar4 = 0x32;
    }
    else {
      iVar4 = 10;
      iVar3 = (int)((uVar2 - uVar9) * 0x280000 >> 0x10) / (int)uVar9;
    }
    cVar6 = (co_list_hdr)vif_mgmt_env.used_list.first;
    while (cVar6 != (co_list_hdr)0x0) {
      pcVar5 = ((co_list_hdr *)((int)cVar6 + 0x40))->next;
      if (pcVar5 != (co_list_hdr *)0x0) {
        if (((td_env[*(byte *)((int)cVar6 + 0x57)].status & 3) != 0) ||
           (iVar1 = iVar4, *(char *)&((co_list_hdr *)((int)cVar6 + 0x58))->next == '\0')) {
          iVar1 = iVar3 + 0x32;
        }
        uVar7 = (undefined2)(((uint)*(ushort *)&pcVar5[4].next + iVar1) * 0x10000 >> 0x10);
        *(undefined2 *)&pcVar5[4].next = uVar7;
        *(undefined2 *)((int)&pcVar5[4].next + 2) = uVar7;
        if (*(char *)((int)cVar6 + 0x56) == '\0') {
          uVar2 = sta_info_tab[*(byte *)&((co_list_hdr *)((int)cVar6 + 0x60))->next].bcn_int;
        }
        else {
          uVar2 = (uint)*(ushort *)((int)cVar6 + 0x33e) << 10;
        }
        uVar8 = (ushort)(DAT_4201d240 / uVar2);
        if (DAT_4201d240 / uVar2 == 0) {
          uVar8 = 1;
        }
        *(ushort *)&pcVar5[5].next = (uVar8 & 0xff) * 10 + *(short *)&pcVar5[5].next;
      }
      cVar6 = *(co_list_hdr *)cVar6;
    }
    if (DAT_4201d1f8 != (chan_ctxt_tag *)0x0) {
      chan_upd_ctxt_status(DAT_4201d1f8,'\x01');
    }
    p_chan_entry = chan_get_next_chan();
    if (env == (void *)0x0) {
      chan_switch_start(p_chan_entry);
      return;
    }
  }
  DAT_4201d1fc = p_chan_entry;
  return;
}


/*
Unable to decompile 'chan_pre_switch_channel'
Cause: Exception while decompiling 230197f8: Decompiler process died

*/


void chan_goto_idle_cb(void)

{
  undefined uVar1;
  co_list_hdr *pcVar2;
  co_list_hdr cVar3;
  uint8_t uVar4;
  undefined3 extraout_var;
  int iVar5;
  
  mm_force_idle_req();
  pcVar2 = DAT_4201d1f8;
  cVar3 = (co_list_hdr)vif_mgmt_env.used_list.first;
  if (((DAT_4201d1f8 != (co_list_hdr *)0x0) && ((DAT_4201d248 & 0x20) == 0)) &&
     ((ps_env.ps_on == false || ((ps_env.prevent_sleep & 8) != 0)))) {
    iVar5 = 0;
    blmac_pwr_mgt_setf('\x01');
    while (cVar3 != (co_list_hdr)0x0) {
      if ((((pcVar2 == ((co_list_hdr *)((int)cVar3 + 0x40))->next) &&
           (*(char *)((int)cVar3 + 0x56) == '\0')) &&
          (*(char *)&((co_list_hdr *)((int)cVar3 + 0x58))->next != '\0')) &&
         (*(char *)&((co_list_hdr *)((int)cVar3 + 0x60))->next != -1)) {
        uVar1 = *(undefined *)((int)&pcVar2[5].next + 2);
        *(undefined *)((int)&pcVar2[5].next + 2) = 6;
        uVar4 = txl_frame_send_null_frame
                          (*(uint8_t *)&((co_list_hdr *)((int)cVar3 + 0x60))->next,chan_tx_cfm,
                           (void *)0x0);
        if (CONCAT31(extraout_var,uVar4) == 0) {
          iVar5 = iVar5 + 1;
        }
        *(undefined *)((int)&pcVar2[5].next + 2) = uVar1;
      }
      cVar3 = *(co_list_hdr *)cVar3;
    }
    DAT_4201d249 = (undefined)iVar5;
    if (iVar5 != 0) {
      chan_upd_ctxt_status(DAT_4201d1fc,'\x03');
      mm_active();
      return;
    }
  }
  chan_pre_switch_channel();
  return;
}



void chan_tx_cfm(void *dummy,uint32_t status)

{
  if (DAT_4201d249 == '\0') {
    assert_err("chan_env.cfm_cnt","module",0x48f);
  }
  DAT_4201d249 = DAT_4201d249 + -1;
  if (DAT_4201d249 == '\0') {
    mm_force_idle_req();
    chan_pre_switch_channel();
    return;
  }
  return;
}


/*
Unable to decompile 'chan_ctxt_op_evt'
Cause: Exception while decompiling 23019b24: Decompiler process died

*/


void chan_init(void)

{
  chan_ctxt_tag *__s;
  int iVar1;
  
  __s = chan_ctxt_pool;
  memset(&chan_env,0,0x74);
  iVar1 = 0;
  do {
    memset(__s,0,0x1c);
    *(undefined2 *)(&__s->channel + 1) = 0xff;
    *(undefined *)((int)&__s->nb_res_slots + 3) = 0xff;
    if (iVar1 < 3) {
      co_list_push_back((co_list *)&chan_env,(co_list_hdr *)__s);
    }
    else {
      if (iVar1 == 3) {
        chan_ctxt_pool[3].channel.center2_freq = 0;
        chan_ctxt_pool[3].channel.type = '\0';
      }
    }
    iVar1 = iVar1 + 1;
    __s = __s + 1;
  } while (iVar1 != 5);
  DAT_4201d204 = chan_tbtt_switch_evt;
  DAT_4201d214 = chan_cde_evt;
  DAT_4201d218 = 0;
  DAT_4201d224 = chan_ctxt_op_evt;
  DAT_4201d234 = chan_conn_less_delay_evt;
  return;
}



void chan_scan_req(uint8_t band,uint16_t freq,int8_t pwr,uint32_t duration_us,uint8_t vif_index)

{
  if (chan_ctxt_pool[3].idx != -1) {
    assert_err("p_scan_chan->idx == CHAN_CTXT_UNUSED","module",0x8a1);
  }
  chan_ctxt_pool[3].taskid = 0xff;
  chan_ctxt_pool[3]._22_2_ = 0x301;
  chan_ctxt_pool[3].nb_rem_slots = (uint16_t)(duration_us >> 10);
  if ((DAT_4201d248 & 0x10) == 0) {
    chan_ctxt_pool[3].channel.band = band;
    chan_ctxt_pool[3].channel.prim20_freq = freq;
    chan_ctxt_pool[3].channel.center1_freq = freq;
    chan_ctxt_pool[3].channel.tx_power = pwr;
    chan_ctxt_pool[3].vif_index = vif_index;
    DAT_4201d248 = DAT_4201d248 | 2;
    chan_conn_less_delay_prog();
    return;
  }
  chan_ctxt_pool[3].channel.band = band;
  chan_ctxt_pool[3].channel.prim20_freq = freq;
  chan_ctxt_pool[3].channel.center1_freq = freq;
  chan_ctxt_pool[3].channel.tx_power = pwr;
  chan_ctxt_pool[3].taskid = 0xff;
  chan_ctxt_pool[3]._22_2_ = 0x301;
  chan_ctxt_pool[3].vif_index = vif_index;
  DAT_4201d248 = DAT_4201d248 | 2;
  return;
}



uint8_t chan_roc_req(mm_remain_on_channel_req *req,ke_task_id_t taskid)

{
  byte bVar1;
  undefined2 in_register_0000202e;
  
  if (req->op_code == '\0') {
    if (chan_ctxt_pool[4].idx == -1) {
      chan_ctxt_pool[4].idx = '\x04';
      chan_ctxt_pool[4].channel.band = req->band;
      chan_ctxt_pool[4].channel.type = req->type;
      chan_ctxt_pool[4].channel.prim20_freq = req->prim20_freq;
      chan_ctxt_pool[4].channel.center1_freq = req->center1_freq;
      chan_ctxt_pool[4].channel.center2_freq = req->center2_freq;
      chan_ctxt_pool[4].status = '\x01';
      chan_ctxt_pool[4].nb_rem_slots = (uint16_t)(req->duration_ms * 1000 >> 10);
      chan_ctxt_pool[4].vif_index = req->vif_index;
      chan_ctxt_pool[4].channel.tx_power = req->tx_power;
      chan_ctxt_pool[4].taskid = taskid;
      if (CONCAT22(in_register_0000202e,taskid) != 0) {
        bVar1 = DAT_4201d248 & 0x10;
        if ((DAT_4201d248 & 0x10) != 0) {
          chan_ctxt_pool[4].status = '\x01';
          chan_ctxt_pool[4].idx = '\x04';
          DAT_4201d248 = DAT_4201d248 | 1;
          return '\0';
        }
        DAT_4201d248 = DAT_4201d248 | 1;
        chan_conn_less_delay_prog();
        return bVar1;
      }
      DAT_4201d248 = DAT_4201d248 | 4;
      if (DAT_4201d1fc != 0) {
        chan_ctxt_pool[4].status = '\x01';
        chan_ctxt_pool[4].idx = '\x04';
        return '\0';
      }
      chan_switch_start(chan_ctxt_pool + 4);
      return '\0';
    }
  }
  else {
    if (req->op_code == '\x01') {
      if (chan_ctxt_pool[4].idx != -1) {
        if (chan_ctxt_pool[4].status < 4) {
          if (chan_ctxt_pool[4].status < 2) {
            if (chan_ctxt_pool[4].status == '\x01') {
              DAT_4201d248 = DAT_4201d248 & 0xfe;
            }
          }
          else {
            DAT_4201d1fc = 0;
            DAT_4201d248 = DAT_4201d248 & 0xfb;
          }
        }
        else {
          if (chan_ctxt_pool[4].status == '\x04') {
            mm_timer_clear((mm_timer_tag *)&DAT_4201d220);
            chan_ctxt_op_evt(chan_ctxt_pool + 4);
          }
        }
        chan_ctxt_pool[4].idx = -1;
        if ((DAT_4201d248 & 0x12) == 0x10) {
          DAT_4201d248 = DAT_4201d248 & 0xef;
          mm_timer_clear((mm_timer_tag *)&DAT_4201d230);
          DAT_4201d248 = DAT_4201d248 & 0xef;
        }
      }
      return '\0';
    }
  }
  return '\x01';
}



uint8_t chan_ctxt_add(mm_chan_ctxt_add_req *p_add_req,uint8_t *idx)

{
  uint8_t uVar1;
  int iVar2;
  co_list_hdr *pcVar3;
  int iVar4;
  chan_ctxt_tag *pcVar5;
  
  pcVar5 = chan_ctxt_pool;
  iVar4 = 0;
  do {
    if (pcVar5->idx != -1) {
      iVar2 = memcmp(p_add_req,&pcVar5->channel,8);
      if (iVar2 == 0) {
        *idx = (uint8_t)iVar4;
        return (uint8_t)iVar2;
      }
    }
    iVar4 = iVar4 + 1;
    pcVar5 = pcVar5 + 1;
  } while (iVar4 != 3);
  pcVar3 = co_list_pop_front((co_list *)&chan_env);
  if (pcVar3 != (co_list_hdr *)0x0) {
    uVar1 = (char)((int)(pcVar3 + -0x10807453) >> 2) * -0x49;
    *(uint8_t *)((int)&pcVar3[5].next + 3) = uVar1;
    *idx = uVar1;
    *(uint8_t *)&pcVar3[1].next = p_add_req->band;
    *(uint8_t *)((int)&pcVar3[1].next + 1) = p_add_req->type;
    *(uint16_t *)&pcVar3[2].next = p_add_req->center1_freq;
    *(uint16_t *)((int)&pcVar3[2].next + 2) = p_add_req->center2_freq;
    *(uint16_t *)((int)&pcVar3[1].next + 2) = p_add_req->prim20_freq;
    *(int8_t *)&pcVar3[3].next = p_add_req->tx_power;
  }
  return (uint8_t)(pcVar3 == (co_list_hdr *)0x0);
}



void chan_ctxt_del(uint8_t chan_idx)

{
  undefined3 in_register_00002029;
  int iVar1;
  
  iVar1 = CONCAT31(in_register_00002029,chan_idx);
  if (chan_ctxt_pool[iVar1].idx == -1) {
    assert_err("p_chan_entry->idx != CHAN_CTXT_UNUSED","module",0x989);
  }
  if (chan_ctxt_pool[iVar1].nb_linked_vif != '\0') {
    assert_err("p_chan_entry->nb_linked_vif == 0","module",0x98b);
  }
  co_list_push_back((co_list *)&chan_env,(co_list_hdr *)(chan_ctxt_pool + iVar1));
  memset(chan_ctxt_pool + iVar1,0,0x1c);
  chan_ctxt_pool[iVar1].taskid = 0xff;
  chan_ctxt_pool[iVar1].idx = -1;
  return;
}


/*
Unable to decompile 'chan_ctxt_update'
Cause: Exception while decompiling 2301a0c2: Decompiler process died

*/


void chan_tbtt_switch_update(vif_info_tag *p_vif_entry,uint32_t tbtt_time)

{
  if ((((p_vif_entry->chan_ctxt != (chan_ctxt_tag *)0x0) && (p_vif_entry->chan_ctxt->status != '\0')
       ) && ((p_vif_entry->tbtt_switch).time != tbtt_time - 0x9c4)) &&
     (((p_vif_entry->tbtt_switch).time = tbtt_time - 0x9c4, 1 < DAT_4201d24a &&
      ((p_vif_entry->tbtt_switch).status != '\x02')))) {
    (p_vif_entry->tbtt_switch).status = '\0';
    co_list_extract((co_list *)&DAT_4201d1e8,(co_list_hdr *)&p_vif_entry->tbtt_switch);
    chan_tbtt_schedule(&p_vif_entry->tbtt_switch);
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void chan_bcn_to_evt(vif_info_tag *p_vif_entry)

{
  ushort uVar1;
  int iVar2;
  chan_ctxt_tag *p_chan_entry;
  ushort uVar3;
  uint uVar4;
  
  iVar2 = _DAT_44b00120;
  if ((p_vif_entry->tbtt_switch).status == '\x02') {
    (p_vif_entry->tbtt_switch).status = '\0';
    p_chan_entry = DAT_4201d1f8;
    co_list_extract((co_list *)&DAT_4201d1e8,(co_list_hdr *)&p_vif_entry->tbtt_switch);
    if (((1 < DAT_4201d24a) &&
        (chan_tbtt_schedule(&p_vif_entry->tbtt_switch), (DAT_4201d248 & 0xc) == 0)) &&
       (DAT_4201d1fc == 0)) {
      chan_upd_nb_rem_slots((uint32_t)&p_chan_entry->nb_rem_slots);
      uVar1 = p_chan_entry->nb_res_slots;
      if (uVar1 != 0) {
        uVar4 = (uint)(iVar2 - DAT_4201d244) >> 10 & 0xffff;
        uVar3 = (ushort)uVar4;
        if (uVar1 < uVar4) {
          uVar3 = uVar1;
        }
        p_chan_entry->nb_res_slots = uVar1 - uVar3;
      }
      DAT_4201d244 = iVar2;
      p_chan_entry = chan_get_next_chan();
      if (DAT_4201d1f8 != p_chan_entry) {
        chan_switch_start(p_chan_entry);
        return;
      }
    }
  }
  return;
}



void chan_bcn_detect_start(vif_info_tag *p_vif_entry)

{
  byte bVar1;
  chan_ctxt_tag *pcVar2;
  undefined *puVar3;
  
  pcVar2 = p_vif_entry->chan_ctxt;
  if (pcVar2 == (chan_ctxt_tag *)0x0) {
    assert_err("p_chan_entry","module",0xb19);
  }
  if (((DAT_4201d248 & 0x40) == 0) && (1 < DAT_4201d24a)) {
    bVar1 = p_vif_entry->u[4];
    puVar3 = (undefined *)ke_msg_alloc(0x46,0,0,0x14);
    *puVar3 = 0;
    puVar3[1] = p_vif_entry->index;
    puVar3[2] = (pcVar2->channel).band;
    puVar3[3] = (pcVar2->channel).type;
    *(uint16_t *)(puVar3 + 4) = (pcVar2->channel).prim20_freq;
    *(uint16_t *)(puVar3 + 6) = (pcVar2->channel).center1_freq;
    *(uint16_t *)(puVar3 + 8) = (pcVar2->channel).center2_freq;
    *(uint *)(puVar3 + 0xc) = (sta_info_tab[bVar1].bcn_int - 5000) / 1000;
    puVar3[0x10] = (pcVar2->channel).tx_power;
    ke_msg_send();
    DAT_4201d248 = DAT_4201d248 | 0x40;
  }
  return;
}



_Bool chan_is_on_channel(vif_info_tag *p_vif_entry)

{
  chan_ctxt_tag *pcVar1;
  
  if (DAT_4201d1f8 != 0) {
    if (*(byte *)(DAT_4201d1f8 + 0x17) < 3) {
      pcVar1 = (chan_ctxt_tag *)((int)p_vif_entry->chan_ctxt - DAT_4201d1f8);
    }
    else {
      pcVar1 = (chan_ctxt_tag *)((uint)*(byte *)(DAT_4201d1f8 + 0x19) - (uint)p_vif_entry->index);
    }
    return (_Bool)(pcVar1 == (chan_ctxt_tag *)0x0);
  }
  return false;
}



_Bool chan_is_tx_allowed(vif_info_tag *p_vif_entry)

{
  bool bVar1;
  undefined3 extraout_var;
  
  bVar1 = (bool)chan_is_on_channel(p_vif_entry);
  if ((CONCAT31(extraout_var,bVar1) != 0) && (DAT_4201d1fc != 0)) {
    bVar1 = *(char *)(DAT_4201d1f8 + 0x16) == '\x06';
  }
  return (_Bool)bVar1;
}



_Bool chan_is_on_operational_channel(vif_info_tag *p_vif_entry)

{
  bool bVar1;
  
  bVar1 = false;
  if ((DAT_4201d1f8 != (chan_ctxt_tag *)0x0) && (bVar1 = false, DAT_4201d1f8->idx < 3)) {
    bVar1 = p_vif_entry->chan_ctxt == DAT_4201d1f8;
  }
  return (_Bool)bVar1;
}



void chan_update_tx_power(chan_ctxt_tag *p_chan_entry)

{
  int8_t iVar1;
  int8_t iVar2;
  char cVar3;
  
  if (p_chan_entry->nb_linked_vif == '\0') {
    return;
  }
  iVar2 = '\x7f';
  if ((p_chan_entry == vif_info_tab[0].chan_ctxt) &&
     (iVar2 = vif_info_tab[0].user_tx_power,
     vif_info_tab[0].tx_power < vif_info_tab[0].user_tx_power)) {
    iVar2 = vif_info_tab[0].tx_power;
  }
  iVar1 = iVar2;
  if (p_chan_entry == vif_info_tab[1].chan_ctxt) {
    iVar1 = vif_info_tab[1].user_tx_power;
    if (iVar2 < vif_info_tab[1].user_tx_power) {
      iVar1 = iVar2;
    }
    cVar3 = vif_info_tab[1].tx_power;
    if (vif_info_tab[1].tx_power < iVar1) goto LAB_2301a43a;
  }
  cVar3 = iVar1;
  if (iVar1 == '\x7f') {
    return;
  }
LAB_2301a43a:
  (p_chan_entry->channel).tx_power = cVar3;
  return;
}



void chan_ctxt_link(uint8_t vif_idx,uint8_t chan_idx)

{
  uint8_t uVar1;
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  int iVar2;
  chan_ctxt_tag *p_chan_entry;
  
  iVar2 = CONCAT31(in_register_0000202d,chan_idx);
  p_chan_entry = chan_ctxt_pool + iVar2;
  if (vif_info_tab[CONCAT31(in_register_00002029,vif_idx)].chan_ctxt != (chan_ctxt_tag *)0x0) {
    assert_err("p_vif_entry->chan_ctxt == NULL","module",0x99c);
  }
  if (chan_ctxt_pool[iVar2].idx == -1) {
    assert_err("p_chan_entry->idx != CHAN_CTXT_UNUSED","module",0x99d);
  }
  uVar1 = chan_ctxt_pool[iVar2].nb_linked_vif + '\x01';
  DAT_4201d240 = DAT_4201d240 + 0xc800;
  vif_info_tab[CONCAT31(in_register_00002029,vif_idx)].chan_ctxt = p_chan_entry;
  chan_ctxt_pool[iVar2].nb_linked_vif = uVar1;
  if (uVar1 == '\x01') {
    chan_ctxt_pool[iVar2].status = '\x01';
    DAT_4201d24a = DAT_4201d24a + '\x01';
    co_list_push_back((co_list *)&p_chan_entry,(co_list_hdr *)p_chan_entry);
    if (DAT_4201d1fc == 0) {
      if ((DAT_4201d248 & 0xc) == 0) {
        if (DAT_4201d24a == '\x01') {
          chan_switch_start(p_chan_entry);
        }
        else {
          chan_cde_evt((void *)0x0);
        }
      }
    }
    else {
      *(undefined *)(DAT_4201d1fc + 0x16) = 1;
      DAT_4201d1fc = 0;
    }
  }
  chan_update_tx_power(p_chan_entry);
  return;
}



void chan_ctxt_unlink(uint8_t vif_idx)

{
  chan_ctxt_tag *pcVar1;
  chan_ctxt_tag *p_chan_entry;
  undefined3 in_register_00002029;
  int iVar2;
  
  iVar2 = CONCAT31(in_register_00002029,vif_idx);
  p_chan_entry = vif_info_tab[iVar2].chan_ctxt;
  if (p_chan_entry == (chan_ctxt_tag *)0x0) {
    assert_err("p_chan_entry != NULL","module",0x9e4);
  }
  co_list_extract((co_list *)&DAT_4201d1e8,(co_list_hdr *)&vif_info_tab[iVar2].tbtt_switch);
  vif_info_tab[iVar2].tbtt_switch.status = '\0';
  vif_info_tab[iVar2].chan_ctxt = (chan_ctxt_tag *)0x0;
  p_chan_entry->nb_linked_vif = p_chan_entry->nb_linked_vif + -1;
  pcVar1 = DAT_4201d1fc;
  if (p_chan_entry->status != '\0') {
    DAT_4201d240 = DAT_4201d240 + -0xc800;
    if (p_chan_entry->nb_linked_vif != '\0') goto LAB_2301a656;
    co_list_extract((co_list *)&p_chan_entry,(co_list_hdr *)p_chan_entry);
    p_chan_entry->status = '\0';
    DAT_4201d24a = DAT_4201d24a - 1;
    if (DAT_4201d1f8 == p_chan_entry) {
      DAT_4201d1f8 = (chan_ctxt_tag *)0x0;
LAB_2301a622:
      if (pcVar1 == (chan_ctxt_tag *)0x0) {
        if (DAT_4201d24a < 2) {
          if (DAT_4201d24a == 1) {
            chan_switch_start(p_chan_entry);
          }
        }
        else {
          chan_cde_evt((void *)0x0);
        }
        goto LAB_2301a648;
      }
    }
    else {
      if (pcVar1 != p_chan_entry) goto LAB_2301a622;
      DAT_4201d1fc = (chan_ctxt_tag *)0x0;
    }
    DAT_4201d248 = DAT_4201d248 | 0x20;
  }
LAB_2301a648:
  if (p_chan_entry->nb_linked_vif == '\0') {
    chan_ctxt_del(p_chan_entry->idx);
  }
LAB_2301a656:
  chan_tbtt_schedule((chan_tbtt_tag *)0x0);
  chan_update_tx_power(p_chan_entry);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void hal_dma_init(void)

{
  co_list_init((co_list *)&hal_dma_env);
  hal_dma_env.lli_cnt[0] = (uint16_t)_DAT_44a000a4;
  co_list_init(hal_dma_env.prog + 1);
  hal_dma_env.lli_cnt[1] = (uint16_t)_DAT_44a000ac;
  return;
}


/*
Unable to decompile 'hal_dma_push'
Cause: Exception while decompiling 2301a6ba: Decompiler process died

*/

/*
Unable to decompile 'hal_dma_evt'
Cause: Exception while decompiling 2301a74a: Decompiler process died

*/


// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t blmac_soft_reset_getf(void)

{
  uint uVar1;
  
  uVar1 = _DAT_44b08050;
  if ((_DAT_44b08050 & 0xfffffffe) != 0) {
    assert_err("(localVal & ~((uint32_t)0x00000001)) == 0","module",0x11d);
  }
  return (uint8_t)uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void blmac_wt_2_crypt_clk_ratio_setf(uint8_t wt2cryptclkratio)

{
  undefined3 in_register_00002029;
  
  _DAT_44b000f0 = CONCAT31(in_register_00002029,wt2cryptclkratio) | _DAT_44b000f0 & 0xfffffffc;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void blmac_rx_flow_cntrl_en_setf(void)

{
  _DAT_44b00054 = _DAT_44b00054 & 0xfffeffff | 0x10000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void blmac_key_sto_ram_reset_setf(void)

{
  _DAT_44b0004c = _DAT_44b0004c & 0xffffdfff | 0x2000;
  return;
}


/*
Unable to decompile 'hal_machw_idle_req'
Cause: Exception while decompiling 2301a80c: Decompiler process died

*/


// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void hal_machw_stop(void)

{
  uint8_t uVar1;
  undefined3 extraout_var;
  
  _DAT_44b08050 = 1;
  do {
    uVar1 = blmac_soft_reset_getf();
  } while (CONCAT31(extraout_var,uVar1) != 0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void hal_machw_init(void)

{
  uint uVar1;
  uint8_t wt2cryptclkratio;
  undefined3 extraout_var;
  uint uVar2;
  undefined3 extraout_var_00;
  uint uVar3;
  uint uVar4;
  
  _DAT_44b08050 = 1;
  do {
    wt2cryptclkratio = blmac_soft_reset_getf();
  } while (CONCAT31(extraout_var,wt2cryptclkratio) != 0);
  _DAT_44b00404 = 0x24f637;
  _DAT_44b00400 = 0x49;
  _DAT_44920004 = 0x5010001f;
  wt2cryptclkratio = phy_get_mac_freq();
  uVar2 = CONCAT31(uVar2._1_3_,wt2cryptclkratio);
  uVar1 = _DAT_44b000e4 & 0xff;
  uVar3 = _DAT_44b000e4 & 0xffffff00 | 0x28;
  uVar4 = (((_DAT_44b000e4 & 0x3ff00) >> 8) * uVar2) / uVar1 << 8;
  _DAT_44b000e4 = uVar3;
  if ((uVar4 & 0xfc0000) != 0) {
    assert_err("(((uint32_t)txrfdelayinmacclk << 8) & ~((uint32_t)0x0003FF00)) == 0","module",0x1d59
              );
  }
  _DAT_44b000e4 = (_DAT_44b000e4 & 0xfffc00ff | uVar4 & 0xffff00) & 0xf003ffff | 0x2200000;
  _DAT_44b000e8 =
       (((_DAT_44b000e8 >> 8 & 0xffff) * uVar2) / uVar1 & 0xffff) << 8 | _DAT_44b000e8 & 0xff0000ff;
  uVar3 = _DAT_44b000ec & 0xc00fffff | 0x2700000;
  uVar4 = (((_DAT_44b000ec & 0xffc00) >> 10) * uVar2) / uVar1 << 10;
  _DAT_44b000ec = uVar3;
  if ((uVar4 & 0x3f00000) != 0) {
    assert_err("(((uint32_t)txdelayrfoninmacclk << 10) & ~((uint32_t)0x000FFC00)) == 0","module",
               0x1ea2);
  }
  wt2cryptclkratio = '\x03';
  _DAT_44b000ec = _DAT_44b000ec & 0xfff00000 | uVar4 & 0x3fffc00 | 0xb4;
  if ((0x1d < uVar2) && (wt2cryptclkratio = '\x02', 0x3b < uVar2)) {
    wt2cryptclkratio = '\x01';
  }
  blmac_wt_2_crypt_clk_ratio_setf(wt2cryptclkratio);
  _DAT_44b000f4 =
       (((_DAT_44b000f4 >> 8 & 0xffff) * uVar2) / uVar1 & 0xffff) << 8 | _DAT_44b000f4 & 0xff0000ff;
  _DAT_44b000f8 =
       (((_DAT_44b000f8 >> 8 & 0xffff) * uVar2) / uVar1 & 0xffff) << 8 | _DAT_44b000f8 & 0xff0000ff;
  uVar3 = ((_DAT_44b00104 >> 0x14 & 0x3ff) * uVar2) / uVar1 << 0x14;
  if ((uVar3 & 0xc0000000) != 0) {
    assert_err("(((uint32_t)rifstoinmacclk << 20) & ~((uint32_t)0x3FF00000)) == 0","module",0x228a);
  }
  uVar3 = _DAT_44b00104 & 0xc00fffff | uVar3;
  uVar4 = (((_DAT_44b00104 & 0xffc00) >> 10) * uVar2) / uVar1 << 10;
  _DAT_44b00104 = uVar3;
  if ((uVar4 & 0x3f00000) != 0) {
    assert_err("(((uint32_t)rifsinmacclk << 10) & ~((uint32_t)0x000FFC00)) == 0","module",0x22a4);
  }
  uVar3 = _DAT_44b00104 & 0xfff003ff | uVar4 & 0x3fffc00;
  uVar1 = ((_DAT_44b00104 & 0x3ff) * uVar2) / uVar1;
  _DAT_44b00104 = uVar3;
  if ((uVar1 & 0xfc00) != 0) {
    assert_err("(((uint32_t)txdmaprocdlyinmacclk << 0) & ~((uint32_t)0x000003FF)) == 0","module",
               0x22be);
  }
  _DAT_44b00104 = _DAT_44b00104 & 0xfffffc00 | uVar1 & 0xffff;
  _DAT_44b08074 = 0x8373f14c;
  _DAT_44b0004c = _DAT_44b0004c & 0xfffff7ff;
  if (_DAT_44b000d8 >> 0x18 < 0x11) {
    assert_err("MM_STA_TO_KEY(NX_REMOTE_STA_MAX - 1) <= blmac_sta_key_max_index_getf()","module",
               0x124);
  }
  printf("[WF] [KEY] [CFG] nVAP is %d, endidx %d, startidx %d\r\n",2,0x11,8);
  _DAT_44b000d8 = 0x21108;
  _DAT_44b08080 = 0x800a07c0;
  _DAT_44b0004c = _DAT_44b0004c | 0x4000780;
  blmac_rx_flow_cntrl_en_setf();
  _DAT_44b00060 = 0x7fffffde;
  _DAT_44b00114 = 0x3010a;
  _DAT_44b00064 = 0xff900064;
  _DAT_44b00150 = 0x1000;
  _DAT_44b00224 = 0;
  _DAT_44b000a0 = 0x2020;
  _DAT_44b0004c = _DAT_44b0004c & 0xffffefff | 0x1000;
  blmac_key_sto_ram_reset_setf();
  _DAT_44b00510 = 0x1c25;
  _DAT_44b00310 = _DAT_44b00310 | 0x80;
  wt2cryptclkratio = phy_get_ntx();
  uVar1 = (CONCAT31(extraout_var_00,wt2cryptclkratio) + 1) * 0x4000000;
  if ((uVar1 & 0xe0000000) != 0) {
    assert_err("(((uint32_t)maxphyntx << 26) & ~((uint32_t)0x1C000000)) == 0","module",0x1539);
  }
  _DAT_44b0004c = _DAT_44b0004c & 0xfdffffff | 0x2000000;
  _DAT_44b0009c = _DAT_44b0009c & 0xe3ffffff | uVar1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void hal_machw_disable_int(void)

{
  _DAT_44b08074 = _DAT_44b08074 & 0x7fffffff;
  _DAT_44b08080 = _DAT_44b08080 & 0x7fffffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void hal_machw_reset(void)

{
  char "hal_machw_reset" [16];
  
  if ((_DAT_44b00038 & 0xf) != 0) {
    helper_record_all_states("hal_machw_reset");
  }
  _DAT_44b0004c = _DAT_44b0004c & 0xffffff7f;
  _DAT_44b00038 = 0;
  _DAT_44b00054 = 0x7c;
  ps_env.prevent_sleep = ps_env.prevent_sleep & 0xfffffffb;
  blmac_rx_flow_cntrl_en_setf();
  _DAT_44b0004c = _DAT_44b0004c | 0x80;
  _DAT_44b08070 = 0x37ff187;
  _DAT_44b08074 = _DAT_44b08074 & 0x7fffffff | 0x80000000;
  _DAT_44b0807c = 0xffffffff;
  _DAT_44b08080 = _DAT_44b08080 & 0x7fffffff | 0x80000000;
  _DAT_44b0808c = _DAT_44b0808c & 0xffffffc0;
  return;
}



// WARNING: Removing unreachable block (ram,0x2301adcc)
// WARNING: Removing unreachable block (ram,0x2301add8)
// WARNING: Removing unreachable block (ram,0x2301ade2)

uint8_t hal_machw_search_addr(mac_addr *addr)

{
                    // WARNING: Do nothing block with infinite loop
  do {
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void hal_machw_monitor_mode(void)

{
  _DAT_44b08074 = _DAT_44b08074 & 0xfffffffc;
  mm_env.rx_filter_umac = 0x7fffffde;
  _DAT_44b00060 = mm_env.rx_filter_lmac_enable | 0x7fffffde;
  _DAT_44b0004c = _DAT_44b0004c & 0xfffe3fff | 0xc700;
  blmac_key_sto_ram_reset_setf();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

_Bool hal_machw_sleep_check(void)

{
  uint uVar1;
  
  uVar1 = 0;
  while (((1 << (uVar1 & 0x1f) & _DAT_44b0808c) == 0 ||
         (-1 < (-2000 - _DAT_44b00120) + *(int *)(&DAT_44b00128 + uVar1 * 4)))) {
    uVar1 = uVar1 + 1;
    if (uVar1 == 9) {
      return true;
    }
  }
  if (-1 < (5000 - _DAT_44b00120) + *(int *)(&DAT_44b00128 + uVar1 * 4)) {
    return false;
  }
  assert_err("!hal_machw_time_past(blmac_abs_timer_get(i) + 5000)","module",0x208);
  return false;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void hal_machw_gen_handler(void)

{
  uint uVar1;
  uint uVar2;
  char *condition;
  int line;
  
  uVar2 = _DAT_44b08074 & _DAT_44b0806c;
  _DAT_44b08070 = uVar2;
  if ((uVar2 & 0x40001) != 0) {
    ke_evt_set(0x400000);
  }
  if ((uVar2 & 0x80002) != 0) {
    ke_evt_set(0x200000);
  }
  if ((uVar2 & 4) != 0) {
    if ((_DAT_44b00038 & 0xf) == 0) {
      _DAT_44b0808c = _DAT_44b0808c & 0xffffffdf;
      ps_env.prevent_sleep = ps_env.prevent_sleep & 0xfffffffb;
      ke_evt_set(0x800000);
    }
    else {
      assert_rec("blmac_current_state_getf() == HW_IDLE","module",0x8c);
    }
  }
  uVar1 = _DAT_44b08084;
  if ((uVar2 & 8) != 0) {
    _DAT_44b08088 = _DAT_44b08084;
    if ((_DAT_44b08084 & 0x100) != 0) {
      ke_evt_set(0x4000000);
    }
    if ((uVar1 & 0x40) != 0) {
      rxl_timeout_int_handler();
    }
    if ((uVar1 & 0x80) != 0) {
      ke_evt_set(0x8000000);
    }
    if ((uVar1 & 1) != 0) {
      assert_rec("HAL_AC0_TIMER_BIT timeout ","module",0x22f);
    }
    if ((uVar1 & 2) == 0) {
      if ((uVar1 & 4) == 0) {
        if ((uVar1 & 8) == 0) {
          if ((uVar1 & 0x10) == 0) {
            if ((uVar1 & 0x20) == 0) goto LAB_2301af80;
            line = 0x236;
            condition = "!(timer_pending & HAL_IDLE_TIMER_BIT)";
          }
          else {
            line = 0x235;
            condition = "!(timer_pending & HAL_BCN_TIMER_BIT)";
          }
        }
        else {
          line = 0x234;
          condition = "!(timer_pending & HAL_AC3_TIMER_BIT)";
        }
      }
      else {
        line = 0x233;
        condition = "!(timer_pending & HAL_AC2_TIMER_BIT)";
      }
    }
    else {
      line = 0x232;
      condition = "!(timer_pending & HAL_AC1_TIMER_BIT)";
    }
    assert_rec(condition,"module",line);
  }
LAB_2301af80:
  if ((uVar2 & 0x80) == 0) {
    if ((uVar2 & 0x100) == 0) {
      if ((int)(uVar2 << 0x13) < 0) {
        line = 0x27a;
        condition = "!(genirq_pending & NXMAC_PT_ERROR_BIT)";
      }
      else {
        if ((int)(uVar2 << 0x12) < 0) {
          line = 0x27b;
          condition = "!(genirq_pending & NXMAC_AC_0_TX_DMA_DEAD_BIT)";
        }
        else {
          if ((int)(uVar2 << 0x11) < 0) {
            line = 0x27c;
            condition = "!(genirq_pending & NXMAC_AC_1_TX_DMA_DEAD_BIT)";
          }
          else {
            if ((int)(uVar2 << 0x10) < 0) {
              line = 0x27d;
              condition = "!(genirq_pending & NXMAC_AC_2_TX_DMA_DEAD_BIT)";
            }
            else {
              if ((int)(uVar2 << 0xf) < 0) {
                line = 0x27e;
                condition = "!(genirq_pending & NXMAC_AC_3_TX_DMA_DEAD_BIT)";
              }
              else {
                if ((int)(uVar2 << 0xe) < 0) {
                  line = 0x27f;
                  condition = "!(genirq_pending & NXMAC_BCN_TX_DMA_DEAD_BIT)";
                }
                else {
                  if ((int)(uVar2 << 10) < 0) {
                    line = 0x280;
                    condition = "!(genirq_pending & NXMAC_MAC_PHYIF_UNDER_RUN_BIT)";
                  }
                  else {
                    if ((int)(uVar2 << 9) < 0) {
                      line = 0x281;
                      condition = "!(genirq_pending & NXMAC_PHY_ERR_BIT)";
                    }
                    else {
                      if ((int)(uVar2 << 7) < 0) {
                        line = 0x282;
                        condition = "!(genirq_pending & NXMAC_RX_HEADER_DMA_DEAD_BIT)";
                      }
                      else {
                        if ((int)(uVar2 << 6) < 0) {
                          line = 0x283;
                          condition = "!(genirq_pending & NXMAC_RX_PAYLOAD_DMA_DEAD_BIT)";
                        }
                        else {
                          if (-1 < (int)(uVar2 << 0xb)) {
                            return;
                          }
                          line = 0x284;
                          condition = "!(genirq_pending & NXMAC_HW_ERR_BIT)";
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    else {
      line = 0x279;
      condition = "!(genirq_pending & NXMAC_RX_FIFO_OVER_FLOW_BIT)";
    }
  }
  else {
    line = 0x278;
    condition = "!(genirq_pending & NXMAC_RX_DMA_EMPTY_BIT)";
  }
  assert_rec(condition,"module",line);
  return;
}



void hal_mib_dump(void)

{
  puts("---------- hal_mib_dump ----------\r\n");
  printf("machw_mib nx_rd_fifo_overflow_count is %u\r\n");
  puts("\r\n");
  return;
}



int mm_monitor_channel_req_handler
              (ke_msg_id_t msgid,mm_monitor_channel_req *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  uint16_t prim20_freq;
  undefined4 *puVar1;
  uint32_t uVar2;
  uint16_t center1_freq;
  
  puVar1 = (undefined4 *)ke_msg_alloc(0x5f,src_id,dest_id,0x28);
  center1_freq = (uint16_t)param->freq;
  *puVar1 = 1;
  puVar1[3] = 0x11111111;
  puVar1[4] = 0x22222222;
  puVar1[5] = 0x33333333;
  puVar1[6] = 0x44444444;
  puVar1[7] = 0x55555555;
  puVar1[8] = 0x66666666;
  puVar1[2] = 0;
  puVar1[9] = 0x77777777;
  uVar2 = param->freq;
  puVar1[1] = uVar2;
  prim20_freq = (uint16_t)uVar2;
  if ((param->use_40Mhz != 0) && (center1_freq = prim20_freq + 10, param->higher_band == 0)) {
    center1_freq = prim20_freq - 10;
  }
  phy_set_channel('\0',param->use_40Mhz != 0,prim20_freq,center1_freq,0,'\0');
  *puVar1 = 0;
  ke_msg_send(puVar1);
  return 0;
}



int mm_monitor_enable_req_handler
              (ke_msg_id_t msgid,mm_monitor_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  undefined4 *puVar1;
  uint32_t local_50;
  phy_cfg_tag config;
  
  puVar1 = (undefined4 *)ke_msg_alloc(0x5d,src_id,dest_id,0x28);
  *puVar1 = 1;
  puVar1[3] = 0x11111111;
  puVar1[4] = 0x22222222;
  puVar1[5] = 0x33333333;
  puVar1[6] = 0x44444444;
  puVar1[7] = 0x55555555;
  puVar1[8] = 0x66666666;
  puVar1[2] = 0;
  puVar1[9] = 0x77777777;
  puVar1[1] = param->enable;
  memset(&local_50,0,0x40);
  local_50 = 0;
  phy_init((phy_cfg_tag *)&local_50);
  phy_set_channel('\0','\0',0x985,0x985,0,'\0');
  mm_active();
  *puVar1 = 0;
  ke_msg_send(puVar1);
  return 0;
}



int mm_cfg_rssi_req_handler
              (ke_msg_id_t msgid,mm_cfg_rssi_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  byte bVar1;
  uint uVar2;
  
  uVar2 = (uint)param->vif_index;
  if (vif_info_tab[uVar2].type != '\0') {
    assert_err("vif_entry->type == VIF_STA","module",0x8fe);
  }
  vif_info_tab[uVar2].u[0x1a] = param->rssi_thold;
  bVar1 = param->rssi_hyst;
  vif_info_tab[uVar2].u[0x1c] = 0;
  vif_info_tab[uVar2].u[0x1b] = bVar1;
  return 0;
}



int mm_set_ps_options_req_handler
              (ke_msg_id_t msgid,mm_set_ps_options_req *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  uint uVar1;
  
  uVar1 = (uint)param->vif_index;
  if (vif_info_tab[uVar1].type != '\0') {
    assert_err("vif_entry->type == VIF_STA","module",0x815);
  }
  *(uint16_t *)vif_info_tab[uVar1].u = param->listen_interval;
  *(_Bool *)(vif_info_tab[uVar1].u + 2) = param->dont_listen_bc_mc;
  ke_msg_send_basic(0x4c,src_id,dest_id);
  return 0;
}



int mm_tim_update_req_handler
              (ke_msg_id_t msgid,mm_tim_update_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  mm_tim_update(param);
  return 1;
}



int mm_bcn_change_req_handler
              (ke_msg_id_t msgid,mm_bcn_change_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  mm_bcn_change(param);
  return 1;
}



int mm_remain_on_channel_req_handler
              (ke_msg_id_t msgid,mm_remain_on_channel_req *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  uint8_t uVar1;
  uint8_t uVar2;
  uint8_t *puVar3;
  undefined2 in_register_00002036;
  
  uVar2 = chan_roc_req(param,src_id);
  if (CONCAT22(in_register_00002036,src_id) != 0) {
    puVar3 = (uint8_t *)ke_msg_alloc(0x47,src_id,dest_id,3);
    uVar1 = param->op_code;
    puVar3[1] = uVar2;
    *puVar3 = uVar1;
    puVar3[2] = '\x04';
    ke_msg_send();
  }
  return 0;
}



int mm_sta_del_req_handler
              (ke_msg_id_t msgid,mm_sta_del_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  mm_sta_del(param->sta_idx);
  ke_msg_send_basic(0xd,src_id,dest_id);
  return 0;
}



int mm_sta_add_req_handler
              (ke_msg_id_t msgid,mm_sta_add_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint8_t uVar1;
  uint8_t *puVar2;
  
  puVar2 = (uint8_t *)ke_msg_alloc(0xb,src_id,dest_id,3);
  uVar1 = mm_sta_add(param,puVar2 + 1,puVar2 + 2);
  *puVar2 = uVar1;
  ke_msg_send(puVar2);
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int mm_key_del_req_handler
              (ke_msg_id_t msgid,mm_key_del_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  if ((_DAT_44b000d8 >> 0x18) + 1 < (uint)param->hw_key_idx) {
    assert_err("param->hw_key_idx <= MM_SEC_MAX_KEY_NBR","module",0x56e);
  }
  mm_sec_machwkey_del(param->hw_key_idx);
  ke_msg_send_basic(0x27,src_id,dest_id);
  return 0;
}



int mm_key_add_req_handler
              (ke_msg_id_t msgid,mm_key_add_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint8_t uVar1;
  undefined *puVar2;
  
  puVar2 = (undefined *)ke_msg_alloc(0x25,src_id,dest_id,2);
  if (3 < param->key_idx) {
    assert_err("param->key_idx < MAC_DEFAULT_KEY_COUNT","module",0x53d);
  }
  if (0x20 < (param->key).length) {
    assert_err("param->key.length <= MAC_SEC_KEY_LEN","module",0x541);
  }
  if (5 < param->cipher_suite) {
    assert_err("param->cipher_suite <= MAC_RSNIE_CIPHER_AES_CMAC","module",0x544);
  }
  uVar1 = mm_sec_machwkey_wr(param);
  puVar2[1] = uVar1;
  *puVar2 = 0;
  ke_msg_send(puVar2);
  return 0;
}



int mm_set_power_req_handler
              (ke_msg_id_t msgid,mm_set_power_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint uVar1;
  uint8_t *idx;
  
  uVar1 = (uint)param->inst_nbr;
  idx = (uint8_t *)ke_msg_alloc(0x2f,src_id,dest_id,2);
  vif_info_tab[uVar1].user_tx_power = param->power;
  idx[1] = vif_info_tab[uVar1].tx_power;
  vif_info_tab[uVar1].tx_power = '\x7f';
  tpc_update_vif_tx_power(vif_info_tab + uVar1,(int8_t *)(idx + 1),idx);
  ke_msg_send(idx);
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int mm_set_idle_req_handler
              (ke_msg_id_t msgid,mm_set_idle_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  int iVar1;
  ke_state_t kVar2;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  
  kVar2 = ke_state_get(dest_id);
  if (CONCAT22(extraout_var,kVar2) == 3) {
LAB_2301b686:
    iVar1 = 2;
  }
  else {
    mm_env.host_idle = param->hw_idle;
    if (mm_env.host_idle == '\0') {
      kVar2 = ke_state_get(dest_id);
      if (CONCAT22(extraout_var_01,kVar2) == 2) goto LAB_2301b686;
      mm_active();
    }
    else {
      kVar2 = ke_state_get(dest_id);
      if (CONCAT22(extraout_var_00,kVar2) != 0) {
        if (CONCAT22(extraout_var_00,kVar2) == 2) {
          return 2;
        }
        hal_machw_idle_req();
        ke_state_set(dest_id,2);
        return 2;
      }
      if ((_DAT_44b00038 & 0xf) != 0) {
        assert_err("blmac_current_state_getf() == HW_IDLE","module",0x47d);
      }
      mm_env._18_2_ = 0;
    }
    ke_msg_send_basic(0x23,src_id,dest_id);
    iVar1 = 0;
  }
  return iVar1;
}


/*
Unable to decompile 'mm_reset_req_handler'
Cause: Exception while decompiling 2301b70e: Decompiler process died

*/


// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int mm_version_req_handler(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  undefined4 *puVar1;
  
  puVar1 = (undefined4 *)ke_msg_alloc(5,src_id,dest_id,0x18);
  *puVar1 = 0x5040000;
  puVar1[1] = _DAT_44b00004;
  puVar1[2] = _DAT_44b00008;
  phy_get_version(puVar1 + 3,puVar1 + 4);
  puVar1[5] = 0x89df;
  ke_msg_send(puVar1);
  return 0;
}



int mm_start_req_handler
              (ke_msg_id_t msgid,mm_start_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  
  kVar1 = ke_state_get(dest_id);
  if (CONCAT22(extraout_var,kVar1) != 0) {
    assert_err("ke_state_get(dest_id) == MM_IDLE","module",0x135);
  }
  phy_init((phy_cfg_tag *)param);
  phy_set_channel('\0','\0',0x96c,0x96c,0,'\0');
  tpc_update_tx_power('\x10');
  ps_env.uapsd_timeout = param->uapsd_timeout * 1000;
  mm_env.lp_clk_accuracy = param->lp_clk_accuracy;
  ke_msg_send_basic(3,src_id,dest_id);
  mm_active();
  hal_machw_idle_req();
  ke_state_set(dest_id,2);
  return 0;
}



// WARNING: Type propagation algorithm not settling

int mm_set_ps_mode_req_handler
              (ke_msg_id_t msgid,mm_set_ps_mode_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  vif_info_tag *vif_entry;
  
  vif_entry = (vif_info_tag *)vif_mgmt_env.used_list.first;
  if (param->new_state == '\x03') {
    while (vif_entry != (vif_info_tag *)0x0) {
      if ((vif_entry->type == '\0') && (vif_entry->active != false)) {
        ps_polling_frame(vif_entry);
      }
      vif_entry = *(vif_info_tag **)&vif_entry->list_hdr;
    }
    ke_msg_send_basic(0x32,ps_env.taskid,0);
  }
  else {
    ps_set_mode(param->new_state,src_id);
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int mm_force_idle_req_handler
              (ke_msg_id_t msgid,mm_force_idle_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  int iVar1;
  ke_state_t kVar2;
  undefined2 extraout_var;
  
  kVar2 = ke_state_get(dest_id);
  if (CONCAT22(extraout_var,kVar2) == 0) {
    if ((_DAT_44b00038 & 0xf) != 0) {
      assert_err("blmac_current_state_getf() == HW_IDLE","module",0x4c0);
    }
    ke_state_set(dest_id,3);
    iVar1 = 0;
    (*param->cb)(param->cb);
  }
  else {
    iVar1 = 2;
    if (CONCAT22(extraout_var,kVar2) != 2) {
      hal_machw_idle_req();
      ke_state_set(dest_id,2);
    }
  }
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int mm_hw_config_handler(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  char cVar1;
  byte bVar2;
  _Bool _Var3;
  uint8_t uVar4;
  uint16_t uVar5;
  uint32_t uVar6;
  uint32_t uVar7;
  int iVar8;
  uint8_t uVar9;
  ke_state_t kVar10;
  ke_msg_id_t id;
  undefined2 in_register_0000202a;
  undefined2 extraout_var;
  uint8_t *puVar11;
  uint32_t uVar12;
  uint32_t uVar13;
  uint uVar14;
  uint uVar15;
  uint uVar16;
  
  uVar16 = CONCAT22(in_register_0000202a,msgid);
  kVar10 = ke_state_get(dest_id);
  if (CONCAT22(extraout_var,kVar10) != 0) {
    if (1 < (CONCAT22(extraout_var,kVar10) - 2U & 0xffff)) {
      mm_env.prev_hw_state = (byte)_DAT_44b00038 & 0xf;
      kVar10 = ke_state_get(dest_id);
      mm_env.prev_mm_state = (uint8_t)kVar10;
      hal_machw_idle_req();
      ke_state_set(dest_id,2);
    }
    return 2;
  }
  if ((_DAT_44b00038 & 0xf) != 0) {
    assert_err("blmac_current_state_getf() == HW_IDLE","module",0x77b);
  }
  iVar8 = DAT_4201d1f8;
  if (uVar16 == 0x16) {
    (&mm_env.rx_filter_lmac_enable)[(uint)*(byte *)((int)param + 5) + 4] = *(uint32_t *)param;
    if ((iVar8 != 0) && (*(char *)(iVar8 + 4) == *(char *)((int)param + 5))) {
      _DAT_44b000dc = 0x10;
    }
    id = 0x17;
LAB_2301baa6:
    ke_msg_send_basic(id,src_id,dest_id);
  }
  else {
    if (0x16 < uVar16) {
      if (uVar16 == 0x1e) {
        uVar16 = (uint)*(byte *)((int)param + 3);
        if (vif_info_tab[uVar16].type == '\0') {
          if (*(char *)((int)param + 2) == '\0') {
            mm_timer_clear(&vif_info_tab[uVar16].tbtt_timer);
          }
          else {
            uVar14 = (uint)vif_info_tab[uVar16].u[4];
            mm_timer_set(&vif_info_tab[uVar16].tbtt_timer,
                         _DAT_44b00120 + sta_info_tab[uVar14].bcn_int);
            uVar5 = *(uint16_t *)param;
            uVar12 = sta_info_tab[uVar14].bcn_int;
            *(undefined2 *)vif_info_tab[uVar16].u = 0;
            sta_info_tab[uVar14].aid = uVar5;
            uVar15 = (uint)mm_env.lp_clk_accuracy;
            vif_info_tab[uVar16].u[2] = 0;
            sta_info_tab[uVar14].drift = (uint16_t)(((uVar15 + 0x14) * uVar12) / 1000000);
            iVar8 = _DAT_44b00120;
            vif_info_tab[uVar16].u[0x18] = 0;
            *(undefined4 *)(vif_info_tab[uVar16].u + 0x14) = 0;
            *(int *)(vif_info_tab[uVar16].u + 8) = iVar8;
            vif_info_tab[uVar16].prevent_sleep = vif_info_tab[uVar16].prevent_sleep | 1;
            *(int *)(vif_info_tab[uVar16].u + 0x10) = _DAT_44b00120;
            chan_bcn_detect_start(vif_info_tab + uVar16);
          }
        }
        _Var3 = *(_Bool *)((int)param + 2);
        vif_info_tab[uVar16].active = _Var3;
        if (_Var3 != false) {
          _DAT_44b00200 = vif_info_tab[uVar16].txq_params[3];
          _DAT_44b00204 = vif_info_tab[uVar16].txq_params[3];
          _DAT_44b00208 = vif_info_tab[uVar16].txq_params[3];
          _DAT_44b0020c = vif_info_tab[uVar16].txq_params[3];
          mm_env_max_ampdu_duration_set();
        }
        id = 0x1f;
      }
      else {
        if (uVar16 < 0x1f) {
          if (uVar16 == 0x1a) {
            uVar16 = (uint)*(byte *)((int)param + 6);
            vif_info_tab[0].txq_params[uVar16 * 0x176 + (uint)*(byte *)((int)param + 5)] =
                 *(uint32_t *)param;
            if (vif_info_tab[uVar16].active != false) {
              cVar1 = *(char *)((int)param + 5);
              uVar13 = *(uint32_t *)param;
              uVar12 = _DAT_44b00200;
              uVar6 = uVar13;
              uVar7 = _DAT_44b00208;
              if (((cVar1 != '\x01') && (uVar12 = uVar13, uVar6 = _DAT_44b00204, cVar1 != '\0')) &&
                 (uVar12 = _DAT_44b00200, uVar7 = uVar13, cVar1 != '\x02')) {
                uVar7 = _DAT_44b00208;
                _DAT_44b0020c = uVar13;
              }
              _DAT_44b00208 = uVar7;
              _DAT_44b00204 = uVar6;
              _DAT_44b00200 = uVar12;
              mm_env_max_ampdu_duration_set();
            }
            if (vif_info_tab[uVar16].type == '\0') {
              ps_uapsd_set(vif_info_tab + uVar16,*(uint8_t *)((int)param + 5),
                           *(_Bool *)((int)param + 4));
            }
            id = 0x1b;
          }
          else {
            if (uVar16 == 0x1c) {
              bVar2 = *(byte *)param;
              if (((uint)bVar2 << 0xe & 0x3e0000) != 0) {
                assert_err("(((uint32_t)abgnmode << 14) & ~((uint32_t)0x0001C000)) == 0","module",
                           0x834);
              }
              _DAT_44b0004c = _DAT_44b0004c & 0xfffe3fff | (uint)bVar2 << 0xe;
              id = 0x1d;
            }
            else {
              if (uVar16 != 0x18) goto LAB_2301b960;
              memcpy(&vif_info_tab[*(byte *)((int)param + 6)].bssid,param,6);
              if ((uint)vif_mgmt_env.vif_sta_cnt + (uint)vif_mgmt_env.vif_ap_cnt == 1) {
                _DAT_44b00020 = *(undefined4 *)param;
                _DAT_44b00024 = (uint)*(ushort *)((int)param + 4);
              }
              id = 0x19;
            }
          }
        }
        else {
          if (uVar16 == 0x28) {
            uVar9 = '\x05';
            if (*(char *)param != '\0') {
              uVar9 = '\0';
              _DAT_44b00054 = _DAT_44b00054 | 0x80;
            }
            puVar11 = (uint8_t *)ke_msg_alloc(0x29,src_id,dest_id,3);
            *puVar11 = *(uint8_t *)((int)param + 1);
            uVar4 = *(uint8_t *)((int)param + 2);
            puVar11[2] = uVar9;
            puVar11[1] = uVar4;
            goto LAB_2301b9bc;
          }
          if (uVar16 == 0x3b) {
            chan_ctxt_update((mm_chan_ctxt_update_req *)param);
            id = 0x3c;
          }
          else {
            if (uVar16 != 0x20) goto LAB_2301b960;
            id = 0x21;
            _DAT_44b000e8 =
                 (uint)*(byte *)param * (_DAT_44b000e4 & 0xff) * 0x100 | (uint)*(byte *)param;
          }
        }
      }
      goto LAB_2301baa6;
    }
    if (uVar16 == 0xe) {
      mm_env.rx_filter_umac = *(uint32_t *)param;
      _DAT_44b00060 = mm_env.rx_filter_umac | mm_env.rx_filter_lmac_enable;
      id = 0xf;
      goto LAB_2301baa6;
    }
    if (0xe < uVar16) {
      if (uVar16 == 0x12) {
        _DAT_44b00090 = (uint)*(byte *)param | _DAT_44b00090 & 0xffffff00 | 0x80000000;
        id = 0x13;
      }
      else {
        if (uVar16 != 0x14) {
          if (uVar16 != 0x10) goto LAB_2301b960;
          puVar11 = (uint8_t *)ke_msg_alloc(0x11,src_id,dest_id,2);
          if (*(uint8_t *)((int)param + 8) != '\0') {
            phy_set_channel(*(uint8_t *)param,*(uint8_t *)((int)param + 1),
                            *(uint16_t *)((int)param + 2),*(uint16_t *)((int)param + 4),
                            *(uint16_t *)((int)param + 6),*(uint8_t *)((int)param + 8));
          }
          goto LAB_2301b9bc;
        }
        uVar16 = (uint)*(byte *)((int)param + 2);
        if (vif_info_tab[uVar16].type == '\0') {
          sta_info_tab[vif_info_tab[uVar16].u[4]].bcn_int = (uint)*(ushort *)param << 10;
        }
        else {
          vif_mgmt_set_ap_bcn_int(vif_info_tab + uVar16,*(ushort *)param);
        }
        id = 0x15;
      }
      goto LAB_2301baa6;
    }
    if (uVar16 != 6) {
      if (uVar16 != 8) {
LAB_2301b960:
        assert_err("0","module",0x7ae);
        iVar8 = 2;
        goto LAB_2301baac;
      }
      if (*(byte *)param < 2) {
        vif_mgmt_unregister(*(byte *)param);
      }
      if (vif_mgmt_env.used_list.first == (co_list_hdr *)0x0) {
        hal_machw_monitor_mode();
      }
      id = 9;
      goto LAB_2301baa6;
    }
    puVar11 = (uint8_t *)ke_msg_alloc(7,src_id,dest_id,2);
    uVar9 = vif_mgmt_register((mac_addr *)((int)param + 1),*(uint8_t *)param,
                              *(_Bool *)((int)param + 7),puVar11 + 1);
    *puVar11 = uVar9;
LAB_2301b9bc:
    ke_msg_send(puVar11);
  }
  iVar8 = 0;
LAB_2301baac:
  uVar16 = (uint)mm_env.prev_hw_state;
  if ((uVar16 << 4 & 0xffffff0f) != 0) {
    assert_err("(((uint32_t)nextstate << 4) & ~((uint32_t)0x000000F0)) == 0","module",0x5b9);
  }
  _DAT_44b00038 = uVar16 << 4;
  ke_state_set(dest_id,(ushort)mm_env.prev_mm_state);
  return iVar8;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int bl60x_edca_get(int ac,uint8_t *aifs,uint8_t *cwmin,uint8_t *cwmax,uint16_t *txop)

{
  uint uVar1;
  uint uVar2;
  
  uVar1 = _DAT_44b00200;
  uVar2 = _DAT_44b00204;
  if (ac != 1) {
    if (ac < 2) {
      if (ac == 0) {
        *txop = (uint16_t)(_DAT_44b00200 >> 0xc);
        *cwmax = (byte)(uVar1 >> 8) & 0xf;
        *cwmin = (byte)(uVar1 >> 4) & 0xf;
        *aifs = (byte)uVar1 & 0xf;
        return 0;
      }
    }
    else {
      uVar2 = _DAT_44b00208;
      if ((ac == 2) || (uVar2 = _DAT_44b0020c, ac == 3)) goto LAB_2301be88;
    }
    return -1;
  }
LAB_2301be88:
  *txop = (uint16_t)(uVar2 >> 0xc);
  *cwmax = (byte)(uVar2 >> 8) & 0xf;
  *cwmin = (byte)(uVar2 >> 4) & 0xf;
  *aifs = (byte)uVar2 & 0xf;
  return 0;
}



void bl_init(void)

{
  fw_nap_chain_ptr = &fw_nap_chain;
  bl_env.hw_in_doze = 0;
  dbg_init();
  me_init();
  mm_init();
  ke_init();
  memset(&sta_conn_info,0,0xec);
  sta_conn_info._4_2_ = 0xffff;
  sta_conn_info.conType = '\0';
  sta_conn_info.gtkHwKeyId = -1;
  supplicantFuncInit();
  allocSupplicantData(&sta_conn_info);
  return;
}


/*
Unable to decompile 'bl_reset_evt'
Cause: Exception while decompiling 2301bf1c: Decompiler process died

*/


// WARNING: Type propagation algorithm not settling

int bl_sleep(void)

{
  vif_info_tag *p_vif_entry;
  _Bool _Var1;
  ke_state_t kVar2;
  undefined2 extraout_var_01;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  
  if (ke_env.evt_field != 0) {
    return 0;
  }
  kVar2 = ke_state_get(4);
  if (((CONCAT22(extraout_var_01,kVar2) == 0) && (ps_env.ps_on != false)) &&
     (p_vif_entry = (vif_info_tag *)vif_mgmt_env.used_list.first, ps_env.prevent_sleep == 0)) {
    while (p_vif_entry != (vif_info_tag *)0x0) {
      _Var1 = chan_is_on_channel(p_vif_entry);
      if ((CONCAT31(extraout_var_00,_Var1) != 0) && (p_vif_entry->prevent_sleep != 0)) {
        return 0;
      }
      p_vif_entry = *(vif_info_tag **)&p_vif_entry->list_hdr;
    }
    if (txl_cntrl_env.pck_cnt == 0) {
      _Var1 = hal_machw_sleep_check();
      return CONCAT31(extraout_var,_Var1);
    }
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t bl_nap_calculate(void)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  
  uVar2 = 0;
  uVar1 = 0xffffffff;
  do {
    if ((1 << (uVar2 & 0x1f) & _DAT_44b0808c) != 0) {
      uVar3 = *(uint *)(&DAT_44b00128 + uVar2 * 4);
      if (_DAT_44b00120 < uVar3) {
        uVar3 = uVar3 - _DAT_44b00120;
      }
      else {
        uVar3 = (_DAT_44b00120 - 1) - uVar3;
      }
      if (uVar3 < uVar1) {
        uVar1 = uVar3;
      }
    }
    uVar2 = uVar2 + 1;
  } while (uVar2 != 9);
  return uVar1;
}



void rx_swdesc_init(void)

{
  rx_swdesc_tab[0].dma_hdrdesc = rx_dma_hdrdesc;
  rx_swdesc_tab[1].dma_hdrdesc = &DAT_42043064;
  rx_swdesc_tab[2].dma_hdrdesc = &DAT_420430c8;
  rx_swdesc_tab[3].dma_hdrdesc = &DAT_4204312c;
  rx_swdesc_tab[4].dma_hdrdesc = &DAT_42043190;
  rx_swdesc_tab[5].dma_hdrdesc = &DAT_420431f4;
  rx_swdesc_tab[6].dma_hdrdesc = &DAT_42043258;
  rx_swdesc_tab[7].dma_hdrdesc = &DAT_420432bc;
  rx_swdesc_tab[8].dma_hdrdesc = &DAT_42043320;
  rx_swdesc_tab[9].dma_hdrdesc = &DAT_42043384;
  rx_swdesc_tab[10].dma_hdrdesc = &DAT_420433e8;
  rx_swdesc_tab[11].dma_hdrdesc = &DAT_4204344c;
  rx_swdesc_tab[12].dma_hdrdesc = &DAT_420434b0;
  return;
}



int scan_cancel_req_handler(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  
  kVar1 = ke_state_get(2);
  if (CONCAT22(extraout_var,kVar1) == 0) {
    scan_send_cancel_cfm('\x01',src_id);
  }
  else {
    DAT_42018f13 = 1;
  }
  return 0;
}



int scan_start_req_handler
              (ke_msg_id_t msgid,scan_start_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  int iVar1;
  ke_state_t kVar2;
  undefined *puVar3;
  undefined2 extraout_var;
  
  puVar3 = (undefined *)ke_msg_alloc(0x801,src_id,dest_id,1);
  kVar2 = ke_state_get(2);
  if (CONCAT22(extraout_var,kVar2) == 0) {
    if (param->chan_cnt == '\0') {
      assert_err("param->chan_cnt > 0","module",0x46);
    }
    *puVar3 = 0;
    DAT_42018f12 = 0;
    iVar1 = 1;
    param = param;
    DAT_42018f10 = src_id;
    scan_ie_download(param);
  }
  else {
    *puVar3 = 8;
    iVar1 = 0;
  }
  ke_msg_send(puVar3);
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 mm_scan_channel_end_ind_handler(void)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  
  kVar1 = ke_state_get(2);
  if (CONCAT22(extraout_var,kVar1) != 3) {
    assert_err("ke_state_get(TASK_SCAN) == SCAN_WAIT_BEACON_PROBE_RSP","module",0xc4);
  }
  mm_env.rx_filter_lmac_enable = mm_env.rx_filter_lmac_enable & 0xffffddff;
  _DAT_44b00060 = mm_env.rx_filter_lmac_enable | mm_env.rx_filter_umac;
  DAT_42018f12 = DAT_42018f12 + 1;
  if ((DAT_42018f12 < param->chan_cnt) && (DAT_42018f13 == '\0')) {
    scan_set_channel_request();
  }
  else {
    ke_msg_free(&param[-1].add_ies);
    if (DAT_42018f13 == '\0') {
      ke_msg_send_basic(0x802,DAT_42018f10,2);
    }
    else {
      scan_send_cancel_cfm('\0',DAT_42018f10);
      DAT_42018f13 = '\0';
    }
    ke_state_set(2,0);
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int mm_scan_channel_start_ind_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  scan_start_req *psVar1;
  uint uVar2;
  ke_state_t kVar3;
  undefined2 extraout_var;
  
  psVar1 = param;
  uVar2 = (uint)DAT_42018f12;
  kVar3 = ke_state_get(2);
  if (CONCAT22(extraout_var,kVar3) != 2) {
    assert_err("ke_state_get(TASK_SCAN) == SCAN_WAIT_CHANNEL","module",0x9d);
  }
  mm_env.rx_filter_lmac_enable = mm_env.rx_filter_lmac_enable | 0x2200;
  _DAT_44b00060 = mm_env.rx_filter_lmac_enable | mm_env.rx_filter_umac;
  if ((psVar1->chan[uVar2].flags & 1) == 0) {
    scan_probe_req_tx();
  }
  ke_state_set(2,3);
  return 0;
}



void txl_buffer_reinit(void)

{
  txl_buffer_env.list[0].first = (txl_buffer_tag *)0x0;
  txl_buffer_env.list[0].last = (txl_buffer_tag *)0x0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void txl_buffer_init(void)

{
  uint uVar1;
  txl_buffer_control *ptVar2;
  txl_buffer_control *ptVar3;
  uint8_t uVar4;
  byte bVar5;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  
  txl_buffer_reinit();
  ptVar3 = txl_buffer_control_desc;
  do {
    *(undefined4 *)ptVar3->field_0 = 0xbadcab1e;
    uVar4 = phy_get_ntx();
    *(int *)(ptVar3->field_0 + 4) = CONCAT31(extraout_var,uVar4) << 0xe;
    bVar5 = phy_get_ntx();
    *(int *)(ptVar3->field_0 + 8) = (1 << ((uint)bVar5 + 1 & 0x1f)) + -1;
    *(undefined4 *)(ptVar3->field_0 + 0xc) = 0;
    *(undefined4 *)(ptVar3->field_0 + 0x10) = 0xffff0704;
    *(undefined4 *)(ptVar3->field_0 + 0x14) = 0;
    *(undefined4 *)(ptVar3->field_0 + 0x18) = 0;
    *(undefined4 *)(ptVar3->field_0 + 0x1c) = 0;
    *(undefined4 *)(ptVar3->field_0 + 0x20) = 0;
    ptVar2 = ptVar3 + 1;
    *(uint *)(ptVar3->field_0 + 0x24) = _DAT_44b000a0 & 0xff;
    *(uint *)(ptVar3->field_0 + 0x28) = _DAT_44b000a0 & 0xff;
    *(uint *)(ptVar3->field_0 + 0x2c) = _DAT_44b000a0 & 0xff;
    uVar1 = _DAT_44b000a0;
    ptVar3->mac_control_info = 0x2200;
    ptVar3->phy_control_info = 0x3f0000;
    *(uint *)(ptVar3->field_0 + 0x30) = uVar1 & 0xff;
    ptVar3 = ptVar2;
  } while (ptVar2 != txl_frame_buf_ctrl);
  ptVar3 = txl_buffer_control_desc_bcmc;
  do {
    *(undefined4 *)ptVar3->field_0 = 0xbadcab1e;
    uVar4 = phy_get_ntx();
    *(int *)(ptVar3->field_0 + 4) = CONCAT31(extraout_var_00,uVar4) << 0xe;
    bVar5 = phy_get_ntx();
    *(int *)(ptVar3->field_0 + 8) = (1 << ((uint)bVar5 + 1 & 0x1f)) + -1;
    *(undefined4 *)(ptVar3->field_0 + 0xc) = 0;
    *(undefined4 *)(ptVar3->field_0 + 0x10) = 0xffff0704;
    *(undefined4 *)(ptVar3->field_0 + 0x14) = 0;
    *(undefined4 *)(ptVar3->field_0 + 0x18) = 0;
    *(undefined4 *)(ptVar3->field_0 + 0x1c) = 0;
    *(undefined4 *)(ptVar3->field_0 + 0x20) = 0;
    uVar1 = _DAT_44b000a0;
    ptVar2 = ptVar3 + 1;
    *(undefined4 *)(ptVar3->field_0 + 0x28) = 0;
    *(uint *)(ptVar3->field_0 + 0x24) = uVar1 & 0xff;
    *(undefined4 *)(ptVar3->field_0 + 0x2c) = 0;
    *(undefined4 *)(ptVar3->field_0 + 0x30) = 0;
    ptVar3->mac_control_info = 0;
    ptVar3->phy_control_info = 0x3f0000;
    ptVar3 = ptVar2;
  } while (ptVar2 != txl_buffer_control_desc);
  return;
}



void txl_buffer_reset(void)

{
  txl_buffer_env.list[0].first = (txl_buffer_tag *)0x0;
  txl_buffer_env.list[0].last = (txl_buffer_tag *)0x0;
  return;
}



txl_buffer_tag * txl_buffer_alloc(txdesc *txdesc,uint8_t access_category,uint8_t user_idx)

{
  ushort uVar1;
  txl_buffer_tag *ptVar2;
  txl_buffer_tag *ptVar3;
  txl_buffer_control *ptVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  
  uVar5 = (uint)(txdesc->umac).head_len;
  *(uint8_t *)(txdesc->buf + 0x3b) = user_idx;
  txdesc->buf[2] = (uVar5 + 0xf & 0xfffffff0) - uVar5;
  txdesc->buf[0xe] = 0xcafefade;
  uVar1 = (txdesc->host).flags;
  txdesc->buf[1] = uVar5;
  ptVar3 = (txl_buffer_tag *)txdesc->buf;
  if ((uVar1 & 8) == 0) {
    txu_cntrl_frame_build(txdesc,(int)txdesc->buf + uVar5 + 0x14c);
  }
  ptVar4 = (txdesc->umac).buf_control;
  iVar6 = 0;
  do {
    iVar7 = iVar6 + 4;
    *(undefined4 *)((int)txdesc->buf + iVar6 + 0xf0) = *(undefined4 *)(ptVar4->field_0 + iVar6);
    iVar6 = iVar7;
  } while (iVar7 != 0x3c);
  ptVar2 = ptVar3;
  if (txl_buffer_env.list[0].first != (txl_buffer_tag *)0x0) {
    (txl_buffer_env.list[0].last)->next = ptVar3;
    ptVar2 = txl_buffer_env.list[0].first;
  }
  txl_buffer_env.list[0].first = ptVar2;
  txl_buffer_env.list[0].last = ptVar3;
  txdesc->buf[4] = 0;
  return ptVar3;
}



void txl_buffer_update_thd(txdesc *txdesc)

{
  char "txl_buffer_update_thd" [22];
  uint32_t *puVar1;
  int iVar2;
  tx_pbd *in_a2;
  tx_pbd *ptVar3;
  uint32_t uVar4;
  txl_buffer_tag *ptVar5;
  tx_hw_desc *ptVar6;
  uint32_t uVar7;
  
  ptVar5 = (txdesc->lmac).buffer;
  ptVar6 = (txdesc->lmac).hw_desc;
  puVar1 = (txdesc->host).pbuf_chained_ptr;
  iVar2 = 0;
  ptVar3 = ptVar5->tbd_body;
  while (*puVar1 != 0) {
    ptVar3->upatterntx = 0xcafefade;
    uVar4 = *puVar1;
    ptVar3->datastartptr = uVar4;
    uVar7 = puVar1[4];
    ptVar3->bufctrlinfo = 0;
    iVar2 = iVar2 + 1;
    ptVar3->dataendptr = (uVar4 + uVar7) - 1;
    *(tx_pbd **)&ptVar3->next = ptVar3 + 1;
    puVar1 = puVar1 + 1;
    in_a2 = ptVar3;
    ptVar3 = ptVar3 + 1;
  }
  if (iVar2 == 0) {
    printf("%s: assert when set add_pbd chain\r\n","txl_buffer_update_thd");
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  uVar4 = ptVar5->lenheader;
  (ptVar5->tbd).upatterntx = 0xcafefade;
  *(txl_buffer_tag **)&(ptVar5->tbd).datastartptr = ptVar5 + 1;
  *(uint8_t **)&(ptVar5->tbd).dataendptr = ptVar5->tkip_mic_icv + uVar4 + 0xb;
  *(tx_pbd **)&(ptVar5->tbd).next = ptVar5->tbd_body;
  (ptVar5->tbd).bufctrlinfo = 0;
  *(tx_pbd **)&(ptVar6->thd).field_3 = &ptVar5->tbd;
  in_a2->bufctrlinfo = 0;
  (ptVar6->thd).macctrlinfo2 = 0x100;
  in_a2->next = 0;
  return;
}



void txl_cfm_init(void)

{
  memset(&txl_cfm_env,0,0x28);
  co_list_init((co_list *)&txl_cfm_env);
  co_list_init(txl_cfm_env.cfmlist + 1);
  co_list_init(txl_cfm_env.cfmlist + 2);
  co_list_init(txl_cfm_env.cfmlist + 3);
  co_list_init(txl_cfm_env.cfmlist + 4);
  return;
}



void txl_cfm_push(txdesc *txdesc,uint32_t status,uint8_t access_category)

{
  undefined3 in_register_00002031;
  
  ((txdesc->lmac).hw_desc)->cfm_ptr->status = status;
  co_list_push_back(txl_cfm_env.cfmlist + CONCAT31(in_register_00002031,access_category),
                    (co_list_hdr *)txdesc);
  ke_evt_set(txl_cfm_evt_bit[CONCAT31(in_register_00002031,access_category)]);
  return;
}


/*
Unable to decompile 'txl_cfm_evt'
Cause: Exception while decompiling 2301c59a: Decompiler process died

*/


void txl_cfm_flush(uint8_t access_category,co_list *list,uint32_t status)

{
  txdesc *txdesc;
  tx_cfm_tag *ptVar1;
  
  while (txdesc = (txdesc *)co_list_pop_front(list), txdesc != (txdesc *)0x0) {
    ptVar1 = ((txdesc->lmac).hw_desc)->cfm_ptr;
    if ((txdesc->lmac).agg_desc == (tx_agg_desc *)0x0) {
      if (-1 < (int)ptVar1->status) {
        ptVar1->status = status;
      }
    }
    else {
      ptVar1->status = status | 0x3c000000;
    }
    if ((txdesc->host).packet_addr == 0) {
      txl_frame_cfm(txdesc);
    }
    else {
      txu_cntrl_cfm(txdesc);
      txl_cntrl_env.pck_cnt = txl_cntrl_env.pck_cnt - 1;
      if ((txdesc->lmac).buffer != (txl_buffer_tag *)0x0) {
        (txdesc->lmac).buffer = (txl_buffer_tag *)0x0;
      }
    }
  }
  txl_frame_evt(0);
  ipc_emb_txcfm_ind(1 << ((uint)access_category & 0x1f));
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void txl_cfm_dma_int_handler(void)

{
  ps_env.prevent_sleep = ps_env.prevent_sleep & 0xfffffffe;
  _DAT_44a00020 = _DAT_44a00024 & 0x100;
  return;
}



void txl_cfm_dump(void)

{
  txl_cfm_env_tag *list;
  uint32_t uVar1;
  uint32_t **ppuVar2;
  
  list = &txl_cfm_env;
  do {
    uVar1 = co_list_cnt((co_list *)list);
    if (uVar1 != 0) {
      ppuVar2 = (uint32_t **)((bam_env_tag *)list)->pkt_cnt;
      while (ppuVar2 != (uint32_t **)0x0) {
        ppuVar2 = (uint32_t **)*ppuVar2;
      }
    }
    list = (txl_cfm_env_tag *)&((bam_env_tag *)list)->ssn;
  } while ((bam_env_tag *)list != bam_env);
  return;
}



void bam_init(void)

{
  bam_env[0].sta_idx = -1;
  ke_state_set(8,0);
  return;
}



void bam_send_air_action_frame
               (int param_1,bam_env_tag *param_2,int param_3,uint8_t param_4,int param_5,
               uint16_t param_6,cfm_func_ptr *param_7)

{
  byte bVar1;
  uint8_t ac;
  uint16_t uVar2;
  txl_frame_desc_tag *frame;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  txl_buffer_tag *ptVar3;
  tx_hw_desc *ptVar4;
  int iVar5;
  uint uVar6;
  char acStack72 [20];
  
  bVar1 = sta_info_tab[param_1].inst_nbr;
  uVar6 = (uint)bVar1;
  phy_get_channel((phy_channel_info *)acStack72,'\0');
  frame = txl_frame_get((uint)(acStack72[0] != '\0'),0x100);
  if (frame == (txl_frame_desc_tag *)0x0) {
    return;
  }
  tpc_update_frame_tx_power(vif_info_tab + uVar6,frame);
  ptVar3 = (frame->txdesc).lmac.buffer;
  *(undefined *)&ptVar3[1].length = 0xd0;
  *(undefined *)((int)&ptVar3[1].length + 1) = 0;
  *(undefined *)((int)&ptVar3[1].length + 2) = 0;
  *(undefined *)((int)&ptVar3[1].length + 3) = 0;
  *(uint16_t *)&ptVar3[1].lenheader = sta_info_tab[param_1].mac_addr.array[0];
  *(uint16_t *)((int)&ptVar3[1].lenheader + 2) = sta_info_tab[param_1].mac_addr.array[1];
  *(uint16_t *)&ptVar3[1].lenpad = sta_info_tab[param_1].mac_addr.array[2];
  *(uint16_t *)((int)&ptVar3[1].lenpad + 2) = vif_info_tab[uVar6].mac_addr.array[0];
  *(uint16_t *)&ptVar3[1].flags = vif_info_tab[uVar6].mac_addr.array[1];
  *(uint16_t *)((int)&ptVar3[1].flags + 2) = vif_info_tab[uVar6].mac_addr.array[2];
  if (vif_info_tab[uVar6].type == '\x02') {
    *(uint16_t *)&ptVar3[1].next = vif_info_tab[uVar6].mac_addr.array[0];
    *(uint16_t *)((int)&ptVar3[1].next + 2) = vif_info_tab[uVar6].mac_addr.array[1];
    uVar2 = vif_info_tab[uVar6].mac_addr.array[2];
  }
  else {
    *(uint16_t *)&ptVar3[1].next = sta_info_tab[param_1].mac_addr.array[0];
    *(uint16_t *)((int)&ptVar3[1].next + 2) = sta_info_tab[param_1].mac_addr.array[1];
    uVar2 = sta_info_tab[param_1].mac_addr.array[2];
  }
  *(uint16_t *)&ptVar3[1].txdesc = uVar2;
  uVar6 = (uint)txl_cntrl_env.seqnbr;
  txl_cntrl_env.seqnbr = (uint16_t)((uVar6 + 1) * 0x10000 >> 0x10);
  iVar5 = (uVar6 + 1) * 0x100000;
  *(undefined *)((int)&ptVar3[1].txdesc + 2) = (char)((uint)iVar5 >> 0x10);
  *(undefined *)((int)&ptVar3[1].txdesc + 3) = (char)((uint)iVar5 >> 0x18);
  (frame->txdesc).host.vif_idx = bVar1;
  (frame->txdesc).host.staid = (uint8_t)param_1;
  if (param_3 == 1) {
    uVar2 = me_build_add_ba_rsp((uint32_t)ptVar3[1].dma_desc,param_2,(uint16_t)param_5,param_4,
                                param_6);
    iVar5 = CONCAT22(extraout_var_00,uVar2);
LAB_2301c8fc:
    iVar5 = iVar5 + 0x18;
  }
  else {
    if (param_3 == 0) {
      ac = "\x01"[param_5 >> 2 & 0xf];
      uVar2 = me_build_add_ba_req((uint32_t)ptVar3[1].dma_desc,param_2);
      iVar5 = CONCAT22(extraout_var,uVar2) + 0x18;
      goto LAB_2301c8ae;
    }
    if (param_3 == 2) {
      uVar2 = me_build_del_ba((uint32_t)ptVar3[1].dma_desc,param_2,param_6);
      iVar5 = CONCAT22(extraout_var_01,uVar2);
      goto LAB_2301c8fc;
    }
    assert_warn("0","module",0x25d);
    iVar5 = 0x18;
  }
  ac = '\x03';
LAB_2301c8ae:
  ptVar4 = (frame->txdesc).lmac.hw_desc;
  (ptVar4->thd).field_5 = (ptVar4->thd).field_4 + -1 + iVar5;
  (ptVar4->thd).frmlen = iVar5 + 4;
  if (param_7 != (cfm_func_ptr *)0x0) {
    (frame->cfm).cfm_func = param_7;
    *(bam_env_tag **)&(frame->cfm).env = param_2;
  }
  txl_frame_push(frame,ac);
  return;
}



undefined4 rxu_mgt_ind_handler(int param_1)

{
  int iVar1;
  int iVar2;
  byte bVar3;
  byte bVar4;
  ushort uVar5;
  uint uVar6;
  uint uVar7;
  
  if (*(char *)(param_1 + 0x1d) == '\0') {
    uVar5 = *(ushort *)(param_1 + 0x1f);
    bVar3 = *(byte *)(param_1 + 7);
    bVar4 = *(byte *)(param_1 + 0x1e);
    iVar1 = 0x408;
    if ((uVar5 & 1) != 0) {
      iVar1 = 0x40c;
    }
    iVar2 = 0x418;
    if ((uVar5 & 2) == 0) {
      iVar2 = 0x42c;
    }
    uVar7 = (uint)(uVar5 >> 6);
    printf(
           "-----------------> AABA Request:\r\n    A-MSDU: %s\r\n    Block Ack Policy: %s\r\n    TID: %u\r\n    Number of Buffers: %u\r\n"
           ,iVar1 + 0x23078000,iVar2 + 0x23078000,(int)(uint)uVar5 >> 2 & 0xf,uVar7);
    if (8 < uVar5 >> 6) {
      uVar7 = 8;
    }
    uVar6 = SEXT24((short)((ushort)(uVar7 << 6) | uVar5 & 0x3e | 2));
    uVar7 = uVar6 & 0xffff;
    printf(
           "-----------------> AABA Response:\r\n    A-MSDU: %s\r\n    Block Ack Policy: %s\r\n    TID: %u\r\n    Number of Buffers: %u\r\n"
           ,"Not Permitted","Immediate Block Ack",(int)uVar6 >> 2 & 0xf,uVar7 >> 6);
    bam_send_air_action_frame((uint)bVar3,0,1,(uint)bVar4,uVar7,0,0);
    return 0;
  }
  return 0;
}



void co_pack8p(uint32_t dst,uint8_t *src,uint32_t len)

{
  uint8_t *puVar1;
  uint8_t *puVar2;
  uint32_t uVar3;
  
  uVar3 = 0;
  while (len != uVar3) {
    puVar1 = src + uVar3;
    puVar2 = (uint8_t *)(dst + uVar3);
    uVar3 = uVar3 + 1;
    *puVar2 = *puVar1;
  }
  return;
}



int phy_freq_to_channel(uint8_t band,uint16_t freq)

{
  undefined3 in_register_00002029;
  undefined2 in_register_0000202e;
  int iVar1;
  int iVar2;
  
  iVar1 = CONCAT22(in_register_0000202e,freq);
  if (CONCAT31(in_register_00002029,band) == 0) {
    if (0x48 < (iVar1 - 0x96cU & 0xffff)) {
      return 0;
    }
    if (iVar1 == 0x9b4) {
      return 0xe;
    }
    iVar2 = -0x967;
  }
  else {
    if (CONCAT31(in_register_00002029,band) != 1) {
      return 0;
    }
    if (0x334 < (iVar1 - 0x138dU & 0xffff)) {
      return 0;
    }
    iVar2 = -5000;
  }
  return (iVar1 + iVar2) / 5;
}



uint16_t phy_channel_to_freq(uint8_t band,int channel)

{
  undefined3 in_register_00002029;
  int iVar1;
  
  if (CONCAT31(in_register_00002029,band) == 0) {
    if (0xd < channel - 1U) {
      return 0xffff;
    }
    if (channel == 0xe) {
      return 0x9b4;
    }
    iVar1 = 0x967;
  }
  else {
    if (0xa4 < channel - 1U) {
      return 0xffff;
    }
    iVar1 = 5000;
  }
  return (uint16_t)((uint)((channel * 5 + iVar1) * 0x10000) >> 0x10);
}



uint32_t me_add_ie_ssid(uint32_t *frame_addr,uint8_t ssid_len,uint8_t *p_ssid)

{
  undefined3 in_register_0000202d;
  uint32_t len;
  
  len = CONCAT31(in_register_0000202d,ssid_len);
  *(undefined *)*frame_addr = 0;
  *(uint8_t *)(*frame_addr + 1) = ssid_len;
  if (len != 0) {
    co_pack8p(*frame_addr + 2,p_ssid,len);
  }
  *frame_addr = *frame_addr + len + 2;
  return len + 2;
}



uint32_t me_add_ie_supp_rates(uint32_t *frame_addr,mac_rateset *p_rateset)

{
  uint32_t len;
  byte bVar1;
  
  bVar1 = p_rateset->length;
  len = 8;
  if (bVar1 < 9) {
    len = (uint)bVar1;
  }
  *(undefined *)*frame_addr = 1;
  if (8 < bVar1) {
    bVar1 = 8;
  }
  *(byte *)(*frame_addr + 1) = bVar1;
  co_pack8p(*frame_addr + 2,p_rateset->array,len);
  *frame_addr = *frame_addr + len + 2;
  return len + 2;
}



uint32_t me_add_ie_ext_supp_rates(uint32_t *frame_addr,mac_rateset *p_rateset)

{
  byte bVar1;
  uint32_t uVar2;
  uint32_t len;
  
  bVar1 = p_rateset->length;
  *(undefined *)*frame_addr = 0x32;
  uVar2 = (uint)bVar1 - 6;
  len = (uint)bVar1 - 8;
  *(undefined *)(*frame_addr + 1) = (char)len;
  co_pack8p(*frame_addr + 2,p_rateset->array + 8,len);
  *frame_addr = *frame_addr + uVar2;
  return uVar2;
}



uint32_t me_add_ie_ds(uint32_t *frame_addr,uint8_t channel)

{
  *(undefined *)*frame_addr = 3;
  *(undefined *)(*frame_addr + 1) = 1;
  *(uint8_t *)(*frame_addr + 2) = channel;
  *frame_addr = *frame_addr + 3;
  return 3;
}



uint32_t me_add_ie_erp(uint32_t *frame_addr,uint8_t erp_info)

{
  *(undefined *)*frame_addr = 0x2a;
  *(undefined *)(*frame_addr + 1) = 1;
  *(uint8_t *)(*frame_addr + 2) = erp_info;
  *frame_addr = *frame_addr + 3;
  return 3;
}



uint32_t me_add_ie_rsn(uint32_t *frame_addr,uint8_t enc_type)

{
  undefined3 in_register_0000202d;
  uint32_t uVar1;
  uint32_t uVar2;
  
  if (CONCAT31(in_register_0000202d,enc_type) == 1) {
    *(undefined *)*frame_addr = 0x30;
    *(undefined *)(*frame_addr + 1) = 0x14;
    uVar1 = *frame_addr;
    *(uint8_t *)(uVar1 + 2) = enc_type;
    *(undefined *)(uVar1 + 3) = 0;
    uVar1 = *frame_addr;
    *(undefined *)(uVar1 + 6) = 0xac;
    *(undefined *)(uVar1 + 7) = 4;
    *(undefined *)(uVar1 + 4) = 0;
    *(undefined *)(uVar1 + 5) = 0xf;
    uVar1 = *frame_addr;
    *(uint8_t *)(uVar1 + 8) = enc_type;
    *(undefined *)(uVar1 + 9) = 0;
    uVar1 = *frame_addr;
    *(undefined *)(uVar1 + 0xc) = 0xac;
    *(undefined *)(uVar1 + 0xd) = 4;
    *(undefined *)(uVar1 + 10) = 0;
    *(undefined *)(uVar1 + 0xb) = 0xf;
    uVar2 = *frame_addr;
    uVar1 = 0x16;
    *(uint8_t *)(uVar2 + 0xe) = enc_type;
    *(undefined *)(uVar2 + 0xf) = 0;
    uVar2 = *frame_addr;
    *(undefined *)(uVar2 + 0x12) = 0xac;
    *(undefined *)(uVar2 + 0x10) = 0;
    *(undefined *)(uVar2 + 0x11) = 0xf;
    *(undefined *)(uVar2 + 0x13) = 2;
    uVar2 = *frame_addr;
    *(undefined *)(uVar2 + 0x14) = 0;
    *(undefined *)(uVar2 + 0x15) = 0;
  }
  else {
    uVar1 = 0;
    if (CONCAT31(in_register_0000202d,enc_type) == 2) {
      *(undefined *)*frame_addr = 0x30;
      *(undefined *)(*frame_addr + 1) = 0x18;
      uVar1 = *frame_addr;
      *(undefined *)(uVar1 + 2) = 1;
      *(undefined *)(uVar1 + 3) = 0;
      uVar1 = *frame_addr;
      *(undefined *)(uVar1 + 4) = 0;
      *(undefined *)(uVar1 + 5) = 0xf;
      *(undefined *)(uVar1 + 6) = 0xac;
      *(uint8_t *)(uVar1 + 7) = enc_type;
      uVar1 = *frame_addr;
      *(uint8_t *)(uVar1 + 8) = enc_type;
      *(undefined *)(uVar1 + 9) = 0;
      uVar1 = *frame_addr;
      *(undefined *)(uVar1 + 10) = 0;
      *(undefined *)(uVar1 + 0xb) = 0xf;
      *(undefined *)(uVar1 + 0xc) = 0xac;
      *(uint8_t *)(uVar1 + 0xd) = enc_type;
      uVar1 = *frame_addr;
      *(undefined *)(uVar1 + 0x11) = 4;
      *(undefined *)(uVar1 + 0xe) = 0;
      *(undefined *)(uVar1 + 0xf) = 0xf;
      *(undefined *)(uVar1 + 0x10) = 0xac;
      uVar2 = *frame_addr;
      uVar1 = 0x1a;
      *(undefined *)(uVar2 + 0x12) = 1;
      *(undefined *)(uVar2 + 0x13) = 0;
      uVar2 = *frame_addr;
      *(undefined *)(uVar2 + 0x14) = 0;
      *(undefined *)(uVar2 + 0x15) = 0xf;
      *(undefined *)(uVar2 + 0x16) = 0xac;
      *(uint8_t *)(uVar2 + 0x17) = enc_type;
      uVar2 = *frame_addr;
      *(undefined *)(uVar2 + 0x18) = 0;
      *(undefined *)(uVar2 + 0x19) = 0;
    }
  }
  *frame_addr = *frame_addr + uVar1;
  return uVar1;
}



uint32_t me_add_ie_wpa(uint32_t *frame_addr,uint8_t enc_type)

{
  uint32_t uVar1;
  undefined3 in_register_0000202d;
  uint32_t uVar2;
  
  uVar1 = 0;
  if (CONCAT31(in_register_0000202d,enc_type) == 2) {
    *(undefined *)*frame_addr = 0xdd;
    *(undefined *)(*frame_addr + 1) = 0x1c;
    uVar1 = *frame_addr;
    *(undefined *)(uVar1 + 5) = 1;
    *(undefined *)(uVar1 + 2) = 0;
    *(undefined *)(uVar1 + 3) = 0x50;
    *(undefined *)(uVar1 + 4) = 0xf2;
    uVar1 = *frame_addr;
    *(undefined *)(uVar1 + 6) = 1;
    *(undefined *)(uVar1 + 7) = 0;
    uVar1 = *frame_addr;
    *(undefined *)(uVar1 + 8) = 0;
    *(undefined *)(uVar1 + 9) = 0x50;
    *(undefined *)(uVar1 + 10) = 0xf2;
    *(uint8_t *)(uVar1 + 0xb) = enc_type;
    uVar1 = *frame_addr;
    *(uint8_t *)(uVar1 + 0xc) = enc_type;
    *(undefined *)(uVar1 + 0xd) = 0;
    uVar1 = *frame_addr;
    *(undefined *)(uVar1 + 0xe) = 0;
    *(undefined *)(uVar1 + 0xf) = 0x50;
    *(undefined *)(uVar1 + 0x10) = 0xf2;
    *(uint8_t *)(uVar1 + 0x11) = enc_type;
    uVar1 = *frame_addr;
    *(undefined *)(uVar1 + 0x12) = 0;
    *(undefined *)(uVar1 + 0x13) = 0x50;
    *(undefined *)(uVar1 + 0x14) = 0xf2;
    *(undefined *)(uVar1 + 0x15) = 4;
    uVar1 = *frame_addr;
    *(undefined *)(uVar1 + 0x16) = 1;
    *(undefined *)(uVar1 + 0x17) = 0;
    uVar2 = *frame_addr;
    uVar1 = 0x1e;
    *(undefined *)(uVar2 + 0x18) = 0;
    *(undefined *)(uVar2 + 0x19) = 0x50;
    *(undefined *)(uVar2 + 0x1a) = 0xf2;
    *(uint8_t *)(uVar2 + 0x1b) = enc_type;
  }
  *frame_addr = *frame_addr + uVar1;
  return uVar1;
}



uint32_t me_add_ie_tim(uint32_t *frame_addr,uint8_t dtim_period)

{
  *(undefined *)*frame_addr = 5;
  *(undefined *)(*frame_addr + 1) = 4;
  *(uint8_t *)(*frame_addr + 3) = dtim_period;
  *frame_addr = *frame_addr + 6;
  return 6;
}



uint32_t me_add_ie_ht_capa(uint32_t *frame_addr)

{
  uint16_t uVar1;
  uint32_t uVar2;
  uint uVar3;
  
  uVar3 = (uint)me_env.ht_cap.ht_capa_info;
  *(undefined *)*frame_addr = 0x2d;
  *(undefined *)(*frame_addr + 1) = 0x1a;
  uVar2 = *frame_addr;
  *(byte *)(uVar2 + 2) = (byte)(uVar3 & 0xfffffff3) | 0xc;
  *(undefined *)(uVar2 + 3) = (char)((uVar3 & 0xfffffff3) >> 8);
  *(uint8_t *)(*frame_addr + 4) = me_env.ht_cap.a_mpdu_param;
  co_pack8p(*frame_addr + 5,me_env.ht_cap.mcs_rate,0x10);
  uVar1 = me_env.ht_cap.ht_extended_capa;
  uVar2 = *frame_addr;
  *(undefined *)(uVar2 + 0x15) = (char)me_env.ht_cap.ht_extended_capa;
  *(undefined *)(uVar2 + 0x16) = (char)(uVar1 >> 8);
  co_pack8p(*frame_addr + 0x17,(uint8_t *)&me_env.ht_cap.tx_beamforming_capa,4);
  *(uint8_t *)(*frame_addr + 0x1b) = me_env.ht_cap.asel_capa;
  *frame_addr = *frame_addr + 0x1c;
  return 0x1c;
}



uint32_t me_add_ie_ht_oper(uint32_t *frame_addr,vif_info_tag *p_vif_entry)

{
  chan_ctxt_tag *pcVar1;
  int iVar2;
  uint8_t uVar3;
  uint32_t uVar4;
  
  pcVar1 = p_vif_entry->chan_ctxt;
  *(undefined *)*frame_addr = 0x3d;
  *(undefined *)(*frame_addr + 1) = 0x16;
  iVar2 = phy_freq_to_channel((pcVar1->channel).band,(pcVar1->channel).prim20_freq);
  *(undefined *)(*frame_addr + 2) = (char)iVar2;
  uVar3 = (pcVar1->channel).type;
  if ((uVar3 != '\0') &&
     (uVar3 = '\a', (pcVar1->channel).prim20_freq <= (pcVar1->channel).center1_freq)) {
    uVar3 = '\x05';
  }
  *(uint8_t *)(*frame_addr + 3) = uVar3;
  uVar4 = *frame_addr;
  *(undefined *)(uVar4 + 4) = 3;
  *(undefined *)(uVar4 + 5) = 0;
  uVar4 = *frame_addr;
  *(undefined *)(uVar4 + 6) = 0;
  *(undefined *)(uVar4 + 7) = 0;
  *(undefined *)(*frame_addr + 8) = 0xff;
  *frame_addr = *frame_addr + 0x18;
  return 0x18;
}



uint16_t me_build_authenticate
                   (uint32_t frame,uint16_t algo_type,uint16_t seq_nbr,uint16_t status_code,
                   uint32_t *challenge_array_ptr)

{
  undefined *puVar1;
  undefined *puVar2;
  int iVar3;
  
  *(char *)frame = (char)algo_type;
  *(undefined *)(frame + 2) = (char)seq_nbr;
  *(undefined *)(frame + 4) = (char)status_code;
  *(undefined *)(frame + 1) = (char)(algo_type >> 8);
  *(undefined *)(frame + 3) = (char)(seq_nbr >> 8);
  *(undefined *)(frame + 5) = (char)(status_code >> 8);
  if (challenge_array_ptr != (uint32_t *)0x0) {
    *(undefined *)(frame + 6) = 0x10;
    *(undefined *)(frame + 7) = 0x80;
    iVar3 = 0;
    do {
      puVar1 = (undefined *)((int)challenge_array_ptr + iVar3);
      puVar2 = (undefined *)(frame + 8 + iVar3);
      iVar3 = iVar3 + 1;
      *puVar2 = *puVar1;
    } while (iVar3 != 0x80);
    return 0x88;
  }
  return 6;
}



uint16_t me_build_deauthenticate(uint32_t frame,uint16_t reason_code)

{
  *(char *)frame = (char)reason_code;
  *(undefined *)(frame + 1) = (char)(reason_code >> 8);
  return 2;
}



// WARNING: Could not reconcile some variable overlaps

uint16_t me_build_associate_req
                   (uint32_t frame,mac_bss_info *bss,mac_addr *old_ap_addr_ptr,uint8_t vif_idx,
                   uint32_t *ie_addr,uint16_t *ie_len,sm_connect_req *con_par)

{
  byte bVar1;
  uint32_t *puVar2;
  uint8_t uVar3;
  ushort uVar4;
  mac_ssid *pmVar5;
  int8_t *piVar6;
  uint uVar7;
  uint16_t uVar8;
  short sVar9;
  int iVar10;
  uint16_t uVar11;
  uint32_t uVar12;
  uint32_t uVar13;
  uint uVar14;
  char *pcVar15;
  int8_t *dst;
  uint uVar16;
  uint uVar17;
  uint uVar18;
  uint uVar19;
  me_chan_config_req *pmVar20;
  char cVar21;
  char cVar22;
  uint uVar23;
  uint8_t uVar24;
  int8_t *apiStack100 [4];
  int8_t iStack81;
  undefined2 uStack80;
  undefined uStack78;
  int8_t min;
  int8_t max;
  
  uVar8 = con_par->listen_interval;
  uVar4 = con_par->ie_len;
  if (uVar8 == 0) {
    uVar8 = 5;
  }
  apiStack100[0] = (int8_t *)frame;
  uVar11 = me_build_capability(vif_idx);
  *apiStack100[0] = (int8_t)uVar11;
  apiStack100[0][1] = (int8_t)(uVar11 >> 8);
  apiStack100[0][2] = (int8_t)uVar8;
  apiStack100[0][3] = (int8_t)(uVar8 >> 8);
  iVar10 = 4;
  if (old_ap_addr_ptr != (mac_addr *)0x0) {
    iVar10 = 10;
    *(uint16_t *)(apiStack100[0] + 4) = old_ap_addr_ptr->array[0];
    *(uint16_t *)(apiStack100[0] + 6) = old_ap_addr_ptr->array[1];
    *(uint16_t *)(apiStack100[0] + 8) = old_ap_addr_ptr->array[2];
  }
  apiStack100[0] = apiStack100[0] + iVar10;
  *(int8_t **)ie_addr = apiStack100[0];
  uVar12 = me_add_ie_ssid((uint32_t *)apiStack100,(bss->ssid).length,(bss->ssid).array);
  uVar13 = me_add_ie_supp_rates((uint32_t *)apiStack100,&bss->rate_set);
  sVar9 = (short)iVar10 + (short)uVar13 + (short)uVar12;
  if (8 < (bss->rate_set).length) {
    uVar12 = me_add_ie_ext_supp_rates((uint32_t *)apiStack100,&bss->rate_set);
    sVar9 = sVar9 + (short)uVar12;
  }
  if ((uVar11 & 0x100) != 0) {
    dst = apiStack100[0] + 1;
    *apiStack100[0] = '!';
    apiStack100[0] = apiStack100[0] + 2;
    *dst = '\x02';
    phy_get_rf_gain_capab((int8_t *)&uStack80,&iStack81);
    bVar1 = bss->chan->tx_power;
    if ((char)bVar1 < (char)uStack80) {
      uStack80 = uStack80 & 0xff00 | (ushort)bVar1;
    }
    *apiStack100[0] = iStack81;
    apiStack100[0][1] = (char)uStack80;
    dst = apiStack100[0] + 3;
    apiStack100[0][2] = '$';
    apiStack100[0] = apiStack100[0] + 4;
    if (bss->chan->band == '\0') {
      pmVar20 = &me_env.chan;
      iVar10 = 1;
      uVar3 = me_env.chan.chan2G4_cnt;
    }
    else {
      pmVar20 = (me_chan_config_req *)me_env.chan.chan5G;
      iVar10 = 4;
      uVar3 = me_env.chan.chan5G_cnt;
    }
    uVar19 = 0;
    cVar21 = '\0';
    uVar24 = '\0';
    uVar7 = 0;
    uVar17 = 0;
    while( true ) {
      piVar6 = apiStack100[0];
      uVar23 = uVar19 + 2 & 0xff;
      pcVar15 = apiStack100[0] + 1;
      if (uVar24 == uVar3) break;
      uVar16 = uVar7;
      uVar18 = uVar17;
      if ((pmVar20->chan2G4[0].flags & 2) == 0) {
        uVar14 = phy_freq_to_channel(pmVar20->chan2G4[0].band,pmVar20->chan2G4[0].freq);
        uVar16 = uVar14 & 0xff;
        uVar18 = uVar16;
        cVar22 = cVar21;
        if ((cVar21 != '\0') && (uVar18 = uVar17, (uVar14 & 0xff) - uVar7 != iVar10)) {
          cVar22 = cVar21 + '\x01';
          *piVar6 = (int8_t)uVar17;
          apiStack100[0] = piVar6 + 2;
          *pcVar15 = cVar21;
          uVar19 = uVar23;
        }
        cVar21 = cVar22 + '\x01';
        pmVar20 = (me_chan_config_req *)(pmVar20->chan2G4 + 1);
      }
      uVar24 = uVar24 + '\x01';
      uVar7 = uVar16;
      uVar17 = uVar18;
    }
    *apiStack100[0] = (int8_t)uVar17;
    sVar9 = sVar9 + 6 + (short)uVar23;
    apiStack100[0] = apiStack100[0] + 2;
    *pcVar15 = cVar21;
    *dst = (int8_t)uVar23;
  }
  pmVar5 = &con_par->ssid;
  iVar10 = -(int)con_par;
  while ((sm_connect_req *)(&pmVar5->length + uVar4) != con_par) {
    puVar2 = con_par->ie_buf;
    dst = apiStack100[0] + iVar10 + (int)con_par;
    con_par = (sm_connect_req *)(con_par->ssid).array;
    *dst = *(int8_t *)puVar2;
  }
  uVar8 = sVar9 + uVar4;
  dst = apiStack100[0] + uVar4;
  apiStack100[0] = dst;
  if ((bss->valid_flags & 1) != 0) {
    memset(&uStack78,0,0xe);
    uStack80 = 0x7dd;
    min = 'P';
    co_pack8p((uint32_t)dst,(uint8_t *)&uStack80,9);
    uVar8 = uVar8 + (ushort)uStack80._1_1_ + 2;
    apiStack100[0] = apiStack100[0] + (uint)uStack80._1_1_ + 2;
  }
  if (((bss->valid_flags & 2) != 0) && (me_env.ht_supported != false)) {
    uVar12 = me_add_ie_ht_capa((uint32_t *)apiStack100);
    uVar8 = uVar8 + (short)uVar12;
  }
  *ie_len = (short)apiStack100[0] - (short)*ie_addr;
  return uVar8;
}



uint16_t me_build_add_ba_req(uint32_t frame,bam_env_tag *bam_env)

{
  uint16_t uVar1;
  uint uVar2;
  int iVar3;
  
  *(undefined *)frame = 3;
  *(undefined *)(frame + 1) = 0;
  *(uint8_t *)(frame + 2) = bam_env->dialog_token;
  uVar2 = (uint)bam_env->ba_policy << 1 | (uint)bam_env->tid << 2 | (uint)bam_env->buffer_size << 6;
  *(undefined *)(frame + 3) = (char)uVar2;
  *(undefined *)(frame + 4) = (char)(uVar2 >> 8);
  uVar1 = bam_env->ba_timeout;
  *(undefined *)(frame + 5) = (char)uVar1;
  *(undefined *)(frame + 6) = (char)(uVar1 >> 8);
  iVar3 = (uint)bam_env->ssn << 0x14;
  *(undefined *)(frame + 7) = (char)((uint)iVar3 >> 0x10);
  *(undefined *)(frame + 8) = (char)((uint)iVar3 >> 0x18);
  return 9;
}



uint16_t me_build_add_ba_rsp(uint32_t frame,bam_env_tag *bam_env,uint16_t param,uint8_t dialog_token
                            ,uint16_t status_code)

{
  undefined2 in_register_0000203a;
  
  *(undefined *)frame = 3;
  *(undefined *)(frame + 1) = 1;
  *(undefined *)(frame + 5) = (char)param;
  *(undefined *)(frame + 4) = (char)(status_code >> 8);
  *(uint8_t *)(frame + 2) = dialog_token;
  *(undefined *)(frame + 3) = (char)status_code;
  *(undefined *)(frame + 6) = (char)(param >> 8);
  if (CONCAT22(in_register_0000203a,status_code) == 0) {
    *(undefined *)(frame + 7) = 0xd0;
    *(undefined *)(frame + 8) = 7;
  }
  else {
    *(undefined *)(frame + 7) = 0;
    *(undefined *)(frame + 8) = 0;
  }
  return 9;
}



uint16_t me_build_del_ba(uint32_t frame,bam_env_tag *bam_env,uint16_t reason_code)

{
  byte bVar1;
  
  *(undefined *)frame = 3;
  *(undefined *)(frame + 1) = 2;
  bVar1 = (byte)(((uint)bam_env->tid << 0x1c) >> 0x18);
  if (bam_env->dev_type == '\x01') {
    bVar1 = bVar1 | 8;
  }
  *(undefined *)(frame + 2) = 0;
  *(byte *)(frame + 3) = bVar1;
  *(undefined *)(frame + 4) = (char)reason_code;
  *(undefined *)(frame + 5) = (char)(reason_code >> 8);
  return 6;
}



void me_extract_rate_set(uint32_t buffer,uint16_t buflen,mac_rateset *mac_rate_set_ptr)

{
  byte bVar1;
  byte bVar2;
  int iVar3;
  undefined2 in_register_0000202e;
  uint uVar4;
  uint8_t *puVar5;
  uint uVar6;
  
  mac_rate_set_ptr->length = '\0';
  iVar3 = mac_ie_find(CONCAT22(in_register_0000202e,buflen),1);
  if (iVar3 != 0) {
    bVar1 = *(byte *)(iVar3 + 1);
    uVar4 = (uint)bVar1;
    if (bVar1 < 0xd) {
      puVar5 = mac_rate_set_ptr->array;
      while (uVar4 = uVar4 - 1, uVar4 != 0xffffffff) {
        *puVar5 = (puVar5 + 1)[iVar3 - (int)mac_rate_set_ptr];
        puVar5 = puVar5 + 1;
      }
      mac_rate_set_ptr->length = bVar1;
      iVar3 = mac_ie_find(buffer,CONCAT22(in_register_0000202e,buflen),0x32);
      if (iVar3 != 0) {
        bVar1 = *(byte *)(iVar3 + 1);
        uVar4 = (uint)bVar1;
        if (0xc < mac_rate_set_ptr->length + uVar4) {
          assert_err("mac_rate_set_ptr->length + elmt_length <= MAC_RATESET_LEN","module",0x396);
        }
        bVar2 = mac_rate_set_ptr->length;
        if (bVar2 + uVar4 < 0xd) {
          uVar6 = 0;
          while (uVar4 != uVar6) {
            mac_rate_set_ptr->array[bVar2 + uVar6] = *(uint8_t *)(iVar3 + 2 + uVar6);
            uVar6 = uVar6 + 1;
          }
          mac_rate_set_ptr->length = bVar1 + mac_rate_set_ptr->length;
        }
      }
    }
  }
  return;
}



void me_extract_power_constraint(uint32_t buffer,uint16_t buflen,mac_bss_info *bss)

{
  int iVar1;
  uint8_t uVar2;
  
  iVar1 = mac_ie_find(0x20);
  uVar2 = '\0';
  if (iVar1 != 0) {
    uVar2 = *(uint8_t *)(iVar1 + 2);
  }
  bss->power_constraint = uVar2;
  return;
}



void me_extract_country_reg(int param_1)

{
  uint16_t *puVar1;
  int iVar2;
  uint uVar3;
  byte *pbVar4;
  uint uVar5;
  byte bVar6;
  uint uVar7;
  int iVar8;
  
  iVar2 = mac_ie_find(7);
  if (iVar2 != 0) {
    puVar1 = *(uint16_t **)(param_1 + 0x4c);
    iVar8 = 1;
    if (*(uint8_t *)(puVar1 + 1) != '\0') {
      iVar8 = 4;
    }
    uVar3 = phy_freq_to_channel(*(uint8_t *)(puVar1 + 1),*puVar1);
    uVar7 = 5;
    while (uVar7 <= (uint)*(byte *)(iVar2 + 1) + 1) {
      pbVar4 = (byte *)(uVar7 + iVar2);
      uVar5 = (uint)*pbVar4;
      bVar6 = 0;
      while (bVar6 != pbVar4[1]) {
        if (uVar5 == (uVar3 & 0xff)) {
          *(byte *)(puVar1 + 2) = pbVar4[2];
          return;
        }
        bVar6 = bVar6 + 1;
        uVar5 = uVar5 + iVar8 & 0xff;
      }
      uVar7 = uVar7 + 3 & 0xff;
    }
  }
  return;
}



void me_extract_mobility_domain(uint32_t buffer,uint16_t buflen,mac_bss_info *bss)

{
  int iVar1;
  
  iVar1 = mac_ie_find(0x36);
  if (iVar1 == 0) {
    (bss->mde).mdid = 0;
    (bss->mde).ft_capability_policy = '\0';
  }
  else {
    (bss->mde).mdid = *(uint16_t *)(iVar1 + 2);
    (bss->mde).ft_capability_policy = *(uint8_t *)(iVar1 + 4);
  }
  return;
}



uint me_extract_csa(undefined4 param_1,undefined4 param_2,undefined *param_3,int param_4)

{
  byte bVar1;
  byte bVar2;
  bool band;
  short sVar3;
  uint16_t uVar4;
  uint16_t uVar5;
  uint16_t uVar6;
  uint uVar7;
  uint uVar8;
  int iVar9;
  int iVar10;
  undefined uVar11;
  
  uVar7 = mac_ie_find(0x25);
  uVar8 = mac_ie_find(param_1,param_2,0x3c);
  if ((uVar7 | uVar8) == 0) {
    return 0;
  }
  iVar9 = mac_ie_find(param_1,param_2,0x3e);
  iVar10 = mac_ie_find(param_1,param_2,0xc4);
  if (iVar10 != 0) {
    iVar10 = mac_ie_find(iVar10 + 2,(uint)*(byte *)(iVar10 + 1),0xc2);
  }
  if (uVar7 == 0) {
    bVar1 = *(byte *)(uVar8 + 5);
    *param_3 = *(undefined *)(uVar8 + 2);
    bVar2 = *(byte *)(uVar8 + 4);
  }
  else {
    bVar1 = *(byte *)(uVar7 + 4);
    *param_3 = *(undefined *)(uVar7 + 2);
    bVar2 = *(byte *)(uVar7 + 3);
  }
  uVar7 = (uint)bVar1;
  if (bVar1 == 0) {
    uVar7 = 2;
  }
  band = 0xe < bVar2;
  uVar4 = phy_channel_to_freq(band,(uint)bVar2);
  if (iVar10 != 0) {
    uVar8 = (uint)*(byte *)(iVar10 + 2) - 1 & 0xff;
    bVar1 = *(byte *)(iVar10 + 4);
    uVar11 = 1;
    if (uVar8 < 3) {
      uVar11 = *(undefined *)((int)&CSWTCH_115 + uVar8);
    }
    uVar5 = phy_channel_to_freq(band,(uint)*(byte *)(iVar10 + 3));
    uVar6 = 0;
    if (bVar1 != 0) {
      uVar6 = phy_channel_to_freq(band,(uint)bVar1);
    }
    goto LAB_2301d564;
  }
  if (iVar9 == 0) {
LAB_2301d5c6:
    uVar6 = 0;
    uVar11 = 0;
    uVar5 = uVar4;
  }
  else {
    sVar3 = 10;
    if (*(char *)(iVar9 + 2) != '\x01') {
      if (*(char *)(iVar9 + 2) != '\x03') goto LAB_2301d5c6;
      sVar3 = -10;
    }
    uVar6 = 0;
    uVar11 = 1;
    uVar5 = uVar4 + sVar3;
  }
LAB_2301d564:
  *(uint16_t *)(param_4 + 6) = uVar6;
  *(bool *)param_4 = band;
  *(undefined *)(param_4 + 1) = uVar11;
  *(uint16_t *)(param_4 + 2) = uVar4;
  *(uint16_t *)(param_4 + 4) = uVar5;
  return uVar7;
}



// WARNING: Could not reconcile some variable overlaps

uint16_t me_build_beacon(uint32_t frame,uint8_t vif_idx,uint16_t *tim_oft,uint8_t *tim_len,
                        uint8_t hidden_ssid)

{
  uint8_t enc_type;
  short sVar1;
  uint16_t uVar2;
  uint32_t uVar3;
  uint32_t uVar4;
  uint32_t uVar5;
  uint32_t uVar6;
  uint8_t ssid_len;
  undefined3 in_register_0000202d;
  int iVar7;
  uint8_t *p_ssid;
  undefined3 in_register_00002039;
  uint uVar8;
  int iVar9;
  undefined *puVar10;
  mac_rateset *p_rateset;
  uint32_t uStack68;
  undefined2 uStack64;
  undefined uStack62;
  undefined uStack61;
  uint8_t wme_ie [16];
  
  iVar7 = CONCAT31(in_register_0000202d,vif_idx);
  enc_type = vif_info_tab[iVar7].bss_info.sec_type;
  *(undefined *)frame = 0x80;
  *(undefined *)(frame + 1) = 0;
  *(undefined *)(frame + 2) = 0;
  *(undefined *)(frame + 3) = 0;
  uStack68 = frame;
  memcpy((void *)(frame + 4),&mac_addr_bcst,6);
  memcpy((void *)(frame + 10),&vif_info_tab[iVar7].mac_addr,6);
  memcpy((void *)(frame + 0x10),&vif_info_tab[iVar7].mac_addr,6);
  uVar8 = (uint)txl_cntrl_env.seqnbr;
  txl_cntrl_env.seqnbr = (uint16_t)((uVar8 + 1) * 0x10000 >> 0x10);
  iVar9 = (uVar8 + 1) * 0x100000;
  *(undefined *)(frame + 0x16) = (char)((uint)iVar9 >> 0x10);
  *(undefined *)(frame + 0x17) = (char)((uint)iVar9 >> 0x18);
  uVar2 = vif_info_tab[iVar7].bss_info.beacon_interval;
  *(undefined *)(uStack68 + 0x20) = (char)uVar2;
  *(undefined *)(uStack68 + 0x21) = (char)(uVar2 >> 8);
  uVar2 = me_build_capability(vif_idx);
  if (enc_type != '\0') {
    uVar2 = uVar2 | 0x10;
  }
  p_ssid = vif_info_tab[iVar7].bss_info.ssid.array;
  *(undefined *)(uStack68 + 0x22) = (char)uVar2;
  *(undefined *)(uStack68 + 0x23) = (char)(uVar2 >> 8);
  uStack68 = uStack68 + 0x24;
  if (CONCAT31(in_register_00002039,hidden_ssid) == 0) {
    ssid_len = vif_info_tab[iVar7].bss_info.ssid.length;
  }
  else {
    printf("Using Hidden SSID [%s]\r\n",p_ssid);
    p_ssid = (uint8_t *)0x0;
    ssid_len = '\0';
  }
  uVar3 = me_add_ie_ssid(&uStack68,ssid_len,p_ssid);
  p_rateset = &vif_info_tab[iVar7].bss_info.rate_set;
  uVar4 = me_add_ie_supp_rates(&uStack68,p_rateset);
  uVar8 = (uVar3 + 0x24 & 0xffff) + uVar4 & 0xffff;
  if (8 < vif_info_tab[iVar7].bss_info.rate_set.length) {
    uVar3 = me_add_ie_ext_supp_rates(&uStack68,p_rateset);
    uVar8 = uVar8 + uVar3 & 0xffff;
  }
  uVar3 = me_add_ie_ds(&uStack68,
                       (char)((int)((uint)(vif_info_tab[iVar7].bss_info.chan)->freq - 0x96c) / 5) +
                       '\x01');
  *tim_oft = (uint16_t)((uVar8 + uVar3) * 0x10000 >> 0x10);
  uVar4 = me_add_ie_tim(&uStack68,*(uint8_t *)&vif_info_tab[iVar7].bss_info.beacon_period);
  *tim_len = (uint8_t)(uVar4 & 0xff);
  uVar5 = me_add_ie_rsn(&uStack68,enc_type);
  memcpy(int_rsn_ie,(void *)(uStack68 - (uVar5 & 0xff)),uVar5 & 0xff);
  uVar6 = me_add_ie_erp(&uStack68,'\0');
  sVar1 = (short)(uVar8 + uVar3) + (short)(uVar4 & 0xff) + (short)uVar6 + ((ushort)uVar5 & 0xff);
  if ((vif_info_tab[iVar7].bss_info.valid_flags & 2) != 0) {
    uVar3 = me_add_ie_ht_capa(&uStack68);
    uVar4 = me_add_ie_ht_oper(&uStack68,vif_info_tab + iVar7);
    sVar1 = sVar1 + (short)uVar4 + (short)uVar3;
  }
  uVar3 = me_add_ie_wpa(&uStack68,enc_type);
  uVar2 = sVar1 + (short)uVar3;
  if ((vif_info_tab[iVar7].bss_info.valid_flags & 1) != 0) {
    memset(&uStack62,0,0xe);
    uStack64 = 0x7dd;
    uStack61 = 0x50;
    wme_ie._0_2_ = 0x2f2;
    wme_ie[3] = '\x01';
    wme_ie[4] = vif_info_tab[iVar7].bss_info.edca_param.qos_info;
    co_pack8p(uStack68,(uint8_t *)&uStack64,9);
    *(char *)(uStack68 + 1) = *(char *)(uStack68 + 1) + '\x11';
    puVar10 = (undefined *)(uStack68 + 2 + (uint)uStack64._1_1_);
    *puVar10 = 0;
    uVar3 = vif_info_tab[iVar7].txq_params[1];
    puVar10[1] = (char)uVar3;
    puVar10[2] = (char)(uVar3 >> 8);
    puVar10[3] = (char)(uVar3 >> 0x10);
    puVar10[4] = (char)(uVar3 >> 0x18);
    uVar3 = vif_info_tab[iVar7].txq_params[0];
    puVar10[5] = (char)uVar3;
    puVar10[6] = (char)(uVar3 >> 8);
    puVar10[7] = (char)(uVar3 >> 0x10);
    puVar10[8] = (char)(uVar3 >> 0x18);
    uVar3 = vif_info_tab[iVar7].txq_params[2];
    puVar10[9] = (char)uVar3;
    puVar10[10] = (char)(uVar3 >> 8);
    puVar10[0xb] = (char)(uVar3 >> 0x10);
    puVar10[0xc] = (char)(uVar3 >> 0x18);
    uVar3 = vif_info_tab[iVar7].txq_params[3];
    puVar10[0xd] = (char)uVar3;
    puVar10[0xe] = (char)(uVar3 >> 8);
    puVar10[0xf] = (char)(uVar3 >> 0x10);
    puVar10[0x10] = (char)(uVar3 >> 0x18);
    uVar2 = uVar2 + (ushort)uStack64._1_1_ + 0x13;
  }
  return uVar2;
}



// WARNING: Variable defined which should be unmapped: wme_ie
// WARNING: Could not reconcile some variable overlaps

uint16_t me_build_probe_rsp(uint32_t frame,uint8_t vif_idx)

{
  uint8_t enc_type;
  short sVar1;
  uint16_t uVar2;
  uint32_t uVar3;
  uint32_t uVar4;
  int iVar5;
  uint32_t uVar6;
  undefined3 in_register_0000202d;
  int iVar7;
  scan_chan_tag *psVar8;
  undefined *puVar9;
  mac_rateset *p_rateset;
  uint32_t uStack52;
  undefined2 uStack48;
  undefined uStack46;
  undefined uStack45;
  uint8_t wme_ie [16];
  
  iVar7 = CONCAT31(in_register_0000202d,vif_idx);
  enc_type = vif_info_tab[iVar7].bss_info.sec_type;
  uVar2 = vif_info_tab[iVar7].bss_info.beacon_interval;
  *(undefined *)(frame + 8) = (char)uVar2;
  *(undefined *)(frame + 9) = (char)(uVar2 >> 8);
  uStack52 = frame;
  uVar2 = me_build_capability(vif_idx);
  if (enc_type != '\0') {
    uVar2 = uVar2 | 0x10;
  }
  *(undefined *)(uStack52 + 10) = (char)uVar2;
  *(undefined *)(uStack52 + 0xb) = (char)(uVar2 >> 8);
  uStack52 = uStack52 + 0xc;
  p_rateset = &vif_info_tab[iVar7].bss_info.rate_set;
  uVar3 = me_add_ie_ssid(&uStack52,vif_info_tab[iVar7].bss_info.ssid.length,
                         vif_info_tab[iVar7].bss_info.ssid.array);
  uVar4 = me_add_ie_supp_rates(&uStack52,p_rateset);
  sVar1 = (short)uVar3 + (short)uVar4 + 0xc;
  if (8 < vif_info_tab[iVar7].bss_info.rate_set.length) {
    uVar3 = me_add_ie_ext_supp_rates(&uStack52,p_rateset);
    sVar1 = sVar1 + (short)uVar3;
  }
  psVar8 = vif_info_tab[iVar7].bss_info.chan;
  iVar5 = phy_freq_to_channel(psVar8->band,psVar8->freq);
  uVar3 = me_add_ie_ds(&uStack52,(uint8_t)iVar5);
  uVar4 = me_add_ie_rsn(&uStack52,enc_type);
  uVar6 = me_add_ie_erp(&uStack52,'\0');
  sVar1 = sVar1 + (short)uVar4 + (short)uVar3 + (short)uVar6;
  if ((vif_info_tab[iVar7].bss_info.valid_flags & 2) != 0) {
    uVar3 = me_add_ie_ht_capa(&uStack52);
    uVar4 = me_add_ie_ht_oper(&uStack52,vif_info_tab + iVar7);
    sVar1 = sVar1 + (short)uVar4 + (short)uVar3;
  }
  uVar3 = me_add_ie_wpa(&uStack52,enc_type);
  uVar2 = sVar1 + (short)uVar3;
  if ((vif_info_tab[iVar7].bss_info.valid_flags & 1) != 0) {
    memset(&uStack46,0,0xe);
    uStack48 = 0x7dd;
    uStack45 = 0x50;
    wme_ie._0_2_ = 0x2f2;
    wme_ie[3] = '\x01';
    wme_ie[4] = vif_info_tab[iVar7].bss_info.edca_param.qos_info;
    co_pack8p(uStack52,(uint8_t *)&uStack48,9);
    *(char *)(uStack52 + 1) = *(char *)(uStack52 + 1) + '\x11';
    puVar9 = (undefined *)(uStack52 + 2 + (uint)uStack48._1_1_);
    *puVar9 = 0;
    uVar3 = vif_info_tab[iVar7].txq_params[1];
    puVar9[1] = (char)uVar3;
    puVar9[2] = (char)(uVar3 >> 8);
    puVar9[3] = (char)(uVar3 >> 0x10);
    puVar9[4] = (char)(uVar3 >> 0x18);
    uVar3 = vif_info_tab[iVar7].txq_params[0];
    puVar9[5] = (char)uVar3;
    puVar9[6] = (char)(uVar3 >> 8);
    puVar9[7] = (char)(uVar3 >> 0x10);
    puVar9[8] = (char)(uVar3 >> 0x18);
    uVar3 = vif_info_tab[iVar7].txq_params[2];
    puVar9[9] = (char)uVar3;
    puVar9[10] = (char)(uVar3 >> 8);
    puVar9[0xb] = (char)(uVar3 >> 0x10);
    puVar9[0xc] = (char)(uVar3 >> 0x18);
    uVar3 = vif_info_tab[iVar7].txq_params[3];
    puVar9[0xd] = (char)uVar3;
    puVar9[0xe] = (char)(uVar3 >> 8);
    puVar9[0xf] = (char)(uVar3 >> 0x10);
    puVar9[0x10] = (char)(uVar3 >> 0x18);
    uVar2 = uVar2 + (ushort)uStack48._1_1_ + 0x13;
  }
  return uVar2;
}



// WARNING: Could not reconcile some variable overlaps

uint16_t me_build_associate_rsp
                   (uint32_t frame,uint8_t vif_idx,uint16_t status_code,me_sta_add_req *req)

{
  uint8_t uVar1;
  ushort uVar2;
  uint16_t uVar3;
  uint32_t uVar4;
  uint32_t uVar5;
  undefined3 in_register_0000202d;
  int iVar6;
  undefined2 in_register_00002032;
  undefined *puStack52;
  undefined2 uStack48;
  undefined uStack46;
  undefined uStack45;
  uint8_t wme_ie [16];
  
  iVar6 = CONCAT31(in_register_0000202d,vif_idx);
  uVar1 = vif_info_tab[iVar6].bss_info.sec_type;
  puStack52 = (undefined *)frame;
  uVar3 = me_build_capability(vif_idx);
  if (uVar1 != '\0') {
    uVar3 = uVar3 | 0x10;
  }
  *puStack52 = (char)uVar3;
  puStack52[1] = (char)(uVar3 >> 8);
  uVar3 = 6;
  puStack52[2] = (char)status_code;
  puStack52[3] = (char)(status_code >> 8);
  uVar2 = req->aid;
  puStack52[4] = (char)uVar2;
  puStack52[5] = (byte)((uint)uVar2 >> 8) | 0xc0;
  puStack52 = puStack52 + 6;
  if (CONCAT22(in_register_00002032,status_code) == 0) {
    uVar4 = me_add_ie_supp_rates((uint32_t *)&puStack52,&req->rate_set);
    uVar3 = (short)uVar4 + 6;
    if (8 < (req->rate_set).length) {
      uVar4 = me_add_ie_ext_supp_rates((uint32_t *)&puStack52,&req->rate_set);
      uVar3 = uVar3 + (short)uVar4;
    }
    if ((req->flags & 2) != 0) {
      uVar4 = me_add_ie_ht_capa((uint32_t *)&puStack52);
      uVar5 = me_add_ie_ht_oper((uint32_t *)&puStack52,vif_info_tab + iVar6);
      uVar3 = uVar3 + (short)uVar5 + (short)uVar4;
    }
    if ((req->flags & 1) != 0) {
      memset(&uStack46,0,0xe);
      uStack48 = 0x7dd;
      uStack45 = 0x50;
      wme_ie._0_2_ = 0x2f2;
      wme_ie[3] = '\x01';
      wme_ie[4] = vif_info_tab[iVar6].bss_info.edca_param.qos_info;
      co_pack8p((uint32_t)puStack52,(uint8_t *)&uStack48,9);
      puStack52[1] = puStack52[1] + '\x11';
      puStack52 = puStack52 + (uint)uStack48._1_1_ + 2;
      *puStack52 = 0;
      uVar4 = vif_info_tab[iVar6].txq_params[1];
      puStack52[1] = (char)uVar4;
      puStack52[2] = (char)(uVar4 >> 8);
      puStack52[3] = (char)(uVar4 >> 0x10);
      puStack52[4] = (char)(uVar4 >> 0x18);
      uVar4 = vif_info_tab[iVar6].txq_params[0];
      puStack52[5] = (char)uVar4;
      puStack52[6] = (char)(uVar4 >> 8);
      puStack52[7] = (char)(uVar4 >> 0x10);
      puStack52[8] = (char)(uVar4 >> 0x18);
      uVar4 = vif_info_tab[iVar6].txq_params[2];
      puStack52[9] = (char)uVar4;
      puStack52[10] = (char)(uVar4 >> 8);
      puStack52[0xb] = (char)(uVar4 >> 0x10);
      puStack52[0xc] = (char)(uVar4 >> 0x18);
      uVar4 = vif_info_tab[iVar6].txq_params[3];
      puStack52[0xd] = (char)uVar4;
      puStack52[0xe] = (char)(uVar4 >> 8);
      puStack52[0xf] = (char)(uVar4 >> 0x10);
      puStack52[0x10] = (char)(uVar4 >> 0x18);
      uVar3 = uVar3 + (ushort)uStack48._1_1_ + 0x13;
    }
  }
  return uVar3;
}



int me_rc_set_rate_req_handler
              (ke_msg_id_t msgid,me_rc_set_rate_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  byte bVar1;
  uint16_t fixed_rate_config;
  rc_sta_stats *rc_ss;
  _Bool _Var2;
  undefined3 extraout_var;
  
  bVar1 = param->sta_idx;
  rc_ss = sta_info_tab[bVar1].pol_tbl.sta_stats;
  if (rc_ss == (rc_sta_stats *)0x0) {
    assert_err("rc_ss != NULL","module",0x31d);
  }
  fixed_rate_config = param->fixed_rate_cfg;
  if (fixed_rate_config == 0xffff) {
    rc_ss->fixed_rate_cfg = 0xffff;
    rc_ss->info = rc_ss->info & 0x9f;
    rc_update_bw_nss_max(sta_info_tab[bVar1].staid,rc_ss->bw_max,rc_ss->no_ss);
  }
  else {
    _Var2 = rc_check_fixed_rate_config(rc_ss,fixed_rate_config);
    if (CONCAT31(extraout_var,_Var2) != 0) {
      rc_ss->fixed_rate_cfg = fixed_rate_config;
      rc_ss->info = rc_ss->info & 0x9f | 0x20;
    }
  }
  return 0;
}



int me_rc_stats_req_handler
              (ke_msg_id_t msgid,me_rc_stats_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  rc_sta_stats *rc_ss;
  byte *pbVar1;
  uint32_t uVar2;
  uint uVar3;
  
  pbVar1 = (byte *)ke_msg_alloc(0x140f,src_id,dest_id,0xd0);
  rc_ss = sta_info_tab[param->sta_idx].pol_tbl.sta_stats;
  *pbVar1 = param->sta_idx;
  if (rc_ss == (rc_sta_stats *)0x0) {
    *(undefined2 *)(pbVar1 + 2) = 0;
  }
  else {
    *(uint16_t *)(pbVar1 + 2) = rc_ss->no_samples;
    uVar3 = 0;
    *(uint16_t *)(pbVar1 + 4) = rc_ss->ampdu_len;
    *(uint16_t *)(pbVar1 + 6) = rc_ss->ampdu_packets;
    *(uint32_t *)(pbVar1 + 8) = rc_ss->avg_ampdu_len;
    pbVar1[0xc] = rc_ss->sw_retry_step;
    pbVar1[0xd] = rc_ss->sample_wait;
    memcpy(pbVar1 + 0x10,rc_ss->retry,0x20);
    memcpy(pbVar1 + 0x30,rc_ss->rate_stats,0x78);
    while (uVar3 < rc_ss->no_samples) {
      uVar2 = rc_calc_tp(rc_ss,(uint8_t)uVar3);
      *(uint32_t *)(pbVar1 + (uVar3 + 0x28) * 4 + 8) = uVar2;
      uVar3 = uVar3 + 1 & 0xffff;
    }
  }
  ke_msg_send(pbVar1);
  return 0;
}



int me_traffic_ind_req_handler
              (ke_msg_id_t msgid,me_traffic_ind_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint uVar1;
  uint16_t *puVar2;
  sta_ps_traffic sVar3;
  sta_ps_traffic sVar4;
  
  uVar1 = (uint)param->sta_idx;
  sVar4 = sta_info_tab[uVar1].traffic_avail;
  if (param->uapsd == false) {
    if (param->tx_avail == '\0') {
      sVar4 = sVar4 & ~PS_TRAFFIC_HOST;
    }
    else {
      sVar4 = sVar4 | PS_TRAFFIC_HOST;
    }
    sta_info_tab[uVar1].traffic_avail = sVar4;
  }
  else {
    sVar3 = sVar4 & ~UAPSD_TRAFFIC_HOST;
    if (param->tx_avail != '\0') {
      sVar3 = sVar4 | UAPSD_TRAFFIC_HOST;
    }
    sta_info_tab[uVar1].traffic_avail = sVar3;
    if (sta_info_tab[uVar1].info.uapsd_queues != '\x0f') goto LAB_2301df24;
  }
  puVar2 = (uint16_t *)ke_msg_alloc(0x41,0,5,4);
  *puVar2 = sta_info_tab[uVar1].aid;
  *(uint8_t *)((int)puVar2 + 3) = sta_info_tab[uVar1].inst_nbr;
  *(uint8_t *)(puVar2 + 1) = param->tx_avail;
  ke_msg_send();
LAB_2301df24:
  ke_msg_send_basic(0x140d,src_id,dest_id);
  return 0;
}



int me_sta_del_req_handler
              (ke_msg_id_t msgid,me_sta_del_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint8_t *puVar1;
  undefined *puVar2;
  
  puVar1 = (uint8_t *)ke_msg_alloc(0xc,0,5,1);
  *puVar1 = param->sta_idx;
  ke_msg_send();
  if (param->tdls_sta != false) {
    puVar2 = (undefined *)ke_msg_alloc(0x1413,5,6,2);
    *puVar2 = 0;
    puVar2[1] = sta_info_tab[param->sta_idx].inst_nbr;
    ke_msg_send();
  }
  ke_msg_send_basic(0x140a,src_id,dest_id);
  return 0;
}



int me_set_control_port_req_handler
              (ke_msg_id_t msgid,me_set_control_port_req *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  byte bVar1;
  undefined *puVar2;
  uint8_t uVar3;
  uint uVar4;
  
  uVar4 = (uint)param->sta_idx;
  bVar1 = sta_info_tab[uVar4].inst_nbr;
  uVar3 = (param->control_port_open != false) + '\x01';
  sta_info_tab[uVar4].ctrl_port_state = uVar3;
  if ((vif_info_tab[bVar1].type == '\0') && (uVar3 == '\x02')) {
    puVar2 = (undefined *)ke_msg_alloc(0x1413,5,6,2);
    *puVar2 = 0;
    puVar2[1] = sta_info_tab[uVar4].inst_nbr;
    ke_msg_send();
  }
  ke_msg_send_basic(0x1405,src_id,dest_id);
  return 0;
}



int me_chan_config_req_handler
              (ke_msg_id_t msgid,me_chan_config_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  memcpy(&me_env.chan,param,0xfe);
  ke_msg_send_basic(0x1403,src_id,dest_id);
  return 0;
}



int mm_set_ps_mode_cfm_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  
  kVar1 = ke_state_get(dest_id);
  if (CONCAT22(extraout_var,kVar1) != 1) {
    assert_err("ke_state_get(dest_id) == ME_BUSY","module",699);
  }
  if (me_env.requester_id != 0xff) {
    ke_msg_send_basic(0x1414,me_env.requester_id,dest_id);
  }
  ke_state_set(dest_id,0);
  return 0;
}



int mm_set_idle_cfm_handler(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  
  kVar1 = ke_state_get(dest_id);
  if (CONCAT22(extraout_var,kVar1) != 1) {
    assert_err("ke_state_get(dest_id) == ME_BUSY","module",0x252);
  }
  if (me_env.requester_id != 0xff) {
    ke_msg_send_basic(0x1412,me_env.requester_id,dest_id);
  }
  ke_state_set(dest_id,0);
  return 0;
}



int me_config_req_handler
              (ke_msg_id_t msgid,me_config_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint8_t uVar1;
  undefined *puVar2;
  undefined3 extraout_var;
  
  puVar2 = (undefined *)ke_msg_alloc(0x31,0,5,1);
  me_env.ht_supported = param->ht_supp;
  memcpy(&me_env.ht_cap,param,0x20);
  ke_msg_send_basic(0x1401,src_id,dest_id);
  if (me_env.ht_supported == false) {
    me_env._302_2_ = 0;
  }
  else {
    uVar1 = phy_get_nss();
    me_env._302_2_ =
         CONCAT11((char)(me_env.ht_cap.ht_capa_info >> 1),
                  (char)(CONCAT31(extraout_var,uVar1) + 1 >> 1)) & 0x1ff;
  }
  me_env.tx_lft = param->tx_lft;
  me_env.ps_on = param->ps_on;
  if (me_env.ps_on != false) {
    me_env.requester_id = 0xff;
    *puVar2 = 2;
    ke_msg_send(puVar2);
    ke_state_set(5,1);
  }
  return 0;
}



int me_set_ps_disable_req_handler
              (ke_msg_id_t msgid,me_set_ps_disable_req *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  char *pcVar2;
  
  if (me_env.ps_on != false) {
    kVar1 = ke_state_get(5);
    if (CONCAT22(extraout_var,kVar1) == 1) {
      return 2;
    }
    if (me_env.ps_disable_vifs == 0) {
      if (param->ps_disable != false) goto LAB_2301e26a;
    }
    else {
      if (param->ps_disable == false) {
LAB_2301e26a:
        pcVar2 = (char *)ke_msg_alloc(0x31,0,dest_id,1);
        if (param->ps_disable == false) {
          me_env.ps_disable_vifs = ~(1 << ((uint)param->vif_idx & 0x1f)) & me_env.ps_disable_vifs;
        }
        else {
          me_env.ps_disable_vifs = 1 << ((uint)param->vif_idx & 0x1f) | me_env.ps_disable_vifs;
        }
        me_env.requester_id = src_id;
        *pcVar2 = (me_env.ps_disable_vifs == 0) << 1;
        ke_msg_send();
        ke_state_set(dest_id,1);
        return 0;
      }
      me_env.ps_disable_vifs = 1 << ((uint)param->vif_idx & 0x1f) | me_env.ps_disable_vifs;
    }
  }
  ke_msg_send_basic(0x1414,src_id,dest_id);
  return 0;
}



int me_set_active_req_handler
              (ke_msg_id_t msgid,me_set_active_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  void *pvVar2;
  
  kVar1 = ke_state_get(5);
  if (CONCAT22(extraout_var,kVar1) == 1) {
    return 2;
  }
  if (me_env.active_vifs == 0) {
    if (param->active != false) goto LAB_2301e304;
  }
  else {
    if (param->active == false) {
LAB_2301e304:
      pvVar2 = ke_msg_alloc(0x22,0,dest_id,1);
      if (param->active == false) {
        me_env.active_vifs = ~(1 << ((uint)param->vif_idx & 0x1f)) & me_env.active_vifs;
      }
      else {
        me_env.active_vifs = 1 << ((uint)param->vif_idx & 0x1f) | me_env.active_vifs;
      }
      me_env.requester_id = src_id;
      *(bool *)pvVar2 = me_env.active_vifs == 0;
      ke_msg_send();
      ke_state_set(dest_id,1);
      return 0;
    }
    me_env.active_vifs = 1 << ((uint)param->vif_idx & 0x1f) | me_env.active_vifs;
  }
  ke_msg_send_basic(0x1412,src_id,dest_id);
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

int me_sta_add_req_handler
              (ke_msg_id_t msgid,me_sta_add_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  byte bVar1;
  byte bVar2;
  _Bool _Var3;
  byte *sta_idx;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined *puVar4;
  undefined3 extraout_var_01;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  int iVar8;
  uint8_t uStack81;
  uint8_t hw_sta_idx;
  uint32_t uStack80;
  mm_sta_add_req sta_add_req;
  
  sta_idx = (byte *)ke_msg_alloc(0x1408,src_id,dest_id,3);
  bVar1 = rxu_cntrl_get_pm();
  sta_add_req.mac_addr.array[1]._1_1_ = param->vif_idx;
  uVar7 = (uint)sta_add_req.mac_addr.array[1]._1_1_;
  if ((param->flags & 2) == 0) {
    sta_add_req.mac_addr.array[1]._0_1_ = '\0';
    sta_add_req.paid_gid._0_2_ = 0;
  }
  else {
    uVar5 = (uint)(param->ht_cap).a_mpdu_param;
    sta_add_req.mac_addr.array[1]._0_1_ = '\x01';
    uVar6 = (int)uVar5 >> 2 & 7;
    if (2 < uVar6) {
      sta_add_req.mac_addr.array[1]._0_1_ = (uint8_t)(1 << (uVar6 - 3 & 0x1f));
    }
    sta_add_req.paid_gid._0_2_ = (short)(1 << (uVar5 & 3) + 0xd) - 1;
  }
  sta_add_req.ampdu_size_max_vht = 0;
  memcpy((void *)((int)&sta_add_req.paid_gid + 2),param,6);
  sta_add_req.mac_addr.array[2]._1_1_ = param->rssi;
  sta_add_req._16_4_ = param->tsflo;
  sta_add_req.tsflo = param->tsfhi;
  uStack80 = 0;
  sta_add_req.tsfhi._0_1_ = param->data_rate;
  bVar2 = mm_sta_add((mm_sta_add_req *)&stack0xffffffb0,sta_idx,&uStack81);
  sta_idx[1] = bVar2;
  if (CONCAT31(extraout_var_00,bVar2) != 0) goto LAB_2301e56a;
  uVar5 = (uint)*sta_idx;
  memcpy(&sta_info_tab[uVar5].info,&param->rate_set,0xd);
  if ((param->flags & 1) == 0) {
LAB_2301e46c:
    iVar8 = 0;
  }
  else {
    uVar6 = sta_info_tab[uVar5].info.capa_flags;
    sta_info_tab[uVar5].info.capa_flags = uVar6 | 1;
    if (((param->flags & 2) == 0) || (me_env.ht_supported == false)) goto LAB_2301e46c;
    sta_info_tab[uVar5].info.capa_flags = uVar6 | 3;
    memcpy(&sta_info_tab[uVar5].info.ht_cap,&param->ht_cap,0x20);
    _Var3 = me_set_sta_ht_vht_param(sta_info_tab + uVar5,&vif_info_tab[uVar7].bss_info);
    iVar8 = CONCAT31(extraout_var_01,_Var3);
  }
  sta_info_tab[uVar5].info.uapsd_queues = param->uapsd_queues;
  sta_info_tab[uVar5].info.max_sp_len = param->max_sp_len;
  sta_info_tab[uVar5].aid = param->aid;
  me_init_rate(sta_info_tab + uVar5);
  if (((param->flags & 0x10) != 0) && (bVar2 = param->opmode, -1 < (char)bVar2)) {
    me_sta_bw_nss_max_upd(sta_info_tab[uVar5].staid,bVar2 & 3,bVar2 >> 4);
  }
  if (iVar8 != 0) {
    me_sta_bw_nss_max_upd(sta_info_tab[uVar5].staid,-1,'\0');
  }
  sta_info_tab[uVar5].pol_tbl.upd_field = sta_info_tab[uVar5].pol_tbl.upd_field | 0x10;
  sta_info_tab[uVar5].ctrl_port_state = ((vif_info_tab[uVar7].flags & 1) == 0) + '\x01';
  sta_info_tab[uVar5].ctrl_port_ethertype =
       *(ushort *)(vif_info_tab[uVar7].u + 0x2f0) >> 8 |
       *(ushort *)(vif_info_tab[uVar7].u + 0x2f0) << 8;
  sta_idx[2] = bVar1;
  if (CONCAT31(extraout_var,bVar1) != 0) {
    sta_info_tab[uVar5].ps_state = bVar1;
    if (vif_info_tab[uVar7].u[0x2ee] == 0) {
      uVar5 = (uint)vif_info_tab[uVar7].index + 10 & 0xff;
      puVar4 = (undefined *)ke_msg_alloc(0x49,0xd,0,2);
      sta_info_tab[uVar5].ps_state = '\x01';
      *puVar4 = (char)uVar5;
      puVar4[1] = 1;
      ke_msg_send();
    }
    vif_info_tab[uVar7].u[0x2ee] = vif_info_tab[uVar7].u[0x2ee] + 1;
  }
LAB_2301e56a:
  ke_msg_send(sta_idx);
  return 0;
}



void cfm_raw_send(void *env,uint32_t status)

{
  printf("send complete, status is %08lX\r\n");
  return;
}



int scanu_raw_send_req_handler
              (ke_msg_id_t msgid,scanu_raw_send_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  size_t __n;
  txl_frame_desc_tag *frame;
  tx_hw_desc *ptVar1;
  void *__src;
  
  printf("[FW] pkt address is %p, len is %lu\r\n",param->pkt,param->len);
  scanu_raw_send_cfm('\0',src_id);
  __src = param->pkt;
  __n = param->len;
  frame = txl_frame_get(0,0x100);
  if (frame != (txl_frame_desc_tag *)0x0) {
    memcpy((frame->txdesc).lmac.buffer + 1,__src,__n);
    (frame->txdesc).host.staid = -1;
    (frame->cfm).cfm_func = cfm_raw_send;
    ptVar1 = (frame->txdesc).lmac.hw_desc;
    (frame->txdesc).host.vif_idx = '\0';
    (frame->txdesc).umac.head_len = '\0';
    (frame->txdesc).umac.tail_len = '\0';
    *(txl_frame_desc_tag **)&(frame->cfm).env = frame;
    (ptVar1->thd).field_5 = (ptVar1->thd).field_4 + (__n - 1);
    (ptVar1->thd).frmlen = __n + 4;
    txl_frame_push_force(frame,'\x03');
  }
  return 0;
}



int scanu_join_req_handler
              (ke_msg_id_t msgid,scanu_start_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  vif_info_tab[param->vif_idx].bss_info.valid_flags = 0;
  scanu_env._362_2_ = 1;
  scanu_env.bssid.array._0_4_ = *(undefined4 *)(param->bssid).array;
  scanu_env.bssid.array[2] = (param->bssid).array[2];
  scanu_env.param = param;
  scanu_env.src_id = src_id;
  if ((*(byte *)(param->bssid).array & 1) != 0) {
    assert_err("!MAC_ADDR_GROUP(&param->bssid)","module",0xb6);
  }
  scanu_start();
  return 1;
}



int scanu_start_req_handler
              (ke_msg_id_t msgid,scanu_start_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  undefined2 in_register_0000202a;
  
  scanu_env._362_2_ = 0;
  scanu_env.bssid.array._0_4_ = *(undefined4 *)(param->bssid).array;
  scanu_env.bssid.array[2] = (param->bssid).array[2];
  scanu_env.param = param;
  scanu_env.src_id = src_id;
  scanu_start(CONCAT22(in_register_0000202a,msgid));
  return 1;
}



int rxu_mgt_ind_handler(ke_msg_id_t msgid,rxu_mgt_ind *param,ke_task_id_t dest_id,
                       ke_task_id_t src_id)

{
  int iVar1;
  
  iVar1 = scanu_frame_handler(param);
  return iVar1;
}



int scan_done_ind_handler(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  undefined2 in_register_0000202a;
  
  scanu_env.band = scanu_env.band + '\x01';
  scanu_scan_next(CONCAT22(in_register_0000202a,msgid));
  return 0;
}



int scan_start_cfm_handler
              (ke_msg_id_t msgid,scan_start_cfm *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  if (param->status != '\0') {
    scanu_confirm(param->status);
    return 0;
  }
  return 0;
}



int me_set_ps_disable_cfm_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  undefined2 extraout_var_02;
  
  kVar1 = ke_state_get(6);
  if (((CONCAT22(extraout_var,kVar1) != 4) &&
      (kVar1 = ke_state_get(6), CONCAT22(extraout_var_00,kVar1) != 0)) &&
     (kVar1 = ke_state_get(6), CONCAT22(extraout_var_01,kVar1) != 8)) {
    assert_err(
               "(ke_state_get(TASK_SM) == SM_BSS_PARAM_SETTING) || (ke_state_get(TASK_SM) == SM_IDLE) || (ke_state_get(TASK_SM) == SM_DISCONNECTING)"
               ,"module",0x1db);
  }
  kVar1 = ke_state_get(6);
  if (CONCAT22(extraout_var_02,kVar1) == 4) {
    sm_send_next_bss_param();
  }
  return 0;
}



int mm_bss_param_setting_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  
  kVar1 = ke_state_get(6);
  if (CONCAT22(extraout_var,kVar1) != 4) {
    assert_err("ke_state_get(TASK_SM) == SM_BSS_PARAM_SETTING","module",0x1fa);
  }
  sm_send_next_bss_param();
  return 0;
}



int sm_rsp_timeout_ind_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  
  kVar1 = ke_state_get(6);
  if ((CONCAT22(extraout_var,kVar1) == 5) ||
     (kVar1 = ke_state_get(6), CONCAT22(extraout_var_00,kVar1) == 6)) {
    sm_connect_ind(0xb);
  }
  return 0;
}



int scanu_start_cfm_handler(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  mac_addr *pmStack24;
  mac_addr *bssid;
  scan_chan_tag *chan;
  
  pmStack24 = (mac_addr *)0x0;
  bssid = (mac_addr *)0x0;
  kVar1 = ke_state_get(6);
  if (CONCAT22(extraout_var,kVar1) != 1) {
    assert_err("ke_state_get(TASK_SM) == SM_SCANNING","module",0x10a);
  }
  sm_get_bss_params(&pmStack24,(scan_chan_tag **)&bssid);
  if ((pmStack24 == (mac_addr *)0x0) || ((scan_chan_tag *)bssid == (scan_chan_tag *)0x0)) {
    sm_connect_ind(0xc);
  }
  else {
    sm_join_bss(pmStack24,(scan_chan_tag *)bssid,false);
  }
  return 0;
}



int mm_connection_loss_ind_handler
              (ke_msg_id_t msgid,mm_connection_loss_ind *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  int iVar1;
  ke_state_t kVar2;
  undefined2 extraout_var;
  uint uVar3;
  
  uVar3 = (uint)param->inst_nbr;
  kVar2 = ke_state_get(6);
  iVar1 = 2;
  if (CONCAT22(extraout_var,kVar2) == 0) {
    iVar1 = 0;
    if ((vif_info_tab[uVar3].type == '\0') && (vif_info_tab[uVar3].active != false)) {
      ke_state_set(6,8);
      sm_disconnect_process(vif_info_tab + uVar3,0x10);
    }
  }
  return iVar1;
}



int scanu_join_cfm_handler(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  sm_connect_req *psVar1;
  uint8_t uVar2;
  ke_state_t kVar3;
  undefined2 extraout_var_00;
  undefined3 extraout_var;
  void *pvVar4;
  undefined uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint8_t auStack33 [4];
  uint8_t chan_idx;
  
  psVar1 = sm_env.connect_param;
  kVar3 = ke_state_get(6);
  if (CONCAT22(extraout_var_00,kVar3) != 2) {
    assert_err("ke_state_get(TASK_SM) == SM_JOINING","module",0x134);
  }
  uVar8 = (uint)psVar1->vif_idx;
  if ((int)vif_info_tab[uVar8].bss_info.valid_flags < 0) {
    uVar2 = sm_add_chan_ctx(auStack33);
    if (CONCAT31(extraout_var,uVar2) == 0) {
      pvVar4 = ke_msg_alloc(10,0,6,0x20);
      chan_ctxt_link(psVar1->vif_idx,auStack33[0]);
      *(uint8_t *)((int)pvVar4 + 0x11) = psVar1->vif_idx;
      memcpy((void *)((int)pvVar4 + 10),&vif_info_tab[uVar8].bss_info.bssid,6);
      *(undefined *)((int)pvVar4 + 0x12) = 0;
      if ((vif_info_tab[uVar8].bss_info.valid_flags & 2) != 0) {
        uVar6 = (uint)vif_info_tab[uVar8].bss_info.ht_cap.a_mpdu_param;
        uVar5 = 1;
        uVar7 = (int)uVar6 >> 2 & 7;
        if (2 < uVar7) {
          uVar5 = (undefined)(1 << (uVar7 - 3 & 0x1f));
        }
        *(undefined *)((int)pvVar4 + 0x10) = uVar5;
        *(short *)((int)pvVar4 + 8) = (short)(1 << (uVar6 & 3) + 0xd) + -1;
      }
      *(undefined4 *)((int)pvVar4 + 4) = 0;
      ke_msg_send(pvVar4);
      ke_state_set(6,3);
    }
    else {
      sm_connect_ind(0xd);
    }
    vif_info_tab[uVar8].flags = psVar1->flags;
    if ((psVar1->flags & 4) != 0) {
      vif_info_tab[uVar8].bss_info.valid_flags =
           vif_info_tab[uVar8].bss_info.valid_flags & 0xfffffff9;
    }
  }
  else {
    if (sm_env.join_passive == false) {
      sm_connect_ind(0xe);
    }
    else {
      sm_join_bss(&vif_info_tab[uVar8].bss_info.bssid,vif_info_tab[uVar8].bss_info.chan,true);
    }
  }
  return 0;
}



// WARNING: Variable defined which should be unmapped: chan

int sm_connect_req_handler
              (ke_msg_id_t msgid,sm_connect_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  int iVar1;
  ke_state_t kVar2;
  undefined2 extraout_var;
  undefined *puVar3;
  undefined2 extraout_var_00;
  undefined uVar4;
  uint uVar5;
  mac_addr *pmStack40;
  mac_addr *bssid;
  scan_chan_tag *chan;
  
  pmStack40 = (mac_addr *)0x0;
  bssid = (mac_addr *)0x0;
  uVar5 = (uint)param->vif_idx;
  kVar2 = ke_state_get(6);
  if (CONCAT22(extraout_var,kVar2) == 8) {
    return 2;
  }
  puVar3 = (undefined *)ke_msg_alloc(0x1801,src_id,dest_id,1);
  kVar2 = ke_state_get(6);
  if (CONCAT22(extraout_var_00,kVar2) == 0) {
    if ((vif_info_tab[uVar5].type == '\0') && (vif_info_tab[uVar5].active == false)) {
      if (param->auth_type != '\x02') {
        if (vif_info_tab[uVar5].u[4] != 0xff) {
          assert_err("vif->u.sta.ap_id == INVALID_STA_IDX","module",0x59);
        }
        if (vif_info_tab[uVar5].chan_ctxt != (chan_ctxt_tag *)0x0) {
          assert_err("vif->chan_ctxt == NULL","module",0x5a);
        }
      }
    }
    else {
      if (param->auth_type != '\x02') {
        iVar1 = 0;
        uVar4 = 9;
        goto LAB_2301eb3e;
      }
    }
    if (sm_env.connect_param != (sm_connect_req *)0x0) {
      assert_err("NULL == sm_env.connect_param","module",0x5d);
    }
    sm_env.connect_param = param;
    if (sm_env.connect_ind != (sm_connect_ind *)0x0) {
      assert_err("NULL == sm_env.connect_ind","module",0x61);
    }
    sm_env.connect_ind = (sm_connect_ind *)ke_msg_alloc(0x1802,src_id,dest_id,0x354);
    sm_env.exist_ssid_idx = -1;
    sm_env.ft_over_ds = false;
    printf("connecting using vif_idx %u\r\n",(uint)param->vif_idx);
    if (param->auth_type == '\x02') {
      sm_env.ft_over_ds = true;
      memcpy(&sm_env.ft_old_bssid,&vif_info_tab[param->vif_idx].bssid,6);
      ke_state_set(6,8);
      sm_disconnect_process(vif_info_tab + param->vif_idx,0);
    }
    else {
      if ((param->chan).freq == 0xffff) {
        sm_get_bss_params(&pmStack40,(scan_chan_tag **)&bssid);
      }
      else {
        pmStack40 = &param->bssid;
        bssid = (mac_addr *)&param->chan;
      }
      if ((pmStack40 == (mac_addr *)0x0) || ((scan_chan_tag *)bssid == (scan_chan_tag *)0x0)) {
        sm_scan_bss(pmStack40,(scan_chan_tag *)bssid);
      }
      else {
        sm_join_bss(pmStack40,(scan_chan_tag *)bssid,false);
      }
    }
    iVar1 = 1;
    uVar4 = 0;
  }
  else {
    iVar1 = 0;
    uVar4 = 8;
  }
LAB_2301eb3e:
  *puVar3 = uVar4;
  ke_msg_send(puVar3);
  return iVar1;
}



int rxu_mgt_ind_handler(ke_msg_id_t msgid,rxu_mgt_ind *param,ke_task_id_t dest_id,
                       ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  int iVar2;
  ushort uVar3;
  
  uVar3 = param->framectrl & 0xfc;
  if (uVar3 == 0xb0) {
    kVar1 = ke_state_get(6);
    if (CONCAT22(extraout_var,kVar1) == 5) {
      sm_auth_handler(param);
    }
  }
  else {
    if ((uVar3 == 0x10) || (uVar3 == 0x30)) {
      kVar1 = ke_state_get(6);
      if (CONCAT22(extraout_var_00,kVar1) == 6) {
        sm_assoc_rsp_handler(param);
      }
    }
    else {
      if (((uVar3 == 0xc0) || (uVar3 == 0xa0)) &&
         (kVar1 = ke_state_get(6), CONCAT22(extraout_var_01,kVar1) == 0)) {
        iVar2 = sm_deauth_handler(param);
        return iVar2;
      }
    }
  }
  return 0;
}



int mm_set_vif_state_cfm_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  byte bVar1;
  sm_connect_req *psVar2;
  ke_state_t kVar3;
  undefined2 extraout_var;
  uint8_t *puVar4;
  undefined *puVar5;
  uint8_t uVar6;
  uint uVar7;
  
  kVar3 = ke_state_get(6);
  psVar2 = sm_env.connect_param;
  if (CONCAT22(extraout_var,kVar3) == 7) {
    uVar7 = (uint)(sm_env.connect_param)->vif_idx;
    bVar1 = vif_info_tab[uVar7].u[4];
    puVar4 = (uint8_t *)ke_msg_alloc(0x4b,0,6,6);
    *(_Bool *)(puVar4 + 4) = psVar2->dont_wait_bcmc;
    *(uint16_t *)(puVar4 + 2) = psVar2->listen_interval;
    *puVar4 = psVar2->vif_idx;
    ke_msg_send();
    uVar6 = ((vif_info_tab[uVar7].flags & 1) == 0) + '\x01';
    sta_info_tab[bVar1].ctrl_port_state = uVar6;
    sta_info_tab[bVar1].ctrl_port_ethertype =
         psVar2->ctrl_port_ethertype >> 8 | psVar2->ctrl_port_ethertype << 8;
    if (uVar6 == '\x02') {
      puVar5 = (undefined *)ke_msg_alloc(0x1413,5,6,2);
      *puVar5 = 0;
      puVar5[1] = psVar2->vif_idx;
      ke_msg_send();
    }
    if ((*(uint *)&vif_info_tab[uVar7].bss_info.is_supplicant_enabled & 0x12800) == 0) {
      sm_connect_ind(0);
    }
  }
  return 0;
}



int me_set_active_cfm_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  mac_addr *pmStack24;
  mac_addr *bssid;
  scan_chan_tag *chan;
  
  kVar1 = ke_state_get(6);
  if ((CONCAT22(extraout_var,kVar1) != 4) &&
     (kVar1 = ke_state_get(6), CONCAT22(extraout_var_00,kVar1) != 8)) {
    assert_err(
               "(ke_state_get(TASK_SM) == SM_BSS_PARAM_SETTING) || (ke_state_get(TASK_SM) == SM_DISCONNECTING)"
               ,"module",0x216);
  }
  kVar1 = ke_state_get(6);
  if (CONCAT22(extraout_var_01,kVar1) == 8) {
    if (sm_env.ft_over_ds == false) {
      ke_state_set(6,0);
    }
    else {
      pmStack24 = (mac_addr *)0x0;
      bssid = (mac_addr *)0x0;
      sm_get_bss_params(&pmStack24,(scan_chan_tag **)&bssid);
      sm_join_bss(pmStack24,(scan_chan_tag *)bssid,false);
    }
  }
  else {
    if (sm_env.ft_over_ds == false) {
      sm_auth_send(1,(uint32_t *)0x0);
    }
    else {
      sm_assoc_req_send();
    }
  }
  return 0;
}



int mm_sta_add_cfm_handler
              (ke_msg_id_t msgid,mm_sta_add_cfm *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint uVar1;
  ke_state_t kVar2;
  undefined2 extraout_var;
  uint uVar3;
  uint uVar4;
  
  kVar2 = ke_state_get(6);
  if (CONCAT22(extraout_var,kVar2) != 3) {
    assert_err("ke_state_get(TASK_SM) == SM_STA_ADDING","module",0x19c);
  }
  if (param->status == '\0') {
    uVar4 = (uint)param->sta_idx;
    uVar1 = (uint)sta_info_tab[uVar4].inst_nbr;
    memcpy(&sta_info_tab[uVar4].info,&vif_info_tab[uVar1].bss_info.rate_set,0xd);
    uVar3 = vif_info_tab[uVar1].bss_info.valid_flags;
    if ((uVar3 & 1) != 0) {
      sta_info_tab[uVar4].info.capa_flags = sta_info_tab[uVar4].info.capa_flags | 1;
    }
    if ((uVar3 & 2) != 0) {
      sta_info_tab[uVar4].info.capa_flags = sta_info_tab[uVar4].info.capa_flags | 2;
      memcpy(&sta_info_tab[uVar4].info.ht_cap,&vif_info_tab[uVar1].bss_info,0x20);
      me_set_sta_ht_vht_param(sta_info_tab + uVar4,&vif_info_tab[uVar1].bss_info);
    }
    sm_set_bss_param();
  }
  else {
    sm_connect_ind(0xf);
  }
  return 0;
}



int sm_disconnect_req_handler
              (ke_msg_id_t msgid,sm_disconnect_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  int iVar2;
  
  kVar1 = ke_state_get(6);
  iVar2 = 2;
  if (CONCAT22(extraout_var,kVar1) == 0) {
    sm_disconnect(param->vif_idx,param->reason_code);
    ke_msg_send_basic(0x1804,0xd,6);
    iVar2 = 0;
  }
  return iVar2;
}



int apm_sta_connect_timeout_ind_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint8_t sta_idx;
  sta_info_tag *psVar1;
  TickType_t TVar2;
  
  TVar2 = xTaskGetTickCount();
  psVar1 = sta_info_tab;
  sta_idx = '\0';
  do {
    if ((psVar1->time_last_seen != 0) && (30000 < (int)(TVar2 - psVar1->time_last_seen))) {
      apm_sta_fw_delete(sta_idx);
    }
    sta_idx = sta_idx + '\x01';
    psVar1 = psVar1 + 1;
  } while (sta_idx != '\f');
  ke_timer_set(0x1c0a,7,5000000);
  return 0;
}



int rxu_mgt_ind_handler(ke_msg_id_t msgid,rxu_mgt_ind *param,ke_task_id_t dest_id,
                       ke_task_id_t src_id)

{
  undefined4 uVar1;
  ushort uVar2;
  
  uVar2 = param->framectrl & 0xfc;
  if (uVar2 == 0x40) {
    apm_probe_req_handler();
  }
  else {
    if (uVar2 == 0xb0) {
      apm_auth_handler(param);
    }
    else {
      uVar1 = 0;
      if ((param->framectrl & 0xfc) != 0) {
        if (uVar2 != 0x20) {
          if (uVar2 == 0xc0) {
            apm_deauth_handler(param);
            return 0;
          }
          if (uVar2 == 0xa0) {
            apm_disassoc_handler(param);
            return 0;
          }
          if (uVar2 != 0x80) {
            return 0;
          }
          apm_beacon_handler(param);
          return 0;
        }
        uVar1 = 1;
      }
      apm_assoc_req_handler(uVar1);
    }
  }
  return 0;
}



int apm_sta_add_cfm_handler
              (ke_msg_id_t msgid,me_sta_add_cfm *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  if (uap_conn_info == (cm_ConnectionInfo_t *)0x0) {
    apm_sta_add(param->sta_idx);
  }
  else {
    uap_conn_info->staId = param->sta_idx;
    SendEAPOLMsgUsingBufDesc(uap_conn_info,(BufferDesc_t *)0x0);
  }
  return 0;
}



int apm_sta_del_req_handler
              (ke_msg_id_t msgid,apm_sta_del_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  undefined *puVar1;
  
  puVar1 = (undefined *)ke_msg_alloc(0x1c0c,src_id,dest_id,3);
  if ((vif_info_tab[param->vif_idx].type == '\x02') && (param->sta_idx < 0xd)) {
    apm_sta_remove(param->vif_idx,param->sta_idx);
    *puVar1 = 0;
  }
  else {
    *puVar1 = 0xff;
  }
  ke_msg_send(puVar1);
  return 0;
}


/*
Unable to decompile 'apm_stop_cac_req_handler'
Cause: Exception while decompiling 2301f08a: Decompiler process died

*/


int apm_conf_max_sta_req_handler
              (ke_msg_id_t msgid,apm_conf_max_sta_req *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  apm_env.max_sta_supported = param->max_sta_supported;
  if (0xc < apm_env.max_sta_supported) {
    apm_env.max_sta_supported = 0xc;
  }
  ke_msg_send_basic(0x1c0e,src_id,dest_id);
  return 0;
}


/*
Unable to decompile 'apm_start_cac_req_handler'
Cause: Exception while decompiling 2301f130: Decompiler process died

*/


int me_set_ps_disable_cfm_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  
  kVar1 = ke_state_get(7);
  if ((CONCAT22(extraout_var,kVar1) != 1) &&
     (kVar1 = ke_state_get(7), CONCAT22(extraout_var_00,kVar1) != 0)) {
    assert_err(
               "(ke_state_get(TASK_APM) == APM_BSS_PARAM_SETTING) || (ke_state_get(TASK_APM) == APM_IDLE)"
               ,"module",0xee);
  }
  kVar1 = ke_state_get(7);
  if (CONCAT22(extraout_var_01,kVar1) == 1) {
    apm_send_next_bss_param();
  }
  return 0;
}



int mm_bss_param_setting_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  
  kVar1 = ke_state_get(7);
  if (CONCAT22(extraout_var,kVar1) != 1) {
    assert_err("ke_state_get(TASK_APM) == APM_BSS_PARAM_SETTING","module",0x110);
  }
  apm_send_next_bss_param();
  return 0;
}



int mm_bcn_change_cfm_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  
  kVar1 = ke_state_get(7);
  if (CONCAT22(extraout_var,kVar1) != 2) {
    assert_err("ke_state_get(TASK_APM) == APM_BCN_SETTING","module",0x156);
  }
  apm_start_cfm(0);
  return 0;
}



int apm_stop_req_handler
              (ke_msg_id_t msgid,apm_stop_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint uVar1;
  ke_state_t kVar2;
  undefined2 extraout_var;
  
  uVar1 = (uint)param->vif_idx;
  if ((vif_info_tab[uVar1].type == '\x02') && (vif_info_tab[uVar1].active != false)) {
    kVar2 = ke_state_get(7);
    if (CONCAT22(extraout_var,kVar2) != 0) {
      return 2;
    }
    if (apm_env.apm_emb_enabled != false) {
      apm_env.apm_emb_enabled = false;
    }
    apm_stop(vif_info_tab + uVar1);
    if (uap_conn_info != (cm_ConnectionInfo_t *)0x0) {
      RemoveAPKeyInfo(uap_conn_info);
      cm_DeleteConnection(uap_conn_info);
      uap_conn_info = (cm_ConnectionInfo_t *)0x0;
    }
  }
  ke_msg_send_basic(0x1c03,src_id,dest_id);
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int apm_start_req_handler
              (ke_msg_id_t msgid,apm_start_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint32_t uVar1;
  char "apm_start_req_handler" [22];
  uint8_t uVar2;
  _Bool _Var3;
  ke_state_t kVar4;
  uint16_t uVar5;
  undefined2 extraout_var_01;
  undefined3 extraout_var;
  scan_chan_tag *psVar6;
  undefined3 extraout_var_00;
  int iVar7;
  undefined *puVar8;
  uint uVar9;
  undefined uVar10;
  uint8_t *ssid;
  uint8_t uStack51;
  int8_t iStack50;
  uint8_t auStack49 [2];
  uint8_t chan_idx;
  int8_t pwr;
  uint8_t idx;
  
  printf("[WF] received APM Start %s:%d\r\n","apm_start_req_handler",0x4c);
  uVar9 = (uint)param->vif_idx;
  uVar10 = 4;
  if (vif_info_tab[uVar9].type == '\x02') {
    kVar4 = ke_state_get(7);
    if (CONCAT22(extraout_var_01,kVar4) == 0) {
      if (vif_info_tab[uVar9].active == false) {
        if (vif_info_tab[uVar9].chan_ctxt != (chan_ctxt_tag *)0x0) {
          assert_err("vif->chan_ctxt == NULL","module",0x67);
        }
        apm_env.param = param;
        uVar2 = me_add_chan_ctx(&uStack51,&param->chan,param->center_freq1,param->center_freq2,
                                param->ch_width);
        uVar10 = 1;
        if (CONCAT31(extraout_var,uVar2) == 0) {
          psVar6 = me_freq_to_chan_ptr((param->chan).band,(param->chan).freq);
          vif_info_tab[uVar9].bss_info.chan = psVar6;
          psVar6->tx_power = (param->chan).tx_power;
          vif_info_tab[uVar9].bss_info.center_freq1 = (uint16_t)param->center_freq1;
          vif_info_tab[uVar9].bss_info.center_freq2 = (uint16_t)param->center_freq2;
          uVar2 = param->ch_width;
          if (uVar2 == '\x04') {
            uVar2 = '\x03';
          }
          vif_info_tab[uVar9].bss_info.bw = uVar2;
          uVar2 = param->ch_width;
          vif_info_tab[uVar9].bss_info.power_constraint = '\0';
          vif_info_tab[uVar9].bss_info.phy_bw = uVar2;
          chan_ctxt_link(param->vif_idx,uStack51);
          apm_env.apm_emb_enabled = param->apm_emb_enabled;
          apm_env.hidden_ssid = param->hidden_ssid;
          _Var3 = apm_embedded_enabled(vif_info_tab + uVar9);
          if (CONCAT31(extraout_var_00,_Var3) != 0) {
            me_get_basic_rates(&param->rate_set,(mac_rateset *)param);
            if (param->qos_supported != '\0') {
              vif_info_tab[uVar9].bss_info.valid_flags =
                   vif_info_tab[uVar9].bss_info.valid_flags | 1;
            }
            if (me_env.ht_supported != false) {
              vif_info_tab[uVar9].bss_info.valid_flags =
                   vif_info_tab[uVar9].bss_info.valid_flags | 2;
            }
            vif_info_tab[uVar9].bss_info.beacon_interval = param->bcn_int;
            vif_info_tab[uVar9].bss_info.beacon_period = (ushort)param->beacon_period;
            vif_info_tab[uVar9].bss_info.sec_type = param->ap_sec_type;
            memcpy(&vif_info_tab[uVar9].bss_info.ssid,&param->ssid,0x22);
            vif_info_tab[uVar9].bss_info.ssid.array[vif_info_tab[uVar9].bss_info.ssid.length] = '\0'
            ;
            *(undefined4 *)vif_info_tab[uVar9].bss_info.bssid.array =
                 *(undefined4 *)vif_info_tab[uVar9].mac_addr.array;
            vif_info_tab[uVar9].bss_info.bssid.array[2] = vif_info_tab[uVar9].mac_addr.array[2];
            memcpy(&vif_info_tab[uVar9].bss_info.rate_set,&param->rate_set,0xd);
            vif_info_tab[uVar9].txq_params[0] = _DAT_44b00200;
            vif_info_tab[uVar9].txq_params[1] = _DAT_44b00204;
            vif_info_tab[uVar9].txq_params[2] = _DAT_44b00208;
            uVar1 = _DAT_44b0020c;
            vif_info_tab[uVar9].bss_info.edca_param.qos_info = '\0';
            vif_info_tab[uVar9].txq_params[3] = uVar1;
            *(undefined4 *)&vif_info_tab[uVar9].bss_info.aid_bitmap = 0xffff0000;
            apm_env.bcn_buf = (uint8_t *)ke_malloc(0x14d);
            uVar5 = me_build_beacon((uint32_t)apm_env.bcn_buf,vif_info_tab[uVar9].index,
                                    &param->tim_oft,&param->tim_len,apm_env.hidden_ssid);
            param->bcn_len = uVar5;
            if (param->ap_sec_type == '\0') {
              uap_conn_info = (cm_ConnectionInfo_t *)0x0;
            }
            else {
              uap_conn_info =
                   cm_InitConnection('\x02','\0','\0',
                                     (IEEEtypes_MacAddr_t *)&vif_info_tab[uVar9].bss_info.bssid,
                                     (IEEEtypes_MacAddr_t *)0x0,'\0',(unkbyte0 *)0x0);
              ssid = vif_info_tab[uVar9].bss_info.ssid.array;
              ap_setpsk(uap_conn_info,(CHAR *)ssid,(CHAR *)param->phrase);
              cm_SetComData(uap_conn_info,(char *)ssid);
              uap_conn_info->instNbr = param->vif_idx;
              printf("%s:uap_conn_info->instNbr = %d\r\n",0x23078994,(uint)uap_conn_info->instNbr);
              InitGroupKey(uap_conn_info);
            }
          }
          if ((param->chan).band == '\0') {
            uVar5 = me_legacy_rate_bitfield_build(&vif_info_tab[uVar9].bss_info.rate_set,true);
            if ((uVar5 & 0xf) == 0) {
              vif_info_tab[uVar9].bss_info.high_11b_rate = '\x01';
            }
            else {
              iVar7 = __clzsi2((uint)uVar5 & 0xf);
              vif_info_tab[uVar9].bss_info.high_11b_rate = '\x1f' - (char)iVar7;
            }
          }
          apm_set_bss_param();
          iStack50 = (vif_info_tab[uVar9].bss_info.chan)->tx_power;
          tpc_update_vif_tx_power(vif_info_tab + uVar9,&iStack50,auStack49);
          printf("[WF] return with other handler\r\n");
          return 1;
        }
      }
      else {
        uVar10 = 9;
      }
    }
    else {
      uVar10 = 8;
    }
  }
  printf("[WF] Sending APM CFM %s:%d\r\n",0x23078994,0xcc);
  puVar8 = (undefined *)ke_msg_alloc(0x1c01,src_id,dest_id,4);
  *puVar8 = uVar10;
  puVar8[1] = param->vif_idx;
  ke_msg_send();
  return 0;
}



int me_set_active_cfm_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  
  kVar1 = ke_state_get(7);
  if ((CONCAT22(extraout_var,kVar1) != 1) &&
     (kVar1 = ke_state_get(7), CONCAT22(extraout_var_00,kVar1) != 0)) {
    assert_err(
               "(ke_state_get(TASK_APM) == APM_BSS_PARAM_SETTING) || (ke_state_get(TASK_APM) == APM_IDLE)"
               ,"module",0x12f);
  }
  kVar1 = ke_state_get(7);
  if (CONCAT22(extraout_var_01,kVar1) == 1) {
    if (apm_env.bss_config.first != (co_list_hdr *)0x0) {
      assert_err("co_list_is_empty(&apm_env.bss_config)","module",0x135);
    }
    apm_bcn_set();
  }
  return 0;
}



int hostapd_mgt_ind_handler
              (ke_msg_id_t msgid,rxu_mgt_ind *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ushort uVar1;
  
  uVar1 = param->framectrl & 0xfc;
  if ((uVar1 != 0x40) && (uVar1 != 0xb0)) {
    return 0;
  }
  ke_state_get(10);
  return 0;
}



void dump_cfg_entries(void)

{
  cfg_element_entry *pcVar1;
  char *pcVar2;
  char acStack64 [4];
  char strs [16];
  
  puts("================= CFG TASK =================\r\n");
  pcVar1 = cfg_entrys_mm;
  while (pcVar1 < &_fsymc_info_bloop) {
    printf("entry %p\r\n",pcVar1);
    printf("    task    : %lu\r\n",(blog_level_t *)pcVar1->task);
    printf("    element : %u\r\n",(uint)pcVar1->element);
    printf("    type    : %u\r\n",(uint)pcVar1->type);
    printf("    name    : %s\r\n",pcVar1->name);
    pcVar2 = cfg_api_element_dump(pcVar1->val,*(CFG_ELEMENT_TYPE *)&pcVar1->type,acStack64);
    printf("    type    : %s\r\n",pcVar2);
    printf("    val     : %s\r\n");
    puts("------------------------\r\n");
    pcVar1 = pcVar1 + 1;
  }
  puts("---------------------------------------------\r\n");
  return;
}



// WARNING: Variable defined which should be unmapped: val

int cfg_start_req_handler
              (ke_msg_id_t msgid,cfg_start_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  undefined2 in_register_0000202a;
  undefined *puVar1;
  int iVar2;
  undefined4 uStack20;
  uint32_t val [1];
  
  if (param->ops == 0) {
    iVar2 = utils_tlv_bl_unpack_auto
                      ((uint32_t *)(param + 5),param[4].ops,*(uint16_t *)&param[3].ops,&uStack20);
    printf("unpack ret is %d, result is %lu\r\n",iVar2,uStack20);
    cfg_api_element_set(param[1].ops,param[2].ops,param[3].ops,&uStack20,(void *)0x0);
  }
  else {
    if (2 < param->ops) {
      dump_cfg_entries(CONCAT22(in_register_0000202a,msgid));
    }
  }
  puVar1 = (undefined *)ke_msg_alloc(0x3001,src_id,dest_id,1);
  *puVar1 = 0;
  ke_msg_send();
  return 0;
}



void dbg_init(void)

{
  memset(&dbg_env,0,8);
  dbg_env.filter_module = 0xffffffff;
  dbg_env.filter_severity = 2;
  return;
}



void dbg_test_print(char *fmt,...)

{
  byte bVar1;
  uint uVar2;
  byte *pbVar3;
  va_list args;
  
  if (dbg_env.filter_severity != 0) {
    pbVar3 = (byte *)(fmt + 2);
    do {
      bVar1 = *fmt;
      uVar2 = (uint)bVar1;
      if (-1 < (char)bVar1) {
        return;
      }
      if (bVar1 < 0x88) {
        if ((~dbg_env.filter_module >> (uVar2 - 0x80 & 0x1f) & 1) != 0) {
          return;
        }
      }
      else {
        if (5 < (uVar2 + 0x66 & 0xff)) {
          assert_err("DBG_SEV_MIN <= prefix && prefix < DBG_SEV_MAX","module",0x297);
        }
        if (dbg_env.filter_severity <= uVar2 - 0x9a) {
          return;
        }
      }
      fmt = (char *)((byte *)fmt + 1);
    } while (pbVar3 != (byte *)fmt);
  }
  return;
}



int dbg_get_sys_stat_req_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  undefined4 *puVar1;
  
  puVar1 = (undefined4 *)ke_msg_alloc(0x40a,src_id,dest_id,0xc);
  *puVar1 = 0;
  puVar1[1] = 0;
  puVar1[2] = 0;
  ke_msg_send();
  return 0;
}



int dbg_mem_write_req_handler
              (ke_msg_id_t msgid,dbg_mem_write_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint32_t **ppuVar1;
  uint32_t **ppuVar2;
  
  ppuVar1 = (uint32_t **)ke_msg_alloc(0x403,src_id,dest_id,8);
  *(uint32_t *)param->memaddr = param->memdata;
  ppuVar2 = (uint32_t **)param->memaddr;
  *(uint32_t ***)ppuVar1 = ppuVar2;
  ppuVar1[1] = *ppuVar2;
  ke_msg_send();
  return 0;
}



int dbg_mem_read_req_handler
              (ke_msg_id_t msgid,dbg_mem_read_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint32_t *puVar1;
  
  puVar1 = (uint32_t *)ke_msg_alloc(0x401,src_id,dest_id,8);
  puVar1[1] = *(uint32_t *)param->memaddr;
  *puVar1 = param->memaddr;
  ke_msg_send();
  return 0;
}



int dbg_set_sev_filter_req_handler
              (ke_msg_id_t msgid,dbg_set_sev_filter_req *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  dbg_env.filter_severity = param->sev_filter;
  ke_msg_send_basic(0x407,src_id,dest_id);
  return 0;
}



int dbg_set_mod_filter_req_handler
              (ke_msg_id_t msgid,dbg_set_mod_filter_req *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  dbg_env.filter_module = param->mod_filter;
  ke_msg_send_basic(0x405,src_id,dest_id);
  return 0;
}



// WARNING: Type propagation algorithm not settling

co_list_hdr *
ke_queue_extract(co_list *queue,anon_subr__Bool_co_list_hdr_ptr_uint32_t *func,uint32_t arg)

{
  co_list_hdr cVar1;
  co_list_hdr cVar2;
  _Bool _Var3;
  undefined3 extraout_var;
  co_list_hdr cVar4;
  
  cVar4 = (co_list_hdr)queue->first;
  cVar1 = (co_list_hdr)0x0;
  do {
    cVar2 = cVar1;
    cVar1 = cVar4;
    if (cVar1 == (co_list_hdr)0x0) {
      return (co_list_hdr *)0;
    }
    _Var3 = (*func)((co_list_hdr *)cVar1,arg);
    cVar4 = *(co_list_hdr *)cVar1;
  } while (CONCAT31(extraout_var,_Var3) == 0);
  if (cVar2 == (co_list_hdr)0x0) {
    *(co_list_hdr *)&queue->first = cVar4;
  }
  else {
    *(co_list_hdr *)cVar2 = cVar4;
  }
  if (*(int *)cVar1 == 0) {
    *(co_list_hdr *)&queue->last = cVar2;
  }
  else {
    *(undefined4 *)cVar1 = 0;
  }
  return (co_list_hdr *)cVar1;
}



void bl_aes_128(UINT8 *key,UINT8 *input,UINT8 *output)

{
  BL_AesEncrypt(key,'\x02',input,output);
  return;
}



void xor_128(UINT8 *a,UINT8 *b,UINT8 *out)

{
  byte *pbVar1;
  int iVar2;
  byte *pbVar3;
  byte *pbVar4;
  
  iVar2 = 0;
  do {
    pbVar1 = a + iVar2;
    pbVar4 = b + iVar2;
    pbVar3 = out + iVar2;
    iVar2 = iVar2 + 1;
    *pbVar3 = *pbVar1 ^ *pbVar4;
  } while (iVar2 != 0x10);
  return;
}



void leftshift_onebit(UINT8 *input,UINT8 *output)

{
  byte *pbVar1;
  int iVar2;
  byte bVar3;
  byte *pbVar4;
  
  bVar3 = 0;
  iVar2 = 0xf;
  do {
    pbVar1 = input + iVar2;
    pbVar4 = output + iVar2;
    iVar2 = iVar2 + -1;
    *pbVar4 = bVar3 | *pbVar1 << 1;
    bVar3 = *pbVar1 >> 7;
  } while (iVar2 != -1);
  return;
}



// WARNING: Variable defined which should be unmapped: tmp

void generate_subkey(UINT8 *key,UINT8 *K1,UINT8 *K2)

{
  UINT8 local_40 [4];
  UINT8 L [16];
  UINT8 Z [16];
  UINT8 tmp [16];
  
  memset(L + 0xc,0,0x10);
  bl_aes_128(key,L + 0xc,local_40);
  if ((char)local_40[0] < '\0') {
    leftshift_onebit(local_40,Z + 0xc);
    xor_128(Z + 0xc,"",K1);
  }
  else {
    leftshift_onebit(local_40,K1);
  }
  if ((char)*K1 < '\0') {
    leftshift_onebit(K1,Z + 0xc);
    xor_128(Z + 0xc,"",K2);
  }
  else {
    leftshift_onebit(K1,K2);
  }
  return;
}



void padding(UINT8 *lastb,UINT8 *pad,int length)

{
  int iVar1;
  
  iVar1 = 0;
  do {
    if (iVar1 < length) {
      pad[iVar1] = lastb[iVar1];
    }
    else {
      if (length == iVar1) {
        pad[length] = -0x80;
      }
      else {
        pad[iVar1] = '\0';
      }
    }
    iVar1 = iVar1 + 1;
  } while (iVar1 != 0x10);
  return;
}



void bl_aes_cmac(UINT8 *key,UINT8 *input,int length,UINT8 *mac)

{
  int iVar1;
  int iVar2;
  UINT8 *a;
  UINT8 *pUVar3;
  UINT8 local_80 [4];
  UINT8 X [16];
  UINT8 Y [16];
  UINT8 M_last [16];
  UINT8 padded [16];
  UINT8 K1 [16];
  UINT8 K2 [16];
  
  generate_subkey(key,padded + 0xc,K1 + 0xc);
  iVar1 = (length + 0xf) / 0x10;
  if (iVar1 == 0) {
    iVar1 = 1;
  }
  else {
    if ((length & 0xfU) == 0) {
      pUVar3 = padded;
      a = input + (iVar1 + -1) * 0x10;
      goto LAB_2301fbde;
    }
  }
  padding(input + (iVar1 + -1) * 0x10,M_last + 0xc,length % 0x10);
  pUVar3 = K1;
  a = M_last + 0xc;
LAB_2301fbde:
  xor_128(a,pUVar3 + 0xc,Y + 0xc);
  memset(local_80,0,0x10);
  iVar2 = 0;
  while (iVar2 < iVar1 + -1) {
    xor_128(local_80,input + iVar2 * 0x10,X + 0xc);
    bl_aes_128(key,X + 0xc,local_80);
    iVar2 = iVar2 + 1;
  }
  xor_128(local_80,Y + 0xc,X + 0xc);
  bl_aes_128(key,X + 0xc,local_80);
  iVar1 = 0;
  do {
    pUVar3 = local_80 + iVar1;
    a = mac + iVar1;
    iVar1 = iVar1 + 1;
    *a = *pUVar3;
  } while (iVar1 != 0x10);
  return;
}



int BL_AES_MEMCMP(UINT8 *dst,UINT8 *src,int len)

{
  int iVar1;
  int iVar2;
  
  iVar2 = 0;
  iVar1 = len;
  while (len != iVar2) {
    if (dst[iVar2] == src[iVar2]) {
      iVar1 = iVar1 + -1;
    }
    iVar2 = iVar2 + 1;
  }
  return -(uint)(iVar1 != 0);
}



void BL_AES_MEMSET(UINT8 *dst,UINT8 val,int size)

{
  UINT8 *pUVar1;
  
  pUVar1 = dst;
  while (pUVar1 != dst + size) {
    *pUVar1 = val;
    pUVar1 = pUVar1 + 1;
  }
  return;
}



void BL_AES_MEMCPY(UINT8 *dst,UINT8 *src,int size)

{
  UINT8 *pUVar1;
  UINT8 *pUVar2;
  int iVar3;
  
  if (dst < src) {
    iVar3 = 0;
    while (iVar3 != size) {
      pUVar1 = src + iVar3;
      pUVar2 = dst + iVar3;
      iVar3 = iVar3 + 1;
      *pUVar2 = *pUVar1;
    }
    return;
  }
  while (size = size + -1, size != -1) {
    dst[size] = src[size];
  }
  return;
}



int BL_AesEncrypt(UINT8 *kek,UINT8 kekLen,UINT8 *data,UINT8 *ret)

{
  undefined3 in_register_0000202d;
  undefined auStack416 [4];
  UINT8 pBuf [400];
  
  rijndael_set_key((rijndael_ctx *)auStack416,kek,CONCAT31(in_register_0000202d,kekLen) << 6,1);
  rijndael_encrypt((rijndael_ctx *)auStack416,data,ret);
  return 0;
}



int BL_AesWrap(UINT8 *kek,UINT8 kekLen,UINT32 n,UINT8 *plain,UINT8 *keyIv,UINT8 *cipher)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  UINT8 aUStack72 [4];
  UINT8 a [8];
  UINT8 b [16];
  
  if (n != 0) {
    BL_AES_MEMSET(a + 4,'\0',0x10);
    if (keyIv == (UINT8 *)0x0) {
      keyIv = BL_DEFAULT_IV;
    }
    BL_AES_MEMCPY(aUStack72,keyIv,8);
    BL_AES_MEMCPY(cipher + 8,plain,n << 3);
    uVar2 = 0;
    iVar4 = 6;
    do {
      iVar1 = 1;
      while (iVar3 = iVar1 * 8, iVar1 != n + 1) {
        BL_AES_MEMCPY(a + 4,aUStack72,8);
        BL_AES_MEMCPY(b + 4,cipher + iVar3,8);
        BL_AesEncrypt(kek,kekLen,a + 4,a + 4);
        BL_AES_MEMCPY(aUStack72,a + 4,8);
        a[3] = (char)uVar2 + (char)iVar1 ^ a[3];
        iVar1 = iVar1 + 1;
        BL_AES_MEMCPY(cipher + iVar3,b + 4,8);
      }
      iVar4 = iVar4 + -1;
      uVar2 = uVar2 + (n & 0xff) & 0xff;
    } while (iVar4 != 0);
    BL_AES_MEMCPY(cipher,aUStack72,8);
    return 0;
  }
  return -1;
}



int BL_AesUnWrap(UINT8 *kek,UINT8 kekLen,UINT32 n,UINT8 *cipher,UINT8 *keyIv,UINT8 *plain)

{
  uint uVar1;
  undefined3 in_register_0000202d;
  UINT32 UVar2;
  UINT8 *src;
  int iVar3;
  UINT8 aUStack472 [4];
  UINT8 a [8];
  UINT8 b [16];
  UINT8 pBuf [400];
  
  if (n != 0) {
    BL_AES_MEMSET(aUStack472,'\0',8);
    BL_AES_MEMSET(a + 4,'\0',0x10);
    BL_AES_MEMCPY(aUStack472,cipher,8);
    uVar1 = (n & 0xff) * 5;
    BL_AES_MEMCPY(plain,cipher + 8,n * 8);
    rijndael_set_key((rijndael_ctx *)(b + 0xc),kek,CONCAT31(in_register_0000202d,kekLen) << 6,0);
    iVar3 = 6;
    do {
      UVar2 = n;
      src = plain + n * 8 + -8;
      while (0 < (int)UVar2) {
        BL_AES_MEMCPY(a + 4,aUStack472,8);
        b[3] = (char)(uVar1 & 0xff) + (char)UVar2 ^ b[3];
        BL_AES_MEMCPY(b + 4,src,8);
        rijndael_decrypt((rijndael_ctx *)(b + 0xc),a + 4,a + 4);
        BL_AES_MEMCPY(aUStack472,a + 4,8);
        BL_AES_MEMCPY(src,b + 4,8);
        src = src + -8;
        UVar2 = UVar2 - 1;
      }
      uVar1 = (uVar1 & 0xff) - (n & 0xff);
      iVar3 = iVar3 + -1;
    } while (iVar3 != 0);
    if (keyIv == (UINT8 *)0x0) {
      keyIv = BL_DEFAULT_IV;
    }
    iVar3 = BL_AES_MEMCMP(keyIv,aUStack472,8);
    return -(uint)(iVar3 != 0);
  }
  return -1;
}



// WARNING: Variable defined which should be unmapped: pBuf

void Bl_hmac_md5(UINT8 *text_data,int text_len,UINT8 *key,int key_len,void *digest)

{
  ulong *puVar1;
  Bl_MD5_CTX *pBVar2;
  Bl_MD5_CTX *context;
  Bl_MD5_CTX *context_00;
  undefined auStack584 [4];
  Bl_MD5_CTX tctx;
  uchar pBuf [400];
  
  if (0x40 < key_len) {
    wpa_MD5Init((Bl_MD5_CTX *)auStack584);
    wpa_MD5Update((Bl_MD5_CTX *)auStack584,key,key_len);
    wpa_MD5Final(pBuf + 0x94,(Bl_MD5_CTX *)auStack584);
    key_len = 0x10;
    key = pBuf + 0x94;
  }
  memset(tctx.buffer + 0x3c,0,0x40);
  memcpy(tctx.buffer + 0x3c,key,key_len);
  context_00 = (Bl_MD5_CTX *)(pBuf + 0x3c);
  pBVar2 = (Bl_MD5_CTX *)(tctx.buffer + 0x3c);
  do {
    puVar1 = pBVar2->state;
    pBVar2->state[0] = pBVar2->state[0] ^ 0x36363636;
    pBVar2 = (Bl_MD5_CTX *)(puVar1 + 1);
  } while ((Bl_MD5_CTX *)(puVar1 + 1) != context_00);
  wpa_MD5Init(context_00);
  wpa_MD5Update(context_00,tctx.buffer + 0x3c,0x40);
  wpa_MD5Update(context_00,text_data,text_len);
  wpa_MD5Final((uchar *)digest,context_00);
  memset(tctx.buffer + 0x3c,0,0x40);
  memcpy(tctx.buffer + 0x3c,key,key_len);
  pBVar2 = (Bl_MD5_CTX *)(tctx.buffer + 0x3c);
  do {
    context = (Bl_MD5_CTX *)(pBVar2->state + 1);
    pBVar2->state[0] = pBVar2->state[0] ^ 0x5c5c5c5c;
    pBVar2 = context;
  } while (context != context_00);
  wpa_MD5Init(context);
  wpa_MD5Update(context,tctx.buffer + 0x3c,0x40);
  wpa_MD5Update(context,(UINT8 *)digest,0x10);
  wpa_MD5Final((uchar *)digest,context);
  return;
}



void Bl_hmac_sha1(uchar **ppText,int *pTextLen,int textNum,uchar *key,int key_len,uchar *output,
                 int outputLen)

{
  uint *puVar1;
  uint *__src;
  uchar **ppuVar2;
  int iVar3;
  uint *Message_Digest;
  uint local_1c0;
  uchar pBuf [400];
  
  if (0x40 < key_len) {
    Bl_SHA1Init((Bl_SHA1_CTX *)(pBuf + 0x50));
    Bl_SHA1Update((Bl_SHA1_CTX *)(pBuf + 0x50),key,key_len);
    Bl_SHA1Final((Bl_SHA1_CTX *)(pBuf + 0x50),key);
    key_len = 0x14;
  }
  memset(&local_1c0,0,0x40);
  memcpy(&local_1c0,key,key_len);
  Message_Digest = (uint *)(pBuf + 0x3c);
  puVar1 = &local_1c0;
  do {
    __src = puVar1 + 2;
    *puVar1 = *puVar1 ^ 0x36363636;
    puVar1[1] = puVar1[1] ^ 0x36363636;
    puVar1 = __src;
  } while (__src != Message_Digest);
  Bl_SHA1Init((Bl_SHA1_CTX *)(pBuf + 0x50));
  Bl_SHA1Update((Bl_SHA1_CTX *)(pBuf + 0x50),(UINT8 *)&local_1c0,0x40);
  iVar3 = 0;
  while (iVar3 < textNum) {
    puVar1 = (uint *)(pTextLen + iVar3);
    ppuVar2 = ppText + iVar3;
    iVar3 = iVar3 + 1;
    Bl_SHA1Update((Bl_SHA1_CTX *)(pBuf + 0x50),*ppuVar2,*puVar1);
  }
  Bl_SHA1Final((Bl_SHA1_CTX *)(pBuf + 0x50),(UINT8 *)Message_Digest);
  memset(&local_1c0,0,0x40);
  memcpy(&local_1c0,key,key_len);
  puVar1 = &local_1c0;
  do {
    __src = puVar1 + 2;
    *puVar1 = *puVar1 ^ 0x5c5c5c5c;
    puVar1[1] = puVar1[1] ^ 0x5c5c5c5c;
    puVar1 = __src;
  } while (__src != Message_Digest);
  Bl_SHA1Init((Bl_SHA1_CTX *)(pBuf + 0x50));
  Bl_SHA1Update((Bl_SHA1_CTX *)(pBuf + 0x50),(UINT8 *)&local_1c0,0x40);
  Bl_SHA1Update((Bl_SHA1_CTX *)(pBuf + 0x50),(UINT8 *)__src,0x14);
  Bl_SHA1Final((Bl_SHA1_CTX *)(pBuf + 0x50),(UINT8 *)__src);
  memcpy(output,__src,outputLen);
  return;
}



void Bl_PRF(uchar *key,int key_len,uchar *prefix,int prefix_len,uchar *data,int data_len,
           uchar *output,int len)

{
  char cVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int local_b0;
  int total_len;
  uchar *pText;
  UINT8 prf_input [120];
  
  total_len = (int)&pText;
  memset(&pText,0,0x78);
  if (prefix == (uchar *)0x0) {
    memcpy(&pText,data,data_len);
    local_b0 = data_len;
  }
  else {
    memcpy(&pText,prefix,prefix_len);
    local_b0 = prefix_len + 1 + data_len;
    *(undefined *)((int)&pText + prefix_len) = 0;
    memcpy((void *)((int)&pText + prefix_len + 1),data,data_len);
  }
  *(undefined *)((int)&pText + local_b0) = 0;
  iVar4 = 0;
  iVar3 = 0;
  local_b0 = local_b0 + 1;
  while( true ) {
    iVar2 = (iVar3 * -0x14 + len) * 0x1000000;
    cVar1 = (char)((uint)iVar2 >> 0x18);
    if ((len + 0x13) / 0x14 <= iVar3) break;
    if (0x14 < iVar2 >> 0x18) {
      cVar1 = '\x14';
    }
    Bl_hmac_sha1((uchar **)&total_len,&local_b0,1,key,key_len,output + iVar4,(int)cVar1);
    iVar4 = iVar4 + (int)cVar1;
    iVar3 = iVar3 + 1;
    *(char *)((int)&total_len + local_b0 + 3) = *(char *)((int)&total_len + local_b0 + 3) + '\x01';
  }
  return;
}



void wpa_MD5Transform(UINT32 *state,ulong *block)

{
  ulong uVar1;
  ulong uVar2;
  ulong uVar3;
  ulong uVar4;
  ulong uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  ulong uVar13;
  ulong uVar14;
  ulong uVar15;
  ulong uVar16;
  ulong uVar17;
  ulong uVar18;
  ulong uVar19;
  uint uVar20;
  uint uVar21;
  ulong uVar22;
  ulong uVar23;
  ulong uVar24;
  ulong uVar25;
  
  uVar19 = *block;
  uVar20 = state[2];
  uVar21 = state[3];
  uVar12 = state[1];
  uVar5 = block[1];
  uVar8 = ((uVar20 ^ uVar21) & uVar12 ^ uVar21) + *state + uVar19 + 0xd76aa478;
  uVar9 = (uVar8 >> 0x19 | uVar8 * 0x80) + uVar12;
  uVar22 = block[2];
  uVar8 = ((uVar12 ^ uVar20) & uVar9 ^ uVar20) + uVar5 + 0xe8c7b756 + uVar21;
  uVar6 = (uVar8 >> 0x14 | uVar8 * 0x1000) + uVar9;
  uVar8 = ((uVar12 ^ uVar9) & uVar6 ^ uVar12) + uVar22 + 0x242070db + uVar20;
  uVar14 = block[3];
  uVar8 = (uVar8 * 0x20000 | uVar8 >> 0xf) + uVar6;
  uVar7 = ((uVar9 ^ uVar6) & uVar8 ^ uVar9) + uVar14 + 0xc1bdceee + uVar12;
  uVar24 = block[4];
  uVar7 = (uVar7 * 0x400000 | uVar7 >> 10) + uVar8;
  uVar9 = ((uVar6 ^ uVar8) & uVar7 ^ uVar6) + uVar24 + 0xf57c0faf + uVar9;
  uVar16 = block[5];
  uVar9 = (uVar9 >> 0x19 | uVar9 * 0x80) + uVar7;
  uVar6 = ((uVar8 ^ uVar7) & uVar9 ^ uVar8) + uVar16 + 0x4787c62a + uVar6;
  uVar1 = block[6];
  uVar6 = (uVar6 >> 0x14 | uVar6 * 0x1000) + uVar9;
  uVar8 = ((uVar7 ^ uVar9) & uVar6 ^ uVar7) + uVar1 + 0xa8304613 + uVar8;
  uVar18 = block[7];
  uVar8 = (uVar8 * 0x20000 | uVar8 >> 0xf) + uVar6;
  uVar7 = ((uVar9 ^ uVar6) & uVar8 ^ uVar9) + uVar18 + 0xfd469501 + uVar7;
  uVar4 = block[8];
  uVar7 = (uVar7 * 0x400000 | uVar7 >> 10) + uVar8;
  uVar9 = ((uVar6 ^ uVar8) & uVar7 ^ uVar6) + uVar4 + 0x698098d8 + uVar9;
  uVar2 = block[9];
  uVar9 = (uVar9 >> 0x19 | uVar9 * 0x80) + uVar7;
  uVar6 = ((uVar8 ^ uVar7) & uVar9 ^ uVar8) + uVar2 + 0x8b44f7af + uVar6;
  uVar13 = block[10];
  uVar6 = (uVar6 >> 0x14 | uVar6 * 0x1000) + uVar9;
  uVar8 = ((uVar7 ^ uVar9) & uVar6 ^ uVar7) + (uVar13 - 0xa44f) + uVar8;
  uVar23 = block[0xb];
  uVar8 = (uVar8 * 0x20000 | uVar8 >> 0xf) + uVar6;
  uVar7 = ((uVar9 ^ uVar6) & uVar8 ^ uVar9) + uVar23 + 0x895cd7be + uVar7;
  uVar15 = block[0xc];
  uVar7 = (uVar7 * 0x400000 | uVar7 >> 10) + uVar8;
  uVar9 = ((uVar6 ^ uVar8) & uVar7 ^ uVar6) + uVar15 + 0x6b901122 + uVar9;
  uVar25 = block[0xd];
  uVar9 = (uVar9 >> 0x19 | uVar9 * 0x80) + uVar7;
  uVar6 = ((uVar8 ^ uVar7) & uVar9 ^ uVar8) + uVar25 + 0xfd987193 + uVar6;
  uVar17 = block[0xe];
  uVar6 = (uVar6 >> 0x14 | uVar6 * 0x1000) + uVar9;
  uVar8 = ((uVar7 ^ uVar9) & uVar6 ^ uVar7) + uVar17 + 0xa679438e + uVar8;
  uVar3 = block[0xf];
  uVar8 = (uVar8 * 0x20000 | uVar8 >> 0xf) + uVar6;
  uVar7 = ((uVar9 ^ uVar6) & uVar8 ^ uVar9) + uVar3 + 0x49b40821 + uVar7;
  uVar7 = (uVar7 * 0x400000 | uVar7 >> 10) + uVar8;
  uVar9 = ((uVar8 ^ uVar7) & uVar6 ^ uVar8) + uVar5 + 0xf61e2562 + uVar9;
  uVar9 = (uVar9 >> 0x1b | uVar9 * 0x20) + uVar7;
  uVar6 = ((uVar7 ^ uVar9) & uVar8 ^ uVar7) + uVar1 + 0xc040b340 + uVar6;
  uVar6 = (uVar6 >> 0x17 | uVar6 * 0x200) + uVar9;
  uVar8 = ((uVar9 ^ uVar6) & uVar7 ^ uVar9) + uVar23 + 0x265e5a51 + uVar8;
  uVar8 = (uVar8 >> 0x12 | uVar8 * 0x4000) + uVar6;
  uVar7 = ((uVar6 ^ uVar8) & uVar9 ^ uVar6) + uVar19 + 0xe9b6c7aa + uVar7;
  uVar7 = (uVar7 * 0x100000 | uVar7 >> 0xc) + uVar8;
  uVar9 = ((uVar8 ^ uVar7) & uVar6 ^ uVar8) + uVar16 + 0xd62f105d + uVar9;
  uVar9 = (uVar9 >> 0x1b | uVar9 * 0x20) + uVar7;
  uVar6 = ((uVar7 ^ uVar9) & uVar8 ^ uVar7) + uVar13 + 0x2441453 + uVar6;
  uVar6 = (uVar6 >> 0x17 | uVar6 * 0x200) + uVar9;
  uVar8 = ((uVar9 ^ uVar6) & uVar7 ^ uVar9) + uVar3 + 0xd8a1e681 + uVar8;
  uVar8 = (uVar8 >> 0x12 | uVar8 * 0x4000) + uVar6;
  uVar7 = ((uVar6 ^ uVar8) & uVar9 ^ uVar6) + uVar24 + 0xe7d3fbc8 + uVar7;
  uVar7 = (uVar7 * 0x100000 | uVar7 >> 0xc) + uVar8;
  uVar9 = ((uVar8 ^ uVar7) & uVar6 ^ uVar8) + uVar2 + 0x21e1cde6 + uVar9;
  uVar9 = (uVar9 >> 0x1b | uVar9 * 0x20) + uVar7;
  uVar6 = ((uVar7 ^ uVar9) & uVar8 ^ uVar7) + uVar17 + 0xc33707d6 + uVar6;
  uVar6 = (uVar6 >> 0x17 | uVar6 * 0x200) + uVar9;
  uVar8 = ((uVar9 ^ uVar6) & uVar7 ^ uVar9) + uVar14 + 0xf4d50d87 + uVar8;
  uVar8 = (uVar8 >> 0x12 | uVar8 * 0x4000) + uVar6;
  uVar7 = ((uVar6 ^ uVar8) & uVar9 ^ uVar6) + uVar4 + 0x455a14ed + uVar7;
  uVar7 = (uVar7 * 0x100000 | uVar7 >> 0xc) + uVar8;
  uVar9 = ((uVar8 ^ uVar7) & uVar6 ^ uVar8) + uVar25 + 0xa9e3e905 + uVar9;
  uVar9 = (uVar9 >> 0x1b | uVar9 * 0x20) + uVar7;
  uVar6 = ((uVar7 ^ uVar9) & uVar8 ^ uVar7) + uVar22 + 0xfcefa3f8 + uVar6;
  uVar6 = (uVar6 >> 0x17 | uVar6 * 0x200) + uVar9;
  uVar8 = ((uVar9 ^ uVar6) & uVar7 ^ uVar9) + uVar8 + uVar18 + 0x676f02d9;
  uVar8 = (uVar8 >> 0x12 | uVar8 * 0x4000) + uVar6;
  uVar7 = (uVar9 & (uVar6 ^ uVar8) ^ uVar6) + uVar15 + 0x8d2a4c8a + uVar7;
  uVar7 = (uVar7 * 0x100000 | uVar7 >> 0xc) + uVar8;
  uVar9 = uVar9 + (uVar16 - 0x5c6be) + (uVar6 ^ uVar8 ^ uVar7);
  uVar10 = (uVar9 >> 0x1c | uVar9 * 0x10) + uVar7;
  uVar6 = (uVar8 ^ uVar7 ^ uVar10) + uVar4 + 0x8771f681 + uVar6;
  uVar6 = (uVar6 >> 0x15 | uVar6 * 0x800) + uVar10;
  uVar8 = (uVar7 ^ uVar10 ^ uVar6) + uVar23 + 0x6d9d6122 + uVar8;
  uVar8 = (uVar8 >> 0x10 | uVar8 * 0x10000) + uVar6;
  uVar7 = (uVar10 ^ uVar6 ^ uVar8) + uVar17 + 0xfde5380c + uVar7;
  uVar9 = (uVar7 * 0x800000 | uVar7 >> 9) + uVar8;
  uVar7 = (uVar6 ^ uVar8 ^ uVar9) + uVar5 + 0xa4beea44 + uVar10;
  uVar10 = (uVar7 >> 0x1c | uVar7 * 0x10) + uVar9;
  uVar6 = (uVar8 ^ uVar9 ^ uVar10) + uVar6 + uVar24 + 0x4bdecfa9;
  uVar6 = (uVar6 >> 0x15 | uVar6 * 0x800) + uVar10;
  uVar8 = (uVar9 ^ uVar10 ^ uVar6) + uVar8 + uVar18 + 0xf6bb4b60;
  uVar7 = (uVar8 >> 0x10 | uVar8 * 0x10000) + uVar6;
  uVar8 = (uVar10 ^ uVar6 ^ uVar7) + uVar13 + 0xbebfbc70 + uVar9;
  uVar9 = (uVar8 * 0x800000 | uVar8 >> 9) + uVar7;
  uVar8 = (uVar6 ^ uVar7 ^ uVar9) + uVar10 + uVar25 + 0x289b7ec6;
  uVar8 = (uVar8 >> 0x1c | uVar8 * 0x10) + uVar9;
  uVar6 = (uVar7 ^ uVar9 ^ uVar8) + uVar6 + uVar19 + 0xeaa127fa;
  uVar10 = (uVar6 >> 0x15 | uVar6 * 0x800) + uVar8;
  uVar6 = (uVar9 ^ uVar8 ^ uVar10) + uVar14 + 0xd4ef3085 + uVar7;
  uVar7 = (uVar6 >> 0x10 | uVar6 * 0x10000) + uVar10;
  uVar6 = (uVar8 ^ uVar10 ^ uVar7) + uVar9 + uVar1 + 0x4881d05;
  uVar6 = (uVar6 * 0x800000 | uVar6 >> 9) + uVar7;
  uVar8 = (uVar10 ^ uVar7 ^ uVar6) + uVar8 + uVar2 + 0xd9d4d039;
  uVar9 = (uVar8 >> 0x1c | uVar8 * 0x10) + uVar6;
  uVar8 = (uVar7 ^ uVar6 ^ uVar9) + uVar10 + uVar15 + 0xe6db99e5;
  uVar8 = (uVar8 >> 0x15 | uVar8 * 0x800) + uVar9;
  uVar7 = (uVar6 ^ uVar9 ^ uVar8) + uVar3 + 0x1fa27cf8 + uVar7;
  uVar7 = (uVar7 >> 0x10 | uVar7 * 0x10000) + uVar8;
  uVar6 = (uVar9 ^ uVar8 ^ uVar7) + uVar6 + uVar22 + 0xc4ac5665;
  uVar10 = (uVar6 * 0x800000 | uVar6 >> 9) + uVar7;
  uVar6 = ((~uVar8 | uVar10) ^ uVar7) + uVar19 + 0xf4292244 + uVar9;
  uVar9 = (uVar6 >> 0x1a | uVar6 * 0x40) + uVar10;
  uVar8 = ((~uVar7 | uVar9) ^ uVar10) + uVar18 + 0x432aff97 + uVar8;
  uVar8 = (uVar8 >> 0x16 | uVar8 * 0x400) + uVar9;
  uVar6 = ((~uVar10 | uVar8) ^ uVar9) + uVar17 + 0xab9423a7 + uVar7;
  uVar7 = (uVar6 >> 0x11 | uVar6 * 0x8000) + uVar8;
  uVar6 = ((~uVar9 | uVar7) ^ uVar8) + uVar10 + uVar16 + 0xfc93a039;
  uVar6 = (uVar6 * 0x200000 | uVar6 >> 0xb) + uVar7;
  uVar9 = ((~uVar8 | uVar6) ^ uVar7) + uVar9 + uVar15 + 0x655b59c3;
  uVar11 = (uVar9 >> 0x1a | uVar9 * 0x40) + uVar6;
  uVar8 = ((~uVar7 | uVar11) ^ uVar6) + uVar8 + uVar14 + 0x8f0ccc92;
  uVar10 = (uVar8 >> 0x16 | uVar8 * 0x400) + uVar11;
  uVar8 = ((~uVar6 | uVar10) ^ uVar11) + (uVar13 - 0x100b83) + uVar7;
  uVar7 = (uVar8 >> 0x11 | uVar8 * 0x8000) + uVar10;
  uVar8 = ((~uVar11 | uVar7) ^ uVar10) + uVar5 + 0x85845dd1 + uVar6;
  uVar9 = (uVar8 * 0x200000 | uVar8 >> 0xb) + uVar7;
  uVar8 = ((~uVar10 | uVar9) ^ uVar7) + uVar11 + uVar4 + 0x6fa87e4f;
  uVar6 = (uVar8 >> 0x1a | uVar8 * 0x40) + uVar9;
  uVar8 = ((~uVar7 | uVar6) ^ uVar9) + uVar10 + uVar3 + 0xfe2ce6e0;
  uVar8 = (uVar8 >> 0x16 | uVar8 * 0x400) + uVar6;
  uVar7 = ((~uVar9 | uVar8) ^ uVar6) + uVar7 + uVar1 + 0xa3014314;
  uVar7 = (uVar7 >> 0x11 | uVar7 * 0x8000) + uVar8;
  uVar9 = ((~uVar6 | uVar7) ^ uVar8) + uVar25 + 0x4e0811a1 + uVar9;
  uVar9 = (uVar9 * 0x200000 | uVar9 >> 0xb) + uVar7;
  uVar6 = ((~uVar8 | uVar9) ^ uVar7) + uVar6 + uVar24 + 0xf7537e82;
  uVar11 = (uVar6 >> 0x1a | uVar6 * 0x40) + uVar9;
  uVar8 = ((~uVar7 | uVar11) ^ uVar9) + uVar8 + uVar23 + 0xbd3af235;
  uVar10 = (uVar8 >> 0x16 | uVar8 * 0x400) + uVar11;
  uVar8 = ((~uVar9 | uVar10) ^ uVar11) + uVar7 + uVar22 + 0x2ad7d2bb;
  uVar6 = (uVar8 >> 0x11 | uVar8 * 0x8000) + uVar10;
  uVar8 = ((~uVar11 | uVar6) ^ uVar10) + uVar2 + 0xeb86d391 + uVar9;
  *state = uVar11 + *state;
  state[2] = uVar20 + uVar6;
  state[3] = uVar21 + uVar10;
  state[1] = uVar12 + uVar6 + (uVar8 * 0x200000 | uVar8 >> 0xb);
  memset(block,0,0x40);
  return;
}



void wpa_MD5Init(Bl_MD5_CTX *context)

{
  context->state[0] = 0x67452301;
  context->state[1] = 0xefcdab89;
  context->state[2] = 0x98badcfe;
  context->count[1] = 0;
  context->count[0] = 0;
  context->state[3] = 0x10325476;
  return;
}



void wpa_MD5Update(Bl_MD5_CTX *context,UINT8 *input,UINT32 inputLen)

{
  uint uVar1;
  uint __n;
  
  uVar1 = context->count[0];
  __n = uVar1 + inputLen * 8;
  context->count[0] = __n;
  uVar1 = uVar1 >> 3 & 0x3f;
  if (__n < inputLen * 8) {
    context->count[1] = context->count[1] + 1;
  }
  context->count[1] = (inputLen >> 0x1d) + context->count[1];
  __n = 0x40 - uVar1;
  if (inputLen < __n) {
    __n = 0;
  }
  else {
    memcpy(context->buffer + uVar1,input,__n);
    wpa_MD5Transform((UINT32 *)context,(ulong *)context->buffer);
    while (__n + 0x3f < inputLen) {
      memcpy(context->scratch,input + __n,0x40);
      wpa_MD5Transform((UINT32 *)context,context->scratch);
      __n = __n + 0x40;
    }
    uVar1 = 0;
  }
  memcpy(context->buffer + uVar1,input + __n,inputLen - __n);
  return;
}



void wpa_MD5Final(uchar *digest,Bl_MD5_CTX *context)

{
  uint uVar1;
  int iVar2;
  UINT8 aUStack24 [4];
  uchar bits [8];
  
  memcpy(aUStack24,context->count,8);
  uVar1 = context->count[0] >> 3 & 0x3f;
  if (uVar1 < 0x38) {
    iVar2 = 0x38;
  }
  else {
    iVar2 = 0x78;
  }
  wpa_MD5Update(context,PADDING,iVar2 - uVar1);
  wpa_MD5Update(context,aUStack24,8);
  memcpy(digest,context,0x10);
  memset(context,0,0x98);
  return;
}



int rijndaelKeySetupEnc(u32 *rk,u8 *cipherKey,int keyBits)

{
  uint uVar1;
  uint uVar2;
  u32 *puVar3;
  u32 *puVar4;
  
  *rk = (uint)*cipherKey << 0x18 ^ (uint)cipherKey[1] << 0x10 ^ (uint)cipherKey[3] ^
        (uint)cipherKey[2] << 8;
  rk[1] = (uint)cipherKey[4] << 0x18 ^ (uint)cipherKey[5] << 0x10 ^ (uint)cipherKey[7] ^
          (uint)cipherKey[6] << 8;
  rk[2] = (uint)cipherKey[8] << 0x18 ^ (uint)cipherKey[9] << 0x10 ^ (uint)cipherKey[0xb] ^
          (uint)cipherKey[10] << 8;
  rk[3] = (uint)cipherKey[0xc] << 0x18 ^ (uint)cipherKey[0xd] << 0x10 ^ (uint)cipherKey[0xf] ^
          (uint)cipherKey[0xe] << 8;
  if (keyBits == 0x80) {
    puVar3 = rcon;
    puVar4 = rk + 0x24;
    while( true ) {
      uVar1 = *puVar3;
      uVar2 = rk[3];
      puVar3 = puVar3 + 1;
      uVar1 = *rk ^ uVar1 ^ (uint)Te4[uVar2 >> 0x18] ^ (uint)Te4[uVar2 & 0xff] << 8 ^
              (uint)Te4[uVar2 >> 0x10 & 0xff] << 0x18 ^ (uint)Te4[uVar2 >> 8 & 0xff] << 0x10;
      rk[4] = uVar1;
      uVar1 = uVar1 ^ rk[1];
      rk[5] = uVar1;
      uVar1 = uVar1 ^ rk[2];
      rk[6] = uVar1;
      rk[7] = uVar1 ^ uVar2;
      if (rk == puVar4) break;
      rk = rk + 4;
    }
    return 10;
  }
  return 0;
}



void rijndael_set_key(rijndael_ctx *ctx,u8 *key,int bits,int encrypt)

{
  int iVar1;
  u32 *rk;
  int iVar2;
  u32 uVar3;
  u32 *puVar4;
  uint uVar5;
  int *piVar6;
  
  rk = ctx->key;
  iVar2 = rijndaelKeySetupEnc(rk,key,bits);
  ctx->Nr = iVar2;
  if (encrypt == 0) {
    ctx->decrypt = 1;
    if (iVar2 == 0) {
      iVar2 = rijndaelKeySetupEnc(rk,key,bits);
    }
    puVar4 = rk;
    piVar6 = &ctx->decrypt + iVar2 * 4;
    while (encrypt < iVar2 * 4 - encrypt) {
      uVar3 = *puVar4;
      encrypt = encrypt + 4;
      *puVar4 = piVar6[2];
      piVar6[2] = uVar3;
      uVar3 = puVar4[1];
      puVar4[1] = piVar6[3];
      piVar6[3] = uVar3;
      uVar3 = puVar4[2];
      puVar4[2] = piVar6[4];
      piVar6[4] = uVar3;
      uVar3 = puVar4[3];
      puVar4[3] = piVar6[5];
      piVar6[5] = uVar3;
      puVar4 = puVar4 + 4;
      piVar6 = piVar6 + -4;
    }
    iVar1 = 1;
    while (iVar1 < iVar2) {
      puVar4 = rk + 4;
      uVar5 = *puVar4;
      iVar1 = iVar1 + 1;
      *puVar4 = Td2[Te4[uVar5 >> 8 & 0xff]] ^
                Td0[Te4[uVar5 >> 0x18]] ^ Td3[Te4[uVar5 & 0xff]] ^ Td1[Te4[uVar5 >> 0x10 & 0xff]];
      uVar5 = rk[5];
      rk[5] = Td2[Te4[uVar5 >> 8 & 0xff]] ^
              Td0[Te4[uVar5 >> 0x18]] ^ Td3[Te4[uVar5 & 0xff]] ^ Td1[Te4[uVar5 >> 0x10 & 0xff]];
      uVar5 = rk[6];
      rk[6] = Td2[Te4[uVar5 >> 8 & 0xff]] ^
              Td0[Te4[uVar5 >> 0x18]] ^ Td3[Te4[uVar5 & 0xff]] ^ Td1[Te4[uVar5 >> 0x10 & 0xff]];
      uVar5 = rk[7];
      rk[7] = Td2[Te4[uVar5 >> 8 & 0xff]] ^
              Td0[Te4[uVar5 >> 0x18]] ^ Td3[Te4[uVar5 & 0xff]] ^ Td1[Te4[uVar5 >> 0x10 & 0xff]];
      rk = puVar4;
    }
  }
  else {
    ctx->decrypt = 0;
  }
  return;
}



void rijndael_decrypt(rijndael_ctx *ctx,u8 *src,u8 *dst)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  u32 *puVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  int iVar13;
  uint uVar14;
  int iVar15;
  uint uVar16;
  uint uVar17;
  uint uVar18;
  uint uVar19;
  
  uVar10 = (uint)*src << 0x18 ^ (uint)src[1] << 0x10 ^ (uint)src[3] ^ (uint)src[2] << 8 ^
           ctx->key[0];
  uVar16 = (uint)src[4] << 0x18 ^ (uint)src[5] << 0x10 ^ (uint)src[7] ^ (uint)src[6] << 8 ^
           ctx->key[1];
  uVar14 = (uint)src[8] << 0x18 ^ (uint)src[9] << 0x10 ^ (uint)src[0xb] ^ (uint)src[10] << 8 ^
           ctx->key[2];
  uVar11 = (uint)src[0xc] << 0x18 ^ (uint)src[0xd] << 0x10 ^ (uint)src[0xf] ^ (uint)src[0xe] << 8 ^
           ctx->key[3];
  iVar13 = ctx->Nr >> 1;
  puVar4 = ctx->key;
  iVar15 = iVar13;
  while( true ) {
    uVar5 = Td0[uVar10 >> 0x18] ^ Td3[uVar16 & 0xff] ^ puVar4[4] ^
            *(uint *)((int)Td1 + (uVar11 >> 0xe & 0x3fc)) ^
            *(uint *)((int)Td2 + (uVar14 >> 6 & 0x3fc));
    iVar15 = iVar15 + -1;
    uVar17 = uVar5 >> 0x10 & 0xff;
    uVar6 = Td0[uVar16 >> 0x18] ^ Td3[uVar14 & 0xff] ^ puVar4[5] ^
            *(uint *)((int)Td1 + (uVar10 >> 0xe & 0x3fc)) ^
            *(uint *)((int)Td2 + (uVar11 >> 6 & 0x3fc));
    uVar8 = Td0[uVar14 >> 0x18] ^ Td3[uVar11 & 0xff] ^ puVar4[6] ^
            *(uint *)((int)Td1 + (uVar16 >> 0xe & 0x3fc)) ^
            *(uint *)((int)Td2 + (uVar10 >> 6 & 0x3fc));
    uVar12 = Td0[uVar11 >> 0x18] ^ Td3[uVar10 & 0xff] ^ puVar4[7] ^
             *(uint *)((int)Td1 + (uVar14 >> 0xe & 0x3fc)) ^
             *(uint *)((int)Td2 + (uVar16 >> 6 & 0x3fc));
    uVar19 = uVar12 >> 0x10 & 0xff;
    uVar18 = uVar8 >> 8 & 0xff;
    uVar10 = puVar4[8];
    uVar16 = uVar12 >> 8 & 0xff;
    uVar11 = uVar6 >> 0x10 & 0xff;
    uVar14 = uVar5 >> 8 & 0xff;
    uVar9 = uVar8 >> 0x10 & 0xff;
    uVar7 = uVar6 >> 8 & 0xff;
    if (iVar15 == 0) break;
    uVar10 = Td0[uVar5 >> 0x18] ^ Td3[uVar6 & 0xff] ^ uVar10 ^ Td1[uVar19] ^ Td2[uVar18];
    uVar16 = Td0[uVar6 >> 0x18] ^ Td3[uVar8 & 0xff] ^ puVar4[9] ^ Td1[uVar17] ^ Td2[uVar16];
    uVar14 = Td0[uVar8 >> 0x18] ^ Td3[uVar12 & 0xff] ^ puVar4[10] ^ Td1[uVar11] ^ Td2[uVar14];
    uVar11 = Td0[uVar12 >> 0x18] ^ Td3[uVar5 & 0xff] ^ puVar4[0xb] ^ Td1[uVar9] ^ Td2[uVar7];
    puVar4 = puVar4 + 8;
  }
  puVar4 = ctx->key + iVar13 * 8;
  uVar10 = (uint)Td4[uVar5 >> 0x18] << 0x18 ^ (uint)Td4[uVar19] << 0x10 ^ (uint)Td4[uVar6 & 0xff] ^
           (uint)Td4[uVar18] << 8 ^ uVar10;
  *dst = (u8)(uVar10 >> 0x18);
  dst[1] = (u8)(uVar10 >> 0x10);
  dst[2] = (u8)(uVar10 >> 8);
  bVar1 = Td4[uVar17];
  bVar2 = Td4[uVar6 >> 0x18];
  bVar3 = Td4[uVar8 & 0xff];
  dst[3] = (u8)uVar10;
  uVar10 = (uint)bVar2 << 0x18 ^ (uint)bVar1 << 0x10 ^ (uint)bVar3 ^ (uint)Td4[uVar16] << 8 ^
           puVar4[1];
  dst[4] = (u8)(uVar10 >> 0x18);
  dst[5] = (u8)(uVar10 >> 0x10);
  dst[6] = (u8)(uVar10 >> 8);
  dst[7] = (u8)uVar10;
  bVar1 = Td4[uVar12 >> 0x18];
  uVar10 = (uint)Td4[uVar8 >> 0x18] << 0x18 ^ (uint)Td4[uVar11] << 0x10 ^ (uint)Td4[uVar12 & 0xff] ^
           (uint)Td4[uVar14] << 8 ^ puVar4[2];
  dst[8] = (u8)(uVar10 >> 0x18);
  dst[9] = (u8)(uVar10 >> 0x10);
  dst[0xb] = (u8)uVar10;
  bVar2 = Td4[uVar9];
  dst[10] = (u8)(uVar10 >> 8);
  uVar10 = (uint)bVar1 << 0x18 ^ (uint)bVar2 << 0x10 ^ (uint)Td4[uVar5 & 0xff] ^
           (uint)Td4[uVar7] << 8 ^ puVar4[3];
  dst[0xc] = (u8)(uVar10 >> 0x18);
  dst[0xd] = (u8)(uVar10 >> 0x10);
  dst[0xe] = (u8)(uVar10 >> 8);
  dst[0xf] = (u8)uVar10;
  return;
}



void rijndael_encrypt(rijndael_ctx *ctx,u8 *src,u8 *dst)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  u32 *puVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  int iVar13;
  uint uVar14;
  int iVar15;
  uint uVar16;
  uint uVar17;
  uint uVar18;
  uint uVar19;
  
  uVar10 = (uint)*src << 0x18 ^ (uint)src[1] << 0x10 ^ (uint)src[3] ^ (uint)src[2] << 8 ^
           ctx->key[0];
  uVar16 = (uint)src[4] << 0x18 ^ (uint)src[5] << 0x10 ^ (uint)src[7] ^ (uint)src[6] << 8 ^
           ctx->key[1];
  uVar14 = (uint)src[8] << 0x18 ^ (uint)src[9] << 0x10 ^ (uint)src[0xb] ^ (uint)src[10] << 8 ^
           ctx->key[2];
  uVar11 = (uint)src[0xc] << 0x18 ^ (uint)src[0xd] << 0x10 ^ (uint)src[0xf] ^ (uint)src[0xe] << 8 ^
           ctx->key[3];
  iVar13 = ctx->Nr >> 1;
  puVar4 = ctx->key;
  iVar15 = iVar13;
  while( true ) {
    uVar8 = Te0[uVar10 >> 0x18] ^ Te3[uVar11 & 0xff] ^ puVar4[4] ^
            *(uint *)((int)Te1 + (uVar16 >> 0xe & 0x3fc)) ^
            *(uint *)((int)Te2 + (uVar14 >> 6 & 0x3fc));
    iVar15 = iVar15 + -1;
    uVar6 = Te0[uVar16 >> 0x18] ^ Te3[uVar10 & 0xff] ^ puVar4[5] ^
            *(uint *)((int)Te1 + (uVar14 >> 0xe & 0x3fc)) ^
            *(uint *)((int)Te2 + (uVar11 >> 6 & 0x3fc));
    uVar5 = Te0[uVar14 >> 0x18] ^ Te3[uVar16 & 0xff] ^ puVar4[6] ^
            *(uint *)((int)Te1 + (uVar11 >> 0xe & 0x3fc)) ^
            *(uint *)((int)Te2 + (uVar10 >> 6 & 0x3fc));
    uVar12 = Te0[uVar11 >> 0x18] ^ Te3[uVar14 & 0xff] ^ puVar4[7] ^
             *(uint *)((int)Te1 + (uVar10 >> 0xe & 0x3fc)) ^
             *(uint *)((int)Te2 + (uVar16 >> 6 & 0x3fc));
    uVar19 = uVar6 >> 0x10 & 0xff;
    uVar18 = uVar5 >> 8 & 0xff;
    uVar10 = puVar4[8];
    uVar17 = uVar5 >> 0x10 & 0xff;
    uVar16 = uVar12 >> 8 & 0xff;
    uVar11 = uVar12 >> 0x10 & 0xff;
    uVar14 = uVar8 >> 8 & 0xff;
    uVar9 = uVar8 >> 0x10 & 0xff;
    uVar7 = uVar6 >> 8 & 0xff;
    if (iVar15 == 0) break;
    uVar10 = Te0[uVar8 >> 0x18] ^ Te3[uVar12 & 0xff] ^ uVar10 ^ Te1[uVar19] ^ Te2[uVar18];
    uVar16 = Te0[uVar6 >> 0x18] ^ Te3[uVar8 & 0xff] ^ puVar4[9] ^ Te1[uVar17] ^ Te2[uVar16];
    uVar14 = Te0[uVar5 >> 0x18] ^ Te3[uVar6 & 0xff] ^ puVar4[10] ^ Te1[uVar11] ^ Te2[uVar14];
    uVar11 = Te0[uVar12 >> 0x18] ^ Te3[uVar5 & 0xff] ^ puVar4[0xb] ^ Te1[uVar9] ^ Te2[uVar7];
    puVar4 = puVar4 + 8;
  }
  puVar4 = ctx->key + iVar13 * 8;
  uVar10 = (uint)Te4[uVar8 >> 0x18] << 0x18 ^ (uint)Te4[uVar19] << 0x10 ^ (uint)Te4[uVar12 & 0xff] ^
           (uint)Te4[uVar18] << 8 ^ uVar10;
  *dst = (u8)(uVar10 >> 0x18);
  dst[1] = (u8)(uVar10 >> 0x10);
  dst[2] = (u8)(uVar10 >> 8);
  bVar1 = Te4[uVar17];
  bVar2 = Te4[uVar6 >> 0x18];
  bVar3 = Te4[uVar8 & 0xff];
  dst[3] = (u8)uVar10;
  uVar10 = (uint)bVar2 << 0x18 ^ (uint)bVar1 << 0x10 ^ (uint)bVar3 ^ (uint)Te4[uVar16] << 8 ^
           puVar4[1];
  dst[4] = (u8)(uVar10 >> 0x18);
  dst[5] = (u8)(uVar10 >> 0x10);
  dst[6] = (u8)(uVar10 >> 8);
  dst[7] = (u8)uVar10;
  bVar1 = Te4[uVar12 >> 0x18];
  uVar10 = (uint)Te4[uVar5 >> 0x18] << 0x18 ^ (uint)Te4[uVar11] << 0x10 ^ (uint)Te4[uVar6 & 0xff] ^
           (uint)Te4[uVar14] << 8 ^ puVar4[2];
  dst[8] = (u8)(uVar10 >> 0x18);
  dst[9] = (u8)(uVar10 >> 0x10);
  dst[0xb] = (u8)uVar10;
  bVar2 = Te4[uVar9];
  dst[10] = (u8)(uVar10 >> 8);
  uVar10 = (uint)bVar1 << 0x18 ^ (uint)bVar2 << 0x10 ^ (uint)Te4[uVar5 & 0xff] ^
           (uint)Te4[uVar7] << 8 ^ puVar4[3];
  dst[0xc] = (u8)(uVar10 >> 0x18);
  dst[0xd] = (u8)(uVar10 >> 0x10);
  dst[0xe] = (u8)(uVar10 >> 8);
  dst[0xf] = (u8)uVar10;
  return;
}



void Bl_SHA1ProcessMessageBlock(Bl_SHA1_CTX *context)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  UINT32 *pUVar4;
  uint uVar5;
  UINT32 *pUVar6;
  UINT32 *pUVar7;
  uint uVar8;
  UINT32 UVar9;
  uint uVar10;
  uint uVar11;
  UINT32 UVar12;
  uint uVar13;
  uint uVar14;
  uint uVar15;
  UINT32 UVar16;
  
  pUVar4 = context->Scratch;
  pUVar6 = pUVar4;
  do {
    pUVar7 = pUVar6 + 1;
    *pUVar6 = (uint)*(byte *)(pUVar6 + 0x10) << 0x18 | (uint)*(byte *)((int)pUVar6 + 0x41) << 0x10 |
              (uint)*(byte *)((int)pUVar6 + 0x42) << 8 | (uint)*(byte *)((int)pUVar6 + 0x43);
    pUVar6 = pUVar7;
  } while ((UINT32 *)context->Message_Block != pUVar7);
  uVar11 = 0;
  uVar8 = context->Intermediate_Hash[2];
  uVar10 = context->Intermediate_Hash[0];
  UVar12 = context->Intermediate_Hash[1];
  uVar2 = context->Intermediate_Hash[3];
  UVar16 = context->Intermediate_Hash[4];
  do {
    uVar13 = uVar2;
    uVar3 = uVar10;
    uVar2 = uVar8;
    if ((uVar11 & 0x30) == 0) {
      UVar9 = context->Scratch[uVar11];
    }
    else {
      uVar8 = pUVar4[uVar11 + 0xd & 0xf] ^ pUVar4[uVar11 + 8 & 0xf] ^ pUVar4[uVar11 & 0xf] ^
              pUVar4[uVar11 + 2 & 0xf];
      UVar9 = uVar8 >> 0x1f | uVar8 << 1;
      pUVar4[uVar11 & 0xf] = UVar9;
    }
    uVar11 = uVar11 + 1;
    uVar10 = UVar9 + ((uVar2 ^ uVar13) & UVar12 ^ uVar13) +
                     (uVar3 << 5 | uVar3 >> 0x1b) + 0x5a827999 + UVar16;
    uVar8 = UVar12 << 0x1e | UVar12 >> 2;
    UVar12 = uVar3;
    UVar16 = uVar13;
  } while (uVar11 != 0x14);
  do {
    uVar14 = uVar10;
    uVar1 = uVar2;
    uVar2 = uVar11 + 0xd;
    uVar10 = uVar11 + 8;
    uVar15 = uVar11 & 0xf;
    uVar5 = uVar11 + 2;
    uVar11 = uVar11 + 1;
    uVar2 = pUVar4[uVar2 & 0xf] ^ pUVar4[uVar10 & 0xf] ^ pUVar4[uVar15] ^ pUVar4[uVar5 & 0xf];
    uVar2 = uVar2 >> 0x1f | uVar2 << 1;
    pUVar4[uVar15] = uVar2;
    uVar10 = (uVar3 ^ uVar8 ^ uVar1) + (uVar14 << 5 | uVar14 >> 0x1b) + 0x6ed9eba1 + uVar2 + uVar13;
    uVar5 = uVar3 << 0x1e | uVar3 >> 2;
    uVar2 = uVar8;
    uVar3 = uVar14;
    uVar8 = uVar5;
    uVar13 = uVar1;
  } while (uVar11 != 0x28);
  do {
    uVar8 = uVar10;
    uVar13 = uVar11 + 0xd;
    uVar10 = uVar11 + 8;
    uVar15 = uVar11 & 0xf;
    uVar3 = uVar11 + 2;
    uVar11 = uVar11 + 1;
    uVar10 = pUVar4[uVar13 & 0xf] ^ pUVar4[uVar10 & 0xf] ^ pUVar4[uVar15] ^ pUVar4[uVar3 & 0xf];
    uVar10 = uVar10 >> 0x1f | uVar10 << 1;
    pUVar4[uVar15] = uVar10;
    uVar10 = ((uVar5 | uVar2) & uVar14 | uVar5 & uVar2) + (uVar8 << 5 | uVar8 >> 0x1b) + 0x8f1bbcdc
             + uVar10 + uVar1;
    uVar13 = uVar14 << 0x1e | uVar14 >> 2;
    uVar1 = uVar2;
    uVar14 = uVar8;
    uVar3 = uVar2;
    uVar2 = uVar5;
    uVar5 = uVar13;
  } while (uVar11 != 0x3c);
  do {
    uVar15 = uVar13;
    uVar5 = uVar2;
    uVar1 = uVar10;
    uVar10 = uVar11 + 0xd;
    uVar13 = uVar11 + 8;
    uVar2 = uVar11 & 0xf;
    uVar14 = uVar11 + 2;
    uVar11 = uVar11 + 1;
    uVar10 = pUVar4[uVar10 & 0xf] ^ pUVar4[uVar13 & 0xf] ^ pUVar4[uVar2] ^ pUVar4[uVar14 & 0xf];
    uVar10 = uVar10 >> 0x1f | uVar10 << 1;
    pUVar4[uVar2] = uVar10;
    uVar10 = uVar10 + (uVar8 ^ uVar15 ^ uVar5) + (uVar1 << 5 | uVar1 >> 0x1b) + 0xca62c1d6 + uVar3;
    uVar13 = uVar8 << 0x1e | uVar8 >> 2;
    uVar8 = uVar1;
    uVar3 = uVar5;
    uVar2 = uVar15;
  } while (uVar11 != 0x50);
  context->Message_Block_Index = 0;
  UVar12 = context->Intermediate_Hash[1];
  context->Intermediate_Hash[0] = uVar10 + context->Intermediate_Hash[0];
  context->Intermediate_Hash[1] = uVar1 + UVar12;
  context->Intermediate_Hash[2] = uVar13 + context->Intermediate_Hash[2];
  context->Intermediate_Hash[3] = uVar15 + context->Intermediate_Hash[3];
  context->Intermediate_Hash[4] = uVar5 + context->Intermediate_Hash[4];
  return;
}



int Bl_SHA1Init(Bl_SHA1_CTX *context)

{
  if (context != (Bl_SHA1_CTX *)0x0) {
    context->Intermediate_Hash[0] = 0x67452301;
    context->Intermediate_Hash[1] = 0xefcdab89;
    context->Intermediate_Hash[2] = 0x98badcfe;
    context->Intermediate_Hash[3] = 0x10325476;
    context->Length_Low = 0;
    context->Length_High = 0;
    context->Intermediate_Hash[4] = 0xc3d2e1f0;
    *(undefined4 *)&context->Message_Block_Index = 0;
    return 0;
  }
  return 1;
}



int Bl_SHA1Final(Bl_SHA1_CTX *context,UINT8 *Message_Digest)

{
  short sVar1;
  ushort uVar2;
  int iVar3;
  uint uVar4;
  UINT32 UVar5;
  SINT16 *pSVar6;
  
  uVar4 = 1;
  if (((context != (Bl_SHA1_CTX *)0x0) && (Message_Digest != (UINT8 *)0x0)) &&
     (uVar4 = (uint)context->Corrupted, context->Corrupted == 0)) {
    if (context->Computed == '\0') {
      iVar3 = (int)context->Message_Block_Index;
      context->Message_Block_Index = (SINT16)((uint)((iVar3 + 1) * 0x10000) >> 0x10);
      context->Message_Block[iVar3] = -0x80;
      if (iVar3 < 0x38) {
        while( true ) {
          sVar1 = context->Message_Block_Index;
          if (0x37 < (int)sVar1) break;
          context->Message_Block_Index = sVar1 + 1;
          context->Message_Block[(int)sVar1] = '\0';
        }
      }
      else {
        while( true ) {
          sVar1 = context->Message_Block_Index;
          if (0x3f < (int)sVar1) break;
          context->Message_Block_Index = sVar1 + 1;
          context->Message_Block[(int)sVar1] = '\0';
        }
        Bl_SHA1ProcessMessageBlock(context);
        while( true ) {
          sVar1 = context->Message_Block_Index;
          if (0x37 < (int)sVar1) break;
          context->Message_Block_Index = sVar1 + 1;
          context->Message_Block[(int)sVar1] = '\0';
        }
      }
      UVar5 = context->Length_High;
      *(ushort *)(context->Message_Block + 0x3a) =
           *(ushort *)&context->Length_High << 8 | *(ushort *)&context->Length_High >> 8;
      context->Message_Block[0x39] = (UINT8)(UVar5 >> 0x10);
      uVar2 = *(ushort *)&context->Length_Low;
      context->Message_Block[0x38] = (UINT8)(UVar5 >> 0x18);
      UVar5 = context->Length_Low;
      *(ushort *)(context->Message_Block + 0x3e) = uVar2 << 8 | uVar2 >> 8;
      context->Message_Block[0x3d] = (UINT8)(UVar5 >> 0x10);
      context->Message_Block[0x3c] = (UINT8)(UVar5 >> 0x18);
      Bl_SHA1ProcessMessageBlock(context);
      pSVar6 = (SINT16 *)context->Message_Block;
      do {
        *(UINT8 *)pSVar6 = '\0';
        pSVar6 = (SINT16 *)((int)pSVar6 + 1);
      } while (&context->Message_Block_Index != pSVar6);
      context->Length_Low = 0;
      context->Length_High = 0;
      context->Computed = '\x01';
    }
    uVar4 = 0;
    do {
      Message_Digest[uVar4] =
           (UINT8)(*(uint *)((int)context->Intermediate_Hash + (uVar4 & 0xfffffffc)) >>
                  ((~uVar4 & 3) << 3));
      uVar4 = uVar4 + 1;
    } while (uVar4 != 0x14);
    memset(context,0,0xa0);
    return 0;
  }
  return uVar4;
}



int Bl_SHA1Update(Bl_SHA1_CTX *context,UINT8 *message_array,uint length)

{
  short sVar1;
  UINT8 *pUVar2;
  uint uVar3;
  UINT32 UVar4;
  int iVar5;
  
  if (length == 0) {
    return 0;
  }
  uVar3 = 1;
  if ((context != (Bl_SHA1_CTX *)0x0) && (message_array != (UINT8 *)0x0)) {
    if (context->Computed == '\0') {
      uVar3 = (uint)context->Corrupted;
      if (context->Corrupted == 0) {
        pUVar2 = message_array + length;
        while ((message_array != pUVar2 && (context->Corrupted == '\0'))) {
          sVar1 = context->Message_Block_Index;
          iVar5 = ((int)sVar1 + 1) * 0x10000;
          context->Message_Block_Index = (SINT16)((uint)iVar5 >> 0x10);
          context->Message_Block[(int)sVar1] = *message_array;
          UVar4 = context->Length_Low + 8;
          context->Length_Low = UVar4;
          if ((UVar4 == 0) &&
             (UVar4 = context->Length_High + 1, context->Length_High = UVar4, UVar4 == 0)) {
            context->Corrupted = '\x01';
          }
          if (iVar5 >> 0x10 == 0x40) {
            Bl_SHA1ProcessMessageBlock(context);
          }
          message_array = message_array + 1;
        }
        uVar3 = 0;
      }
    }
    else {
      context->Corrupted = '\x03';
      uVar3 = 3;
    }
  }
  return uVar3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

Status_e supplicantRestoreDefaults(void)

{
  char "supplicantRestoreDefaults" [26];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantRestoreDefaults");
  pmkCacheInit();
  pmkCacheRomInit();
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307af3c);
  return FW_SUCCESS;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void supplicantFuncInit(void)

{
  char "supplicantFuncInit" [19];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantFuncInit");
  supplicantRestoreDefaults();
  dbg_test_print("%dms : Leave: %s\n",0x2307af58);
  return;
}



void ap_setpsk(cm_ConnectionInfo_t *connPtr,CHAR *ssid,CHAR *passphrase)

{
  apInfo_t *paVar1;
  size_t sVar2;
  
  paVar1 = cm_GetApInfo(connPtr);
  if (paVar1 != (apInfo_t *)0x0) {
    sVar2 = strlen(ssid);
    (paVar1->bssConfig).comData.SsIdLen = (IEEEtypes_Len_t)sVar2;
    memcpy(&(paVar1->bssConfig).comData,ssid,0x20);
    sVar2 = strlen(passphrase);
    (paVar1->bssConfig).RsnConfig.PSKPassPhraseLen = (UINT8)sVar2;
    memcpy((paVar1->bssConfig).RsnConfig.PSKPassPhrase,passphrase,0x40);
    return;
  }
  return;
}



void ap_resetConfiguration(cm_ConnectionInfo_t *connPtr)

{
  ushort uVar1;
  apInfo_t *paVar2;
  apSpecificData_t *paVar3;
  size_t sVar4;
  
  paVar2 = cm_GetApInfo(connPtr);
  paVar3 = cm_GetApData(connPtr);
  if ((paVar2 != (apInfo_t *)0x0) && (paVar3 != (apSpecificData_t *)0x0)) {
    sVar4 = strlen("Marvell Micro AP");
    (paVar2->bssConfig).comData.SsIdLen = (IEEEtypes_Len_t)sVar4;
    memcpy(&(paVar2->bssConfig).comData,"Marvell Micro AP",0x20);
    (paVar2->bssData).updatePassPhrase = 1;
    memset(&(paVar2->bssConfig).RsnConfig,0,0x7c);
    uVar1 = *(ushort *)&(paVar2->bssConfig).RsnConfig;
    (paVar2->bssConfig).RsnConfig.AuthKeyCount = 1;
    *(ushort *)&(paVar2->bssConfig).RsnConfig = uVar1 & 0xf7 | 0x108;
    *(ushort *)&(paVar2->bssConfig).RsnConfig.wpa2UcstCipher =
         *(ushort *)&(paVar2->bssConfig).RsnConfig.wpa2UcstCipher & 0xf7 | 0x108;
    (paVar2->bssConfig).RsnConfig.MaxPwsHskRetries = '\x03';
    (paVar2->bssConfig).RsnConfig.MaxGrpHskRetries = '\x03';
    (paVar2->bssConfig).RsnConfig.PwsHskTimeOut = 100;
    (paVar2->bssConfig).RsnConfig.GrpHskTimeOut = 100;
    (paVar2->bssConfig).RsnConfig.GrpReKeyTime = 0x15180;
  }
  return;
}



void InitializeAp(cm_ConnectionInfo_t *connPtr)

{
  ushort uVar1;
  apInfo_t *paVar2;
  apSpecificData_t *paVar3;
  size_t sVar4;
  
  paVar2 = cm_GetApInfo(connPtr);
  paVar3 = cm_GetApData(connPtr);
  if ((paVar2 != (apInfo_t *)0x0) && (paVar3 != (apSpecificData_t *)0x0)) {
    sVar4 = strlen("Marvell Micro AP");
    (paVar2->bssConfig).comData.SsIdLen = (IEEEtypes_Len_t)sVar4;
    memcpy(&(paVar2->bssConfig).comData,"Marvell Micro AP",0x20);
    (paVar2->bssData).updatePassPhrase = 1;
    memset(&(paVar2->bssConfig).RsnConfig,0,0x7c);
    uVar1 = *(ushort *)&(paVar2->bssConfig).RsnConfig;
    (paVar2->bssConfig).RsnConfig.AuthKeyCount = 1;
    *(ushort *)&(paVar2->bssConfig).RsnConfig = uVar1 & 0xf7 | 0x108;
    *(ushort *)&(paVar2->bssConfig).RsnConfig.wpa2UcstCipher =
         *(ushort *)&(paVar2->bssConfig).RsnConfig.wpa2UcstCipher & 0xf7 | 0x108;
    (paVar2->bssConfig).RsnConfig.MaxPwsHskRetries = '\x03';
    (paVar2->bssConfig).RsnConfig.MaxGrpHskRetries = '\x03';
    (paVar2->bssConfig).RsnConfig.PwsHskTimeOut = 100;
    (paVar2->bssConfig).RsnConfig.GrpHskTimeOut = 100;
    (paVar2->bssConfig).RsnConfig.GrpReKeyTime = 0x15180;
  }
  return;
}



int bl60x_check_mac_status(int *is_ok)

{
  int iVar1;
  dump_data_t *pdVar2;
  
  iVar1 = 0;
  pdVar2 = dump_data_poll;
  while( true ) {
    if ((int)(uint)dump_data_ptr <= iVar1) {
      *is_ok = 0;
      return 0;
    }
    if (pdVar2->mac_debugRegHWSM2 != 0x8801e000) break;
    iVar1 = iVar1 + 1;
    pdVar2 = pdVar2 + 1;
  }
  *is_ok = 1;
  return 0;
}



void helper_record_dump(void)

{
  uint32_t *puVar1;
  dump_data_t *pdVar2;
  int iVar3;
  
  pdVar2 = dump_data_poll;
  puts("========= helper_record_dump\r\n");
  iVar3 = 0;
  while (iVar3 < (int)(uint)dump_data_ptr) {
    printf("[%d] time %ld, func %s\r\n",iVar3,pdVar2->time,pdVar2->func_name);
    printf("MAC: %08lx: rxControlCs %d,txControlCs %d,macControlCs %d\r\n",pdVar2->mac_debugRegHWSM2
           ,pdVar2->mac_debugRegHWSM2 & 0x3f,pdVar2->mac_debugRegHWSM2 >> 8 & 0x1ff,
           (uint)*(byte *)((int)&pdVar2->mac_debugRegHWSM2 + 3));
    iVar3 = iVar3 + 1;
    printf("MAC: Coex %04x,Backoff %04x,MPIF %04x,MPIF2 %04x\r\n",(uint)pdVar2->mac_debugPortCoex,
           (uint)pdVar2->mac_debugPortBackoff,(uint)pdVar2->mac_debugPortMacPhyIf,
           (uint)pdVar2->mac_debugPortMacPhyIf2);
    printf("PHY: MainFSM %04x,TDTX %04x,DSSSCCK1 %04x,DSSSCCKTx %04x\r\n",
           (uint)pdVar2->phy_debugPortMainFSM,(uint)pdVar2->phy_debugPortTDTX,
           (uint)pdVar2->phy_debugPortDSSSCCK1,(uint)pdVar2->phy_debugPortDSSSCCKTx);
    puVar1 = &pdVar2->rf_state;
    pdVar2 = pdVar2 + 1;
    printf("RFC: RC %s, RF %s\r\n",rf_state_str[*puVar1]);
  }
  printf("\r\n\r\n");
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void helper_record_rc_rf_states(uint *param_1,uint *param_2)

{
  uint uVar1;
  
  _DAT_40001220 = _DAT_40001220 & 0xfffffff | 0x20000000;
  uVar1 = _DAT_40001224 >> 0x19;
  *param_1 = _DAT_40001224 >> 0x1c & 7;
  *param_2 = uVar1 & 7;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void helper_record_all_states(char *func_name)

{
  uint32_t uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  
  uVar1 = _DAT_44b00120;
  uVar4 = (uint)dump_data_ptr;
  dump_data_poll[uVar4].func_name = func_name;
  dump_data_poll[uVar4].time = uVar1;
  helper_record_rc_rf_states(uVar4 * 0x28 + 0x42012024,uVar4 * 0x28 + 0x42012028);
  dump_data_poll[uVar4].mac_debugRegHWSM1 = _DAT_44b00500;
  dump_data_poll[uVar4].mac_debugRegHWSM2 = _DAT_44b00504;
  _DAT_44b00510 = _DAT_44b00510 & 0xffff0000 | 0x31;
  *(undefined4 *)&dump_data_poll[uVar4].mac_debugPortCoex = _DAT_44b0050c;
  _DAT_44b00510 = _DAT_44b00510 & 0xffff0000 | 0x2f0b;
  *(undefined4 *)&dump_data_poll[uVar4].mac_debugPortMacPhyIf = _DAT_44b0050c;
  _DAT_44900068 = _DAT_44900068 & 0xffff0000 | 0x14;
  _DAT_400000d0 = 4;
  _DAT_400000d4 = 0x40000004;
  _DAT_400000d8 = 0x80000004;
  _DAT_400000dc = 0xc0000004;
  uVar2 = _DAT_400000e0 & 0xfffffffe;
  uVar3 = _DAT_400000e0 >> 1;
  _DAT_400000e0 = uVar2;
  dump_data_poll[uVar4].phy_debugPortTDTX = (uint16_t)uVar3;
  dump_data_poll[uVar4].phy_debugPortMainFSM = (ushort)(uVar2 >> 0x11);
  _DAT_44900074 = 0xb09;
  uVar2 = _DAT_400000e0 & 0xfffffffe;
  uVar3 = _DAT_400000e0 >> 1;
  _DAT_400000e0 = uVar2;
  dump_data_poll[uVar4].phy_debugPortDSSSCCK1 = (uint16_t)uVar3;
  dump_data_poll[uVar4].phy_debugPortDSSSCCKTx = (ushort)(uVar2 >> 0x11);
  dump_data_ptr = dump_data_ptr + 1 & 0xf;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

u32_conflict3 ipc_emb2app_rawstatus_get(void)

{
  return _DAT_44800004;
}



void ipc_host_init(ipc_host_env_tag *env,ipc_host_cb_tag *cb,
                  ipc_shared_env_tag_conflict3 *shared_env_ptr,void *pthis)

{
  printf("[IPC] [TX] Low level size %d, driver size %d, total size %d\r\n",internel_cal_size_tx_desc
         ,internel_cal_size_tx_hdr,internel_cal_size_tx_desc + internel_cal_size_tx_hdr);
  utils_list_init(&tx_list_bl);
  memset(env,0,0xe4);
  *(ipc_shared_env_tag_conflict3 **)&env->shared = shared_env_ptr;
  memcpy(env,cb,0x20);
  env->rx_bufnb = 2;
  env->rxdesc_nb = '\x02';
  env->ipc_e2amsg_bufnb = 8;
  env->ipc_e2amsg_bufsz = 0x3e0;
  env->pthis = pthis;
  env->rx_bufsz = 0x800;
  env->tx_host_id = env->tx_host_id0;
  env->txdesc = (txdesc_host *)shared_env_ptr->txdesc0;
  memset((txdesc_host *)shared_env_ptr->txdesc0,0,0xcc0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int ipc_host_msg_push(ipc_host_env_tag *env,void *msg_buf,uint16_t len)

{
  undefined2 in_register_00002032;
  int iVar1;
  ipc_shared_env_tag_conflict30 *piVar2;
  int iVar3;
  
  iVar1 = *(int *)((int)msg_buf + 0xc);
  piVar2 = env->shared;
  iVar3 = 0;
  while (iVar3 < CONCAT22(in_register_00002032,len)) {
    *(undefined4 *)((int)(piVar2->msg_a2e_buf).msg + iVar3) = *(undefined4 *)(iVar1 + iVar3);
    iVar3 = iVar3 + 4;
  }
  env->msga2e_hostid = msg_buf;
  _DAT_44800000 = 2;
  return 0;
}



uint32_t ipc_host_get_rawstatus(ipc_host_env_tag *env)

{
  u32_conflict3 uVar1;
  
  uVar1 = ipc_emb2app_rawstatus_get();
  return uVar1;
}



txdesc_host * ipc_host_txdesc_get(ipc_host_env_tag *env)

{
  uint uVar1;
  uint uVar2;
  
  uVar1 = env->txdesc_used_idx;
  uVar2 = env->txdesc_free_idx;
  if (uVar2 < uVar1) {
    used_issue = used_issue + 1;
  }
  if (uVar1 + 4 != uVar2) {
    if (uVar2 - uVar1 < 5) {
      return env->txdesc + (uVar2 & 3);
    }
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  return (txdesc_host *)0x0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_host_txdesc_push(ipc_host_env_tag *env,void *host_id)

{
  uint uVar1;
  
  uVar1 = env->txdesc_free_idx & 3;
  env->txdesc[uVar1].ready = 0xffffffff;
  env->tx_host_id[uVar1] = host_id;
  env->txdesc_free_idx = env->txdesc_free_idx + 1;
  _DAT_44800000 = 0x100;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_host_irq(ipc_host_env_tag *env,uint32_t status)

{
  uint uVar1;
  uint8_t uVar2;
  int iVar3;
  undefined3 extraout_var;
  void *pvVar4;
  anon_subr_uint8_t_void_ptr_void_ptr_for_recv_msgack_ind *paVar5;
  uint uVar6;
  int *piVar7;
  uint uVar8;
  
  uVar1 = _DAT_4480001c | status;
  _DAT_44800008 = status;
  if ((uVar1 & 0x780) != 0) {
    piVar7 = nx_txdesc_cnt_msk;
    uVar8 = 7;
    do {
      if ((1 << (uVar8 & 0x1f) & uVar1) != 0) {
        while( true ) {
          uVar6 = env->txdesc_used_idx & *piVar7;
          if ((env->tx_host_id[uVar6] == (void *)0x0) ||
             (iVar3 = (*(env->cb).send_data_cfm)(env->pthis,env->tx_host_id[uVar6]), iVar3 != 0))
          break;
          env->tx_host_id[uVar6] = (void *)0x0;
          env->txdesc_used_idx = env->txdesc_used_idx + 1;
          bl_tx_notify();
        }
      }
      uVar8 = uVar8 + 1;
      piVar7 = (int *)((uint *)piVar7 + 1);
    } while (uVar8 != 0xb);
  }
  bl_tx_resend();
  if ((uVar1 & 4) != 0) {
    pvVar4 = env->msga2e_hostid;
    env->msga2e_cnt = env->msga2e_cnt + '\x01';
    paVar5 = (env->cb).recv_msgack_ind;
    env->msga2e_hostid = (void *)0x0;
    (*paVar5)(env->pthis,pvVar4);
  }
  if ((uVar1 & 1) != 0) {
    do {
      uVar2 = (*(env->cb).recv_dbg_ind)
                        (env->pthis,
                         (&(env->cb).recv_data_ind)[((uint)env->ipc_host_dbg_idx + 0x16) * 2]);
    } while (CONCAT31(extraout_var,uVar2) == 0);
  }
  if ((uVar1 & 0x10) != 0) {
    (*(env->cb).prim_tbtt_ind)(env->pthis);
  }
  if ((uVar1 & 0x20) != 0) {
                    // WARNING: Could not recover jumptable at 0x230223be. Too many branches
                    // WARNING: Treating indirect jump as call
    (*(env->cb).sec_tbtt_ind)(env->pthis);
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_host_enable_irq(ipc_host_env_tag *env,uint32_t value)

{
  _DAT_4480000c = value;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_host_disable_irq_e2a(void)

{
  _DAT_44800010 = 0x7ff;
  return;
}



int bl_main_disconnect(void)

{
  bl_send_sm_disconnect_req(&wifi_hw,0x34);
  return 0;
}



int bl_main_powersaving(int mode)

{
  int iVar1;
  
  iVar1 = bl_send_mm_powersaving_req(&wifi_hw,mode);
  return iVar1;
}



int bl_main_denoise(int mode)

{
  int iVar1;
  
  iVar1 = bl_send_mm_denoise_req(&wifi_hw,mode);
  return iVar1;
}



int bl_main_monitor(void)

{
  undefined auStack56 [4];
  mm_monitor_cfm cfm;
  
  memset(auStack56,0,0x28);
  bl_send_monitor_enable(&wifi_hw,(mm_monitor_cfm *)auStack56);
  return 0;
}



int bl_main_phy_up(void)

{
  int iVar1;
  
  iVar1 = bl_send_start(&wifi_hw);
  if (iVar1 == 0) {
    wifi_hw.drv_flags = wifi_hw.drv_flags | 4;
  }
  else {
    iVar1 = -1;
  }
  return iVar1;
}



int bl_main_monitor_channel_set(int channel,int use_40MHZ)

{
  undefined auStack56 [4];
  mm_monitor_channel_cfm cfm;
  
  bl_send_monitor_channel_set(&wifi_hw,(mm_monitor_channel_cfm *)auStack56,channel,use_40MHZ);
  return 0;
}



int bl_main_if_remove(uint8_t vif_index)

{
  undefined3 in_register_00002029;
  
  printf("[WF] MM_REMOVE_IF_REQ Sending with vif_index %u...\r\n",
         CONCAT31(in_register_00002029,vif_index));
  bl_send_remove_if(&wifi_hw,vif_index);
  printf("[WF] MM_REMOVE_IF_REQ Done\r\n");
  return 0;
}



int bl_main_raw_send(uint8_t *pkt,int len)

{
  int iVar1;
  
  iVar1 = bl_send_scanu_raw_send(&wifi_hw,pkt,len);
  return iVar1;
}



int bl_main_rate_config(uint8_t sta_idx,uint16_t fixed_rate_cfg)

{
  int iVar1;
  
  iVar1 = bl_send_me_rate_config_req(&wifi_hw,sta_idx,fixed_rate_cfg);
  return iVar1;
}



int bl_main_set_country_code(char *country_code)

{
  bl_msg_update_channel_cfg(country_code);
  bl_send_me_chan_config_req(&wifi_hw);
  return 0;
}



int bl_main_get_channel_nums(void)

{
  return channel_num_default;
}



int bl_main_if_add(int is_sta,netif *netif,uint8_t *vif_index)

{
  uint uVar1;
  int iVar2;
  undefined *puVar3;
  mm_add_if_cfm amStack36 [2];
  mm_add_if_cfm add_if_cfm;
  
  if (is_sta == 0) {
    puVar3 = &UNK_2307b2d0;
  }
  else {
    puVar3 = &UNK_2307b2cc;
  }
  printf("[WF] MM_ADD_IF_REQ Sending: %s\r\n",puVar3);
  iVar2 = bl_send_add_if(&wifi_hw,netif->hwaddr,(is_sta == 0) + NL80211_IFTYPE_STATION,false,
                         amStack36);
  printf("[WF] MM_ADD_IF_REQ Done\r\n");
  if (iVar2 == 0) {
    if (amStack36[0].status == '\0') {
      uVar1 = (uint)amStack36[0].inst_nbr;
      if (is_sta != 0) {
        wifi_hw.vif_index_sta = (uint)amStack36[0].inst_nbr;
        uVar1 = wifi_hw.vif_index_ap;
      }
      wifi_hw.vif_index_ap = uVar1;
      *vif_index = amStack36[0].inst_nbr;
      printf("[WF] vif_index from LAMC is %d\r\n");
      wifi_hw.vif_table[amStack36[0].inst_nbr].dev = netif;
      wifi_hw.vif_table[amStack36[0].inst_nbr].up = true;
    }
    else {
      printf("%s: Status Error(%d)\n",&UNK_2307b314);
      iVar2 = -5;
    }
  }
  return iVar2;
}



int bl_main_apm_start(char *ssid,char *password,int channel,uint8_t vif_index,uint8_t hidden_ssid)

{
  int iVar1;
  undefined3 in_register_00002035;
  apm_start_cfm local_24;
  apm_start_cfm start_ap_cfm;
  
  memset(&local_24,0,4);
  printf("[WF] APM_START_REQ Sending with vif_index %u\r\n",CONCAT31(in_register_00002035,vif_index)
        );
  iVar1 = bl_send_apm_start_req(&wifi_hw,&local_24,ssid,password,channel,vif_index,hidden_ssid);
  printf("[WF] APM_START_REQ Done\r\n");
  printf("[WF] status is %02X\r\n",(uint)local_24.status);
  printf("[WF] vif_idx is %02X\r\n",(uint)local_24.vif_idx);
  printf("[WF] ch_idx is %02X\r\n",(uint)local_24.ch_idx);
  printf("[WF] bcmc_idx is %02X\r\n",(uint)local_24.bcmc_idx);
  wifi_hw.ap_bcmc_idx = (uint)local_24.bcmc_idx;
  return iVar1;
}



int bl_main_apm_stop(uint8_t vif_index)

{
  undefined3 in_register_00002029;
  int iVar1;
  
  printf("[WF] APM_STOP_REQ Sending with vif_index %u\r\n",CONCAT31(in_register_00002029,vif_index))
  ;
  iVar1 = bl_send_apm_stop_req(&wifi_hw,vif_index);
  printf("[WF] APM_STOP_REQ Done\r\n");
  return iVar1;
}



int bl_main_apm_sta_cnt_get(uint8_t *sta_cnt)

{
  *sta_cnt = '\f';
  return 0;
}



int bl_main_apm_sta_info_get(wifi_apm_sta_info *apm_sta_info,uint8_t idx)

{
  undefined3 in_register_0000202d;
  int iVar1;
  
  iVar1 = CONCAT31(in_register_0000202d,idx);
  if (wifi_hw.sta_table[iVar1].is_used != '\0') {
    apm_sta_info->sta_idx = wifi_hw.sta_table[iVar1].sta_idx;
    apm_sta_info->is_used = wifi_hw.sta_table[iVar1].is_used;
    apm_sta_info->rssi = (int)wifi_hw.sta_table[iVar1].rssi;
    apm_sta_info->tsflo = wifi_hw.sta_table[iVar1].tsflo;
    apm_sta_info->tsfhi = wifi_hw.sta_table[iVar1].tsfhi;
    apm_sta_info->data_rate = wifi_hw.sta_table[iVar1].data_rate;
    memcpy(apm_sta_info->sta_mac,wifi_hw.sta_table + iVar1,6);
    return 0;
  }
  return 0;
}



int bl_main_apm_sta_delete(uint8_t sta_idx)

{
  byte vif_idx;
  undefined3 in_register_00002029;
  int iVar1;
  int iVar2;
  apm_sta_del_cfm aStack36;
  apm_sta_del_cfm sta_del_cfm;
  
  iVar1 = CONCAT31(in_register_00002029,sta_idx);
  memset(&aStack36,0,3);
  vif_idx = wifi_hw.sta_table[iVar1].vif_idx;
  printf("[WF] APM_STA_DEL_REQ: sta_idx = %u, vif_idx = %u\r\n",iVar1,(uint)vif_idx);
  bl_send_apm_sta_del_req(&wifi_hw,&aStack36,sta_idx,vif_idx);
  iVar2 = -1;
  if (aStack36.status == '\0') {
    memset(wifi_hw.sta_table + iVar1,0,0x1c);
    iVar2 = 0;
  }
  return iVar2;
}



int bl_main_apm_remove_all_sta(void)

{
  uint8_t sta_idx;
  u8 *puVar1;
  
  puVar1 = &wifi_hw.sta_table[0].is_used;
  sta_idx = '\0';
  do {
    if (*puVar1 == '\x01') {
      bl_main_apm_sta_delete(sta_idx);
    }
    sta_idx = sta_idx + '\x01';
    puVar1 = puVar1 + 0x1c;
  } while (sta_idx != '\f');
  return 0;
}



int bl_main_conf_max_sta(uint8_t max_sta_supported)

{
  int iVar1;
  
  iVar1 = bl_send_apm_conf_max_sta_req(&wifi_hw,max_sta_supported);
  return iVar1;
}



int bl_main_cfg_task_req
              (uint32_t ops,uint32_t task,uint32_t element,uint32_t type,void *arg1,void *arg2)

{
  int iVar1;
  
  iVar1 = bl_send_cfg_task_req(&wifi_hw,ops,task,element,type,arg1,arg2);
  return iVar1;
}



int bl_main_scan(void)

{
  bl_send_scanu_req(&wifi_hw);
  return 0;
}



int bl_cfg80211_connect(bl_hw *bl_hw,cfg80211_connect_params *sme)

{
  int iVar1;
  sm_connect_cfm asStack20 [4];
  sm_connect_cfm sm_connect_cfm;
  
  iVar1 = bl_send_sm_connect_req(bl_hw,sme,asStack20);
  if (iVar1 == 0) {
    iVar1 = -5;
    if ((byte)asStack20[0] < 10) {
      iVar1 = (int)(char)CSWTCH_6[(byte)asStack20[0]];
    }
  }
  return iVar1;
}



// WARNING: Could not reconcile some variable overlaps

int bl_main_connect(uint8_t *ssid,int ssid_len,uint8_t *psk,int psk_len,uint8_t *pmk,int pmk_len,
                   uint8_t *mac,uint8_t band,uint16_t freq)

{
  short in_stack_00000000;
  nl80211_band anStack272 [4];
  cfg80211_connect_params sme;
  
  memset(anStack272,0,0xf0);
  sme.crypto.cipher_group = 0;
  sme.ssid_len._0_1_ = __NL80211_AUTHTYPE_NUM;
  sme.pmk._0_1_ = (u8)psk_len;
  sme.pmk._1_1_ = (u8)pmk_len;
  if (mac != (uint8_t *)0x0) {
    sme.channel_hint = (ieee80211_channel *)mac;
  }
  if (in_stack_00000000 != 0) {
    sme.channel._4_4_ = 0;
    anStack272[0] = band;
  }
  sme.bssid_hint = ssid;
  sme.ssid = (u8 *)ssid_len;
  sme.crypto.wep_tx_key = (int)psk;
  sme.key = pmk;
  bl_cfg80211_connect(&wifi_hw,(cfg80211_connect_params *)anStack272);
  return 0;
}



void bl_main_event_handle(void)

{
  bl_irq_bottomhalf(&wifi_hw);
  bl_tx_try_flush();
  return;
}



void bl_main_lowlevel_init(void)

{
  bl_irqs_init(&wifi_hw);
  return;
}



int bl_main_rtthread_start(bl_hw **bl_hw)

{
  int iVar1;
  char *__format;
  
  bl_main_lowlevel_init();
  *bl_hw = &wifi_hw;
  wifi_hw.vifs.next = &wifi_hw.vifs;
  wifi_hw.vifs.prev = &wifi_hw.vifs;
  wifi_hw.mod_params = &bl_mod_params;
  iVar1 = bl_platform_on(&wifi_hw);
  if (iVar1 == 0) {
    ipc_host_enable_irq(wifi_hw.ipc_env,0x7ff);
    bl_wifi_enable_irq();
    iVar1 = bl_send_reset(&wifi_hw);
    if (iVar1 == 0) {
      vTaskDelay(5);
      iVar1 = bl_send_version_req(&wifi_hw,&wifi_hw.version_cfm);
      if (iVar1 != 0) {
        return 0;
      }
      printf("[version] lmac %u.%u.%u.%u\r\n",wifi_hw.version_cfm.version_lmac >> 0x18,
             wifi_hw.version_cfm.version_lmac >> 0x10 & 0xff,
             wifi_hw.version_cfm.version_lmac >> 8 & 0xff,wifi_hw.version_cfm.version_lmac & 0xff);
      printf("[version] version_machw_1 %08X\r\n",wifi_hw.version_cfm.version_machw_1);
      printf("[version] version_machw_2 %08X\r\n",wifi_hw.version_cfm.version_machw_2);
      printf("[version] version_phy_1 %08X\r\n",wifi_hw.version_cfm.version_phy_1);
      printf("[version] version_phy_2 %08X\r\n",wifi_hw.version_cfm.version_phy_2);
      printf("[version] features %08X\r\n",wifi_hw.version_cfm.features);
      iVar1 = bl_handle_dynparams(&wifi_hw);
      if (iVar1 == 0) {
        bl_send_me_config_req(&wifi_hw);
        bl_send_me_chan_config_req(&wifi_hw);
        wifi_hw.status = RWNX_INTERFACE_STATUS_UP;
        return 0;
      }
      __format = "bl_handle_dynparams Error\r\n";
    }
    else {
      __format = "bl_send_reset Error\r\n";
    }
  }
  else {
    __format = "bl_platform_on Error\r\n";
  }
  printf(__format);
  return 0;
}



int bl_handle_dynparams(bl_hw *bl_hw)

{
  ushort uVar1;
  short sVar2;
  char "bl_handle_dynparams" [20];
  int iVar3;
  short sVar4;
  uint uVar5;
  bl_mod_params *pbVar6;
  
  uVar5 = bl_hw->flags;
  bl_hw->flags = uVar5 | 0x40000;
  pbVar6 = bl_hw->mod_params;
  if (pbVar6->tdls != false) {
    bl_hw->flags = uVar5 | 0x58000;
  }
  if (pbVar6->ap_uapsd_on != false) {
    bl_hw->flags = bl_hw->flags | 0x4000;
  }
  if (5 < (uint)pbVar6->phy_cfg) {
    pbVar6->phy_cfg = 2;
  }
  if (2 < (uint)bl_hw->mod_params->mcs_map) {
    bl_hw->mod_params->mcs_map = 0;
  }
  uVar1 = (bl_hw->ht_cap).cap;
  pbVar6 = bl_hw->mod_params;
  iVar3 = pbVar6->nss;
  (bl_hw->ht_cap).cap = uVar1 | 0x100;
  if (pbVar6->ldpc_on != false) {
    (bl_hw->ht_cap).cap = uVar1 | 0x101;
  }
  sVar2 = (short)iVar3;
  if (pbVar6->use_2040 == false) {
    (bl_hw->ht_cap).mcs.rx_highest = sVar2 * 0x41;
    (bl_hw->ht_cap).mcs.rx_mask[0] = -1;
  }
  else {
    uVar1 = (bl_hw->ht_cap).cap;
    (bl_hw->ht_cap).mcs.rx_mask[4] = '\x01';
    (bl_hw->ht_cap).cap = uVar1 | 2;
    (bl_hw->ht_cap).mcs.rx_highest = sVar2 * 0x87;
  }
  if (1 < iVar3) {
    (bl_hw->ht_cap).cap = (bl_hw->ht_cap).cap | 0x80;
  }
  if (pbVar6->sgi != false) {
    uVar1 = (bl_hw->ht_cap).cap;
    (bl_hw->ht_cap).cap = uVar1 | 0x20;
    if (pbVar6->use_2040 == false) {
      sVar4 = 0x48;
    }
    else {
      (bl_hw->ht_cap).cap = uVar1 | 0x60;
      sVar4 = 0x96;
    }
    (bl_hw->ht_cap).mcs.rx_highest = sVar2 * sVar4;
  }
  (bl_hw->ht_cap).cap = (bl_hw->ht_cap).cap | 0xc;
  if (pbVar6->ht_on == false) {
    (bl_hw->ht_cap).ht_supported = false;
  }
  if (pbVar6->custregd != false) {
    printf("\n\n%s: CAUTION: USING PERMISSIVE CUSTOM REGULATORY RULES\n\n","bl_handle_dynparams");
    return 0;
  }
  return 0;
}



int bl_send_msg(bl_hw *bl_hw,void *msg_params,int reqcfm,lmac_msg_id_t reqid,void *cfm)

{
  ushort uVar1;
  lmac_msg_id_t lVar2;
  bool bVar3;
  char "bl_send_msg" [12];
  bl_cmd *__s;
  int iVar4;
  undefined2 in_register_00002036;
  lmac_msg *pv;
  
  iVar4 = CONCAT22(in_register_00002036,reqid);
  pv = (lmac_msg *)((int)msg_params + -8);
  if ((((((bl_hw->drv_flags >> 2 & 1) == 0) && ((reqid & 0xfffd) != 1)) && (iVar4 != 5)) &&
      ((iVar4 != 0x23 && ((reqid & 0xfffd) != 0x1401)))) && (iVar4 != 0x32)) {
    printf("%s: bypassing (RWNX_DEV_RESTARTING set) 0x%02x\n","bl_send_msg",iVar4);
  }
  else {
    if (bl_hw->ipc_env != (ipc_host_env_tag *)0x0) {
      uVar1 = *(ushort *)((int)msg_params + -8);
      bVar3 = true;
      if (((uVar1 != 0x41) && (uVar1 != 0x50)) && ((uVar1 + 0xebf4 & 0xfffb) != 0)) {
        bVar3 = (uVar1 & 0xfffb) == 0x2408;
      }
      __s = (bl_cmd *)pvPortMalloc(0x40);
      if (__s == (bl_cmd *)0x0) {
        vPortFree(pv);
        printf("%s: failed to allocate mem for cmd, size is %d\r\n",0x2307b550,0x40);
        return -0xc;
      }
      memset(__s,0,0x40);
      __s->result = 4;
      lVar2 = *(lmac_msg_id_t *)((int)msg_params + -8);
      __s->reqid = reqid;
      __s->a2e_msg = pv;
      __s->id = lVar2;
      __s->e2a_msg = cfm;
      if (bVar3) {
        __s->flags = 1;
      }
      if (reqcfm != 0) {
        __s->flags = __s->flags | 2;
      }
      iVar4 = (*(bl_hw->cmd_mgr).queue)(&bl_hw->cmd_mgr,__s);
      if (!bVar3) {
        vPortFree(__s);
        return iVar4;
      }
      return __s->result;
    }
    printf("%s: bypassing (restart must have failed)\r\n",0x2307b550);
  }
  vPortFree(pv);
  return -0x10;
}



void * bl_msg_zalloc(lmac_msg_id_t id,lmac_task_id_t dest_id,uint16_t param_len)

{
  lmac_msg_id_t *__s;
  undefined2 in_register_00002032;
  size_t xWantedSize;
  
  xWantedSize = CONCAT22(in_register_00002032,param_len) + 8;
  __s = (lmac_msg_id_t *)pvPortMalloc(xWantedSize);
  if (__s == (lmac_msg_id_t *)0x0) {
    printf("%s: msg allocation failed\n",0x2307b540);
  }
  else {
    memset(__s,0,xWantedSize);
    *__s = id;
    __s[1] = dest_id;
    __s[2] = 100;
    __s[3] = param_len;
    __s = __s + 4;
  }
  return __s;
}



void bl_msg_update_channel_cfg(char *code)

{
  int iVar1;
  int iVar2;
  char *__format;
  ieee80211_dot_d *piVar3;
  
  piVar3 = country_list;
  iVar1 = 0;
  do {
    iVar2 = strcmp(piVar3->code,code);
    if (iVar2 == 0) {
      __format = "[WF] country code %s used, num of channel %d\r\n";
      channel_num_default = country_list[iVar1].channel_num;
      channels_default = country_list[iVar1].channels;
      goto LAB_23022de2;
    }
    iVar1 = iVar1 + 1;
    piVar3 = piVar3 + 1;
  } while (iVar1 != 4);
  channel_num_default = 0xe;
  __format = "[WF] %s NOT found, using JP instead, num of channel %d\r\n";
  channels_default = bl_channels_24_JP;
LAB_23022de2:
  printf(__format,code,channel_num_default);
  return;
}



int bl_msg_get_channel_nums(void)

{
  return channel_num_default;
}



int bl_send_reset(bl_hw *bl_hw)

{
  void *msg_params;
  int iVar1;
  
  msg_params = bl_msg_zalloc(0,0,0);
  if (msg_params != (void *)0x0) {
    iVar1 = bl_send_msg(bl_hw,msg_params,1,1,(void *)0x0);
    return iVar1;
  }
  return -0xc;
}



int bl_send_monitor_enable(bl_hw *bl_hw,mm_monitor_cfm *cfm)

{
  undefined4 *msg_params;
  int iVar1;
  
  msg_params = (undefined4 *)bl_msg_zalloc(0x5c,0,4);
  if (msg_params != (undefined4 *)0x0) {
    *msg_params = 1;
    iVar1 = bl_send_msg(bl_hw,msg_params,1,0x5d,cfm);
    return iVar1;
  }
  return -0xc;
}



int bl_send_monitor_channel_set(bl_hw *bl_hw,mm_monitor_channel_cfm *cfm,int channel,int use_40Mhz)

{
  uint uVar1;
  uint *msg_params;
  int iVar2;
  
  msg_params = (uint *)bl_msg_zalloc(0x5e,0,0xc);
  if (msg_params == (uint *)0x0) {
    return -0xc;
  }
  if (channel - 1U < 0xe) {
    if (channel == 0xe) {
      uVar1 = 0x9b4;
    }
    else {
      uVar1 = channel * 5 + 0x967U & 0xffff;
    }
  }
  else {
    uVar1 = 0xffff;
  }
  *msg_params = uVar1;
  if (use_40Mhz == 0) {
    msg_params[1] = 0;
  }
  else {
    msg_params[1] = 1;
    if (use_40Mhz != 1) {
      msg_params[2] = 1;
      goto LAB_23022f04;
    }
  }
  msg_params[2] = 0;
LAB_23022f04:
  iVar2 = bl_send_msg(bl_hw,msg_params,1,0x5f,cfm);
  return iVar2;
}



int bl_send_version_req(bl_hw *bl_hw,mm_version_cfm *cfm)

{
  void *msg_params;
  int iVar1;
  
  msg_params = bl_msg_zalloc(4,0,0);
  if (msg_params != (void *)0x0) {
    iVar1 = bl_send_msg(bl_hw,msg_params,1,5,cfm);
    return iVar1;
  }
  return -0xc;
}



int bl_send_me_config_req(bl_hw *bl_hw)

{
  u8 *puVar1;
  u16 *msg_params;
  int iVar2;
  u8 *puVar3;
  ieee80211_mcs_info *piVar4;
  
  msg_params = (u16 *)bl_msg_zalloc(0x1400,5,0x34);
  if (msg_params != (u16 *)0x0) {
    printf("[ME] HT supp %d, VHT supp %d\r\n",1,0);
    msg_params[0x17] = 1;
    *msg_params = (bl_hw->ht_cap).cap;
    *(u8 *)(msg_params + 1) = (bl_hw->ht_cap).ampdu_density << 2 | (bl_hw->ht_cap).ampdu_factor;
    piVar4 = &(bl_hw->ht_cap).mcs;
    puVar3 = (u8 *)((int)msg_params + 3);
    while (piVar4 != (ieee80211_mcs_info *)&bl_hw->vif_started) {
      puVar1 = piVar4->rx_mask;
      piVar4 = (ieee80211_mcs_info *)(piVar4->rx_mask + 1);
      *puVar3 = *puVar1;
      puVar3 = puVar3 + 1;
    }
    msg_params[10] = 0;
    *(undefined4 *)(msg_params + 0xc) = 0;
    *(undefined *)(msg_params + 0xe) = 0;
    *(_Bool *)(msg_params + 0x18) = bl_hw->mod_params->ps_on;
    msg_params[0x16] = (u16)bl_hw->mod_params->tx_lft;
    iVar2 = bl_send_msg(bl_hw,msg_params,1,0x1401,(void *)0x0);
    return iVar2;
  }
  return -0xc;
}



int bl_send_me_chan_config_req(bl_hw *bl_hw)

{
  byte bVar1;
  void *msg_params;
  int iVar2;
  uint uVar3;
  u16 *puVar4;
  
  msg_params = bl_msg_zalloc(0x1402,5,0xfe);
  if (msg_params == (void *)0x0) {
    return -0xc;
  }
  *(undefined *)((int)msg_params + 0xfc) = 0;
  iVar2 = 0;
  while (iVar2 < channel_num_default) {
    bVar1 = *(byte *)((int)msg_params + 0xfc);
    puVar4 = (u16 *)((uint)bVar1 * 6 + (int)msg_params);
    *(undefined *)((int)puVar4 + 3) = 0;
    if ((channels_default[iVar2].flags & 1) != 0) {
      *(undefined *)((int)puVar4 + 3) = 2;
    }
    uVar3 = channels_default[iVar2].flags;
    *(undefined *)(puVar4 + 1) = 0;
    *(byte *)((int)puVar4 + 3) = (uVar3 & 10) != 0 | *(byte *)((int)puVar4 + 3);
    *puVar4 = channels_default[iVar2].center_freq;
    *(char *)(puVar4 + 2) = (char)channels_default[iVar2].max_power;
    uVar3 = (uint)bVar1 + 1 & 0xff;
    *(undefined *)((int)msg_params + 0xfc) = (char)uVar3;
    if (uVar3 == 0xe) break;
    iVar2 = iVar2 + 1;
  }
  *(undefined *)((int)msg_params + 0xfd) = 0;
  iVar2 = bl_send_msg(bl_hw,msg_params,1,0x1403,(void *)0x0);
  return iVar2;
}



int bl_send_me_rate_config_req(bl_hw *bl_hw,uchar sta_idx,uint16_t fixed_rate_cfg)

{
  uchar *msg_params;
  int iVar1;
  
  msg_params = (uchar *)bl_msg_zalloc(0x1410,5,4);
  if (msg_params != (uchar *)0x0) {
    *msg_params = sta_idx;
    *(uint16_t *)(msg_params + 2) = fixed_rate_cfg;
    iVar1 = bl_send_msg(bl_hw,msg_params,0,0,(void *)0x0);
    return iVar1;
  }
  return -0xc;
}



int bl_send_start(bl_hw *bl_hw)

{
  void *__dest;
  int iVar1;
  
  __dest = bl_msg_zalloc(2,0,0x48);
  if (__dest != (void *)0x0) {
    (bl_hw->phy_config).parameters = 1;
    memcpy(__dest,&bl_hw->phy_config,0x40);
    *(int *)((int)__dest + 0x40) = bl_hw->mod_params->uapsd_timeout;
    *(undefined2 *)((int)__dest + 0x44) = (short)bl_hw->mod_params->lp_clk_ppm;
    iVar1 = bl_send_msg(bl_hw,__dest,1,3,(void *)0x0);
    return iVar1;
  }
  return -0xc;
}



int bl_send_add_if(bl_hw *bl_hw,uchar *mac,nl80211_iftype iftype,_Bool p2p,mm_add_if_cfm *cfm)

{
  undefined *msg_params;
  int iVar1;
  undefined uVar2;
  
  msg_params = (undefined *)bl_msg_zalloc(6,0,8);
  if (msg_params == (undefined *)0x0) {
    return -0xc;
  }
  memcpy(msg_params + 1,mac,6);
  switch((uint)iftype - 1 & 0xff) {
  case 0:
    uVar2 = 1;
    break;
  case 3:
    return -1;
  case 6:
    uVar2 = 3;
    break;
  case 7:
    msg_params[7] = 1;
  default:
    *msg_params = 0;
    goto LAB_2302320e;
  case 8:
    msg_params[7] = 1;
  case 2:
    uVar2 = 2;
  }
  *msg_params = uVar2;
LAB_2302320e:
  iVar1 = bl_send_msg(bl_hw,msg_params,1,7,cfm);
  return iVar1;
}



int bl_send_remove_if(bl_hw *bl_hw,uchar inst_nbr)

{
  uchar *msg_params;
  int iVar1;
  
  msg_params = (uchar *)bl_msg_zalloc(8,0,1);
  if (msg_params != (uchar *)0x0) {
    *msg_params = inst_nbr;
    iVar1 = bl_send_msg(bl_hw,msg_params,1,9,(void *)0x0);
    return iVar1;
  }
  return -0xc;
}



int bl_send_scanu_req(bl_hw *bl_hw)

{
  u16 uVar1;
  u16 *msg_params;
  int iVar2;
  ieee80211_channel *piVar3;
  int iVar4;
  u16 *puVar5;
  
  msg_params = (u16 *)bl_msg_zalloc(0x1000,4,0x154);
  if (msg_params != (u16 *)0x0) {
    iVar4 = bl_hw->vif_index_sta;
    msg_params[0xa6] = 0;
    *(char *)(msg_params + 0xa7) = (char)iVar4;
    iVar4 = channel_num_default;
    *(undefined *)((int)msg_params + 0x14f) = (char)channel_num_default;
    *(undefined4 *)(msg_params + 0xa0) = 0xffffffff;
    msg_params[0xa2] = 0xffff;
    msg_params[0xa8] = 0x100;
    *(undefined4 *)(msg_params + 0xa4) = 0;
    iVar2 = 0;
    puVar5 = msg_params;
    while (iVar2 < (int)(iVar4 & 0xffU)) {
      piVar3 = channels_default + iVar2;
      *(nl80211_band *)(puVar5 + 1) = piVar3->band;
      uVar1 = piVar3->center_freq;
      *(undefined *)((int)puVar5 + 3) = 1;
      *puVar5 = uVar1;
      *(char *)(puVar5 + 2) = (char)piVar3->max_reg_power;
      iVar2 = iVar2 + 1;
      puVar5 = puVar5 + 3;
    }
    iVar4 = bl_send_msg(bl_hw,msg_params,0,0,(void *)0x0);
    return iVar4;
  }
  return -0xc;
}



int bl_send_scanu_raw_send(bl_hw *bl_hw,uint8_t *pkt,int len)

{
  uint8_t **msg_params;
  int iVar1;
  undefined auStack36 [4];
  scanu_raw_send_cfm cfm;
  
  msg_params = (uint8_t **)bl_msg_zalloc(0x1005,4,8);
  if (msg_params == (uint8_t **)0x0) {
    iVar1 = -0xc;
  }
  else {
    *msg_params = pkt;
    *(int *)(msg_params + 1) = len;
    iVar1 = bl_send_msg(bl_hw,msg_params,1,0x1006,auStack36);
  }
  return iVar1;
}



int bl_send_sm_connect_req(bl_hw *bl_hw,cfg80211_connect_params *sme,sm_connect_cfm *cfm)

{
  _Bool _Var1;
  char "bl_send_sm_connect_req" [23];
  undefined *msg_params;
  int iVar2;
  nl80211_auth_type nVar3;
  u32_conflict15 uVar4;
  uint uVar5;
  uint uVar6;
  __be16 _Var7;
  u8 *puVar8;
  uint __n;
  
  msg_params = (undefined *)bl_msg_zalloc(0x1800,6,0x1c4);
  if (msg_params == (undefined *)0x0) {
    return -0xc;
  }
  __n = 0;
  if ((sme->crypto).n_ciphers_pairwise != 0) {
    uVar4 = (sme->crypto).ciphers_pairwise[0];
    __n = 4;
    if ((1 < uVar4 - 0xfac01) && (__n = 0, uVar4 == 0xfac05)) {
      __n = 4;
    }
  }
  if ((sme->crypto).control_port != false) {
    __n = __n | 1;
  }
  if ((sme->crypto).control_port_no_encrypt != false) {
    __n = __n | 2;
  }
  if (((sme->crypto).cipher_group & 0xfffffffb) != 0xfac01) {
    __n = __n | 8;
  }
  if (sme->mfp == NL80211_MFP_REQUIRED) {
    __n = __n | 0x10;
  }
  _Var7 = (sme->crypto).control_port_ethertype;
  if (_Var7 == 0) {
    _Var7 = 0x888e;
  }
  *(__be16 *)(msg_params + 0x34) = _Var7;
  puVar8 = sme->bssid;
  if (puVar8 == (u8 *)0x0) {
LAB_23023458:
    memcpy(msg_params + 0x22,&mac_addr_bcst,6);
  }
  else {
    if (*puVar8 == -1) {
      uVar5 = 0;
      if (((puVar8[1] == -1) && (puVar8[2] == -1)) &&
         ((puVar8[3] == -1 && ((puVar8[4] == -1 && (puVar8[5] == -1)))))) goto LAB_23023458;
    }
    else {
      if ((((*puVar8 == '\0') && (puVar8[1] == '\0')) && (puVar8[2] == '\0')) &&
         ((puVar8[3] == '\0' && (uVar5 = (uint)puVar8[4], puVar8[4] == 0)))) {
        if (puVar8[5] == '\0') goto LAB_23023458;
      }
      else {
        uVar5 = 0;
      }
    }
    do {
      uVar6 = uVar5 + 1;
      msg_params[uVar5 + 0x22] = sme->bssid[uVar5];
      uVar5 = uVar6;
    } while (uVar6 != 6);
  }
  msg_params[0x3d] = (char)bl_hw->vif_index_sta;
  if ((sme->channel).center_freq == 0) {
    *(undefined2 *)(msg_params + 0x28) = 0xffff;
  }
  else {
    msg_params[0x2a] = (sme->channel).band;
    *(u16 *)(msg_params + 0x28) = (sme->channel).center_freq;
    *(bool *)(msg_params + 0x2b) = ((sme->channel).flags & 10) != 0;
  }
  uVar5 = 0;
  while (uVar5 < sme->ssid_len) {
    msg_params[uVar5 + 1] = sme->ssid[uVar5];
    uVar5 = uVar5 + 1;
  }
  *msg_params = (char)sme->ssid_len;
  *(uint *)(msg_params + 0x30) = __n;
  __n = sme->ie_len;
  if (0x100 < __n) {
    printf("%s:%d\r\n","bl_send_sm_connect_req",0x30a);
    return -0x16;
  }
  if (__n != 0) {
    memcpy(msg_params + 0x40,sme->ie,__n);
  }
  *(short *)(msg_params + 0x36) = (short)sme->ie_len;
  _Var1 = bl_mod_params.listen_bcmc;
  *(short *)(msg_params + 0x38) = (short)bl_mod_params.listen_itv;
  msg_params[0x3a] = _Var1 ^ 1;
  nVar3 = sme->auth_type;
  if (nVar3 == __NL80211_AUTHTYPE_NUM) {
    nVar3 = NL80211_AUTHTYPE_OPEN_SYSTEM;
  }
  msg_params[0x3b] = nVar3;
  msg_params[0x3c] = (char)bl_mod_params.uapsd_queues;
  msg_params[0x140] = 1;
  if (sme->key_len != 0) {
    memcpy(msg_params + 0x141,sme->key,(uint)sme->key_len);
  }
  if (sme->pmk_len != 0) {
    memcpy(msg_params + 0x181,sme->pmk,(uint)sme->pmk_len);
  }
  iVar2 = bl_send_msg(bl_hw,msg_params,1,0x1801,cfm);
  return iVar2;
}



int bl_send_sm_disconnect_req(bl_hw *bl_hw,u16 reason)

{
  u16 *msg_params;
  int iVar1;
  
  msg_params = (u16 *)bl_msg_zalloc(0x1803,6,4);
  if (msg_params != (u16 *)0x0) {
    *msg_params = reason;
    *(char *)(msg_params + 1) = (char)bl_hw->vif_index_sta;
    iVar1 = bl_send_msg(bl_hw,msg_params,1,0x1804,(void *)0x0);
    return iVar1;
  }
  return -0xc;
}



int bl_send_mm_powersaving_req(bl_hw *bl_hw,int mode)

{
  undefined *msg_params;
  int iVar1;
  
  msg_params = (undefined *)bl_msg_zalloc(0x31,0,1);
  if (msg_params != (undefined *)0x0) {
    *msg_params = (char)mode;
    iVar1 = bl_send_msg(bl_hw,msg_params,1,0x32,(void *)0x0);
    return iVar1;
  }
  return -0xc;
}



int bl_send_mm_denoise_req(bl_hw *bl_hw,int mode)

{
  undefined *msg_params;
  int iVar1;
  
  msg_params = (undefined *)bl_msg_zalloc(0x30,0,1);
  if (msg_params != (undefined *)0x0) {
    *msg_params = (char)mode;
    iVar1 = bl_send_msg(bl_hw,msg_params,1,0x32,(void *)0x0);
    return iVar1;
  }
  return -0xc;
}



int bl_send_apm_start_req
              (bl_hw *bl_hw,apm_start_cfm *cfm,char *ssid,char *password,int channel,uchar vif_index
              ,uchar hidden_ssid)

{
  void *msg_params;
  size_t __n;
  int iVar1;
  uint uVar2;
  undefined auStack44 [4];
  uint8_t rate [12];
  
  memcpy(auStack44,&DAT_2307b534,0xc);
  msg_params = bl_msg_zalloc(0x1c00,7,0xa8);
  if (msg_params == (void *)0x0) {
    iVar1 = -0xc;
  }
  else {
    *(undefined *)((int)msg_params + 0x10) = 0;
    if (channel - 1U < 0xe) {
      if (channel == 0xe) {
        uVar2 = 0x9b4;
      }
      else {
        uVar2 = channel * 5 + 0x967U & 0xffff;
      }
    }
    else {
      uVar2 = 0xffff;
    }
    *(undefined2 *)((int)msg_params + 0xe) = (short)uVar2;
    *(uint *)((int)msg_params + 0x14) = uVar2;
    *(undefined2 *)((int)msg_params + 0x28) = 100;
    *(undefined4 *)((int)msg_params + 0x2c) = 8;
    *(undefined2 *)((int)msg_params + 0x30) = 0x8e88;
    *(undefined *)((int)msg_params + 0x32) = 6;
    *(uchar *)((int)msg_params + 0x1d) = hidden_ssid;
    *(uchar *)((int)msg_params + 0x33) = vif_index;
    *(undefined *)((int)msg_params + 0x11) = 0;
    *(undefined *)((int)msg_params + 0x12) = 0;
    *(undefined4 *)((int)msg_params + 0x18) = 0;
    *(undefined *)((int)msg_params + 0x1c) = 0;
    *(undefined4 *)((int)msg_params + 0x20) = 0;
    *(undefined4 *)((int)msg_params + 0x24) = 0;
    __n = strlen(password);
    *(undefined *)((int)msg_params + 0x34) = 1;
    *(bool *)((int)msg_params + 0x66) = __n != 0;
    __n = strlen(ssid);
    memcpy((void *)((int)msg_params + 0x45),ssid,__n);
    __n = strlen(password);
    memcpy((void *)((int)msg_params + 0x67),password,__n);
    __n = strlen(ssid);
    *(undefined *)((int)msg_params + 0x44) = (char)__n;
    *(undefined *)((int)msg_params + 0x35) = 0xc;
    memcpy((void *)((int)msg_params + 0x36),auStack44,0xc);
    *(undefined2 *)((int)msg_params + 0x42) = 0x101;
    iVar1 = bl_send_msg(bl_hw,msg_params,1,0x1c01,cfm);
  }
  return iVar1;
}



int bl_send_apm_stop_req(bl_hw *bl_hw,uchar vif_idx)

{
  uchar *msg_params;
  int iVar1;
  
  msg_params = (uchar *)bl_msg_zalloc(0x1c02,7,1);
  if (msg_params != (uchar *)0x0) {
    *msg_params = vif_idx;
    iVar1 = bl_send_msg(bl_hw,msg_params,1,0x1c03,(void *)0x0);
    return iVar1;
  }
  return -0xc;
}



int bl_send_apm_sta_del_req(bl_hw *bl_hw,apm_sta_del_cfm *cfm,uchar sta_idx,uchar vif_idx)

{
  uchar *msg_params;
  int iVar1;
  
  msg_params = (uchar *)bl_msg_zalloc(0x1c0b,7,2);
  if (msg_params != (uchar *)0x0) {
    msg_params[1] = sta_idx;
    *msg_params = vif_idx;
    iVar1 = bl_send_msg(bl_hw,msg_params,1,0x1c0c,cfm);
    return iVar1;
  }
  return -0xc;
}



int bl_send_apm_conf_max_sta_req(bl_hw *bl_hw,uchar max_sta_supported)

{
  uchar *msg_params;
  int iVar1;
  
  msg_params = (uchar *)bl_msg_zalloc(0x1c0d,7,1);
  if (msg_params != (uchar *)0x0) {
    *msg_params = max_sta_supported;
    iVar1 = bl_send_msg(bl_hw,msg_params,1,0x1c0e,(void *)0x0);
    return iVar1;
  }
  return -0xc;
}



int bl_send_cfg_task_req
              (bl_hw *bl_hw,uint32_t ops,uint32_t task,uint32_t element,uint32_t type,void *arg1,
              void *arg2)

{
  uint32_t *msg_params;
  int iVar1;
  TickType_t TVar2;
  uint32_t uVar3;
  
  msg_params = (uint32_t *)bl_msg_zalloc(0x3000,0xc,0x24);
  if (msg_params == (uint32_t *)0x0) {
    return -0xc;
  }
  *msg_params = ops;
  if (ops < 3) {
    if (ops == 0) {
      msg_params[1] = task;
      msg_params[2] = element;
      msg_params[3] = type;
      uVar3 = utils_tlv_bl_pack_auto(msg_params + 5,8,(uint16_t)type,arg1);
      msg_params[4] = uVar3;
    }
  }
  else {
    if (ops != 3) {
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] ASSERT: %s:%d\r\n",TVar2,&UNK_2307c064,&UNK_2307c058,0x40f,
                &UNK_2307c058,0x40f);
      do {
                    // WARNING: Do nothing block with infinite loop
      } while( true );
    }
    msg_params[1] = task;
    msg_params[2] = element;
    msg_params[4] = 0;
  }
  iVar1 = bl_send_msg(bl_hw,msg_params,1,0x3001,(void *)0x0);
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int bl_platform_on(bl_hw *bl_hw)

{
  int iVar1;
  
  ipc_shenv = &ipc_shared_env;
  iVar1 = bl_ipc_init(bl_hw,(ipc_shared_env_tag_conflict21 *)&ipc_shared_env);
  if (iVar1 == 0) {
    _DAT_44800008 = 0xffffffff;
  }
  return iVar1;
}



int bl_rx_chan_pre_switch_ind(bl_hw *bl_hw,bl_cmd *cmd,ipc_e2a_msg *msg)

{
  return 0;
}



int bl_rx_rssi_status_ind(bl_hw *bl_hw,bl_cmd *cmd,ipc_e2a_msg *msg)

{
  if (cb_rssi != (wifi_event_rssi_cb_t *)0x0) {
    (*cb_rssi)(cb_rssi_env,*(int8_t *)((int)msg->param + 2));
    return 0;
  }
  return 0;
}



int bl_rx_apm_sta_del_ind(bl_hw *bl_hw,bl_cmd *cmd,ipc_e2a_msg *msg)

{
  printf("[WF] APM_STA_DEL_IND\r\n");
  printf("[WF]    sta_idx %u\r\n",(uint)*(byte *)msg->param);
  if (*(byte *)msg->param < 0xc) {
    bl_hw->sta_table[*(byte *)msg->param].is_used = '\0';
  }
  else {
    printf("[WF]    --------- Potential illegal sta_idx\r\n");
  }
  aos_post_event(2,0x16,(uint)*(byte *)msg->param);
  return 0;
}



int bl_rx_apm_sta_add_ind(bl_hw *bl_hw,bl_cmd *cmd,ipc_e2a_msg *msg)

{
  byte bVar1;
  int *piVar2;
  
  printf("[WF] APM_STA_ADD_IND\r\n");
  printf("[WF]    flags %08X\r\n",msg->param[0]);
  printf("[WF]    MAC %02X:%02X:%02X:%02X:%02X:%02X\r\n",(uint)*(byte *)(msg->param + 1),
         (uint)*(byte *)((int)msg->param + 5),(uint)*(byte *)((int)msg->param + 6),
         (uint)*(byte *)((int)msg->param + 7),(uint)*(byte *)(msg->param + 2),
         (uint)*(byte *)((int)msg->param + 9));
  printf("[WF]    vif_idx %u\r\n",(uint)*(byte *)((int)msg->param + 10));
  printf("[WF]    sta_idx %u\r\n",(uint)*(byte *)((int)msg->param + 0xb));
  bVar1 = *(byte *)((int)msg->param + 0xb);
  if (bVar1 < 0xc) {
    memcpy(bl_hw->sta_table + (uint)bVar1,msg->param + 1,6);
    piVar2 = &bl_hw->is_up + (uint)bVar1 * 7;
    *(undefined *)((int)piVar2 + 0xc99) = *(undefined *)((int)msg->param + 0xb);
    *(undefined *)((int)piVar2 + 0xc9a) = *(undefined *)((int)msg->param + 10);
    *(undefined *)(piVar2 + 0x326) = 1;
    *(undefined *)(piVar2 + 0x327) = *(undefined *)(msg->param + 3);
    piVar2[0x328] = msg->param[4];
    piVar2[0x329] = msg->param[5];
    *(undefined *)(piVar2 + 0x32a) = *(undefined *)(msg->param + 6);
  }
  else {
    printf("[WF]    ------ Potential illegal sta_idx\r\n");
  }
  aos_post_event(2,0x15,(uint)*(byte *)((int)msg->param + 0xb));
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

void notify_event_scan_done(int join_scan)

{
  wifi_event wStack24;
  uint8_t buffer [8];
  
  memset(&wStack24,0,4);
  memset(buffer,0,4);
  buffer._0_4_ = 0xec;
  wStack24 = (wifi_event)((uint)(join_scan != 0) + 1);
  if (cb_event != (wifi_event_cb_t *)0x0) {
    (*cb_event)(cb_event_env,&wStack24);
  }
  return;
}



int bl_rx_scanu_join_cfm(bl_hw *bl_hw,bl_cmd *cmd,ipc_e2a_msg *msg)

{
  notify_event_scan_done(1);
  return 0;
}



int bl_rx_scanu_start_cfm(bl_hw *bl_hw,bl_cmd *cmd,ipc_e2a_msg *msg)

{
  notify_event_scan_done(0);
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

int bl_rx_chan_switch_ind(bl_hw *bl_hw,bl_cmd *cmd,ipc_e2a_msg *msg)

{
  wifi_event wStack24;
  uint8_t buffer [8];
  
  buffer._0_4_ = (uint)*(byte *)msg->param;
  memset(&wStack24,0,4);
  memset(buffer,0,4);
  wStack24 = (wifi_event)0x0;
  if (cb_event != (wifi_event_cb_t *)0x0) {
    (*cb_event)(cb_event_env,&wStack24);
  }
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

int bl_rx_sm_connect_ind(bl_hw *bl_hw,bl_cmd *cmd,ipc_e2a_msg *msg)

{
  netif *netif;
  sm_reason_code *psVar1;
  uint uVar2;
  int iVar3;
  u32_l local_40;
  wifi_event_sm_connect_ind ind_new;
  
  psVar1 = reason_list;
  iVar3 = 0;
  do {
    if (psVar1->reason_code == *(uint16_t *)msg->param) goto LAB_23023c3e;
    iVar3 = iVar3 + 1;
    psVar1 = psVar1 + 1;
  } while (iVar3 != 0x10);
  iVar3 = 0;
LAB_23023c3e:
  printf("[RX] Connection Status\r\n");
  printf("[RX]   status_code %u\r\n",(uint)*(ushort *)msg->param);
  printf("[RX]   connect result: %s\r\n",reason_list[iVar3].action);
  printf("[RX]   MAC %02X:%02X:%02X:%02X:%02X:%02X\r\n",(uint)*(byte *)((int)msg->param + 2),
         (uint)*(byte *)((int)msg->param + 3),(uint)*(byte *)(msg->param + 1),
         (uint)*(byte *)((int)msg->param + 5),(uint)*(byte *)((int)msg->param + 6),
         (uint)*(byte *)((int)msg->param + 7));
  printf("[RX]   vif_idx %u\r\n",(uint)*(byte *)((int)msg->param + 9));
  printf("[RX]   ap_idx %u\r\n",(uint)*(byte *)((int)msg->param + 10));
  printf("[RX]   ch_idx %u\r\n",(uint)*(byte *)((int)msg->param + 0xb));
  printf("[RX]   qos %u\r\n",(uint)*(byte *)(msg->param + 3));
  printf("[RX]   acm %u\r\n",(uint)*(byte *)((int)msg->param + 0xd));
  printf("[RX]   assoc_req_ie_len %u\r\n",(uint)*(ushort *)((int)msg->param + 0xe));
  printf("[RX]   assoc_rsp_ie_len %u\r\n",(uint)*(ushort *)(msg->param + 4));
  printf("[RX]   aid %u\r\n",(uint)*(ushort *)(msg->param + 0xcd));
  printf("[RX]   band %u\r\n",(uint)*(byte *)((int)msg->param + 0x336));
  printf("[RX]   center_freq %u\r\n",(uint)*(ushort *)(msg->param + 0xce));
  printf("[RX]   width %u\r\n",(uint)*(byte *)((int)msg->param + 0x33a));
  printf("[RX]   center_freq1 %u\r\n",msg->param[0xcf]);
  printf("[RX]   center_freq2 %u\r\n",msg->param[0xd0]);
  if (*(short *)msg->param == 0) {
    bl_hw->sta_idx = (uint)*(byte *)((int)msg->param + 10);
    bl_hw->is_up = 1;
  }
  else {
    bl_hw->is_up = 0;
  }
  memset(&local_40,0,0x20);
  local_40 = msg->param[0];
  ind_new._0_4_ = msg->param[1];
  ind_new.bssid[2] = *(uint8_t *)((int)msg->param + 9);
  ind_new.bssid[3] = *(uint8_t *)((int)msg->param + 10);
  ind_new.bssid[4] = *(uint8_t *)((int)msg->param + 0xb);
  ind_new._8_4_ = (uint)*(byte *)(msg->param + 3);
  ind_new.qos._0_2_ = *(uint16_t *)(msg->param + 0xcd);
  ind_new.qos._2_1_ = *(uint8_t *)((int)msg->param + 0x336);
  ind_new.aid = *(uint16_t *)(msg->param + 0xce);
  ind_new.band = *(uint8_t *)((int)msg->param + 0x33a);
  ind_new._20_4_ = msg->param[0xcf];
  ind_new.center_freq1 = msg->param[0xd0];
  if (cb_sm_connect_ind != (wifi_event_sm_connect_ind_cb_t *)0x0) {
    (*cb_sm_connect_ind)(cb_sm_connect_ind_env,(wifi_event_sm_connect_ind *)&local_40);
  }
  if (*(short *)msg->param == 0) {
    uVar2 = (uint)*(byte *)((int)msg->param + 9);
    if (bl_hw->vif_table + uVar2 != (bl_vif *)0x0) {
      netif = (netif *)(&bl_hw->is_up + uVar2 * 0x31)[0xda];
      if (netif != (netif *)0x0) {
        netifapi_netif_common(netif,netif_set_link_up,(netifapi_errt_fn)0x0);
        netifapi_netif_common
                  ((netif *)(&bl_hw->is_up + uVar2 * 0x31)[0xda],netif_set_default,
                   (netifapi_errt_fn)0x0);
        return 0;
      }
    }
    printf("[RX]  -------- CRITICAL when check netif. ptr is %p:%p\r\n");
  }
  return 0;
}



// WARNING: Variable defined which should be unmapped: ind_new
// WARNING: Could not reconcile some variable overlaps

int bl_rx_sm_disconnect_ind(bl_hw *bl_hw,bl_cmd *cmd,ipc_e2a_msg *msg)

{
  netif *netif;
  uint uVar1;
  ip4_addr_t iStack28;
  ip4_addr_t addr_any;
  wifi_event_sm_disconnect_ind ind_new;
  
  iStack28 = (ip4_addr_t)ipaddr_addr("0.0.0.0");
  printf("[RX] sm_disconnect_ind\r\n       reason_code %u\r\n",(uint)*(ushort *)msg->param);
  printf("[RX]    vif_idx %u\r\n",(uint)*(byte *)((int)msg->param + 2));
  printf("[RX]     ft_over_ds %u\r\n",(uint)*(byte *)((int)msg->param + 3));
  if (cb_sm_disconnect_ind != (wifi_event_sm_disconnect_ind_cb_t *)0x0) {
    memset(&addr_any,0,8);
    addr_any.addr._0_2_ = *(uint16_t *)msg->param;
    addr_any.addr._2_1_ = *(uint8_t *)((int)msg->param + 2);
    (*cb_sm_disconnect_ind)(cb_sm_disconnect_ind_env,(wifi_event_sm_disconnect_ind *)&addr_any);
  }
  uVar1 = (uint)*(byte *)((int)msg->param + 2);
  if (bl_hw->vif_table + uVar1 != (bl_vif *)0x0) {
    netif = (netif *)(&bl_hw->is_up + uVar1 * 0x31)[0xda];
    if (netif != (netif *)0x0) {
      netifapi_netif_common(netif,netif_set_link_down,(netifapi_errt_fn)0x0);
      netifapi_netif_set_addr
                ((netif *)(&bl_hw->is_up + uVar1 * 0x31)[0xda],&iStack28,&iStack28,&iStack28);
    }
  }
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

undefined4 bl_rx_scanu_result_ind(int param_1,longlong param_2)

{
  uchar uVar1;
  void *__src;
  undefined3 extraout_var;
  uint __n;
  SecurityMode_t *security_mode;
  _Bool wpa2_prefered;
  byte bVar2;
  ushort uVar3;
  int iVar4;
  byte *pbVar5;
  byte *pbVar6;
  _Bool _Stack121;
  uint8_t auStack120 [32];
  undefined2 uStack88;
  undefined2 uStack86;
  undefined2 uStack84;
  undefined auStack82 [33];
  int8_t iStack49;
  int8_t iStack48;
  int8_t iStack47;
  byte bStack46;
  uint8_t uStack45;
  undefined4 uStack44;
  undefined4 uStack40;
  uint uStack36;
  SecurityMode_t aSStack32 [4];
  
  _Stack121 = false;
  memset(auStack120,0,0x20);
  security_mode = (SecurityMode_t *)0x80;
  uVar3 = *(ushort *)(param_1 + 0x24) & 0xfc;
  if (uVar3 != 0x80) {
    if (uVar3 != 0x50) {
      printf("Bug Scan IND?\r\n");
      return 0;
    }
    printf("Probe Response\r\n");
    if (cb_probe_resp_ind == (wifi_event_probe_resp_ind_cb_t *)0x0) {
      return 0;
    }
    (*cb_probe_resp_ind)((void *)0x0,param_2);
    return 0;
  }
  if (cb_beacon_ind == (wifi_event_beacon_ind_cb_t *)0x0) {
    return 0;
  }
  memset(&uStack88,0,0x38);
  uVar3 = *(ushort *)(param_1 + 8);
  pbVar6 = (byte *)(param_1 + 0x48);
  iVar4 = 0;
  pbVar5 = pbVar6;
  while (iVar4 < (int)(uint)uVar3) {
    security_mode = (SecurityMode_t *)(uint)*pbVar5;
    __n = (uint)pbVar5[1];
    if (*pbVar5 == 0) {
      if (pbVar5[1] < 0x21) {
        uStack36 = __n;
        memcpy(auStack82,pbVar5 + 2,__n);
        security_mode = aSStack32;
        auStack82[pbVar5[1]] = 0;
      }
      break;
    }
    iVar4 = iVar4 + __n + 2;
    pbVar5 = pbVar5 + __n + 2;
  }
  iVar4 = 0;
  pbVar5 = pbVar6;
  while (iVar4 < (int)(uint)*(ushort *)(param_1 + 8)) {
    security_mode = (SecurityMode_t *)(uint)pbVar5[1];
    if (*pbVar5 == 3) {
      if (pbVar5[1] < 0x21) {
        bStack46 = pbVar5[2];
      }
      break;
    }
    security_mode = security_mode + 1;
    iVar4 = &security_mode->field_0x0 + iVar4;
    pbVar5 = pbVar5 + (int)security_mode;
  }
  if ((*(ushort *)(param_1 + 0x46) & 0x10) == 0) {
    uStack45 = '\0';
    goto LAB_230240a6;
  }
  __n = (uint)uVar3 - 0x24 & 0xffff;
  __src = (void *)mac_ie_find(pbVar6,__n,0x30);
  iVar4 = 0;
  if (__src != (void *)0x0) {
    wpa2_prefered = (_Bool)(uStack40._1_1_ | 0x20);
    uStack40 = uStack40 | 0x2000;
    memcpy(auStack120,__src,(uint)*(byte *)((int)__src + 1) + 2 & 0xff);
    uVar1 = process_rsn_ie(auStack120,(Cipher_t *)((int)&uStack44 + 3),(Cipher_t *)&uStack40,
                           &_Stack121,security_mode,wpa2_prefered);
    iVar4 = CONCAT31(extraout_var,uVar1);
  }
  __src = (void *)mac_vsie_find(pbVar6,__n,&DAT_2307c188,4);
  if ((__src != (void *)0x0) && (uStack40 = uStack40 | 0x800, iVar4 == 0)) {
    memcpy(auStack120,__src,(uint)*(byte *)((int)__src + 1) + 2 & 0xff);
    process_wpa_ie(auStack120,(Cipher_t *)((int)&uStack44 + 1),(Cipher_t *)((int)&uStack44 + 2));
  }
  if ((uStack40 & 0x2800) == 0x2800) {
    bVar2 = (byte)uStack40._0_1_ | (byte)uStack44._2_1_;
    __n = (uint)bVar2 & 8;
    if ((bVar2 & 4) == 0) {
      if ((bVar2 & 8) != 0) {
        if (((uStack44 & 0x8000800) == 0) && ((uStack44 & 0x4000400) != 0)) goto LAB_23024090;
LAB_23024118:
        bVar2 = 2;
        goto next;
      }
    }
    else {
LAB_2302408c:
      bVar2 = 3;
      if (__n != 0) {
LAB_23024090:
        bVar2 = 4;
      }
next:
      uStack44 = uStack44 & 0xffffff00 | (uint)bVar2;
      if ((uStack40 & 0x2800) != 0x2800) goto LAB_23024172;
    }
    uStack45 = '\x04';
  }
  else {
    if ((uStack40 & 0x800) == 0) {
      if ((uStack40 & 0x2000) == 0) {
        uStack44 = CONCAT31(uStack44._1_3_,1);
      }
      else {
        __n = uStack40 & 8;
        if ((uStack40 & 4) != 0) goto LAB_2302408c;
        if ((uStack40 & 8) != 0) {
          uStack44._1_1_ = uStack44._3_1_;
          goto LAB_23024146;
        }
      }
    }
    else {
      __n = (uint)(byte)uStack44._2_1_ & 8;
      if ((uStack44 & 0x40000) != 0) goto LAB_2302408c;
      if ((uStack44 & 0x80000) != 0) {
LAB_23024146:
        if ((((byte)uStack44._1_1_ & 8) != 0) || (((byte)uStack44._1_1_ & 4) == 0))
        goto LAB_23024118;
        goto LAB_23024090;
      }
    }
LAB_23024172:
    if ((uStack40 & 0x2000) == 0) {
      if ((uStack40 & 0x800) == 0) {
        uStack45 = '\x01';
      }
      else {
        uStack45 = '\x02';
      }
    }
    else {
      uStack45 = '\x03';
    }
  }
LAB_230240a6:
  iStack49 = *(int8_t *)(param_1 + 0x20);
  iStack48 = *(int8_t *)(param_1 + 0x21);
  iStack47 = *(int8_t *)(param_1 + 0x22);
  uStack88 = *(undefined2 *)(param_1 + 0x34);
  uStack86 = *(undefined2 *)(param_1 + 0x36);
  uStack84 = *(undefined2 *)(param_1 + 0x38);
  (*cb_beacon_ind)(cb_beacon_ind_env,(wifi_event_beacon_ind_conflict *)&uStack88);
  return 0;
}



undefined4 bl_rx_mesh_path_update_ind(void)

{
  return 0;
}



undefined4 bl_rx_mesh_proxy_update_ind(void)

{
  return 0;
}



undefined4 bl_rx_remain_on_channel_exp_ind(void)

{
  return 0;
}



undefined4 bl_rx_ps_change_ind(void)

{
  return 0;
}



undefined4 bl_rx_traffic_req_ind(void)

{
  return 0;
}



undefined4 bl_rx_csa_counter_ind(void)

{
  return 0;
}



undefined4 bl_rx_csa_finish_ind(void)

{
  return 0;
}



undefined4 bl_rx_csa_traffic_ind(void)

{
  return 0;
}



undefined4 bl_rx_channel_survey_ind(void)

{
  return 0;
}



undefined4 bl_rx_dbg_error_ind(void)

{
  return 0;
}



undefined4 bl_rx_tdls_chan_switch_cfm(void)

{
  return 0;
}



undefined4 bl_rx_tdls_chan_switch_ind(void)

{
  return 0;
}



undefined4 bl_rx_tdls_chan_switch_base_ind(void)

{
  return 0;
}



undefined4 bl_rx_tdls_peer_ps_ind(void)

{
  return 0;
}



undefined4 bl_rx_me_tkip_mic_failure_ind(void)

{
  return 0;
}



undefined4 bl_rx_me_tx_credits_update_ind(void)

{
  return 0;
}



undefined4 bl_rx_mesh_path_create_cfm(void)

{
  return 0;
}



undefined4 bl_rx_mesh_peer_update_ind(void)

{
  return 0;
}



int bl_rx_sm_connect_ind_cb_register(void *env,wifi_event_sm_connect_ind_cb_t *cb)

{
  cb_sm_connect_ind = cb;
  cb_sm_connect_ind_env = env;
  return 0;
}



int bl_rx_sm_disconnect_ind_cb_register(void *env,wifi_event_sm_disconnect_ind_cb_t *cb)

{
  cb_sm_disconnect_ind = cb;
  cb_sm_disconnect_ind_env = env;
  return 0;
}



int bl_rx_beacon_ind_cb_register(void *env,wifi_event_beacon_ind_cb_t *cb)

{
  cb_beacon_ind = cb;
  cb_beacon_ind_env = env;
  return 0;
}



int bl_rx_probe_resp_ind_cb_register(void *env,wifi_event_probe_resp_ind_cb_t *cb)

{
  cb_probe_resp_ind = cb;
  return 0;
}



int bl_rx_pkt_cb_register(void *env,wifi_event_pkt_cb_t *cb)

{
  cb_pkt = cb;
  cb_pkt_env = env;
  return 0;
}



int bl_rx_pkt_cb_unregister(void *env)

{
  cb_pkt = (wifi_event_pkt_cb_t *)0x0;
  cb_pkt_env = (void *)0x0;
  return 0;
}



int bl_rx_rssi_cb_register(void *env,wifi_event_rssi_cb_t *cb)

{
  cb_rssi = cb;
  cb_rssi_env = env;
  return 0;
}



int bl_rx_event_register(void *env,wifi_event_cb_t *cb)

{
  cb_event = cb;
  cb_event_env = env;
  return 0;
}



void bl_rx_e2a_handler(void *arg)

{
                    // WARNING: Could not recover jumptable at 0x230242f0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*wifi_hw.cmd_mgr.msgind)
            ((bl_cmd_mgr *)0x4201d5b0,(ipc_e2a_msg *)arg,
             (msg_cb_fct *)msg_hdlrs[*(ushort *)arg >> 10][(uint)*(ushort *)arg & 0x3ff]);
  return;
}



void bl_rx_pkt_cb(uint8_t *pkt,int len)

{
  if (cb_pkt != (wifi_event_pkt_cb_t *)0x0) {
                    // WARNING: Could not recover jumptable at 0x2302430a. Too many branches
                    // WARNING: Treating indirect jump as call
    (*cb_pkt)(cb_pkt_env,pkt,len);
    return;
  }
  return;
}



void bl_tx_push(bl_hw *bl_hw,bl_txhdr_conflict1 *txhdr)

{
  hostdesc *phVar1;
  hostdesc *phVar2;
  txdesc_host *ptVar3;
  hostdesc_conflict44 *phVar4;
  uint32_t *host_id;
  
  host_id = txhdr->p;
  ptVar3 = ipc_host_txdesc_get(bl_hw->ipc_env);
  if (&ptVar3->host == (hostdesc *)0x0) {
    printf("%d:ASSERT_ERR(host)\n",0x37);
  }
  phVar1 = &ptVar3->host;
  phVar4 = &txhdr->host;
  do {
    phVar2 = (hostdesc *)((int)&phVar1->pbuf_addr + 1);
    *(undefined *)&phVar1->pbuf_addr = *(undefined *)&phVar4->pbuf_addr;
    phVar1 = phVar2;
    phVar4 = (hostdesc_conflict44 *)((int)&phVar4->pbuf_addr + 1);
  } while ((hostdesc *)ptVar3->pad_txdesc != phVar2);
  ipc_host_txdesc_push(bl_hw->ipc_env,host_id);
  (bl_hw->stats).cfm_balance = (bl_hw->stats).cfm_balance + 1;
  return;
}



void bl_tx_resend(void)

{
  bl_hw *bl_hw;
  txdesc_host *ptVar1;
  uint uVar2;
  
  vTaskEnterCritical();
  while ((txhdr_pos_r != txhdr_pos_w &&
         (ptVar1 = ipc_host_txdesc_get(bl_hw_static->ipc_env), bl_hw = bl_hw_static,
         ptVar1 != (txdesc_host *)0x0))) {
    uVar2 = txhdr_pos_r & 7;
    txhdr_hodler[uVar2]->status = 0;
    bl_tx_push(bl_hw,(bl_txhdr_conflict1 *)txhdr_hodler[uVar2]);
    txhdr_pos_r = txhdr_pos_r + 1;
  }
  vTaskExitCritical();
  return;
}



void bl_tx_try_flush(void)

{
  txdesc_host *ptVar1;
  bl_txhdr_conflict1 *txhdr;
  
  vTaskEnterCritical();
  while ((ptVar1 = ipc_host_txdesc_get(bl_hw_static->ipc_env), ptVar1 != (txdesc_host *)0x0 &&
         (txhdr = (bl_txhdr_conflict1 *)utils_list_pop_front(&tx_list_bl),
         txhdr != (bl_txhdr_conflict1 *)0x0))) {
    bl_tx_push(bl_hw_static,txhdr);
  }
  vTaskExitCritical();
  return;
}



int bl_txdatacfm(void *pthis,void *host_id)

{
  bl_txhdr_conflict *pbVar1;
  int iVar2;
  
  pbVar1 = (bl_txhdr_conflict *)((-*(int *)((int)host_id + 4) & 3U) + *(int *)((int)host_id + 4));
  iVar2 = pbVar1->status;
  if (iVar2 == 0) {
    return -1;
  }
  if (iVar2 << 0xf < 0) {
    if (((txhdr_pos_w + 1 ^ txhdr_pos_r) & 7) != 0) {
      puts(" push back\r\n");
      txhdr_hodler[txhdr_pos_w & 7] = pbVar1;
      txhdr_pos_w = txhdr_pos_w + 1;
      return 0;
    }
    puts(" NOT push back when no mem\r\n");
  }
  pbuf_free((pbuf *)host_id);
  return 0;
}



void bl_tx_notify(void)

{
  if (taskHandle_output != (TaskHandle_t)0x0) {
    xTaskGenericNotify(taskHandle_output,0,eIncrement,(uint32_t *)0x0);
    return;
  }
  return;
}



err_t bl_output(bl_hw *bl_hw,netif *netif,pbuf *p,int is_sta)

{
  u16_t uVar1;
  undefined2 uVar2;
  utils_list_hdr *list_hdr;
  err_t eVar3;
  u8_t uVar4;
  undefined3 extraout_var;
  undefined uVar5;
  pbuf *ppVar6;
  uint8_t *mac;
  int iVar7;
  utils_list_hdr *puVar8;
  
  if ((bl_hw == (bl_hw *)0x0) || ((netif->flags & 4) == 0)) {
    printf("[TX] wifi is down, return now\r\n");
    eVar3 = -0xb;
  }
  else {
    if (taskHandle_output == (TaskHandle_t)0x0) {
      taskHandle_output = xTaskGetCurrentTaskHandle();
    }
    mac = (uint8_t *)p->payload;
    uVar1 = p->tot_len;
    bl_hw_static = bl_hw;
    uVar4 = pbuf_header(p,0x80);
    if (CONCAT31(extraout_var,uVar4) == 0) {
      list_hdr = (utils_list_hdr *)((-(int)p->payload & 3U) + (int)p->payload);
      memset(list_hdr,0,0x5c);
      *(pbuf **)&list_hdr[2].next = p;
      memcpy(list_hdr + 7,mac,6);
      memcpy((void *)((int)&list_hdr[8].next + 2),mac + 6,6);
      *(pbuf **)&list_hdr[3].next = p;
      uVar2 = *(undefined2 *)(mac + 0xc);
      *(undefined *)((int)&list_hdr[0xd].next + 2) = 0;
      *(undefined2 *)&list_hdr[10].next = uVar2;
      if (is_sta == 0) {
        uVar5 = *(undefined *)&bl_hw->vif_index_ap;
      }
      else {
        uVar5 = *(undefined *)&bl_hw->vif_index_sta;
      }
      *(undefined *)((int)&list_hdr[0xd].next + 3) = uVar5;
      *(undefined2 *)((int)&list_hdr[0xe].next + 2) = 0;
      *(u16_t *)&list_hdr[5].next = uVar1 - 0xe;
      if (is_sta == 0) {
        iVar7 = bl_utils_idx_lookup(bl_hw,mac);
        *(char *)&list_hdr[0xe].next = (char)iVar7;
      }
      else {
        *(char *)&list_hdr[0xe].next = (char)bl_hw->sta_idx;
      }
      puVar8 = list_hdr + 0xf;
      iVar7 = 0;
      ppVar6 = p;
      do {
        if (iVar7 == 0) {
          list_hdr[0xf].next = (utils_list_hdr *)((int)ppVar6->payload + 0x8e);
          list_hdr[0x13].next = (utils_list_hdr *)((uint)ppVar6->len - 0x8e);
        }
        else {
          if (iVar7 == 4) {
            printf("[TX] [PBUF] Please fix for bigger chained pbuf, total_len %d\r\n",
                   (uint)p->tot_len);
          }
          puVar8->next = (utils_list_hdr *)ppVar6->payload;
          puVar8[4].next = (utils_list_hdr *)(uint)ppVar6->len;
        }
        ppVar6 = ppVar6->next;
        iVar7 = iVar7 + 1;
        puVar8 = puVar8 + 1;
      } while (ppVar6 != (pbuf *)0x0);
      if (2 < iVar7) {
        printf("[TX] [LOOP] Chain Used %d\r\n",iVar7);
      }
      list_hdr[4].next = (utils_list_hdr *)0x11111111;
      list_hdr[6].next = list_hdr + 1;
      list_hdr[1].next = (utils_list_hdr *)0x0;
      pbuf_ref(p);
      vTaskEnterCritical();
      utils_list_push_back(&tx_list_bl,list_hdr);
      vTaskExitCritical();
      bl_irq_handler();
      eVar3 = '\0';
    }
    else {
      printf("[TX] Reserve room failed for header\r\n");
      eVar3 = -0xc;
    }
  }
  return eVar3;
}



u8 bl_radarind(void *pthis,void *hostid)

{
  return '\0';
}



u8 bl_msgackind(bl_hw *pthis,void *hostid)

{
  (*(pthis->cmd_mgr).llind)(&pthis->cmd_mgr,(bl_cmd *)hostid);
  return '\0';
}



void bl_prim_tbtt_ind(void *pthis)

{
  return;
}



void my_pbuf_free_custom(pbuf *p)

{
  bl60x_firmwre_mpdu_free(p[1].payload);
  return;
}



undefined4 bl_dbgind(void)

{
  return 0;
}



void bl_sec_tbtt_ind(void)

{
  return;
}



void my_pbuf_free_custom_fake(void)

{
  return;
}



// WARNING: Control flow encountered bad instruction data

int tcpip_stack_input(void *swdesc,uchar status,void *hwhdr,uint msdu_offset,wifi_pkt *pkt)

{
  if ((status & 1) == 0) {
    return -1;
  }
                    // WARNING: Bad instruction - Truncating control flow here
  halt_baddata();
}



int bl_utils_idx_lookup(bl_hw *bl_hw,uint8_t *mac)

{
  bl_sta *__s1;
  int iVar1;
  int iVar2;
  
  __s1 = bl_hw->sta_table;
  iVar1 = 0;
  while ((__s1->is_used == '\0' || (iVar2 = memcmp(__s1,mac,6), iVar2 != 0))) {
    iVar1 = iVar1 + 1;
    __s1 = __s1 + 1;
    if (iVar1 == 0xc) {
      return wifi_hw.ap_bcmc_idx;
    }
  }
  return iVar1;
}



int bl_ipc_init(bl_hw *bl_hw,ipc_shared_env_tag_conflict21 *ipc_shared_mem)

{
  code *local_30;
  ipc_host_cb_tag cb;
  
  memset(&local_30,0,0x20);
  cb.recv_data_ind = bl_radarind;
  cb.recv_msg_ind = bl_msgackind;
  cb.recv_msgack_ind = bl_dbgind;
  local_30 = bl_txdatacfm;
  cb.recv_dbg_ind = bl_prim_tbtt_ind;
  cb.prim_tbtt_ind = bl_sec_tbtt_ind;
  cb.send_data_cfm = (anon_subr_int_void_ptr_void_ptr_for_send_data_cfm *)0x0;
  cb.recv_radar_ind = (anon_subr_uint8_t_void_ptr_void_ptr_for_recv_radar_ind *)0x0;
  ipc_env = (ipc_host_env_tag *)pvPortMalloc(0xe4);
  bl_hw->ipc_env = ipc_env;
  ipc_host_init(ipc_env,(ipc_host_cb_tag *)&local_30,(ipc_shared_env_tag_conflict3 *)ipc_shared_mem,
                bl_hw);
  bl_cmd_mgr_init(&bl_hw->cmd_mgr);
  return 0;
}



void bl_utils_dump(void)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  
  puts("---------- bl_utils_dump -----------\r\n");
  printf("txdesc_free_idx: %lu(%lu)\r\n",ipc_env->txdesc_free_idx,ipc_env->txdesc_free_idx & 3);
  printf("txdesc_used_idx: %lu(%lu)\r\n",ipc_env->txdesc_used_idx,ipc_env->txdesc_used_idx & 3);
  iVar1 = 0;
  printf("tx_host_id0 cnt: %d(used %ld)\r\n",4,ipc_env->txdesc_free_idx - ipc_env->txdesc_used_idx);
  puts("  list:   pbuf    status ptr  status\r\n");
  do {
    uVar2 = ipc_env->txdesc_used_idx + iVar1;
    if (uVar2 == ipc_env->txdesc_free_idx) break;
    iVar1 = iVar1 + 1;
    iVar3 = *(int *)((&(ipc_env->cb).recv_radar_ind)[(uVar2 & 3) + 0x10] + 4);
    iVar3 = (-iVar3 & 3U) + iVar3;
    printf("    [%lu]%p(%p:%08lX)\r\n",*(undefined4 *)(iVar3 + 0x18),*(undefined4 *)(iVar3 + 4));
  } while (iVar1 != 4);
  puts("========== bl_utils_dump End =======\r\n");
  return;
}



_Bool stateSnifferGuard(void *ch,event *event)

{
  return (_Bool)(ch == (void *)(uint)*(byte *)event->data);
}



_Bool stateConnectedIPYesGuard_ip_update(void *ch,event *event)

{
  return (_Bool)(ch == (void *)(uint)*(byte *)event->data);
}



void printErrMsg(void *stateData,event *event)

{
  printf("ENTERED ERROR STATE!");
  return;
}



void stateSnifferExit(void *stateData,event *event)

{
  printf("[WF][SM] Exiting %s state\r\n",stateData);
  return;
}



void stateSnifferAction(void *oldStateData,event *event,void *newStateData)

{
  printf("[WF][SM] State Action ###%s### --->>> ###%s###\r\n",oldStateData);
  return;
}



void stateConnectedIPNoAction_ipgot(void *oldStateData,event *event,void *newStateData)

{
  uint *puVar1;
  uint *puVar2;
  uint uVar3;
  uint uVar4;
  
  puVar1 = (uint *)((int)event->data + 0xd);
  puVar2 = (uint *)((int)event->data + 0x11);
  uVar4 = *puVar1;
  uVar3 = *puVar2;
  printf(
         "[WF][SM] IP GOT IP:%u.%u.%u.%u, MASK: %u.%u.%u.%u, Gateway: %u.%u.%u.%u, dns1: %u.%u.%u.%u, dns2: %u.%u.%u.%u\r\n"
         ,uVar4 & 0xff,uVar4 >> 8 & 0xff,(uint)(*(uint3 *)puVar1 >> 0x10),uVar4 >> 0x18,uVar3 & 0xff
         ,uVar3 >> 8 & 0xff,(uint)(*(uint3 *)puVar2 >> 0x10));
  printf("[WF][SM] State Action ###%s### --->>> ###%s###\r\n",oldStateData,newStateData);
  return;
}



void stateGlobalEnter(void *stateData,event *event)

{
  printf("[WF][SM] Entering %s state\r\n",stateData);
  return;
}



void stateGlobalAction(void *oldStateData,event *event,void *newStateData)

{
  printf("[WF][SM] Global Action\r\n");
  return;
}



void stateConnectingEnter(void *stateData,event *event)

{
  printf("[WF][SM] Entering %s state\r\n",stateData);
  aos_post_event(2,8,0);
  return;
}



_Bool stateSnifferGuard_ChannelSet(void *ch,event *event)

{
  byte *pbVar1;
  
  pbVar1 = (byte *)event->data;
  if (ch == (void *)(uint)*pbVar1) {
    bl_main_monitor_channel_set(*(int *)(pbVar1 + 1),*(int *)(pbVar1 + 5));
    return false;
  }
  return false;
}



_Bool stateIdleGuard_sniffer(void *ev,event *event)

{
  if (ev == (void *)(uint)*(byte *)event->data) {
    bl_main_monitor();
    return true;
  }
  return false;
}



void stateConnectedIPNoExit(void *stateData,event *event)

{
  printf("[WF][SM] Exiting %s state\r\n",stateData);
  xTimerGenericCommand((TimerHandle_t)((int)stateData + 0x20),3,0,(BaseType_t *)0x0,0);
  xTimerGenericCommand((TimerHandle_t)((int)stateData + 0x20),5,0,(BaseType_t *)0x0,0);
  return;
}



void stateDisconnect_action_idle(void *oldStateData,event *event,void *newStateData)

{
  printf("[WF][SM] State Action ###%s### --->>> ###%s###\r\n",oldStateData);
  printf("[WF][SM] Removing STA interface...\r\n");
  bl_main_if_remove(wifiMgmr.wlan_sta.vif_index);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void stateDisconnect_action_reconnect(void *oldStateData,event *event,void *newStateData)

{
  printf("[WF][SM] State Action ###%s### --->>> ###%s###\r\n",oldStateData);
  printf("[WF][SM]  Action Connect\r\n");
  printf("           ssid %s\r\n",(uint8_t *)((int)oldStateData + 0x4d));
  printf("           ssid len %u\r\n",*(undefined4 *)((int)oldStateData + 0x6e));
  printf("           psk %s\r\n",(uint8_t *)((int)oldStateData + 0x72));
  printf("           psk len %u\r\n",*(undefined4 *)((int)oldStateData + 0xf4));
  printf("           pmk %s\r\n",(uint8_t *)((int)oldStateData + 0xb3));
  printf("           pmk len %u\r\n",*(undefined4 *)((int)oldStateData + 0xf8));
  printf("           mac %02X:%02X:%02X:%02X:%02X:%02X\r\n",
         (uint)*(byte *)((int)oldStateData + 0x101),(uint)*(byte *)((int)oldStateData + 0x100),
         (uint)*(byte *)((int)oldStateData + 0xff),(uint)*(byte *)((int)oldStateData + 0xfe),
         (uint)*(byte *)((int)oldStateData + 0xfd),(uint)*(byte *)((int)oldStateData + 0xfc));
  bl_main_connect((uint8_t *)((int)oldStateData + 0x4d),*(int *)((int)oldStateData + 0x6e),
                  (uint8_t *)((int)oldStateData + 0x72),*(int *)((int)oldStateData + 0xf4),
                  (uint8_t *)((int)oldStateData + 0xb3),*(int *)((int)oldStateData + 0xf8),
                  (uint8_t *)((int)oldStateData + 0xfc),'\0',_DAT_00000010);
  aos_post_event(2,3,0);
  return;
}



void ip_obtaining_timeout(timer_cb_arg_t data)

{
  pvTimerGetTimerID((TimerHandle_t)data);
  printf("[WF][SM] IP obtaining timeout\r\n");
  wifi_mgmr_api_fw_disconnect();
  return;
}



void stateConnectedIPNoEnter(void *stateData,event *event)

{
  uint32_t uVar1;
  uint32_t uVar2;
  uint32_t uVar3;
  uint32_t uVar4;
  uint32_t uVar5;
  TickType_t xOptionalValue;
  ip4_addr_t iStack44;
  ip4_addr_t addr_ipaddr;
  ip4_addr_t addr_netmask;
  ip4_addr_t addr_gw;
  
  printf("[WF][SM] Entering %s state\r\n",stateData);
  xTimerCreateStatic("wifi IP obtaining",15000,0,stateData,ip_obtaining_timeout,
                     (StaticTimer_t *)(TimerHandle_t)((int)stateData + 0x20));
  xOptionalValue = xTaskGetTickCount();
  xTimerGenericCommand
            ((TimerHandle_t)((int)stateData + 0x20),1,xOptionalValue,(BaseType_t *)0x0,0xffffffff);
  vTaskEnterCritical();
  uVar5 = wifiMgmr.wlan_sta.ipv4.dns2;
  uVar4 = wifiMgmr.wlan_sta.ipv4.dns1;
  uVar3 = wifiMgmr.wlan_sta.ipv4.gw;
  uVar2 = wifiMgmr.wlan_sta.ipv4.mask;
  uVar1 = wifiMgmr.wlan_sta.ipv4.ip;
  vTaskExitCritical();
  if (uVar1 == 0) {
    printf("[WF][SM] DHCP Starting...%p\r\n",0x4201e474);
    wifi_netif_dhcp_start((netif *)&wifiMgmr.wlan_sta.netif);
  }
  else {
    printf("[WF][SM] Static IP Starting...%p\r\n",0x4201e474);
    iStack44 = (ip_addr_t)uVar4;
    dns_setserver('\0',(ip_addr_t *)&iStack44);
    iStack44 = (ip_addr_t)uVar5;
    dns_setserver('\x01',(ip_addr_t *)&iStack44);
    iStack44 = (ip_addr_t)uVar1;
    addr_ipaddr = uVar2;
    addr_netmask = uVar3;
    netifapi_netif_common((netif *)&wifiMgmr.wlan_sta.netif,dhcp_stop,(netifapi_errt_fn)0x0);
    netifapi_netif_set_addr((netif *)&wifiMgmr.wlan_sta.netif,&iStack44,&addr_ipaddr,&addr_netmask);
  }
  aos_post_event(2,4,0);
  return;
}



_Bool stateConnectedIPNoGuard_disconnect(void *ch,event *event)

{
  if (ch == (void *)(uint)*(byte *)event->data) {
    bl_main_disconnect();
    return false;
  }
  return false;
}



_Bool stateConnectedIPYesGuard_disconnect(void *ch,event *event)

{
  if (ch == (void *)(uint)*(byte *)event->data) {
    bl_main_disconnect();
    return false;
  }
  return false;
}



_Bool stateConnectedIPYesGuard_rcconfig(void *ch,event *event)

{
  byte *pbVar1;
  
  pbVar1 = (byte *)event->data;
  if (ch == (void *)(uint)*pbVar1) {
    printf("[WF][SM] rate config, use sta_idx 0, rate_config %04X\r\n",*(undefined4 *)(pbVar1 + 1));
    bl_main_rate_config('\0',*(uint16_t *)(pbVar1 + 1));
  }
  return false;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void stateIdleAction_connect(void *oldStateData,event *event,void *newStateData)

{
  void *pvVar1;
  wifi_mgmr_profile_msg_t *profile_msg;
  char *pcVar2;
  
  pvVar1 = event->data;
  *(undefined *)((int)pvVar1 + 0x2d) = 0;
  *(undefined *)((int)pvVar1 + 0x72) = 0;
  printf("[WF][SM] Action Connect\r\n");
  profile_msg = (wifi_mgmr_profile_msg_t *)((int)pvVar1 + 0xd);
  printf("           ssid %s\r\n",profile_msg);
  printf("           ssid len %u\r\n",*(undefined4 *)((int)pvVar1 + 0x2e));
  printf("           psk %s\r\n",(uint8_t *)((int)pvVar1 + 0x32));
  printf("           psk len %u\r\n",*(undefined4 *)((int)pvVar1 + 0xb4));
  printf("           pmk %s\r\n",(uint8_t *)((int)pvVar1 + 0x73));
  printf("           pmk len %u\r\n",*(undefined4 *)((int)pvVar1 + 0xb8));
  printf("           channel band %d\r\n",(uint)*(byte *)((int)pvVar1 + 0xc2));
  printf("           channel freq %d\r\n",(uint)*(ushort *)((int)pvVar1 + 0xc3));
  printf("           mac %02X:%02X:%02X:%02X:%02X:%02X\r\n",(uint)*(byte *)((int)pvVar1 + 0xc1),
         (uint)*(byte *)((int)pvVar1 + 0xc0),(uint)*(byte *)((int)pvVar1 + 0xbf),
         (uint)*(byte *)((int)pvVar1 + 0xbe),(uint)*(byte *)((int)pvVar1 + 0xbd),
         (uint)*(byte *)((int)pvVar1 + 0xbc));
  if (*(char *)((int)pvVar1 + 0xc5) == '\0') {
    pcVar2 = "false";
  }
  else {
    pcVar2 = "true";
  }
  printf("           dhcp status: %s\r\n",pcVar2);
  wifi_mgmr_profile_add(&wifiMgmr,profile_msg,-1);
  printf("[WF][SM] State Action ###%s### --->>> ###%s###\r\n",oldStateData,newStateData);
  bl_main_connect((uint8_t *)profile_msg,*(int *)((int)pvVar1 + 0x2e),
                  (uint8_t *)((int)pvVar1 + 0x32),*(int *)((int)pvVar1 + 0xb4),
                  (uint8_t *)((int)pvVar1 + 0x73),*(int *)((int)pvVar1 + 0xb8),
                  (uint8_t *)((int)pvVar1 + 0xbc),*(uint8_t *)((int)pvVar1 + 0xc2),_DAT_00000010);
  return;
}



_Bool stateGlobal_cfg_req(void *ch,event *event)

{
  char *pcVar1;
  
  pcVar1 = (char *)event->data;
  if (*pcVar1 == '\x16') {
    bl_main_cfg_task_req
              (*(uint32_t *)(pcVar1 + 0xd),*(uint32_t *)(pcVar1 + 0x11),*(uint32_t *)(pcVar1 + 0x15)
               ,*(uint32_t *)(pcVar1 + 0x19),pcVar1 + 0x21,(void *)0x0);
    return false;
  }
  return false;
}



_Bool stateGlobalGuard_fw_powersaving(void *ch,event *event)

{
  char *pcVar1;
  
  pcVar1 = (char *)event->data;
  if (*pcVar1 == '\x10') {
    printf("------>>>>>> Powersaving CMD, mode: %u\r\n",*(undefined4 *)(pcVar1 + 1));
    bl_main_powersaving(*(int *)(pcVar1 + 1));
  }
  return false;
}



_Bool stateGlobalGuard_conf_max_sta(void *ev,event *event)

{
  char *pcVar1;
  
  pcVar1 = (char *)event->data;
  if (*pcVar1 == '\n') {
    printf("[WF][SM] Conf max sta supported %lu...\r\n",*(undefined4 *)(pcVar1 + 1));
    bl_main_conf_max_sta(pcVar1[1]);
  }
  return false;
}



_Bool stateGlobalGuard_AP(void *ev,event *event)

{
  char "stateGlobalGuard_AP" [20];
  char *pcVar1;
  int iVar2;
  
  pcVar1 = (char *)event->data;
  if (*pcVar1 == '\b') {
    iVar2 = bl_main_if_add(0,(netif *)&wifiMgmr.wlan_ap.netif,&wifiMgmr.wlan_ap.vif_index);
    if (iVar2 == 0) {
      netifapi_netif_common
                ((netif *)&wifiMgmr.wlan_ap.netif,netif_set_link_up,(netifapi_errt_fn)0x0);
      netifapi_netif_common((netif *)&wifiMgmr.wlan_ap.netif,dhcpd_start,(netifapi_errt_fn)0x0);
      printf("[WF][SM] start AP with ssid %s;\r\n",pcVar1 + 0x11);
      printf("[WF][SM]               pwd  %s;\r\n",pcVar1 + 0x37);
      printf("[WF][SM]               channel  %ld;\r\n",*(undefined4 *)(pcVar1 + 0xd));
      bl_main_apm_start(pcVar1 + 0x11,pcVar1 + 0x37,*(int *)(pcVar1 + 0xd),
                        wifiMgmr.wlan_ap.vif_index,pcVar1[0x32]);
      wifiMgmr.inf_ap_enabled = 1;
      dns_server_init();
      aos_post_event(2,0xb,0);
    }
    else {
      printf("[WF][SM] %s: add AP iface failed\r\n","stateGlobalGuard_AP");
    }
  }
  return false;
}



_Bool stateGlobalGuard_scan_beacon(void *ch,event *event)

{
  byte bVar1;
  bool bVar2;
  byte *pbVar3;
  int iVar4;
  int iVar5;
  TickType_t TVar6;
  size_t sVar7;
  int iVar8;
  int iVar9;
  TickType_t TVar10;
  uint32_t uVar11;
  wifi_mgmr_t *pwVar12;
  int iVar13;
  wifi_mgmr_scan_item_t *__s;
  uint32_t uVar14;
  
  pbVar3 = (byte *)event->data;
  if (ch == (void *)(uint)*pbVar3) {
    pwVar12 = &wifiMgmr;
    if ((((int)(uint)pbVar3[0x3b] <= wifiMgmr.channel_nums) && (pbVar3[0x3b] != 0)) &&
       ((pbVar3[0xd] != 0 || ((wifiMgmr.features & 1) != 0)))) {
      TVar6 = xTaskGetTickCount();
      bVar2 = false;
      uVar14 = 0xffffffff;
      iVar4 = -1;
      iVar13 = 0;
      iVar9 = -1;
      do {
        iVar5 = iVar13;
        if (wifiMgmr.channel_nums < (int)(uint)pwVar12->scan_items[0].channel) {
          memset(pwVar12->scan_items,0,0x3c);
          pwVar12->scan_items[0].is_used = '\0';
        }
        else {
          if (pwVar12->scan_items[0].is_used != '\0') {
            uVar11 = pwVar12->scan_items[0].timestamp_lastseen;
            if ((!bVar2) || ((int)(uVar11 - uVar14) < 0)) {
              iVar4 = iVar13;
              uVar14 = uVar11;
            }
            iVar8 = memcmp(pwVar12->scan_items[0].bssid,pbVar3 + 0x35,6);
            iVar5 = iVar9;
            bVar2 = true;
            if ((iVar8 == 0) &&
               (iVar9 = strcmp((char *)(pbVar3 + 0xd),(char *)pwVar12->scan_items), bVar2 = true,
               iVar9 == 0)) {
              if (((char)pbVar3[0x3c] < wifiMgmr.scan_items[iVar13].rssi) &&
                 (TVar10 = xTaskGetTickCount(),
                 (int)(TVar10 - wifiMgmr.scan_items[iVar13].timestamp_lastseen) < 3000)) {
                return false;
              }
              wifiMgmr.scan_items[iVar13].channel = pbVar3[0x3b];
              wifiMgmr.scan_items[iVar13].rssi = pbVar3[0x3c];
              wifiMgmr.scan_items[iVar13].ppm_abs = pbVar3[0x3d];
              bVar1 = pbVar3[0x3e];
              wifiMgmr.scan_items[iVar13].timestamp_lastseen = TVar6;
              wifiMgmr.scan_items[iVar13].ppm_rel = bVar1;
              wifiMgmr.scan_items[iVar13].auth = pbVar3[0x3f];
              wifiMgmr.scan_items[iVar13].cipher = pbVar3[0x40];
              return false;
            }
          }
        }
        iVar13 = iVar13 + 1;
        pwVar12 = (wifi_mgmr_t *)&(pwVar12->wlan_sta).netif.input;
        iVar9 = iVar5;
      } while (iVar13 != 0x32);
      if ((iVar5 != -1) || (iVar5 = iVar4, iVar4 != -1)) {
        __s = wifiMgmr.scan_items + iVar5;
        memset(__s,0,0x3c);
        strncpy((char *)__s,(char *)(pbVar3 + 0xd),0x20);
        wifiMgmr.scan_items[iVar5].ssid_tail[0] = '\0';
        sVar7 = strlen((char *)__s);
        wifiMgmr.scan_items[iVar5].ssid_len = sVar7;
        memcpy(wifiMgmr.scan_items[iVar5].bssid,pbVar3 + 0x35,6);
        wifiMgmr.scan_items[iVar5].channel = pbVar3[0x3b];
        bVar1 = pbVar3[0x3c];
        wifiMgmr.scan_items[iVar5].timestamp_lastseen = TVar6;
        wifiMgmr.scan_items[iVar5].rssi = bVar1;
        wifiMgmr.scan_items[iVar5].auth = pbVar3[0x3f];
        wifiMgmr.scan_items[iVar5].cipher = pbVar3[0x40];
        wifiMgmr.scan_items[iVar5].is_used = '\x01';
      }
    }
  }
  return false;
}



void __reload_tsen(timer_cb_arg_t data)

{
  pvTimerGetTimerID((TimerHandle_t)data);
  wifi_mgmr_api_fw_tsen_reload();
  return;
}



void event_cb_wifi_event_mgmr(input_event_t *event,void *private_data)

{
  if (event->code == 0x14) {
    aos_post_delayed_action(0x55,trigger_auto_denoise,(void *)0x0);
    return;
  }
  return;
}



void trigger_auto_denoise(void *arg)

{
  if (auto_repeat != 0) {
    wifi_mgmr_api_denoise_enable();
    aos_post_delayed_action(0x55,trigger_auto_denoise,(void *)0x0);
    return;
  }
  return;
}



void stateDisconnect_exit(void *stateData,event *event)

{
  printf("[WF][SM] Exiting %s state\r\n",stateData);
  if (*(char *)((int)stateData + 0x4c) != '\0') {
    printf("Delete Timer.\r\n");
    xTimerGenericCommand((TimerHandle_t)((int)stateData + 0x20),3,0,(BaseType_t *)0x0,0);
    xTimerGenericCommand((TimerHandle_t)((int)stateData + 0x20),5,0,(BaseType_t *)0x0,0);
    *(undefined *)((int)stateData + 0x4c) = 0;
    return;
  }
  printf("Delete Timer Skipped\r\n");
  return;
}



void disconnect_retry(timer_cb_arg_t data)

{
  void *pvVar1;
  int iVar2;
  
  pvVar1 = pvTimerGetTimerID((TimerHandle_t)data);
  iVar2 = wifi_mgmr_profile_get(&wifiMgmr,(wifi_mgmr_profile_msg_t *)((int)pvVar1 + 0x4d));
  if (iVar2 != 0) {
    printf("[WF][SM] Retry Again --->>> retry Abort, since profile copy failed\r\n");
    return;
  }
  printf("[WF][SM] Retry Again --->>> retry connect\r\n");
  wifi_mgmr_api_reconnect();
  return;
}



_Bool stateGlobalGuard_fw_disconnect(void *ch,event *event)

{
  if (*(char *)event->data == '\x0f') {
    printf("Disconnect CMD\r\n");
    bl_main_disconnect();
    return false;
  }
  return false;
}



void stateConnectedIPYes_exit(void *stateData,event *event)

{
  ip4_addr_t iStack20;
  ip4_addr_t addr_ipaddr;
  
  iStack20 = (ip4_addr_t)0x0;
  printf("[WF][SM] Exiting %s state\r\n",stateData);
  netifapi_netif_common((netif *)&wifiMgmr.wlan_sta.netif,dhcp_stop,(netifapi_errt_fn)0x0);
  netifapi_netif_set_addr((netif *)&wifiMgmr.wlan_sta.netif,&iStack20,&iStack20,&iStack20);
  if (auto_repeat != 0) {
    auto_repeat = 0;
    bl_main_denoise(0);
  }
  return;
}



_Bool stateGlobalGuard_denoise(void *ev,event *event)

{
  int mode;
  
  if (*(char *)event->data != '\f') {
    return false;
  }
  if (*(int *)(event->data + 1) == 0) {
    auto_repeat = 0;
    mode = 0;
  }
  else {
    if (wifiMgmr.m.currentState != &stateConnectedIPYes) {
      return false;
    }
    mode = 3;
    if (auto_repeat == 0) {
      auto_repeat = 1;
      bl_main_denoise(1);
      aos_post_event(2,0x14,0);
      return false;
    }
  }
  bl_main_denoise(mode);
  return false;
}



_Bool stateIdleGuard_connect(void *ev,event *event)

{
  int iVar1;
  
  if (ev == (void *)(uint)*(byte *)event->data) {
    iVar1 = bl_main_if_add(1,(netif *)&wifiMgmr.wlan_sta.netif,&wifiMgmr.wlan_sta.vif_index);
    if (iVar1 != 0) {
      printf("[WF][SM] %s: add STA iface failed\r\n","stateIdleGuard_connect");
    }
    return (_Bool)(iVar1 == 0);
  }
  return false;
}



_Bool stateIfaceDownGuard_phyup(void *ev,event *event)

{
  bool bVar1;
  int iVar2;
  
  if (ev == (void *)(uint)*(byte *)event->data) {
    iVar2 = bl_main_phy_up();
    bVar1 = iVar2 == 0;
  }
  else {
    printf("[WF][SM] state mismatch\r\n");
    bVar1 = false;
  }
  return (_Bool)bVar1;
}



_Bool stateSnifferGuard_raw_send(void *ch,event *event)

{
  char *pcVar1;
  
  if (((wifiMgmr.m.currentState != &stateIdle) && (wifiMgmr.m.currentState != &stateIfaceDown)) &&
     (pcVar1 = (char *)event->data, *pcVar1 == '\x15')) {
    bl_main_raw_send(*(uint8_t **)(pcVar1 + 1),*(int *)(pcVar1 + 5));
    return false;
  }
  return false;
}



_Bool stateGlobalGuard_stop(void *ev,event *event)

{
  if (*(char *)event->data == '\t') {
    printf("[WF][SM] Stoping AP interface...\r\n");
    bl_main_apm_stop(wifiMgmr.wlan_ap.vif_index);
    printf("[WF][SM] Removing and deauth all sta client...\r\n");
    bl_main_apm_remove_all_sta();
    printf("[WF][SM] Removing AP interface...\r\n");
    bl_main_if_remove(wifiMgmr.wlan_ap.vif_index);
    printf("[WF][SM] Stopping DHCP on AP interface...\r\n");
    netifapi_netif_common((netif *)&wifiMgmr.wlan_ap.netif,(netifapi_void_fn)0x0,dhcp_server_stop);
    printf("[WF][SM] Removing ETH interface ...\r\n");
    netifapi_netif_common((netif *)&wifiMgmr.wlan_ap.netif,netif_remove,(netifapi_errt_fn)0x0);
    wifiMgmr.inf_ap_enabled = 0;
    aos_post_event(2,0xc,0);
    return false;
  }
  return false;
}



_Bool stateGlobalGuard_enable_autoreconnect(void *ch,event *event)

{
  if (ch == (void *)(uint)*(byte *)event->data) {
    printf("Enable Auto Reconnect\r\n");
    wifi_mgmr_profile_autoreconnect_enable(&wifiMgmr,-1);
    return false;
  }
  return false;
}



_Bool stateGlobalGuard_disable_autoreconnect(void *ch,event *event)

{
  bool bVar1;
  
  if (ch == (void *)(uint)*(byte *)event->data) {
    bVar1 = wifiMgmr.m.currentState != &stateDisconnect;
    if (bVar1) {
      printf("Disable Auto Reconnect\r\n");
      wifi_mgmr_profile_autoreconnect_disable(&wifiMgmr,-1);
    }
    else {
      printf("Disable Autoreconnect in Disconnec State\r\n");
      printf("[WF][SM] Removing STA interface...\r\n");
      bl_main_if_remove(wifiMgmr.wlan_sta.vif_index);
    }
    return (_Bool)!bVar1;
  }
  return false;
}



// WARNING: Variable defined which should be unmapped: is_ok

void stateDisconnect_enter(void *stateData,event *event)

{
  int iVar1;
  TickType_t xOptionalValue;
  uint uVar2;
  uint uStack20;
  int is_ok;
  
  uStack20 = 0;
  printf("[WF][SM] Entering %s state\r\n",stateData);
  iVar1 = wifi_mgmr_profile_autoreconnect_is_enabled(&wifiMgmr,-1);
  if (iVar1 == 0) {
    printf("[WF][SM] Will NOT retry connect\r\n");
  }
  else {
    xTimerCreateStatic("wifi disconnect",2000,0,stateData,disconnect_retry,
                       (StaticTimer_t *)(TimerHandle_t)((int)stateData + 0x20));
    printf("[WF][SM] Will retry in 2000 ticks\r\n");
    xOptionalValue = xTaskGetTickCount();
    xTimerGenericCommand
              ((TimerHandle_t)((int)stateData + 0x20),1,xOptionalValue,(BaseType_t *)0x0,0xffffffff)
    ;
    *(undefined *)((int)stateData + 0x4c) = 1;
  }
  aos_post_event(2,5,(uint)wifiMgmr.wifi_mgmr_stat_info.status_code);
  uVar2 = bl60x_check_mac_status((int *)&uStack20);
  if ((uVar2 | uStack20) == 0) {
    aos_post_event(2,0x17,0);
    helper_record_dump();
  }
  if ((wifiMgmr.pending_task & 1) != 0) {
    printf("[WF][SM] Pending Scan Sent\r\n");
    bl_main_scan();
    wifiMgmr.pending_task = wifiMgmr.pending_task & 0xfffffffe;
  }
  return;
}



_Bool stateGlobalGuard_fw_scan(void *ch,event *event)

{
  if (*(char *)event->data == '\x12') {
    if (((wifiMgmr.m.currentState == &stateConnecting) ||
        (wifiMgmr.m.currentState == &stateConnectedIPNo)) ||
       (wifiMgmr.m.currentState == &stateDisconnect)) {
      printf("------>>>>>> Scan CMD Pending\r\n");
      wifiMgmr.pending_task = wifiMgmr.pending_task | 1;
    }
    else {
      if (((wifiMgmr.m.currentState == &stateIdle) ||
          (wifiMgmr.m.currentState == &stateConnectedIPYes)) ||
         (wifiMgmr.m.currentState == &stateSniffer)) {
        printf("------>>>>>> Scan CMD\r\n");
        bl_main_scan();
      }
      else {
        printf("------>>>>>> FW busy\r\n");
        aos_post_event(2,9,1);
      }
    }
    return false;
  }
  return false;
}



uint stateDisconnect_guard(uint param_1,int param_2)

{
  return (uint)(param_1 == (uint)**(byte **)(param_2 + 4));
}



void stateGlobalExit(void)

{
  printf("[WF][SM] Entering %s state\r\n");
  return;
}



void stateSnifferEnter(void)

{
  printf("[WF][SM] Entering %s state\r\n");
  return;
}



uint stateConnectingGuard(uint param_1,int param_2)

{
  return (uint)(param_1 == (uint)**(byte **)(param_2 + 4));
}



void stateConnectingAction_connected(void)

{
  printf("[WF][SM] State Action ###%s### --->>> ###%s###\r\n");
  return;
}



void stateConnectingAction_disconnect(void)

{
  printf("[WF][SM] State Action ###%s### --->>> ###%s###\r\n");
  return;
}



void stateConnectingExit(void)

{
  printf("[WF][SM] Exiting %s state\r\n");
  return;
}



void stateIdleAction_sniffer(void)

{
  printf("[WF][SM] State Action ###%s### --->>> ###%s###\r\n");
  return;
}



void stateIdleEnter(void)

{
  printf("[WF][SM] Entering %s state\r\n");
  return;
}



void stateIdleExit(void)

{
  printf("[WF][SM] Entering %s state\r\n");
  return;
}



void stateIfaceDownAction_phyup(void)

{
  printf("[WF][SM] State Action ###%s### --->>> ###%s###\r\n");
  return;
}



void stateIfaceDownEnter(void)

{
  printf("[WF][SM] Entering %s state\r\n");
  return;
}



void stateIfaceDownExit(void)

{
  printf("[WF][SM] Exiting %s state\r\n");
  return;
}



uint stateConnectedIPNoGuard(uint param_1,int param_2)

{
  return (uint)(param_1 == (uint)**(byte **)(param_2 + 4));
}



void stateConnectedIPNoAction_disconnect(void)

{
  printf("[WF][SM] State Action ###%s### --->>> ###%s###\r\n");
  return;
}



uint stateConnectedIPYesGuard(uint param_1,int param_2)

{
  return (uint)(param_1 == (uint)**(byte **)(param_2 + 4));
}



void stateConnectedIPYes_action(void)

{
  printf("[WF][SM] State Action ###%s### --->>> ###%s###\r\n");
  return;
}



void stateConnectedIPYes_enter(void *stateData,event *event)

{
  printf("[WF][SM] Entering %s state\r\n",stateData);
  aos_post_event(2,7,0);
  if ((wifiMgmr.pending_task & 1) != 0) {
    printf("[WF][SM] Pending Scan Sent\r\n");
    bl_main_scan();
    wifiMgmr.pending_task = wifiMgmr.pending_task & 0xfffffffe;
  }
  return;
}



char * wifi_mgmr_auth_to_str(uint8_t auth)

{
  undefined3 in_register_00002029;
  
  switch(CONCAT31(in_register_00002029,auth)) {
  case 0:
    return "Open";
  case 1:
    return "WEP";
  case 2:
    return "WPA-PSK";
  case 3:
    return "WPA2-PSK";
  case 4:
    return "WPA2-PSK/WPA-PSK";
  case 5:
    return "WPA/WPA2-Enterprise";
  default:
    return "Unknown";
  }
}



char * wifi_mgmr_cipher_to_str(uint8_t cipher)

{
  undefined3 in_register_00002029;
  int iVar1;
  
  iVar1 = CONCAT31(in_register_00002029,cipher);
  if (iVar1 == 0) {
    return "NONE";
  }
  if (iVar1 == 1) {
    return "WEP";
  }
  if (iVar1 == 2) {
    return "AES";
  }
  if (iVar1 != 3) {
    if (iVar1 != 4) {
      return "Unknown";
    }
    return "TKIP/AES";
  }
  return "TKIP";
}



int wifi_mgmr_event_notify(wifi_mgmr_msg_t *msg)

{
  size_t sVar1;
  int iVar2;
  
  while (wifiMgmr.ready == '\0') {
    printf("Wait Wi-Fi Mgmr Start up...\r\n");
    vTaskDelay(0x14);
  }
  sVar1 = xStreamBufferSend((StreamBufferHandle_t)&wifiMgmr.mq,msg,msg->len,0xffffffff);
  iVar2 = 0;
  if (sVar1 == 0) {
    printf("Failed when send msg 0x%p, len dec:%u\r\n",msg,msg->len);
    iVar2 = -1;
  }
  return iVar2;
}



// WARNING: Could not reconcile some variable overlaps

void wifi_mgmr_start(void)

{
  TickType_t xOptionalValue;
  size_t sVar1;
  void *pvRxData;
  int16_t iStack274;
  int16_t temp;
  int iStack272;
  event ev;
  uint8_t buffer [232];
  
  pvRxData = (void *)((int)&ev.data + 1);
  iStack272 = 1;
  ev.type = (int)pvRxData;
  stateM_init(&wifiMgmr.m,&stateIfaceDown,&stateError);
  wifi_mgmr_event_init();
  aos_register_event_filter(2,event_cb_wifi_event_mgmr,(void *)0x0);
  aos_post_event(2,2,0);
  hal_sys_capcode_update(-1,-1);
  printf("[WF][SM] reload tsen \r\n");
  xTimerCreateStatic("wifi reload tsen",10000,1,&state_tsen_reload_data,__reload_tsen,
                     (StaticTimer_t *)&state_tsen_reload_data.timer);
  xOptionalValue = xTaskGetTickCount();
  xTimerGenericCommand
            ((TimerHandle_t)&state_tsen_reload_data.timer,1,xOptionalValue,(BaseType_t *)0x0,
             0xffffffff);
  do {
    while( true ) {
      do {
        sVar1 = xStreamBufferReceive((StreamBufferHandle_t)&wifiMgmr.mq,pvRxData,0xe0,0xffffffff);
      } while (sVar1 == 0);
      if (ev.data._1_1_ != 0xd) break;
      iStack274 = 0;
      if ((((wifiMgmr.m.currentState == &stateConnecting) ||
           (wifiMgmr.m.currentState == &stateDisconnect)) ||
          (wifiMgmr.m.currentState == &stateConnectedIPYes)) ||
         ((wifiMgmr.m.currentState == &stateSniffer ||
          (wifiMgmr.m.currentState == &stateConnectedIPNo)))) {
        bl_tsen_adc_get(&iStack274,0);
        phy_tcal_callback(iStack274);
      }
    }
    iStack272 = 1;
    if (0xd < ev.data._1_1_) {
      iStack272 = (uint)(0x16 < ev.data._1_1_) << 1;
    }
    stateM_handleEvent(&wifiMgmr.m,(event *)&stack0xfffffef0);
  } while( true );
}



void _wifi_mgmr_entry(void *pvParameters)

{
  wifi_conf_t *conf;
  TaskHandle_t aptStack36 [4];
  code *pcStack20;
  
  pcStack20 = wifi_mgmr_start_background;
  conf = (wifi_conf_t *)wifi_mgmr_start();
  wifi_mgmr_drv_init(conf);
  aptStack36[0] = (TaskHandle_t)0x0;
  xTaskCreate(_wifi_mgmr_entry,"wifi_mgmr",0x300,(void *)0x0,0x1c,aptStack36);
  return;
}



void wifi_mgmr_start_background(wifi_conf_t *conf)

{
  TaskHandle_t ptStack20;
  TaskHandle_t xHandle;
  
  wifi_mgmr_drv_init(conf);
  ptStack20 = (TaskHandle_t)0x0;
  xTaskCreate(_wifi_mgmr_entry,"wifi_mgmr",0x300,(void *)0x0,0x1c,&ptStack20);
  return;
}



int wifi_mgmr_init(void)

{
  StreamBufferHandle_t pSVar1;
  
  pSVar1 = xStreamBufferGenericCreateStatic
                     (0x8c0,0,1,wifiMgmr.mq_pool,(StaticStreamBuffer_t *)&wifiMgmr.mq);
  wifiMgmr.ready = '\x01';
  wifiMgmr.scan_item_timeout = 15000;
  return (uint)(pSVar1 == (StreamBufferHandle_t)0x0);
}



int wifi_mgmr_state_get_internal(int *state)

{
  uint16_t uVar1;
  int iVar2;
  
  uVar1 = wifiMgmr.wifi_mgmr_stat_info.status_code;
  if (wifiMgmr.m.currentState == &stateIdle) {
    if (wifiMgmr.inf_ap_enabled != 0) {
      iVar2 = 0x11;
      goto LAB_230262ac;
    }
    iVar2 = 1;
  }
  else {
    if (wifiMgmr.m.currentState == &stateConnecting) {
      if (wifiMgmr.inf_ap_enabled != 0) {
        iVar2 = 0x12;
        goto LAB_230262ac;
      }
      iVar2 = 2;
    }
    else {
      if (wifiMgmr.m.currentState == &stateConnectedIPNo) {
        if (wifiMgmr.inf_ap_enabled == 0) {
          iVar2 = 3;
        }
        else {
          iVar2 = 0x13;
        }
        goto LAB_230262ac;
      }
      if (wifiMgmr.m.currentState == &stateConnectedIPYes) {
        if (wifiMgmr.inf_ap_enabled == 0) {
          iVar2 = 4;
        }
        else {
          iVar2 = 0x14;
        }
        goto LAB_230262ac;
      }
      if (wifiMgmr.m.currentState != &stateDisconnect) {
        if (wifiMgmr.m.currentState == &stateIfaceDown) {
          iVar2 = 6;
        }
        else {
          if (wifiMgmr.m.currentState != &stateSniffer) {
            *state = 0;
            return 0;
          }
          iVar2 = 7;
        }
        goto LAB_230262ac;
      }
      if (wifiMgmr.inf_ap_enabled != 0) {
        iVar2 = 0x15;
        goto LAB_230262ac;
      }
      iVar2 = 5;
    }
  }
  *state = iVar2;
  if (uVar1 == 8) {
    iVar2 = 8;
  }
  else {
    if (uVar1 != 0xc) {
      return 0;
    }
    iVar2 = 9;
  }
LAB_230262ac:
  *state = iVar2;
  return 0;
}



void wifi_mgmr_set_connect_stat_info(wifi_event_sm_connect_ind *ind,uint8_t type_ind)

{
  uint8_t uVar1;
  uint8_t *puVar2;
  uint8_t *puVar3;
  
  wifiMgmr.wifi_mgmr_stat_info.status_code = ind->status_code;
  puVar2 = ind->bssid;
  puVar3 = wifiMgmr.wifi_mgmr_stat_info.bssid;
  do {
    uVar1 = *puVar2;
    puVar2 = puVar2 + 1;
    *puVar3 = uVar1;
    puVar3 = puVar3 + 1;
  } while (puVar2 != &ind->vif_idx);
  wifiMgmr.wifi_mgmr_stat_info.type_ind = type_ind;
  wifiMgmr.wifi_mgmr_stat_info.chan_freq = ind->center_freq;
  wifiMgmr.wifi_mgmr_stat_info.chan_band = ind->band;
  return;
}



int wifi_mgmr_set_country_code_internal(char *country_code)

{
  bl_main_set_country_code(country_code);
  strncpy(wifiMgmr.country_code,country_code,3);
  wifiMgmr.country_code[2] = '\0';
  wifiMgmr.channel_nums = bl_main_get_channel_nums();
  return 0;
}



int wifi_mgmr_ap_sta_cnt_get_internal(uint8_t *sta_cnt)

{
  bl_main_apm_sta_cnt_get(sta_cnt);
  return 0;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Could not reconcile some variable overlaps

int wifi_mgmr_ap_sta_info_get_internal(wifi_mgmr_sta_basic_info_t *sta_info_internal,uint8_t idx)

{
  undefined2 uStack40;
  wifi_apm_sta_info apm_sta_info;
  
  memset(&uStack40,0,0x18);
  bl_main_apm_sta_info_get((wifi_apm_sta_info *)&uStack40,idx);
  *(undefined2 *)sta_info_internal = uStack40;
  sta_info_internal->rssi = apm_sta_info.tsflo;
  sta_info_internal->tsflo = apm_sta_info.tsfhi;
  sta_info_internal->tsfhi = apm_sta_info.sta_mac._2_4_;
  sta_info_internal->data_rate = (uint8_t)apm_sta_info.rssi;
  memcpy(sta_info_internal->sta_mac,&uStack40 + 1,6);
  return 0;
}



int wifi_mgmr_ap_sta_delete_internal(uint8_t sta_idx)

{
  bl_main_apm_sta_delete(sta_idx);
  return 0;
}



int wifi_mgmr_scan_complete_notify(void)

{
  wifi_mgmr_scan_complete_callback();
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

int wifi_mgmr_api_connect(char *ssid,char *psk,char *pmk,uint8_t *mac,uint8_t band,uint16_t freq)

{
  size_t __n;
  int iVar1;
  undefined3 in_register_00002039;
  undefined2 in_register_0000203e;
  WIFI_MGMR_EVENT_T WStack232;
  undefined uStack231;
  undefined uStack230;
  undefined uStack229;
  uint8_t buffer [198];
  
  memset(&WStack232,0,0xc6);
  WStack232 = WIFI_MGMR_EVENT_APP_CONNECT;
  uStack231 = 0x44;
  uStack230 = 0x33;
  uStack229 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = -0x3a;
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  __n = strlen(ssid);
  buffer._42_2_ = (undefined2)__n;
  buffer._44_2_ = (undefined2)(__n >> 0x10);
  memcpy(buffer + 9,ssid,__n);
  buffer[41] = '\0';
  if (psk == (char *)0x0) {
    buffer._176_4_ = 0;
LAB_23026504:
    buffer[110] = '\0';
    if (pmk == (char *)0x0) {
      buffer._180_4_ = 0;
    }
    else {
      buffer._180_4_ = strlen(pmk);
      if (buffer._180_4_ != 0) {
        if (buffer._180_4_ != 0x40) goto LAB_23026562;
        memcpy(buffer + 0x6f,pmk,0x40);
      }
    }
    buffer[175] = '\0';
    if (mac != (uint8_t *)0x0) {
      memcpy(buffer + 0xb8,mac,6);
    }
    if (CONCAT22(in_register_0000203e,freq) != 0) {
      buffer[191] = (uint8_t)freq;
      buffer[192] = (uint8_t)(freq >> 8);
      buffer[190] = band;
      printf("wifi mgmr band:%d freq: %d\r\n",CONCAT31(in_register_00002039,band),
             CONCAT22(in_register_0000203e,freq));
    }
    buffer[193] = '\x01';
    wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&WStack232);
    iVar1 = 0;
  }
  else {
    buffer._176_4_ = strlen(psk);
    if (buffer._176_4_ < 0x41) {
      if (buffer._176_4_ != 0) {
        memcpy(buffer + 0x2e,psk,buffer._176_4_);
      }
      goto LAB_23026504;
    }
LAB_23026562:
    iVar1 = -1;
  }
  return iVar1;
}



int wifi_mgmr_api_cfg_req
              (uint32_t ops,uint32_t task,uint32_t element,uint32_t type,uint32_t length,
              uint32_t *buf)

{
  int iVar1;
  WIFI_MGMR_EVENT_T WStack100;
  undefined uStack99;
  undefined uStack98;
  undefined uStack97;
  uint8_t buffer [65];
  
  if (length < 0x21) {
    memset(&WStack100,0,0x41);
    WStack100 = WIFI_MGMR_EVENT_FW_CFG_REQ;
    uStack99 = 0x44;
    uStack98 = 0x33;
    uStack97 = 0x22;
    buffer[0] = '\x11';
    buffer[1] = -0x78;
    buffer[2] = 'w';
    iVar1 = length + 0xc6;
    buffer[3] = 'f';
    buffer[4] = 'U';
    buffer[6] = (uint8_t)((uint)iVar1 >> 8);
    buffer[7] = (uint8_t)((uint)iVar1 >> 0x10);
    buffer[10] = (uint8_t)(ops >> 8);
    buffer[11] = (uint8_t)(ops >> 0x10);
    buffer[14] = (uint8_t)(task >> 8);
    buffer[15] = (uint8_t)(task >> 0x10);
    buffer[18] = (uint8_t)(element >> 8);
    buffer[19] = (uint8_t)(element >> 0x10);
    buffer[22] = (uint8_t)(type >> 8);
    buffer[23] = (uint8_t)(type >> 0x10);
    buffer[5] = (uint8_t)iVar1;
    buffer[9] = (uint8_t)ops;
    buffer[13] = (uint8_t)task;
    buffer[17] = (uint8_t)element;
    buffer[21] = (uint8_t)type;
    buffer[26] = (uint8_t)(length >> 8);
    buffer[27] = (uint8_t)(length >> 0x10);
    buffer[8] = (uint8_t)((uint)iVar1 >> 0x18);
    buffer[12] = (uint8_t)(ops >> 0x18);
    buffer[16] = (uint8_t)(task >> 0x18);
    buffer[20] = (uint8_t)(element >> 0x18);
    buffer[24] = (uint8_t)(type >> 0x18);
    buffer[25] = (uint8_t)length;
    buffer[28] = (uint8_t)(length >> 0x18);
    if (length != 0) {
      memcpy(buffer + 0x1d,buf,length);
    }
    wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&WStack100);
    return 0;
  }
  return -1;
}



// WARNING: Variable defined which should be unmapped: buffer

int wifi_mgmr_api_ip_got(uint32_t ip,uint32_t mask,uint32_t gw,uint32_t dns1,uint32_t dns2)

{
  WIFI_MGMR_EVENT_T WStack52;
  undefined uStack51;
  undefined uStack50;
  undefined uStack49;
  uint8_t buffer [33];
  
  memset(&WStack52,0,0x21);
  WStack52 = WIFI_MGMR_EVENT_APP_IP_GOT;
  uStack51 = 0x44;
  uStack50 = 0x33;
  uStack49 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = '!';
  buffer[10] = (uint8_t)(ip >> 8);
  buffer[11] = (uint8_t)(ip >> 0x10);
  buffer[14] = (uint8_t)(mask >> 8);
  buffer[15] = (uint8_t)(mask >> 0x10);
  buffer[18] = (uint8_t)(gw >> 8);
  buffer[19] = (uint8_t)(gw >> 0x10);
  buffer[9] = (uint8_t)ip;
  buffer[13] = (uint8_t)mask;
  buffer[17] = (uint8_t)gw;
  buffer[21] = (uint8_t)dns1;
  buffer[22] = (uint8_t)(dns1 >> 8);
  buffer[12] = (uint8_t)(ip >> 0x18);
  buffer[16] = (uint8_t)(mask >> 0x18);
  buffer[20] = (uint8_t)(gw >> 0x18);
  buffer[23] = (uint8_t)(dns1 >> 0x10);
  buffer[24] = (uint8_t)(dns1 >> 0x18);
  buffer[25] = (uint8_t)dns2;
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  buffer[26] = (uint8_t)(dns2 >> 8);
  buffer[27] = (uint8_t)(dns2 >> 0x10);
  buffer[28] = (uint8_t)(dns2 >> 0x18);
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&WStack52);
  return 0;
}



int wifi_mgmr_api_ip_update(void)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  local_20 = WIFI_MGMR_EVENT_GLB_IP_UPDATE;
  uStack31 = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



int wifi_mgmr_api_reconnect(void)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  local_20 = WIFI_MGMR_EVENT_APP_RECONNECT;
  uStack31 = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



int wifi_mgmr_api_disable_autoreconnect(void)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  local_20 = WIFI_MGMR_EVENT_GLB_DISABLE_AUTORECONNECT;
  uStack31 = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



int wifi_mgmr_api_enable_autoreconnect(void)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  local_20 = WIFI_MGMR_EVENT_GLB_ENABLE_AUTORECONNECT;
  uStack31 = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



int wifi_mgmr_api_disconnect(void)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  local_20 = WIFI_MGMR_EVENT_APP_DISCONNECT;
  uStack31 = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



int wifi_mgmr_api_rate_config(uint16_t config)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  local_20 = WIFI_MGMR_EVENT_APP_RC_CONFIG;
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  uStack31 = (undefined)config;
  buffer[4] = 'U';
  uStack30 = (undefined)(config >> 8);
  uStack29 = 0;
  buffer[0] = '\0';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



int wifi_mgmr_api_conf_max_sta(uint8_t max_sta_supported)

{
  WIFI_MGMR_EVENT_T local_20;
  uint8_t uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  local_20 = WIFI_MGMR_EVENT_APP_CONF_MAX_STA;
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  uStack30 = 0;
  uStack29 = 0;
  buffer[0] = '\0';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  uStack31 = max_sta_supported;
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



int wifi_mgmr_api_ifaceup(void)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  local_20 = WIFI_MGMR_EVENT_APP_PHY_UP;
  uStack31 = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



int wifi_mgmr_api_sniffer_enable(void)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  local_20 = WIFI_MGMR_EVENT_APP_SNIFFER;
  uStack31 = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



int wifi_mgmr_api_scan_item_beacon
              (uint8_t channel,int8_t rssi,uint8_t auth,uint8_t *mac,uint8_t *ssid,int len,
              int8_t ppm_abs,int8_t ppm_rel,uint8_t cipher)

{
  WIFI_MGMR_EVENT_T WStack108;
  undefined uStack107;
  undefined uStack106;
  undefined uStack105;
  uint8_t buffer [73];
  
  memset(&WStack108,0,0x49);
  WStack108 = WIFI_MGMR_EVENT_GLB_SCAN_IND_BEACON;
  uStack107 = 0x44;
  uStack106 = 0x33;
  uStack105 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = 'I';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  memcpy(buffer + 9,ssid,len);
  buffer[45] = (uint8_t)len;
  buffer[46] = (uint8_t)((uint)len >> 8);
  buffer[47] = (uint8_t)((uint)len >> 0x10);
  buffer[48] = (uint8_t)((uint)len >> 0x18);
  buffer[41] = '\0';
  memcpy(buffer + 0x31,mac,6);
  buffer[55] = channel;
  buffer[56] = rssi;
  buffer[57] = ppm_abs;
  buffer[58] = ppm_rel;
  buffer[59] = auth;
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&WStack108);
  return 0;
}



int wifi_mgmr_api_fw_disconnect(void)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  local_20 = WIFI_MGMR_EVENT_FW_DISCONNECT;
  uStack31 = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



int wifi_mgmr_api_fw_tsen_reload(void)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  uStack31 = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  local_20 = WIFI_MGMR_EVENT_APP_RELOAD_TSEN;
  buffer[4] = 'U';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



int wifi_mgmr_api_fw_scan(void)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  local_20 = WIFI_MGMR_EVENT_FW_SCAN;
  uStack31 = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



int wifi_mgmr_api_fw_powersaving(int mode)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  local_20 = WIFI_MGMR_EVENT_FW_POWERSAVING;
  uStack30 = (undefined)((uint)mode >> 8);
  uStack29 = (undefined)((uint)mode >> 0x10);
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  uStack31 = (undefined)mode;
  buffer[4] = 'U';
  buffer[0] = (uint8_t)((uint)mode >> 0x18);
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

int wifi_mgmr_api_ap_start(char *ssid,char *passwd,int channel,uint8_t hidden_ssid)

{
  size_t sVar1;
  int iVar2;
  undefined3 in_register_00002035;
  WIFI_MGMR_EVENT_T WStack156;
  undefined uStack155;
  undefined uStack154;
  undefined uStack153;
  uint8_t buffer [124];
  
  if (ssid == (char *)0x0) {
    return -1;
  }
  memset(&WStack156,0,0x7c);
  sVar1 = strlen(ssid);
  buffer[47] = (uint8_t)sVar1;
  buffer._48_4_ = buffer._48_4_ & 0xff000000 | sVar1 >> 8;
  if (sVar1 < 0x21) {
    if (passwd != (char *)0x0) {
      buffer._116_4_ = strlen(passwd);
      if (0x20 < buffer._116_4_) goto LAB_23026f80;
    }
    WStack156 = WIFI_MGMR_EVENT_APP_AP_START;
    uStack155 = 0x44;
    uStack154 = 0x33;
    uStack153 = 0x22;
    buffer[0] = '\x11';
    buffer[1] = -0x78;
    buffer[2] = 'w';
    buffer[3] = 'f';
    buffer[4] = 'U';
    buffer[5] = '|';
    buffer[6] = '\0';
    buffer[7] = '\0';
    buffer[8] = '\0';
    memcpy(buffer + 0xd,ssid,(uint)buffer[47] | buffer._48_4_ << 8);
    if (passwd == (char *)0x0) {
      buffer._116_4_ = 0;
    }
    else {
      memcpy(buffer + 0x33,passwd,buffer._116_4_);
    }
    buffer[9] = (uint8_t)channel;
    buffer[10] = (uint8_t)((uint)channel >> 8);
    buffer[46] = CONCAT31(in_register_00002035,hidden_ssid) != 0;
    buffer[11] = (uint8_t)((uint)channel >> 0x10);
    buffer[12] = (uint8_t)((uint)channel >> 0x18);
    wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&WStack156);
    iVar2 = 0;
  }
  else {
LAB_23026f80:
    iVar2 = -1;
  }
  return iVar2;
}



int wifi_mgmr_api_ap_stop(void)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  local_20 = WIFI_MGMR_EVENT_APP_AP_STOP;
  uStack31 = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



int wifi_mgmr_api_idle(void)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  uStack31 = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  local_20 = WIFI_MGMR_EVENT_APP_IDLE;
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



int wifi_mgmr_api_denoise_enable(void)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  local_20 = WIFI_MGMR_EVENT_APP_DENOISE;
  uStack31 = 1;
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  uStack30 = 0;
  uStack29 = 0;
  buffer[0] = '\0';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



int wifi_mgmr_api_denoise_disable(void)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  local_20 = WIFI_MGMR_EVENT_APP_DENOISE;
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  uStack31 = 0;
  uStack30 = 0;
  uStack29 = 0;
  buffer[0] = '\0';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



int wifi_mgmr_api_raw_send(uint8_t *pkt,int len)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  local_20 = WIFI_MGMR_EVENT_FW_DATA_RAW_SEND;
  uStack30 = (undefined)((uint)pkt >> 8);
  uStack29 = (undefined)((uint)pkt >> 0x10);
  buffer[2] = (uint8_t)((uint)len >> 8);
  uStack31 = SUB41(pkt,0);
  buffer[1] = (uint8_t)len;
  buffer[3] = (uint8_t)((uint)len >> 0x10);
  buffer[0] = (uint8_t)((uint)pkt >> 0x18);
  buffer[4] = (uint8_t)((uint)len >> 0x18);
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



int wifi_mgmr_api_set_country_code(char *country_code)

{
  wifi_mgmr_set_country_code_internal(country_code);
  return 0;
}



void cmd_rf_dump(char *buf,int len,int argc,char **argv)

{
  return;
}



void cmd_dump_reset(char *buf,int len,int argc,char **argv)

{
  pkt_counter = 10;
  return;
}



void cmd_wifi_power_table_update(char *buf,int len,int argc,char **argv)

{
  int8_t aiStack56 [4];
  int8_t power_table_test [38];
  
  memcpy(aiStack56,&DAT_2307d844,0x26);
  bl_tpc_update_power_table(aiStack56);
  return;
}



void cmd_wifi_state_get(char *buf,int len,int argc,char **argv)

{
  char *__format;
  int iStack20;
  int state;
  
  iStack20 = 0;
  wifi_mgmr_state_get(&iStack20);
  switch(iStack20) {
  case 0:
    __format = "wifi state unknown\r\n";
    break;
  case 1:
    __format = "wifi state idle\r\n";
    break;
  case 2:
    __format = "wifi state connecting\r\n";
    break;
  case 3:
    __format = "wifi state connected ip getting\r\n";
    break;
  case 4:
    __format = "wifi state connected ip got\r\n";
    break;
  case 5:
    __format = "wifi state disconnect\r\n";
    break;
  case 6:
    __format = "wifi state ifdown\r\n";
    break;
  case 7:
    __format = "wifi state sniffer\r\n";
    break;
  case 8:
    __format = "wifi state psk error\r\n";
    break;
  case 9:
    __format = "wifi state no ap found\r\n";
    break;
  default:
    goto switchD_2302724c_caseD_a;
  case 0x11:
    __format = "wifi state with ap idle\r\n";
    break;
  case 0x12:
    __format = "wifi state with ap connecting\r\n";
    break;
  case 0x13:
    __format = "wifi state with ap connected ip getting\r\n";
    break;
  case 0x14:
    __format = "wifi state with ap connected ip got\r\n";
    break;
  case 0x15:
    __format = "wifi state with ap disconnect\r\n";
  }
  printf(__format);
switchD_2302724c_caseD_a:
  return;
}



void wifi_sta_get_state_cmd(char *buf,int len,int argc,char **argv)

{
  char "wifi_sta_get_state_cmd" [23];
  char *__format;
  int iStack20;
  int state;
  
  iStack20 = 0;
  wifi_mgmr_state_get(&iStack20);
  printf("%s:wifi state = 0x%x\r\n","wifi_sta_get_state_cmd",iStack20);
  if (iStack20 == 0) {
    __format = "wifi current state: WIFI_STATE_UNKNOWN\r\n";
  }
  else {
    if (iStack20 == 1) {
      __format = "wifi current state: WIFI_STATE_IDLE\r\n";
    }
    else {
      if (iStack20 == 2) {
        __format = "wifi current state: WIFI_STATE_CONNECTING\r\n";
      }
      else {
        if (iStack20 == 3) {
          __format = "wifi current state: WIFI_STATE_CONNECTED_IP_GETTING\r\n";
        }
        else {
          if (iStack20 == 4) {
            __format = "wifi current state: WIFI_STATE_CONNECTED_IP_GOT\r\n";
          }
          else {
            if (iStack20 == 5) {
              __format = "wifi current state: WIFI_STATE_DISCONNECT\r\n";
            }
            else {
              if (iStack20 == 0x11) {
                __format = "wifi current state: WIFI_STATE_WITH_AP_IDLE\r\n";
              }
              else {
                if (iStack20 == 0x12) {
                  __format = "wifi current state: WIFI_STATE_WITH_AP_CONNECTING\r\n";
                }
                else {
                  if (iStack20 == 0x13) {
                    __format = "wifi current state: WIFI_STATE_WITH_AP_CONNECTED_IP_GETTING\r\n";
                  }
                  else {
                    if (iStack20 == 0x14) {
                      __format = "wifi current state: WIFI_STATE_WITH_AP_CONNECTED_IP_GOT\r\n";
                    }
                    else {
                      if (iStack20 == 0x15) {
                        __format = "wifi current state: WIFI_STATE_WITH_AP_DISCONNECT\r\n";
                      }
                      else {
                        if (iStack20 == 6) {
                          __format = "wifi current state: WIFI_STATE_IFDOWN\r\n";
                        }
                        else {
                          if (iStack20 == 7) {
                            __format = "wifi current state: WIFI_STATE_SNIFFER\r\n";
                          }
                          else {
                            if (iStack20 == 8) {
                              __format = "wifi current state: WIFI_STATE_PSK_ERROR\r\n";
                            }
                            else {
                              if (iStack20 == 9) {
                                __format = "wifi current state: WIFI_STATE_NO_AP_FOUND\r\n";
                              }
                              else {
                                __format = "wifi current state: invalid\r\n";
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  printf(__format);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void wifi_edca_dump_cmd(char *buf,int len,int argc,char **argv)

{
  byte local_15;
  byte local_14;
  byte local_13;
  uint8_t aifs;
  ushort uStack18;
  uint8_t cwmin;
  uint8_t cwmax;
  uint16_t txop;
  
  local_15 = 0;
  local_14 = 0;
  local_13 = 0;
  uStack18 = 0;
  puts("EDCA Statistic:\r\n");
  bl60x_edca_get(0,&local_15,&local_14,&local_13,(uint16_t *)&stack0xffffffee);
  puts("  AC_BK:");
  printf("aifs %3u, cwmin %3u, cwmax %3u, txop %4u\r\n",(uint)local_15,(uint)local_14,(uint)local_13
         ,(uint)uStack18);
  bl60x_edca_get(1,&local_15,&local_14,&local_13,(uint16_t *)&stack0xffffffee);
  puts("  AC_BE:");
  printf("aifs %3u, cwmin %3u, cwmax %3u, txop %4u\r\n",(uint)local_15,(uint)local_14,(uint)local_13
         ,(uint)uStack18);
  bl60x_edca_get(2,&local_15,&local_14,&local_13,(uint16_t *)&stack0xffffffee);
  puts("  AC_VI:");
  printf("aifs %3u, cwmin %3u, cwmax %3u, txop %4u\r\n",(uint)local_15,(uint)local_14,(uint)local_13
         ,(uint)uStack18);
  bl60x_edca_get(3,&local_15,&local_14,&local_13,(uint16_t *)&stack0xffffffee);
  puts("  AC_VO:");
  printf("aifs %3u, cwmin %3u, cwmax %3u, txop %4u\r\n",(uint)local_15,(uint)local_14,(uint)local_13
         ,(uint)uStack18);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void wifi_ap_sta_list_get_cmd(char *buf,int len,int argc,char **argv)

{
  char cVar1;
  uint uVar2;
  char *__format;
  wifi_ap_data_rate *pwVar3;
  byte bStack77;
  uint8_t sta_cnt;
  uint uStack76;
  int state;
  wifi_sta_basic_info sta_info;
  
  uStack76 = 0;
  bStack77 = 0;
  wifi_mgmr_state_get((int *)&stack0xffffffb4);
  if ((uStack76 & 0x10) == 0) {
    __format = "wifi AP is not enabled, state = %d\r\n";
    uVar2 = uStack76;
  }
  else {
    wifi_mgmr_ap_sta_cnt_get(&bStack77);
    if (bStack77 != 0) {
      memset(&state,0,0x18);
      printf("sta list:\r\n");
      printf(
            "-----------------------------------------------------------------------------------\r\n"
            );
      printf(
            "No.      StaIndex      Mac-Address       Signal      DateRate            TimeStamp\r\n"
            );
      printf(
            "-----------------------------------------------------------------------------------\r\n"
            );
      uVar2 = 0;
      do {
        if (bStack77 <= uVar2) {
          return;
        }
        wifi_mgmr_ap_sta_info_get((wifi_sta_basic_info *)&state,(uint8_t)uVar2);
        if ((state._1_1_ != '\0') && ((uint8_t)state != -0x11)) {
          pwVar3 = data_rate_list;
          cVar1 = '\0';
          do {
            if (pwVar3->data_rate == (uint8_t)sta_info.rssi) break;
            cVar1 = cVar1 + '\x01';
            pwVar3 = pwVar3 + 1;
          } while (cVar1 != '\f');
          printf(
                 " %u          %u        %02X:%02X:%02X:%02X:%02X:%02X    %d      %s      0x%llx\r\n"
                 ,uVar2,(uint)state._2_1_,(uint)state._3_1_,(uint)sta_info.sta_idx,
                 (uint)sta_info.is_used,(uint)sta_info.sta_mac[0]);
        }
        uVar2 = uVar2 + 1 & 0xff;
      } while( true );
    }
    uVar2 = 0;
    __format = "no sta connect current AP, sta_cnt = %d\r\n";
  }
  printf(__format,uVar2);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void wifi_ap_sta_delete_cmd(char *buf,int len,int argc,char **argv)

{
  char cVar1;
  byte idx;
  char *__format;
  size_t sVar2;
  char *pcVar3;
  char *__s;
  byte bVar4;
  char cVar5;
  byte bStack45;
  uint8_t sta_cnt;
  char *pcStack44;
  int state;
  wifi_sta_basic_info sta_info;
  
  pcStack44 = (char *)0x0;
  bStack45 = 0;
  if (argc == 2) {
    wifi_mgmr_state_get((int *)&stack0xffffffd4);
    if (((uint)pcStack44 & 0x10) == 0) {
      __format = "wifi AP is not enabled, state = %d\r\n";
      pcVar3 = pcStack44;
    }
    else {
      printf("Delete Sta No.%s \r\n",argv[1]);
      __s = argv[1];
      idx = 0;
      sVar2 = strlen(__s);
      cVar5 = '\x01';
      __format = __s + sVar2;
      *__format = '\0';
      pcVar3 = __format;
      while ((int)(__format + -(int)pcVar3) < (int)sVar2) {
        cVar1 = pcVar3[-1];
        bVar4 = cVar1 - 0x30;
        if (9 < bVar4) {
          if ((byte)(cVar1 + 0x9fU) < 6) {
            bVar4 = cVar1 + 0xa9;
          }
          else {
            bVar4 = 0;
            if ((byte)(cVar1 + 0xbfU) < 6) {
              bVar4 = cVar1 - 0x37;
            }
          }
        }
        pcVar3 = pcVar3 + -1;
        idx = idx + bVar4 * cVar5;
        cVar5 = cVar5 * '\n';
      }
      pcVar3 = (char *)(uint)idx;
      printf("sta_str: %s, str_len: %d, sta_num: %d, q: %s\r\n",__s,pcVar3);
      printf("sta num = %d \r\n",pcVar3);
      wifi_mgmr_ap_sta_cnt_get(&bStack45);
      if ((bStack45 == 0) || ((char *)(uint)bStack45 < pcVar3)) {
        __format = "no valid sta in list or sta idx(%d) is invalid\r\n";
        pcVar3 = (char *)(uint)bStack45;
      }
      else {
        memset(&state,0,0x18);
        wifi_mgmr_ap_sta_info_get((wifi_sta_basic_info *)&state,idx);
        if ((state._1_1_ != '\0') && ((uint8_t)state != -0x11)) {
          printf("sta info: No.%u,sta_idx = %u,mac = %02X:%02X:%02X:%02X:%02X:%02X,rssi = %d\r\n",
                 pcVar3,(uint)state._2_1_,(uint)state._3_1_,(uint)sta_info.sta_idx,
                 (uint)sta_info.is_used,(uint)sta_info.sta_mac[0]);
          wifi_mgmr_ap_sta_delete((uint8_t)state);
          return;
        }
        __format = "No.%d sta is invalid\r\n";
      }
    }
  }
  else {
    __format = "[USAGE]: %s sta_num\r\n";
    pcVar3 = *argv;
  }
  printf(__format,pcVar3);
  return;
}



void cmd_wifi_coex_pta_force_off(char *buf,int len,int argc,char **argv)

{
  coex_wifi_pta_forece_enable(0);
  return;
}



void cmd_wifi_coex_pta_force_on(char *buf,int len,int argc,char **argv)

{
  coex_wifi_pta_forece_enable(1);
  return;
}



void cmd_wifi_coex_pti_force_off(char *buf,int len,int argc,char **argv)

{
  coex_wifi_pti_forece_enable(0);
  return;
}



void cmd_wifi_coex_pti_force_on(char *buf,int len,int argc,char **argv)

{
  coex_wifi_pti_forece_enable(1);
  return;
}



void cmd_wifi_coex_rf_force_off(char *buf,int len,int argc,char **argv)

{
  coex_wifi_rf_forece_enable(0);
  return;
}



void cmd_wifi_coex_rf_force_on(char *buf,int len,int argc,char **argv)

{
  coex_wifi_rf_forece_enable(1);
  return;
}



void cmd_wifi_mib(char *buf,int len,int argc,char **argv)

{
  hal_mib_dump();
  utils_hexdump(*argv,0x1e);
  return;
}



void cmd_wifi_cfg(char *buf,int len,int argc,char **argv)

{
  uint uVar1;
  uint32_t task;
  int iVar2;
  uint32_t ops;
  uint32_t length;
  uint32_t *buf_00;
  uint32_t element;
  uint32_t type;
  uint32_t uStack88;
  uint32_t val [1];
  getopt_env_t getopt_env;
  
  type = 0;
  utils_getopt_init((getopt_env_t *)val,0);
  element = 0;
  task = 0;
  uVar1 = 4;
  while (iVar2 = utils_getopt((getopt_env_t *)val,argc,argv,":c:T:e:t:v:"), iVar2 != -1) {
    if (iVar2 == 99) {
      iVar2 = strcmp("dump",(char *)val);
      if (iVar2 == 0) {
        uVar1 = 3;
      }
      else {
        iVar2 = strcmp("set",(char *)val);
        if (iVar2 == 0) {
          uVar1 = 0;
        }
        else {
          iVar2 = strcmp("get",(char *)val);
          if (iVar2 == 0) {
            uVar1 = 1;
          }
          else {
            iVar2 = strcmp("reset",(char *)val);
            if (iVar2 == 0) {
              uVar1 = 2;
            }
          }
        }
      }
    }
    else {
      if (iVar2 < 100) {
        if (iVar2 == 0x3f) {
          printf("%s: unknown option %c\r\n",*argv,getopt_env.opterr);
          return;
        }
        if (iVar2 == 0x54) {
          type = atoi((char *)val);
        }
      }
      else {
        if (iVar2 == 0x74) {
          task = atoi((char *)val);
        }
        else {
          if (iVar2 == 0x76) {
            uStack88 = atoi((char *)val);
          }
          else {
            if (iVar2 == 0x65) {
              element = atoi((char *)val);
            }
          }
        }
      }
    }
  }
  printf("Target CFG Element Info, task: %lu, element %lu, type %lu, val %lu\r\n",task,element,type,
         uStack88);
  if (uVar1 == 2) {
    printf("    OPS: %s\r\n","reset");
    buf_00 = (uint32_t *)0x0;
    length = 0;
    type = 0;
    ops = 2;
  }
  else {
    if (uVar1 < 3) {
      if (uVar1 == 1) {
        printf("    OPS: %s\r\n",0x2308276c);
        buf_00 = &uStack88;
        length = 4;
        ops = 1;
        goto LAB_230278a4;
      }
    }
    else {
      if (uVar1 == 3) {
        printf("    OPS: %s\r\n",0x23082780);
        buf_00 = (uint32_t *)0x0;
        length = 0;
        type = 0;
        element = 0;
        task = 0;
        ops = 3;
        goto LAB_230278a4;
      }
      if (uVar1 == 4) {
        printf("UNKNOWN OPS\r\n");
        return;
      }
    }
    printf("    OPS: %s\r\n",0x23082744);
    buf_00 = &uStack88;
    length = 4;
    ops = 0;
  }
LAB_230278a4:
  wifi_mgmr_cfg_req(ops,task,element,type,length,buf_00);
  return;
}



void cmd_wifi_ap_stop(char *buf,int len,int argc,char **argv)

{
  wifi_mgmr_ap_stop((wifi_interface_t *)0x0);
  printf("--->>> cmd_wifi_ap_stop\r\n");
  return;
}



// WARNING: Variable defined which should be unmapped: ssid_name

void cmd_wifi_ap_start(char *buf,int len,int argc,char **argv)

{
  wifi_interface_t *interface;
  uint hidden_ssid;
  char *passwd;
  int channel;
  uint8_t auStack56 [3];
  byte bStack53;
  uint8_t mac [6];
  char ssid_name [32];
  
  memset(auStack56,0,6);
  bl_wifi_mac_addr_get(auStack56);
  memset(mac + 4,0,0x20);
  snprintf((char *)(mac + 4),0x20,"BL60X_uAP_%02X%02X%02X",(uint)bStack53,(uint)mac[0],(uint)mac[1])
  ;
  interface = (wifi_interface_t *)wifi_mgmr_ap_enable();
  if (argc == 1) {
    channel = 1;
    passwd = (char *)0x0;
    hidden_ssid = 0;
  }
  else {
    channel = atoi(argv[1]);
    if (10 < channel - 1U) {
      return;
    }
    passwd = "12345678";
    hidden_ssid = (uint)(argc == 3);
  }
  wifi_mgmr_ap_start(interface,(char *)(mac + 4),hidden_ssid,passwd,channel);
  return;
}



void wifi_sniffer_off_cmd(char *buf,int len,int argc,char **argv)

{
  wifi_mgmr_sniffer_disable();
  wifi_mgmr_sniffer_unregister((void *)0x0);
  return;
}



void wifi_sniffer_on_cmd(char *buf,int len,int argc,char **argv)

{
  wifi_mgmr_sniffer_enable();
  wifi_mgmr_sniffer_register((void *)0x0,sniffer_cb);
  return;
}



int wifi_denoise_disable_cmd(void)

{
  WIFI_MGMR_EVENT_T WStack32;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  undefined uStack28;
  undefined uStack27;
  undefined uStack26;
  undefined uStack25;
  undefined uStack24;
  undefined uStack23;
  undefined uStack22;
  undefined uStack21;
  undefined uStack20;
  
  memset(&WStack32,0,0xd);
  WStack32 = WIFI_MGMR_EVENT_APP_DENOISE;
  uStack27 = 0x88;
  uStack26 = 0x77;
  uStack25 = 0x66;
  uStack24 = 0x55;
  uStack31 = 0;
  uStack30 = 0;
  uStack29 = 0;
  uStack28 = 0;
  uStack23 = 0xd;
  uStack22 = 0;
  uStack21 = 0;
  uStack20 = 0;
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&WStack32);
  return 0;
}



int wifi_denoise_enable_cmd(void)

{
  WIFI_MGMR_EVENT_T WStack32;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  undefined uStack28;
  undefined uStack27;
  undefined uStack26;
  undefined uStack25;
  undefined uStack24;
  undefined uStack23;
  undefined uStack22;
  undefined uStack21;
  undefined uStack20;
  
  memset(&WStack32,0,0xd);
  WStack32 = WIFI_MGMR_EVENT_APP_DENOISE;
  uStack31 = 1;
  uStack27 = 0x88;
  uStack26 = 0x77;
  uStack25 = 0x66;
  uStack24 = 0x55;
  uStack30 = 0;
  uStack29 = 0;
  uStack28 = 0;
  uStack23 = 0xd;
  uStack22 = 0;
  uStack21 = 0;
  uStack20 = 0;
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&WStack32);
  return 0;
}



void wifi_power_saving_off_cmd(char *buf,int len,int argc,char **argv)

{
  wifi_mgmr_sta_powersaving(0);
  return;
}



void wifi_power_saving_on_cmd(char *buf,int len,int argc,char **argv)

{
  wifi_mgmr_sta_powersaving(2);
  return;
}



void wifi_rc_fixed_disable(char *buf,int len,int argc,char **argv)

{
  wifi_mgmr_rate_config(0xffff);
  return;
}



int wifi_disable_autoreconnect_cmd(void)

{
  wifi_mgmr_api_disable_autoreconnect();
  return 0;
}



int wifi_enable_autoreconnect_cmd(void)

{
  wifi_mgmr_api_enable_autoreconnect();
  return 0;
}



void wifi_disconnect_cmd(char *buf,int len,int argc,char **argv)

{
  wifi_mgmr_sta_disconnect();
  vTaskDelay(1000);
  wifi_mgmr_sta_disable((wifi_interface_t *)0x0);
  return;
}



int wifi_sta_ip_unset_cmd(void)

{
  int iVar1;
  
  iVar1 = wifi_mgmr_sta_ip_set(0,0,0,0,0);
  return iVar1;
}



// WARNING: Could not reconcile some variable overlaps

void wifi_sta_ip_info(char *buf,int len,int argc,char **argv)

{
  char *pcVar1;
  ip4_addr_t iStack80;
  ip4_addr_t ip;
  ip4_addr_t gw;
  ip4_addr_t mask;
  ip4_addr_t dns1;
  ip4_addr_t dns2;
  int rssi;
  int8_t power_rate_table [38];
  
  wifi_mgmr_sta_ip_get((uint32_t *)&iStack80,(uint32_t *)&ip,(uint32_t *)&gw);
  wifi_mgmr_sta_dns_get((uint32_t *)&mask,(uint32_t *)&dns1);
  wifi_mgmr_rssi_get((int *)&dns2);
  bl_tpc_power_table_get((int8_t *)&rssi);
  printf("RSSI:   %ddbm\r\n",dns2);
  pcVar1 = ip4addr_ntoa(&iStack80);
  printf("IP  :   %s \r\n",pcVar1);
  pcVar1 = ip4addr_ntoa(&gw);
  printf("MASK:   %s \r\n",pcVar1);
  pcVar1 = ip4addr_ntoa(&ip);
  printf("GW  :   %s \r\n",pcVar1);
  pcVar1 = ip4addr_ntoa(&mask);
  printf("DNS1:   %s \r\n",pcVar1);
  pcVar1 = ip4addr_ntoa(&dns1);
  printf("DNS2:   %s \r\n",pcVar1);
  puts("Power Table (dbm):\r\n");
  puts("--------------------------------\r\n");
  printf("  11b: %u %u %u %u             (1Mbps 2Mbps 5.5Mbps 11Mbps)\r\n",(int)(char)rssi,
         (int)rssi._1_1_,(int)rssi._2_1_,(int)rssi._3_1_);
  printf(
         "  11g: %u %u %u %u %u %u %u %u (6Mbps 9Mbps 12Mbps 18Mbps 24Mbps 36Mbps 48Mbps 54Mbps)\r\n"
         ,(int)power_rate_table[4],(int)power_rate_table[5],(int)power_rate_table[6],
         (int)power_rate_table[7],(int)power_rate_table[8],(int)power_rate_table[9],
         (int)power_rate_table[10]);
  printf("  11n: %u %u %u %u %u %u %u %u (MCS0 ~ MCS7)\r\n",(int)power_rate_table[12],
         (int)power_rate_table[13],(int)power_rate_table[14],(int)power_rate_table[15],
         (int)power_rate_table[16],(int)power_rate_table[17],(int)power_rate_table[18]);
  puts("--------------------------------\r\n");
  return;
}



void cmd_wifi_raw_send(char *buf,int len,int argc,char **argv)

{
  uint32_t seq;
  char *__s;
  int iVar1;
  
  iVar1 = seq << 4;
  packet_raw[22] = (uint8_t)iVar1;
  seq = seq + 1;
  packet_raw[23] = (uint8_t)((uint)iVar1 >> 8);
  iVar1 = wifi_mgmr_raw_80211_send(packet_raw,0x18);
  if (iVar1 == 0) {
    __s = "Raw send succeed\r\n";
  }
  else {
    __s = "Raw send failed\r\n";
  }
  puts(__s);
  return;
}



void wifi_scan_cmd(char *buf,int len,int argc,char **argv)

{
  wifi_mgmr_scan((void *)0x0,(scan_complete_cb_t *)0x0);
  return;
}



void sniffer_cb(void *env,uint8_t *pkt,int len)

{
  TickType_t TVar1;
  
  sniffer_counter_5067 = sniffer_counter_5067 + 1;
  TVar1 = xTaskGetTickCount();
  if (10000 < (int)(TVar1 - last_tick_5069)) {
    last_tick_5069 = xTaskGetTickCount();
  }
  return;
}



void cmd_wifi_dump(char *buf,int len,int argc,char **argv)

{
  if (argc < 2) {
    puts("[CLI] Dump statistic use normal mode\r\n");
    vTaskEnterCritical();
  }
  else {
    puts("[CLI] Dump statistic use forced mode\r\n");
    vTaskEnterCritical();
  }
  bl60x_fw_dump_statistic((uint)(argc >= 2));
  vTaskExitCritical();
  return;
}



void cmd_wifi_ap_conf_max_sta(char *buf,int len,int argc,char **argv)

{
  int iVar1;
  
  if (argc != 2) {
    printf("Usage: wifi_ap_max_sta [num]\r\n");
    return;
  }
  iVar1 = atoi(argv[1]);
  printf("Conf Max Sta to %d\r\n",iVar1);
  wifi_mgmr_conf_max_sta((uint8_t)iVar1);
  return;
}



void wifi_mon_cmd(char *buf,int len,int argc,char **argv)

{
  if (1 < argc) {
    wifi_mgmr_sniffer_enable();
    return;
  }
  wifi_mgmr_sniffer_register((void *)0x0,sniffer_cb);
  return;
}



void wifi_rc_fixed_enable(char *buf,int len,int argc,char **argv)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  char *pcVar4;
  uint uVar5;
  
  if (argc != 4) {
    printf("rc_fix_en [b/g/n] [MCS] [GI]");
    return;
  }
  uVar1 = atoi(argv[1]);
  uVar5 = uVar1 & 0xff;
  uVar2 = atoi(argv[2]);
  uVar3 = atoi(argv[3]);
  if (uVar5 == 1) {
    pcVar4 = "n mode";
  }
  else {
    pcVar4 = "b/g mdoe";
  }
  printf("wifi set mode:%s, mcs:%d, gi:%d\r\n",pcVar4,uVar2 & 0xff,uVar3 & 0xff);
  if (uVar5 == 1) {
    uVar1 = ((uVar1 & 0xff) << 0xc | (uVar3 & 0xff) << 9) & 0xffff | uVar2 & 0xff;
  }
  else {
    uVar1 = 0;
    if (uVar5 == 0) {
      uVar1 = uVar2 & 0xff | 0x600;
    }
  }
  printf("wifi rc:0x%x\r\n",uVar1);
  wifi_mgmr_rate_config((uint16_t)uVar1);
  return;
}



void wifi_connect_cmd(char *buf,int len,int argc,char **argv)

{
  wifi_interface_t *wifi_interface;
  
  if (argc != 3) {
    printf("[USAGE]: %s [ssid] [password]\r\n",*argv);
    return;
  }
  wifi_interface = (wifi_interface_t *)wifi_mgmr_sta_enable();
  wifi_mgmr_sta_connect(wifi_interface,argv[1],argv[2],(char *)0x0,(uint8_t *)0x0,'\0',0);
  return;
}



void wifi_sta_ip_set_cmd(char *buf,int len,int argc,char **argv)

{
  ip4_addr_t ip;
  ip4_addr_t mask;
  ip4_addr_t gw;
  ip4_addr_t dns1;
  ip4_addr_t dns2;
  ip4_addr_t iStack56;
  ip4_addr_t addr;
  char addr_str [20];
  
  if (argc == 6) {
    ip = (ip4_addr_t)ipaddr_addr(argv[1]);
    mask = (ip4_addr_t)ipaddr_addr(argv[2]);
    gw = (ip4_addr_t)ipaddr_addr(argv[3]);
    dns1 = (ip4_addr_t)ipaddr_addr(argv[4]);
    dns2 = (ip4_addr_t)ipaddr_addr(argv[5]);
    iStack56 = ip;
    ip4addr_ntoa_r(&iStack56,(char *)&addr,0x14);
    puts("IP  : ");
    puts((char *)&addr);
    puts("\r\n");
    iStack56 = mask;
    ip4addr_ntoa_r(&iStack56,(char *)&addr,0x14);
    puts("MASK: ");
    puts((char *)&addr);
    puts("\r\n");
    iStack56 = gw;
    ip4addr_ntoa_r(&iStack56,(char *)&addr,0x14);
    puts("GW  : ");
    puts((char *)&addr);
    puts("\r\n");
    iStack56 = dns1;
    ip4addr_ntoa_r(&iStack56,(char *)&addr,0x14);
    puts("DNS1: ");
    puts((char *)&addr);
    puts("\r\n");
    iStack56 = dns2;
    ip4addr_ntoa_r(&iStack56,(char *)&addr,0x14);
    puts("DNS2: ");
    puts((char *)&addr);
    puts("\r\n");
    wifi_mgmr_sta_ip_set((uint32_t)ip,(uint32_t)mask,(uint32_t)gw,(uint32_t)dns1,(uint32_t)dns2);
  }
  else {
    puts("Illegal CMD format\r\n");
  }
  return;
}



void wifi_scan_filter_cmd(char *buf,int len,int argc,char **argv)

{
  if (argc == 2) {
    wifi_mgmr_scan_filter_hidden_ssid((uint)(*argv[1] == '1'));
    return;
  }
  return;
}



void wifi_capcode_cmd(char *buf,int len,int argc,char **argv)

{
  uint8_t uVar1;
  char *__format;
  undefined3 extraout_var;
  int iVar2;
  char *pcVar3;
  
  if (argc - 1U < 2) {
    if (argc != 1) {
      iVar2 = atoi(argv[1]);
      printf("Setting capcode to %d\r\n",iVar2);
      if (0 < iVar2) {
        hal_sys_capcode_update((uint8_t)iVar2,(uint8_t)iVar2);
        return;
      }
      return;
    }
    uVar1 = hal_sys_capcode_get();
    pcVar3 = (char *)CONCAT31(extraout_var,uVar1);
    __format = "Capcode %u is being used\r\n";
  }
  else {
    pcVar3 = *argv;
    __format = "Usage: %s capcode\r\n";
  }
  printf(__format,pcVar3);
  return;
}



int wifi_mgmr_cli_scanlist(void)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  byte bVar5;
  byte bVar6;
  wifi_mgmr_t *pwVar7;
  int iVar8;
  TickType_t TVar9;
  
  printf("cached scan list\r\n");
  pwVar7 = &wifiMgmr;
  printf(
        "****************************************************************************************************\r\n"
        );
  iVar8 = 0;
  do {
    if (pwVar7->scan_items[0].is_used == '\0') {
LAB_2302810e:
      printf("index[%02d]: empty\r\n",iVar8);
    }
    else {
      TVar9 = xTaskGetTickCount();
      if ((uint)wifiMgmr.scan_item_timeout <= TVar9 - pwVar7->scan_items[0].timestamp_lastseen)
      goto LAB_2302810e;
      bVar1 = pwVar7->scan_items[0].channel;
      bVar2 = pwVar7->scan_items[0].bssid[0];
      bVar3 = pwVar7->scan_items[0].bssid[1];
      bVar4 = pwVar7->scan_items[0].bssid[2];
      bVar5 = pwVar7->scan_items[0].bssid[3];
      bVar6 = pwVar7->scan_items[0].bssid[4];
      wifi_mgmr_auth_to_str(pwVar7->scan_items[0].auth);
      wifi_mgmr_cipher_to_str(pwVar7->scan_items[0].cipher);
      printf(
             "index[%02d]: channel %02u, bssid %02X:%02X:%02X:%02X:%02X:%02X, rssi %3d, ppm abs:rel %3d : %3d, auth %20s, cipher:%12s, SSID %s\r\n"
             ,iVar8,(uint)bVar1,(uint)bVar2,(uint)bVar3,(uint)bVar4,(uint)bVar5,(uint)bVar6);
    }
    iVar8 = iVar8 + 1;
    pwVar7 = (wifi_mgmr_t *)&(pwVar7->wlan_sta).netif.input;
    if (iVar8 == 0x32) {
      printf(
            "----------------------------------------------------------------------------------------------------\r\n"
            );
      return 0;
    }
  } while( true );
}



int wifi_mgmr_ext_dump_needed(void)

{
  bool bVar1;
  
  bVar1 = 0 < pkt_counter;
  if (bVar1) {
    pkt_counter = pkt_counter + -1;
  }
  return (uint)bVar1;
}



int wifi_mgmr_cli_init(void)

{
  return 0;
}



int mac_is_unvalid(uint8_t *mac)

{
  int iVar1;
  
  iVar1 = 1;
  do {
    if (mac[iVar1] != *mac) {
      return 0;
    }
    iVar1 = iVar1 + 1;
  } while (iVar1 != 6);
  return (uint)((byte)(*mac - 1) < 0xfe) ^ 1;
}



int wifi_mgmr_psk_cal(char *password,char *ssid,int ssid_len,char *output)

{
  int iVar1;
  uchar auStack48 [4];
  char psk [32];
  
  iVar1 = bl60x_fw_password_hash(password,(uchar *)ssid,ssid_len,auStack48);
  if (iVar1 == 0) {
    utils_bin2hex(output,auStack48,0x20);
  }
  return iVar1;
}



int wifi_mgmr_drv_init(wifi_conf_t *conf)

{
  bl606a0_wifi_init(conf);
  wifi_mgmr_api_set_country_code((char *)conf);
  wifi_mgmr_init();
  wifi_mgmr_api_ifaceup();
  return 0;
}



// WARNING: Variable defined which should be unmapped: gw

wifi_interface_t wifi_mgmr_sta_enable(void)

{
  int done;
  int iVar1;
  ip4_addr_t iStack28;
  ip4_addr_t ipaddr;
  ip4_addr_t netmask;
  ip4_addr_t gw;
  
  if (done == 1) {
    printf("----- BUG FIXME? NOT do STA enable again\r\n");
  }
  else {
    done = 1;
    printf("---------STA enable\r\n");
    wifiMgmr.wlan_sta.mode = 0;
    iStack28 = (ip4_addr_t)0x0;
    ipaddr = 0;
    netmask = 0;
    memcpy(wifiMgmr.wlan_sta.netif.hwaddr,wifiMgmr.wlan_sta.mac,6);
    iVar1 = mac_is_unvalid(wifiMgmr.wlan_sta.netif.hwaddr);
    if (iVar1 != 0) {
      bl_wifi_mac_addr_get(wifiMgmr.wlan_sta.netif.hwaddr);
      iVar1 = mac_is_unvalid(wifiMgmr.wlan_sta.netif.hwaddr);
      if (iVar1 != 0) {
        wifiMgmr.wlan_sta.netif.hwaddr._0_2_ = 0x50c0;
        wifiMgmr.wlan_sta.netif.hwaddr._2_4_ = 0x100c943;
      }
      memcpy(wifiMgmr.wlan_sta.mac,wifiMgmr.wlan_sta.netif.hwaddr,6);
    }
    netifapi_netif_add((netif *)&wifiMgmr.wlan_sta.netif,&iStack28,&ipaddr,&netmask,(void *)0x0,
                       bl606a0_wifi_netif_init,tcpip_input);
    wifiMgmr.wlan_sta.netif.name = 0x7473;
    wifiMgmr.wlan_sta.netif.flags = wifiMgmr.wlan_sta.netif.flags | 0x24;
    netif_set_default((netif *)&wifiMgmr.wlan_sta.netif);
    netif_set_up((netif *)&wifiMgmr.wlan_sta.netif);
  }
  return &wifiMgmr.wlan_sta;
}



int wifi_mgmr_sta_disable(wifi_interface_t *interface)

{
  wifi_mgmr_api_idle();
  return 0;
}



int wifi_mgmr_sta_ip_get(uint32_t *ip,uint32_t *gw,uint32_t *mask)

{
  *ip = wifiMgmr.wlan_sta.netif.ip_addr;
  *mask = wifiMgmr.wlan_sta.netif.netmask;
  *gw = wifiMgmr.wlan_sta.netif.gw;
  return 0;
}



int wifi_mgmr_sta_dns_get(uint32_t *dns1,uint32_t *dns2)

{
  ip_addr_t *piVar1;
  
  piVar1 = dns_getserver('\0');
  *dns1 = piVar1->addr;
  piVar1 = dns_getserver('\x01');
  *dns2 = piVar1->addr;
  return 0;
}



int wifi_mgmr_sta_ip_set(uint32_t ip,uint32_t mask,uint32_t gw,uint32_t dns1,uint32_t dns2)

{
  vTaskEnterCritical();
  wifiMgmr.wlan_sta.ipv4.ip = ip;
  wifiMgmr.wlan_sta.ipv4.mask = mask;
  wifiMgmr.wlan_sta.ipv4.gw = gw;
  wifiMgmr.wlan_sta.ipv4.dns1 = dns1;
  wifiMgmr.wlan_sta.ipv4.dns2 = dns2;
  vTaskExitCritical();
  wifi_mgmr_api_ip_update();
  return 0;
}



int wifi_mgmr_sta_ip_unset(void)

{
  int iVar1;
  
  iVar1 = wifi_mgmr_sta_ip_set(0,0,0,0,0);
  return iVar1;
}



int wifi_mgmr_sta_disconnect(void)

{
  wifi_mgmr_api_disconnect();
  return 0;
}



int wifi_mgmr_sta_powersaving(int ps)

{
  if ((ps == 1) || (ps == 2)) {
    wifi_mgmr_api_fw_powersaving(ps);
    ps = 0;
  }
  else {
    if (ps == 0) {
      wifi_mgmr_api_fw_powersaving(0);
    }
    else {
      ps = -1;
    }
  }
  return ps;
}



int wifi_mgmr_sta_autoconnect_enable(void)

{
  wifi_mgmr_api_enable_autoreconnect();
  return 0;
}



int wifi_mgmr_sta_autoconnect_disable(void)

{
  wifi_mgmr_api_disable_autoreconnect();
  return 0;
}



void wifi_mgmr_sta_ssid_set(char *ssid)

{
  size_t __n;
  
  __n = strlen(ssid);
  if (__n != 0) {
    __n = strlen(ssid);
    memcpy(wifiMgmr.wifi_mgmr_stat_info.ssid,ssid,__n);
    return;
  }
  return;
}



void wifi_mgmr_sta_psk_set(char *psk)

{
  size_t __n;
  
  __n = strlen(psk);
  if (__n != 0) {
    __n = strlen(psk);
    memcpy(wifiMgmr.wifi_mgmr_stat_info.psk,psk,__n);
    return;
  }
  return;
}



int wifi_mgmr_sta_connect
              (wifi_interface_t *wifi_interface,char *ssid,char *psk,char *pmk,uint8_t *mac,
              uint8_t band,uint16_t freq)

{
  int iVar1;
  
  wifi_mgmr_sta_ssid_set(ssid);
  wifi_mgmr_sta_psk_set(psk);
  iVar1 = wifi_mgmr_api_connect(ssid,psk,pmk,mac,band,freq);
  return iVar1;
}



// WARNING: Variable defined which should be unmapped: gw

wifi_interface_t wifi_mgmr_ap_enable(void)

{
  int iVar1;
  ip4_addr_t iStack28;
  ip4_addr_t ipaddr;
  ip4_addr_t netmask;
  ip4_addr_t gw;
  
  wifiMgmr.wlan_ap.mode = 1;
  iStack28 = (ip4_addr_t)0x10ba8c0;
  ipaddr = 0xffffff;
  netmask = 0;
  memcpy(wifiMgmr.wlan_ap.netif.hwaddr,wifiMgmr.wlan_ap.mac,6);
  iVar1 = mac_is_unvalid(wifiMgmr.wlan_ap.netif.hwaddr);
  if (iVar1 != 0) {
    bl_wifi_mac_addr_get(wifiMgmr.wlan_ap.netif.hwaddr);
    iVar1 = mac_is_unvalid(wifiMgmr.wlan_ap.netif.hwaddr);
    if (iVar1 != 0) {
      wifiMgmr.wlan_ap.netif.hwaddr._0_2_ = 0x50c0;
      wifiMgmr.wlan_ap.netif.hwaddr._2_4_ = 0x100c943;
    }
    memcpy(wifiMgmr.wlan_ap.mac,wifiMgmr.wlan_ap.netif.hwaddr,6);
  }
  netifapi_netif_add((netif *)&wifiMgmr.wlan_ap.netif,&iStack28,&ipaddr,&netmask,(void *)0x0,
                     bl606a0_wifi_netif_init,tcpip_input);
  wifiMgmr.wlan_ap.netif.name = 0x7061;
  netif_set_default((netif *)&wifiMgmr.wlan_ap.netif);
  netif_set_up((netif *)&wifiMgmr.wlan_ap.netif);
  return &wifiMgmr.wlan_ap;
}



int wifi_mgmr_ap_start(wifi_interface_t *interface,char *ssid,int hidden_ssid,char *passwd,
                      int channel)

{
  wifi_mgmr_api_ap_start(ssid,passwd,channel,(uint8_t)hidden_ssid);
  return 0;
}



int wifi_mgmr_ap_stop(wifi_interface_t *interface)

{
  wifi_mgmr_api_ap_stop();
  return 0;
}



int wifi_mgmr_ap_sta_cnt_get(uint8_t *sta_cnt)

{
  wifi_mgmr_ap_sta_cnt_get_internal(sta_cnt);
  return 0;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Could not reconcile some variable overlaps

int wifi_mgmr_ap_sta_info_get(wifi_sta_basic_info *sta_info,uint8_t idx)

{
  undefined2 uStack40;
  wifi_mgmr_sta_basic_info sta_info_internal;
  
  memset(&uStack40,0,0x18);
  wifi_mgmr_ap_sta_info_get_internal((wifi_mgmr_sta_basic_info_t *)&uStack40,idx);
  *(undefined2 *)sta_info = uStack40;
  sta_info->rssi = sta_info_internal.tsflo;
  sta_info->tsflo = sta_info_internal.tsfhi;
  sta_info->tsfhi = sta_info_internal.sta_mac._2_4_;
  sta_info->data_rate = (uint8_t)sta_info_internal.rssi;
  memcpy(sta_info->sta_mac,&uStack40 + 1,6);
  return 0;
}



int wifi_mgmr_ap_sta_delete(uint8_t sta_idx)

{
  wifi_mgmr_ap_sta_delete_internal(sta_idx);
  return 0;
}



int wifi_mgmr_sniffer_register(void *env,sniffer_cb_t *cb)

{
  bl_rx_pkt_cb_register(env,(wifi_event_pkt_cb_t *)cb);
  return 0;
}



int wifi_mgmr_sniffer_unregister(void *env)

{
  bl_rx_pkt_cb_unregister(env);
  return 0;
}



int wifi_mgmr_sniffer_enable(void)

{
  wifi_mgmr_api_sniffer_enable();
  return 0;
}



int wifi_mgmr_sniffer_disable(void)

{
  wifi_mgmr_api_idle();
  return 0;
}



int wifi_mgmr_rate_config(uint16_t config)

{
  WIFI_MGMR_EVENT_T WStack32;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  undefined uStack28;
  undefined uStack27;
  undefined uStack26;
  undefined uStack25;
  undefined uStack24;
  undefined uStack23;
  undefined uStack22;
  undefined uStack21;
  undefined uStack20;
  
  memset(&WStack32,0,0xd);
  WStack32 = WIFI_MGMR_EVENT_APP_RC_CONFIG;
  uStack27 = 0x88;
  uStack26 = 0x77;
  uStack25 = 0x66;
  uStack31 = (undefined)config;
  uStack24 = 0x55;
  uStack30 = (undefined)(config >> 8);
  uStack29 = 0;
  uStack28 = 0;
  uStack23 = 0xd;
  uStack22 = 0;
  uStack21 = 0;
  uStack20 = 0;
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&WStack32);
  return 0;
}



int wifi_mgmr_conf_max_sta(uint8_t max_sta_supported)

{
  WIFI_MGMR_EVENT_T WStack32;
  uint8_t uStack31;
  undefined uStack30;
  undefined uStack29;
  undefined uStack28;
  undefined uStack27;
  undefined uStack26;
  undefined uStack25;
  undefined uStack24;
  undefined uStack23;
  undefined uStack22;
  undefined uStack21;
  undefined uStack20;
  
  memset(&WStack32,0,0xd);
  WStack32 = WIFI_MGMR_EVENT_APP_CONF_MAX_STA;
  uStack27 = 0x88;
  uStack26 = 0x77;
  uStack25 = 0x66;
  uStack24 = 0x55;
  uStack30 = 0;
  uStack29 = 0;
  uStack28 = 0;
  uStack23 = 0xd;
  uStack22 = 0;
  uStack21 = 0;
  uStack20 = 0;
  uStack31 = max_sta_supported;
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&WStack32);
  return 0;
}



int wifi_mgmr_state_get(int *state)

{
  uint16_t uVar1;
  int iVar2;
  
  uVar1 = wifiMgmr.wifi_mgmr_stat_info.status_code;
  if (wifiMgmr.m.currentState == &stateIdle) {
    if (wifiMgmr.inf_ap_enabled != 0) {
      iVar2 = 0x11;
      goto LAB_230262ac;
    }
    iVar2 = 1;
  }
  else {
    if (wifiMgmr.m.currentState == &stateConnecting) {
      if (wifiMgmr.inf_ap_enabled != 0) {
        iVar2 = 0x12;
        goto LAB_230262ac;
      }
      iVar2 = 2;
    }
    else {
      if (wifiMgmr.m.currentState == &stateConnectedIPNo) {
        if (wifiMgmr.inf_ap_enabled == 0) {
          iVar2 = 3;
        }
        else {
          iVar2 = 0x13;
        }
        goto LAB_230262ac;
      }
      if (wifiMgmr.m.currentState == &stateConnectedIPYes) {
        if (wifiMgmr.inf_ap_enabled == 0) {
          iVar2 = 4;
        }
        else {
          iVar2 = 0x14;
        }
        goto LAB_230262ac;
      }
      if (wifiMgmr.m.currentState != &stateDisconnect) {
        if (wifiMgmr.m.currentState == &stateIfaceDown) {
          iVar2 = 6;
        }
        else {
          if (wifiMgmr.m.currentState != &stateSniffer) {
            *state = 0;
            return 0;
          }
          iVar2 = 7;
        }
        goto LAB_230262ac;
      }
      if (wifiMgmr.inf_ap_enabled != 0) {
        iVar2 = 0x15;
        goto LAB_230262ac;
      }
      iVar2 = 5;
    }
  }
  *state = iVar2;
  if (uVar1 == 8) {
    iVar2 = 8;
  }
  else {
    if (uVar1 != 0xc) {
      return 0;
    }
    iVar2 = 9;
  }
LAB_230262ac:
  *state = iVar2;
  return 0;
}



int wifi_mgmr_rssi_get(int *rssi)

{
  *rssi = (int)wifiMgmr.wlan_sta.field_5;
  return 0;
}



int wifi_mgmr_raw_80211_send(uint8_t *pkt,int len)

{
  if (len < 0x1e1) {
    wifi_mgmr_api_raw_send(pkt,len);
    return 0;
  }
  return -1;
}



int wifi_mgmr_scan(void *data,scan_complete_cb_t *cb)

{
  scan_cb = cb;
  scan_data = data;
  wifi_mgmr_api_fw_scan();
  return 0;
}



int wifi_mgmr_cfg_req(uint32_t ops,uint32_t task,uint32_t element,uint32_t type,uint32_t length,
                     uint32_t *buf)

{
  int iVar1;
  WIFI_MGMR_EVENT_T WStack100;
  undefined uStack99;
  undefined uStack98;
  undefined uStack97;
  undefined uStack96;
  undefined uStack95;
  undefined uStack94;
  undefined uStack93;
  undefined uStack92;
  undefined uStack91;
  undefined uStack90;
  undefined uStack89;
  undefined uStack88;
  undefined uStack87;
  undefined uStack86;
  undefined uStack85;
  undefined uStack84;
  undefined uStack83;
  undefined uStack82;
  undefined uStack81;
  undefined uStack80;
  undefined uStack79;
  undefined uStack78;
  undefined uStack77;
  undefined uStack76;
  undefined uStack75;
  undefined uStack74;
  undefined uStack73;
  undefined uStack72;
  undefined uStack71;
  undefined uStack70;
  undefined uStack69;
  undefined uStack68;
  undefined auStack67 [39];
  
  if (length < 0x21) {
    memset(&WStack100,0,0x41);
    WStack100 = WIFI_MGMR_EVENT_FW_CFG_REQ;
    uStack99 = 0x44;
    uStack98 = 0x33;
    uStack97 = 0x22;
    uStack96 = 0x11;
    uStack95 = 0x88;
    uStack94 = 0x77;
    iVar1 = length + 0xc6;
    uStack93 = 0x66;
    uStack92 = 0x55;
    uStack90 = (undefined)((uint)iVar1 >> 8);
    uStack89 = (undefined)((uint)iVar1 >> 0x10);
    uStack86 = (undefined)(ops >> 8);
    uStack85 = (undefined)(ops >> 0x10);
    uStack82 = (undefined)(task >> 8);
    uStack81 = (undefined)(task >> 0x10);
    uStack78 = (undefined)(element >> 8);
    uStack77 = (undefined)(element >> 0x10);
    uStack74 = (undefined)(type >> 8);
    uStack73 = (undefined)(type >> 0x10);
    uStack91 = (undefined)iVar1;
    uStack87 = (undefined)ops;
    uStack83 = (undefined)task;
    uStack79 = (undefined)element;
    uStack75 = (undefined)type;
    uStack70 = (undefined)(length >> 8);
    uStack69 = (undefined)(length >> 0x10);
    uStack88 = (undefined)((uint)iVar1 >> 0x18);
    uStack84 = (undefined)(ops >> 0x18);
    uStack80 = (undefined)(task >> 0x18);
    uStack76 = (undefined)(element >> 0x18);
    uStack72 = (undefined)(type >> 0x18);
    uStack71 = (undefined)length;
    uStack68 = (undefined)(length >> 0x18);
    if (length != 0) {
      memcpy(auStack67,buf,length);
    }
    wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&WStack100);
    return 0;
  }
  return -1;
}



int wifi_mgmr_scan_filter_hidden_ssid(int filter)

{
  vTaskEnterCritical();
  if (filter == 0) {
    wifiMgmr.features = wifiMgmr.features | 1;
  }
  else {
    wifiMgmr.features = wifiMgmr.features & 0xfffffffe;
  }
  vTaskExitCritical();
  return 0;
}



int wifi_mgmr_scan_complete_callback(void)

{
  char "wifi_mgmr_scan_complete_callback" [33];
  undefined4 uStack20;
  int status;
  
  uStack20 = 0;
  printf("%s: scan complete\r\n","wifi_mgmr_scan_complete_callback");
  if (scan_cb != (scan_complete_cb_t *)0x0) {
    uStack20 = 1;
    (*scan_cb)(scan_data,&uStack20);
  }
  return 0;
}



char * wifi_mgmr_status_code_str(uint16_t status_code)

{
  undefined2 in_register_0000202a;
  
  if (CONCAT22(in_register_0000202a,status_code) < 0x11) {
    return *(char **)(CSWTCH_17 + CONCAT22(in_register_0000202a,status_code) * 4);
  }
  return "Unknown Status Code";
}



int wifi_mgmr_profile_add(wifi_mgmr_t *mgmr,wifi_mgmr_profile_msg_t *profile_msg,int index)

{
  wifi_mgmr_profile_t *__s;
  int iVar1;
  
  if (index == -1) {
    __s = mgmr->profiles;
    if (__s == (wifi_mgmr_profile_t *)0x0) {
      return -1;
    }
  }
  else {
    if (mgmr->profiles[0].isUsed == '\0') {
      iVar1 = 0;
    }
    else {
      if (mgmr->profiles[1].isUsed != '\0') {
        return -1;
      }
      iVar1 = 1;
    }
    mgmr->profile_active_index = iVar1;
    __s = mgmr->profiles + iVar1;
    printf("[WF][PF] Using free profile, idx is @%d\r\n");
  }
  memset(__s,0,0xc4);
  *(undefined2 *)&__s->isActive = 0x100;
  __s->ssid_len = profile_msg->ssid_len;
  __s->psk_len = profile_msg->psk_len;
  __s->pmk_len = profile_msg->pmk_len;
  __s->priority = -1;
  memcpy(__s,profile_msg,0x21);
  memcpy(__s->psk,profile_msg->psk,0x41);
  memcpy(__s->pmk,profile_msg->pmk,0x41);
  memcpy(__s->mac,profile_msg->mac,6);
  __s->dhcp_use = profile_msg->dhcp_use;
  return 0;
}



int wifi_mgmr_profile_get(wifi_mgmr_t *mgmr,wifi_mgmr_profile_msg_t *profile_msg)

{
  int iVar1;
  uint8_t *puVar2;
  undefined4 uVar3;
  
  if (mgmr->profiles[0].isUsed == '\x01') {
    iVar1 = 0;
  }
  else {
    iVar1 = 1;
    if (mgmr->profiles[1].isUsed != '\x01') {
      return -1;
    }
  }
  printf("[WF][PF] Using profile, idx is @%d\r\n",iVar1);
  memset(profile_msg,0,0xb9);
  puVar2 = &mgmr->ready + iVar1 * 0xc4;
  uVar3 = *(undefined4 *)(puVar2 + 0x114);
  *(char *)&profile_msg->ssid_len = (char)uVar3;
  *(undefined *)((int)&profile_msg->ssid_len + 1) = (char)((uint)uVar3 >> 8);
  *(undefined *)((int)&profile_msg->ssid_len + 2) = (char)((uint)uVar3 >> 0x10);
  *(undefined *)((int)&profile_msg->ssid_len + 3) = (char)((uint)uVar3 >> 0x18);
  uVar3 = *(undefined4 *)(puVar2 + 0x15c);
  *(char *)&profile_msg->psk_len = (char)uVar3;
  *(undefined *)((int)&profile_msg->psk_len + 1) = (char)((uint)uVar3 >> 8);
  *(undefined *)((int)&profile_msg->psk_len + 2) = (char)((uint)uVar3 >> 0x10);
  *(undefined *)((int)&profile_msg->psk_len + 3) = (char)((uint)uVar3 >> 0x18);
  uVar3 = *(undefined4 *)(puVar2 + 0x1a4);
  *(char *)&profile_msg->pmk_len = (char)uVar3;
  *(undefined *)((int)&profile_msg->pmk_len + 1) = (char)((uint)uVar3 >> 8);
  *(undefined *)((int)&profile_msg->pmk_len + 2) = (char)((uint)uVar3 >> 0x10);
  *(undefined *)((int)&profile_msg->pmk_len + 3) = (char)((uint)uVar3 >> 0x18);
  profile_msg->dhcp_use = puVar2[0x1ae];
  memcpy(profile_msg,mgmr->profiles + iVar1,0x21);
  memcpy(profile_msg->psk,mgmr->profiles[iVar1].psk,0x41);
  memcpy(profile_msg->pmk,mgmr->profiles[iVar1].pmk,0x41);
  memcpy(profile_msg->mac,mgmr->profiles[iVar1].mac,6);
  return 0;
}



int wifi_mgmr_profile_autoreconnect_is_enabled(wifi_mgmr_t *mgmr,int index)

{
  return (uint)(mgmr->disable_autoreconnect == '\0');
}



int wifi_mgmr_profile_autoreconnect_disable(wifi_mgmr_t *mgmr,int index)

{
  mgmr->disable_autoreconnect = '\x01';
  return 0;
}



int wifi_mgmr_profile_autoreconnect_enable(wifi_mgmr_t *mgmr,int index)

{
  mgmr->disable_autoreconnect = '\0';
  return 0;
}



int wifi_netif_dhcp_start(netif *netif)

{
  netifapi_netif_common(netif,(netifapi_void_fn)0x0,dhcp_start);
  return 0;
}



void cb_rssi_ind(void *env,int8_t rssi)

{
  wifiMgmr.wlan_sta.field_5 = rssi;
  return;
}



void cb_probe_resp_ind(void *env)

{
  printf("timestamp = 0x%llx\r\n");
  return;
}



void cb_beacon_ind(void *env,wifi_event_beacon_ind_conflict4 *ind)

{
  wifi_mgmr_api_scan_item_beacon
            (ind->channel,ind->rssi,ind->auth,(uint8_t *)ind,ind->ssid,ind->ssid_len,ind->ppm_abs,
             ind->ppm_rel,DAT_00000010);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void cb_disconnect_ind(void *env,wifi_event_sm_disconnect_ind *ind)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  wifi_mgmr_msg_t msg_wifi;
  
  memset(&local_20,0,0xd);
  printf("sending disconnect\r\n");
  local_20 = WIFI_MGMR_EVENT_FW_IND_DISCONNECT;
  uStack31 = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  msg_wifi.ev = WIFI_MGMR_EVENT_FW_CHANNEL_SET;
  msg_wifi.data1._0_1_ = 0x88;
  msg_wifi.data1._1_1_ = 0x77;
  msg_wifi.data1._2_1_ = 0x66;
  msg_wifi.data1._3_1_ = 0x55;
  msg_wifi.data2._0_1_ = 0xd;
  wifiMgmr.wifi_mgmr_stat_info.type_ind = '\x02';
  wifiMgmr.wifi_mgmr_stat_info.status_code = ind->reason_code;
  msg_wifi.data2._1_1_ = 0;
  msg_wifi.data2._2_1_ = 0;
  msg_wifi.data2._3_1_ = 0;
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void cb_connect_ind(void *env,wifi_event_sm_connect_ind *ind)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  wifi_mgmr_msg_t msg_wifi;
  
  memset(&local_20,0,0xd);
  local_20 = (ind->status_code == 0) + WIFI_MGMR_EVENT_FW_IND_DISCONNECT;
  uStack31 = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  msg_wifi.ev = WIFI_MGMR_EVENT_FW_CHANNEL_SET;
  msg_wifi.data1._0_1_ = 0x88;
  msg_wifi.data1._1_1_ = 0x77;
  msg_wifi.data1._2_1_ = 0x66;
  msg_wifi.data1._3_1_ = 0x55;
  msg_wifi.data2._0_1_ = 0xd;
  msg_wifi.data2._1_1_ = 0;
  msg_wifi.data2._2_1_ = 0;
  msg_wifi.data2._3_1_ = 0;
  wifi_mgmr_set_connect_stat_info(ind,'\x01');
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return;
}



void cb_event_ind(void *env,wifi_event *event)

{
  int iVar1;
  uint16_t code;
  uint32_t uVar2;
  
  uVar2 = event->id;
  if (uVar2 == 1) {
    puts("[WIFI] [IND] SCAN Done\r\n");
    wifi_mgmr_scan_complete_notify();
    code = 9;
LAB_23028b2c:
    aos_post_event(2,code,0);
    return;
  }
  if (uVar2 == 0) {
    uVar2 = event[1].id;
    iVar1 = -400;
    wifiMgmr.channel = uVar2;
  }
  else {
    if (uVar2 == 2) {
      code = 10;
      goto LAB_23028b2c;
    }
    iVar1 = -0x154;
  }
  printf(" SKIP Notify for set Empty Address\r\n" + iVar1 + 0x20,uVar2);
  return;
}



int wifi_mgmr_event_init(void)

{
  bl_rx_sm_connect_ind_cb_register((void *)0x0,cb_connect_ind);
  bl_rx_sm_disconnect_ind_cb_register((void *)0x0,cb_disconnect_ind);
  bl_rx_beacon_ind_cb_register((void *)0x0,cb_beacon_ind);
  bl_rx_probe_resp_ind_cb_register((void *)0x0,cb_probe_resp_ind);
  bl_rx_rssi_cb_register((void *)0x0,cb_rssi_ind);
  bl_rx_event_register((void *)0x0,cb_event_ind);
  return 0;
}



void cmd_mgr_print(bl_cmd_mgr *cmd_mgr)

{
  list_head *plVar1;
  
  xQueueSemaphoreTake((QueueHandle_t)cmd_mgr->lock,0xffffffff);
  plVar1 = (cmd_mgr->cmds).next;
  while (plVar1 != &cmd_mgr->cmds) {
    plVar1 = plVar1->next;
  }
  xQueueGenericSend((QueueHandle_t)cmd_mgr->lock,(void *)0x0,0,0);
  return;
}



void cmd_complete(bl_cmd *cmd)

{
  ushort uVar1;
  int *in_a1;
  int iVar2;
  int *piVar3;
  
  (cmd->list).next = (list_head *)((int)&(cmd->list).next[-1].prev + 3);
  piVar3 = (int *)in_a1[1];
  iVar2 = *in_a1;
  *(int **)(iVar2 + 4) = piVar3;
  *piVar3 = iVar2;
  *in_a1 = 0x100100;
  in_a1[1] = 0x200200;
  uVar1 = *(ushort *)(in_a1 + 6);
  *(ushort *)(in_a1 + 6) = uVar1 | 0x20;
  if ((uVar1 & 1) != 0) {
    vPortFree(in_a1);
    return;
  }
  if ((uVar1 & 0x18) == 0) {
    in_a1[0xf] = 0;
    xEventGroupSetBits((EventGroupHandle_t)(in_a1 + 7),1);
    return;
  }
  return;
}



int cmd_mgr_msgind(bl_cmd_mgr *cmd_mgr,ipc_e2a_msg *msg,msg_cb_fct *cb)

{
  bool bVar1;
  bl_cmd *pbVar2;
  int iVar3;
  
  xQueueSemaphoreTake((QueueHandle_t)cmd_mgr->lock,0xffffffff);
  pbVar2 = (bl_cmd *)(cmd_mgr->cmds).next;
  do {
    if (pbVar2 == (bl_cmd *)&cmd_mgr->cmds) {
      bVar1 = false;
LAB_23028c80:
      xQueueGenericSend((QueueHandle_t)cmd_mgr->lock,(void *)0x0,0,0);
      if ((!bVar1) && (cb != (msg_cb_fct *)0x0)) {
        (*cb)((bl_hw *)&cmd_mgr[-1].drain,(bl_cmd *)0x0,msg);
      }
      return 0;
    }
    if (((pbVar2->reqid == msg->id) && ((pbVar2->flags & 0x10) != 0)) &&
       ((cb == (msg_cb_fct *)0x0 ||
        (iVar3 = (*cb)((bl_hw *)&cmd_mgr[-1].drain,pbVar2,msg), iVar3 == 0)))) {
      pbVar2->flags = pbVar2->flags & 0xffef;
      if ((pbVar2->e2a_msg != (char *)0x0) && (msg->param_len != 0)) {
        memcpy(pbVar2->e2a_msg,msg->param,(uint)msg->param_len);
      }
      bVar1 = true;
      if ((pbVar2->flags & 0x18) == 0) {
        cmd_complete((bl_cmd *)&cmd_mgr->queue_sz);
      }
      goto LAB_23028c80;
    }
    pbVar2 = (bl_cmd *)(pbVar2->list).next;
  } while( true );
}



int cmd_mgr_llind(bl_cmd_mgr *cmd_mgr,bl_cmd *cmd)

{
  ushort uVar1;
  char "cmd_mgr_llind" [14];
  bl_cmd *msg_buf;
  bl_cmd *pbVar2;
  _Bool __warned;
  
  xQueueSemaphoreTake((QueueHandle_t)cmd_mgr->lock,0xffffffff);
  msg_buf = (bl_cmd *)(cmd_mgr->cmds).next;
  pbVar2 = (bl_cmd *)0x0;
  do {
    if (msg_buf == (bl_cmd *)&cmd_mgr->cmds) {
      msg_buf = (bl_cmd *)0x0;
      if (pbVar2 != (bl_cmd *)0x0) {
LAB_23028d50:
        uVar1 = cmd->flags;
        cmd->flags = uVar1 & 0xfff7;
        if ((uVar1 & 0x10) == 0) {
          cmd_complete((bl_cmd *)&cmd_mgr->queue_sz);
        }
        if (msg_buf != (bl_cmd *)0x0) {
LAB_23028d6c:
          msg_buf->flags = msg_buf->flags & 0xfffb;
          ipc_host_msg_push(*(ipc_host_env_tag **)(cmd_mgr + 1),msg_buf,
                            (uint16_t)(((uint)msg_buf->a2e_msg->param_len + 8) * 0x10000 >> 0x10));
          vPortFree(msg_buf->a2e_msg);
        }
      }
      xQueueGenericSend((QueueHandle_t)cmd_mgr->lock,(void *)0x0,0,0);
      return 0;
    }
    if ((pbVar2 == (bl_cmd *)0x0) && ((list_head *)msg_buf->tkn == (list_head *)cmd->tkn)) {
      pbVar2 = msg_buf;
      if ((msg_buf != cmd) && (__warned == false)) {
        printf("%s:%d\r\n","cmd_mgr_llind",0xcf);
        __warned = true;
      }
    }
    else {
      if ((msg_buf->flags & 4) != 0) {
        if (pbVar2 == (bl_cmd *)0x0) goto LAB_23028d6c;
        goto LAB_23028d50;
      }
    }
    msg_buf = (bl_cmd *)(msg_buf->list).next;
  } while( true );
}



undefined4 cmd_mgr_queue(char *param_1,char **param_2)

{
  bool bVar1;
  ushort uVar2;
  undefined4 uVar3;
  EventBits_t EVar4;
  char *pcVar5;
  char **ppcVar6;
  int iVar7;
  
  xQueueSemaphoreTake(*(QueueHandle_t *)(param_1 + 0x18),0xffffffff);
  if (*param_1 == '\x02') {
    param_2[0xf] = &DAT_00000020;
    xQueueGenericSend(*(QueueHandle_t *)(param_1 + 0x18),(void *)0x0,0,0);
    uVar3 = 0xffffffe0;
  }
  else {
    if (param_1 + 0x10 == *(char **)(param_1 + 0x10)) {
      bVar1 = false;
    }
    else {
      if (*(int *)(param_1 + 8) == *(int *)(param_1 + 0xc)) {
        param_2[0xf] = &DAT_0000000c;
        xQueueGenericSend(*(QueueHandle_t *)(param_1 + 0x18),(void *)0x0,0,0);
        return 0xfffffff4;
      }
      bVar1 = false;
      if ((*(ushort *)(*(int *)(param_1 + 0x14) + 0x18) & 0xc) != 0) {
        bVar1 = true;
        *(ushort *)(param_2 + 6) = *(ushort *)(param_2 + 6) | 4;
      }
    }
    if ((*(ushort *)(param_2 + 6) & 2) == 0) {
      uVar2 = 8;
    }
    else {
      uVar2 = 0x18;
    }
    *(ushort *)(param_2 + 6) = *(ushort *)(param_2 + 6) | uVar2;
    pcVar5 = *(char **)(param_1 + 4);
    *(char **)(param_1 + 4) = pcVar5 + 1;
    param_2[5] = pcVar5;
    param_2[0xf] = &DAT_00000004;
    if ((*(ushort *)(param_2 + 6) & 1) == 0) {
      xEventGroupCreateStatic((StaticEventGroup_t *)(param_2 + 7));
    }
    ppcVar6 = *(char ***)(param_1 + 0x14);
    *(char ***)(param_1 + 0x14) = param_2;
    *param_2 = param_1 + 0x10;
    *(char ***)(param_2 + 1) = ppcVar6;
    *(char ***)ppcVar6 = param_2;
    iVar7 = *(int *)(param_1 + 8);
    *(int *)(param_1 + 8) = iVar7 + 1;
    xQueueGenericSend(*(QueueHandle_t *)(param_1 + 0x18),(void *)0x0,0,0);
    if (!bVar1) {
      ipc_host_msg_push(*(ipc_host_env_tag **)(param_1 + 0x30),param_2,
                        (uint16_t)(((uint)*(ushort *)(param_2[3] + 6) + 8) * 0x10000 >> 0x10));
      vPortFree(param_2[3]);
    }
    if ((*(ushort *)(param_2 + 6) & 1) == 0) {
      EVar4 = xEventGroupWaitBits((EventGroupHandle_t)(param_2 + 7),1,1,0,(iVar7 + 1) * 1000000);
      if ((EVar4 & 1) == 0) {
        xQueueSemaphoreTake(*(QueueHandle_t *)(param_1 + 0x18),0xffffffff);
        *param_1 = '\x02';
        if ((*(ushort *)(param_2 + 6) & 0x20) == 0) {
          param_2[0xf] = (char *)0x6e;
          cmd_complete((bl_cmd *)(param_1 + 8));
        }
        xQueueGenericSend(*(QueueHandle_t *)(param_1 + 0x18),(void *)0x0,0,0);
      }
      vEventGroupDelete((EventGroupHandle_t)(param_2 + 7));
    }
    else {
      param_2[0xf] = (char *)0x0;
    }
    uVar3 = 0;
  }
  return uVar3;
}



void cmd_mgr_drain(bl_cmd_mgr *cmd_mgr)

{
  list_head *plVar1;
  list_head *plVar2;
  list_head *plVar3;
  list_head *plVar4;
  
  xQueueSemaphoreTake((QueueHandle_t)cmd_mgr->lock,0xffffffff);
  plVar2 = (cmd_mgr->cmds).next;
  plVar3 = plVar2->next;
  while (plVar1 = plVar3, plVar2 != &cmd_mgr->cmds) {
    plVar4 = plVar2->prev;
    plVar3 = plVar2->next;
    plVar3->prev = plVar4;
    plVar4->next = plVar3;
    plVar2->next = (list_head *)0x100100;
    plVar2->prev = (list_head *)0x200200;
    cmd_mgr->queue_sz = cmd_mgr->queue_sz - 1;
    if ((*(ushort *)&plVar2[3].next & 1) == 0) {
      xEventGroupSetBits((EventGroupHandle_t)&plVar2[3].prev,1);
    }
    plVar3 = plVar1->next;
    plVar2 = plVar1;
  }
  xQueueGenericSend((QueueHandle_t)cmd_mgr->lock,(void *)0x0,0,0);
  return;
}



void bl_cmd_mgr_init(bl_cmd_mgr *cmd_mgr)

{
  QueueHandle_t pQVar1;
  
  (cmd_mgr->cmds).next = &cmd_mgr->cmds;
  (cmd_mgr->cmds).prev = &cmd_mgr->cmds;
  pQVar1 = xQueueCreateMutex('\x01');
  cmd_mgr->max_queue_sz = 8;
  cmd_mgr->queue = cmd_mgr_queue;
  cmd_mgr->print = cmd_mgr_print;
  cmd_mgr->drain = cmd_mgr_drain;
  cmd_mgr->llind = cmd_mgr_llind;
  *(QueueHandle_t *)&cmd_mgr->lock = pQVar1;
  cmd_mgr->msgind = cmd_mgr_msgind;
  return;
}



int bl_irqs_init(bl_hw *bl_hw)

{
  return 0;
}



void bl_irq_bottomhalf(bl_hw *bl_hw)

{
  uint uVar1;
  uint status;
  TickType_t TVar2;
  
  xTaskGetTickCount();
  uVar1 = 0;
  status = ipc_host_get_rawstatus(bl_hw->ipc_env);
  do {
    while (status != 0) {
      uVar1 = uVar1 | status;
      ipc_host_irq(bl_hw->ipc_env,status);
      status = ipc_host_get_rawstatus(bl_hw->ipc_env);
    }
    TVar2 = xTaskGetTickCount();
    if ((uVar1 & 8) != 0) {
      (bl_hw->stats).last_rx = TVar2;
    }
    if ((uVar1 & 0x780) != 0) {
      (bl_hw->stats).last_tx = TVar2;
    }
    ipc_host_enable_irq(bl_hw->ipc_env,0x7ff);
    status = ipc_host_get_rawstatus(bl_hw->ipc_env);
  } while (status != 0);
  return;
}



// WARNING: Exceeded maximum restarts with more pending

void goToErrorState(stateMachine *fsm,event *event)

{
  state *psVar1;
  
  fsm->previousState = fsm->currentState;
  psVar1 = fsm->errorState;
  fsm->currentState = psVar1;
  if ((psVar1 != (state *)0x0) &&
     (psVar1->entryAction != (anon_subr_void_void_ptr_event_ptr_for_entryAction *)0x0)) {
                    // WARNING: Could not recover jumptable at 0x23029062. Too many branches
                    // WARNING: Treating indirect jump as call
    (*psVar1->entryAction)(psVar1->data);
    return;
  }
  return;
}



void stateM_init(stateMachine *fsm,state *initialState,state *errorState)

{
  if (fsm != (stateMachine *)0x0) {
    fsm->currentState = initialState;
    fsm->previousState = (state *)0x0;
    fsm->errorState = errorState;
  }
  return;
}



// WARNING: Type propagation algorithm not settling

int stateM_handleEvent(stateMachine *fsm,event *event)

{
  state *psVar1;
  state *psVar2;
  int iVar3;
  int *piVar4;
  uint uVar5;
  
  if (fsm == (stateMachine *)0x0) {
    return -2;
  }
  iVar3 = -2;
  if (event != (event *)0x0) {
    psVar1 = fsm->currentState;
    if (psVar1 == (state *)0x0) {
LAB_23029090:
      goToErrorState(fsm,event);
      iVar3 = -1;
    }
    else {
      psVar2 = (state *)psVar1->numTransitions;
      while (psVar2 != (state *)0x0) {
        uVar5 = 0;
        while (uVar5 < psVar1->numTransitions) {
          piVar4 = &psVar1->transitions->eventType + uVar5 * 5;
          if ((*piVar4 == event->type) &&
             (((code *)piVar4[2] == (code *)0x0 ||
              (iVar3 = (*(code *)piVar4[2])(piVar4[1],event), iVar3 != 0)))) {
            psVar1 = (state *)piVar4[4];
            if ((state *)piVar4[4] != (state *)0x0) {
              do {
                psVar2 = psVar1;
                psVar1 = psVar2->entryState;
              } while (psVar2->entryState != (state *)0x0);
              psVar1 = fsm->currentState;
              if ((psVar1 != psVar2) &&
                 (psVar1->exitAction != (anon_subr_void_void_ptr_event_ptr_for_exitAction *)0x0)) {
                (*psVar1->exitAction)(psVar1->data,event);
              }
              if ((code *)piVar4[3] != (code *)0x0) {
                (*(code *)piVar4[3])(fsm->currentState->data,event,psVar2->data);
              }
              if ((fsm->currentState != psVar2) &&
                 (psVar2->entryAction != (anon_subr_void_void_ptr_event_ptr_for_entryAction *)0x0))
              {
                (*psVar2->entryAction)(psVar2->data,event);
              }
              psVar1 = fsm->currentState;
              fsm->currentState = psVar2;
              fsm->previousState = psVar1;
              if (psVar1 == psVar2) {
                return 1;
              }
              if (fsm->errorState == psVar2) {
                return -1;
              }
              if (psVar2->numTransitions == 0) {
                return 3;
              }
              return 0;
            }
            goto LAB_23029090;
          }
          uVar5 = uVar5 + 1;
        }
        psVar1 = psVar1->parentState;
        psVar2 = psVar1;
      }
      iVar3 = 2;
    }
  }
  return iVar3;
}



void netif_status_callback(netif *netif)

{
  uint32_t ip;
  char *pcVar1;
  ip_addr_t *piVar2;
  uint32_t mask;
  uint32_t gw;
  uint32_t dns1;
  
  pcVar1 = ip4addr_ntoa((ip4_addr_t *)&netif->ip_addr);
  printf("[lwip] netif status callback\r\n  IP: %s\r\n",pcVar1);
  pcVar1 = ip4addr_ntoa((ip4_addr_t *)&netif->netmask);
  printf("  MK: %s\r\n",pcVar1);
  pcVar1 = ip4addr_ntoa((ip4_addr_t *)&netif->gw);
  printf("  GW: %s\r\n",pcVar1);
  if (((ip4_addr_t *)&netif->ip_addr != (ip4_addr_t *)0x0) && ((netif->ip_addr).addr != 0)) {
    wifi_mgmr_api_ip_update();
    mask = (netif->netmask).addr;
    gw = (netif->gw).addr;
    ip = (netif->ip_addr).addr;
    piVar2 = dns_getserver('\0');
    dns1 = piVar2->addr;
    piVar2 = dns_getserver('\x01');
    wifi_mgmr_api_ip_got(ip,mask,gw,dns1,piVar2->addr);
    return;
  }
  printf(" SKIP Notify for set Empty Address\r\n");
  return;
}



err_t wifi_tx(netif *netif,pbuf *p)

{
  err_t eVar1;
  TickType_t TVar2;
  pbuf *ppVar3;
  
  ppVar3 = p;
  if (p->tot_len < 0x5eb) {
    do {
      ppVar3 = ppVar3->next;
    } while (ppVar3 != (pbuf *)0x0);
    eVar1 = '\0';
    bl_output(bl606a0_sta,netif,p,(uint)(netif[-1].client_data[1] == (void *)0x0));
  }
  else {
    TVar2 = xTaskGetTickCount();
    eVar1 = -0xc;
    if (2000 < TVar2 - ticks_7281) {
      printf("[TX] %s, TX size too big: %u bytes\r\n",&__func___7282,(uint)p->tot_len);
      ticks_7281 = xTaskGetTickCount();
    }
  }
  return eVar1;
}



err_t bl606a0_wifi_netif_init(netif *netif)

{
  netif->hostname = "bl606a0";
  netif->mtu = 0x5dc;
  *(undefined2 *)&netif->hwaddr_len = 0xa06;
  netif->output = etharp_output;
  netif->linkoutput = wifi_tx;
  netif_set_status_callback(netif,netif_status_callback);
  return '\0';
}



int bl606a0_wifi_init(wifi_conf_t *conf)

{
  int iVar1;
  byte bStack24;
  byte bStack23;
  byte bStack22;
  byte bStack21;
  uint8_t mac [6];
  
  printf("\r\n\r\n[BL] Initi Wi-Fi");
  memset(&bStack24,0,6);
  bl_wifi_mac_addr_get(&bStack24);
  printf(" with MAC #### %02X:%02X:%02X:%02X:%02X:%02X ####\r\n",(uint)bStack24,(uint)bStack23,
         (uint)bStack22,(uint)bStack21,(uint)mac[0],(uint)mac[1]);
  bl_msg_update_channel_cfg((char *)conf);
  printf("-----------------------------------------------------\r\n");
  bl_wifi_clock_enable();
  memset(&bl606a0_sta,0,4);
  iVar1 = bl_main_rtthread_start((bl_hw **)&bl606a0_sta);
  return iVar1;
}



uint32_t fdt32_ld(fdt32_t *p)

{
  return (uint)*(byte *)((int)p + 2) << 8 |
         (uint)*(byte *)p << 0x18 | (uint)*(byte *)((int)p + 1) << 0x10 |
         (uint)*(byte *)((int)p + 3);
}



int nextprop_(void *fdt,int offset)

{
  uint32_t uVar1;
  int iStack36;
  int nextoffset;
  
  while( true ) {
    uVar1 = fdt_next_tag(fdt,offset,&iStack36);
    if (uVar1 == 3) {
      return offset;
    }
    if (uVar1 == 9) break;
    offset = iStack36;
    if (uVar1 != 4) {
      return -1;
    }
  }
  if (iStack36 < 0) {
    return iStack36;
  }
  return -0xb;
}



fdt_property * fdt_get_property_by_offset_(void *fdt,int offset,int *lenp)

{
  fdt_property *pfVar1;
  uint32_t uVar2;
  
  uVar2 = fdt_check_prop_offset_(fdt,offset);
  if ((int)uVar2 < 0) {
    pfVar1 = (fdt_property *)0x0;
    if (lenp == (int *)0x0) {
      return (fdt_property *)0x0;
    }
  }
  else {
    uVar2 = fdt32_ld((fdt32_t *)((int)fdt + 8));
    pfVar1 = (fdt_property *)((int)fdt + uVar2 + offset);
    if (lenp == (int *)0x0) {
      return pfVar1;
    }
    uVar2 = fdt32_ld(&pfVar1->len);
  }
  *lenp = uVar2;
  return pfVar1;
}



char * fdt_get_string(void *fdt,int stroffset,int *lenp)

{
  char *__s;
  uint32_t uVar1;
  void *pvVar2;
  uint __n;
  uint uVar3;
  
  uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 0xc));
  pvVar2 = (void *)fdt_ro_probe_(fdt);
  if (pvVar2 == (void *)0x0) {
    uVar3 = uVar1 + stroffset;
    uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 4));
    if (uVar3 < uVar1) {
      __n = uVar1 - uVar3;
      uVar1 = fdt32_ld((fdt32_t *)fdt);
      if (uVar1 == 0xd00dfeed) {
        if (-1 < stroffset) {
          uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 0x14));
          if (0x10 < uVar1) {
            uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 0x20));
            if (uVar1 <= (uint)stroffset) goto LAB_230294a2;
            if (uVar1 - stroffset < __n) {
              __n = uVar1 - stroffset;
            }
          }
LAB_23029442:
          __s = (char *)((int)fdt + uVar3);
          pvVar2 = memchr(__s,0,__n);
          if (pvVar2 != (void *)0x0) {
            pvVar2 = (void *)((int)pvVar2 - (int)__s);
            goto joined_r0x23029498;
          }
          pvVar2 = (void *)0xfffffff8;
          goto fail;
        }
      }
      else {
        if (uVar1 != 0x2ff20112) {
          pvVar2 = (void *)0xfffffff3;
          goto fail;
        }
        if ((stroffset < 0) &&
           (uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 0x20)), -uVar1 <= (uint)stroffset)) {
          if ((uint)-stroffset < __n) {
            __n = -stroffset;
          }
          goto LAB_23029442;
        }
      }
    }
LAB_230294a2:
    pvVar2 = (void *)0xfffffffc;
  }
fail:
  __s = (char *)0x0;
joined_r0x23029498:
  if (lenp != (int *)0x0) {
    *(void **)lenp = pvVar2;
  }
  return __s;
}



char * fdt_get_name(void *fdt,int nodeoffset,int *len)

{
  uint32_t uVar1;
  size_t sVar2;
  uint32_t uVar3;
  char *__s;
  
  uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 8));
  sVar2 = fdt_ro_probe_(fdt);
  if ((sVar2 == 0) && (sVar2 = fdt_check_node_offset_(fdt,nodeoffset), -1 < (int)sVar2)) {
    uVar3 = fdt32_ld((fdt32_t *)((int)fdt + 0x14));
    __s = (char *)((int)fdt + nodeoffset + uVar1 + 4);
    if (uVar3 < 0x10) {
      __s = strrchr(__s,0x2f);
      if (__s == (char *)0x0) {
        sVar2 = 0xfffffff5;
        goto fail;
      }
      __s = __s + 1;
    }
    if (len == (int *)0x0) {
      return __s;
    }
    sVar2 = strlen(__s);
  }
  else {
fail:
    __s = (char *)0x0;
    if (len == (int *)0x0) {
      return (char *)0x0;
    }
  }
  *len = sVar2;
  return __s;
}



int fdt_subnode_offset_namelen(void *fdt,int offset,char *name,int namelen)

{
  int iVar1;
  char *__s1;
  void *pvVar2;
  int iStack40;
  int depth;
  int olen;
  
  iVar1 = fdt_ro_probe_(fdt);
  if (iVar1 == 0) {
    iStack40 = 0;
    while (-1 < offset) {
      if (iStack40 < 0) goto LAB_23029550;
      if ((((iStack40 == 1) && (__s1 = fdt_get_name(fdt,offset,&depth), __s1 != (char *)0x0)) &&
          (namelen <= depth)) && (iVar1 = memcmp(__s1,name,namelen), iVar1 == 0)) {
        if (__s1[namelen] == '\0') {
          return offset;
        }
        pvVar2 = memchr(name,0x40,namelen);
        if ((pvVar2 == (void *)0x0) && (__s1[namelen] == '@')) {
          return offset;
        }
      }
      offset = fdt_next_node(fdt,offset,&iStack40);
    }
    iVar1 = offset;
    if (iStack40 < 0) {
LAB_23029550:
      iVar1 = -1;
    }
  }
  return iVar1;
}



int fdt_subnode_offset(void *fdt,int parentoffset,char *name)

{
  size_t namelen;
  int iVar1;
  
  namelen = strlen(name);
  iVar1 = fdt_subnode_offset_namelen(fdt,parentoffset,name,namelen);
  return iVar1;
}



int fdt_first_property_offset(void *fdt,int nodeoffset)

{
  int offset;
  
  offset = fdt_check_node_offset_(fdt,nodeoffset);
  if (-1 < offset) {
    offset = nextprop_(fdt,offset);
    return offset;
  }
  return offset;
}



int fdt_next_property_offset(void *fdt,int offset)

{
  int offset_00;
  
  offset_00 = fdt_check_prop_offset_(fdt,offset);
  if (-1 < offset_00) {
    offset_00 = nextprop_(fdt,offset_00);
    return offset_00;
  }
  return offset_00;
}



// WARNING: Variable defined which should be unmapped: slen

fdt_property *
fdt_get_property_namelen_(void *fdt,int offset,char *name,int namelen,int *lenp,int *poffset)

{
  int offset_00;
  fdt_property *pfVar1;
  uint32_t stroffset;
  char *__s1;
  int iVar2;
  int iStack36;
  int slen;
  
  offset_00 = fdt_first_property_offset(fdt,offset);
  do {
    if (offset_00 < 0) {
LAB_2302964e:
      if (lenp != (int *)0x0) {
        *lenp = offset_00;
      }
      return (fdt_property *)0x0;
    }
    pfVar1 = fdt_get_property_by_offset_(fdt,offset_00,lenp);
    if (pfVar1 == (fdt_property *)0x0) {
      offset_00 = -0xd;
      goto LAB_2302964e;
    }
    stroffset = fdt32_ld(&pfVar1->nameoff);
    __s1 = fdt_get_string(fdt,stroffset,&iStack36);
    if (((__s1 != (char *)0x0) && (namelen == iStack36)) &&
       (iVar2 = memcmp(__s1,name,namelen), iVar2 == 0)) {
      if (poffset == (int *)0x0) {
        return pfVar1;
      }
      *poffset = offset_00;
      return pfVar1;
    }
    offset_00 = fdt_next_property_offset(fdt,offset_00);
  } while( true );
}



void * fdt_getprop_namelen(void *fdt,int nodeoffset,char *name,int namelen,int *lenp)

{
  fdt_property *pfVar1;
  uint32_t uVar2;
  int iStack20;
  int poffset;
  
  pfVar1 = fdt_get_property_namelen_(fdt,nodeoffset,name,namelen,lenp,&iStack20);
  if (pfVar1 != (fdt_property *)0x0) {
    uVar2 = fdt32_ld((fdt32_t *)((int)fdt + 0x14));
    if (((uVar2 < 0x10) && ((iStack20 + 0xcU & 7) != 0)) &&
       (uVar2 = fdt32_ld(&pfVar1->len), 7 < uVar2)) {
      pfVar1 = (fdt_property *)&pfVar1[1].len;
    }
    else {
      pfVar1 = pfVar1 + 1;
    }
  }
  return pfVar1;
}



void * fdt_getprop(void *fdt,int nodeoffset,char *name,int *lenp)

{
  size_t namelen;
  void *pvVar1;
  
  namelen = strlen(name);
  pvVar1 = fdt_getprop_namelen(fdt,nodeoffset,name,namelen,lenp);
  return pvVar1;
}



// WARNING: Variable defined which should be unmapped: length

int fdt_stringlist_count(void *fdt,int nodeoffset,char *property)

{
  int iVar1;
  char *__string;
  size_t sVar2;
  char *pcVar3;
  int iStack20;
  int length;
  
  __string = (char *)fdt_getprop(fdt,nodeoffset,property,&iStack20);
  iVar1 = iStack20;
  if (__string != (char *)0x0) {
    pcVar3 = __string + iStack20;
    iVar1 = 0;
    while (__string < pcVar3) {
      sVar2 = strnlen(__string,(size_t)(pcVar3 + -(int)__string));
      iStack20 = sVar2 + 1;
      __string = __string + iStack20;
      if (pcVar3 < __string) {
        return -0xf;
      }
      iVar1 = iVar1 + 1;
    }
  }
  return iVar1;
}



char * fdt_stringlist_get(void *fdt,int nodeoffset,char *property,int idx,int *lenp)

{
  char *__string;
  size_t sVar1;
  int iVar2;
  char *pcVar3;
  int iStack36;
  int length;
  
  __string = (char *)fdt_getprop(fdt,nodeoffset,property,&iStack36);
  if (__string == (char *)0x0) {
    if (lenp != (int *)0x0) {
      *lenp = iStack36;
      return (char *)0x0;
    }
  }
  else {
    pcVar3 = __string + iStack36;
    while (__string < pcVar3) {
      sVar1 = strnlen(__string,(size_t)(pcVar3 + -(int)__string));
      iStack36 = sVar1 + 1;
      if (pcVar3 < __string + iStack36) {
        iVar2 = -0xf;
        if (lenp == (int *)0x0) {
          return (char *)0x0;
        }
        goto LAB_230297ce;
      }
      if (idx == 0) {
        if (lenp != (int *)0x0) {
          *lenp = sVar1;
          return __string;
        }
        return __string;
      }
      idx = idx + -1;
      __string = __string + iStack36;
    }
    if (lenp != (int *)0x0) {
      iVar2 = -1;
LAB_230297ce:
      *lenp = iVar2;
    }
  }
  return (char *)0x0;
}



void blfdt(char *buf,int len,int argc,char **argv)

{
  tc_fdt_wifi();
  tc_blfdtdump();
  return;
}



int blfdt_cli_init(void)

{
  return 0;
}



uint32_t fdt32_ld(fdt32_t *p)

{
  return (uint)*(byte *)((int)p + 2) << 8 |
         (uint)*(byte *)p << 0x18 | (uint)*(byte *)((int)p + 1) << 0x10 |
         (uint)*(byte *)((int)p + 3);
}



int fdt_ro_probe_(void *fdt)

{
  uint32_t uVar1;
  int iVar2;
  
  uVar1 = fdt32_ld((fdt32_t *)fdt);
  if (uVar1 == 0xd00dfeed) {
    uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 0x14));
    iVar2 = -10;
    if (1 < uVar1) {
      uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 0x18));
      iVar2 = 0;
      if (0x11 < uVar1) {
        iVar2 = -10;
      }
    }
  }
  else {
    iVar2 = -9;
    if (uVar1 == 0x2ff20112) {
      uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 0x24));
      iVar2 = 0;
      if (uVar1 == 0) {
        iVar2 = -7;
      }
    }
  }
  return iVar2;
}



void * fdt_offset_ptr(void *fdt,int offset,uint len)

{
  uint32_t uVar1;
  void *pvVar2;
  uint uVar3;
  
  uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 8));
  uVar3 = uVar1 + offset;
  pvVar2 = (void *)0x0;
  if ((uint)offset <= uVar3) {
    pvVar2 = (void *)0x0;
    if (uVar3 <= uVar3 + len) {
      uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 4));
      pvVar2 = (void *)0x0;
      if (uVar3 + len <= uVar1) {
        uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 0x14));
        if (0x10 < uVar1) {
          if (len + offset < (uint)offset) {
            return (void *)0x0;
          }
          uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 0x24));
          if (uVar1 < len + offset) {
            return (void *)0x0;
          }
        }
        pvVar2 = (void *)((int)fdt + uVar3);
      }
    }
  }
  return pvVar2;
}



uint32_t fdt_next_tag(void *fdt,int startoffset,int *nextoffset)

{
  int offset;
  int offset_00;
  uint *puVar1;
  char *pcVar2;
  void *pvVar3;
  uint32_t uVar4;
  uint uVar5;
  uint uVar6;
  
  *nextoffset = -8;
  puVar1 = (uint *)fdt_offset_ptr(fdt,startoffset,4);
  if (puVar1 != (uint *)0x0) {
    uVar5 = *puVar1;
    offset = startoffset + 4;
    uVar5 = uVar5 << 0x18 | uVar5 >> 0x18 | (uVar5 >> 8 & 0xff) << 0x10 |
            (uVar5 >> 0x10 & 0xff) << 8;
    *nextoffset = -0xb;
    offset_00 = offset;
    switch(uVar5) {
    case 1:
      do {
        offset = offset_00 + 1;
        pcVar2 = (char *)fdt_offset_ptr(fdt,offset_00,1);
        if (pcVar2 == (char *)0x0) {
          return 9;
        }
        offset_00 = offset;
      } while (*pcVar2 != '\0');
      break;
    case 2:
    case 4:
    case 9:
      break;
    case 3:
      puVar1 = (uint *)fdt_offset_ptr(fdt,offset,4);
      if (puVar1 == (uint *)0x0) {
        return 9;
      }
      uVar6 = *puVar1;
      uVar6 = uVar6 << 0x18 | uVar6 >> 0x18 | (uVar6 >> 8 & 0xff) << 0x10 |
              (uVar6 >> 0x10 & 0xff) << 8;
      uVar4 = fdt32_ld((fdt32_t *)((int)fdt + 0x14));
      offset = startoffset + 0xcU + uVar6;
      if (((uVar4 < 0x10) && (7 < uVar6)) && ((startoffset + 0xcU & 7) != 0)) {
        offset = offset + 4;
      }
      break;
    default:
      goto LAB_23029986;
    }
    pvVar3 = fdt_offset_ptr(fdt,startoffset,offset - startoffset);
    if (pvVar3 != (void *)0x0) {
      *nextoffset = offset + 3U & 0xfffffffc;
      return uVar5;
    }
  }
LAB_23029986:
  return 9;
}



int fdt_check_node_offset_(void *fdt,int offset)

{
  uint32_t uVar1;
  int aiStack20 [4];
  
  if (((offset < 0) || ((offset & 3U) != 0)) ||
     (aiStack20[0] = offset, uVar1 = fdt_next_tag(fdt,offset,aiStack20), uVar1 != 1)) {
    aiStack20[0] = -4;
  }
  return aiStack20[0];
}



int fdt_check_prop_offset_(void *fdt,int offset)

{
  uint32_t uVar1;
  int aiStack20 [4];
  
  if (((offset < 0) || ((offset & 3U) != 0)) ||
     (aiStack20[0] = offset, uVar1 = fdt_next_tag(fdt,offset,aiStack20), uVar1 != 3)) {
    aiStack20[0] = -4;
  }
  return aiStack20[0];
}



int fdt_next_node(void *fdt,int offset,int *depth)

{
  uint32_t uVar1;
  int iVar2;
  int iStack36;
  int nextoffset;
  
  iStack36 = 0;
  if (offset < 0) goto LAB_23029a68;
  iStack36 = fdt_check_node_offset_(fdt,offset);
  iVar2 = iStack36;
  do {
    if (iVar2 < 0) {
      return iStack36;
    }
LAB_23029a68:
    do {
      while (iVar2 = iStack36, uVar1 = fdt_next_tag(fdt,iStack36,&iStack36), uVar1 != 2) {
        if (uVar1 == 9) {
          if (iStack36 < 0) {
            if (iStack36 != -8) {
              return iStack36;
            }
            if (depth != (int *)0x0) {
              return -8;
            }
          }
          return -1;
        }
        if (uVar1 == 1) {
          if (depth == (int *)0x0) {
            return iVar2;
          }
          *depth = *depth + 1;
          return iVar2;
        }
      }
    } while (depth == (int *)0x0);
    iVar2 = *depth + -1;
    *depth = iVar2;
  } while( true );
}



uint32_t fdt32_to_cpu(fdt32_t x)

{
  return (x >> 0x10 & 0xff) << 8 | x << 0x18 | x >> 0x18 | (x >> 8 & 0xff) << 0x10;
}



uint64_t fdt64_to_cpu(void)

{
  uint64_t in_fa0;
  
  return in_fa0;
}



uint32_t fdt32_ld(fdt32_t *p)

{
  return (uint)*(byte *)((int)p + 2) << 8 |
         (uint)*(byte *)p << 0x18 | (uint)*(byte *)((int)p + 1) << 0x10 |
         (uint)*(byte *)((int)p + 3);
}



_Bool util_is_printable_string(void *data,int len)

{
  byte *pbVar1;
  undefined uVar2;
  byte *pbVar3;
  byte *pbVar4;
  
  if (len == 0) {
LAB_23029ba0:
    uVar2 = 0;
  }
  else {
    pbVar1 = (byte *)(len + (int)data);
    uVar2 = 0;
    if (pbVar1[-1] == 0) {
      while (pbVar3 = (byte *)data, data < pbVar1) {
        do {
          pbVar4 = pbVar3;
          if ((*pbVar3 == 0) || ((_ctype_[(uint)*pbVar3 + 1] & 0x97) == 0)) break;
          pbVar3 = pbVar3 + 1;
          pbVar4 = pbVar1;
        } while (pbVar1 != pbVar3);
        if ((*pbVar4 != 0) || ((byte *)data == pbVar4)) goto LAB_23029ba0;
        data = pbVar4 + 1;
      }
      uVar2 = 1;
    }
  }
  return (_Bool)uVar2;
}



void utilfdt_print_data(char *data,int len)

{
  char *__format;
  _Bool _Var1;
  undefined3 extraout_var;
  size_t sVar2;
  uint32_t uVar3;
  undefined1 *puVar4;
  int iVar5;
  
  if (len == 0) {
    return;
  }
  _Var1 = util_is_printable_string(data,len);
  if (CONCAT31(extraout_var,_Var1) != 0) {
    printf(" = ");
    __format = data + len;
    while( true ) {
      printf("\"%s\"",data);
      sVar2 = strlen(data);
      data = data + sVar2 + 1;
      if (__format <= data) break;
      printf(", ");
    }
    return;
  }
  if ((len & 3U) == 0) {
    printf(" = <");
    iVar5 = 0;
    while (iVar5 < len / 4) {
      uVar3 = fdt32_to_cpu(*(fdt32_t *)(data + iVar5 * 4));
      puVar4 = (undefined1 *)0x23080f8c;
      if (len / 4 + -1 <= iVar5) {
        puVar4 = &DAT_23088e60;
      }
      printf("0x%08x%s",uVar3,puVar4);
      iVar5 = iVar5 + 1;
    }
    __format = ">";
  }
  else {
    printf(" = [");
    iVar5 = 0;
    while (iVar5 < len) {
      puVar4 = (undefined1 *)0x23080f8c;
      if (len + -1 <= iVar5) {
        puVar4 = &DAT_23088e60;
      }
      printf("%02x%s",(uint)(byte)data[iVar5],puVar4);
      iVar5 = iVar5 + 1;
    }
    __format = "]";
  }
  printf(__format);
  return;
}



undefined4 tc_blfdtdump(void)

{
  uint8_t *__s;
  uint *puVar1;
  fdt32_t *pfVar2;
  TickType_t TVar3;
  uint32_t len;
  uint32_t uVar4;
  uint32_t uVar5;
  uint32_t uVar6;
  uint32_t uVar7;
  uint32_t uVar8;
  uint uVar9;
  uint uVar10;
  undefined *puVar11;
  undefined4 uVar12;
  size_t sVar13;
  char *__format;
  uint uVar14;
  uint uVar15;
  int iVar16;
  fdt32_t *pfVar17;
  undefined *puVar18;
  int iVar19;
  fdt32_t *data;
  uint64_t uVar20;
  fdt32_t *pfStack72;
  
  __s = tc_wifi_dtb;
  while( true ) {
    if ((int)(&UNK_2308063b + -(int)__s) < 4) break;
    __s = (uint8_t *)memchr(__s,0xd0,-(int)__s + 0x23080637);
    if ((fdt32_t *)__s == (fdt32_t *)0x0) goto LAB_23029ed2;
    len = fdt32_ld((fdt32_t *)__s);
    if (len == 0xd00dfeed) {
      puVar18 = &UNK_2308063b + -(int)__s;
      if ((((((undefined *)0x27 < puVar18) && (len = fdt32_ld((fdt32_t *)__s + 5), len < 0x12)) &&
           (len = fdt32_ld((fdt32_t *)__s + 6), len < 0x12)) &&
          ((puVar11 = (undefined *)fdt32_ld((fdt32_t *)__s + 1), puVar11 < puVar18 &&
           (puVar11 = (undefined *)fdt32_ld((fdt32_t *)__s + 2), puVar11 < puVar18)))) &&
         (puVar11 = (undefined *)fdt32_ld((fdt32_t *)__s + 3), puVar11 < puVar18))
      goto LAB_23029d34;
      printf("%s: skipping fdt magic at offset %#tx\r\n","fdtbuff",(fdt32_t *)__s + -0x8c1fce3);
    }
    __s = (uint8_t *)((int)__s + 1);
  }
  if (((fdt32_t *)__s == (fdt32_t *)0x0) || (&UNK_2308063b + -(int)__s < (undefined *)0x28)) {
LAB_23029ed2:
    if (TrapNetCounter == 0) {
      xTaskGetTickCount();
    }
    else {
      xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] %s: could not locate fdt magic\r\n",&DAT_23072bcc,
              "tc_blfdt_dump.c",0x149,"fdtbuff");
    printf("dump failed\r\n");
    uVar12 = 0xffffffff;
  }
  else {
LAB_23029d34:
    printf("%s: found fdt at offset %#tx\r\n","fdtbuff",(fdt32_t *)__s + -0x8c1fce3);
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] dump_blob.",TVar3,&DAT_2307f16c,"tc_blfdt_dump.c",0x153);
    len = fdt32_to_cpu(((fdt32_t *)__s)[4]);
    uVar4 = fdt32_to_cpu(((fdt32_t *)__s)[2]);
    uVar5 = fdt32_to_cpu(((fdt32_t *)__s)[3]);
    uVar6 = fdt32_to_cpu(((fdt32_t *)__s)[5]);
    uVar7 = fdt32_to_cpu(((fdt32_t *)__s)[1]);
    printf("/dts-v1/;\r\n");
    uVar8 = fdt32_to_cpu(*(fdt32_t *)__s);
    printf("// magic:\t\t0x%lx\r\n",uVar8);
    printf("// totalsize:\t\t0x%lx (%lu)\r\n",uVar7);
    printf("// off_dt_struct:\t0x%lx\r\n",uVar4);
    printf("// off_dt_strings:\t0x%lx\r\n",uVar5);
    printf("// off_mem_rsvmap:\t0x%lx\r\n",len);
    printf("// version:\t\t%lu\r\n",uVar6);
    uVar7 = fdt32_to_cpu(((fdt32_t *)__s)[6]);
    printf("// last_comp_version:\t%lu\r\n",uVar7);
    if (1 < uVar6) {
      uVar7 = fdt32_to_cpu(((fdt32_t *)__s)[7]);
      printf("// boot_cpuid_phys:\t0x%lx\r\n",uVar7);
      if (uVar6 != 2) {
        uVar7 = fdt32_to_cpu(((fdt32_t *)__s)[8]);
        printf("// size_dt_strings:\t0x%lx\r\n",uVar7);
        if (0x10 < uVar6) {
          uVar7 = fdt32_to_cpu(((fdt32_t *)__s)[9]);
          printf("// size_dt_struct:\t0x%lx\r\n",uVar7);
        }
      }
    }
    printf("\r\n");
    puVar1 = (uint *)(len + (int)__s);
    while( true ) {
      uVar9 = *puVar1;
      uVar14 = puVar1[1];
      fdt64_to_cpu();
      uVar10 = puVar1[2];
      uVar15 = puVar1[3];
      uVar20 = fdt64_to_cpu();
      if ((uVar9 | uVar10 | uVar15 | uVar14) == 0) break;
      printf("/memreserve/ %#llx %#llx;\r\n",uVar10,uVar15,(int)uVar20);
      puVar1 = puVar1 + 4;
    }
    iVar19 = 0;
    pfStack72 = (fdt32_t *)&DAT_23085d30;
    pfVar17 = (fdt32_t *)((int)__s + uVar4);
    while( true ) {
      data = pfVar17 + 1;
      len = fdt32_to_cpu(*pfVar17);
      if (len == 9) break;
      puVar18 = &DAT_2307f0c0;
      if ((len < 10) &&
         (puVar18 = *(undefined **)(&names_3639 + len * 4),
         *(undefined **)(&names_3639 + len * 4) == (undefined *)0x0)) {
        puVar18 = &DAT_2307f0c0;
      }
      printf("// %04x: tag: 0x%08lx (%s)\r\n",(int)data + (-4 - (int)__s),len,puVar18);
      if (len == 1) {
        sVar13 = strlen((char *)data);
        pfVar2 = data;
        if (*(char *)(pfVar17 + 1) == '\0') {
          pfVar2 = pfStack72;
        }
        printf("%*s%s {\r\n",&DAT_23088e60,pfVar2);
        iVar19 = iVar19 + 1;
        pfVar17 = (fdt32_t *)((int)data + sVar13 + 4 & 0xfffffffc);
      }
      else {
        if (len == 2) {
          iVar19 = iVar19 + -1;
          __format = "%*s};\r\n";
LAB_2302a036:
          printf(__format,&DAT_23088e60);
          pfVar17 = data;
        }
        else {
          if (len == 4) {
            __format = "%*s// [NOP]\r\n";
            goto LAB_2302a036;
          }
          if (len != 3) {
            if (TrapNetCounter == 0) {
              xTaskGetTickCount();
            }
            else {
              xTaskGetTickCountFromISR();
            }
            bl_printk("[%10u][%s: %s:%4d] %*s ** Unknown tag 0x%08lx\r\n",&DAT_23072bcc,
                      "tc_blfdt_dump.c",0xf7,iVar19 << 2,&DAT_23088e60,len);
            break;
          }
          data = pfVar17 + 3;
          len = fdt32_to_cpu(pfVar17[1]);
          uVar4 = fdt32_to_cpu(pfVar17[2]);
          iVar16 = (int)__s + uVar5 + uVar4;
          if ((uVar6 < 0x10) && (7 < (int)len)) {
            data = (fdt32_t *)((uint)((int)pfVar17 + 0x13) & 0xfffffff8);
          }
          printf("// %04x: string: %s\r\n",iVar16);
          printf("// %04x: value\r\n",(fdt32_t *)((int)data - (int)__s));
          printf("%*s%s",iVar19 << 2,&DAT_23088e60,iVar16);
          utilfdt_print_data((char *)data,len);
          pfVar17 = (fdt32_t *)((int)data + len + 3 & 0xfffffffc);
          printf(";\r\n");
        }
      }
    }
    printf("dump successed\r\n");
    uVar12 = 0;
  }
  return uVar12;
}



undefined4 tc_fdt_wifi_module(void)

{
  int idx;
  int parentoffset;
  char *format;
  int nodeoffset;
  uint *puVar1;
  TickType_t TVar2;
  void *__src;
  int iVar3;
  undefined4 uVar4;
  uint uVar5;
  int iStack308;
  undefined auStack304 [256];
  
  iStack308 = 0;
  parentoffset = fdt_subnode_offset(tc_wifi_dtb,0,"wifi");
  if (parentoffset < 1) {
    if (TrapNetCounter == 0) {
      xTaskGetTickCount();
    }
    else {
      xTaskGetTickCountFromISR();
    }
    uVar4 = 0x37;
    format = "[%10u][%s: %s:%4d] wifi NULL.\r\n";
  }
  else {
    nodeoffset = fdt_subnode_offset(tc_wifi_dtb,parentoffset,"region");
    if (0 < nodeoffset) {
      puVar1 = (uint *)fdt_getprop(tc_wifi_dtb,nodeoffset,"country_code",&iStack308);
      if (puVar1 == (uint *)0x0) {
        if (TrapNetCounter == 0) {
          xTaskGetTickCount();
        }
        else {
          xTaskGetTickCountFromISR();
        }
        uVar4 = 0x42;
        format = "[%10u][%s: %s:%4d] country_code NULL.\r\n";
        goto LAB_2302a1c6;
      }
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      uVar5 = *puVar1;
      bl_printk("[%10u][%s: %s:%4d] value = %ld, lentmp = %d\r\n",TVar2,&DAT_2307f16c,
                "tc_blfdt_wifi.c",0x40,
                uVar5 << 0x18 | uVar5 >> 0x18 | (uVar5 >> 8 & 0xff) << 0x10 |
                (uVar5 >> 0x10 & 0xff) << 8,iStack308);
    }
    nodeoffset = fdt_subnode_offset(tc_wifi_dtb,parentoffset,"mac");
    if (0 < nodeoffset) {
      __src = fdt_getprop(tc_wifi_dtb,nodeoffset,"sta_mac_addr",&iStack308);
      if (iStack308 != 6) {
        if (TrapNetCounter == 0) {
          xTaskGetTickCount();
        }
        else {
          xTaskGetTickCountFromISR();
        }
        uVar4 = 0x52;
        format = "[%10u][%s: %s:%4d] sta_mac_addr NULL.\r\n";
        goto LAB_2302a1c6;
      }
      memcpy(auStack304,__src,6);
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] sta_mac :\r\n",TVar2,&DAT_2307f16c,"tc_blfdt_wifi.c",0x4f);
      log_buf_out("tc_blfdt_wifi.c",0x50,auStack304,6,LOG_BUF_OUT_DATA_TYPE_HEX);
      __src = fdt_getprop(tc_wifi_dtb,nodeoffset,"ap_mac_addr",&iStack308);
      if (iStack308 == 6) {
        memcpy(auStack304,__src,6);
        if (TrapNetCounter == 0) {
          TVar2 = xTaskGetTickCount();
        }
        else {
          TVar2 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] ap_mac :\r\n",TVar2,&DAT_2307f16c,"tc_blfdt_wifi.c",0x5c);
        log_buf_out("tc_blfdt_wifi.c",0x5d,auStack304,6,LOG_BUF_OUT_DATA_TYPE_HEX);
      }
    }
    nodeoffset = fdt_subnode_offset(tc_wifi_dtb,parentoffset,"ap");
    if (nodeoffset < 1) {
      if (TrapNetCounter == 0) {
        xTaskGetTickCount();
      }
      else {
        xTaskGetTickCountFromISR();
      }
      uVar4 = 0x98;
    }
    else {
      iVar3 = fdt_stringlist_count(tc_wifi_dtb,nodeoffset,"ssid");
      if (0 < iVar3) {
        idx = 0;
        do {
          format = fdt_stringlist_get(tc_wifi_dtb,nodeoffset,"ssid",idx,&iStack308);
          if (0 < iStack308) {
            if (TrapNetCounter == 0) {
              TVar2 = xTaskGetTickCount();
            }
            else {
              TVar2 = xTaskGetTickCountFromISR();
            }
            bl_printk("[%10u][%s: %s:%4d] ap string[%d] = %s, lentmp = %d\r\n",TVar2,&DAT_2307f16c,
                      "tc_blfdt_wifi.c",0x6a,idx,format,iStack308);
          }
          idx = idx + 1;
        } while (iVar3 != idx);
        iVar3 = fdt_stringlist_count(tc_wifi_dtb,nodeoffset,"pwd");
        if (iVar3 < 1) {
          if (TrapNetCounter == 0) {
            xTaskGetTickCount();
          }
          else {
            xTaskGetTickCountFromISR();
          }
          uVar4 = 0x7d;
          format = "[%10u][%s: %s:%4d] pwd NULL.\r\n";
        }
        else {
          idx = 0;
          do {
            format = fdt_stringlist_get(tc_wifi_dtb,nodeoffset,"pwd",idx,&iStack308);
            if (0 < iStack308) {
              if (TrapNetCounter == 0) {
                TVar2 = xTaskGetTickCount();
              }
              else {
                TVar2 = xTaskGetTickCountFromISR();
              }
              bl_printk("[%10u][%s: %s:%4d] pwd string[%d] = %s, lentmp = %d\r\n",TVar2,
                        &DAT_2307f16c,"tc_blfdt_wifi.c",0x79,idx,format,iStack308);
            }
            idx = idx + 1;
          } while (iVar3 != idx);
          puVar1 = (uint *)fdt_getprop(tc_wifi_dtb,nodeoffset,"ap_channel",&iStack308);
          if (puVar1 == (uint *)0x0) {
            if (TrapNetCounter == 0) {
              xTaskGetTickCount();
            }
            else {
              xTaskGetTickCountFromISR();
            }
            uVar4 = 0x86;
            format = "[%10u][%s: %s:%4d] ap_channel NULL.\r\n";
          }
          else {
            if (TrapNetCounter == 0) {
              TVar2 = xTaskGetTickCount();
            }
            else {
              TVar2 = xTaskGetTickCountFromISR();
            }
            uVar5 = *puVar1;
            bl_printk("[%10u][%s: %s:%4d] ap_channel = %ld\r\n",TVar2,&DAT_2307f16c,
                      "tc_blfdt_wifi.c",0x84,
                      uVar5 << 0x18 | uVar5 >> 0x18 | (uVar5 >> 8 & 0xff) << 0x10 |
                      (uVar5 >> 0x10 & 0xff) << 8);
            iVar3 = fdt_stringlist_count(tc_wifi_dtb,nodeoffset,"auto_chan_detect");
            idx = 0;
            if (iVar3 < 1) {
              if (TrapNetCounter == 0) {
                xTaskGetTickCount();
              }
              else {
                xTaskGetTickCountFromISR();
              }
              uVar4 = 0x94;
              format = "[%10u][%s: %s:%4d] auto_chan_detect NULL.\r\n";
            }
            else {
              do {
                format = fdt_stringlist_get(tc_wifi_dtb,nodeoffset,"auto_chan_detect",idx,&iStack308
                                           );
                if (0 < iStack308) {
                  if (TrapNetCounter == 0) {
                    TVar2 = xTaskGetTickCount();
                  }
                  else {
                    TVar2 = xTaskGetTickCountFromISR();
                  }
                  bl_printk("[%10u][%s: %s:%4d] auto_chan_detect string[%d] = %s, lentmp = %d\r\n",
                            TVar2,&DAT_2307f16c,"tc_blfdt_wifi.c",0x90,idx,format,iStack308);
                }
                idx = idx + 1;
              } while (iVar3 != idx);
              parentoffset = fdt_subnode_offset(tc_wifi_dtb,parentoffset,"brd_rf");
              if (parentoffset < 1) {
                if (TrapNetCounter == 0) {
                  xTaskGetTickCount();
                }
                else {
                  xTaskGetTickCountFromISR();
                }
                uVar4 = 0xdc;
                format = "[%10u][%s: %s:%4d] brd_rf NULL.\r\n";
              }
              else {
                __src = fdt_getprop(tc_wifi_dtb,parentoffset,"xtal",&iStack308);
                if (iStack308 == 0x14) {
                  memcpy(auStack304,__src,0x14);
                  if (TrapNetCounter == 0) {
                    TVar2 = xTaskGetTickCount();
                  }
                  else {
                    TVar2 = xTaskGetTickCountFromISR();
                  }
                  bl_printk("[%10u][%s: %s:%4d] xtal :\r\n",TVar2,&DAT_2307f16c,"tc_blfdt_wifi.c",
                            0xa5);
                  log_buf_out("tc_blfdt_wifi.c",0xa6,auStack304,0x14,LOG_BUF_OUT_DATA_TYPE_HEX);
                  __src = fdt_getprop(tc_wifi_dtb,parentoffset,"pwr_table",&iStack308);
                  if (iStack308 != 0x100) {
                    if (TrapNetCounter == 0) {
                      xTaskGetTickCount();
                    }
                    else {
                      xTaskGetTickCountFromISR();
                    }
                    bl_printk("[%10u][%s: %s:%4d] pwr_table NULL. lentmp = %d.\r\n",&DAT_23072bcc,
                              "tc_blfdt_wifi.c",0xb4,iStack308);
                    return 0xffffffff;
                  }
                  memcpy(auStack304,__src,0x100);
                  if (TrapNetCounter == 0) {
                    TVar2 = xTaskGetTickCount();
                  }
                  else {
                    TVar2 = xTaskGetTickCountFromISR();
                  }
                  bl_printk("[%10u][%s: %s:%4d] pwr_table :\r\n",TVar2,&DAT_2307f16c,
                            "tc_blfdt_wifi.c",0xb1);
                  log_buf_out("tc_blfdt_wifi.c",0xb2,auStack304,0x100,LOG_BUF_OUT_DATA_TYPE_HEX);
                  __src = fdt_getprop(tc_wifi_dtb,parentoffset,"channel_div_table",&iStack308);
                  if (iStack308 == 0x3c) {
                    memcpy(auStack304,__src,0x3c);
                    if (TrapNetCounter == 0) {
                      TVar2 = xTaskGetTickCount();
                    }
                    else {
                      TVar2 = xTaskGetTickCountFromISR();
                    }
                    bl_printk("[%10u][%s: %s:%4d] channel_div_table :\r\n",TVar2,&DAT_2307f16c,
                              "tc_blfdt_wifi.c",0xbd);
                    log_buf_out("tc_blfdt_wifi.c",0xbe,auStack304,0x3c,LOG_BUF_OUT_DATA_TYPE_HEX);
                    __src = fdt_getprop(tc_wifi_dtb,parentoffset,"channel_cnt_table",&iStack308);
                    if (iStack308 == 0x38) {
                      memcpy(auStack304,__src,0x38);
                      if (TrapNetCounter == 0) {
                        TVar2 = xTaskGetTickCount();
                      }
                      else {
                        TVar2 = xTaskGetTickCountFromISR();
                      }
                      bl_printk("[%10u][%s: %s:%4d] channel_cnt_table :\r\n",TVar2,&DAT_2307f16c,
                                "tc_blfdt_wifi.c",0xc9);
                      log_buf_out("tc_blfdt_wifi.c",0xca,auStack304,0x38,LOG_BUF_OUT_DATA_TYPE_HEX);
                      __src = fdt_getprop(tc_wifi_dtb,parentoffset,"lo_fcal_div",&iStack308);
                      if (iStack308 == 4) {
                        memcpy(auStack304,__src,4);
                        if (TrapNetCounter == 0) {
                          TVar2 = xTaskGetTickCount();
                        }
                        else {
                          TVar2 = xTaskGetTickCountFromISR();
                        }
                        bl_printk("[%10u][%s: %s:%4d] lo_fcal_div :\r\n",TVar2,&DAT_2307f16c,
                                  "tc_blfdt_wifi.c",0xd5);
                        log_buf_out("tc_blfdt_wifi.c",0xd6,auStack304,4,LOG_BUF_OUT_DATA_TYPE_HEX);
                        return 0;
                      }
                      if (TrapNetCounter == 0) {
                        xTaskGetTickCount();
                      }
                      else {
                        xTaskGetTickCountFromISR();
                      }
                      uVar4 = 0xd8;
                      format = "[%10u][%s: %s:%4d] lo_fcal_div NULL.\r\n";
                    }
                    else {
                      if (TrapNetCounter == 0) {
                        xTaskGetTickCount();
                      }
                      else {
                        xTaskGetTickCountFromISR();
                      }
                      uVar4 = 0xcc;
                      format = "[%10u][%s: %s:%4d] channel_cnt_table NULL.\r\n";
                    }
                  }
                  else {
                    if (TrapNetCounter == 0) {
                      xTaskGetTickCount();
                    }
                    else {
                      xTaskGetTickCountFromISR();
                    }
                    uVar4 = 0xc0;
                    format = "[%10u][%s: %s:%4d] channel_div_table NULL.\r\n";
                  }
                }
                else {
                  if (TrapNetCounter == 0) {
                    xTaskGetTickCount();
                  }
                  else {
                    xTaskGetTickCountFromISR();
                  }
                  uVar4 = 0xa8;
                  format = "[%10u][%s: %s:%4d] xtal NULL.";
                }
              }
            }
          }
        }
        goto LAB_2302a1c6;
      }
      if (TrapNetCounter == 0) {
        xTaskGetTickCount();
      }
      else {
        xTaskGetTickCountFromISR();
      }
      uVar4 = 0x6e;
    }
    format = "[%10u][%s: %s:%4d] ap NULL.\r\n";
  }
LAB_2302a1c6:
  bl_printk(format,&DAT_23072bcc,"tc_blfdt_wifi.c",uVar4);
  return 0xffffffff;
}



int tc_fdt_wifi(void)

{
  int iVar1;
  char *__format;
  
  iVar1 = tc_fdt_wifi_module();
  if (iVar1 == 0) {
    __format = "fdt wifi module successed\r\n";
  }
  else {
    __format = "fdt wifi module failed\r\n";
  }
  printf(__format);
  return iVar1;
}



void cmd_blog_info_dump(char *buf,int len,int argc,char **argv)

{
  blog_info_t *pbVar1;
  blog_info_t *pbVar2;
  size_t __n;
  int iVar3;
  char *pcVar4;
  byte *pbVar5;
  byte **ppbVar6;
  char local_b0 [4];
  char name_buf [128];
  
  memset(local_b0,0,0x80);
  bl_printk("blog code1 = %p - %p\r\n",&_fsymc_info_bloop,&_fsymf_info_bloopbloop_base);
  bl_printk("blog code2 = %p - %p\r\n",&_fsymf_info_bloopbloop_base,&_bl_static_blogfile_code_end);
  bl_printk("blog code3 = %p - %p\r\n",&_bl_static_blogfile_code_end,&_bl_static_blogfile_code_end);
  pbVar1 = &_fsymc_info_bloop;
  do {
    if ((blog_info_t *)((int)&_fsymc_info_loopset.name + 3U) < pbVar1) {
      return;
    }
    __n = strlen(pbVar1->name);
    if (0x80 < __n) {
      bl_printk("name too long.\r\n");
      return;
    }
    if (local_b0[0] == '\0') {
LAB_2302aada:
      bl_printk("[%-48s] = [%d]\r\n",pbVar1->name,(uint)*pbVar1->level);
      if ((local_b0[0] == '\0') || (iVar3 = strcmp(pbVar1->name,local_b0), iVar3 != 0)) {
        pbVar2 = &_fsymf_info_bloopbloop_base;
        strcpy(local_b0,pbVar1->name);
        while (pbVar2 < (blog_info_t *)&_bl_static_blogfile_code_end) {
          pcVar4 = strstr(pbVar2->name,pbVar1->name);
          if (pcVar4 == pbVar2->name) {
            ppbVar6 = (byte **)&_bl_static_blogfile_code_end;
            bl_printk("[%-48s] = [%d]\r\n",pcVar4,(uint)*pbVar2->level);
            while (ppbVar6 < &_bl_static_blogfile_code_end) {
              pbVar5 = (byte *)strstr((char *)ppbVar6[1],pbVar2->name);
              if (pbVar5 == ppbVar6[1]) {
                bl_printk("[%-48s] = [%d]\r\n",pbVar5,(uint)**ppbVar6);
              }
              ppbVar6 = ppbVar6 + 2;
            }
          }
          pbVar2 = pbVar2 + 1;
        }
      }
    }
    else {
      iVar3 = strcmp(local_b0,pbVar1->name);
      if (iVar3 != 0) {
        __n = strlen(local_b0);
        memset(local_b0,0,__n);
        goto LAB_2302aada;
      }
    }
    pbVar1 = pbVar1 + 1;
  } while( true );
}



void cmd_blog_set_level(char *buf,int len,int argc,char **argv)

{
  blog_info_t *pbVar1;
  int iVar2;
  char *format;
  size_t sVar3;
  int iVar4;
  char *__s;
  int iVar5;
  blog_info_t *pbVar6;
  blog_level_t bVar7;
  int iVar8;
  
  if (argc != 3) {
    bl_printk("arg error.\r\n");
    goto LAB_2302ab82;
  }
  iVar2 = strcmp(argv[1],"all");
  if (iVar2 == 0) {
    bVar7 = BLOG_LEVEL_ALL;
LAB_2302ac30:
    __s = argv[2];
    sVar3 = strlen(__s);
    iVar5 = 0;
    iVar2 = 0;
    while (iVar2 < (int)sVar3) {
      if (__s[iVar2] == '.') {
        iVar5 = iVar5 + 1;
      }
      iVar2 = iVar2 + 1;
    }
    if (iVar5 == 0) {
      pbVar1 = &_fsymf_info_bloopbloop_base;
      pbVar6 = &_fsymc_info_bloop;
    }
    else {
      if (iVar5 == 1) {
        pbVar1 = (blog_info_t *)&_bl_static_blogfile_code_end;
        pbVar6 = &_fsymf_info_bloopbloop_base;
      }
      else {
        if (iVar5 != 2) {
          __s = argv[2];
          format = "input name = %s not support.\r\n";
          goto LAB_2302ac28;
        }
        pbVar1 = (blog_info_t *)&_bl_static_blogfile_code_end;
        pbVar6 = (blog_info_t *)&_bl_static_blogfile_code_end;
      }
    }
    iVar2 = ((int)((int)pbVar1 - (int)pbVar6) >> 3) + -1;
    iVar5 = 0;
    while (__s = argv[2], iVar5 <= iVar2) {
      iVar8 = iVar5 + iVar2 >> 1;
      pbVar1 = pbVar6 + iVar8;
      iVar4 = strcmp(pbVar1->name,__s);
      if (iVar4 < 0) {
        iVar5 = iVar8 + 1;
      }
      else {
        if (iVar4 == 0) {
          *pbVar1->level = bVar7;
          bl_printk("set %s = %d\r\n",pbVar1->name,(uint)*pbVar1->level);
          return;
        }
        iVar2 = iVar8 + -1;
      }
    }
    format = "input name = %s not find.\r\n";
  }
  else {
    iVar2 = strcmp(argv[1],"debug");
    bVar7 = BLOG_LEVEL_DEBUG;
    if (iVar2 == 0) goto LAB_2302ac30;
    iVar2 = strcmp(argv[1],"info");
    bVar7 = BLOG_LEVEL_INFO;
    if (iVar2 == 0) goto LAB_2302ac30;
    iVar2 = strcmp(argv[1],"warn");
    bVar7 = BLOG_LEVEL_WARN;
    if (iVar2 == 0) goto LAB_2302ac30;
    iVar2 = strcmp(argv[1],"error");
    bVar7 = BLOG_LEVEL_ERROR;
    if (iVar2 == 0) goto LAB_2302ac30;
    iVar2 = strcmp(argv[1],"assert");
    bVar7 = BLOG_LEVEL_ASSERT;
    if (iVar2 == 0) goto LAB_2302ac30;
    iVar2 = strcmp(argv[1],"never");
    bVar7 = BLOG_LEVEL_NEVER;
    if (iVar2 == 0) goto LAB_2302ac30;
    __s = argv[1];
    format = "input level = %s not support.\r\n";
  }
LAB_2302ac28:
  bl_printk(format,__s);
LAB_2302ab82:
  bl_printk("set blog error.\r\n");
  return;
}



void blog_init(void)

{
  blog_level_t **ppbVar1;
  undefined *puVar2;
  blog_info_t *pbVar3;
  undefined4 *puVar4;
  
  bl_printk("\r\nblog init set power on level %d, %d, %d.\r\n",2,2);
  pbVar3 = &_fsymc_info_bloop;
  while (pbVar3 < &_fsymf_info_bloopbloop_base) {
    ppbVar1 = &pbVar3->level;
    pbVar3 = pbVar3 + 1;
    **ppbVar1 = BLOG_LEVEL_INFO;
  }
  pbVar3 = &_fsymf_info_bloopbloop_base;
  while (pbVar3 < (blog_info_t *)&_bl_static_blogfile_code_end) {
    ppbVar1 = &pbVar3->level;
    pbVar3 = pbVar3 + 1;
    **ppbVar1 = BLOG_LEVEL_INFO;
  }
  puVar4 = (undefined4 *)&_bl_static_blogfile_code_end;
  while (puVar4 < &_bl_static_blogfile_code_end) {
    puVar2 = (undefined *)*puVar4;
    puVar4 = puVar4 + 2;
    *puVar2 = 2;
  }
  return;
}



int ota_dump_cmd(void)

{
  _dump_partition();
  return 0;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Could not reconcile some variable overlaps

void ota_tcp_cmd(char **argv)

{
  int iVar1;
  uint32_t uVar2;
  uint8_t uVar3;
  hostent *phVar4;
  char *__s;
  int s;
  uchar *input;
  undefined3 extraout_var;
  int iVar5;
  ssize_t sVar6;
  uint addr;
  int iVar7;
  uint ilen;
  int iVar8;
  bl_mtd_handle_t local_150;
  bl_mtd_handle_t handle;
  uint32_t address;
  uint32_t bin_size;
  sockaddr_in dest;
  uint8_t sha256_result [32];
  uint8_t sha256_img [32];
  char str [33];
  byte bStack206;
  HALPartition_Entry_Config ptEntry;
  iot_sha256_context ctx;
  
  phVar4 = lwip_gethostbyname(argv[1]);
  if (phVar4 == (hostent *)0x0) {
    __s = "gethostbyname Failed\r\n";
  }
  else {
    s = bl_mtd_open("FW",&local_150,1);
    if (s == 0) {
      s = lwip_socket(2,1,0);
      if (s < 0) {
        printf("Error in socket\r\n");
      }
      else {
        memset(&bin_size,0,0x10);
        bin_size._1_1_ = '\x02';
        bin_size._2_2_ = lwip_htons(0xd05);
        handle = (bl_mtd_handle_t)((ip4_addr_t *)((ip4_addr_t *)phVar4->h_addr_list)->addr)->addr;
        dest._0_4_ = (ip4_addr_t)handle;
        __s = ip4addr_ntoa((ip4_addr_t *)&handle);
        input = (uchar *)pvPortMalloc(0x200);
        uVar3 = hal_boot2_get_active_partition();
        printf("Starting OTA test. OTA bin addr is %p\r\n",input);
        printf("[OTA] [TEST] activeID is %u\r\n",CONCAT31(extraout_var,uVar3));
        iVar5 = hal_boot2_get_active_entries(0,(HALPartition_Entry_Config *)(str + 0x20));
        if (iVar5 == 0) {
          address = *(uint32_t *)(&ptEntry.type + ((uint)(bStack206 == 0) + 4) * 4);
          iVar7 = *(int *)(ptEntry.name + (uint)(bStack206 == 0) * 4 + 5);
          printf("Starting OTA test. OTA size is %lu\r\n");
          printf("[OTA] [TEST] activeIndex is %u, use OTA address=%08x\r\n",(uint)bStack206,iVar7);
          printf("[OTA] [TEST] Erase flash with size %lu...",address);
          bl_mtd_erase_all(local_150);
          printf("Done\r\n");
          printf("Server ip Address : %s\r\n",__s);
          iVar5 = lwip_connect(s,(sockaddr *)&bin_size,0x10);
          if (iVar5 == 0) {
            utils_sha256_init((iot_sha256_context *)&ptEntry.age);
            utils_sha256_starts((iot_sha256_context *)&ptEntry.age);
            memset(dest.sin_zero + 4,0,0x20);
            iVar5 = 0;
            uVar2 = 0;
            addr = 0;
            ilen = 0;
LAB_2302af8e:
            while (sVar6 = lwip_read(s,input + ilen,0x200 - ilen), -1 < sVar6) {
              uVar2 = uVar2 + sVar6;
              if (sVar6 == 0) {
                printf("[OTA] [TEST] seems ota file ends unexpectedly, already transfer %u\r\n",
                       uVar2);
                goto LAB_2302afbc;
              }
              printf("total = %d, ret = %d\n\r",uVar2,sVar6);
              ilen = ilen + sVar6;
              if (iVar5 != 0) {
                if (address != uVar2) goto code_r0x2302b164;
                goto LAB_2302b180;
              }
              if (0x1ff < ilen) {
                if (ilen != 0x200) {
                  printf("[OTA] [TCP] Assert for unexpected error %d\r\n",ilen);
                  do {
                    // WARNING: Do nothing block with infinite loop
                  } while( true );
                }
                memcpy(sha256_img + 0x1c,input,0x10);
                str[12] = '\0';
                puts("[OTA] [HEADER] ota header is ");
                puts((char *)(sha256_img + 0x1c));
                puts("\r\n");
                memcpy(sha256_img + 0x1c,input + 0x10,4);
                str[0] = '\0';
                puts("[OTA] [HEADER] file type is ");
                puts((char *)(sha256_img + 0x1c));
                puts("\r\n");
                __s = strstr((char *)(sha256_img + 0x1c),"XZ");
                memcpy(&address,input + 0x14,4);
                printf("[OTA] [HEADER] file length (exclude ota header) is %lu\r\n",address);
                memcpy(sha256_img + 0x1c,input + 0x20,0x10);
                str[12] = '\0';
                puts("[OTA] [HEADER] ver_hardware is ");
                puts((char *)(sha256_img + 0x1c));
                puts("\r\n");
                memcpy(sha256_img + 0x1c,input + 0x30,0x10);
                str[12] = '\0';
                puts("[OTA] [HEADER] ver_software is ");
                puts((char *)(sha256_img + 0x1c));
                puts("\r\n");
                memcpy(sha256_img + 0x1c,input + 0x40,0x20);
                str[28] = '\0';
                puts("[OTA] [HEADER] sha256 is ");
                do {
                  iVar8 = iVar5 + 0x1c;
                  iVar5 = iVar5 + 1;
                  printf("%02X",(uint)sha256_img[iVar8]);
                } while (iVar5 != 0x20);
                puts("\r\n");
                memcpy(sha256_result + 0x1c,input + 0x40,0x20);
                iVar5 = -0x2f0;
                if (__s == (char *)0x0) {
                  iVar5 = -0x2ec;
                }
                uVar2 = uVar2 - 0x200;
                printf("[OTA] [TCP] Update bin_size to %lu, file status %s\r\n",address,
                       iVar5 + 0x23081000);
                ilen = 0;
                iVar5 = 1;
              }
            }
            printf("ret = %d, err = %d\n\r",sVar6,errno);
LAB_2302afbc:
            lwip_close(s);
            vPortFree(input);
            utils_sha256_free((iot_sha256_context *)&ptEntry.age);
            goto LAB_2302ae54;
          }
          printf("Error in connect\r\n");
          lwip_close(s);
        }
        else {
          printf("PtTable_Get_Active_Entries fail\r\n");
        }
        vPortFree(input);
      }
LAB_2302ae54:
      bl_mtd_close(local_150);
      return;
    }
    __s = "Open Default FW partition failed\r\n";
  }
  puts(__s);
  return;
code_r0x2302b164:
  if (0x1ff < ilen) {
    if (ilen != 0x200) {
      printf("[OTA] [TCP] Assert for unexpected error %d\r\n",ilen);
      do {
                    // WARNING: Do nothing block with infinite loop
      } while( true );
    }
LAB_2302b180:
    printf("Will Write %u to %08X from %p\r\n",ilen,iVar7 + addr,input);
    utils_sha256_update((iot_sha256_context *)&ptEntry.age,input,ilen);
    bl_mtd_write(local_150,addr,ilen,input);
    addr = addr + ilen;
    ilen = 0;
    if (uVar2 == address) {
      utils_sha256_finish((iot_sha256_context *)&ptEntry.age,(uint8_t *)(dest.sin_zero + 4));
      puts("\r\nCalculated SHA256 Checksum:");
      do {
        iVar8 = ilen + 4;
        ilen = ilen + 1;
        printf("%02X",(uint)(byte)dest.sin_zero[iVar8]);
      } while (ilen != 0x20);
      puts("\r\nHeader SET SHA256 Checksum:");
      iVar8 = 0;
      do {
        iVar1 = iVar8 + 0x1c;
        iVar8 = iVar8 + 1;
        printf("%02X",(uint)sha256_result[iVar1]);
      } while (iVar8 != 0x20);
      puts("\r\n");
      iVar8 = memcmp(sha256_result + 0x1c,dest.sin_zero + 4,0x20);
      if (iVar8 != 0) {
        printf("[OTA] [TCP] SHA256 NOT Correct\r\n");
        goto LAB_2302afbc;
      }
      printf("[OTA] [TCP] prepare OTA partition info\r\n");
      ptEntry.maxLen[1] = address;
      printf("[OTA] [TCP] Update PARTITION, partition len is %lu\r\n");
      hal_boot2_update_ptable((HALPartition_Entry_Config *)(str + 0x20));
      printf("[OTA] [TCP] Rebooting\r\n");
      hal_reboot();
      ilen = 0;
    }
  }
  goto LAB_2302af8e;
}



void ota_tcp_cmd(char *buf,int len,int argc,char **argv)

{
  if (argc != 2) {
    printf("Usage: %s IP\r\n",*argv);
    return;
  }
  ota_tcp_cmd(argv);
  return;
}



int bl_sys_ota_cli_init(void)

{
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

void cmd_sys_time_now(char *buf,int len,int argc,char **argv)

{
  UDItype UVar1;
  undefined4 local_30;
  uint64_t epoch_ms;
  undefined auStack36 [4];
  utils_time_date_t date;
  
  local_30 = 0;
  epoch_ms._0_4_ = 0;
  puts("BL SYS TIME time is\r\n");
  bl_sys_time_get((uint64_t *)&local_30);
  UVar1 = __udivdi3();
  utils_time_date_from_epoch(auStack36,(int)UVar1);
  return;
}



int bl_sys_time_cli_init(void)

{
  return 0;
}



void bl_sys_time_update(undefined4 param_1,undefined4 param_2)

{
  time_synced._0_4_ = xTaskGetTickCount();
  epoch_time._0_4_ = param_1;
  epoch_time._4_4_ = param_2;
  time_synced._4_4_ = 0;
  return;
}



int bl_sys_time_get(uint64_t *epoch)

{
  TickType_t TVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  
  if (((uint)epoch_time | epoch_time._4_4_) == 0) {
    iVar2 = -1;
  }
  else {
    TVar1 = xTaskGetTickCount();
    uVar4 = TVar1 - (int)time_synced;
    uVar3 = (uint)epoch_time + uVar4;
    iVar2 = ((int)uVar4 >> 0x1f) + epoch_time._4_4_;
    *(uint *)epoch = uVar3;
    *(int *)((int)epoch + 4) = (uint)(uVar3 < uVar4) + iVar2;
    iVar2 = 0;
  }
  return iVar2;
}



int bl_sys_time_sync_state(uint32_t *xTicksToJump)

{
  bool bVar1;
  TickType_t TVar2;
  TickType_t TVar3;
  uint uVar4;
  uint64_t uVar5;
  
  if (sync_init != 0) {
    vTaskEnterCritical();
    TVar2 = xTaskGetTickCount();
    TVar3 = TVar2;
    uVar5 = bl_rtc_get_timestamp_ms();
    vTaskExitCritical((int)uVar5);
    uVar4 = TVar3 - init_tick_rtc;
    bVar1 = TVar2 - init_tick_rtos < uVar4;
    if (bVar1) {
      *xTicksToJump = (init_tick_rtos - TVar2) + uVar4;
    }
    return (uint)bVar1;
  }
  return -1;
}



cli_command * cli_command_get(int idx,int *is_static_cmd)

{
  cli_st *pcVar1;
  cli_command *pcVar2;
  
  pcVar1 = cli;
  pcVar2 = (cli_command *)0xffffffff;
  if (-1 < idx) {
    pcVar2 = (cli_command *)0xffffffff;
    if ((uint)idx < cli->num_static_cmds + 8) {
      if ((uint)idx < cli->num_static_cmds) {
        if (is_static_cmd != (int *)0x0) {
          *is_static_cmd = 1;
        }
        pcVar2 = pcVar1->static_cmds + idx;
      }
      else {
        if (is_static_cmd != (int *)0x0) {
          *is_static_cmd = 0;
        }
        pcVar2 = pcVar1->dynamic_cmds[idx - pcVar1->num_static_cmds];
      }
    }
  }
  return pcVar2;
}



void exit_cmd(char *buf,int len,int argc,char **argv)

{
  cliexit = 1;
  return;
}



int cb_idnoe(void *arg,inode_t *node)

{
  uint8_t uVar1;
  char *pcVar2;
  undefined4 uVar3;
  
  if (*(int *)arg == 0) {
    *(undefined4 *)arg = 1;
    printf("\tSize\t\t\t\t\t Name\t\t\tFiletype\r\n");
    printf("----------------------------------------------------------------------------------\r\n")
    ;
  }
  uVar1 = node->type;
  uVar3 = 0x1c;
  if ((1 < (byte)(uVar1 - 1)) && (uVar3 = 0x50, uVar1 != '\x03')) {
    uVar3 = 0;
  }
  if (uVar1 == '\x01') {
    pcVar2 = "Char Device";
  }
  else {
    if (uVar1 == '\x02') {
      pcVar2 = "Block Device";
    }
    else {
      if (uVar1 == '\x03') {
        pcVar2 = "File System";
      }
      else {
        pcVar2 = "Unknown";
      }
    }
  }
  printf("%10d\t\t%30s\t\t\t%s\r\n",uVar3,node->i_name,pcVar2);
  return 0;
}



void ota_cmd(char *buf,int len,int argc,char **argv)

{
  aos_task_new("LOCAL OTA",tftp_ota_thread,(void *)0x0,0x1000);
  return;
}



void tftp_ota_thread(void *arg)

{
  aos_task_exit(0);
  return;
}



void cat_cmd(char *buf,int len,int argc,char **argv)

{
  int fd;
  ssize_t sVar1;
  byte local_11 [4];
  char ch;
  
  if (argc != 2) {
    printf("invalid parameter!\r\n");
  }
  fd = aos_open(argv[1],0);
  if (fd < 0) {
    printf("open %s failed!\r\n",argv[1]);
  }
  else {
    while (sVar1 = aos_read(fd,local_11,1), sVar1 == 1) {
      printf("%c",(uint)local_11[0]);
    }
    printf("\r\n");
    aos_close(fd);
  }
  return;
}



void hexdump_cmd(char *buf,int len,int argc,char **argv)

{
  int fd;
  void *local_18;
  romfs_filebuf_t filebuf;
  
  if (argc != 2) {
    printf("invalid parameter!\r\n");
  }
  fd = aos_open(argv[1],0);
  if (fd < 0) {
    printf("open %s failed!\r\n",argv[1]);
  }
  else {
    memset(&local_18,0,8);
    aos_ioctl(fd,1,(ulong)&local_18);
    printf("Found file %s. XIP Addr %p, len %lu\r\n",argv[1],local_18,filebuf.buf);
    utils_hexdump(local_18,(uint)filebuf.buf);
    aos_close(fd);
  }
  return;
}



int aos_cli_init(int use_thread)

{
  cli_st *pcVar1;
  int iVar2;
  
  cli = (cli_st *)aos_malloc(0x244);
  iVar2 = 0xc;
  if (cli != (cli_st *)0x0) {
    memset(cli,0,0x244);
    pcVar1 = cli;
    cli->static_cmds = cmds_user;
    pcVar1->echo_disabled = 0;
    pcVar1->num_static_cmds = 0x6c;
    pcVar1->num_commands = 0x6c;
    pcVar1->initialized = 1;
    iVar2 = 0;
  }
  return iVar2;
}



void * aos_cli_event_cb_read_get(void)

{
  return console_cb_read;
}



int cli_putstr(char *msg)

{
  int iVar1;
  size_t sVar2;
  ssize_t sVar3;
  
  sVar2 = strlen(msg);
  iVar1 = 0;
  while ((iVar1 < (int)sVar2 &&
         (sVar3 = aos_write(fd_console,msg + iVar1,sVar2 - iVar1), -1 < sVar3))) {
    iVar1 = iVar1 + sVar3;
  }
  return 0;
}



void ps_cmd(char *buf,int len,int argc,char **argv)

{
  char *__dest;
  char *__dest_00;
  size_t sVar1;
  int iVar2;
  
  __dest_00 = (char *)pvPortMalloc(0x600);
  if (__dest_00 != (char *)0x0) {
    strcpy(__dest_00,"Task");
    sVar1 = strlen(__dest_00);
    __dest = __dest_00 + sVar1;
    sVar1 = strlen("Task");
    iVar2 = sVar1 - (int)__dest;
    while ((int)(__dest + iVar2) < 0xd) {
      *__dest = ' ';
      __dest = __dest + 1;
      *__dest = '\0';
    }
    strcpy(__dest,
           "State   Priority  Stack    #          Base\r\n********************************************************\r\n"
          );
    sVar1 = strlen(
                  "State   Priority  Stack    #          Base\r\n********************************************************\r\n"
                  );
    vTaskList(__dest + sVar1);
    cli_putstr(__dest_00);
    vPortFree(__dest_00);
    return;
  }
  return;
}



int aos_cli_printf(char *msg,...)

{
  size_t sVar1;
  int iVar2;
  undefined4 in_a1;
  undefined4 in_a2;
  undefined4 in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list ap;
  char message [256];
  undefined4 uStack28;
  undefined4 uStack24;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  undefined4 uStack8;
  undefined4 uStack4;
  
  uStack28 = in_a1;
  uStack24 = in_a2;
  uStack20 = in_a3;
  uStack16 = in_a4;
  uStack12 = in_a5;
  uStack8 = in_a6;
  uStack4 = in_a7;
  memset(&ap,0,0x100);
  sVar1 = 0;
  if (esc_tag_len != '\0') {
    strcpy((char *)&ap,esc_tag);
    sVar1 = strlen(esc_tag);
  }
  iVar2 = vsnprintf((char *)((int)&ap + sVar1),0x100 - sVar1,msg,&uStack28);
  if (0 < iVar2) {
    cli_putstr((char *)&ap);
  }
  return 0;
}



int proc_onecmd(int argc,char **argv)

{
  cli_st *pcVar1;
  cli_st *pcVar2;
  char *__s1;
  cli_command *pcVar3;
  int iVar4;
  uint idx;
  uint uVar5;
  char *__n;
  char *__s2;
  
  if (argc < 1) {
    return 0;
  }
  if (cli->echo_disabled == 0) {
    printf("\r\n");
  }
  __n = (char *)0x0;
  __s1 = strchr(*argv,0x2e);
  __s2 = *argv;
  if (__s1 != (char *)0x0) {
    __n = __s1 + -(int)__s2;
  }
  idx = 0;
  uVar5 = 0;
  while( true ) {
    if (cli->num_static_cmds + 8 <= idx) {
      return 1;
    }
    if (cli->num_commands <= uVar5) break;
    pcVar3 = cli_command_get(idx,(int *)0x0);
    __s1 = pcVar3->name;
    if (__s1 != (char *)0x0) {
      if (__n == (char *)0x0) {
        iVar4 = strcmp(__s1,__s2);
      }
      else {
        iVar4 = strncmp(__s1,__s2,(size_t)__n);
      }
      pcVar1 = cli;
      if (iVar4 == 0) {
        __s1 = (char *)aos_malloc(0x200);
        pcVar2 = cli;
        pcVar1->outbuf = __s1;
        if (pcVar2->outbuf == (char *)0x0) {
          aos_cli_printf("Error! cli alloc mem fail!\r\n");
          return 1;
        }
        memset(pcVar2->outbuf,0,0x200);
        (*pcVar3->function)(cli->outbuf,0x200,argc,argv);
        aos_cli_printf("%s",cli->outbuf);
        aos_free(cli->outbuf);
        cli->outbuf = (char *)0x0;
        return 0;
      }
      uVar5 = uVar5 + 1;
    }
    idx = idx + 1;
  }
  return 1;
}



void ls_cmd(char *buf,int len,int argc,char **argv)

{
  stat *st;
  int iVar1;
  aos_dir_t *dir;
  aos_dirent_t *paVar2;
  char *msg;
  size_t __n;
  size_t sVar3;
  undefined4 uStack180;
  int env;
  char path_name [128];
  
  uStack180 = 0;
  st = (stat *)pvPortMalloc(0x58);
  memset(stat,0,0x58);
  memset(&env,0,0x80);
  if (argc == 2) {
    iVar1 = strcmp(argv[1],"/sdcard");
    if (iVar1 == 0) {
      dir = aos_opendir("/sdcard");
      if (dir == (aos_dir_t *)0x0) {
        msg = "can not open sdcard\r\n";
LAB_2302b970:
        printf(msg);
        goto LAB_2302b94a;
      }
      printf("\tSize\t\t\t\t\t Name\t\t\tFiletype\r\n");
      printf(
            "----------------------------------------------------------------------------------\r\n"
            );
      while (paVar2 = aos_readdir(dir), paVar2 != (aos_dirent_t *)0x0) {
        snprintf((char *)&env,0x7f,"/sdcard/%s",&paVar2->field_0x5);
        iVar1 = aos_stat((char *)&env,st);
        if (iVar1 == 0) {
          iVar1 = 0x450;
          if (-1 < (int)(st->st_mode << 0x11)) {
            iVar1 = 0x46c;
          }
          printf("\r\nCalculated SHA256 Checksum:" + iVar1 + 0x18,st->st_size,&paVar2->field_0x5);
        }
      }
    }
    else {
      msg = argv[1];
      __n = strlen("/romfs");
      iVar1 = memcmp(msg,"/romfs",__n);
      if (iVar1 != 0) {
        iVar1 = strcmp(argv[1],"/");
        if (iVar1 != 0) {
          msg = "un-supported direcotry!\r\n";
          goto LAB_2302ba96;
        }
        goto LAB_2302ba7e;
      }
      dir = aos_opendir(argv[1]);
      if (dir == (aos_dir_t *)0x0) {
        msg = "can not open romfs\r\n";
        goto LAB_2302b970;
      }
      printf("\tSize\t\t\t\t\t Name\t\t\tFiletype\r\n");
      printf(
            "----------------------------------------------------------------------------------\r\n"
            );
      while (paVar2 = aos_readdir(dir), paVar2 != (aos_dirent_t *)0x0) {
        memset(&env,0,0x80);
        snprintf((char *)&env,0x7f,"%s",argv[1]);
        __n = strlen((char *)&env);
        if (*(char *)((int)&uStack180 + __n + 3) != '/') {
          __n = strlen((char *)&env);
          *(undefined *)((int)&env + __n) = 0x2f;
        }
        __n = strlen((char *)&env);
        sVar3 = strlen((char *)&env);
        snprintf((char *)((int)&env + __n),0x7f - sVar3,"%s",&paVar2->field_0x5);
        iVar1 = aos_stat((char *)&env,st);
        if (iVar1 == 0) {
          iVar1 = 0x450;
          if (-1 < (int)(st->st_mode << 0x11)) {
            iVar1 = 0x46c;
          }
          printf("\r\nCalculated SHA256 Checksum:" + iVar1 + 0x18,st->st_size,&paVar2->field_0x5);
        }
      }
    }
    aos_closedir(dir);
  }
  else {
    if (argc != 1) {
      msg = "invalid parameter!\r\n";
LAB_2302ba96:
      aos_cli_printf(msg);
      goto LAB_2302b94a;
    }
LAB_2302ba7e:
    inode_forearch_name(cb_idnoe,&uStack180);
  }
LAB_2302b94a:
  vPortFree(st);
  return;
}



void uptime_cmd(char *buf,int len,int argc,char **argv)

{
  char *pcVar1;
  char *pcVar2;
  int iVar3;
  int iVar4;
  longlong lVar5;
  DItype DVar6;
  
  lVar5 = aos_now_ms();
  aos_cli_printf("UP time in ms %llu\r\n",buf,len,(int)lVar5);
  pcVar1 = buf;
  iVar3 = len;
  __divdi3();
  __moddi3();
  pcVar2 = buf;
  iVar4 = len;
  __divdi3();
  __moddi3();
  __divdi3();
  __divdi3();
  DVar6 = __moddi3();
  aos_cli_printf("UP time in %llu days, %llu hours, %llu minutes, %llu seconds\r\n",buf,len,pcVar2,
                 iVar4,pcVar1,iVar3,(int)DVar6);
  return;
}



void reset_cmd(char *buf,int len,int argc,char **argv)

{
  aos_cli_printf("system reset\r\n");
  hal_sys_reset();
  return;
}



void poweroff_cmd(char *buf,int len,int argc,char **argv)

{
  aos_cli_printf("poweroff\r\n");
  hal_poweroff();
  return;
}



void reboot_cmd(char *buf,int len,int argc,char **argv)

{
  aos_cli_printf("reboot\r\n");
  hal_reboot();
  return;
}



// WARNING: Variable defined which should be unmapped: desc

void version_cmd(char *buf,int len,int argc,char **argv)

{
  int iVar1;
  size_t sVar2;
  int iStack76;
  int num;
  uint addr [4];
  uint size [4];
  char desc [4] [6];
  
  iStack76 = 4;
  aos_cli_printf("kernel version :posix\r\n");
  aos_cli_printf("release_bl_iot_sdk_1.6.11-1-g66bb28da-dirty");
  aos_cli_printf("\r\n");
  iVar1 = bl_chip_memory_ram(&iStack76,(uint *)&num,addr + 3,(char (*) [6])(size + 3));
  if (iVar1 == 0) {
    aos_cli_printf("Memory Configuration on %d banks:\r\n",iStack76);
    while (iVar1 < iStack76) {
      aos_cli_printf("    [%d]%6s %6u Kbytes @ %p\r\n",iVar1,(int)size + iVar1 * 6 + 0xc,
                     addr[iVar1 + 3] >> 10,(&num)[iVar1]);
      iVar1 = iVar1 + 1;
    }
  }
  sVar2 = xPortGetFreeHeapSize();
  aos_cli_printf("Heap left: %d Bytes\r\n",sVar2);
  return;
}



void devname_cmd(char *buf,int len,int argc,char **argv)

{
  aos_cli_printf("device name: %s\r\n",&UNK_23081328);
  return;
}



void echo_cmd(char *buf,int len,int argc,char **argv)

{
  int iVar1;
  char *pcVar2;
  
  if (argc == 1) {
    if (cli->echo_disabled == 0) {
      pcVar2 = "Enabled";
    }
    else {
      pcVar2 = "Disabled";
    }
    aos_cli_printf("Usage: echo on/off. Echo is currently %s\r\n",pcVar2);
    return;
  }
  iVar1 = strcmp(argv[1],"on");
  if (iVar1 == 0) {
    aos_cli_printf("Enable echo\r\n");
    cli->echo_disabled = 0;
  }
  else {
    iVar1 = strcmp(argv[1],"off");
    if (iVar1 == 0) {
      aos_cli_printf("Disable echo\r\n");
      cli->echo_disabled = 1;
    }
  }
  return;
}



void mmem_cmd(char *buf,int len,int argc,char **argv)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  
  if (argc == 3) {
    iVar2 = 4;
LAB_2302bd2e:
    uVar1 = strtol(argv[2],(char **)0x0,0);
  }
  else {
    if (argc == 4) {
      iVar2 = strtol(argv[3],(char **)0x0,0);
      goto LAB_2302bd2e;
    }
    if (argc != 2) goto LAB_2302bd4c;
    uVar1 = 0;
    iVar2 = 4;
  }
  len = strtol(argv[1],(char **)0x0,0);
  if ((uint *)len != (uint *)0x0) {
    if (iVar2 == 1) {
      uVar3 = (uint)*(byte *)len;
      *(byte *)len = (byte)uVar1;
      uVar1 = (uint)*(byte *)len;
    }
    else {
      if (iVar2 == 2) {
        uVar3 = (uint)*(ushort *)len;
        *(ushort *)len = (ushort)uVar1;
        uVar1 = (uint)*(ushort *)len;
      }
      else {
        uVar3 = *(uint *)len;
        *(uint *)len = uVar1;
        uVar1 = *(uint *)len;
      }
    }
    aos_cli_printf("value on 0x%x change from 0x%x to 0x%x.\r\n",len,uVar3,uVar1);
    return;
  }
LAB_2302bd4c:
  aos_cli_printf(
                 "m <addr> <value> <width>\r\naddr  : address to modify\r\nvalue : new value (default is 0)\r\nwidth : width of unit, 1/2/4 (default is 4)\r\n"
                 ,len);
  return;
}



void pmem_cmd(char *buf,int len,int argc,char **argv)

{
  ushort uVar1;
  undefined4 *puVar2;
  int iVar3;
  undefined4 uVar4;
  long lVar5;
  uint uVar6;
  char *pcStack52;
  char *pos;
  
  pcStack52 = (char *)0x0;
  if (argc == 3) {
    lVar5 = 4;
LAB_2302be3e:
    iVar3 = strtol(argv[2],(char **)0x0,0);
    if (0x400 < iVar3) {
      iVar3 = 0x400;
    }
  }
  else {
    if (argc == 4) {
      lVar5 = strtol(argv[3],(char **)0x0,0);
      goto LAB_2302be3e;
    }
    lVar5 = 4;
    iVar3 = 0x10;
    puVar2 = (undefined4 *)0x0;
    if (argc != 2) goto LAB_2302be02;
  }
  puVar2 = (undefined4 *)strtol(argv[1],&pcStack52,0);
LAB_2302be02:
  if ((pcStack52 == (char *)0x0) || (pcStack52 == argv[1])) {
    aos_cli_printf(
                  "p <addr> <nunits> <width>\r\naddr  : address to display\r\nnunits: number of units to display (default is 16)\r\nwidth : width of unit, 1/2/4 (default is 4)\r\n"
                  );
  }
  else {
    if (lVar5 == 1) {
      uVar6 = 0;
      while ((int)uVar6 < iVar3) {
        if ((uVar6 & 0xf) == 0) {
          aos_cli_printf("0x%08x:",(byte *)((int)puVar2 + uVar6));
        }
        aos_cli_printf(" %02x",(uint)*(byte *)((int)puVar2 + uVar6));
        if ((uVar6 & 0xf) == 0xf) {
          aos_cli_printf("\r\n");
        }
        uVar6 = uVar6 + 1;
      }
    }
    else {
      if (lVar5 == 2) {
        uVar6 = 0;
        while ((int)uVar6 < iVar3) {
          if ((uVar6 & 7) == 0) {
            aos_cli_printf("0x%08x:",puVar2);
          }
          uVar1 = *(ushort *)puVar2;
          puVar2 = (undefined4 *)((int)puVar2 + 2);
          aos_cli_printf(" %04x",(uint)uVar1);
          if ((uVar6 & 7) == 7) {
            aos_cli_printf("\r\n");
          }
          uVar6 = uVar6 + 1;
        }
      }
      else {
        uVar6 = 0;
        while ((int)uVar6 < iVar3) {
          if ((uVar6 & 3) == 0) {
            aos_cli_printf("0x%08x:",puVar2);
          }
          uVar4 = *puVar2;
          puVar2 = puVar2 + 1;
          aos_cli_printf(" %08x",uVar4);
          if ((uVar6 & 3) == 3) {
            aos_cli_printf("\r\n");
          }
          uVar6 = uVar6 + 1;
        }
      }
    }
  }
  return;
}



void help_cmd(char *buf,int len,int argc,char **argv)

{
  cli_command *pcVar1;
  uint idx;
  char *pcVar2;
  uint uVar3;
  
  aos_cli_printf("====Build-in Commands====\r\n");
  pcVar1 = built_ins;
  aos_cli_printf("====Support %d cmds once, seperate by ; ====\r\n",4);
  do {
    if (pcVar1->name != (char *)0x0) {
      pcVar2 = pcVar1->help;
      if (pcVar1->help == (char *)0x0) {
        pcVar2 = "";
      }
      aos_cli_printf("%-25s: %s\r\n",pcVar2);
    }
    pcVar1 = pcVar1 + 1;
  } while (pcVar1 != cmds_user);
  aos_cli_printf("\r\n");
  aos_cli_printf("====User Commands====\r\n");
  uVar3 = 0x10;
  idx = 0;
  while ((idx < cli->num_static_cmds + 8 && (uVar3 < cli->num_commands))) {
    pcVar1 = cli_command_get(idx,(int *)0x0);
    if (((pcVar1 < built_ins) || ((cli_command *)((int)&built_ins[0xf].function + 3U) < pcVar1)) &&
       (pcVar1->name != (char *)0x0)) {
      pcVar2 = pcVar1->help;
      if (pcVar1->help == (char *)0x0) {
        pcVar2 = "";
      }
      aos_cli_printf("%-25s: %s\r\n",pcVar2);
      uVar3 = uVar3 + 1;
    }
    idx = idx + 1;
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

int cli_getchar(char *inbuf)

{
  int32_t iVar1;
  uint uVar2;
  uint32_t local_50;
  uint32_t recv_size;
  uart_dev_t uart_stdio;
  
  local_50 = 0;
  memset(&recv_size,0,0x3c);
  recv_size._0_1_ = '\0';
  iVar1 = hal_uart_recv_II((uart_dev_t *)&recv_size,inbuf,1,&local_50,0xffffffff);
  if (iVar1 == 0) {
    uVar2 = (uint)(local_50 == 1);
  }
  else {
    uVar2 = 0;
  }
  return uVar2;
}



// WARNING: Could not reconcile some variable overlaps

void cli_main_input(char *buffer,int count)

{
  byte bVar1;
  char cVar2;
  cli_st *pcVar3;
  cli_st *pcVar4;
  uint8_t uVar5;
  anon_struct *paVar6;
  undefined1 *argv;
  size_t __n;
  cli_command *pcVar7;
  uint uVar8;
  char *__s1;
  char *__s;
  anon_struct aVar9;
  int iVar10;
  byte *__src;
  char *__s_00;
  uint idx;
  int iVar11;
  size_t __n_00;
  int iVar12;
  uint uStack84;
  anon_struct stat;
  char c;
  
  pcVar3 = cli;
  __s1 = cli->inbuf;
  if (__s1 == (char *)0x0) {
    __s1 = "inbuf_null\r\n";
LAB_2302c170:
    aos_cli_printf(__s1);
    return;
  }
  iVar11 = 0;
  uVar5 = esc_tag_len;
LAB_2302c092:
  esc_tag_len = uVar5;
  if (buffer == (char *)0x0) {
    iVar12 = cli_getchar((char *)&stat);
    if (iVar12 != 1) {
      return;
    }
  }
  else {
    if (count <= iVar11) {
      return;
    }
    __src = (byte *)(buffer + iVar11);
    iVar11 = iVar11 + 1;
    stat = (anon_struct)((uint)stat & 0xffffff00 | (uint)*__src);
  }
  pcVar4 = cli;
  cVar2 = key1_4391;
  if ((stat._0_1_ != '\n') && (stat._0_1_ != '\r')) {
    uVar5 = esc_tag_len;
    if (stat._0_1_ == '\x1b') {
      esc_4390 = '\x01';
      key1_4391 = -1;
      key2_4392 = -1;
    }
    else {
      if (esc_4390 != '\0') {
        if (key1_4391 < '\0') {
          __s = (char *)(int)stat._0_1_;
          key1_4391 = stat._0_1_;
          if (__s == (char *)0x5b) goto LAB_2302c092;
          __s1[pcVar3->bp] = '\x1b';
          idx = pcVar3->bp + 1;
          pcVar3->bp = idx;
          __s1[idx] = stat._0_1_;
          pcVar3->bp = pcVar3->bp + 1;
          if (cli->echo_disabled == 0) {
            __s_00 = "\x1b%c";
LAB_2302c1fa:
            printf(__s_00,__s);
          }
        }
        else {
          if ((key2_4392 < '\0') && (key2_4392 = stat._0_1_, stat._0_1_ == 't')) {
            esc_tag[0] = '\x1b';
            esc_tag[1] = key1_4391;
            esc_tag_len = '\x02';
          }
          idx = SEXT14(key2_4392);
          if (((idx & 0xff) - 0x41 & 0xff) < 2) {
            __s_00 = __s1;
            if (idx == 0x41) {
              iVar10 = cli->his_idx;
              iVar12 = iVar10;
              do {
                iVar12 = (iVar12 + 0xff) % 0x100;
                if (cli->history[iVar12] != '\0') {
                  if (iVar10 != iVar12) {
                    do {
                      iVar12 = (iVar12 + 0xff) % 0x100;
                    } while (cli->history[iVar12] != '\0');
                    iVar12 = (iVar12 + 1) % 0x100;
                  }
                  break;
                }
              } while (iVar10 != iVar12);
              cli->his_idx = iVar12;
              while (pcVar4->history[iVar10] != '\0') {
                *__s_00 = pcVar4->history[iVar10];
                iVar10 = (iVar10 + 1) % 0x100;
                __s_00 = __s_00 + 1;
              }
            }
            else {
              iVar10 = cli->his_idx;
              iVar12 = iVar10;
              while (cli->history[iVar12] != '\0') {
                iVar12 = (iVar12 + 1) % 0x100;
              }
              if (iVar10 != iVar12) {
                do {
                  iVar12 = (iVar12 + 1) % 0x100;
                } while (cli->history[iVar12] == '\0');
              }
              cli->his_idx = iVar12;
              while (pcVar4->history[iVar10] != '\0') {
                *__s_00 = pcVar4->history[iVar10];
                iVar10 = (iVar10 + 1) % 0x100;
                __s_00 = __s_00 + 1;
              }
            }
            *__s_00 = '\0';
            printf("\r\n# %s",__s1);
            __n = strlen(__s1);
            pcVar3->bp = __n;
            esc_tag[0] = '\0';
            esc_tag_len = '\0';
          }
          else {
            if (idx == 0x74) {
              if (0x3f < esc_tag_len) {
                esc_tag[0] = '\0';
                esc_tag_len = '\0';
                esc_4390 = '\0';
                printf("Error: esc_tag buffer overflow\r\n");
                uVar5 = esc_tag_len;
                goto LAB_2302c092;
              }
              idx = (uint)esc_tag_len + 1 & 0xff;
              esc_tag[(uint)esc_tag_len] = stat._0_1_;
              pcVar4 = cli;
              uVar5 = (uint8_t)idx;
              if (stat._0_1_ != 'm') goto LAB_2302c092;
              esc_tag[idx] = '\0';
              esc_tag_len = esc_tag_len + '\x02';
              if (pcVar4->echo_disabled == 0) {
                __s = esc_tag;
                __s_00 = "%s";
                goto LAB_2302c1fa;
              }
            }
            else {
              __s1[pcVar3->bp] = '\x1b';
              uVar8 = pcVar3->bp + 1;
              pcVar3->bp = uVar8;
              __s1[uVar8] = cVar2;
              uVar8 = pcVar3->bp + 1;
              pcVar3->bp = uVar8;
              __s1[uVar8] = (char)(idx & 0xff);
              pcVar3->bp = pcVar3->bp + 1;
              if (cli->echo_disabled == 0) {
                printf("\x1b%c%c");
              }
              esc_tag[0] = '\0';
              esc_tag_len = '\0';
            }
          }
        }
        esc_4390 = '\0';
        uVar5 = esc_tag_len;
        goto LAB_2302c092;
      }
      __s1[pcVar3->bp] = stat._0_1_;
      if ((stat._0_1_ == '\b') || (stat._0_1_ == '\x7f')) {
        uVar5 = esc_tag_len;
        if ((pcVar3->bp != 0) &&
           (pcVar3->bp = pcVar3->bp - 1, uVar5 = esc_tag_len, cli->echo_disabled == 0)) {
          printf("%c %c",8,8);
          uVar5 = esc_tag_len;
        }
      }
      else {
        if (stat._0_1_ == '\t') {
          __s1[pcVar3->bp] = '\0';
          aos_cli_printf("\r\n");
          iVar12 = 0;
          uVar8 = 0;
          idx = 0;
          __s_00 = (char *)0x0;
          while ((idx < cli->num_static_cmds + 8 && (uVar8 < cli->num_commands))) {
            pcVar7 = cli_command_get(idx,(int *)0x0);
            __s = __s_00;
            if (pcVar7->name != (char *)0x0) {
              iVar10 = strncmp(__s1,pcVar7->name,pcVar3->bp);
              if (iVar10 == 0) {
                iVar12 = iVar12 + 1;
                __s = pcVar7->name;
                if (iVar12 != 1) {
                  if (iVar12 == 2) {
                    aos_cli_printf("%s %s ",__s_00);
                    __s = __s_00;
                  }
                  else {
                    aos_cli_printf("%s ",__s);
                    __s = __s_00;
                  }
                }
              }
              uVar8 = uVar8 + 1;
            }
            idx = idx + 1;
            __s_00 = __s;
          }
          if (iVar12 == 1) {
            if ((__s_00 != (char *)0x0) && (__n = strlen(__s_00), __n < 0x100)) {
              idx = pcVar3->bp;
              memcpy(__s1 + idx,__s_00 + idx,__n - idx);
              iVar12 = (__n - idx) + pcVar3->bp;
              pcVar3->bp = iVar12 + 1;
              __s1[iVar12] = ' ';
              __s1[pcVar3->bp] = '\0';
            }
          }
          else {
            if (1 < iVar12) {
              aos_cli_printf("\r\n");
            }
          }
          aos_cli_printf("%s%s",&DAT_230812a4,__s1);
          uVar5 = esc_tag_len;
        }
        else {
          if (cli->echo_disabled == 0) {
            printf("%c",(uint)stat & 0xff);
          }
          idx = pcVar3->bp + 1;
          pcVar3->bp = idx;
          uVar5 = esc_tag_len;
          if (0xff < idx) {
            aos_cli_printf("Error: input buffer overflow\r\n");
            aos_cli_printf("# ");
            pcVar3->bp = 0;
            return;
          }
        }
      }
    }
    goto LAB_2302c092;
  }
  __s1[pcVar3->bp] = '\0';
  __s1 = pcVar4->inbuf;
  pcVar3->bp = 0;
  __n = strlen(__s1);
  if (__n != 0) {
    __s = cli->inbuf;
    __n = strlen(__s);
    pcVar3 = cli;
    __n = __n + 1;
    iVar11 = cli->his_cur;
    __n_00 = 0x100 - iVar11;
    cli->his_idx = iVar11;
    __s_00 = pcVar3->history + iVar11;
    iVar12 = iVar11 + __n + -1;
    if ((int)__n_00 < (int)__n) {
      iVar12 = iVar12 % 0x100;
      cVar2 = pcVar3->history[iVar12];
      strncpy(__s_00,__s,__n_00);
      __n = __n - __n_00;
      __s = __s + __n_00;
      __s_00 = cli->history;
    }
    else {
      cVar2 = pcVar3->history[iVar11 + __n + -1];
    }
    strncpy(__s_00,__s,__n);
    pcVar3 = cli;
    iVar11 = (iVar12 + 1) % 0x100;
    cli->his_cur = iVar11;
    if (cVar2 != '\0') {
      while (iVar12 = (int)&pcVar3->initialized + iVar11, *(char *)(iVar12 + 0x144) != '\0') {
        *(undefined *)(iVar12 + 0x144) = 0;
        iVar11 = (iVar11 + 1) % 0x100;
      }
    }
  }
  stat = (anon_struct)0x0;
  memset(argvall_4313,0,0x100);
  memset(&stat,0,0x10);
  memset(&uStack84,0,4);
  iVar11 = 0;
  paVar6 = &stat;
  iVar12 = 0;
  do {
    __src = (byte *)(__s1 + iVar11);
    bVar1 = *__src;
    if (bVar1 != 0x20) {
      if (0x20 < bVar1) {
        if (bVar1 == 0x22) {
          if (((iVar11 == 0) || (__s_00 = __s1 + iVar11 + -1, *__s_00 != '\\')) ||
             ((uStack84 & 1) == 0)) {
            idx = uStack84 & 3;
            if (idx != 1) {
              if (idx == 2) goto LAB_2302c80a;
              if (idx == 0) {
                aVar9 = *paVar6;
                uStack84 = uStack84 & 0xfffffffc | 3;
                *(int *)paVar6 = (int)aVar9 + 1;
                *(char **)(argvall_4313 + (iVar12 * 0x10 + (int)aVar9) * 4) = __s1 + iVar11 + 1;
              }
              else {
                if (idx == 3) {
                  uStack84._0_1_ = (byte)uStack84 & 0xfc;
                  goto LAB_2302c7d0;
                }
              }
            }
          }
          else {
LAB_2302c76c:
            iVar11 = iVar11 + -1;
            __n = strlen((char *)__src);
            memcpy(__s_00,__src,__n + 1);
          }
        }
        else {
          if (bVar1 != 0x3b) goto LAB_2302c13a;
          if (((iVar11 != 0) && (__s_00 = __s1 + iVar11 + -1, *__s_00 == '\\')) &&
             ((uStack84 & 1) != 0)) goto LAB_2302c76c;
          if ((uStack84 & 2) != 0) goto LAB_2302c80a;
          if ((uStack84 & 3) == 1) {
            uStack84 = uStack84 & 0xfffffffe;
            *__src = 0;
            if ((*paVar6 != (anon_struct)0x0) && (iVar12 = iVar12 + 1, iVar12 < 4)) {
              paVar6 = &stat + iVar12;
            }
          }
        }
        goto LAB_2302c6c4;
      }
      if (bVar1 != 0) {
LAB_2302c13a:
        if ((uStack84 & 1) == 0) {
          aVar9 = *paVar6;
          uStack84 = uStack84 | 1;
          *(int *)paVar6 = (int)aVar9 + 1;
          *(byte **)(argvall_4313 + (iVar12 * 0x10 + (int)aVar9) * 4) = __src;
        }
        goto LAB_2302c6c4;
      }
      if ((uStack84 & 2) == 0) {
        uStack84 = uStack84 | 4;
        goto LAB_2302c6c4;
      }
LAB_2302c80a:
      aos_cli_printf("syntax error\r\n");
      goto LAB_2302c72c;
    }
    if (((iVar11 != 0) && (__s_00 = __s1 + iVar11 + -1, *__s_00 == '\\')) && ((uStack84 & 1) != 0))
    goto LAB_2302c76c;
    if ((uStack84 & 3) == 1) {
      uStack84._0_1_ = (byte)uStack84 & 0xfe;
LAB_2302c7d0:
      uStack84 = uStack84 & 0xffffff00 | (uint)(byte)uStack84;
      *__src = 0;
    }
LAB_2302c6c4:
  } while ((((uStack84 & 4) == 0) && (iVar11 = iVar11 + 1, iVar11 < 0x100)) &&
          ((iVar12 < 4 && ((int)*paVar6 < 0x10))));
  if ((uStack84 & 2) != 0) goto LAB_2302c80a;
  paVar6 = &stat;
  argv = argvall_4313;
  idx = 0;
  iVar11 = 0;
  do {
    iVar11 = iVar11 + 1;
    uVar8 = proc_onecmd((int)*paVar6,(char **)argv);
    idx = idx | uVar8;
    if (iVar12 < iVar11) break;
    paVar6 = paVar6 + 1;
    argv = (undefined1 *)((char **)argv + 0x10);
  } while (iVar11 != 4);
  if (idx == 1) {
    if (__s1 != (char *)0x0) {
      aos_cli_printf("command \'%s\' not found\r\n",__s1);
    }
  }
  else {
    if (idx == 2) goto LAB_2302c80a;
  }
LAB_2302c72c:
  aos_cli_printf("\r\n");
  esc_tag[0] = '\0';
  esc_tag_len = '\0';
  __s1 = "# ";
  goto LAB_2302c170;
}



void console_cb_read(int fd,void *param)

{
  ssize_t count;
  char acStack32 [4];
  char buffer [16];
  
  count = aos_read(fd,acStack32,0x10);
  if (0 < count) {
    if (count < 0x11) {
      fd_console = fd;
      cli_main_input(acStack32,count);
    }
    else {
      printf("-------------BUG from aos_read for ret\r\n");
    }
  }
  return;
}



// WARNING: Variable defined which should be unmapped: qry
// WARNING: Could not reconcile some variable overlaps

void get_dns_request(void *arg,udp_pcb *upcb,pbuf *p,ip_addr_t *addr,u16_t port)

{
  u16_t uVar1;
  int iVar2;
  pbuf *buf;
  uint uVar3;
  char *dataptr;
  char *pcVar4;
  uint uVar5;
  uint local_50;
  int len;
  dns_ans_hdr hdr;
  dns_ans_hdr hdr_1;
  dns_ans_ans qry;
  
  *(udp_pcb **)((int)arg + 0x108) = upcb;
  *(ip_addr_t **)((int)arg + 0x10c) = addr;
  *(u16_t *)((int)arg + 0x110) = port;
  if (0xb < p->tot_len) {
    pbuf_copy_partial(p,&len,0xc,0);
    uVar1 = lwip_htons((u16_t)len);
    *(u16_t *)((int)arg + 0x100) = uVar1;
    uVar1 = lwip_htons(hdr.id);
    *(u16_t *)((int)arg + 0x102) = uVar1;
    local_50 = (uint)p->tot_len;
    if (0xff < p->tot_len) {
      local_50 = 0xff;
    }
    pbuf_copy_partial(p,arg,(u16_t)local_50,0xc);
    iVar2 = utils_dns_domain_get((uint8_t *)arg,(uint8_t *)arg,(int *)&local_50);
    if (iVar2 == 0) {
      if ((0 < (int)local_50) && (*(char *)((int)arg + (local_50 - 1)) == '.')) {
        local_50 = local_50 - 1;
      }
      *(undefined *)(local_50 + (int)arg) = 0;
    }
  }
  pbuf_free(p);
  buf = pbuf_alloc(PBUF_TRANSPORT,0x200,PBUF_RAM);
  if (buf != (pbuf *)0x0) {
    memset(&hdr.numauthrr,0,0xc);
    pcVar4 = (char *)((int)arg + -1);
    uVar3 = 0xc;
    hdr.numauthrr = lwip_htons(*(u16_t *)((int)arg + 0x100));
    hdr.numextrarr = lwip_htons(0x8180);
    hdr_1.id = lwip_htons(1);
    hdr_1.flag = lwip_htons(1);
    hdr_1.numquestions = lwip_htons(0);
    hdr_1.numanswers = lwip_htons(0);
    pbuf_take(buf,&hdr.numauthrr,0xc);
    do {
      dataptr = pcVar4 + 1;
      uVar5 = 0;
      pcVar4 = dataptr;
      while ((*pcVar4 != '.' && (*pcVar4 != '\0'))) {
        uVar5 = uVar5 + 1 & 0xff;
        pcVar4 = pcVar4 + 1;
      }
      pbuf_put_at(buf,(u16_t)uVar3,(u8_t)uVar5);
      pbuf_take_at(buf,dataptr,(u16_t)((uint)((int)(pcVar4 + -(int)dataptr) * 0x10000) >> 0x10),
                   (u16_t)((uVar3 + 1) * 0x10000 >> 0x10));
      uVar5 = uVar3 + uVar5 & 0xffff;
      uVar3 = uVar5 + 1 & 0xffff;
    } while (*pcVar4 != '\0');
    pbuf_put_at(buf,(u16_t)((uVar5 + 1) * 0x10000 >> 0x10),'\0');
    hdr_1.numauthrr = lwip_htons(1);
    hdr_1.numextrarr = lwip_htons(1);
    lwip_htons(0xc00c);
    lwip_htons(1);
    lwip_htons(1);
    lwip_htons(0);
    lwip_htonl(0x3c0004);
    lwip_htonl(0xc0a8a901);
    pbuf_take_at(buf,&hdr_1.numauthrr,0x14,(u16_t)((uVar5 + 2) * 0x10000 >> 0x10));
    pbuf_realloc(buf,(u16_t)((uVar5 + 0x16) * 0x10000 >> 0x10));
    udp_sendto(*(udp_pcb **)((int)arg + 0x108),buf,*(ip_addr_t **)((int)arg + 0x10c),
               *(u16_t *)((int)arg + 0x110));
    pbuf_free(buf);
  }
  return;
}



void dns_server_init(void)

{
  err_t eVar1;
  udp_pcb *pcb;
  undefined3 extraout_var;
  void *__s;
  
  pcb = udp_new();
  if (pcb == (udp_pcb *)0x0) {
    return;
  }
  eVar1 = udp_bind(pcb,&ip_addr_any,0x35);
  if ((CONCAT31(extraout_var,eVar1) == 0) && (__s = pvPortMalloc(0x114), __s != (void *)0x0)) {
    memset(__s,0,4);
    udp_recv(pcb,get_dns_request,__s);
    return;
  }
  udp_remove(pcb);
  return;
}



EfErrCode easyflash_init(void)

{
  EfErrCode EVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  char *format;
  size_t local_18;
  size_t default_env_set_size;
  ef_env *default_env_set;
  
  local_18 = 0;
  EVar1 = ef_port_init((ef_env **)&default_env_set_size,&local_18);
  if ((CONCAT31(extraout_var,EVar1) == 0) &&
     (EVar1 = ef_env_init((ef_env *)default_env_set_size,local_18),
     CONCAT31(extraout_var_00,EVar1) == 0)) {
    format = "EasyFlash V%s is initialize success.\r\n";
  }
  else {
    format = "EasyFlash V%s is initialize fail.\r\n";
  }
  ef_log_info(format,&UNK_23081918);
  ef_log_info("You can get the latest version on https://github.com/armink/EasyFlash .\r\n");
  return EVar1;
}



size_t get_status(uint8_t *status_table,size_t status_num)

{
  size_t sVar1;
  size_t sVar2;
  
  sVar2 = status_num - 1;
  do {
    sVar1 = sVar2;
    sVar2 = sVar1 - 1;
    if (sVar2 == 0xffffffff) {
      return sVar1;
    }
  } while (status_table[sVar2] != '\0');
  return sVar1;
}



void update_sector_cache(uint32_t sec_addr,uint32_t empty_addr)

{
  sector_cache_node *psVar1;
  int iVar2;
  int iVar3;
  uint32_t uVar4;
  
  psVar1 = sector_cache_table;
  iVar2 = 4;
  iVar3 = 0;
  do {
    uVar4 = psVar1->addr;
    if ((sec_addr < empty_addr) && (empty_addr < sec_addr + 0x1000)) {
      if (sec_addr == uVar4) {
        psVar1 = sector_cache_table + iVar3;
        goto LAB_2302cb84;
      }
      if ((uVar4 == 0xffffffff) && (iVar2 == 4)) {
        iVar2 = iVar3;
      }
    }
    else {
      if (sec_addr == uVar4) {
        sector_cache_table[iVar3].addr = 0xffffffff;
        return;
      }
    }
    iVar3 = iVar3 + 1;
    psVar1 = psVar1 + 1;
  } while (iVar3 != 4);
  if (iVar2 != 4) {
    psVar1 = sector_cache_table + iVar2;
    psVar1->addr = sec_addr;
LAB_2302cb84:
    psVar1->empty_addr = empty_addr;
  }
  return;
}



uint32_t get_next_sector_addr(sector_meta_data_t pre_sec)

{
  uint uVar1;
  int iVar2;
  
  uVar1 = env_start_addr;
  if (pre_sec->addr != 0xffffffff) {
    if (pre_sec->combined == 0xffffffff) {
      iVar2 = 0x1000;
    }
    else {
      iVar2 = pre_sec->combined << 0xc;
    }
    uVar1 = iVar2 + pre_sec->addr;
    if (env_start_addr + 0x8000 <= uVar1) {
      return 0xffffffff;
    }
  }
  return uVar1;
}



_Bool gc_check_cb(sector_meta_data_t sector,void *arg1,void *arg2)

{
  if (sector->check_ok != false) {
    *(int *)arg1 = *(int *)arg1 + 1;
  }
  return false;
}



void update_env_cache(char *name,size_t name_len,uint32_t addr)

{
  uint32_t uVar1;
  int iVar2;
  env_cache_node *peVar3;
  int iVar4;
  int iVar5;
  ushort uVar6;
  
  uVar1 = ef_calc_crc32(0,name,name_len);
  peVar3 = env_cache_table;
  uVar6 = 0xffff;
  iVar5 = 0x10;
  iVar2 = 0x10;
  iVar4 = 0;
  do {
    if (addr == 0xffffffff) {
      if ((uint)peVar3->name_crc == uVar1 >> 0x10) {
        peVar3 = env_cache_table + iVar4;
        env_cache_table[iVar4].addr = 0xffffffff;
        goto LAB_2302cc82;
      }
    }
    else {
      if ((uint)peVar3->name_crc == uVar1 >> 0x10) {
        env_cache_table[iVar4].addr = addr;
        return;
      }
      if (peVar3->addr == 0xffffffff) {
        if (iVar2 == 0x10) {
          iVar2 = iVar4;
        }
      }
      else {
        if (peVar3->active != 0) {
          peVar3->active = peVar3->active - 1;
        }
        if (peVar3->active < uVar6) {
          iVar5 = iVar4;
          uVar6 = peVar3->active;
        }
      }
    }
    iVar4 = iVar4 + 1;
    peVar3 = peVar3 + 1;
  } while (iVar4 != 0x10);
  if ((iVar2 != 0x10) || (iVar2 = iVar5, iVar5 != 0x10)) {
    peVar3 = env_cache_table + iVar2;
    env_cache_table[iVar2].addr = addr;
    peVar3->name_crc = (uint16_t)(uVar1 >> 0x10);
LAB_2302cc82:
    peVar3->active = 0;
  }
  return;
}



_Bool find_env_cb(env_node_obj_t env,void *arg1,void *arg2)

{
  _Bool _Var1;
  size_t sVar2;
  int iVar3;
  
  sVar2 = strlen((char *)arg1);
  if (((((uint)env->name_len == sVar2) && (_Var1 = env->crc_is_ok, _Var1 != false)) &&
      (env->status == ENV_WRITE)) &&
     (iVar3 = strncmp(env->name,(char *)arg1,(uint)env->name_len), iVar3 == 0)) {
    *(undefined *)arg2 = 1;
  }
  else {
    _Var1 = false;
  }
  return _Var1;
}



_Bool sector_statistics_cb(sector_meta_data_t sector,void *arg1,void *arg2)

{
  sector_store_status_t sVar1;
  
  if (sector->check_ok != false) {
    sVar1 = (sector->status).store;
    if (sVar1 == SECTOR_STORE_EMPTY) {
      *(int *)arg1 = *(int *)arg1 + 1;
    }
    else {
      if (sVar1 == SECTOR_STORE_USING) {
        *(int *)arg2 = *(int *)arg2 + 1;
      }
    }
  }
  return false;
}



_Bool alloc_env_cb(sector_meta_data_t sector,void *arg1,void *arg2)

{
  sector_dirty_status_t sVar1;
  _Bool _Var2;
  
  _Var2 = sector->check_ok;
  if (_Var2 != false) {
    if ((*(uint *)arg1 < sector->remain) &&
       ((sVar1 = (sector->status).dirty, sVar1 == SECTOR_DIRTY_FALSE ||
        ((sVar1 == SECTOR_DIRTY_TRUE && (gc_request == false)))))) {
      *(uint32_t *)arg2 = sector->empty_env;
    }
    else {
      _Var2 = false;
    }
  }
  return _Var2;
}



EfErrCode write_status(uint32_t addr,uint8_t *status_table,size_t status_num,size_t status_index)

{
  EfErrCode EVar1;
  
  if (status_num <= status_index) {
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x111,
                 "(%s) has assert failed at %s.\r\n","status_index < status_num","write_status");
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  if (status_table == (uint8_t *)0x0) {
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x112,
                 "(%s) has assert failed at %s.\r\n","status_table","write_status");
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  memset(status_table,0xff,status_num * 8 - 1 >> 3);
  status_table[status_index - 1] = 0;
  EVar1 = ef_port_write(addr + (status_index - 1),(uint32_t *)(status_table + (status_index - 1)),1)
  ;
  return EVar1;
}



// WARNING: Could not reconcile some variable overlaps

EfErrCode read_env(env_node_obj_t env)

{
  char "read_env" [9];
  uint uVar1;
  uint32_t crc;
  size_t size;
  uint uVar2;
  uint32_t uStack92;
  env_hdr_data env_hdr;
  uint8_t buf [32];
  
  ef_port_read((env->addr).start,&uStack92,0x1c);
  size = get_status((uint8_t *)&uStack92,6);
  env->status = (env_status_t)(size & 0xff);
  env->len = env_hdr.magic;
  uVar2 = env_hdr.magic - 0x14;
  if (uVar2 < 0x7fed) {
    if (env_hdr.magic - 0xfed < 0x7013) {
      ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x223
                   ,"(%s) has assert failed at %s.\r\n",0x23076768,"read_env");
      do {
                    // WARNING: Do nothing block with infinite loop
      } while( true );
    }
    uVar1 = 0;
    crc = 0;
    while (uVar1 < uVar2) {
      size = 0x20;
      if (uVar2 <= uVar1 + 0x20) {
        size = uVar2 - uVar1;
      }
      ef_port_read((env->addr).start + 0x14 + uVar1,&env_hdr.value_len,size);
      crc = ef_calc_crc32(crc,&env_hdr.value_len,size);
      uVar1 = uVar1 + size;
    }
    if (env_hdr.len == crc) {
      crc = (env->addr).start + 0x1c;
      env->crc_is_ok = true;
      ef_port_read(crc,(uint32_t *)env->name,(uint)(byte)env_hdr.crc32);
      (env->addr).value = crc + (byte)env_hdr.crc32;
      env->value_len = env_hdr._20_4_;
      env->name_len = (byte)env_hdr.crc32;
      return EF_NO_ERR;
    }
  }
  else {
    env->len = 0x1c;
    if ((size & 0xff) != 5) {
      env->status = ENV_ERR_HDR;
      ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x21c
                   ,"Error: The ENV @0x%08X length has an error.\r\n",(env->addr).start);
      write_status((env->addr).start,(uint8_t *)&uStack92,6,5);
    }
  }
  env->crc_is_ok = false;
  return EF_READ_ERR;
}



// WARNING: Variable defined which should be unmapped: status_table

EfErrCode update_sec_status(sector_meta_data_t sector,size_t new_env_len,_Bool *is_full)

{
  sector_store_status_t sVar1;
  EfErrCode EVar2;
  uint8_t auStack20 [4];
  uint8_t status_table [3];
  
  sVar1 = (sector->status).store;
  if (sVar1 == SECTOR_STORE_EMPTY) {
    EVar2 = write_status(sector->addr,auStack20,4,2);
  }
  else {
    EVar2 = EF_NO_ERR;
    if (sVar1 == SECTOR_STORE_USING) {
      if ((sector->remain < 0x5c) || (sector->remain - new_env_len < 0x5c)) {
        EVar2 = write_status(sector->addr,auStack20,4,3);
        update_sector_cache(sector->addr,sector->addr + 0x1000);
        if (is_full != (_Bool *)0x0) {
          *is_full = true;
        }
      }
      else {
        if (is_full != (_Bool *)0x0) {
          *is_full = false;
        }
      }
    }
  }
  return EVar2;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Could not reconcile some variable overlaps

EfErrCode format_sector(uint32_t addr)

{
  EfErrCode EVar1;
  undefined3 extraout_var;
  undefined uStack36;
  undefined uStack33;
  sector_hdr_data sec_hdr;
  
  if ((addr & 0xfff) != 0) {
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x3b5,
                 "(%s) has assert failed at %s.\r\n","addr % SECTOR_SIZE == 0","format_sector");
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  EVar1 = ef_port_erase(addr,0x1000);
  if (CONCAT31(extraout_var,EVar1) == 0) {
    memset(&uStack36,0xff,0x14);
    memset(&uStack36,0xff,3);
    uStack36 = 0;
    memset(&uStack36 + 3,0xff,3);
    sec_hdr._4_4_ = 0x30344645;
    uStack33 = 0;
    sec_hdr.magic = 0xffffffff;
    sec_hdr.combined = 0xffffffff;
    EVar1 = ef_port_write(addr,&uStack36,0x14);
    update_sector_cache(addr,addr + 0x1000);
  }
  return EVar1;
}



_Bool check_sec_hdr_cb(sector_meta_data_t sector,void *arg1,void *arg2)

{
  if (sector->check_ok == false) {
    ef_log_info("Warning: Sector header check failed. Format this sector (0x%08x).\r\n",sector->addr
               );
    *(int *)arg1 = *(int *)arg1 + 1;
    format_sector(sector->addr);
    return false;
  }
  return false;
}



_Bool print_env_cb(env_node_obj_t env,void *arg1,void *arg2)

{
  _Bool _Var1;
  uint uVar2;
  uint uVar3;
  size_t sVar4;
  size_t size;
  int iVar5;
  _Bool _Var6;
  uint32_t local_50;
  uint8_t buf [32];
  
  _Var1 = env->crc_is_ok;
  if ((_Var1 != false) && (*(uint32_t *)arg1 = *(int *)arg1 + env->len, env->status == ENV_WRITE)) {
    ef_print("%.*s=",(uint)env->name_len,env->name);
    if (env->value_len < 0xf8c) {
      iVar5 = 2;
      _Var6 = false;
      while( true ) {
        uVar2 = 0;
        while (uVar3 = env->value_len, uVar2 < uVar3) {
          size = 0x20;
          if (uVar3 <= uVar2 + 0x20) {
            size = uVar3 - uVar2;
          }
          ef_port_read((env->addr).value + uVar2,&local_50,size);
          sVar4 = 0;
          if (_Var6 == false) {
            while (size != sVar4) {
              if (0x5e < (uint)*(byte *)((int)&local_50 + sVar4) - 0x20) goto LAB_2302d108;
              sVar4 = sVar4 + 1;
            }
          }
          else {
            ef_print("%.*s",size,&local_50);
          }
          uVar2 = uVar2 + size;
        }
        if (iVar5 == 1) break;
        iVar5 = 1;
        _Var6 = _Var1;
      }
    }
    else {
LAB_2302d108:
      ef_print("blob @0x%08X %dbytes",(env->addr).value,env->value_len);
    }
    ef_print("\r\n");
  }
  return false;
}



// WARNING: Variable defined which should be unmapped: buf

uint32_t get_next_env_addr(sector_meta_data_t sector,env_node_obj_t pre_env)

{
  uint uVar1;
  uint32_t uVar2;
  sector_cache_node *psVar3;
  uint addr;
  int iVar4;
  uint32_t *puVar5;
  uint32_t uVar6;
  uint32_t local_40;
  uint8_t buf [32];
  
  if ((sector->status).store != SECTOR_STORE_EMPTY) {
    addr = (pre_env->addr).start;
    uVar6 = sector->addr;
    if (addr == 0xffffffff) {
      return uVar6 + 0x14;
    }
    if (addr <= uVar6 + 0x1000) {
      uVar1 = addr + 1;
      if (pre_env->crc_is_ok != false) {
        uVar1 = pre_env->len + addr;
      }
      psVar3 = sector_cache_table;
      iVar4 = 0;
      do {
        if ((uVar1 & 0xfffff000) == psVar3->addr) {
          if (uVar1 == sector_cache_table[iVar4].empty_addr) goto LAB_2302d1b4;
          break;
        }
        iVar4 = iVar4 + 1;
        psVar3 = psVar3 + 1;
      } while (iVar4 != 4);
      addr = uVar1;
      while (addr < uVar6 + 0xfec) {
        ef_port_read(addr,&local_40,0x20);
        uVar2 = addr - 8;
        puVar5 = &local_40;
        do {
          if (uVar6 + 0xfe4 == uVar2) break;
          if ((*puVar5 == 0x3034564b) && (uVar1 <= uVar2)) goto LAB_2302d1b6;
          uVar2 = uVar2 + 1;
          puVar5 = (uint32_t *)((int)puVar5 + 1);
        } while (addr + 0x14 != uVar2);
        addr = addr + 0x1c;
      }
LAB_2302d1b4:
      uVar2 = 0xffffffff;
LAB_2302d1b6:
      if ((sector->addr + 0x1000 < uVar2) || (pre_env->len == 0)) {
        uVar2 = 0xffffffff;
      }
      return uVar2;
    }
  }
  return 0xffffffff;
}



// WARNING: Could not reconcile some variable overlaps

EfErrCode read_sector_meta_data(uint32_t addr,sector_meta_data_t sector,_Bool traversal)

{
  char cVar1;
  EfErrCode EVar2;
  uint uVar3;
  size_t size;
  undefined3 in_register_00002031;
  sector_cache_node *psVar4;
  int iVar5;
  uint32_t uVar6;
  uint32_t uVar7;
  size_t sVar8;
  uint addr_00;
  char cVar9;
  uint32_t uVar10;
  undefined4 uStack188;
  sector_hdr_data sec_hdr;
  uint8_t buf [32];
  env_node_obj env_meta;
  
  if ((addr & 0xfff) != 0) {
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x24a,
                 "(%s) has assert failed at %s.\r\n","addr % SECTOR_SIZE == 0",
                 "read_sector_meta_data");
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  ef_port_read(addr,&uStack188,0x14);
  sector->addr = addr;
  sector->magic = sec_hdr._4_4_;
  if (sec_hdr._4_4_ == 0x30344645) {
    sector->combined = sec_hdr.magic;
    sector->check_ok = true;
    size = get_status((uint8_t *)&uStack188,4);
    uVar3 = size & 0xff;
    EVar2 = (EfErrCode)uVar3;
    (sector->status).store = EVar2;
    size = get_status((uint8_t *)((int)&uStack188 + 3),4);
    (sector->status).dirty = (sector_dirty_status_t)size;
    if (CONCAT31(in_register_00002031,traversal) != 0) {
      sector->remain = 0;
      sector->empty_env = addr + 0x14;
      if (uVar3 == 1) {
        sector->remain = 0xfec;
      }
      else {
        if (uVar3 == 2) {
          psVar4 = sector_cache_table;
          iVar5 = 0;
          do {
            if (addr == psVar4->addr) {
              uVar6 = sector_cache_table[iVar5].empty_addr;
              sector->empty_env = uVar6;
              sector->remain = (addr + 0x1000) - uVar6;
              goto LAB_2302d302;
            }
            iVar5 = iVar5 + 1;
            psVar4 = psVar4 + 1;
          } while (iVar5 != 4);
          sector->remain = 0xfec;
          do {
            uVar6 = get_next_env_addr(sector,(env_node_obj_t)(buf + 0x1c));
            if (uVar6 == 0xffffffff) {
              EVar2 = EF_NO_ERR;
LAB_2302d3a0:
              uVar7 = sector->addr;
              uVar6 = sector->empty_env;
              uVar3 = uVar7 + 0x1000;
              cVar9 = '\0';
              uVar10 = uVar6;
              while (addr_00 = uVar10, addr_00 < uVar3) {
                uVar10 = addr_00 + 0x20;
                size = 0x20;
                if (uVar3 <= uVar10) {
                  size = (uVar7 + 0x1020) - uVar10;
                }
                ef_port_read(addr_00,&sec_hdr.reserved,size);
                sVar8 = 0;
                while (size != sVar8) {
                  cVar1 = *(char *)((int)&sec_hdr.reserved + sVar8);
                  if ((cVar9 != -1) && (cVar1 == -1)) {
                    uVar6 = addr_00 + sVar8;
                  }
                  sVar8 = sVar8 + 1;
                  cVar9 = cVar1;
                }
              }
              if (cVar9 != -1) {
                uVar6 = uVar3;
              }
              if (sector->empty_env != uVar6) {
                sector->empty_env = uVar6;
                sector->remain = (sector->addr + 0x1000) - uVar6;
              }
              update_sector_cache(sector->addr,sector->empty_env);
              return EVar2;
            }
            read_env((env_node_obj_t)(buf + 0x1c));
            if ((buf[29] == '\0') && ((buf[28] & 0xfb) != 1)) {
              ef_log_info("Error: The ENV (@0x%08X) CRC32 check failed!\r\n",uVar6);
              sector->remain = 0;
              goto LAB_2302d3a0;
            }
            sector->empty_env = sector->empty_env + env_meta.magic;
            sector->remain = sector->remain - env_meta.magic;
          } while( true );
        }
      }
    }
LAB_2302d302:
    EVar2 = EF_NO_ERR;
  }
  else {
    sector->check_ok = false;
    sector->combined = 0xffffffff;
    EVar2 = EF_ENV_INIT_FAILED;
  }
  return EVar2;
}



void sector_iterator(sector_meta_data_t sector,sector_store_status_t status,void *arg1,void *arg2,
                    anon_subr__Bool_sector_meta_data_t_void_ptr_void_ptr *callback,
                    _Bool traversal_env)

{
  _Bool _Var1;
  uint32_t addr;
  undefined3 extraout_var;
  undefined3 in_register_0000202d;
  undefined3 in_register_0000203d;
  
  sector->addr = 0xffffffff;
  do {
    do {
      addr = get_next_sector_addr(sector);
      if (addr == 0xffffffff) {
        return;
      }
      read_sector_meta_data(addr,sector,false);
    } while ((CONCAT31(in_register_0000202d,status) != 0) &&
            ((uint)(sector->status).store != CONCAT31(in_register_0000202d,status)));
    if (CONCAT31(in_register_0000203d,traversal_env) != 0) {
      read_sector_meta_data(addr,sector,true);
    }
    _Var1 = (*callback)(sector,arg1,arg2);
  } while (CONCAT31(extraout_var,_Var1) == 0);
  return;
}



// WARNING: Variable defined which should be unmapped: using_sector

uint32_t alloc_env(sector_meta_data_t sector,size_t env_size)

{
  size_t asStack36 [2];
  uint32_t local_1c;
  uint32_t empty_env;
  size_t empty_sector;
  size_t using_sector;
  
  local_1c = 0xffffffff;
  empty_env = 0;
  empty_sector = 0;
  asStack36[0] = env_size;
  sector_iterator(sector,SECTOR_STORE_UNUSED,&empty_env,&empty_sector,sector_statistics_cb,false);
  if (empty_sector != 0) {
    sector_iterator(sector,SECTOR_STORE_USING,asStack36,&local_1c,alloc_env_cb,true);
  }
  if ((empty_env != 0) && (local_1c == 0xffffffff)) {
    if ((empty_env < 2) && (gc_request == false)) {
      ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x42d
                   ,"Trigger a GC check after alloc ENV failed.\r\n");
      gc_request = true;
    }
    else {
      sector_iterator(sector,SECTOR_STORE_EMPTY,asStack36,&local_1c,alloc_env_cb,true);
    }
  }
  return local_1c;
}



void gc_collect(void)

{
  uint uStack44;
  size_t empty_sec;
  sector_meta_data sector;
  
  uStack44 = 0;
  sector_iterator((sector_meta_data_t)&empty_sec,SECTOR_STORE_EMPTY,&uStack44,(void *)0x0,
                  gc_check_cb,false);
  ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x4fa,
               "The remain empty sector is %d, GC threshold is %d.\r\n",uStack44,1);
  if (uStack44 < 2) {
    sector_iterator((sector_meta_data_t)&empty_sec,SECTOR_STORE_UNUSED,(void *)0x0,(void *)0x0,do_gc
                    ,false);
  }
  gc_request = false;
  return;
}



uint32_t new_env(sector_meta_data_t sector,size_t env_size)

{
  uint32_t uVar1;
  
  uVar1 = alloc_env(sector,env_size);
  if ((uVar1 == 0xffffffff) && (gc_request != false)) {
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x4b6,
                 "Warning: Alloc an ENV (size %d) failed when new ENV. Now will GC then retry.\r\n",
                 env_size);
    gc_collect();
    uVar1 = alloc_env(sector,env_size);
  }
  return uVar1;
}



_Bool check_and_recovery_gc_cb(sector_meta_data_t sector,void *arg1,void *arg2)

{
  if ((sector->check_ok != false) && ((sector->status).dirty == SECTOR_DIRTY_GC)) {
    gc_request = true;
    gc_collect();
    return false;
  }
  return false;
}



// WARNING: Could not reconcile some variable overlaps

void env_iterator(env_node_obj_t env,void *arg1,void *arg2,
                 anon_subr__Bool_env_node_obj_t_void_ptr_void_ptr *callback)

{
  EfErrCode EVar1;
  _Bool _Var2;
  uint32_t addr;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined uStack56;
  sector_store_status_t sStack55;
  sector_meta_data sector;
  
  sector._0_4_ = 0xffffffff;
  do {
    do {
      addr = get_next_sector_addr((sector_meta_data_t)&uStack56);
      if (addr == 0xffffffff) {
        return;
      }
      EVar1 = read_sector_meta_data(addr,(sector_meta_data_t)&uStack56,false);
    } while ((CONCAT31(extraout_var,EVar1) != 0) || (1 < (byte)(sStack55 + ~SECTOR_STORE_EMPTY)));
    (env->addr).start = 0xffffffff;
    while( true ) {
      addr = get_next_env_addr((sector_meta_data_t)&uStack56,env);
      (env->addr).start = addr;
      if (addr == 0xffffffff) break;
      read_env(env);
      _Var2 = (*callback)(env,arg1,arg2);
      if (CONCAT31(extraout_var_00,_Var2) != 0) {
        return;
      }
    }
  } while( true );
}



_Bool find_env(char *key,env_node_obj_t env)

{
  char cVar1;
  int iVar2;
  size_t size;
  uint32_t uVar3;
  int iVar4;
  uint16_t uVar5;
  env_cache_node *peVar6;
  char local_70;
  char saved_name [64];
  
  size = strlen(key);
  uVar3 = ef_calc_crc32(0,key,size);
  peVar6 = env_cache_table;
  iVar2 = 0;
  do {
    if ((peVar6->addr != 0xffffffff) && ((uint)peVar6->name_crc == uVar3 >> 0x10)) {
      ef_port_read(peVar6->addr + 0x1c,&local_70,0x40);
      iVar4 = strncmp(key,(char *)&local_70,size);
      if (iVar4 == 0) {
        (env->addr).start = env_cache_table[iVar2].addr;
        uVar5 = 0xffff;
        if (env_cache_table[iVar2].active < 0xffef) {
          uVar5 = env_cache_table[iVar2].active + 0x10;
        }
        env_cache_table[iVar2].active = uVar5;
        read_env(env);
        return true;
      }
    }
    iVar2 = iVar2 + 1;
    peVar6 = peVar6 + 1;
  } while (iVar2 != 0x10);
  local_70 = '\0';
  env_iterator(env,key,&local_70,find_env_cb);
  cVar1 = local_70;
  if (local_70 != '\0') {
    update_env_cache(key,size,(env->addr).start);
  }
  return (_Bool)cVar1;
}



EfErrCode del_env(char *key,env_node_obj_t old_env,_Bool complete_del)

{
  _Bool last_is_complete_del;
  int iVar1;
  _Bool _Var2;
  EfErrCode EVar3;
  undefined3 extraout_var;
  uint32_t addr;
  undefined3 extraout_var_00;
  size_t sVar4;
  undefined3 extraout_var_01;
  size_t name_len;
  undefined3 in_register_00002031;
  uint32_t uStack128;
  uint8_t status_table [5];
  env_node_obj env;
  
  if (old_env == (env_node_obj_t)0x0) {
    _Var2 = find_env(key,(env_node_obj_t)(status_table + 4));
    if (CONCAT31(extraout_var,_Var2) == 0) {
      ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x447
                   ,"Not found \'%s\' in ENV.\r\n",key);
      return EF_ENV_NAME_ERR;
    }
    old_env = (env_node_obj_t)(status_table + 4);
  }
  addr = (old_env->addr).start;
  if (CONCAT31(in_register_00002031,complete_del) == 0) {
    EVar3 = write_status(addr,(uint8_t *)&uStack128,6,3);
    iVar1 = CONCAT31(extraout_var_00,EVar3);
    last_is_complete_del = true;
  }
  else {
    EVar3 = write_status(addr,(uint8_t *)&uStack128,6,4);
    iVar1 = CONCAT31(extraout_var_01,EVar3);
    if ((last_is_complete_del == false) && (iVar1 == 0)) {
      if (key == (char *)0x0) {
        name_len = (size_t)old_env->name_len;
        key = old_env->name;
      }
      else {
        name_len = strlen(key);
      }
      update_env_cache(key,name_len,0xffffffff);
    }
    last_is_complete_del = false;
  }
  EVar3 = (EfErrCode)iVar1;
  if (iVar1 == 0) {
    addr = ((old_env->addr).start & 0xfffff000) + 3;
    ef_port_read(addr,&uStack128,3);
    sVar4 = get_status((uint8_t *)&uStack128,4);
    if (sVar4 == 1) {
      EVar3 = write_status(addr,(uint8_t *)&uStack128,4,2);
    }
  }
  return EVar3;
}



EfErrCode move_env(env_node_obj_t env)

{
  EfErrCode EVar1;
  uint32_t addr;
  uint uVar2;
  size_t new_env_len;
  uint uVar3;
  char *__src;
  char cStack229;
  undefined auStack228 [3];
  _Bool find_ok;
  sector_meta_data sector;
  uint8_t status_table [5];
  undefined auStack136 [4];
  env_node_obj env_bak;
  
  if (env->status == ENV_WRITE) {
    del_env((char *)0x0,env,false);
  }
  addr = alloc_env((sector_meta_data_t)auStack228,env->len);
  if (addr == 0xffffffff) {
    return EF_ENV_FULL;
  }
  __src = env->name;
  if (in_recovery_check != false) {
    memset(&sector.empty_env,0,0x41);
    strncpy((char *)&sector.empty_env,__src,(uint)env->name_len);
    cStack229 = '\0';
    env_iterator((env_node_obj_t)auStack136,&sector.empty_env,&cStack229,find_env_cb);
    EVar1 = EF_NO_ERR;
    if (cStack229 != '\0') goto __exit;
  }
  new_env_len = env->len;
  update_sec_status((sector_meta_data_t)auStack228,new_env_len,(_Bool *)0x0);
  write_status(addr,(uint8_t *)&sector.empty_env,6,1);
  uVar3 = new_env_len - 8;
  uVar2 = 0;
  EVar1 = EF_NO_ERR;
  while (uVar2 < uVar3) {
    new_env_len = 0x20;
    if (uVar3 <= uVar2 + 0x20) {
      new_env_len = uVar3 - uVar2;
    }
    ef_port_read((env->addr).start + 8 + uVar2,(uint32_t *)auStack136,new_env_len);
    EVar1 = ef_port_write(addr + 8 + uVar2,(uint32_t *)auStack136,new_env_len);
    uVar2 = uVar2 + new_env_len;
  }
  write_status(addr,(uint8_t *)&sector.empty_env,6,2);
  update_sector_cache(addr & 0xfffff000,env->value_len + 0x1c + (uint)env->name_len + addr);
  update_env_cache(__src,(uint)env->name_len,addr);
  ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x4a6,
               "Moved the ENV (%.*s) from 0x%08X to 0x%08X.\r\n",(uint)env->name_len,__src,
               (env->addr).start,addr);
__exit:
  del_env((char *)0x0,env,true);
  return EVar1;
}



_Bool check_and_recovery_env_cb(env_node_obj_t env,void *arg1,void *arg2)

{
  _Bool _Var1;
  EfErrCode EVar2;
  undefined3 extraout_var;
  uint8_t auStack24 [4];
  uint8_t status_table [5];
  
  _Var1 = env->crc_is_ok;
  if ((_Var1 == false) || (env->status != ENV_PRE_DELETE)) {
    _Var1 = false;
    if (env->status == ENV_PRE_WRITE) {
      write_status((env->addr).start,auStack24,6,5);
      _Var1 = true;
    }
  }
  else {
    ef_log_info("Found an ENV (%.*s) which has changed value failed. Now will recovery it.\r\n",
                (uint)env->name_len,env->name);
    EVar2 = move_env(env);
    if (CONCAT31(extraout_var,EVar2) == 0) {
      ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x6d5
                   ,"Recovery the ENV successful.\r\n");
      _Var1 = false;
    }
    else {
      ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x6d7
                   ,
                   "Warning: Moved an ENV (size %d) failed when recovery. Now will GC then retry.\r\n"
                   ,env->len);
    }
  }
  return _Var1;
}



// WARNING: Could not reconcile some variable overlaps

_Bool do_gc(sector_meta_data_t sector,void *arg1,void *arg2)

{
  EfErrCode EVar1;
  undefined3 extraout_var;
  uint8_t auStack124 [4];
  uint8_t status_table [3];
  env_node_obj env;
  
  if ((sector->check_ok != false) && ((byte)((sector->status).dirty + ~SECTOR_DIRTY_FALSE) < 2)) {
    write_status(sector->addr + 3,auStack124,4,3);
    env.name._60_4_ = 0xffffffff;
    while( true ) {
      env.name._60_4_ = get_next_env_addr(sector,(env_node_obj_t)status_table);
      if (env.name._60_4_ == 0xffffffff) break;
      read_env((env_node_obj_t)status_table);
      if ((((_Bool)status_table[1] != false) && ((byte)(status_table[0] + ~ENV_PRE_WRITE) < 2)) &&
         (EVar1 = move_env((env_node_obj_t)status_table), CONCAT31(extraout_var,EVar1) != 0)) {
        ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",
                     0x4e1,"Error: Moved the ENV (%.*s) for GC failed.\r\n",(uint)status_table[2],
                     &env.value_len);
      }
    }
    format_sector(sector->addr);
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x4e6,
                 "Collect a sector @0x%08X\r\n",sector->addr);
    return false;
  }
  return false;
}



// WARNING: Could not reconcile some variable overlaps

EfErrCode create_env_blob(sector_meta_data_t sector,char *key,void *value,size_t len)

{
  size_t size;
  uint size_00;
  uint32_t addr;
  EfErrCode EVar1;
  size_t sVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  undefined auStack64 [3];
  _Bool _Stack61;
  uint8_t align_data [1];
  _Bool is_full;
  env_hdr_data env_hdr;
  
  addr = sector->empty_env;
  _Stack61 = false;
  sVar2 = strlen(key);
  if (sVar2 < 0x41) {
    memset(align_data,0xff,0x1c);
    env_hdr._4_4_ = 0x3034564b;
    sVar2 = strlen(key);
    env_hdr.crc32._0_1_ = (byte)sVar2;
    env_hdr.magic = len + 0x1c + (sVar2 & 0xff);
    env_hdr._20_4_ = len;
    if (env_hdr.magic < 0xfed) {
      if ((addr == 0xffffffff) && (addr = new_env(sector,env_hdr.magic), addr == 0xffffffff)) {
        return EF_ENV_FULL;
      }
      EVar1 = update_sec_status(sector,env_hdr.magic,&_Stack61);
      if (CONCAT31(extraout_var,EVar1) == 0) {
        env_hdr.len = ef_calc_crc32(0,&env_hdr.crc32,8);
        env_hdr.len = ef_calc_crc32(env_hdr.len,key,(uint)(byte)env_hdr.crc32);
        env_hdr.len = ef_calc_crc32(env_hdr.len,value,env_hdr._20_4_);
        EVar1 = write_status(addr,align_data,6,1);
        if ((CONCAT31(extraout_var_00,EVar1) == 0) &&
           (EVar1 = ef_port_write(addr + 8,(uint32_t *)(env_hdr.status_table + 4),0x14),
           CONCAT31(extraout_var_01,EVar1) == 0)) {
          size_00 = (uint)(byte)env_hdr.crc32;
          memset(auStack64,0xff,1);
          EVar1 = ef_port_write(addr + 0x1c,(uint32_t *)key,size_00);
          if (_Stack61 == false) {
            update_sector_cache(sector->addr,
                                env_hdr._20_4_ + 0x1c + (uint)(byte)env_hdr.crc32 + addr);
          }
          update_env_cache(key,(uint)(byte)env_hdr.crc32,addr);
          size = env_hdr._20_4_;
          if (CONCAT31(extraout_var_02,EVar1) == 0) {
            size_00 = (uint)(byte)env_hdr.crc32;
            memset(auStack64,0xff,1);
            EVar1 = ef_port_write(size_00 + 0x1c + addr,(uint32_t *)value,size);
            if (((CONCAT31(extraout_var_03,EVar1) == 0) &&
                (EVar1 = write_status(addr,align_data,6,2), CONCAT31(extraout_var_04,EVar1) == 0))
               && (_Stack61 != false)) {
              ef_log_debug(
                           "/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c"
                           ,0x562,"Trigger a GC check after created ENV.\r\n");
              gc_request = true;
            }
          }
        }
      }
    }
    else {
      ef_log_info("Error: The ENV size is too big\r\n");
      EVar1 = EF_ENV_FULL;
    }
  }
  else {
    ef_log_info("Error: The ENV name length is more than %d\r\n",0x40);
    EVar1 = EF_ENV_NAME_ERR;
  }
  return EVar1;
}



size_t ef_get_env_blob(char *key,void *value_buf,size_t buf_len,size_t *saved_value_len)

{
  size_t sVar1;
  _Bool _Var2;
  TickType_t TVar3;
  char *format;
  size_t sVar4;
  undefined3 extraout_var;
  undefined4 uVar5;
  undefined auStack120 [4];
  env_node_obj env;
  
  if (init_ok == false) {
    ef_log_info("ENV isn\'t initialize OK.\r\n");
    sVar1 = 0;
  }
  else {
    if ((key == (char *)0x0) || (value_buf == (void *)0x0)) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      uVar5 = 0x34c;
      format = "[%10u][%s: %s:%4d] key = %p, value_buf = %p\r\n";
    }
    else {
      sVar4 = strlen(key);
      if (sVar4 < 0x41) {
        ef_port_env_lock();
        _Var2 = find_env(key,(env_node_obj_t)auStack120);
        sVar1 = 0;
        if (CONCAT31(extraout_var,_Var2) != 0) {
          if (saved_value_len != (size_t *)0x0) {
            *saved_value_len = env.len;
          }
          if (env.len < buf_len) {
            buf_len = env.len;
          }
          ef_port_read(env.addr.start,(uint32_t *)value_buf,buf_len);
          sVar1 = buf_len;
        }
        ef_port_env_unlock();
        return sVar1;
      }
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      key = (char *)strlen(key);
      value_buf = (void *)0x40;
      uVar5 = 0x351;
      format = "[%10u][%s: %s:%4d] key err. %d > %d\r\n";
    }
    bl_printk(format,TVar3,&DAT_23081ce8,&UNK_23081cdc,uVar5,key,value_buf);
    sVar1 = 8;
  }
  return sVar1;
}



EfErrCode ef_del_env(char *key)

{
  EfErrCode EVar1;
  TickType_t TVar2;
  size_t sVar3;
  EfErrCode result;
  
  if (init_ok == false) {
    ef_log_info("Error: ENV isn\'t initialize OK.\r\n");
    EVar1 = EF_ENV_INIT_FAILED;
  }
  else {
    if ((key == (char *)0x0) || (sVar3 = strlen(key), 0x40 < sVar3)) {
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] key = %p\r\n",TVar2,&DAT_23081ce8,&UNK_23081cdc,0x57d,key);
      EVar1 = EF_NO_ERR;
    }
    else {
      ef_port_env_lock();
      EVar1 = del_env(key,(env_node_obj_t)0x0,true);
      ef_port_env_unlock();
    }
  }
  return EVar1;
}



EfErrCode ef_set_env_blob(char *key,void *value_buf,size_t buf_len)

{
  _Bool _Var1;
  EfErrCode EVar2;
  TickType_t TVar3;
  char *format;
  size_t sVar4;
  uint32_t uVar5;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined4 uVar6;
  
  if (init_ok == false) {
    ef_log_info("ENV isn\'t initialize OK.\r\n");
    return EF_ENV_INIT_FAILED;
  }
  if ((key == (char *)0x0) || (value_buf == (void *)0x0)) {
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    uVar6 = 0x5d4;
    format = "[%10u][%s: %s:%4d] key = %p, value_buf = %p\r\n";
  }
  else {
    sVar4 = strlen(key);
    if (sVar4 < 0x41) {
      if (buf_len < 0xf8d) {
        ef_port_env_lock();
        sVar4 = strlen(key);
        uVar5 = new_env((sector_meta_data_t)sector_3152,buf_len + 0x1c + sVar4);
        EVar2 = EF_ENV_FULL;
        if (uVar5 != 0xffffffff) {
          _Var1 = find_env(key,(env_node_obj_t)env_3151);
          if ((CONCAT31(extraout_var,_Var1) == 0) ||
             (EVar2 = del_env(key,(env_node_obj_t)env_3151,false),
             CONCAT31(extraout_var_01,EVar2) == 0)) {
            EVar2 = create_env_blob((sector_meta_data_t)sector_3152,key,value_buf,buf_len);
            if ((CONCAT31(extraout_var,_Var1) != 0) && (CONCAT31(extraout_var_00,EVar2) == 0)) {
              EVar2 = del_env(key,(env_node_obj_t)env_3151,true);
            }
          }
          if (gc_request != false) {
            gc_collect();
          }
        }
        ef_port_env_unlock();
        return EVar2;
      }
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      value_buf = (void *)0xf8c;
      uVar6 = 0x5de;
      format = "[%10u][%s: %s:%4d] buf_len err. %d > %d\r\n";
      key = (char *)buf_len;
    }
    else {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      key = (char *)strlen(key);
      value_buf = (void *)0x40;
      uVar6 = 0x5d9;
      format = "[%10u][%s: %s:%4d] key err. %d > %d\r\n";
    }
  }
  bl_printk(format,TVar3,&DAT_23081ce8,&UNK_23081cdc,uVar6,key,value_buf);
  return EF_ENV_ARG_ERR;
}



EfErrCode ef_set_env(char *key,char *value)

{
  EfErrCode EVar1;
  size_t buf_len;
  
  buf_len = strlen(value);
  EVar1 = ef_set_env_blob(key,value,buf_len);
  return EVar1;
}



EfErrCode ef_save_env(void)

{
  return EF_NO_ERR;
}



EfErrCode ef_env_set_default(void)

{
  uint uVar1;
  uint32_t addr;
  EfErrCode EVar2;
  undefined3 extraout_var;
  size_t len;
  ef_env *peVar3;
  undefined auStack56 [4];
  sector_meta_data sector;
  
  if (default_env_set == (ef_env *)0x0) {
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x621,
                 "(%s) has assert failed at %s.\r\n","default_env_set","ef_env_set_default");
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  if (default_env_set_size == 0) {
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x622,
                 "(%s) has assert failed at %s.\r\n","default_env_set_size","ef_env_set_default");
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  ef_port_env_lock();
  addr = env_start_addr;
  while (addr < env_start_addr + 0x8000) {
    EVar2 = format_sector(addr);
    if (CONCAT31(extraout_var,EVar2) != 0) goto __exit;
    addr = addr + 0x1000;
  }
  uVar1 = 0;
  while (uVar1 < default_env_set_size) {
    len = default_env_set[uVar1].value_len;
    if (len == 0) {
      len = strlen((char *)default_env_set[uVar1].value);
    }
    sector.remain = 0xffffffff;
    peVar3 = default_env_set + uVar1;
    uVar1 = uVar1 + 1;
    create_env_blob((sector_meta_data_t)auStack56,peVar3->key,peVar3->value,len);
  }
  EVar2 = EF_NO_ERR;
__exit:
  ef_port_env_unlock();
  return EVar2;
}



void ef_print_env(void)

{
  int local_6c;
  size_t using_size;
  env_node_obj env;
  
  local_6c = 0;
  if (init_ok == false) {
    ef_log_info("ENV isn\'t initialize OK.\r\n");
  }
  else {
    ef_port_env_lock();
    env_iterator((env_node_obj_t)&using_size,&local_6c,(void *)0x0,print_env_cb);
    ef_print("\r\nmode: next generation\r\n");
    ef_print("size: %lu/%lu bytes.\r\n",local_6c + 0x8c,0x7000);
    ef_port_env_unlock();
  }
  return;
}



// WARNING: Variable defined which should be unmapped: env

EfErrCode ef_load_env(void)

{
  int iStack132;
  size_t check_failed_count;
  sector_meta_data sector;
  env_node_obj env;
  
  in_recovery_check = true;
  iStack132 = 0;
  sector_iterator((sector_meta_data_t)&check_failed_count,SECTOR_STORE_UNUSED,&iStack132,(void *)0x0
                  ,check_sec_hdr_cb,false);
  if (iStack132 == 8) {
    ef_log_info("Warning: All sector header check failed. Set it to default.\r\n");
    ef_env_set_default();
  }
  ef_port_env_lock();
  sector_iterator((sector_meta_data_t)&check_failed_count,SECTOR_STORE_UNUSED,(void *)0x0,
                  (void *)0x0,check_and_recovery_gc_cb,false);
  while( true ) {
    env_iterator((env_node_obj_t)&sector.empty_env,(void *)0x0,(void *)0x0,check_and_recovery_env_cb
                );
    if (gc_request == false) break;
    gc_collect();
  }
  in_recovery_check = false;
  ef_port_env_unlock();
  return EF_NO_ERR;
}



EfErrCode ef_env_init(ef_env *default_env,size_t default_env_size)

{
  char "ef_env_init" [12];
  EfErrCode EVar1;
  undefined3 extraout_var;
  env_cache_node *peVar2;
  
  if (default_env == (ef_env *)0x0) {
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x71e,
                 "(%s) has assert failed at %s.\r\n","default_env","ef_env_init");
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  EVar1 = EF_NO_ERR;
  if (init_ok == false) {
    sector_cache_table[0].addr = 0xffffffff;
    sector_cache_table[1].addr = 0xffffffff;
    sector_cache_table[2].addr = 0xffffffff;
    sector_cache_table[3].addr = 0xffffffff;
    peVar2 = env_cache_table;
    do {
      peVar2->addr = 0xffffffff;
      peVar2 = peVar2 + 1;
    } while (peVar2 != (env_cache_node *)sector_3152);
    env_start_addr = 0;
    default_env_set = default_env;
    default_env_set_size = default_env_size;
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x738,
                 "ENV start address is 0x%08X, size is %d bytes.\r\n",0,0x8000);
    EVar1 = ef_load_env();
    if (CONCAT31(extraout_var,EVar1) == 0) {
      init_ok = true;
    }
  }
  return EVar1;
}



EfErrCode ef_port_read(uint32_t addr,uint32_t *buf,size_t size)

{
  int iVar1;
  
  iVar1 = bl_mtd_read(handle,addr,size,(uint8_t *)buf);
  return (EfErrCode)((iVar1 < 0) << 1);
}



EfErrCode ef_port_write(uint32_t addr,uint32_t *buf,size_t size)

{
  EfErrCode EVar1;
  int iVar2;
  
  iVar2 = bl_mtd_write(handle,addr,size,(uint8_t *)buf);
  if (iVar2 < 0) {
    EVar1 = EF_WRITE_ERR;
  }
  else {
    EVar1 = EF_NO_ERR;
  }
  return EVar1;
}



void ef_port_env_lock(void)

{
  xQueueSemaphoreTake((QueueHandle_t)env_cache_lock,0xffffffff);
  return;
}



void ef_port_env_unlock(void)

{
  xQueueGenericSend((QueueHandle_t)env_cache_lock,(void *)0x0,0,0);
  return;
}



void ef_log_debug(char *file,long line,char *format,...)

{
  undefined4 in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list args;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  undefined4 uStack8;
  undefined4 uStack4;
  
  uStack20 = in_a3;
  uStack16 = in_a4;
  uStack12 = in_a5;
  uStack8 = in_a6;
  uStack4 = in_a7;
  vprint(format,&uStack20);
  return;
}



EfErrCode ef_port_erase(uint32_t addr,size_t size)

{
  char "ef_port_erase" [14];
  int iVar1;
  
  if ((addr & 0xfff) != 0) {
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_port.c",0x77,
                 "(%s) has assert failed at %s.\r\n","addr % EF_ERASE_MIN_SIZE == 0","ef_port_erase"
                );
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  iVar1 = bl_mtd_erase(handle,addr,size);
  return (EfErrCode)((uint)iVar1 >> 0x1f);
}



void ef_log_info(char *format,...)

{
  undefined4 in_a1;
  undefined4 in_a2;
  undefined4 in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list args;
  undefined4 uStack28;
  undefined4 uStack24;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  undefined4 uStack8;
  undefined4 uStack4;
  
  uStack28 = in_a1;
  uStack24 = in_a2;
  uStack20 = in_a3;
  uStack16 = in_a4;
  uStack12 = in_a5;
  uStack8 = in_a6;
  uStack4 = in_a7;
  vprint(format,&uStack28);
  return;
}



// WARNING: Variable defined which should be unmapped: info
// WARNING: Could not reconcile some variable overlaps

EfErrCode ef_port_init(ef_env **default_env,size_t *default_env_size)

{
  int iVar1;
  undefined auStack44 [4];
  bl_mtd_info_t info;
  
  iVar1 = bl_mtd_open("PSM",&handle,2);
  if (iVar1 < 0) {
    ef_log_info("[EF] [PART] [XIP] error when get PSM partition %d\r\n",iVar1);
    puts("[EF] [PART] [XIP] Dead Loop. Reason: no Valid PSM partition found\r\n");
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  memset(auStack44,0,0x1c);
  bl_mtd_info(handle,(bl_mtd_info_t *)auStack44);
  ef_log_info("[EF] Found Valid PSM partition, XIP Addr %08x, flash addr %08x\r\n",info.size,
              info.name._12_4_);
  *default_env = default_env_set;
  *default_env_size = 1;
  printf("*default_env_size = 0x%08x\r\n",1);
  env_cache_lock = (SemaphoreHandle_t)xQueueCreateMutex('\x01');
  return EF_NO_ERR;
}



void ef_print(char *format,...)

{
  undefined4 in_a1;
  undefined4 in_a2;
  undefined4 in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list args;
  undefined4 uStack28;
  undefined4 uStack24;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  undefined4 uStack8;
  undefined4 uStack4;
  
  uStack28 = in_a1;
  uStack24 = in_a2;
  uStack20 = in_a3;
  uStack16 = in_a4;
  uStack12 = in_a5;
  uStack8 = in_a6;
  uStack4 = in_a7;
  vprint(format,&uStack28);
  return;
}



uint32_t ef_calc_crc32(uint32_t crc,void *buf,size_t size)

{
  uint uVar1;
  byte *pbVar2;
  
  uVar1 = ~crc;
  pbVar2 = (byte *)buf;
  while (pbVar2 != (byte *)(size + (int)buf)) {
    uVar1 = uVar1 >> 8 ^ crc32_table[(*pbVar2 ^ uVar1) & 0xff];
    pbVar2 = pbVar2 + 1;
  }
  return ~uVar1;
}



void psm_get_cmd(char *buf,int len,int argc,char **argv)

{
  return;
}



void psm_test_cmd(void)

{
  size_t *psVar1;
  EfErrCode EVar2;
  void *__s;
  void *__s_00;
  undefined3 extraout_var;
  size_t __n;
  char *format;
  int iVar3;
  undefined *puVar4;
  undefined4 uVar5;
  size_t xWantedSize;
  size_t sVar6;
  size_t sStack92;
  size_t local_58 [6];
  size_t asStack64 [3];
  
  psVar1 = local_58;
  memcpy(local_58,&DAT_23082570,0x18);
  do {
    sVar6 = *psVar1;
    sStack92 = 0;
    xWantedSize = sVar6 + 1;
    __s = pvPortMalloc(xWantedSize);
    __s_00 = pvPortMalloc(xWantedSize);
    if ((__s == (void *)0x0) || (__s_00 == (void *)0x0)) {
      if (TrapNetCounter == 0) {
        xTaskGetTickCount();
      }
      else {
        xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] kvbin malloc %d byte error\r\n",&DAT_2307f16c,"easyflash_cli.c",
                0x3d);
      if (__s != (void *)0x0) goto LAB_2302e4c6;
    }
    else {
      memset(__s,0,xWantedSize);
      memset(__s_00,0,xWantedSize);
      xWantedSize = 0;
      while (xWantedSize != sVar6) {
        *(undefined *)((int)__s + xWantedSize) = 0x76;
        xWantedSize = xWantedSize + 1;
      }
      EVar2 = ef_set_env_blob("1234567890123456789012345678901234567890123456789012345678901234",__s
                              ,xWantedSize);
      iVar3 = CONCAT31(extraout_var,EVar2);
      __n = ef_get_env_blob("1234567890123456789012345678901234567890123456789012345678901234",
                            __s_00,xWantedSize,&sStack92);
      if ((iVar3 == 0) && (xWantedSize == __n)) {
        iVar3 = memcmp(__s_00,__s,__n);
        if (iVar3 == 0) {
          if (TrapNetCounter == 0) {
            xTaskGetTickCount();
          }
          else {
            xTaskGetTickCountFromISR();
          }
          bl_printk(
                    "[%10u][%s: %s:%4d] kvbin set %ld byte bin -> read %ld byte -> memcmp success.\r\n"
                    ,&DAT_2307f16c,"easyflash_cli.c",0x56,__n,__n);
          goto LAB_2302e4c6;
        }
        if (TrapNetCounter == 0) {
          xTaskGetTickCount();
        }
        else {
          xTaskGetTickCountFromISR();
        }
        iVar3 = 0;
        uVar5 = 0x52;
        puVar4 = &DAT_23072bcc;
        format = 
        "[%10u][%s: %s:%4d] kvbin set/get %ld byte , res1 = %ld, res2 = %d. memcmp error\r\n";
        sVar6 = __n;
      }
      else {
        if (TrapNetCounter == 0) {
          xTaskGetTickCount();
        }
        else {
          xTaskGetTickCountFromISR();
        }
        uVar5 = 0x4d;
        puVar4 = &DAT_23081ce8;
        format = "[%10u][%s: %s:%4d] kvbin set/get %ld byte error, res1 = %ld, res2 = %d.\r\n";
      }
      bl_printk(format,puVar4,"easyflash_cli.c",uVar5,sVar6,iVar3,__n);
LAB_2302e4c6:
      vPortFree(__s);
    }
    if (__s_00 != (void *)0x0) {
      vPortFree(__s_00);
    }
    psVar1 = psVar1 + 1;
    if (psVar1 == asStack64) {
      ef_del_env("1234567890123456789012345678901234567890123456789012345678901234");
      return;
    }
  } while( true );
}



EfErrCode psm_erase_cmd(void)

{
  uint uVar1;
  uint32_t addr;
  EfErrCode EVar2;
  undefined3 extraout_var;
  size_t len;
  ef_env *peVar3;
  sector_meta_data sStack56;
  
  if (default_env_set == (ef_env *)0x0) {
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x621,
                 "(%s) has assert failed at %s.\r\n","default_env_set","ef_env_set_default");
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  if (default_env_set_size == 0) {
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x622,
                 "(%s) has assert failed at %s.\r\n","default_env_set_size","ef_env_set_default");
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  ef_port_env_lock();
  addr = env_start_addr;
  while (addr < env_start_addr + 0x8000) {
    EVar2 = format_sector(addr);
    if (CONCAT31(extraout_var,EVar2) != 0) goto __exit;
    addr = addr + 0x1000;
  }
  uVar1 = 0;
  while (uVar1 < default_env_set_size) {
    len = default_env_set[uVar1].value_len;
    if (len == 0) {
      len = strlen((char *)default_env_set[uVar1].value);
    }
    sStack56.empty_env = 0xffffffff;
    peVar3 = default_env_set + uVar1;
    uVar1 = uVar1 + 1;
    create_env_blob((sector_meta_data_t)&sStack56,peVar3->key,peVar3->value,len);
  }
  EVar2 = EF_NO_ERR;
__exit:
  ef_port_env_unlock();
  return EVar2;
}



void psm_dump_cmd(void)

{
  int iStack108;
  env_node_obj eStack104;
  
  iStack108 = 0;
  if (init_ok == false) {
    ef_log_info("ENV isn\'t initialize OK.\r\n");
  }
  else {
    ef_port_env_lock();
    env_iterator((env_node_obj_t)&eStack104,&iStack108,(void *)0x0,print_env_cb);
    ef_print("\r\nmode: next generation\r\n");
    ef_print("size: %lu/%lu bytes.\r\n",iStack108 + 0x8c,0x7000);
    ef_port_env_unlock();
  }
  return;
}



void psm_unset_cmd(char *buf,int len,int argc,char **argv)

{
  if (argc != 2) {
    printf("usage: psm_unset [key]\r\n");
    return;
  }
  ef_del_env(argv[1]);
  ef_save_env();
  return;
}



void psm_set_cmd(char *buf,int len,int argc,char **argv)

{
  if (argc != 3) {
    printf("usage: psm_set [key] [value]\r\n");
    return;
  }
  ef_set_env(argv[1],argv[2]);
  ef_save_env();
  return;
}



int easyflash_cli_init(void)

{
  return 0;
}



// WARNING: Removing unreachable block (ram,0x2302e680)
// WARNING: Removing unreachable block (ram,0x2302e696)

EventGroupHandle_t xEventGroupCreateStatic(StaticEventGroup_t *pxEventGroupBuffer)

{
  size_t xSize;
  
  if (pxEventGroupBuffer == (StaticEventGroup_t *)0x0) {
    vAssertCalled();
  }
  else {
    pxEventGroupBuffer->xDummy1 = 0;
    vListInitialise((List_t *)&pxEventGroupBuffer->xDummy2);
    pxEventGroupBuffer->ucDummy4 = '\x01';
  }
  return (EventGroupHandle_t)pxEventGroupBuffer;
}



EventBits_t
xEventGroupWaitBits(EventGroupHandle_t xEventGroup,EventBits_t uxBitsToWaitFor,
                   BaseType_t xClearOnExit,BaseType_t xWaitForAllBits,TickType_t xTicksToWait)

{
  uint uVar1;
  BaseType_t BVar2;
  uint uVar3;
  
  if (xEventGroup == (EventGroupHandle_t)0x0) {
    vAssertCalled();
  }
  if (((uxBitsToWaitFor & 0xff000000) == 0) && (uxBitsToWaitFor != 0)) {
    BVar2 = xTaskGetSchedulerState();
    if (BVar2 != 0) goto LAB_2302e6c8;
LAB_2302e748:
    if (xTicksToWait == 0) goto LAB_2302e6c8;
    vAssertCalled();
    vTaskSuspendAll();
    uVar1 = xEventGroup->uxEventBits;
    uVar3 = uxBitsToWaitFor & uVar1;
    if (xWaitForAllBits != 0) goto LAB_2302e70c;
LAB_2302e6d8:
    if (uVar3 == 0) {
LAB_2302e710:
      if (xTicksToWait == 0) goto LAB_2302e762;
      uVar1 = (uint)(xClearOnExit != 0) << 0x18;
      if (xWaitForAllBits != 0) {
        uVar1 = uVar1 | 0x4000000;
      }
      vTaskPlaceOnUnorderedEventList
                (&xEventGroup->xTasksWaitingForBits,uVar1 | uxBitsToWaitFor,xTicksToWait);
      BVar2 = xTaskResumeAll();
      if (BVar2 == 0) {
        ecall();
      }
      uVar1 = uxTaskResetEventItemValue();
      if ((int)(uVar1 << 6) < 0) goto LAB_2302e740;
      vTaskEnterCritical();
      uVar1 = xEventGroup->uxEventBits;
      if (xWaitForAllBits == 0) {
        if ((uxBitsToWaitFor & uVar1) != 0) {
LAB_2302e788:
          if (xClearOnExit != 0) {
            xEventGroup->uxEventBits = ~uxBitsToWaitFor & uVar1;
          }
        }
      }
      else {
        if (uxBitsToWaitFor == (uxBitsToWaitFor & uVar1)) goto LAB_2302e788;
      }
      vTaskExitCritical();
LAB_2302e740:
      return uVar1 & 0xffffff;
    }
  }
  else {
    vAssertCalled();
    BVar2 = xTaskGetSchedulerState();
    if (BVar2 == 0) goto LAB_2302e748;
LAB_2302e6c8:
    vTaskSuspendAll();
    uVar1 = xEventGroup->uxEventBits;
    uVar3 = uxBitsToWaitFor & uVar1;
    if (xWaitForAllBits == 0) goto LAB_2302e6d8;
LAB_2302e70c:
    if (uxBitsToWaitFor != uVar3) goto LAB_2302e710;
  }
  if (xClearOnExit != 0) {
    xEventGroup->uxEventBits = ~uxBitsToWaitFor & uVar1;
    xTaskResumeAll();
    return uVar1;
  }
LAB_2302e762:
  xTaskResumeAll();
  return uVar1;
}



EventBits_t xEventGroupSetBits(EventGroupHandle_t xEventGroup,EventBits_t uxBitsToSet)

{
  xLIST_ITEM *pxEventListItem;
  xLIST_ITEM *pxVar1;
  uint uVar2;
  uint uVar3;
  xLIST_ITEM *pxVar4;
  uint uVar5;
  
  if (xEventGroup == (EventGroupHandle_t)0x0) {
    vAssertCalled();
  }
  if ((uxBitsToSet & 0xff000000) != 0) {
    vAssertCalled();
  }
  vTaskSuspendAll();
  pxEventListItem = (xEventGroup->xTasksWaitingForBits).xListEnd.pxNext;
  pxVar4 = (xLIST_ITEM *)&(xEventGroup->xTasksWaitingForBits).xListEnd;
  uxBitsToSet = uxBitsToSet | xEventGroup->uxEventBits;
  xEventGroup->uxEventBits = uxBitsToSet;
  if (pxVar4 != pxEventListItem) {
    uVar5 = 0;
    do {
      while( true ) {
        uVar3 = ((ListItem_t *)pxEventListItem)->xItemValue;
        uVar2 = uVar3 & 0xffffff;
        pxVar1 = ((ListItem_t *)pxEventListItem)->pxNext;
        if ((int)(uVar3 << 5) < 0) break;
        if ((uVar2 & uxBitsToSet) != 0) {
LAB_2302e806:
          if ((int)(uVar3 << 7) < 0) {
            uVar5 = uVar5 | uVar2;
          }
          vTaskRemoveFromUnorderedEventList((ListItem_t *)pxEventListItem,uxBitsToSet | 0x2000000);
          uxBitsToSet = xEventGroup->uxEventBits;
        }
        pxEventListItem = pxVar1;
        if (pxVar4 == pxVar1) goto LAB_2302e81c;
      }
      if (uVar2 == (uVar2 & uxBitsToSet)) goto LAB_2302e806;
      pxEventListItem = pxVar1;
    } while (pxVar4 != pxVar1);
LAB_2302e81c:
    uxBitsToSet = uxBitsToSet & ~uVar5;
  }
  xEventGroup->uxEventBits = uxBitsToSet;
  xTaskResumeAll();
  return xEventGroup->uxEventBits;
}



void vEventGroupDelete(EventGroupHandle_t xEventGroup)

{
  ListItem_t *pxEventListItem;
  UBaseType_t UVar1;
  
  vTaskSuspendAll();
  UVar1 = (xEventGroup->xTasksWaitingForBits).uxNumberOfItems;
  while (UVar1 != 0) {
    while (pxEventListItem = (ListItem_t *)(xEventGroup->xTasksWaitingForBits).xListEnd.pxNext,
          pxEventListItem != (ListItem_t *)&(xEventGroup->xTasksWaitingForBits).xListEnd) {
      vTaskRemoveFromUnorderedEventList(pxEventListItem,0x2000000);
      if ((xEventGroup->xTasksWaitingForBits).uxNumberOfItems == 0) goto LAB_2302e890;
    }
    vAssertCalled();
    vTaskRemoveFromUnorderedEventList
              ((ListItem_t *)(xEventGroup->xTasksWaitingForBits).xListEnd.pxNext,0x2000000);
    UVar1 = (xEventGroup->xTasksWaitingForBits).uxNumberOfItems;
  }
LAB_2302e890:
  if (xEventGroup->ucStaticallyAllocated != '\0') {
    xTaskResumeAll();
    return;
  }
  vPortFree(xEventGroup);
  xTaskResumeAll();
  return;
}



void vListInitialise(List_t *pxList)

{
  ListItem_t *pLVar1;
  
  pLVar1 = (ListItem_t *)&pxList->xListEnd;
  pxList->pxIndex = pLVar1;
  (pxList->xListEnd).xItemValue = 0xffffffff;
  *(ListItem_t **)&(pxList->xListEnd).pxNext = pLVar1;
  *(ListItem_t **)&(pxList->xListEnd).pxPrevious = pLVar1;
  pxList->uxNumberOfItems = 0;
  return;
}



void vListInitialiseItem(ListItem_t *pxItem)

{
  pxItem->pvContainer = (xLIST *)0x0;
  return;
}



void vListInsertEnd(List_t *pxList,ListItem_t *pxNewListItem)

{
  xLIST_ITEM *pxVar1;
  ListItem_t *pLVar2;
  
  pLVar2 = pxList->pxIndex;
  *(ListItem_t **)&pxNewListItem->pxNext = pLVar2;
  pxVar1 = pLVar2->pxPrevious;
  pxNewListItem->pxPrevious = pxVar1;
  *(ListItem_t **)&pxVar1->pxNext = pxNewListItem;
  *(ListItem_t **)&pLVar2->pxPrevious = pxNewListItem;
  *(List_t **)&pxNewListItem->pvContainer = pxList;
  pxList->uxNumberOfItems = pxList->uxNumberOfItems + 1;
  return;
}



void vListInsert(List_t *pxList,ListItem_t *pxNewListItem)

{
  xLIST_ITEM *pxVar1;
  xLIST_ITEM *pxVar2;
  
  pxVar2 = (xLIST_ITEM *)&pxList->xListEnd;
  if (pxNewListItem->xItemValue == 0xffffffff) {
    pxVar1 = (pxList->xListEnd).pxPrevious;
    pxVar2 = pxVar1->pxNext;
  }
  else {
    do {
      pxVar1 = pxVar2;
      pxVar2 = pxVar1->pxNext;
    } while (pxVar2->xItemValue <= pxNewListItem->xItemValue);
  }
  pxNewListItem->pxNext = pxVar2;
  *(ListItem_t **)&pxVar2->pxPrevious = pxNewListItem;
  pxNewListItem->pxPrevious = pxVar1;
  *(ListItem_t **)&pxVar1->pxNext = pxNewListItem;
  *(List_t **)&pxNewListItem->pvContainer = pxList;
  pxList->uxNumberOfItems = pxList->uxNumberOfItems + 1;
  return;
}



UBaseType_t uxListRemove(ListItem_t *pxItemToRemove)

{
  xLIST_ITEM *pxVar1;
  xLIST *pxVar2;
  
  pxVar1 = pxItemToRemove->pxPrevious;
  pxVar2 = pxItemToRemove->pvContainer;
  pxItemToRemove->pxNext->pxPrevious = pxVar1;
  pxVar1->pxNext = pxItemToRemove->pxNext;
  if (pxVar2->pxIndex != pxItemToRemove) {
    pxItemToRemove->pvContainer = (xLIST *)0x0;
    pxVar2->uxNumberOfItems = pxVar2->uxNumberOfItems - 1;
    return pxVar2->uxNumberOfItems;
  }
  pxVar2->pxIndex = (ListItem_t *)pxItemToRemove->pxPrevious;
  pxItemToRemove->pvContainer = (xLIST *)0x0;
  pxVar2->uxNumberOfItems = pxVar2->uxNumberOfItems - 1;
  return pxVar2->uxNumberOfItems;
}



BaseType_t prvCopyDataToQueue(Queue_t *pxQueue,void *pvItemToQueue,BaseType_t xPosition)

{
  UBaseType_t UVar1;
  BaseType_t BVar2;
  UBaseType_t UVar3;
  size_t __n;
  int8_t *piVar4;
  int8_t *piVar5;
  
  __n = pxQueue->uxItemSize;
  UVar1 = pxQueue->uxMessagesWaiting;
  if (__n == 0) {
    UVar1 = UVar1 + 1;
    BVar2 = 0;
    if (pxQueue->pcHead == (int8_t *)0x0) {
      BVar2 = xTaskPriorityDisinherit(*(TaskHandle_t *)&pxQueue->u);
      *(undefined4 *)&pxQueue->u = 0;
    }
  }
  else {
    if (xPosition == 0) {
      UVar1 = UVar1 + 1;
      memcpy(pxQueue->pcWriteTo,pvItemToQueue,__n);
      piVar4 = pxQueue->pcWriteTo;
      BVar2 = 0;
      pxQueue->pcWriteTo = piVar4 + pxQueue->uxItemSize;
      if (*(int8_t **)&pxQueue->u <= piVar4 + pxQueue->uxItemSize) {
        pxQueue->uxMessagesWaiting = UVar1;
        pxQueue->pcWriteTo = pxQueue->pcHead;
        return 0;
      }
    }
    else {
      memcpy(*(void **)((int)&pxQueue->u + 4),pvItemToQueue,__n);
      UVar3 = pxQueue->uxItemSize;
      piVar4 = pxQueue->pcHead;
      piVar5 = (int8_t *)(*(int *)((int)&pxQueue->u + 4) + -UVar3);
      *(int8_t **)((int)&pxQueue->u + 4) = piVar5;
      if (piVar5 < piVar4) {
        *(int *)((int)&pxQueue->u + 4) = -UVar3 + *(int *)&pxQueue->u;
      }
      if (xPosition != 2) {
        pxQueue->uxMessagesWaiting = UVar1 + 1;
        return 0;
      }
      BVar2 = 0;
      if (UVar1 == 0) {
        UVar1 = 1;
      }
    }
  }
  pxQueue->uxMessagesWaiting = UVar1;
  return BVar2;
}



void prvCopyDataFromQueue(Queue_t *pxQueue,void *pvBuffer)

{
  int8_t *__src;
  size_t __n;
  int8_t *piVar1;
  
  __n = pxQueue->uxItemSize;
  if (__n != 0) {
    piVar1 = *(int8_t **)&pxQueue->u;
    __src = (int8_t *)(*(int *)((int)&pxQueue->u + 4) + __n);
    *(int8_t **)((int)&pxQueue->u + 4) = __src;
    if (piVar1 <= __src) {
      __src = pxQueue->pcHead;
      *(int8_t **)((int)&pxQueue->u + 4) = __src;
    }
    memcpy(pvBuffer,__src,__n);
    return;
  }
  return;
}



void prvUnlockQueue(Queue_t *pxQueue)

{
  char cVar1;
  int iVar2;
  BaseType_t BVar3;
  uint uVar4;
  
  vTaskEnterCritical();
  iVar2 = (int)pxQueue->cTxLock;
  if ((0 < iVar2) && ((pxQueue->xTasksWaitingToReceive).uxNumberOfItems != 0)) {
    do {
      BVar3 = xTaskRemoveFromEventList(&pxQueue->xTasksWaitingToReceive);
      if (BVar3 == 0) {
        uVar4 = iVar2 - 1U & 0xff;
        cVar1 = (char)uVar4;
      }
      else {
        vTaskMissedYield();
        uVar4 = iVar2 - 1U & 0xff;
        cVar1 = (char)uVar4;
      }
    } while ((uVar4 != 0) &&
            (iVar2 = (int)cVar1, (pxQueue->xTasksWaitingToReceive).uxNumberOfItems != 0));
  }
  pxQueue->cTxLock = -1;
  vTaskExitCritical();
  vTaskEnterCritical();
  iVar2 = (int)pxQueue->cRxLock;
  if ((0 < iVar2) && ((pxQueue->xTasksWaitingToSend).uxNumberOfItems != 0)) {
    do {
      BVar3 = xTaskRemoveFromEventList(&pxQueue->xTasksWaitingToSend);
      if (BVar3 == 0) {
        uVar4 = iVar2 - 1U & 0xff;
        cVar1 = (char)uVar4;
      }
      else {
        vTaskMissedYield();
        uVar4 = iVar2 - 1U & 0xff;
        cVar1 = (char)uVar4;
      }
    } while ((uVar4 != 0) &&
            (iVar2 = (int)cVar1, (pxQueue->xTasksWaitingToSend).uxNumberOfItems != 0));
  }
  pxQueue->cRxLock = -1;
  vTaskExitCritical();
  return;
}



BaseType_t xQueueGenericReset(QueueHandle_t xQueue,BaseType_t xNewQueue)

{
  BaseType_t BVar1;
  int8_t *piVar2;
  int iVar3;
  
  if (xQueue == (QueueHandle_t)0x0) {
    vAssertCalled();
  }
  vTaskEnterCritical();
  piVar2 = xQueue->pcHead;
  xQueue->uxMessagesWaiting = 0;
  iVar3 = xQueue->uxItemSize * xQueue->uxLength;
  xQueue->cRxLock = -1;
  xQueue->pcWriteTo = piVar2;
  xQueue->cTxLock = -1;
  *(int8_t **)&xQueue->u = piVar2 + iVar3;
  *(int8_t **)((int)&xQueue->u + 4) = piVar2 + (iVar3 - xQueue->uxItemSize);
  if (xNewQueue == 0) {
    if (((xQueue->xTasksWaitingToSend).uxNumberOfItems != 0) &&
       (BVar1 = xTaskRemoveFromEventList(&xQueue->xTasksWaitingToSend), BVar1 != 0)) {
      ecall();
      vTaskExitCritical();
      return 1;
    }
    vTaskExitCritical();
    return 1;
  }
  vListInitialise(&xQueue->xTasksWaitingToSend);
  vListInitialise(&xQueue->xTasksWaitingToReceive);
  vTaskExitCritical();
  return 1;
}



// WARNING: Removing unreachable block (ram,0x2302eb7e)

QueueHandle_t
xQueueGenericCreateStatic
          (UBaseType_t uxQueueLength,UBaseType_t uxItemSize,uint8_t *pucQueueStorage,
          StaticQueue_t *pxStaticQueue,uint8_t ucQueueType)

{
  size_t xSize;
  
  if (uxQueueLength == 0) {
    vAssertCalled();
  }
  if (pxStaticQueue == (StaticQueue_t *)0x0) {
    vAssertCalled();
  }
  if (pucQueueStorage == (uint8_t *)0x0) {
    if (uxItemSize == 0) goto LAB_2302eb82;
  }
  else {
    if (uxItemSize != 0) goto LAB_2302eb82;
  }
  vAssertCalled();
LAB_2302eb82:
  if (pxStaticQueue != (StaticQueue_t *)0x0) {
    pxStaticQueue->ucDummy6 = '\x01';
    if (uxItemSize == 0) {
      pucQueueStorage = (uint8_t *)pxStaticQueue;
    }
    *(uint8_t **)pxStaticQueue->pvDummy1 = pucQueueStorage;
    pxStaticQueue->uxDummy4[1] = uxQueueLength;
    pxStaticQueue->uxDummy4[2] = uxItemSize;
    xQueueGenericReset((QueueHandle_t)pxStaticQueue,1);
    pxStaticQueue->ucDummy9 = ucQueueType;
  }
  return (QueueHandle_t)pxStaticQueue;
}



QueueHandle_t
xQueueGenericCreate(UBaseType_t uxQueueLength,UBaseType_t uxItemSize,uint8_t ucQueueType)

{
  QueueHandle_t xQueue;
  
  if (uxQueueLength == 0) {
    vAssertCalled();
  }
  if (uxItemSize == 0) {
    xQueue = (QueueHandle_t)pvPortMalloc(0x50);
    if (xQueue == (QueueHandle_t)0x0) {
      return (QueueHandle_t)0x0;
    }
    xQueue->ucStaticallyAllocated = '\0';
    *(QueueHandle_t *)&xQueue->pcHead = xQueue;
  }
  else {
    xQueue = (QueueHandle_t)pvPortMalloc(uxQueueLength * uxItemSize + 0x50);
    if (xQueue == (QueueHandle_t)0x0) {
      return (QueueHandle_t)0x0;
    }
    xQueue->ucStaticallyAllocated = '\0';
    *(QueueHandle_t *)&xQueue->pcHead = xQueue + 1;
  }
  xQueue->uxLength = uxQueueLength;
  xQueue->uxItemSize = uxItemSize;
  xQueueGenericReset(xQueue,1);
  xQueue->ucQueueType = ucQueueType;
  return xQueue;
}



QueueHandle_t xQueueCreateCountingSemaphore(UBaseType_t uxMaxCount,UBaseType_t uxInitialCount)

{
  bool bVar1;
  QueueHandle_t pQVar2;
  
  if (uxMaxCount == 0) {
    vAssertCalled();
    bVar1 = uxInitialCount == 0;
  }
  else {
    bVar1 = uxInitialCount <= uxMaxCount;
  }
  if (!bVar1) {
    vAssertCalled();
  }
  pQVar2 = xQueueGenericCreate(uxMaxCount,0,'\x02');
  if (pQVar2 != (QueueHandle_t)0x0) {
    pQVar2->uxMessagesWaiting = uxInitialCount;
  }
  return pQVar2;
}



// WARNING: Variable defined which should be unmapped: xTimeOut

BaseType_t
xQueueGenericSend(QueueHandle_t xQueue,void *pvItemToQueue,TickType_t xTicksToWait,
                 BaseType_t xCopyPosition)

{
  bool bVar1;
  BaseType_t BVar2;
  int iVar3;
  TickType_t local_34 [3];
  undefined auStack40 [4];
  TimeOut_t xTimeOut;
  
  local_34[0] = xTicksToWait;
  if (xQueue == (QueueHandle_t)0x0) {
    vAssertCalled();
  }
  if ((pvItemToQueue == (void *)0x0) && (xQueue->uxItemSize != 0)) {
    vAssertCalled();
  }
  if ((xCopyPosition == 2) && (xQueue->uxLength != 1)) {
    vAssertCalled();
  }
  BVar2 = xTaskGetSchedulerState();
  if ((BVar2 == 0) && (local_34[0] != 0)) {
    vAssertCalled();
  }
  vTaskEnterCritical();
  bVar1 = false;
  if (xQueue->uxLength <= xQueue->uxMessagesWaiting) {
    do {
      if (xCopyPosition == 2) break;
      if (local_34[0] == 0) {
        vTaskExitCritical();
        return 0;
      }
      if (!bVar1) {
        vTaskInternalSetTimeOutState((TimeOut_t *)auStack40);
      }
      vTaskExitCritical();
      vTaskSuspendAll();
      vTaskEnterCritical();
      if (xQueue->cRxLock == -1) {
        xQueue->cRxLock = '\0';
      }
      if (xQueue->cTxLock == -1) {
        xQueue->cTxLock = '\0';
      }
      vTaskExitCritical();
      BVar2 = xTaskCheckForTimeOut((TimeOut_t *)auStack40,local_34);
      if (BVar2 != 0) {
        prvUnlockQueue((Queue_t *)xQueue);
        xTaskResumeAll();
        return 0;
      }
      vTaskEnterCritical();
      if (xQueue->uxMessagesWaiting == xQueue->uxLength) {
        vTaskExitCritical();
        vTaskPlaceOnEventList(&xQueue->xTasksWaitingToSend,local_34[0]);
        prvUnlockQueue((Queue_t *)xQueue);
        BVar2 = xTaskResumeAll();
        if (BVar2 == 0) {
          ecall();
        }
      }
      else {
        vTaskExitCritical();
        prvUnlockQueue((Queue_t *)xQueue);
        xTaskResumeAll();
      }
      bVar1 = true;
      vTaskEnterCritical();
    } while (xQueue->uxLength <= xQueue->uxMessagesWaiting);
  }
  iVar3 = prvCopyDataToQueue((Queue_t *)xQueue,pvItemToQueue,xCopyPosition);
  if ((xQueue->xTasksWaitingToReceive).uxNumberOfItems != 0) {
    iVar3 = xTaskRemoveFromEventList(&xQueue->xTasksWaitingToReceive);
  }
  if (iVar3 != 0) {
    ecall();
  }
  vTaskExitCritical();
  return 1;
}



QueueHandle_t xQueueCreateMutexStatic(uint8_t ucQueueType,StaticQueue_t *pxStaticQueue)

{
  QueueHandle_t xQueue;
  
  xQueue = xQueueGenericCreateStatic(1,0,(uint8_t *)0x0,pxStaticQueue,ucQueueType);
  if (xQueue != (QueueHandle_t)0x0) {
    *(undefined4 *)&xQueue->u = 0;
    xQueue->pcHead = (int8_t *)0x0;
    *(undefined4 *)((int)&xQueue->u + 4) = 0;
    xQueueGenericSend(xQueue,(void *)0x0,0,0);
  }
  return xQueue;
}



BaseType_t xQueueGiveMutexRecursive(QueueHandle_t xMutex)

{
  BaseType_t BVar1;
  TaskHandle_t ptVar2;
  int iVar3;
  TaskHandle_t ptVar4;
  
  if (xMutex == (QueueHandle_t)0x0) {
    vAssertCalled();
  }
  ptVar4 = *(TaskHandle_t *)&xMutex->u;
  ptVar2 = xTaskGetCurrentTaskHandle();
  BVar1 = 0;
  if (ptVar4 == ptVar2) {
    iVar3 = *(int *)((int)&xMutex->u + 4) + -1;
    *(int *)((int)&xMutex->u + 4) = iVar3;
    BVar1 = 1;
    if (iVar3 == 0) {
      xQueueGenericSend(xMutex,(void *)0x0,0,0);
      BVar1 = 1;
    }
  }
  return BVar1;
}



QueueHandle_t xQueueCreateMutex(uint8_t ucQueueType)

{
  QueueHandle_t xQueue;
  
  xQueue = xQueueGenericCreate(1,0,ucQueueType);
  if (xQueue != (QueueHandle_t)0x0) {
    *(undefined4 *)&xQueue->u = 0;
    xQueue->pcHead = (int8_t *)0x0;
    *(undefined4 *)((int)&xQueue->u + 4) = 0;
    xQueueGenericSend(xQueue,(void *)0x0,0,0);
  }
  return xQueue;
}



BaseType_t
xQueueGenericSendFromISR
          (QueueHandle_t xQueue,void *pvItemToQueue,BaseType_t *pxHigherPriorityTaskWoken,
          BaseType_t xCopyPosition)

{
  byte bVar1;
  BaseType_t BVar2;
  
  if (xQueue == (QueueHandle_t)0x0) {
    vAssertCalled();
  }
  if ((pvItemToQueue == (void *)0x0) && (xQueue->uxItemSize != 0)) {
    vAssertCalled();
  }
  if (xCopyPosition == 2) {
    if (xQueue->uxLength != 1) {
      vAssertCalled();
    }
  }
  else {
    if (xQueue->uxLength <= xQueue->uxMessagesWaiting) {
      return 0;
    }
  }
  bVar1 = xQueue->cTxLock;
  prvCopyDataToQueue((Queue_t *)xQueue,pvItemToQueue,xCopyPosition);
  if (bVar1 == 0xff) {
    if ((((xQueue->xTasksWaitingToReceive).uxNumberOfItems != 0) &&
        (BVar2 = xTaskRemoveFromEventList(&xQueue->xTasksWaitingToReceive), BVar2 != 0)) &&
       (pxHigherPriorityTaskWoken != (BaseType_t *)0x0)) {
      *pxHigherPriorityTaskWoken = 1;
    }
    return 1;
  }
  xQueue->cTxLock = (int8_t)(((uint)bVar1 + 1) * 0x1000000 >> 0x18);
  return 1;
}



BaseType_t xQueueGiveFromISR(QueueHandle_t xQueue,BaseType_t *pxHigherPriorityTaskWoken)

{
  BaseType_t BVar1;
  int8_t *piVar2;
  
  if (xQueue == (QueueHandle_t)0x0) {
    vAssertCalled();
  }
  if (xQueue->uxItemSize == 0) {
    piVar2 = xQueue->pcHead;
  }
  else {
    vAssertCalled();
    piVar2 = xQueue->pcHead;
  }
  if ((piVar2 == (int8_t *)0x0) && (*(int *)&xQueue->u != 0)) {
    vAssertCalled();
  }
  BVar1 = 0;
  if (xQueue->uxMessagesWaiting < xQueue->uxLength) {
    xQueue->uxMessagesWaiting = xQueue->uxMessagesWaiting + 1;
    if (xQueue->cTxLock == 0xff) {
      if ((((xQueue->xTasksWaitingToReceive).uxNumberOfItems != 0) &&
          (BVar1 = xTaskRemoveFromEventList(&xQueue->xTasksWaitingToReceive), BVar1 != 0)) &&
         (pxHigherPriorityTaskWoken != (BaseType_t *)0x0)) {
        *pxHigherPriorityTaskWoken = 1;
        return 1;
      }
    }
    else {
      xQueue->cTxLock = (int8_t)(((uint)(byte)xQueue->cTxLock + 1) * 0x1000000 >> 0x18);
    }
    BVar1 = 1;
  }
  return BVar1;
}



BaseType_t xQueueReceive(QueueHandle_t xQueue,void *pvBuffer,TickType_t xTicksToWait)

{
  BaseType_t BVar1;
  UBaseType_t UVar2;
  TickType_t local_34 [3];
  undefined auStack40 [4];
  TimeOut_t xTimeOut;
  
  local_34[0] = xTicksToWait;
  if (xQueue == (QueueHandle_t)0x0) {
    vAssertCalled();
  }
  if ((pvBuffer == (void *)0x0) && (xQueue->uxItemSize != 0)) {
    vAssertCalled();
  }
  BVar1 = xTaskGetSchedulerState();
  if ((BVar1 == 0) && (local_34[0] != 0)) {
    vAssertCalled();
  }
  vTaskEnterCritical();
  UVar2 = xQueue->uxMessagesWaiting;
  if (UVar2 != 0) {
LAB_2302f0a0:
    prvCopyDataFromQueue((Queue_t *)xQueue,pvBuffer);
    xQueue->uxMessagesWaiting = UVar2 - 1;
    if (((xQueue->xTasksWaitingToSend).uxNumberOfItems != 0) &&
       (BVar1 = xTaskRemoveFromEventList(&xQueue->xTasksWaitingToSend), BVar1 != 0)) {
      ecall();
    }
    vTaskExitCritical();
    return 1;
  }
  if (local_34[0] != 0) {
    vTaskInternalSetTimeOutState((TimeOut_t *)auStack40);
    do {
      vTaskExitCritical();
      vTaskSuspendAll();
      vTaskEnterCritical();
      if (xQueue->cRxLock == -1) {
        xQueue->cRxLock = '\0';
      }
      if (xQueue->cTxLock == -1) {
        xQueue->cTxLock = '\0';
      }
      vTaskExitCritical();
      BVar1 = xTaskCheckForTimeOut((TimeOut_t *)auStack40,local_34);
      if (BVar1 == 0) {
        vTaskEnterCritical();
        if (xQueue->uxMessagesWaiting == 0) {
          vTaskExitCritical();
          vTaskPlaceOnEventList(&xQueue->xTasksWaitingToReceive,local_34[0]);
          prvUnlockQueue((Queue_t *)xQueue);
          BVar1 = xTaskResumeAll();
          if (BVar1 == 0) {
            ecall();
          }
          goto LAB_2302f094;
        }
        vTaskExitCritical();
        prvUnlockQueue((Queue_t *)xQueue);
        xTaskResumeAll();
        vTaskEnterCritical();
        UVar2 = xQueue->uxMessagesWaiting;
      }
      else {
        prvUnlockQueue((Queue_t *)xQueue);
        xTaskResumeAll();
        vTaskEnterCritical();
        if (xQueue->uxMessagesWaiting == 0) break;
        vTaskExitCritical();
LAB_2302f094:
        vTaskEnterCritical();
        UVar2 = xQueue->uxMessagesWaiting;
      }
      if (UVar2 != 0) goto LAB_2302f0a0;
    } while (local_34[0] != 0);
  }
  vTaskExitCritical();
  return 0;
}



// WARNING: Type propagation algorithm not settling

BaseType_t xQueueSemaphoreTake(QueueHandle_t xQueue,TickType_t xTicksToWait)

{
  bool bVar1;
  BaseType_t BVar2;
  TaskHandle_t ptVar3;
  UBaseType_t uxHighestPriorityWaitingTask;
  int iVar4;
  TickType_t local_34 [3];
  undefined auStack40 [4];
  TimeOut_t xTimeOut;
  
  local_34[0] = xTicksToWait;
  if (xQueue == (QueueHandle_t)0x0) {
    vAssertCalled();
  }
  if (xQueue->uxItemSize != 0) {
    vAssertCalled();
  }
  BVar2 = xTaskGetSchedulerState();
  if ((BVar2 == 0) && (local_34[0] != 0)) {
    vAssertCalled();
  }
  vTaskEnterCritical();
  uxHighestPriorityWaitingTask = xQueue->uxMessagesWaiting;
  iVar4 = 0;
  bVar1 = false;
  while( true ) {
    if (uxHighestPriorityWaitingTask != 0) {
      xQueue->uxMessagesWaiting = uxHighestPriorityWaitingTask - 1;
      if (xQueue->pcHead == (int8_t *)0x0) {
        ptVar3 = pvTaskIncrementMutexHeldCount();
        *(TaskHandle_t *)&xQueue->u = ptVar3;
      }
      if (((xQueue->xTasksWaitingToSend).uxNumberOfItems != 0) &&
         (BVar2 = xTaskRemoveFromEventList(&xQueue->xTasksWaitingToSend), BVar2 != 0)) {
        ecall();
      }
      vTaskExitCritical();
      return 1;
    }
    if (local_34[0] == 0) break;
    if (!bVar1) {
      vTaskInternalSetTimeOutState((TimeOut_t *)auStack40);
    }
    vTaskExitCritical();
    vTaskSuspendAll();
    vTaskEnterCritical();
    if (xQueue->cRxLock == -1) {
      xQueue->cRxLock = '\0';
    }
    if (xQueue->cTxLock == -1) {
      xQueue->cTxLock = '\0';
    }
    vTaskExitCritical();
    BVar2 = xTaskCheckForTimeOut((TimeOut_t *)auStack40,local_34);
    if (BVar2 == 0) {
      vTaskEnterCritical();
      if (xQueue->uxMessagesWaiting == 0) {
        vTaskExitCritical();
        if (xQueue->pcHead == (int8_t *)0x0) {
          vTaskEnterCritical();
          iVar4 = xTaskPriorityInherit(*(TaskHandle_t *)&xQueue->u);
          vTaskExitCritical();
        }
        vTaskPlaceOnEventList(&xQueue->xTasksWaitingToReceive,local_34[0]);
        prvUnlockQueue((Queue_t *)xQueue);
        BVar2 = xTaskResumeAll();
        if (BVar2 == 0) {
          ecall();
        }
      }
      else {
        vTaskExitCritical();
        prvUnlockQueue((Queue_t *)xQueue);
        xTaskResumeAll();
      }
    }
    else {
      prvUnlockQueue((Queue_t *)xQueue);
      xTaskResumeAll();
      vTaskEnterCritical();
      if (xQueue->uxMessagesWaiting == 0) {
        vTaskExitCritical();
        if (iVar4 == 0) {
          return 0;
        }
        vTaskEnterCritical();
        uxHighestPriorityWaitingTask = (xQueue->xTasksWaitingToReceive).uxNumberOfItems;
        if (uxHighestPriorityWaitingTask != 0) {
          uxHighestPriorityWaitingTask =
               0x20 - ((xQueue->xTasksWaitingToReceive).xListEnd.pxNext)->xItemValue;
        }
        vTaskPriorityDisinheritAfterTimeout
                  (*(TaskHandle_t *)&xQueue->u,uxHighestPriorityWaitingTask);
        vTaskExitCritical();
        return 0;
      }
      vTaskExitCritical();
    }
    bVar1 = true;
    vTaskEnterCritical();
    uxHighestPriorityWaitingTask = xQueue->uxMessagesWaiting;
  }
  if (iVar4 != 0) {
    vAssertCalled();
  }
  vTaskExitCritical();
  return 0;
}



BaseType_t xQueueTakeMutexRecursive(QueueHandle_t xMutex,TickType_t xTicksToWait)

{
  TaskHandle_t ptVar1;
  TaskHandle_t ptVar2;
  BaseType_t BVar3;
  
  if (xMutex == (QueueHandle_t)0x0) {
    vAssertCalled();
  }
  ptVar1 = *(TaskHandle_t *)&xMutex->u;
  ptVar2 = xTaskGetCurrentTaskHandle();
  if (ptVar1 != ptVar2) {
    BVar3 = xQueueSemaphoreTake(xMutex,xTicksToWait);
    if (BVar3 != 0) {
      *(int *)((int)&xMutex->u + 4) = *(int *)((int)&xMutex->u + 4) + 1;
    }
    return BVar3;
  }
  *(int *)((int)&xMutex->u + 4) = *(int *)((int)&xMutex->u + 4) + 1;
  return 1;
}



UBaseType_t uxQueueMessagesWaiting(QueueHandle_t xQueue)

{
  UBaseType_t UVar1;
  
  if (xQueue == (QueueHandle_t)0x0) {
    vAssertCalled();
  }
  vTaskEnterCritical();
  UVar1 = xQueue->uxMessagesWaiting;
  vTaskExitCritical();
  return UVar1;
}



void vQueueDelete(QueueHandle_t xQueue)

{
  QueueHandle_t *ppQVar1;
  int iVar2;
  QueueRegistryItem_t *pQVar3;
  
  if (xQueue == (QueueHandle_t)0x0) {
    vAssertCalled();
    iVar2 = 0;
    pQVar3 = xQueueRegistry;
    do {
      ppQVar1 = &pQVar3->xHandle;
      pQVar3 = pQVar3 + 1;
      if (*ppQVar1 == (QueueHandle_t)0x0) {
        xQueueRegistry[iVar2].pcQueueName = (char *)0x0;
        xQueueRegistry[iVar2].xHandle = (QueueHandle_t)0x0;
        break;
      }
      iVar2 = iVar2 + 1;
    } while (iVar2 != 8);
    if (cRam00000046 != '\0') {
      return;
    }
    vPortFree((void *)0x0);
    return;
  }
  iVar2 = 0;
  pQVar3 = xQueueRegistry;
  do {
    ppQVar1 = &pQVar3->xHandle;
    pQVar3 = pQVar3 + 1;
    if (xQueue == *ppQVar1) {
      xQueueRegistry[iVar2].pcQueueName = (char *)0x0;
      xQueueRegistry[iVar2].xHandle = (QueueHandle_t)0x0;
      break;
    }
    iVar2 = iVar2 + 1;
  } while (iVar2 != 8);
  if (xQueue->ucStaticallyAllocated != '\0') {
    return;
  }
  vPortFree(xQueue);
  return;
}



void vQueueAddToRegistry(QueueHandle_t xQueue,char *pcQueueName)

{
  char **ppcVar1;
  int iVar2;
  QueueRegistryItem_t *pQVar3;
  
  iVar2 = 0;
  pQVar3 = xQueueRegistry;
  do {
    ppcVar1 = &pQVar3->pcQueueName;
    pQVar3 = pQVar3 + 1;
    if (*ppcVar1 == (char *)0x0) {
      xQueueRegistry[iVar2].pcQueueName = pcQueueName;
      xQueueRegistry[iVar2].xHandle = xQueue;
      return;
    }
    iVar2 = iVar2 + 1;
  } while (iVar2 != 8);
  return;
}



void vQueueWaitForMessageRestricted
               (QueueHandle_t xQueue,TickType_t xTicksToWait,BaseType_t xWaitIndefinitely)

{
  vTaskEnterCritical();
  if (xQueue->cRxLock == -1) {
    xQueue->cRxLock = '\0';
  }
  if (xQueue->cTxLock == -1) {
    xQueue->cTxLock = '\0';
  }
  vTaskExitCritical();
  if (xQueue->uxMessagesWaiting != 0) {
    prvUnlockQueue((Queue_t *)xQueue);
    return;
  }
  vTaskPlaceOnEventListRestricted(&xQueue->xTasksWaitingToReceive,xTicksToWait,xWaitIndefinitely);
  prvUnlockQueue((Queue_t *)xQueue);
  return;
}



void prvInitialiseNewStreamBuffer
               (StreamBuffer_t *pxStreamBuffer,uint8_t *pucBuffer,size_t xBufferSizeBytes,
               size_t xTriggerLevelBytes,uint8_t ucFlags)

{
  uint8_t *puVar1;
  
  puVar1 = (uint8_t *)memset(pucBuffer,0x55,xBufferSizeBytes);
  if (pucBuffer != puVar1) {
    vAssertCalled();
  }
  memset(pxStreamBuffer,0,0x24);
  pxStreamBuffer->pucBuffer = pucBuffer;
  pxStreamBuffer->xLength = xBufferSizeBytes;
  pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
  pxStreamBuffer->ucFlags = ucFlags;
  return;
}



size_t prvWriteBytesToBuffer(StreamBuffer_t *pxStreamBuffer,uint8_t *pucData,size_t xCount)

{
  uint uVar1;
  uint __n;
  size_t __n_00;
  
  if (xCount == 0) {
    vAssertCalled();
    uVar1 = pxStreamBuffer->xHead;
    if (pxStreamBuffer->xLength < uVar1) {
      __n_00 = 0;
      goto LAB_2302f4f8;
    }
    memcpy(pxStreamBuffer->pucBuffer + uVar1,pucData,0);
    __n = pxStreamBuffer->xLength;
    if (uVar1 < __n) goto LAB_2302f4d6;
  }
  else {
    uVar1 = pxStreamBuffer->xHead;
    __n_00 = pxStreamBuffer->xLength - uVar1;
    if (xCount < __n_00) {
      __n = uVar1 + xCount;
      __n_00 = xCount;
    }
    else {
      __n = uVar1 + __n_00;
    }
    if (pxStreamBuffer->xLength < __n) {
LAB_2302f4f8:
      vAssertCalled();
    }
    memcpy(pxStreamBuffer->pucBuffer + uVar1,pucData,__n_00);
    if (__n_00 < xCount) {
      __n = xCount - __n_00;
      if (pxStreamBuffer->xLength < __n) {
        vAssertCalled();
        memcpy(pxStreamBuffer->pucBuffer,pucData + __n_00,__n);
      }
      else {
        memcpy(pxStreamBuffer->pucBuffer,pucData + __n_00,__n);
      }
    }
    __n = pxStreamBuffer->xLength;
    uVar1 = uVar1 + xCount;
    if (uVar1 < __n) goto LAB_2302f4d6;
  }
  uVar1 = uVar1 - __n;
LAB_2302f4d6:
  pxStreamBuffer->xHead = uVar1;
  return xCount;
}



size_t prvReadBytesFromBuffer
                 (StreamBuffer_t *pxStreamBuffer,uint8_t *pucData,size_t xMaxCount,
                 size_t xBytesAvailable)

{
  size_t sVar1;
  uint __n;
  
  if (xMaxCount <= xBytesAvailable) {
    xBytesAvailable = xMaxCount;
  }
  if (xBytesAvailable == 0) {
    return 0;
  }
  sVar1 = pxStreamBuffer->xTail;
  __n = pxStreamBuffer->xLength - sVar1;
  if (xBytesAvailable < __n) {
    __n = xBytesAvailable;
    if (xBytesAvailable <= xMaxCount) goto LAB_2302f566;
LAB_2302f5c0:
    vAssertCalled();
    if (sVar1 + __n <= pxStreamBuffer->xLength) goto LAB_2302f56e;
  }
  else {
    if (xMaxCount < __n) goto LAB_2302f5c0;
LAB_2302f566:
    if (sVar1 + __n <= pxStreamBuffer->xLength) goto LAB_2302f56e;
  }
  vAssertCalled();
LAB_2302f56e:
  memcpy(pucData,pxStreamBuffer->pucBuffer + sVar1,__n);
  if (__n < xBytesAvailable) {
    if (xMaxCount < xBytesAvailable) {
      vAssertCalled();
    }
    memcpy(pucData + __n,pxStreamBuffer->pucBuffer,xBytesAvailable - __n);
  }
  sVar1 = sVar1 + xBytesAvailable;
  if (pxStreamBuffer->xLength <= sVar1) {
    sVar1 = sVar1 - pxStreamBuffer->xLength;
  }
  pxStreamBuffer->xTail = sVar1;
  return xBytesAvailable;
}



StreamBufferHandle_t
xStreamBufferGenericCreate
          (size_t xBufferSizeBytes,size_t xTriggerLevelBytes,BaseType_t xIsMessageBuffer)

{
  uint8_t uVar1;
  StreamBuffer_t *pxStreamBuffer;
  uint8_t ucFlags;
  
  ucFlags = (uint8_t)xBufferSizeBytes;
  if (xIsMessageBuffer == 1) {
    uVar1 = '\x01';
    if (xBufferSizeBytes < 5) {
      vAssertCalled();
      uVar1 = '\x01';
    }
joined_r0x2302f64a:
    ucFlags = uVar1;
    if (xTriggerLevelBytes <= xBufferSizeBytes) goto joined_r0x2302f5f8;
  }
  else {
    uVar1 = '\0';
    if (xBufferSizeBytes != 0) goto joined_r0x2302f64a;
    vAssertCalled();
    if (xTriggerLevelBytes == 0) goto joined_r0x2302f5f8;
  }
  vAssertCalled();
joined_r0x2302f5f8:
  if (xTriggerLevelBytes == 0) {
    xTriggerLevelBytes = 1;
  }
  pxStreamBuffer = (StreamBuffer_t *)pvPortMalloc(xBufferSizeBytes + 0x25);
  if (pxStreamBuffer != (StreamBuffer_t *)0x0) {
    prvInitialiseNewStreamBuffer
              (pxStreamBuffer,(uint8_t *)(pxStreamBuffer + 1),xBufferSizeBytes + 1,
               xTriggerLevelBytes,ucFlags);
  }
  return (StreamBufferHandle_t)pxStreamBuffer;
}



// WARNING: Removing unreachable block (ram,0x2302f6dc)

StreamBufferHandle_t
xStreamBufferGenericCreateStatic
          (size_t xBufferSizeBytes,size_t xTriggerLevelBytes,BaseType_t xIsMessageBuffer,
          uint8_t *pucStreamBufferStorageArea,StaticStreamBuffer_t *pxStaticStreamBuffer)

{
  size_t xSize;
  
  if (pucStreamBufferStorageArea == (uint8_t *)0x0) {
    vAssertCalled();
  }
  if (pxStaticStreamBuffer == (StaticStreamBuffer_t *)0x0) {
    vAssertCalled();
  }
  if (xBufferSizeBytes < xTriggerLevelBytes) {
    vAssertCalled();
  }
  if (xTriggerLevelBytes == 0) {
    xTriggerLevelBytes = 1;
  }
  if (xBufferSizeBytes < 5) {
    vAssertCalled();
  }
  if (pucStreamBufferStorageArea == (uint8_t *)0x0) {
    pxStaticStreamBuffer = (StaticStreamBuffer_t *)0x0;
  }
  else {
    if (pxStaticStreamBuffer != (StaticStreamBuffer_t *)0x0) {
      prvInitialiseNewStreamBuffer
                ((StreamBuffer_t *)pxStaticStreamBuffer,pucStreamBufferStorageArea,xBufferSizeBytes,
                 xTriggerLevelBytes,(xIsMessageBuffer != 0) + '\x02');
      pxStaticStreamBuffer->ucDummy3 = pxStaticStreamBuffer->ucDummy3 | 2;
    }
  }
  return (StreamBufferHandle_t)pxStaticStreamBuffer;
}



void vStreamBufferDelete(StreamBufferHandle_t xStreamBuffer)

{
  if (xStreamBuffer == (StreamBufferHandle_t)0x0) {
    vAssertCalled();
    if ((bRam0000001c & 2) == 0) {
      vPortFree((void *)0x0);
      return;
    }
    memset((void *)0x0,0,0x24);
    return;
  }
  if ((xStreamBuffer->ucFlags & 2) == 0) {
    vPortFree(xStreamBuffer);
    return;
  }
  memset(xStreamBuffer,0,0x24);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

size_t xStreamBufferSpacesAvailable(StreamBufferHandle_t xStreamBuffer)

{
  uint uVar1;
  size_t sVar2;
  uint uVar3;
  
  if (xStreamBuffer == (StreamBufferHandle_t)0x0) {
    vAssertCalled();
    sVar2 = (_DAT_00000008 + ___EM_SIZE + -1) - _DAT_00000004;
    if (_DAT_00000008 <= sVar2) {
      sVar2 = sVar2 - _DAT_00000008;
    }
    return sVar2;
  }
  uVar3 = xStreamBuffer->xLength;
  uVar1 = (uVar3 + xStreamBuffer->xTail + -1) - xStreamBuffer->xHead;
  if (uVar3 <= uVar1) {
    return uVar1 - uVar3;
  }
  return uVar1;
}



size_t xStreamBufferSend(StreamBufferHandle_t xStreamBuffer,void *pvTxData,size_t xDataLengthBytes,
                        TickType_t xTicksToWait)

{
  TaskHandle_t ptVar1;
  BaseType_t BVar2;
  uint uVar3;
  uint uVar4;
  size_t sVar5;
  TickType_t aTStack52 [2];
  size_t sStack44;
  undefined auStack40 [4];
  TimeOut_t xTimeOut;
  
  aTStack52[0] = xTicksToWait;
  if (pvTxData == (void *)0x0) {
    vAssertCalled();
  }
  if (xStreamBuffer == (StreamBufferHandle_t)0x0) {
    vAssertCalled();
  }
  sVar5 = xDataLengthBytes;
  if (((xStreamBuffer->ucFlags & 1) == 0) ||
     (sVar5 = xDataLengthBytes + 4, xDataLengthBytes < sVar5)) {
    if (aTStack52[0] != 0) goto LAB_2302f7ba;
LAB_2302f85c:
    uVar3 = xStreamBufferSpacesAvailable(xStreamBuffer);
    if (uVar3 != 0) goto LAB_2302f80c;
LAB_2302f868:
    sVar5 = 0;
  }
  else {
    vAssertCalled();
    if (aTStack52[0] == 0) goto LAB_2302f85c;
LAB_2302f7ba:
    vTaskSetTimeOutState((TimeOut_t *)auStack40);
    do {
      vTaskEnterCritical();
      uVar3 = xStreamBufferSpacesAvailable(xStreamBuffer);
      if (sVar5 <= uVar3) {
        vTaskExitCritical();
        break;
      }
      xTaskNotifyStateClear((TaskHandle_t)0x0);
      if (xStreamBuffer->xTaskWaitingToSend != (TaskHandle_t)0x0) {
        vAssertCalled();
      }
      ptVar1 = xTaskGetCurrentTaskHandle();
      xStreamBuffer->xTaskWaitingToSend = ptVar1;
      vTaskExitCritical();
      xTaskNotifyWait(0,0,(uint32_t *)0x0,aTStack52[0]);
      xStreamBuffer->xTaskWaitingToSend = (TaskHandle_t)0x0;
      BVar2 = xTaskCheckForTimeOut((TimeOut_t *)auStack40,aTStack52);
    } while (BVar2 == 0);
    if (uVar3 == 0) goto LAB_2302f85c;
LAB_2302f80c:
    if ((xStreamBuffer->ucFlags & 1) == 0) {
      sStack44 = xDataLengthBytes;
      if (uVar3 < xDataLengthBytes) {
        sStack44 = uVar3;
      }
    }
    else {
      if (uVar3 < sVar5) goto LAB_2302f868;
      sStack44 = xDataLengthBytes;
      prvWriteBytesToBuffer((StreamBuffer_t *)xStreamBuffer,(uint8_t *)&sStack44,4);
    }
    sVar5 = prvWriteBytesToBuffer((StreamBuffer_t *)xStreamBuffer,(uint8_t *)pvTxData,sStack44);
    if (sVar5 != 0) {
      uVar3 = xStreamBuffer->xLength;
      uVar4 = (xStreamBuffer->xHead + uVar3) - xStreamBuffer->xTail;
      if (uVar3 <= uVar4) {
        uVar4 = uVar4 - uVar3;
      }
      if (xStreamBuffer->xTriggerLevelBytes <= uVar4) {
        vTaskSuspendAll();
        if (xStreamBuffer->xTaskWaitingToReceive != (TaskHandle_t)0x0) {
          xTaskGenericNotify(xStreamBuffer->xTaskWaitingToReceive,0,eNoAction,(uint32_t *)0x0);
          xStreamBuffer->xTaskWaitingToReceive = (TaskHandle_t)0x0;
        }
        xTaskResumeAll();
      }
    }
  }
  return sVar5;
}



size_t xStreamBufferSendFromISR
                 (StreamBufferHandle_t xStreamBuffer,void *pvTxData,size_t xDataLengthBytes,
                 BaseType_t *pxHigherPriorityTaskWoken)

{
  size_t sVar1;
  uint uVar2;
  uint uVar3;
  size_t sVar4;
  size_t asStack36 [3];
  
  if (pvTxData == (void *)0x0) {
    vAssertCalled();
  }
  if (xStreamBuffer == (StreamBufferHandle_t)0x0) {
    vAssertCalled();
  }
  sVar4 = xDataLengthBytes;
  if ((xStreamBuffer->ucFlags & 1) != 0) {
    sVar4 = xDataLengthBytes + 4;
  }
  sVar1 = xStreamBufferSpacesAvailable(xStreamBuffer);
  if (sVar1 == 0) {
LAB_2302f8de:
    sVar4 = 0;
  }
  else {
    if ((xStreamBuffer->ucFlags & 1) == 0) {
      asStack36[0] = xDataLengthBytes;
      if (sVar1 < xDataLengthBytes) {
        asStack36[0] = sVar1;
      }
    }
    else {
      if (sVar1 < sVar4) goto LAB_2302f8de;
      asStack36[0] = xDataLengthBytes;
      prvWriteBytesToBuffer((StreamBuffer_t *)xStreamBuffer,(uint8_t *)asStack36,4);
    }
    sVar4 = prvWriteBytesToBuffer((StreamBuffer_t *)xStreamBuffer,(uint8_t *)pvTxData,asStack36[0]);
    if (sVar4 != 0) {
      uVar2 = xStreamBuffer->xLength;
      uVar3 = (xStreamBuffer->xHead + uVar2) - xStreamBuffer->xTail;
      if (uVar2 <= uVar3) {
        uVar3 = uVar3 - uVar2;
      }
      if ((xStreamBuffer->xTriggerLevelBytes <= uVar3) &&
         (xStreamBuffer->xTaskWaitingToReceive != (TaskHandle_t)0x0)) {
        xTaskGenericNotifyFromISR
                  (xStreamBuffer->xTaskWaitingToReceive,0,eNoAction,(uint32_t *)0x0,
                   pxHigherPriorityTaskWoken);
        xStreamBuffer->xTaskWaitingToReceive = (TaskHandle_t)0x0;
      }
    }
  }
  return sVar4;
}



size_t xStreamBufferReceive
                 (StreamBufferHandle_t xStreamBuffer,void *pvRxData,size_t xBufferLengthBytes,
                 TickType_t xTicksToWait)

{
  bool bVar1;
  byte bVar2;
  size_t xBytesAvailable;
  TaskHandle_t ptVar3;
  uint uVar4;
  uint uVar5;
  uint xMaxCount;
  size_t sVar6;
  uint uStack36;
  size_t xTempNextMessageLength;
  
  if (pvRxData == (void *)0x0) {
    vAssertCalled();
  }
  if (xStreamBuffer == (StreamBufferHandle_t)0x0) {
    vAssertCalled();
  }
  bVar2 = xStreamBuffer->ucFlags;
  uVar5 = (uint)bVar2 & 1;
  xMaxCount = uVar5 * 4;
  if (xTicksToWait != 0) {
    vTaskEnterCritical();
    uVar4 = xStreamBuffer->xLength;
    xBytesAvailable = (xStreamBuffer->xHead + uVar4) - xStreamBuffer->xTail;
    if (uVar4 <= xBytesAvailable) {
      xBytesAvailable = xBytesAvailable - uVar4;
    }
    if (xMaxCount < xBytesAvailable) {
      vTaskExitCritical();
      goto LAB_2302f9ce;
    }
    xTaskNotifyStateClear((TaskHandle_t)0x0);
    if (xStreamBuffer->xTaskWaitingToReceive != (TaskHandle_t)0x0) {
      vAssertCalled();
    }
    ptVar3 = xTaskGetCurrentTaskHandle();
    xStreamBuffer->xTaskWaitingToReceive = ptVar3;
    vTaskExitCritical();
    xTaskNotifyWait(0,0,(uint32_t *)0x0,xTicksToWait);
    xStreamBuffer->xTaskWaitingToReceive = (TaskHandle_t)0x0;
  }
  uVar4 = xStreamBuffer->xLength;
  xBytesAvailable = (xStreamBuffer->xHead + uVar4) - xStreamBuffer->xTail;
  if (uVar4 <= xBytesAvailable) {
    xBytesAvailable = xBytesAvailable - uVar4;
  }
  if (xBytesAvailable <= xMaxCount) {
    return 0;
  }
LAB_2302f9ce:
  if ((bVar2 & 1) != 0) {
    sVar6 = xStreamBuffer->xTail;
    prvReadBytesFromBuffer
              ((StreamBuffer_t *)xStreamBuffer,(uint8_t *)&uStack36,xMaxCount,xBytesAvailable);
    xBytesAvailable = xBytesAvailable + uVar5 * -4;
    bVar1 = xBufferLengthBytes < uStack36;
    xBufferLengthBytes = uStack36;
    if (bVar1) {
      xStreamBuffer->xTail = sVar6;
      xBufferLengthBytes = 0;
    }
  }
  xBytesAvailable =
       prvReadBytesFromBuffer
                 ((StreamBuffer_t *)xStreamBuffer,(uint8_t *)pvRxData,xBufferLengthBytes,
                  xBytesAvailable);
  if (xBytesAvailable == 0) {
    return 0;
  }
  vTaskSuspendAll();
  if (xStreamBuffer->xTaskWaitingToSend != (TaskHandle_t)0x0) {
    xTaskGenericNotify(xStreamBuffer->xTaskWaitingToSend,0,eNoAction,(uint32_t *)0x0);
    xStreamBuffer->xTaskWaitingToSend = (TaskHandle_t)0x0;
  }
  xTaskResumeAll();
  return xBytesAvailable;
}



// WARNING: Variable defined which should be unmapped: xTempNextMessageLength

size_t xStreamBufferReceiveFromISR
                 (StreamBufferHandle_t xStreamBuffer,void *pvRxData,size_t xBufferLengthBytes,
                 BaseType_t *pxHigherPriorityTaskWoken)

{
  bool bVar1;
  size_t xBytesAvailable;
  uint uVar2;
  uint uVar3;
  uint xMaxCount;
  size_t sVar4;
  uint uStack36;
  size_t xTempNextMessageLength;
  
  if (pvRxData == (void *)0x0) {
    vAssertCalled();
  }
  if (xStreamBuffer == (StreamBufferHandle_t)0x0) {
    vAssertCalled();
  }
  uVar2 = xStreamBuffer->xLength;
  uVar3 = (uint)xStreamBuffer->ucFlags & 1;
  xBytesAvailable = (xStreamBuffer->xHead + uVar2) - xStreamBuffer->xTail;
  xMaxCount = uVar3 * 4;
  if (uVar2 <= xBytesAvailable) {
    xBytesAvailable = xBytesAvailable - uVar2;
  }
  if (xMaxCount < xBytesAvailable) {
    if ((xStreamBuffer->ucFlags & 1) != 0) {
      sVar4 = xStreamBuffer->xTail;
      prvReadBytesFromBuffer
                ((StreamBuffer_t *)xStreamBuffer,(uint8_t *)&uStack36,xMaxCount,xBytesAvailable);
      xBytesAvailable = xBytesAvailable + uVar3 * -4;
      bVar1 = xBufferLengthBytes < uStack36;
      xBufferLengthBytes = uStack36;
      if (bVar1) {
        xStreamBuffer->xTail = sVar4;
        xBufferLengthBytes = 0;
      }
    }
    xBytesAvailable =
         prvReadBytesFromBuffer
                   ((StreamBuffer_t *)xStreamBuffer,(uint8_t *)pvRxData,xBufferLengthBytes,
                    xBytesAvailable);
    if (xBytesAvailable != 0) {
      if (xStreamBuffer->xTaskWaitingToSend == (TaskHandle_t)0x0) {
        return xBytesAvailable;
      }
      xTaskGenericNotifyFromISR
                (xStreamBuffer->xTaskWaitingToSend,0,eNoAction,(uint32_t *)0x0,
                 pxHigherPriorityTaskWoken);
      xStreamBuffer->xTaskWaitingToSend = (TaskHandle_t)0x0;
      return xBytesAvailable;
    }
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BaseType_t xStreamBufferIsEmpty(StreamBufferHandle_t xStreamBuffer)

{
  if (xStreamBuffer != (StreamBufferHandle_t)0x0) {
    return (uint)(xStreamBuffer->xHead == xStreamBuffer->xTail);
  }
  vAssertCalled();
  return (uint)(_DAT_00000004 == ___EM_SIZE);
}



void prvResetNextTaskUnblockTime(void)

{
  xNextTaskUnblockTime = *(TickType_t *)((int)((pxDelayedTaskList->xListEnd).pxNext)->pvOwner + 4);
  return;
}



void prvInitialiseNewTask
               (TaskFunction_t *pxTaskCode,char *pcName,uint32_t ulStackDepth,void *pvParameters,
               UBaseType_t uxPriority,TaskHandle_t *pxCreatedTask,TCB_t *pxNewTCB)

{
  char cVar1;
  char *pcVar2;
  char *pcVar3;
  StackType_t *pSVar4;
  
  memset(pxNewTCB->pxStack,0xa5,ulStackDepth * 4);
  pSVar4 = pxNewTCB->pxStack;
  if (pcName == (char *)0x0) {
    pxNewTCB->pcTaskName[0] = '\0';
  }
  else {
    pcVar2 = pcName + 0x10;
    pcVar3 = pxNewTCB->pcTaskName;
    do {
      cVar1 = *pcName;
      pcName = pcName + 1;
      *pcVar3 = cVar1;
      if (cVar1 == '\0') break;
      pcVar3 = pcVar3 + 1;
    } while (pcName != pcVar2);
    pxNewTCB->pcTaskName[0xf] = '\0';
  }
  if (0x1f < uxPriority) {
    uxPriority = 0x1f;
  }
  pxNewTCB->uxPriority = uxPriority;
  pxNewTCB->uxBasePriority = uxPriority;
  pxNewTCB->uxMutexesHeld = 0;
  vListInitialiseItem(&pxNewTCB->xStateListItem);
  vListInitialiseItem(&pxNewTCB->xEventListItem);
  pxNewTCB->ulNotifiedValue = 0;
  *(TCB_t **)&(pxNewTCB->xStateListItem).pvOwner = pxNewTCB;
  (pxNewTCB->xEventListItem).xItemValue = 0x20 - uxPriority;
  *(TCB_t **)&(pxNewTCB->xEventListItem).pvOwner = pxNewTCB;
  pxNewTCB->uxCriticalNesting = 0;
  pxNewTCB->ucNotifyState = '\0';
  pSVar4 = (StackType_t *)
           pxPortInitialiseStack
                     ((uint)(pSVar4 + (ulStackDepth - 1)) & 0xfffffff8,pxTaskCode,pvParameters);
  pxNewTCB->pxTopOfStack = pSVar4;
  if (pxCreatedTask != (TaskHandle_t *)0x0) {
    *(TCB_t **)pxCreatedTask = pxNewTCB;
  }
  return;
}



void prvDeleteTCB(TCB_t *pxTCB)

{
  uint8_t uVar1;
  
  uVar1 = pxTCB->ucStaticallyAllocated;
  if (uVar1 == '\0') {
    vPortFree(pxTCB->pxStack);
    vPortFree(pxTCB);
    return;
  }
  if (uVar1 != '\x01') {
    if (uVar1 == '\x02') {
      return;
    }
    vAssertCalled();
    return;
  }
  vPortFree(pxTCB);
  return;
}



void prvAddCurrentTaskToDelayedList(TickType_t xTicksToWait,BaseType_t xCanBlockIndefinitely)

{
  TickType_t TVar1;
  uint uVar2;
  UBaseType_t UVar3;
  
  TVar1 = xTickCount;
  UVar3 = uxListRemove(&pxCurrentTCB->xStateListItem);
  if (UVar3 == 0) {
    uxTopReadyPriority = ~(1 << (pxCurrentTCB->uxPriority & 0x1f)) & uxTopReadyPriority;
  }
  if ((xTicksToWait == 0xffffffff) && (xCanBlockIndefinitely != 0)) {
    vListInsertEnd(&xSuspendedTaskList,&pxCurrentTCB->xStateListItem);
    return;
  }
  uVar2 = xTicksToWait + TVar1;
  (pxCurrentTCB->xStateListItem).xItemValue = uVar2;
  if (TVar1 <= uVar2) {
    vListInsert(pxDelayedTaskList,&pxCurrentTCB->xStateListItem);
    if (uVar2 < xNextTaskUnblockTime) {
      xNextTaskUnblockTime = uVar2;
    }
    return;
  }
  vListInsert(pxOverflowDelayedTaskList,&pxCurrentTCB->xStateListItem);
  return;
}



void vTaskEnterCritical(void)

{
  pxCurrentTCB->uxCriticalNesting = pxCurrentTCB->uxCriticalNesting + 1;
  return;
}



void vTaskExitCritical(void)

{
  pxCurrentTCB->uxCriticalNesting = pxCurrentTCB->uxCriticalNesting - 1;
  return;
}



void prvAddNewTaskToReadyList(TCB_t *pxNewTCB)

{
  uint uVar1;
  List_t *pxList;
  List_t *pLVar2;
  
  if (xSchedulerRunning != 0) {
    vTaskEnterCritical();
  }
  uxCurrentNumberOfTasks = uxCurrentNumberOfTasks + 1;
  if (pxCurrentTCB == (TCB_t *)0x0) {
    if (uxCurrentNumberOfTasks == 1) {
      pxList = pxReadyTasksLists;
      pxCurrentTCB = pxNewTCB;
      do {
        pLVar2 = pxList + 1;
        vListInitialise(pxList);
        pxList = pLVar2;
      } while (pLVar2 != &xDelayedTaskList1);
      vListInitialise(&xDelayedTaskList1);
      vListInitialise(&xDelayedTaskList2);
      vListInitialise(&xPendingReadyList);
      vListInitialise(&xTasksWaitingTermination);
      vListInitialise(&xSuspendedTaskList);
      pxDelayedTaskList = &xDelayedTaskList1;
      pxOverflowDelayedTaskList = &xDelayedTaskList2;
      uVar1 = pxNewTCB->uxPriority;
    }
    else {
      uVar1 = pxNewTCB->uxPriority;
      pxCurrentTCB = pxNewTCB;
    }
  }
  else {
    uVar1 = pxNewTCB->uxPriority;
    if ((xSchedulerRunning == 0) && (pxCurrentTCB->uxPriority <= uVar1)) {
      pxCurrentTCB = pxNewTCB;
    }
  }
  uxTaskNumber = uxTaskNumber + 1;
  uxTopReadyPriority = 1 << (uVar1 & 0x1f) | uxTopReadyPriority;
  pxNewTCB->uxTCBNumber = uxTaskNumber;
  vListInsertEnd(pxReadyTasksLists + uVar1,&pxNewTCB->xStateListItem);
  if ((xSchedulerRunning != 0) && (pxCurrentTCB->uxCriticalNesting != 0)) {
    vTaskExitCritical();
  }
  if ((xSchedulerRunning != 0) && (pxCurrentTCB->uxPriority < pxNewTCB->uxPriority)) {
    ecall();
  }
  return;
}


/*
Unable to decompile 'prvIdleTask'
Cause: Exception while decompiling 2302fea6: Decompiler process died

*/


// WARNING: Removing unreachable block (ram,0x2302ff8e)
// WARNING: Removing unreachable block (ram,0x2302ffd4)

TaskHandle_t
xTaskCreateStatic(TaskFunction_t *pxTaskCode,char *pcName,uint32_t ulStackDepth,void *pvParameters,
                 UBaseType_t uxPriority,StackType_t *puxStackBuffer,StaticTask_t *pxTaskBuffer)

{
  TaskHandle_t ptVar1;
  size_t xSize;
  TaskHandle_t xReturn;
  
  ptVar1 = (TaskHandle_t)xSize;
  if (puxStackBuffer == (StackType_t *)0x0) {
    vAssertCalled();
    ptVar1 = (TaskHandle_t)xSize;
  }
  if (pxTaskBuffer == (StaticTask_t *)0x0) {
    vAssertCalled();
    return (TaskHandle_t)0x0;
  }
  xSize = 0;
  if (puxStackBuffer != (StackType_t *)0x0) {
    pxTaskBuffer->uxDummy20 = '\x02';
    *(StackType_t **)&pxTaskBuffer->pxDummy6 = puxStackBuffer;
    xSize = (size_t)ptVar1;
    prvInitialiseNewTask
              (pxTaskCode,pcName,ulStackDepth,pvParameters,uxPriority,(TaskHandle_t *)&xSize,
               (TCB_t *)pxTaskBuffer);
    prvAddNewTaskToReadyList((TCB_t *)pxTaskBuffer);
  }
  return (TaskHandle_t)xSize;
}



BaseType_t
xTaskCreate(TaskFunction_t *pxTaskCode,char *pcName,uint16_t usStackDepth,void *pvParameters,
           UBaseType_t uxPriority,TaskHandle_t *pxCreatedTask)

{
  StackType_t *pv;
  TCB_t *pxNewTCB;
  BaseType_t BVar1;
  undefined2 in_register_00002032;
  
  pv = (StackType_t *)pvPortMalloc(CONCAT22(in_register_00002032,usStackDepth) << 2);
  if (pv == (StackType_t *)0x0) {
    BVar1 = -1;
  }
  else {
    pxNewTCB = (TCB_t *)pvPortMalloc(0x60);
    if (pxNewTCB == (TCB_t *)0x0) {
      vPortFree(pv);
      BVar1 = -1;
    }
    else {
      pxNewTCB->pxStack = pv;
      pxNewTCB->ucStaticallyAllocated = '\0';
      prvInitialiseNewTask
                (pxTaskCode,pcName,CONCAT22(in_register_00002032,usStackDepth),pvParameters,
                 uxPriority,pxCreatedTask,pxNewTCB);
      prvAddNewTaskToReadyList(pxNewTCB);
      BVar1 = 1;
    }
  }
  return BVar1;
}



void vTaskDelete(TaskHandle_t xTaskToDelete)

{
  UBaseType_t UVar1;
  
  if (xSchedulerRunning != 0) {
    vTaskEnterCritical();
  }
  if (xTaskToDelete == (TaskHandle_t)0x0) {
    xTaskToDelete = (TaskHandle_t)pxCurrentTCB;
  }
  UVar1 = uxListRemove(&((TCB_t *)xTaskToDelete)->xStateListItem);
  if ((UVar1 == 0) && (pxReadyTasksLists[((TCB_t *)xTaskToDelete)->uxPriority].uxNumberOfItems == 0)
     ) {
    uxTopReadyPriority = ~(1 << (((TCB_t *)xTaskToDelete)->uxPriority & 0x1f)) & uxTopReadyPriority;
  }
  if ((((TCB_t *)xTaskToDelete)->xEventListItem).pvContainer != (xLIST *)0x0) {
    uxListRemove(&((TCB_t *)xTaskToDelete)->xEventListItem);
  }
  uxTaskNumber = uxTaskNumber + 1;
  if (pxCurrentTCB == (TCB_t *)xTaskToDelete) {
    vListInsertEnd(&xTasksWaitingTermination,&((TCB_t *)xTaskToDelete)->xStateListItem);
    uxDeletedTasksWaitingCleanUp = uxDeletedTasksWaitingCleanUp + 1;
  }
  else {
    uxCurrentNumberOfTasks = uxCurrentNumberOfTasks - 1;
    prvDeleteTCB((TCB_t *)xTaskToDelete);
    if (pxDelayedTaskList->uxNumberOfItems == 0) {
      xNextTaskUnblockTime = 0xffffffff;
    }
    else {
      prvResetNextTaskUnblockTime();
    }
  }
  if ((xSchedulerRunning != 0) && (pxCurrentTCB->uxCriticalNesting != 0)) {
    vTaskExitCritical();
  }
  if ((xSchedulerRunning != 0) && (pxCurrentTCB == (TCB_t *)xTaskToDelete)) {
    if (uxSchedulerSuspended == 0) {
      ecall();
    }
    else {
      vAssertCalled();
      ecall();
    }
    return;
  }
  return;
}


/*
Unable to decompile 'eTaskGetState'
Cause: Exception while decompiling 23030196: Decompiler process died

*/

/*
Unable to decompile 'vTaskStartScheduler'
Cause: Exception while decompiling 23030264: Decompiler process died

*/


void vTaskSuspendAll(void)

{
  uxSchedulerSuspended = uxSchedulerSuspended + 1;
  return;
}



TickType_t xTaskGetTickCount(void)

{
  return xTickCount;
}



BaseType_t xTaskGetTickCount2(TickType_t *ticks,BaseType_t *overflow)

{
  BaseType_t BVar1;
  
  BVar1 = xNumOfOverflows;
  *ticks = xTickCount;
  *overflow = BVar1;
  return 1;
}



TickType_t xTaskGetTickCountFromISR(void)

{
  return xTickCount;
}



char * pcTaskGetName(TaskHandle_t xTaskToQuery)

{
  if ((xTaskToQuery == (TaskHandle_t)0x0) &&
     (xTaskToQuery = (TaskHandle_t)pxCurrentTCB, pxCurrentTCB == (TCB_t *)0x0)) {
    vAssertCalled();
    return (char *)0x34;
  }
  return ((TCB_t *)xTaskToQuery)->pcTaskName;
}



BaseType_t xTaskIncrementTick(void)

{
  List_t *pLVar1;
  List_t *pLVar2;
  TickType_t TVar3;
  void *pvVar4;
  int iVar5;
  int iVar6;
  uint uVar7;
  uint32_t uStack52;
  uint32_t tmp;
  
  iVar6 = bl_sys_time_sync_state(&uStack52);
  if (iVar6 != 0) {
    if (uxSchedulerSuspended == 0) {
      uVar7 = xTickCount + 1;
      xTickCount = uVar7;
      if (uVar7 == 0) {
        if (pxDelayedTaskList->uxNumberOfItems != 0) {
          vAssertCalled();
        }
        pLVar2 = pxOverflowDelayedTaskList;
        pLVar1 = pxDelayedTaskList;
        pxDelayedTaskList = pxOverflowDelayedTaskList;
        pxOverflowDelayedTaskList = pLVar1;
        xNumOfOverflows = xNumOfOverflows + 1;
        if (pLVar2->uxNumberOfItems == 0) {
          xNextTaskUnblockTime = 0xffffffff;
        }
        else {
          prvResetNextTaskUnblockTime();
        }
      }
      if (uVar7 < xNextTaskUnblockTime) {
        iVar6 = 0;
        TVar3 = xNextTaskUnblockTime;
      }
      else {
        iVar6 = 0;
        while (iVar5 = iVar6, pxDelayedTaskList->uxNumberOfItems != 0) {
          while( true ) {
            pvVar4 = ((pxDelayedTaskList->xListEnd).pxNext)->pvOwner;
            TVar3 = *(uint *)((int)pvVar4 + 4);
            if (uVar7 < *(uint *)((int)pvVar4 + 4)) goto LAB_230304b2;
            uxListRemove((ListItem_t *)((int)pvVar4 + 4));
            if (*(int *)((int)pvVar4 + 0x28) != 0) {
              uxListRemove((ListItem_t *)((int)pvVar4 + 0x18));
            }
            uxTopReadyPriority = 1 << (*(uint *)((int)pvVar4 + 0x2c) & 0x1f) | uxTopReadyPriority;
            vListInsertEnd(pxReadyTasksLists + *(uint *)((int)pvVar4 + 0x2c),
                           (ListItem_t *)((int)pvVar4 + 4));
            if (*(uint *)((int)pvVar4 + 0x2c) < pxCurrentTCB->uxPriority) break;
            iVar6 = 1;
            iVar5 = 1;
            if (pxDelayedTaskList->uxNumberOfItems == 0) goto LAB_23030498;
          }
        }
LAB_23030498:
        xNextTaskUnblockTime = 0xffffffff;
        iVar6 = iVar5;
        TVar3 = xNextTaskUnblockTime;
      }
LAB_230304b2:
      xNextTaskUnblockTime = TVar3;
      if (1 < pxReadyTasksLists[pxCurrentTCB->uxPriority].uxNumberOfItems) {
        iVar6 = 1;
      }
    }
    else {
      iVar6 = 0;
      uxPendedTicks = uxPendedTicks + 1;
    }
    if (xYieldPending != 0) {
      iVar6 = 1;
    }
  }
  return iVar6;
}


/*
Unable to decompile 'xTaskResumeAll'
Cause: Exception while decompiling 230304dc: Decompiler process died

*/


void vTaskDelay(TickType_t xTicksToDelay)

{
  BaseType_t BVar1;
  
  if (xTicksToDelay == 0) {
    ecall();
    return;
  }
  if (uxSchedulerSuspended != 0) {
    vAssertCalled();
  }
  uxSchedulerSuspended = uxSchedulerSuspended + 1;
  prvAddCurrentTaskToDelayedList(xTicksToDelay,0);
  BVar1 = xTaskResumeAll();
  if (BVar1 == 0) {
    ecall();
  }
  return;
}



void vTaskSwitchContext(void)

{
  int iVar1;
  StackType_t *pSVar2;
  xLIST_ITEM *pxVar3;
  
  if (uxSchedulerSuspended == 0) {
    xYieldPending = 0;
    pSVar2 = pxCurrentTCB->pxStack;
    if ((((*pSVar2 != 0xa5a5a5a5) || (pSVar2[1] != 0xa5a5a5a5)) || (pSVar2[2] != 0xa5a5a5a5)) ||
       (pSVar2[3] != 0xa5a5a5a5)) {
      vApplicationStackOverflowHook((TaskHandle_t)pxCurrentTCB,pxCurrentTCB->pcTaskName);
    }
    iVar1 = __clzsi2(uxTopReadyPriority);
    iVar1 = 0x1f - iVar1;
    if (pxReadyTasksLists[iVar1].uxNumberOfItems == 0) {
      vAssertCalled();
    }
    pxVar3 = (pxReadyTasksLists[iVar1].pxIndex)->pxNext;
    *(xLIST_ITEM **)&pxReadyTasksLists[iVar1].pxIndex = pxVar3;
    if (pxVar3 == (xLIST_ITEM *)(iVar1 * 0x14 + 0x42012544)) {
      pxVar3 = pxVar3->pxNext;
      *(xLIST_ITEM **)&pxReadyTasksLists[iVar1].pxIndex = pxVar3;
    }
    pxCurrentTCB = (TCB_t *)pxVar3->pvOwner;
    return;
  }
  xYieldPending = 1;
  return;
}



void vTaskPlaceOnEventList(List_t *pxEventList,TickType_t xTicksToWait)

{
  if (pxEventList == (List_t *)0x0) {
    vAssertCalled();
  }
  vListInsert(pxEventList,&pxCurrentTCB->xEventListItem);
  prvAddCurrentTaskToDelayedList(xTicksToWait,1);
  return;
}



void vTaskPlaceOnUnorderedEventList
               (List_t *pxEventList,TickType_t xItemValue,TickType_t xTicksToWait)

{
  ListItem_t *pxNewListItem;
  
  if (pxEventList == (List_t *)0x0) {
    vAssertCalled();
  }
  if (uxSchedulerSuspended == 0) {
    vAssertCalled();
  }
  pxNewListItem = &pxCurrentTCB->xEventListItem;
  (pxCurrentTCB->xEventListItem).xItemValue = xItemValue | 0x80000000;
  vListInsertEnd(pxEventList,pxNewListItem);
  prvAddCurrentTaskToDelayedList(xTicksToWait,1);
  return;
}



void vTaskPlaceOnEventListRestricted
               (List_t *pxEventList,TickType_t xTicksToWait,BaseType_t xWaitIndefinitely)

{
  if (pxEventList == (List_t *)0x0) {
    vAssertCalled();
  }
  vListInsertEnd(pxEventList,&pxCurrentTCB->xEventListItem);
  if (xWaitIndefinitely != 0) {
    xTicksToWait = 0xffffffff;
  }
  prvAddCurrentTaskToDelayedList(xTicksToWait,xWaitIndefinitely);
  return;
}



BaseType_t xTaskRemoveFromEventList(List_t *pxEventList)

{
  bool bVar1;
  void *pvVar2;
  
  pvVar2 = ((pxEventList->xListEnd).pxNext)->pvOwner;
  if (pvVar2 == (void *)0x0) {
    vAssertCalled();
  }
  uxListRemove((ListItem_t *)((int)pvVar2 + 0x18));
  if (uxSchedulerSuspended == 0) {
    uxListRemove((ListItem_t *)((int)pvVar2 + 4));
    uxTopReadyPriority = 1 << (*(uint *)((int)pvVar2 + 0x2c) & 0x1f) | uxTopReadyPriority;
    vListInsertEnd(pxReadyTasksLists + *(uint *)((int)pvVar2 + 0x2c),(ListItem_t *)((int)pvVar2 + 4)
                  );
  }
  else {
    vListInsertEnd(&xPendingReadyList,(ListItem_t *)((int)pvVar2 + 0x18));
  }
  bVar1 = pxCurrentTCB->uxPriority < *(uint *)((int)pvVar2 + 0x2c);
  if (bVar1) {
    xYieldPending = 1;
  }
  return (uint)bVar1;
}



void vTaskRemoveFromUnorderedEventList(ListItem_t *pxEventListItem,TickType_t xItemValue)

{
  void *pvVar1;
  
  if (uxSchedulerSuspended == 0) {
    vAssertCalled();
    pvVar1 = pxEventListItem->pvOwner;
    pxEventListItem->xItemValue = xItemValue | 0x80000000;
  }
  else {
    pvVar1 = pxEventListItem->pvOwner;
    pxEventListItem->xItemValue = xItemValue | 0x80000000;
  }
  if (pvVar1 == (void *)0x0) {
    vAssertCalled();
  }
  uxListRemove(pxEventListItem);
  uxListRemove((ListItem_t *)((int)pvVar1 + 4));
  uxTopReadyPriority = 1 << (*(uint *)((int)pvVar1 + 0x2c) & 0x1f) | uxTopReadyPriority;
  vListInsertEnd(pxReadyTasksLists + *(uint *)((int)pvVar1 + 0x2c),(ListItem_t *)((int)pvVar1 + 4));
  if (pxCurrentTCB->uxPriority < *(uint *)((int)pvVar1 + 0x2c)) {
    xYieldPending = 1;
  }
  return;
}


/*
Unable to decompile 'vTaskSetTimeOutState'
Cause: Exception while decompiling 23030936: Decompiler process died

*/


void vTaskInternalSetTimeOutState(TimeOut_t *pxTimeOut)

{
  TickType_t TVar1;
  
  TVar1 = xTickCount;
  pxTimeOut->xOverflowCount = xNumOfOverflows;
  pxTimeOut->xTimeOnEntering = TVar1;
  return;
}


/*
Unable to decompile 'xTaskCheckForTimeOut'
Cause: Exception while decompiling 230309ac: Decompiler process died

*/


void vTaskMissedYield(void)

{
  xYieldPending = 1;
  return;
}



void vTaskGetInfo(TaskHandle_t xTask,TaskStatus_t *pxTaskStatus,BaseType_t xGetFreeStackSpace,
                 eTaskState eState)

{
  eTaskState eVar1;
  undefined3 in_register_00002035;
  UBaseType_t UVar2;
  uint uVar3;
  
  if (xTask == (TaskHandle_t)0x0) {
    xTask = (TaskHandle_t)pxCurrentTCB;
  }
  pxTaskStatus->pcTaskName = xTask->pcTaskName;
  pxTaskStatus->xHandle = xTask;
  pxTaskStatus->uxCurrentPriority = xTask->uxPriority;
  pxTaskStatus->pxStackBase = xTask->pxStack;
  pxTaskStatus->xTaskNumber = xTask->uxTCBNumber;
  UVar2 = xTask->uxBasePriority;
  pxTaskStatus->ulRunTimeCounter = 0;
  pxTaskStatus->uxBasePriority = UVar2;
  if (CONCAT31(in_register_00002035,eState) == 5) {
    eVar1 = eTaskGetState(xTask);
    pxTaskStatus->eCurrentState = eVar1;
  }
  else {
    if (pxCurrentTCB == (TCB_t *)xTask) {
      pxTaskStatus->eCurrentState = eRunning;
    }
    else {
      pxTaskStatus->eCurrentState = eState;
      if (CONCAT31(in_register_00002035,eState) == 3) {
        uxSchedulerSuspended = uxSchedulerSuspended + 1;
        if ((xTask->xEventListItem).pvContainer != (xLIST *)0x0) {
          pxTaskStatus->eCurrentState = eBlocked;
        }
        xTaskResumeAll();
      }
    }
  }
  if (xGetFreeStackSpace != 0) {
    if (*(char *)xTask->pxStack == -0x5b) {
      uVar3 = 0;
      do {
        uVar3 = uVar3 + 1;
      } while (*(char *)((int)xTask->pxStack + uVar3) == -0x5b);
      pxTaskStatus->usStackHighWaterMark = (uint16_t)(uVar3 >> 2);
    }
    else {
      pxTaskStatus->usStackHighWaterMark = 0;
    }
    return;
  }
  pxTaskStatus->usStackHighWaterMark = 0;
  return;
}



UBaseType_t
prvListTasksWithinSingleList(TaskStatus_t *pxTaskStatusArray,List_t *pxList,eTaskState eState)

{
  TaskHandle_t xTask;
  xLIST_ITEM *pxVar1;
  int iVar2;
  TaskHandle_t ptVar3;
  
  pxVar1 = pxList->pxIndex->pxNext;
  *(xLIST_ITEM **)&pxList->pxIndex = pxVar1;
  if (pxVar1 == (xLIST_ITEM *)&pxList->xListEnd) {
    pxVar1 = (pxList->xListEnd).pxNext;
    *(xLIST_ITEM **)&pxList->pxIndex = pxVar1;
  }
  ptVar3 = (TaskHandle_t)pxVar1->pvOwner;
  iVar2 = 0;
  while( true ) {
    pxVar1 = pxVar1->pxNext;
    *(xLIST_ITEM **)&pxList->pxIndex = pxVar1;
    if ((xLIST_ITEM *)&pxList->xListEnd == pxVar1) {
      pxVar1 = (pxList->xListEnd).pxNext;
      *(xLIST_ITEM **)&pxList->pxIndex = pxVar1;
      xTask = (TaskHandle_t)pxVar1->pvOwner;
      vTaskGetInfo(xTask,pxTaskStatusArray,1,eState);
    }
    else {
      xTask = (TaskHandle_t)pxVar1->pvOwner;
      vTaskGetInfo(xTask,pxTaskStatusArray,1,eState);
    }
    if (ptVar3 == xTask) break;
    iVar2 = iVar2 + 1;
    pxTaskStatusArray = pxTaskStatusArray + 1;
    pxVar1 = (xLIST_ITEM *)pxList->pxIndex;
  }
  return iVar2 + 1;
}



UBaseType_t
uxTaskGetSystemState
          (TaskStatus_t *pxTaskStatusArray,UBaseType_t uxArraySize,uint32_t *pulTotalRunTime)

{
  int iVar1;
  UBaseType_t UVar2;
  int iVar3;
  TaskStatus_t *pxTaskStatusArray_00;
  UBaseType_t UVar4;
  List_t *pxList;
  
  uxSchedulerSuspended = uxSchedulerSuspended + 1;
  UVar4 = 0;
  if (uxCurrentNumberOfTasks <= uxArraySize) {
    pxList = pxReadyTasksLists + 0x1f;
    iVar1 = 0x20;
    UVar4 = 0;
    iVar3 = 0;
    do {
      iVar1 = iVar1 + -1;
      pxTaskStatusArray_00 = (TaskStatus_t *)(&pxTaskStatusArray->xHandle + iVar3 + UVar4);
      if (pxReadyTasksLists[iVar1].uxNumberOfItems != 0) {
        UVar2 = prvListTasksWithinSingleList(pxTaskStatusArray_00,pxList,eReady);
        UVar4 = UVar4 + UVar2;
        iVar3 = UVar4 * 8;
        pxTaskStatusArray_00 = pxTaskStatusArray + UVar4;
      }
      pxList = pxList + -1;
    } while (iVar1 != 0);
    if (pxDelayedTaskList->uxNumberOfItems != 0) {
      UVar2 = prvListTasksWithinSingleList(pxTaskStatusArray_00,pxDelayedTaskList,eBlocked);
      UVar4 = UVar4 + UVar2;
      pxTaskStatusArray_00 = pxTaskStatusArray + UVar4;
    }
    if (pxOverflowDelayedTaskList->uxNumberOfItems != 0) {
      UVar2 = prvListTasksWithinSingleList(pxTaskStatusArray_00,pxOverflowDelayedTaskList,eBlocked);
      UVar4 = UVar4 + UVar2;
      pxTaskStatusArray_00 = pxTaskStatusArray + UVar4;
    }
    if (xTasksWaitingTermination.uxNumberOfItems != 0) {
      UVar2 = prvListTasksWithinSingleList(pxTaskStatusArray_00,&xTasksWaitingTermination,eDeleted);
      UVar4 = UVar4 + UVar2;
      pxTaskStatusArray_00 = pxTaskStatusArray + UVar4;
    }
    if (xSuspendedTaskList.uxNumberOfItems != 0) {
      UVar2 = prvListTasksWithinSingleList(pxTaskStatusArray_00,&xSuspendedTaskList,eSuspended);
      UVar4 = UVar4 + UVar2;
    }
    if (pulTotalRunTime != (uint32_t *)0x0) {
      *pulTotalRunTime = 0;
    }
  }
  xTaskResumeAll();
  return UVar4;
}



UBaseType_t uxTaskGetStackHighWaterMark(TaskHandle_t xTask)

{
  char cVar1;
  uint uVar2;
  StackType_t *pSVar3;
  
  if (xTask == (TaskHandle_t)0x0) {
    pSVar3 = pxCurrentTCB->pxStack;
    cVar1 = *(char *)pSVar3;
  }
  else {
    pSVar3 = xTask->pxStack;
    cVar1 = *(char *)pSVar3;
  }
  if (cVar1 == -0x5b) {
    uVar2 = 0;
    do {
      uVar2 = uVar2 + 1;
    } while (*(char *)((int)pSVar3 + uVar2) == -0x5b);
    return uVar2 >> 2 & 0xffff;
  }
  return 0;
}



TaskHandle_t xTaskGetCurrentTaskHandle(void)

{
  return (TaskHandle_t)pxCurrentTCB;
}



BaseType_t xTaskGetSchedulerState(void)

{
  BaseType_t BVar1;
  
  BVar1 = 1;
  if (xSchedulerRunning != 0) {
    BVar1 = (uint)(uxSchedulerSuspended == 0) << 1;
  }
  return BVar1;
}



BaseType_t xTaskPriorityInherit(TaskHandle_t pxMutexHolder)

{
  UBaseType_t UVar1;
  uint uVar2;
  
  if (pxMutexHolder == (TaskHandle_t)0x0) {
    return 0;
  }
  uVar2 = pxMutexHolder->uxPriority;
  if (uVar2 < pxCurrentTCB->uxPriority) {
    if (-1 < (int)(pxMutexHolder->xEventListItem).xItemValue) {
      (pxMutexHolder->xEventListItem).xItemValue = 0x20 - pxCurrentTCB->uxPriority;
    }
    if ((List_t *)(pxMutexHolder->xStateListItem).pvContainer != pxReadyTasksLists + uVar2) {
      pxMutexHolder->uxPriority = pxCurrentTCB->uxPriority;
      return 1;
    }
    UVar1 = uxListRemove(&pxMutexHolder->xStateListItem);
    if ((UVar1 == 0) && (pxReadyTasksLists[pxMutexHolder->uxPriority].uxNumberOfItems == 0)) {
      uxTopReadyPriority = ~(1 << (pxMutexHolder->uxPriority & 0x1f)) & uxTopReadyPriority;
    }
    uVar2 = pxCurrentTCB->uxPriority;
    uxTopReadyPriority = 1 << (uVar2 & 0x1f) | uxTopReadyPriority;
    pxMutexHolder->uxPriority = uVar2;
    vListInsertEnd(pxReadyTasksLists + uVar2,&pxMutexHolder->xStateListItem);
    uVar2 = 1;
  }
  else {
    uVar2 = (uint)(pxMutexHolder->uxBasePriority < pxCurrentTCB->uxPriority);
  }
  return uVar2;
}



BaseType_t xTaskPriorityDisinherit(TaskHandle_t pxMutexHolder)

{
  uint uVar1;
  UBaseType_t UVar2;
  
  if (pxMutexHolder == (TaskHandle_t)0x0) {
    return 0;
  }
  if (pxCurrentTCB != (TCB_t *)pxMutexHolder) {
    vAssertCalled();
  }
  if (pxMutexHolder->uxMutexesHeld == 0) {
    vAssertCalled();
    UVar2 = pxMutexHolder->uxMutexesHeld - 1;
    pxMutexHolder->uxMutexesHeld = UVar2;
    if (pxMutexHolder->uxPriority == pxMutexHolder->uxBasePriority) {
      return 0;
    }
  }
  else {
    UVar2 = pxMutexHolder->uxMutexesHeld - 1;
    pxMutexHolder->uxMutexesHeld = UVar2;
    if (pxMutexHolder->uxPriority == pxMutexHolder->uxBasePriority) {
      return 0;
    }
  }
  if (UVar2 != 0) {
    return 0;
  }
  UVar2 = uxListRemove(&pxMutexHolder->xStateListItem);
  if ((UVar2 == 0) && (pxReadyTasksLists[pxMutexHolder->uxPriority].uxNumberOfItems == 0)) {
    uxTopReadyPriority = ~(1 << (pxMutexHolder->uxPriority & 0x1f)) & uxTopReadyPriority;
  }
  uVar1 = pxMutexHolder->uxBasePriority;
  uxTopReadyPriority = 1 << (uVar1 & 0x1f) | uxTopReadyPriority;
  pxMutexHolder->uxPriority = uVar1;
  (pxMutexHolder->xEventListItem).xItemValue = 0x20 - uVar1;
  vListInsertEnd(pxReadyTasksLists + uVar1,&pxMutexHolder->xStateListItem);
  return 1;
}



void vTaskPriorityDisinheritAfterTimeout
               (TaskHandle_t pxMutexHolder,UBaseType_t uxHighestPriorityWaitingTask)

{
  UBaseType_t UVar1;
  TickType_t TVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  
  if (pxMutexHolder == (TaskHandle_t)0x0) {
    return;
  }
  if (pxMutexHolder->uxMutexesHeld == 0) {
    vAssertCalled();
    uVar5 = pxMutexHolder->uxBasePriority;
  }
  else {
    uVar5 = pxMutexHolder->uxBasePriority;
  }
  if (uVar5 < uxHighestPriorityWaitingTask) {
    uVar3 = pxMutexHolder->uxPriority;
    if (uVar3 == uxHighestPriorityWaitingTask) {
      return;
    }
  }
  else {
    uVar3 = pxMutexHolder->uxPriority;
    uxHighestPriorityWaitingTask = uVar5;
    if (uVar3 == uVar5) {
      return;
    }
  }
  if (pxMutexHolder->uxMutexesHeld == 1) {
    if (pxCurrentTCB == (TCB_t *)pxMutexHolder) {
      vAssertCalled();
      uVar3 = pxMutexHolder->uxPriority;
    }
    TVar2 = (pxMutexHolder->xEventListItem).xItemValue;
    pxMutexHolder->uxPriority = uxHighestPriorityWaitingTask;
    if (-1 < (int)TVar2) {
      (pxMutexHolder->xEventListItem).xItemValue = 0x20 - uxHighestPriorityWaitingTask;
    }
    if ((List_t *)(pxMutexHolder->xStateListItem).pvContainer == pxReadyTasksLists + uVar3) {
      UVar1 = uxListRemove(&pxMutexHolder->xStateListItem);
      if (UVar1 == 0) {
        uVar5 = pxMutexHolder->uxPriority;
        iVar4 = uVar5 * 4;
        uVar3 = 1 << (uVar5 & 0x1f);
        if (pxReadyTasksLists[uVar5].uxNumberOfItems == 0) {
          uxTopReadyPriority = ~uVar3 & uxTopReadyPriority;
        }
      }
      else {
        uVar5 = pxMutexHolder->uxPriority;
        uVar3 = 1 << (uVar5 & 0x1f);
        iVar4 = uVar5 << 2;
      }
      uxTopReadyPriority = uVar3 | uxTopReadyPriority;
      vListInsertEnd((List_t *)(&pxReadyTasksLists[0].uxNumberOfItems + iVar4 + uVar5),
                     &pxMutexHolder->xStateListItem);
      return;
    }
  }
  return;
}



void vTaskEnterCritical(void)

{
  if (xSchedulerRunning == 0) {
    return;
  }
  vTaskEnterCritical();
  return;
}



void vTaskExitCritical(void)

{
  if ((xSchedulerRunning != 0) && (pxCurrentTCB->uxCriticalNesting != 0)) {
    vTaskExitCritical();
    return;
  }
  return;
}



void vTaskList(char *pcWriteBuffer)

{
  TaskStatus_t *pTVar1;
  TaskStatus_t *pxTaskStatusArray;
  UBaseType_t uxArraySize;
  size_t sVar2;
  char *pcVar3;
  uint uVar4;
  
  uxArraySize = uxCurrentNumberOfTasks;
  *pcWriteBuffer = '\0';
  pxTaskStatusArray = (TaskStatus_t *)pvPortMalloc(uxArraySize * 0x24);
  if (pxTaskStatusArray != (TaskStatus_t *)0x0) {
    uxArraySize = uxTaskGetSystemState(pxTaskStatusArray,uxArraySize,(uint32_t *)0x0);
    if (uxArraySize != 0) {
      pTVar1 = pxTaskStatusArray;
      do {
        uVar4 = 0;
        if (pTVar1->eCurrentState < eInvalid) {
          uVar4 = (uint)(byte)"XRBSD"[pTVar1->eCurrentState];
        }
        strcpy(pcWriteBuffer,pTVar1->pcTaskName);
        sVar2 = strlen(pcWriteBuffer);
        if (sVar2 < 0xf) {
          pcVar3 = pcWriteBuffer + sVar2;
          do {
            *pcVar3 = ' ';
            pcVar3 = pcVar3 + 1;
          } while (pcWriteBuffer + 0xf != pcVar3);
          sVar2 = 0xf;
        }
        pcWriteBuffer = pcWriteBuffer + sVar2;
        *pcWriteBuffer = '\0';
        sprintf(pcWriteBuffer,"\t%c\t%u\t%u\t%u\t%p\r\n",uVar4,pTVar1->uxCurrentPriority,
                (uint)pTVar1->usStackHighWaterMark,pTVar1->xTaskNumber,pTVar1->pxStackBase);
        sVar2 = strlen(pcWriteBuffer);
        pTVar1 = pTVar1 + 1;
        pcWriteBuffer = pcWriteBuffer + sVar2;
      } while (pTVar1 != pxTaskStatusArray + uxArraySize);
    }
    vPortFree(pxTaskStatusArray);
    return;
  }
  return;
}



TickType_t uxTaskResetEventItemValue(void)

{
  TickType_t TVar1;
  
  TVar1 = (pxCurrentTCB->xEventListItem).xItemValue;
  (pxCurrentTCB->xEventListItem).xItemValue = 0x20 - pxCurrentTCB->uxPriority;
  return TVar1;
}



TaskHandle_t pvTaskIncrementMutexHeldCount(void)

{
  if (pxCurrentTCB != (TCB_t *)0x0) {
    pxCurrentTCB->uxMutexesHeld = pxCurrentTCB->uxMutexesHeld + 1;
  }
  return (TaskHandle_t)pxCurrentTCB;
}


/*
Unable to decompile 'ulTaskNotifyTake'
Cause: Exception while decompiling 2303116c: Decompiler process died

*/

/*
Unable to decompile 'xTaskNotifyWait'
Cause: Exception while decompiling 23031212: Decompiler process died

*/

/*
Unable to decompile 'xTaskGenericNotify'
Cause: 
Low-level Error: Assignment to constant at r0x2303130c
*/


BaseType_t
xTaskGenericNotifyFromISR
          (TaskHandle_t xTaskToNotify,uint32_t ulValue,eNotifyAction eAction,
          uint32_t *pulPreviousNotificationValue,BaseType_t *pxHigherPriorityTaskWoken)

{
  uint8_t uVar1;
  undefined3 in_register_00002031;
  
  if (xTaskToNotify == (TaskHandle_t)0x0) {
    vAssertCalled();
  }
  if (pulPreviousNotificationValue != (uint32_t *)0x0) {
    *pulPreviousNotificationValue = xTaskToNotify->ulNotifiedValue;
  }
  uVar1 = xTaskToNotify->ucNotifyState;
  xTaskToNotify->ucNotifyState = '\x02';
  switch(CONCAT31(in_register_00002031,eAction)) {
  case 0:
    break;
  case 1:
    xTaskToNotify->ulNotifiedValue = ulValue | xTaskToNotify->ulNotifiedValue;
    break;
  case 2:
    xTaskToNotify->ulNotifiedValue = xTaskToNotify->ulNotifiedValue + 1;
    break;
  case 4:
    if (uVar1 == '\x02') {
      return 0;
    }
  case 3:
    xTaskToNotify->ulNotifiedValue = ulValue;
    break;
  default:
    if (xTaskToNotify->ulNotifiedValue != 0xffffffff) {
      vAssertCalled();
    }
  }
  if (uVar1 == '\x01') {
    if ((xTaskToNotify->xEventListItem).pvContainer != (xLIST *)0x0) {
      vAssertCalled();
    }
    if (uxSchedulerSuspended == 0) {
      uxListRemove(&xTaskToNotify->xStateListItem);
      uxTopReadyPriority = 1 << (xTaskToNotify->uxPriority & 0x1f) | uxTopReadyPriority;
      vListInsertEnd(pxReadyTasksLists + xTaskToNotify->uxPriority,&xTaskToNotify->xStateListItem);
    }
    else {
      vListInsertEnd(&xPendingReadyList,&xTaskToNotify->xEventListItem);
    }
    if (pxCurrentTCB->uxPriority < xTaskToNotify->uxPriority) {
      if (pxHigherPriorityTaskWoken != (BaseType_t *)0x0) {
        *pxHigherPriorityTaskWoken = 1;
      }
      xYieldPending = 1;
    }
  }
  return 1;
}



void vTaskNotifyGiveFromISR(TaskHandle_t xTaskToNotify,BaseType_t *pxHigherPriorityTaskWoken)

{
  uint8_t uVar1;
  
  if (xTaskToNotify == (TaskHandle_t)0x0) {
    vAssertCalled();
  }
  uVar1 = xTaskToNotify->ucNotifyState;
  xTaskToNotify->ucNotifyState = '\x02';
  xTaskToNotify->ulNotifiedValue = xTaskToNotify->ulNotifiedValue + 1;
  if (uVar1 == '\x01') {
    if ((xTaskToNotify->xEventListItem).pvContainer != (xLIST *)0x0) {
      vAssertCalled();
    }
    if (uxSchedulerSuspended == 0) {
      uxListRemove(&xTaskToNotify->xStateListItem);
      uxTopReadyPriority = 1 << (xTaskToNotify->uxPriority & 0x1f) | uxTopReadyPriority;
      vListInsertEnd(pxReadyTasksLists + xTaskToNotify->uxPriority,&xTaskToNotify->xStateListItem);
    }
    else {
      vListInsertEnd(&xPendingReadyList,&xTaskToNotify->xEventListItem);
    }
    if (pxCurrentTCB->uxPriority < xTaskToNotify->uxPriority) {
      if (pxHigherPriorityTaskWoken != (BaseType_t *)0x0) {
        *pxHigherPriorityTaskWoken = 1;
      }
      xYieldPending = 1;
      return;
    }
  }
  return;
}



BaseType_t xTaskNotifyStateClear(TaskHandle_t xTask)

{
  bool bVar1;
  
  if (xTask == (TaskHandle_t)0x0) {
    xTask = (TaskHandle_t)pxCurrentTCB;
  }
  if (xSchedulerRunning != 0) {
    vTaskEnterCritical();
  }
  bVar1 = ((TCB_t *)xTask)->ucNotifyState == '\x02';
  if (bVar1) {
    ((TCB_t *)xTask)->ucNotifyState = '\0';
  }
  if ((xSchedulerRunning != 0) && (pxCurrentTCB->uxCriticalNesting != 0)) {
    vTaskExitCritical();
  }
  return (uint)bVar1;
}



void prvCheckForValidListAndQueue(void)

{
  uint8_t ucStaticTimerQueueStorage [64];
  StaticQueue_t xStaticTimerQueue;
  
  vTaskEnterCritical();
  if (xTimerQueue == (QueueHandle_t)0x0) {
    vListInitialise(&xActiveTimerList1);
    vListInitialise(&xActiveTimerList2);
    pxCurrentTimerList = &xActiveTimerList1;
    pxOverflowTimerList = &xActiveTimerList2;
    xTimerQueue = xQueueGenericCreateStatic
                            (4,0x10,ucStaticTimerQueueStorage,&xStaticTimerQueue,'\0');
    if (xTimerQueue != (QueueHandle_t)0x0) {
      vQueueAddToRegistry(xTimerQueue,"TmrQ");
    }
  }
  vTaskExitCritical();
  return;
}



BaseType_t
prvInsertTimerInActiveList
          (Timer_t *pxTimer,TickType_t xNextExpiryTime,TickType_t xTimeNow,TickType_t xCommandTime)

{
  (pxTimer->xTimerListItem).xItemValue = xNextExpiryTime;
  *(Timer_t **)&(pxTimer->xTimerListItem).pvOwner = pxTimer;
  if (xTimeNow < xNextExpiryTime) {
    if ((xCommandTime <= xTimeNow) || (xNextExpiryTime < xCommandTime)) {
      vListInsert(pxCurrentTimerList,&pxTimer->xTimerListItem);
      return 0;
    }
  }
  else {
    if (xTimeNow - xCommandTime < pxTimer->xTimerPeriodInTicks) {
      vListInsert(pxOverflowTimerList,&pxTimer->xTimerListItem);
      return 0;
    }
  }
  return 1;
}



BaseType_t xTimerCreateTimerTask(void)

{
  StaticTask_t *pSStack28;
  StaticTask_t *pxTimerTaskTCBBuffer;
  StackType_t *pxTimerTaskStackBuffer;
  uint32_t ulTimerTaskStackSize;
  
  prvCheckForValidListAndQueue();
  if (xTimerQueue != (QueueHandle_t)0x0) {
    pSStack28 = (StaticTask_t *)0x0;
    pxTimerTaskTCBBuffer = (StaticTask_t *)0x0;
    vApplicationGetTimerTaskMemory
              (&pSStack28,(StackType_t **)&pxTimerTaskTCBBuffer,(uint32_t *)&pxTimerTaskStackBuffer)
    ;
    xTimerTaskHandle =
         xTaskCreateStatic(prvTimerTask,"Tmr Svc",(uint32_t)pxTimerTaskStackBuffer,(void *)0x0,0x1f,
                           (StackType_t *)pxTimerTaskTCBBuffer,pSStack28);
    if (xTimerTaskHandle != (TaskHandle_t)0x0) {
      return 1;
    }
  }
  vAssertCalled();
  return 0;
}



// WARNING: Removing unreachable block (ram,0x230317ba)

TimerHandle_t
xTimerCreateStatic(char *pcTimerName,TickType_t xTimerPeriodInTicks,UBaseType_t uxAutoReload,
                  void *pvTimerID,TimerCallbackFunction_t *pxCallbackFunction,
                  StaticTimer_t *pxTimerBuffer)

{
  size_t xSize;
  
  if (pxTimerBuffer == (StaticTimer_t *)0x0) {
    vAssertCalled(0x2c);
  }
  else {
    pxTimerBuffer->ucDummy8 = '\x02';
    if (xTimerPeriodInTicks == 0) {
      vAssertCalled();
    }
    prvCheckForValidListAndQueue();
    *(char **)&pxTimerBuffer->pvDummy1 = pcTimerName;
    pxTimerBuffer->xDummy3 = xTimerPeriodInTicks;
    pxTimerBuffer->pvDummy5 = pvTimerID;
    *(TimerCallbackFunction_t **)&pxTimerBuffer->pvDummy6 = pxCallbackFunction;
    vListInitialiseItem((ListItem_t *)&pxTimerBuffer->xDummy2);
    if (uxAutoReload != 0) {
      pxTimerBuffer->ucDummy8 = pxTimerBuffer->ucDummy8 | 4;
    }
  }
  return (TimerHandle_t)pxTimerBuffer;
}



// WARNING: Could not reconcile some variable overlaps

BaseType_t
xTimerGenericCommand
          (TimerHandle_t xTimer,BaseType_t xCommandID,TickType_t xOptionalValue,
          BaseType_t *pxHigherPriorityTaskWoken,TickType_t xTicksToWait)

{
  BaseType_t BVar1;
  BaseType_t BStack48;
  DaemonTaskMessage_t xMessage;
  
  if (xTimer == (TimerHandle_t)0x0) {
    vAssertCalled();
  }
  BVar1 = 0;
  if (xTimerQueue != (QueueHandle_t)0x0) {
    BStack48 = xCommandID;
    xMessage.xMessageID = xOptionalValue;
    xMessage.u._0_4_ = xTimer;
    if (5 < xCommandID) {
      BVar1 = xQueueGenericSendFromISR(xTimerQueue,&BStack48,pxHigherPriorityTaskWoken,0);
      return BVar1;
    }
    BVar1 = xTaskGetSchedulerState();
    if (BVar1 == 2) {
      BVar1 = xQueueGenericSend(xTimerQueue,&BStack48,xTicksToWait,0);
      return BVar1;
    }
    BVar1 = xQueueGenericSend(xTimerQueue,&BStack48,0,0);
  }
  return BVar1;
}



void prvSwitchTimerLists(void)

{
  List_t *pxList;
  TimerHandle_t xTimer;
  BaseType_t BVar1;
  xLIST_ITEM *pxVar2;
  uint uVar3;
  uint xOptionalValue;
  
  while (pxList = pxCurrentTimerList, pxCurrentTimerList->uxNumberOfItems != 0) {
    pxVar2 = (pxCurrentTimerList->xListEnd).pxNext;
    xTimer = (TimerHandle_t)pxVar2->pvOwner;
    xOptionalValue = pxVar2->xItemValue;
    uxListRemove(&xTimer->xTimerListItem);
    (*xTimer->pxCallbackFunction)(xTimer);
    pxList = pxCurrentTimerList;
    if ((xTimer->ucStatus & 4) != 0) {
      uVar3 = xTimer->xTimerPeriodInTicks + xOptionalValue;
      if (xOptionalValue < uVar3) {
        (xTimer->xTimerListItem).xItemValue = uVar3;
        *(TimerHandle_t *)&(xTimer->xTimerListItem).pvOwner = xTimer;
        vListInsert(pxList,&xTimer->xTimerListItem);
      }
      else {
        BVar1 = xTimerGenericCommand(xTimer,0,xOptionalValue,(BaseType_t *)0x0,0);
        if (BVar1 == 0) {
          vAssertCalled();
        }
      }
    }
  }
  pxCurrentTimerList = pxOverflowTimerList;
  pxOverflowTimerList = pxList;
  return;
}



// WARNING: Could not reconcile some variable overlaps

void prvTimerTask(void *pvParameters)

{
  uint xTimeNow;
  BaseType_t BVar1;
  TickType_t xTimeNow_00;
  TickType_t TVar2;
  uint xWaitIndefinitely;
  UBaseType_t xCommandTime;
  Timer_t *pxTimer;
  uint uStack64;
  DaemonTaskMessage_t xMessage;
  
  do {
    xCommandTime = pxCurrentTimerList->uxNumberOfItems;
    if (xCommandTime == 0) {
      vTaskSuspendAll(pvParameters);
      xTimeNow = xTaskGetTickCount();
      if (xTimeNow < xLastTime_2297) goto LAB_23031aa2;
      xWaitIndefinitely = (uint)(pxOverflowTimerList->uxNumberOfItems == 0);
LAB_2303199c:
      xLastTime_2297 = xTimeNow;
      vQueueWaitForMessageRestricted(xTimerQueue,xCommandTime - xTimeNow,xWaitIndefinitely);
      BVar1 = xTaskResumeAll();
      if (BVar1 == 0) {
        ecall();
      }
    }
    else {
      xCommandTime = ((pxCurrentTimerList->xListEnd).pxNext)->xItemValue;
      vTaskSuspendAll(pvParameters);
      xTimeNow = xTaskGetTickCount();
      if (xTimeNow < xLastTime_2297) {
LAB_23031aa2:
        prvSwitchTimerLists();
        xLastTime_2297 = xTimeNow;
        xTaskResumeAll();
      }
      else {
        xWaitIndefinitely = 0;
        if (xTimeNow < xCommandTime) goto LAB_2303199c;
        xLastTime_2297 = xTimeNow;
        xTaskResumeAll();
        pxTimer = (Timer_t *)((pxCurrentTimerList->xListEnd).pxNext)->pvOwner;
        uxListRemove(&pxTimer->xTimerListItem);
        if ((pxTimer->ucStatus & 4) == 0) {
          pxTimer->ucStatus = pxTimer->ucStatus & 0xfe;
        }
        else {
          BVar1 = prvInsertTimerInActiveList
                            (pxTimer,pxTimer->xTimerPeriodInTicks + xCommandTime,xTimeNow,
                             xCommandTime);
          if ((BVar1 != 0) &&
             (BVar1 = xTimerGenericCommand
                                ((TimerHandle_t)pxTimer,0,xCommandTime,(BaseType_t *)0x0,0),
             BVar1 == 0)) {
            vAssertCalled();
          }
        }
        (*pxTimer->pxCallbackFunction)((TimerHandle_t)pxTimer);
      }
    }
    while (pvParameters = (void *)xQueueReceive(xTimerQueue,&uStack64,0),
          pvParameters != (void *)0x0) {
      if ((-1 < (int)uStack64) ||
         ((*(code *)xMessage.xMessageID)((Timer_t *)xMessage.u,xMessage.u._4_4_,xMessage.xMessageID)
         , -1 < (int)uStack64)) {
        pxTimer = (Timer_t *)xMessage.u;
        if ((((Timer_t *)xMessage.u)->xTimerListItem).pvContainer != (xLIST *)0x0) {
          uxListRemove(&((Timer_t *)xMessage.u)->xTimerListItem);
        }
        xTimeNow_00 = xTaskGetTickCount();
        if (xTimeNow_00 < xLastTime_2297) {
          prvSwitchTimerLists();
        }
        xLastTime_2297 = xTimeNow_00;
        switch(uStack64) {
        case 0:
        case 1:
        case 2:
        case 6:
        case 7:
          pxTimer->ucStatus = pxTimer->ucStatus | 1;
          BVar1 = prvInsertTimerInActiveList
                            (pxTimer,pxTimer->xTimerPeriodInTicks + xMessage.xMessageID,xTimeNow_00,
                             xMessage.xMessageID);
          if (((BVar1 != 0) &&
              ((*pxTimer->pxCallbackFunction)((TimerHandle_t)pxTimer), (pxTimer->ucStatus & 4) != 0)
              ) && (BVar1 = xTimerGenericCommand
                                      ((TimerHandle_t)pxTimer,0,
                                       xMessage.xMessageID + pxTimer->xTimerPeriodInTicks,
                                       (BaseType_t *)0x0,0), BVar1 == 0)) {
            vAssertCalled();
          }
          break;
        case 3:
        case 8:
          pxTimer->ucStatus = pxTimer->ucStatus & 0xfe;
          break;
        case 4:
        case 9:
          pxTimer->ucStatus = pxTimer->ucStatus | 1;
          pxTimer->xTimerPeriodInTicks = xMessage.xMessageID;
          TVar2 = xMessage.xMessageID;
          if (xMessage.xMessageID == 0) {
            vAssertCalled();
            TVar2 = pxTimer->xTimerPeriodInTicks;
          }
          prvInsertTimerInActiveList(pxTimer,TVar2 + xTimeNow_00,xTimeNow_00,xTimeNow_00);
          break;
        case 5:
          if ((pxTimer->ucStatus & 2) == 0) {
            vPortFree(pxTimer);
          }
          else {
            pxTimer->ucStatus = pxTimer->ucStatus & 0xfe;
          }
        }
      }
    }
  } while( true );
}



void * pvTimerGetTimerID(TimerHandle_t xTimer)

{
  void *pvVar1;
  
  if (xTimer == (TimerHandle_t)0x0) {
    vAssertCalled();
  }
  vTaskEnterCritical();
  pvVar1 = xTimer->pvTimerID;
  vTaskExitCritical();
  return pvVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void vPortSetupTimerInterrupt(void)

{
  _DAT_02004000 = _DAT_0200bff8 + 10000;
  _DAT_02004004 = (uint)(_DAT_0200bff8 + 10000 < _DAT_0200bff8) + _DAT_0200bffc;
  ullNextTime._0_4_ = _DAT_0200bff8 + 20000;
  ullNextTime._4_4_ = _DAT_0200bffc + (uint)(_DAT_0200bff8 + 20000 < _DAT_0200bff8);
  return;
}


/*
Unable to decompile 'xPortStartScheduler'
Cause: Exception while decompiling 23031b92: Decompiler process died

*/

/*
Unable to decompile 'xPortStartFirstTask'
Cause: Exception while decompiling 23031f00: Decompiler process died

*/


// WARNING: Removing unreachable block (ram,0x23032000)

void pxPortInitialiseStack(int param_1,undefined4 param_2,undefined4 param_3)

{
  int iVar1;
  undefined4 *puVar2;
  uint in_mstatus;
  
  *(uint *)(param_1 + -4) = in_mstatus & 0xfffffff7 | 0x1880;
  *(undefined4 *)(param_1 + -0x5c) = param_3;
  puVar2 = (undefined4 *)(param_1 + -0x74);
  *puVar2 = 0;
  iVar1 = 0x22;
  while (iVar1 != 0) {
    puVar2 = puVar2 + -1;
    *puVar2 = 0;
    iVar1 = iVar1 + -1;
  }
  puVar2[-1] = param_2;
  return;
}



void prvInsertBlockIntoFreeList(BlockLink_t *pxBlockToInsert)

{
  size_t sVar1;
  BlockLink_t *pBVar2;
  BlockLink_t *pBVar3;
  
  pBVar3 = &xStart;
  do {
    pBVar2 = pBVar3;
    pBVar3 = (BlockLink_t *)pBVar2->pxNextFreeBlock;
  } while (pBVar3 < pxBlockToInsert);
  sVar1 = pxBlockToInsert->xBlockSize;
  if (pxBlockToInsert == (BlockLink_t *)(pBVar2->xBlockSize + (int)&pBVar2->pxNextFreeBlock)) {
    sVar1 = pBVar2->xBlockSize + sVar1;
    pBVar2->xBlockSize = sVar1;
    pxBlockToInsert = pBVar2;
  }
  if ((pBVar3 == (BlockLink_t *)(sVar1 + (int)&pxBlockToInsert->pxNextFreeBlock)) &&
     (pBVar3 != pxEnd)) {
    pxBlockToInsert->xBlockSize = sVar1 + pBVar3->xBlockSize;
    pxBlockToInsert->pxNextFreeBlock = pBVar2->pxNextFreeBlock->pxNextFreeBlock;
  }
  else {
    *(BlockLink_t **)&pxBlockToInsert->pxNextFreeBlock = pBVar3;
  }
  if (pxBlockToInsert != pBVar2) {
    *(BlockLink_t **)&pBVar2->pxNextFreeBlock = pxBlockToInsert;
  }
  return;
}



void * pvPortMalloc(size_t xWantedSize)

{
  size_t sVar1;
  size_t sVar2;
  BlockLink_t *pBVar3;
  A_BLOCK_LINK *pAVar4;
  BlockLink_t *pxBlockToInsert;
  uint uVar5;
  uint uVar6;
  
  if (pxEnd == (BlockLink_t *)0x0) {
    vAssertCalled();
  }
  vTaskSuspendAll();
  sVar2 = xFreeBytesRemaining;
  sVar1 = xBlockAllocatedBit;
  if (((xBlockAllocatedBit & xWantedSize) == 0) && (xWantedSize != 0)) {
    uVar6 = xWantedSize + 8;
    if ((uVar6 & 7) != 0) {
      uVar6 = (uVar6 & 0xfffffff8) + 8;
    }
    if ((uVar6 != 0) && (uVar6 <= xFreeBytesRemaining)) {
      pAVar4 = xStart.pxNextFreeBlock;
      pBVar3 = &xStart;
      do {
        pxBlockToInsert = pBVar3;
        pBVar3 = (BlockLink_t *)pAVar4;
        if (uVar6 <= pBVar3->xBlockSize) break;
        pAVar4 = pBVar3->pxNextFreeBlock;
      } while (pBVar3->pxNextFreeBlock != (A_BLOCK_LINK *)0x0);
      if (pxEnd != pBVar3) {
        pAVar4 = pxBlockToInsert->pxNextFreeBlock;
        pxBlockToInsert->pxNextFreeBlock = pBVar3->pxNextFreeBlock;
        uVar5 = pBVar3->xBlockSize;
        pAVar4 = pAVar4 + 1;
        if (0x10 < uVar5 - uVar6) {
          pxBlockToInsert = (BlockLink_t *)((int)&pBVar3->pxNextFreeBlock + uVar6);
          pxBlockToInsert->xBlockSize = uVar5 - uVar6;
          pBVar3->xBlockSize = uVar6;
          prvInsertBlockIntoFreeList(pxBlockToInsert);
          uVar5 = pBVar3->xBlockSize;
        }
        xFreeBytesRemaining = sVar2 - uVar5;
        if (xFreeBytesRemaining < xMinimumEverFreeBytesRemaining) {
          xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
        }
        pBVar3->xBlockSize = sVar1 | uVar5;
        pBVar3->pxNextFreeBlock = (A_BLOCK_LINK *)0x0;
        xTaskResumeAll();
        if (pAVar4 != (A_BLOCK_LINK *)0x0) {
          return pAVar4;
        }
        goto LAB_230321be;
      }
    }
  }
  xTaskResumeAll();
LAB_230321be:
  vApplicationMallocFailedHook();
  return (void *)0x0;
}



void vPortFree(void *pv)

{
  uint uVar1;
  
  if (pv == (void *)0x0) {
    return;
  }
  uVar1 = *(uint *)((int)pv + -4);
  if ((uVar1 & xBlockAllocatedBit) == 0) {
    vAssertCalled();
    if (*(int *)((int)pv + -8) == 0) {
      uVar1 = *(uint *)((int)pv + -4);
      if ((uVar1 & xBlockAllocatedBit) == 0) {
        return;
      }
      goto LAB_230322ce;
    }
  }
  else {
    if (*(int *)((int)pv + -8) == 0) goto LAB_230322ce;
  }
  vAssertCalled();
  uVar1 = *(uint *)((int)pv + -4);
  if (((uVar1 & xBlockAllocatedBit) == 0) || (*(int *)((int)pv + -8) != 0)) {
    return;
  }
LAB_230322ce:
  *(uint *)((int)pv + -4) = ~xBlockAllocatedBit & uVar1;
  vTaskSuspendAll();
  xFreeBytesRemaining = *(int *)((int)pv + -4) + xFreeBytesRemaining;
  prvInsertBlockIntoFreeList((BlockLink_t *)((int)pv + -8));
  xTaskResumeAll();
  return;
}



size_t xPortGetFreeHeapSize(void)

{
  return xFreeBytesRemaining;
}



void vPortDefineHeapRegions(HeapRegion_t *pxHeapRegions)

{
  size_t sVar1;
  BlockLink_t *pBVar2;
  BlockLink_t *pBVar3;
  BlockLink_t *pBVar4;
  A_BLOCK_LINK *pAVar5;
  int iVar6;
  size_t sVar7;
  
  if (pxEnd == (BlockLink_t *)0x0) {
    sVar1 = pxHeapRegions->xSizeInBytes;
    pBVar4 = pxEnd;
  }
  else {
    vAssertCalled();
    sVar1 = pxHeapRegions->xSizeInBytes;
    pBVar4 = pxEnd;
  }
  pxEnd = pBVar4;
  if (sVar1 == 0) {
    xMinimumEverFreeBytesRemaining = 0;
  }
  else {
    iVar6 = 0;
    sVar7 = 0;
    do {
      pBVar3 = (BlockLink_t *)pxHeapRegions->pucStartAddress;
      pBVar2 = pBVar3;
      if (((uint)pBVar3 & 7) != 0) {
        pBVar2 = (BlockLink_t *)((int)&pBVar3->xBlockSize + 3U & 0xfffffff8);
        sVar1 = (int)pBVar3 + (sVar1 - (int)pBVar2);
      }
      if (iVar6 == 0) {
        xStart.xBlockSize = 0;
        pBVar3 = pBVar4;
        xStart.pxNextFreeBlock = (A_BLOCK_LINK *)pBVar2;
      }
      else {
        if (pBVar4 == (BlockLink_t *)0x0) {
          vAssertCalled();
          pBVar4 = pxEnd;
        }
        pBVar3 = pBVar4;
        if (pBVar2 <= pBVar4) {
          vAssertCalled();
          pBVar3 = pxEnd;
        }
      }
      pBVar4 = (BlockLink_t *)((int)&pBVar2[-1].pxNextFreeBlock + sVar1 & 0xfffffff8);
      ((A_BLOCK_LINK *)pBVar4)->xBlockSize = 0;
      ((A_BLOCK_LINK *)pBVar4)->pxNextFreeBlock = (A_BLOCK_LINK *)0x0;
      pAVar5 = (A_BLOCK_LINK *)((int)pBVar4 - (int)pBVar2);
      pxEnd = pBVar4;
      *(A_BLOCK_LINK **)&pBVar2->xBlockSize = pAVar5;
      *(BlockLink_t **)&pBVar2->pxNextFreeBlock = pBVar4;
      if (pBVar3 != (BlockLink_t *)0x0) {
        *(BlockLink_t **)&pBVar3->pxNextFreeBlock = pBVar2;
        pAVar5 = (A_BLOCK_LINK *)pBVar2->xBlockSize;
      }
      sVar1 = pxHeapRegions[1].xSizeInBytes;
      sVar7 = (int)&pAVar5->pxNextFreeBlock + sVar7;
      iVar6 = iVar6 + 1;
      pxHeapRegions = pxHeapRegions + 1;
    } while (sVar1 != 0);
    xMinimumEverFreeBytesRemaining = sVar7;
    if (sVar7 != 0) {
      xBlockAllocatedBit = 0x80000000;
      xFreeBytesRemaining = sVar7;
      return;
    }
  }
  xFreeBytesRemaining = xMinimumEverFreeBytesRemaining;
  vAssertCalled();
  xBlockAllocatedBit = 0x80000000;
  return;
}



void uart_generic_notify_handler(uint8_t id)

{
  uint uVar1;
  uint uVar2;
  undefined3 in_register_00002029;
  int iVar3;
  uint32_t uVar4;
  
  iVar3 = CONCAT31(in_register_00002029,id);
  uVar4 = uartAddr[iVar3];
  uVar2 = *(uint *)(uVar4 + 0x20);
  uVar1 = *(uint *)(uVar4 + 0x24);
  if (((uVar2 & 1) != 0) && ((uVar1 & 1) == 0)) {
    *(undefined4 *)(uVar4 + 0x28) = 1;
  }
  if (((uVar2 & 2) != 0) && ((uVar1 & 2) == 0)) {
    *(undefined4 *)(uVar4 + 0x28) = 2;
    if (g_uart_notify_arg[iVar3].rx_cb != (cb_uart_notify_t *)0x0) {
      (*g_uart_notify_arg[iVar3].rx_cb)(g_uart_notify_arg[iVar3].rx_cb_arg);
    }
  }
  if (((uVar2 & 4) != 0) && ((uVar1 & 4) == 0)) {
    if (g_uart_notify_arg[iVar3].tx_cb != (cb_uart_notify_t *)0x0) {
      (*g_uart_notify_arg[iVar3].tx_cb)(g_uart_notify_arg[iVar3].tx_cb_arg);
    }
  }
  if (((uVar2 & 8) != 0) && ((uVar1 & 8) == 0)) {
    if (g_uart_notify_arg[iVar3].rx_cb != (cb_uart_notify_t *)0x0) {
      (*g_uart_notify_arg[iVar3].rx_cb)(g_uart_notify_arg[iVar3].rx_cb_arg);
    }
  }
  if (((uVar2 & 0x10) != 0) && ((uVar1 & 0x10) == 0)) {
    *(undefined4 *)(uVar4 + 0x28) = 0x10;
    if (g_uart_notify_arg[iVar3].rx_cb != (cb_uart_notify_t *)0x0) {
      (*g_uart_notify_arg[iVar3].rx_cb)(g_uart_notify_arg[iVar3].rx_cb_arg);
    }
  }
  if (((uVar2 & 0x20) != 0) && ((uVar1 & 0x20) == 0)) {
    *(undefined4 *)(uVar4 + 0x28) = 0x20;
  }
  return;
}



void UART0_IRQHandler(void)

{
  uart_generic_notify_handler('\0');
  return;
}



void UART1_IRQHandler(void)

{
  uart_generic_notify_handler('\x01');
  return;
}



// WARNING: Could not reconcile some variable overlaps

int bl_uart_init(uint8_t id,uint8_t tx_pin,uint8_t rx_pin,uint8_t cts_pin,uint8_t rts_pin,
                uint32_t baudrate)

{
  uint8_t uart_clk_init;
  GLB_UART_SIG_FUN_Type fun;
  undefined3 in_register_00002029;
  GLB_UART_SIG_FUN_Type fun_00;
  UART_FifoCfg_Type UStack60;
  UART_FifoCfg_Type fifoCfg;
  GLB_GPIO_Cfg_Type cfg;
  UART_CFG_Type uartCfg;
  
  memcpy(&cfg.drive,&DAT_23082820,0x10);
  UStack60 = DAT_4200d9c0;
  if (uart_clk_init == '\0') {
    GLB_Set_UART_CLK('\x01',HBN_UART_CLK_160M,'\x03');
    uart_clk_init = '\x01';
  }
  fifoCfg.rxFifoDmaThreshold = '\a';
  fifoCfg._2_2_ = 2;
  cfg._0_2_ = 0x101;
  fifoCfg.txFifoDmaThreshold = rx_pin;
  GLB_GPIO_Init((GLB_GPIO_Cfg_Type *)&fifoCfg);
  fifoCfg._2_2_ = 2;
  fifoCfg.txFifoDmaThreshold = tx_pin;
  GLB_GPIO_Init((GLB_GPIO_Cfg_Type *)&fifoCfg);
  if (CONCAT31(in_register_00002029,id) == 0) {
    fun = GLB_UART_SIG_FUN_UART0_RXD;
    fun_00 = GLB_UART_SIG_FUN_UART0_TXD;
  }
  else {
    fun = GLB_UART_SIG_FUN_UART1_RXD;
    fun_00 = GLB_UART_SIG_FUN_UART1_TXD;
  }
  GLB_UART_Fun_Sel(tx_pin & 7,fun_00);
  GLB_UART_Fun_Sel(rx_pin & 7,fun);
  stack0xffffffd0 = 40000000;
  UART_IntMask(id,UART_INT_ALL,MASK);
  UART_Disable(id,UART_TXRX);
  UART_Init(id,(UART_CFG_Type *)&cfg.drive);
  UART_TxFreeRun(id,ENABLE);
  UART_FifoConfig(id,&UStack60);
  UART_Enable(id,UART_TXRX);
  return 0;
}



int bl_uart_data_send(uint8_t id,uint8_t data)

{
  uint32_t uVar1;
  uint8_t uVar2;
  undefined3 in_register_00002029;
  undefined3 extraout_var;
  
  uVar1 = uartAddr[CONCAT31(in_register_00002029,id)];
  do {
    uVar2 = UART_GetTxFifoCount(id);
  } while (CONCAT31(extraout_var,uVar2) == 0);
  *(uint8_t *)(uVar1 + 0x88) = data;
  return 0;
}



int bl_uart_data_recv(uint8_t id)

{
  uint32_t uVar1;
  uint8_t uVar2;
  undefined3 in_register_00002029;
  undefined3 extraout_var;
  uint uVar3;
  
  uVar1 = uartAddr[CONCAT31(in_register_00002029,id)];
  uVar2 = UART_GetRxFifoCount(id);
  if (CONCAT31(extraout_var,uVar2) == 0) {
    uVar3 = 0xffffffff;
  }
  else {
    uVar3 = (uint)*(byte *)(uVar1 + 0x8c);
  }
  return uVar3;
}



int bl_uart_int_rx_enable(uint8_t id)

{
  UART_SetRxTimeoutValue(id,'\x18');
  UART_IntMask(id,UART_INT_RX_FIFO_REQ,UNMASK);
  UART_IntMask(id,UART_INT_RX_END,UNMASK);
  UART_IntMask(id,UART_INT_RTO,UNMASK);
  return 0;
}



int bl_uart_int_rx_disable(uint8_t id)

{
  UART_IntMask(id,UART_INT_RX_FIFO_REQ,MASK);
  UART_IntMask(id,UART_INT_RX_END,MASK);
  UART_IntMask(id,UART_INT_RTO,MASK);
  return 0;
}



int bl_uart_int_tx_enable(uint8_t id)

{
  UART_IntMask(id,UART_INT_TX_FIFO_REQ,UNMASK);
  return 0;
}



int bl_uart_int_tx_disable(uint8_t id)

{
  UART_IntMask(id,UART_INT_TX_FIFO_REQ,MASK);
  return 0;
}



int bl_uart_flush(uint8_t id)

{
  uint8_t uVar1;
  undefined3 extraout_var;
  
  do {
    uVar1 = UART_GetTxFifoCount(id);
  } while (CONCAT31(extraout_var,uVar1) != 0x20);
  return 0;
}



void bl_uart_getdefconfig(uint8_t id,uint8_t *parity)

{
  if (parity != (uint8_t *)0x0) {
    *parity = '\0';
  }
  return;
}



// WARNING: Variable defined which should be unmapped: UartCfg
// WARNING: Could not reconcile some variable overlaps

void bl_uart_setconfig(uint8_t id,uint32_t baudrate,UART_Parity_Type parity)

{
  undefined auStack32 [4];
  UART_CFG_Type UartCfg;
  
  memcpy(auStack32,&DAT_23082830,0x10);
  UartCfg.uartClk = baudrate;
  UartCfg.baudRate._2_1_ = parity;
  UART_Disable(id,UART_TXRX);
  UART_Init(id,(UART_CFG_Type *)auStack32);
  UART_TxFreeRun(id,ENABLE);
  UART_Enable(id,UART_TXRX);
  return;
}



void bl_uart_setbaud(uint8_t id,uint32_t baud)

{
  bl_uart_setconfig(id,baud,UART_PARITY_NONE);
  return;
}



int bl_uart_int_enable(uint8_t id)

{
  undefined3 in_register_00002029;
  uint source;
  
  if (CONCAT31(in_register_00002029,id) == 0) {
    bl_uart_int_rx_enable(id);
    bl_uart_int_tx_enable('\0');
    bl_irq_register(0x2d,UART0_IRQHandler);
    source = 0x2d;
  }
  else {
    if (CONCAT31(in_register_00002029,id) != 1) {
      return -1;
    }
    bl_uart_int_rx_enable(id);
    bl_uart_int_tx_enable('\x01');
    bl_irq_register(0x2e,UART1_IRQHandler);
    source = 0x2e;
  }
  bl_irq_enable(source);
  return 0;
}



int bl_uart_int_disable(uint8_t id)

{
  undefined3 in_register_00002029;
  uint source;
  
  if (CONCAT31(in_register_00002029,id) == 0) {
    bl_uart_int_rx_disable(id);
    bl_uart_int_tx_disable('\0');
    bl_irq_unregister(0x2d,UART0_IRQHandler);
    source = 0x2d;
  }
  else {
    if (CONCAT31(in_register_00002029,id) != 1) {
      return -1;
    }
    bl_uart_int_rx_disable(id);
    bl_uart_int_tx_disable('\x01');
    bl_irq_unregister(0x2e,UART1_IRQHandler);
    source = 0x2e;
  }
  bl_irq_disable(source);
  return 0;
}



int bl_uart_int_rx_notify_register(uint8_t id,cb_uart_notify_t *cb,void *arg)

{
  undefined3 in_register_00002029;
  uint uVar1;
  
  uVar1 = CONCAT31(in_register_00002029,id);
  if (uVar1 < 2) {
    g_uart_notify_arg[uVar1].rx_cb = cb;
    g_uart_notify_arg[uVar1].rx_cb_arg = arg;
    return 0;
  }
  return -1;
}



int bl_uart_int_tx_notify_register(uint8_t id,cb_uart_notify_t *cb,void *arg)

{
  undefined3 in_register_00002029;
  uint uVar1;
  
  uVar1 = CONCAT31(in_register_00002029,id);
  if (uVar1 < 2) {
    g_uart_notify_arg[uVar1].tx_cb = cb;
    g_uart_notify_arg[uVar1].tx_cb_arg = arg;
    return 0;
  }
  return -1;
}



// WARNING: Removing unreachable block (ram,0x23032876)

int bl_chip_info(char *info)

{
  char *pcVar1;
  undefined *__src;
  uint uVar2;
  uint in_register_90000c04;
  uint32_t misa;
  
  uVar2 = in_register_90000c04 >> 0x1e;
  if (uVar2 == 2) {
    memcpy(info,&DAT_23082b04,4);
    pcVar1 = info + 4;
  }
  else {
    if (uVar2 == 3) {
      memcpy(info,"RV128",5);
      pcVar1 = info + 5;
    }
    else {
      pcVar1 = info + 4;
      if (uVar2 == 1) {
        __src = &DAT_23082afc;
      }
      else {
        __src = &DAT_23082b14;
      }
      memcpy(info,__src,4);
    }
  }
  *pcVar1 = '-';
  pcVar1 = pcVar1 + 1;
  uVar2 = 0;
  do {
    if ((1 << (uVar2 & 0x1f) & in_register_90000c04) != 0) {
      *pcVar1 = (char)uVar2 + 'A';
      pcVar1 = pcVar1 + 1;
    }
    uVar2 = uVar2 + 1;
  } while (uVar2 != 0x1a);
  *pcVar1 = '\0';
  return 0;
}



int bl_chip_banner(char **banner)

{
  *banner = 
  "          \n\r      \n\r       \n\r     \n\r\n\r     \n\r"
  ;
  return 0;
}



int bl_chip_memory_ram(int *num,uint *addr,uint *size,char (*desc) [6])

{
  if (2 < *num) {
    *num = 3;
    *addr = 0x23000000;
    *size = 0x400000;
    strcpy((char *)desc,"flash");
    addr[1] = 0x4200c000;
    size[1] = 0x36000;
    strcpy((char *)(desc + 1),"tcm");
    addr[2] = 0x42042000;
    size[2] = 0xa000;
    strcpy((char *)(desc + 2),"wifi");
    return 0;
  }
  return -1;
}



void _cb_cmd(void *arg)

{
  TickType_t TVar1;
  
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [DMA] [TEST] Callback is working, arg is %p\r\n",TVar1,
              &DAT_2307f16c,"bl_cks.c",0xe5,arg);
  }
  *(undefined4 *)((int)arg + 8) = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 bl_cks_test(void)

{
  ushort uVar1;
  TickType_t TVar2;
  char *format;
  undefined *puVar3;
  undefined4 uVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  undefined2 local_80;
  ushort uStack126;
  undefined4 uStack124;
  undefined4 uStack120;
  bl_dma_item bStack116;
  undefined auStack88 [4];
  undefined4 uStack84;
  undefined4 uStack80;
  undefined2 *puStack76;
  undefined *puStack72;
  undefined **ppuStack68;
  undefined4 uStack64;
  undefined auStack60 [4];
  undefined4 uStack56;
  undefined4 uStack52;
  undefined *puStack48;
  ushort *puStack44;
  undefined4 uStack40;
  undefined4 uStack36;
  
  puStack76 = &local_80;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] --->>> case1 test\r\n",TVar2,&DAT_2307f16c,"bl_cks.c",0x137);
  }
  DAT_4000a700 = 1;
  iVar5 = 0;
  do {
    DAT_4000a704 = data_src1_2802[iVar5];
    iVar5 = iVar5 + 1;
  } while (iVar5 != 0x14);
  uVar6 = (uint)_DAT_4000a708;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] CKS result with LE is %04x, should be %02x%02x\r\n",TVar2,
              &DAT_2307f16c,"bl_cks.c",0x40,uVar6,0x61,0xb8);
  }
  DAT_4000a700 = 2;
  iVar5 = 0;
  do {
    DAT_4000a704 = data_src1_2802[iVar5];
    iVar5 = iVar5 + 1;
  } while (iVar5 != 0x14);
  uVar6 = (uint)_DAT_4000a708;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] CKS result with BE is %04x, should be %02x%02x\r\n",TVar2,
              &DAT_2307f16c,"bl_cks.c",0x48,uVar6,0x61,0xb8);
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN))
    {
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] --->>> case2 test\r\n",TVar2,&DAT_2307f16c,"bl_cks.c",0x139);
    }
  }
  DAT_4000a700 = 1;
  DAT_4000a704 = 0x3f;
  uVar6 = (uint)_DAT_4000a708;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] CKS LE result is %04x, %04x\r\n",TVar2,&DAT_2307f16c,"bl_cks.c",
              0x61,uVar6,0xc0e0);
  }
  uVar1 = _DAT_4000a708;
  DAT_4000a700 = 2;
  DAT_4000a704 = 0x3f;
  uVar6 = (uint)_DAT_4000a708;
  if (_fsymc_level_hal_drv < BLOG_LEVEL_WARN) {
    if (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN) {
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] CKS BE result is %04x, %04x\r\n",TVar2,&DAT_2307f16c,"bl_cks.c",
                0x73,uVar6,0xc0e0);
      if (uVar1 != 0xc0e0) goto LAB_2303332e;
      if ((BLOG_LEVEL_INFO < _fsymc_level_hal_drv) || (BLOG_LEVEL_INFO < _fsymf_level_hal_drvbl_cks)
         ) goto LAB_23032c88;
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      uVar6 = 0xc0e0;
      uVar4 = 0x75;
      format = "[%10u][%s: %s:%4d] ====== Success %04X Checksum=====\r\n";
LAB_23032c7a:
      bl_printk(format,TVar2,&DAT_2307f16c,"bl_cks.c",uVar4,uVar6);
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)
         ) {
        if (TrapNetCounter == 0) {
          TVar2 = xTaskGetTickCount();
        }
        else {
          TVar2 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] --->>> case3 test\r\n",TVar2,&DAT_2307f16c,"bl_cks.c",0x13b);
      }
    }
    else {
      if (_DAT_4000a708 != 0xc0e0) goto LAB_23033338;
    }
  }
  else {
    if (_DAT_4000a708 != 0xc0e0) {
LAB_2303332e:
      if (_fsymc_level_hal_drv < BLOG_LEVEL_WARN) {
LAB_23033338:
        if (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN) {
          if (TrapNetCounter == 0) {
            TVar2 = xTaskGetTickCount();
          }
          else {
            TVar2 = xTaskGetTickCountFromISR();
          }
          uVar4 = 0x77;
          format = "[%10u][%s: %s:%4d] ====== Failed %04X Checksum======\r\n";
          goto LAB_23032c7a;
        }
      }
    }
  }
LAB_23032c88:
  DAT_4000a700 = 1;
  iVar5 = 1000;
  do {
    DAT_4000a704 = 0x3f;
    iVar5 = iVar5 + -1;
  } while (iVar5 != 0);
  uVar6 = 0xf69118;
  while (uVar6 >> 0x10 != 0) {
    uVar6 = (uVar6 & 0xffff) + (uVar6 >> 0x10);
  }
  uVar7 = (uint)_DAT_4000a708;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] CKS LE result is %04x, %04x\r\n",TVar2,&DAT_2307f16c,"bl_cks.c",
              0x91,uVar7,~uVar6 & 0xffff);
  }
  DAT_4000a700 = 2;
  iVar5 = 1000;
  do {
    DAT_4000a704 = 0x3f;
    iVar5 = iVar5 + -1;
  } while (iVar5 != 0);
  uVar6 = 0xf69118;
  while (uVar6 >> 0x10 != 0) {
    uVar6 = (uVar6 & 0xffff) + (uVar6 >> 0x10);
  }
  uVar7 = (uint)_DAT_4000a708;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] CKS BE result is %04x, %04x\r\n",TVar2,&DAT_2307f16c,"bl_cks.c",
              0xa3,uVar7,~uVar6 & 0xffff);
  }
  if (uVar7 == (~uVar6 & 0xffff)) {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN))
    {
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      uVar4 = 0xa5;
      puVar3 = &DAT_2307f16c;
      format = "[%10u][%s: %s:%4d] ====== Success %04X Checksum=====\r\n";
LAB_230330f0:
      bl_printk(format,TVar2,puVar3,"bl_cks.c",uVar4,uVar7);
      goto LAB_230330f4;
    }
  }
  else {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
       (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_ASSERT)) {
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      uVar4 = 0xa7;
      puVar3 = &DAT_23072bcc;
      format = "[%10u][%s: %s:%4d] ====== Failed %04X Checksum======\r\n";
      goto LAB_230330f0;
    }
LAB_230330f4:
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN))
    {
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] --->>> case4 test\r\n",TVar2,&DAT_2307f16c,"bl_cks.c",0x13d);
    }
  }
  DAT_4000a700 = 1;
  DAT_4000a704 = 0xa1;
  uVar6 = (uint)_DAT_4000a708;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] CKS LE result is %04x, %04x\r\n",TVar2,&DAT_2307f16c,"bl_cks.c",
              0xc4,uVar6,0xc03f);
  }
  uVar1 = _DAT_4000a708;
  DAT_4000a700 = 2;
  DAT_4000a704 = 0xa1;
  uVar6 = (uint)_DAT_4000a708;
  if (_fsymc_level_hal_drv < BLOG_LEVEL_WARN) {
    if (BLOG_LEVEL_INFO < _fsymf_level_hal_drvbl_cks) {
      if (_DAT_4000a708 == 0xc03f) goto LAB_23032ef6;
      goto LAB_230332e4;
    }
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] CKS BE result is %04x, %04x\r\n",TVar2,&DAT_2307f16c,"bl_cks.c",
              0xd8,uVar6,0xc03f);
    if (uVar1 != 0xc03f) goto LAB_230332da;
    if ((BLOG_LEVEL_INFO < _fsymc_level_hal_drv) || (BLOG_LEVEL_INFO < _fsymf_level_hal_drvbl_cks))
    goto LAB_23032ef6;
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    uVar6 = 0xc03f;
    uVar4 = 0xda;
    puVar3 = &DAT_2307f16c;
    format = "[%10u][%s: %s:%4d] ====== Success %04X Checksum=====\r\n";
LAB_230331c2:
    bl_printk(format,TVar2,puVar3,"bl_cks.c",uVar4,uVar6);
  }
  else {
    if (_DAT_4000a708 == 0xc03f) goto LAB_23032ef6;
LAB_230332da:
    if (_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) {
LAB_230332e4:
      if (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_ASSERT) {
        if (TrapNetCounter == 0) {
          TVar2 = xTaskGetTickCount();
        }
        else {
          TVar2 = xTaskGetTickCountFromISR();
        }
        uVar4 = 0xdc;
        puVar3 = &DAT_23072bcc;
        format = "[%10u][%s: %s:%4d] ====== Failed %04X Checksum======\r\n";
        goto LAB_230331c2;
      }
    }
  }
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] --->>> case5 test\r\n",TVar2,&DAT_2307f16c,"bl_cks.c",0x13f);
  }
LAB_23032ef6:
  bStack116.arg = &bStack116;
  local_80 = 0x3f1f;
  uStack124 = 1;
  uStack120 = 2;
  uStack126 = 0;
  memset(bStack116.arg,0,0x1c);
  memset(auStack88,0,0x1c);
  memset(auStack60,0,0x1c);
  bStack116.src = &uStack124;
  bStack116.dst = &DAT_4000a700;
  bStack116.next = &puStack76;
  bStack116.ctrl = 0x4480002;
  bStack116.cb = _cb_cmd;
  puStack72 = &DAT_4000a704;
  puStack48 = &DAT_4000a708;
  ppuStack68 = &puStack48;
  puStack44 = &uStack126;
  uStack64 = 0x403e8;
  uStack84 = 0;
  uStack80 = 0;
  uStack40 = 0;
  uStack36 = 0x80240001;
  uStack56 = 0;
  uStack52 = 0;
  bl_dma_copy(bStack116.arg);
  while (bStack116.arg != (bl_dma_item *)0x0) {
    vTaskDelay(2);
  }
  if (uStack126 == 0x6df1) {
    if (BLOG_LEVEL_INFO < _fsymc_level_hal_drv) {
      return 0;
    }
    if (BLOG_LEVEL_INFO < _fsymf_level_hal_drvbl_cks) {
      return 0;
    }
    if (TrapNetCounter == 0) {
      xTaskGetTickCount();
    }
    else {
      xTaskGetTickCountFromISR();
    }
    uVar4 = 0x12f;
    puVar3 = &DAT_2307f16c;
    format = "[%10u][%s: %s:%4d] ====== Success %04X Checksum=====\r\n";
  }
  else {
    if (BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) {
      return 0;
    }
    if (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvbl_cks) {
      return 0;
    }
    if (TrapNetCounter == 0) {
      xTaskGetTickCount();
    }
    else {
      xTaskGetTickCountFromISR();
    }
    uVar4 = 0x131;
    puVar3 = &DAT_23072bcc;
    format = "[%10u][%s: %s:%4d] ====== Failed %04X Checksum======\r\n";
  }
  bl_printk(format,puVar3,"bl_cks.c",uVar4,(uint)uStack126);
  return 0;
}



void _cb_cmd(void *arg)

{
  TickType_t TVar1;
  
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_dma < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [DMA] [TEST] Callback is working, arg is %p\r\n",TVar1,
              &DAT_2307f16c,"bl_dma.c",0x19c,arg);
  }
  *(undefined4 *)((int)arg + 8) = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void bl_dma_int_process(void)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  int *piStack52;
  dma_ctx *pstctx;
  
  uVar1 = _DAT_4000c00c;
  uVar2 = _DAT_4000c004;
  uVar5 = 0;
  bl_irq_ctx_get(0x1f,&piStack52);
  do {
    uVar4 = 1 << (uVar5 & 0x1f);
    uVar7 = uVar4 & uVar2;
    uVar6 = uVar4 & uVar1;
    if (uVar7 == 0) {
      if (uVar6 != 0) {
LAB_23033424:
        uVar2 = _DAT_4000c010 | uVar4;
        _DAT_4000c010 = uVar2;
        goto LAB_2303342e;
      }
    }
    else {
      uVar2 = _DAT_4000c008 | uVar4;
      _DAT_4000c008 = uVar2;
      if (uVar6 != 0) goto LAB_23033424;
LAB_2303342e:
      iVar3 = *(int *)(*piStack52 + 4);
      while (iVar3 != *piStack52) {
        if (*(uint *)(iVar3 + 8) == uVar5) {
          if ((*(code **)(iVar3 + 0xc) != (code *)0x0) && (uVar7 != 0)) {
            (**(code **)(iVar3 + 0xc))();
          }
          if ((*(code **)(iVar3 + 0x10) != (code *)0x0) && (uVar6 != 0)) {
            (**(code **)(iVar3 + 0x10))();
          }
        }
        iVar3 = *(int *)(iVar3 + 4);
      }
    }
    uVar5 = uVar5 + 1;
    if (uVar5 == 4) {
      return;
    }
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int bl_dma_int_clear(int ch)

{
  uint uVar1;
  
  uVar1 = 1 << (ch & 0x1fU);
  if ((_DAT_4000c004 & uVar1 & 0xff) != 0) {
    _DAT_4000c008 = _DAT_4000c008 | uVar1;
  }
  if ((_DAT_4000c00c & uVar1 & 0xff) != 0) {
    _DAT_4000c010 = uVar1 | _DAT_4000c010;
  }
  return 0;
}



void bl_dma_IRQHandler(void)

{
  utils_list_hdr *puVar1;
  TickType_t TVar2;
  
  bl_dma_int_clear(0);
  puVar1 = utils_list_pop_front(&dma_copy_list);
  if (puVar1 == (utils_list_hdr *)0x0) {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_dma < BLOG_LEVEL_WARN))
    {
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] [INT] ASSERT here for empty chain\r\n",TVar2,&DAT_2307f16c,
                "bl_dma.c",0x9d);
    }
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  if (puVar1[1].next != (utils_list_hdr *)0x0) {
    (*(code *)puVar1[1].next)(puVar1[2].next);
  }
  if (dma_copy_list.first != (utils_list_hdr *)0x0) {
    DMA_LLI_Update('\0',(uint32_t)(dma_copy_list.first + 3));
    DMA_Channel_Enable('\0');
    return;
  }
  return;
}



void bl_dma_copy(bl_dma_item *first)

{
  vTaskEnterCritical();
  if (dma_copy_list.first == (utils_list_hdr *)0x0) {
    DMA_LLI_Update('\0',(uint32_t)&first->src);
    DMA_Channel_Enable('\0');
  }
  utils_list_push_back(&dma_copy_list,(utils_list_hdr *)first);
  vTaskExitCritical();
  return;
}



int bl_dma_irq_register(int channel,void *tc_handler,void *interr_handler,void *ctx)

{
  int iVar1;
  TickType_t TVar2;
  int *piVar3;
  int **ppiVar4;
  int *piStack36;
  dma_ctx *pstctx;
  
  if (((uint)channel < 5) && (tc_handler != (void *)0x0)) {
    bl_irq_ctx_get(0x1f,&piStack36);
    iVar1 = *(int *)(*piStack36 + 4);
    while (*piStack36 != iVar1) {
      if (channel == *(int *)(iVar1 + 8)) {
        if (BLOG_LEVEL_WARN < _fsymc_level_hal_drv) {
          return -1;
        }
        if (BLOG_LEVEL_WARN < _fsymf_level_hal_drvbl_dma) {
          return -1;
        }
        if (TrapNetCounter == 0) {
          TVar2 = xTaskGetTickCount();
        }
        else {
          TVar2 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] channel %d already register \r\n",TVar2,&DAT_23081ce8,
                  "bl_dma.c",0x124,*(undefined4 *)(iVar1 + 8));
        return -1;
      }
      iVar1 = *(int *)(iVar1 + 4);
    }
    piVar3 = (int *)pvPortMalloc(0x18);
    if (((piVar3 == (int *)0x0) && (_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT)) &&
       (_fsymf_level_hal_drvbl_dma < BLOG_LEVEL_ASSERT)) {
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] malloc dma node failed. \r\n",TVar2,&DAT_23072bcc,"bl_dma.c",
                0x12a);
    }
    piVar3[2] = channel;
    *(void **)(piVar3 + 3) = tc_handler;
    *(void **)(piVar3 + 4) = interr_handler;
    *(void **)(piVar3 + 5) = ctx;
    iVar1 = *piStack36;
    ppiVar4 = *(int ***)(iVar1 + 4);
    *piVar3 = iVar1;
    *(int ***)(piVar3 + 1) = ppiVar4;
    *(int **)(iVar1 + 4) = piVar3;
    *ppiVar4 = piVar3;
  }
  else {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
       (_fsymf_level_hal_drvbl_dma < BLOG_LEVEL_ASSERT)) {
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] not valid para \r\n",TVar2,&DAT_23072bcc,"bl_dma.c",0x11c);
    }
  }
  return -1;
}



void bl_dma_init(void)

{
  void **ctx;
  char *format;
  void *pvVar1;
  undefined4 uVar2;
  undefined2 uStack20;
  DMA_Periph_Req_Type DStack18;
  DMA_LLI_Cfg_Type lliCfg;
  
  uStack20 = 0;
  DStack18 = DMA_REQ_UART0_RX;
  utils_list_init(&dma_copy_list);
  ctx = (void **)pvPortMalloc(4);
  if (ctx == (void **)0x0) {
    if (BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) {
      return;
    }
    if (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvbl_dma) {
      return;
    }
    if (TrapNetCounter == 0) {
      xTaskGetTickCount();
    }
    else {
      xTaskGetTickCountFromISR();
    }
    uVar2 = 0x180;
    format = "[%10u][%s: %s:%4d] malloc dma ctx failed \r\n";
  }
  else {
    pvVar1 = pvPortMalloc(8);
    *ctx = pvVar1;
    if (pvVar1 != (void *)0x0) {
      *(void **)((int)pvVar1 + 4) = pvVar1;
      *(void **)pvVar1 = pvVar1;
      DMA_Enable();
      DMA_IntMask('\0',DMA_INT_ALL,MASK);
      DMA_IntMask('\0',DMA_INT_TCOMPLETED,UNMASK);
      DMA_IntMask('\0',DMA_INT_ERR,UNMASK);
      DMA_LLI_Init('\0',(DMA_LLI_Cfg_Type *)&uStack20);
      bl_irq_register_with_ctx(0x1f,bl_dma_int_process,ctx);
      bl_dma_irq_register(0,bl_dma_IRQHandler,(void *)0x0,(void *)0x0);
      bl_irq_enable(0x1f);
      return;
    }
    if (BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) {
      return;
    }
    if (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvbl_dma) {
      return;
    }
    if (TrapNetCounter == 0) {
      xTaskGetTickCount();
    }
    else {
      xTaskGetTickCountFromISR();
    }
    uVar2 = 0x187;
    format = "[%10u][%s: %s:%4d] malloc dma pstqueue failed \r\n";
  }
  bl_printk(format,&DAT_23072bcc,"bl_dma.c",uVar2);
  return;
}



void bl_dma_test(void)

{
  bl_dma_item *first;
  void *__s;
  void *__s_00;
  TickType_t TVar1;
  
  first = (bl_dma_item *)pvPortMalloc(0x1c);
  __s = pvPortMalloc(0x44);
  __s_00 = pvPortMalloc(0x44);
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_dma < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [TEST] [DMA] first %p, src %p, dst %p\r\n",TVar1,&DAT_2307f16c,
              "bl_dma.c",0x1af,first,__s,__s_00);
  }
  memset(first,0,0x1c);
  memset(__s,1,0x44);
  memset(__s_00,0xff,0x44);
  first->ctrl = 0x8c49b011;
  *(void **)&first->src = __s;
  *(void **)&first->dst = __s_00;
  first->next = 0;
  first->cb = _cb_cmd;
  *(bl_dma_item **)&first->arg = first;
  bl_dma_copy(first);
  while (first->arg != (void *)0x0) {
    vTaskDelay(2);
  }
  vPortFree((void *)first->src);
  vPortFree((void *)first->dst);
  vPortFree(first);
  return;
}



void _irq_num_check(int irqnum)

{
  TickType_t TVar1;
  
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) && (_fsymf_level_hal_drvbl_irq < BLOG_LEVEL_ASSERT)
     ) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] illegal irqnum %d\r\n",TVar1,&DAT_23072bcc,"bl_irq.c",0x70,irqnum)
    ;
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void bl_irq_enable(uint source)

{
  (&DAT_02800400)[source] = 1;
  return;
}



void bl_irq_disable(uint source)

{
  (&DAT_02800400)[source] = 0;
  return;
}



void bl_irq_exception_trigger(BL_IRQ_EXCEPTION_TYPE_T type,void *ptr)

{
  undefined3 in_register_00002029;
  uint uVar1;
  undefined4 uVar2;
  undefined auStack20 [4];
  uint32_t fun_val;
  
  uVar1 = CONCAT31(in_register_00002029,type);
  if (uVar1 < 3) {
    if (uVar1 == 0) {
      uVar2 = *(undefined4 *)ptr;
    }
    else {
      uVar2 = 0x12345678;
      *(undefined4 *)ptr = 0x12345678;
    }
  }
  else {
    uVar2 = 0x12345678;
    if (uVar1 == 3) {
      (*(code *)auStack20)(0x12345678,auStack20);
      uVar2 = 0x12345678;
    }
  }
  printf("Trigger exception val is %08lx\r\n",uVar2);
  return;
}



void bl_irq_register_with_ctx(int irqnum,void *handler,void *ctx)

{
  TickType_t TVar1;
  
  if (0x4f < (uint)irqnum) {
    _irq_num_check(irqnum);
  }
  if (handler_list[irqnum] == (anon_subr_void *)0x0) goto LAB_23033a6a;
  if (handler_list[irqnum] == (anon_subr_void *)handler) {
LAB_23033adc:
    handler_list[irqnum] = handler;
    if ((anon_subr_void *)ctx == (anon_subr_void *)0x0) {
      handler_list[irqnum + 0x50] = (anon_subr_void *)0x0;
    }
    else {
      handler_list[irqnum + 0x50] = ctx;
    }
  }
  else {
    if (_fsymc_level_hal_drv < BLOG_LEVEL_ERROR) {
      if (_fsymf_level_hal_drvbl_irq < BLOG_LEVEL_ERROR) {
        if (TrapNetCounter == 0) {
          TVar1 = xTaskGetTickCount();
        }
        else {
          TVar1 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] IRQ %d already registered with %p \r\n",TVar1,&DAT_23081ce8,
                  "bl_irq.c",0x7e,irqnum,handler_list[irqnum]);
        goto LAB_23033a6a;
      }
      if ((anon_subr_void *)handler != (anon_subr_void *)0x0) goto LAB_23033adc;
    }
    else {
LAB_23033a6a:
      if ((anon_subr_void *)handler != (anon_subr_void *)0x0) goto LAB_23033adc;
      if (BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) {
        return;
      }
    }
    if (_fsymf_level_hal_drvbl_irq < BLOG_LEVEL_ASSERT) {
      if (TrapNetCounter == 0) {
        TVar1 = xTaskGetTickCount();
      }
      else {
        TVar1 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] handler is NULL pointer! \r\n",TVar1,&DAT_23072bcc,"bl_irq.c",
                0x82);
      return;
    }
  }
  return;
}



void bl_irq_ctx_get(int irqnum,void **ctx)

{
  if (0x4f < (uint)irqnum) {
    _irq_num_check(irqnum);
  }
  *(anon_subr_void **)ctx = handler_list[irqnum + 0x50];
  return;
}



void bl_irq_register(int irqnum,void *handler)

{
  bl_irq_register_with_ctx(irqnum,handler,(void *)0x0);
  return;
}



void bl_irq_unregister(int irqnum,void *handler)

{
  TickType_t TVar1;
  
  if (0x4f < (uint)irqnum) {
    _irq_num_check(irqnum);
  }
  if (((handler_list[irqnum] != (anon_subr_void *)handler) &&
      (_fsymc_level_hal_drv < BLOG_LEVEL_ERROR)) && (_fsymf_level_hal_drvbl_irq < BLOG_LEVEL_ERROR))
  {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] IRQ %d:%p Not match with registered %p\r\n",TVar1,&DAT_23081ce8,
              "bl_irq.c",0xa8,irqnum,handler,handler_list[irqnum]);
  }
  handler_list[irqnum] = handler;
  return;
}



// WARNING: Exceeded maximum restarts with more pending

void interrupt_entry(uint32_t mcause)

{
  anon_subr_void *UNRECOVERED_JUMPTABLE_00;
  uint uVar1;
  
  uVar1 = mcause & 0x7ffffff;
  if (uVar1 < 0x50) {
    UNRECOVERED_JUMPTABLE_00 = handler_list[uVar1];
    if (UNRECOVERED_JUMPTABLE_00 != (anon_subr_void *)0x0) {
      if (handler_list[uVar1 + 0x50] != (anon_subr_void *)0x0) {
                    // WARNING: Could not recover jumptable at 0x23033c02. Too many branches
                    // WARNING: Treating indirect jump as call
        (*UNRECOVERED_JUMPTABLE_00)();
        return;
      }
                    // WARNING: Could not recover jumptable at 0x23033c04. Too many branches
                    // WARNING: Treating indirect jump as call
      (*UNRECOVERED_JUMPTABLE_00)();
      return;
    }
  }
  printf("Cannot handle mcause 0x%lx:%lu, adjust to externel(0x%lx:%lu)\r\n",uVar1,uVar1 - 0x10);
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void exception_entry(uint32_t mcause,uint32_t mepc,uint32_t mtval,uintptr_t *regs)

{
  char *__s;
  
  if ((mcause & 0x3ff) == 4) {
    misaligned_load_trap(mcause,mepc);
    return;
  }
  if ((mcause & 0x3ff) != 6) {
    puts("Exception Entry--->>>\r\n");
    printf("mcause %08lx, mepc %08lx, mtval %08lx\r\n",mcause,mepc,mtval);
    printf("Exception code: %lu\r\n",mcause & 0xffff);
    switch(mcause & 0xffff) {
    case 0:
      __s = "  msg: Instruction address misaligned\r\n";
      break;
    case 1:
      __s = "  msg: Instruction access fault\r\n";
      break;
    case 2:
      __s = "  msg: Illegal instruction\r\n";
      break;
    case 3:
      __s = "  msg: Breakpoint\r\n";
      break;
    case 4:
      __s = "  msg: Load address misaligned\r\n";
      break;
    case 5:
      __s = "  msg: Load access fault\r\n";
      break;
    case 6:
      __s = "  msg: Store/AMO access misaligned\r\n";
      break;
    case 7:
      __s = "  msg: Store/AMO access fault\r\n";
      break;
    case 8:
      __s = "  msg: Environment call from U-mode\r\n";
      break;
    case 9:
      __s = "  msg: Environment call from S-mode\r\n";
      break;
    case 10:
    case 0xe:
      __s = "  msg: Reserved\r\n";
      break;
    case 0xb:
      __s = "  msg: Environment call from M-mode\r\n";
      break;
    case 0xc:
      __s = "  msg: Instruction page fault\r\n";
      break;
    case 0xd:
      __s = "  msg: Load page fault\r\n";
      break;
    case 0xf:
      __s = "  msg: Store/AMO page fault\r\n";
      break;
    default:
      __s = "  msg: Reserved default exception\r\n";
    }
    puts(__s);
    backtrace_riscv(printf,regs);
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  misaligned_store_trap(mcause,mepc);
  return;
}



void bl_irq_init(void)

{
  undefined *puVar1;
  
  puts("[IRQ] Clearing and Disable all the pending IRQ...\r\n");
  puVar1 = &DAT_02800400;
  do {
    *puVar1 = 0;
    puVar1 = puVar1 + 1;
  } while (puVar1 != (undefined *)0x2800480);
  puVar1 = &DAT_02800000;
  do {
    *puVar1 = 0;
    puVar1 = puVar1 + 1;
  } while (puVar1 != (undefined *)0x2800080);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void _trng_trigger(void)

{
  if ((_DAT_40004200 & 1) == 0) {
    _DAT_40004200 = _DAT_40004200 | 0x606;
    _DAT_4000422c = trng_buffer[0];
    _DAT_40004230 = trng_buffer[1];
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void wait_trng4feed(void)

{
  do {
  } while ((_DAT_40004200 & 1) != 0);
  _DAT_40004200 = _DAT_40004200 & 0xfffffffd | 0x200;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) && (_fsymf_level_hal_drvbl_sec < BLOG_LEVEL_INFO)) {
    if (TrapNetCounter == 0) {
      xTaskGetTickCount();
    }
    else {
      xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] Feed random number is %08lx\r\n","DEBUG ","bl_sec.c",0x5b,
              trng_buffer[0]);
  }
  trng_buffer[0] = _DAT_40004208;
  trng_buffer[1] = _DAT_4000420c;
  trng_buffer[2] = _DAT_40004210;
  trng_buffer[3] = _DAT_40004214;
  trng_buffer[4] = _DAT_40004218;
  trng_buffer[5] = _DAT_4000421c;
  trng_buffer[6] = _DAT_40004220;
  trng_buffer[7] = _DAT_40004224;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void sec_trng_IRQHandler(uint param_1,int param_2)

{
  aos_now_ms();
  if ((param_2 < 1) && ((param_2 != 0 || (param_1 < 2000)))) {
    puts("[BL] [SEC] TRNG Handler\r\n");
  }
  _DAT_40004200 = _DAT_40004200 & 0xfffffffd | 0x200;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) && (_fsymf_level_hal_drvbl_sec < BLOG_LEVEL_INFO)) {
    if (TrapNetCounter == 0) {
      xTaskGetTickCount();
    }
    else {
      xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] random number is %08lx\r\n","DEBUG ","bl_sec.c",0xab,
              trng_buffer[0]);
  }
  trng_buffer[0] = _DAT_40004208;
  trng_buffer[1] = _DAT_4000420c;
  trng_buffer[2] = _DAT_40004210;
  trng_buffer[3] = _DAT_40004214;
  trng_buffer[4] = _DAT_40004218;
  trng_buffer[5] = _DAT_4000421c;
  trng_buffer[6] = _DAT_40004220;
  trng_buffer[7] = _DAT_40004224;
  return;
}



void bl_sec_pka_IRQHandler(void)

{
  puts("--->>> PKA IRQ\r\n");
  SEC_Eng_IntMask(SEC_ENG_INT_PKA,MASK);
  return;
}



uint32_t bl_sec_get_random_word(void)

{
  uint uVar1;
  
  uVar1 = trng_idx & 7;
  if (uVar1 == 0) {
    trng_idx = uVar1;
    _trng_trigger();
  }
  trng_idx = uVar1 + 1;
  return trng_buffer[uVar1];
}



void bl_rand_stream(uint8_t *buf,int len)

{
  size_t __n;
  int iVar1;
  
  if (trng_idx != 0) {
    _trng_trigger();
    wait_trng4feed();
    trng_idx = 0;
  }
  iVar1 = 0;
  while (0 < len) {
    if (trng_idx != 0) {
      _trng_trigger();
      wait_trng4feed();
      trng_idx = 0;
    }
    __n = len;
    if (0x20 < len) {
      __n = 0x20;
    }
    memcpy(buf + iVar1,trng_buffer,__n);
    iVar1 = iVar1 + __n;
    len = len - __n;
    trng_idx = 0x1f;
  }
  _trng_trigger();
  wait_trng4feed();
  trng_idx = 0;
  return;
}



int bl_rand(void)

{
  int iVar1;
  uint32_t uVar2;
  
  iVar1 = 0x13;
  do {
    uVar2 = bl_sec_get_random_word();
    iVar1 = iVar1 + -1;
    if (iVar1 == 0) {
      puts("[BL] [SEC] Failed after loop (17)\r\n");
      break;
    }
  } while (uVar2 == 0);
  return uVar2 >> 1;
}



int bl_sec_init(void)

{
  g_bl_sec_sha_mutex =
       (SemaphoreHandle_t)xQueueCreateMutexStatic('\x01',(StaticQueue_t *)&sha_mutex_buf);
  _trng_trigger();
  wait_trng4feed();
  _trng_trigger();
  wait_trng4feed();
  bl_irq_register(0x1c,sec_trng_IRQHandler);
  bl_irq_enable(0x1c);
  return 0;
}



int bl_sec_test(void)

{
  int iVar1;
  
  bl_printk("------------------TRNG TEST---------------------------------\r\n");
  iVar1 = bl_rand();
  bl_printk("**********TRNG TEST rand[%08x]**************\r\n",iVar1);
  iVar1 = bl_rand();
  bl_printk("**********TRNG TEST rand[%08x]**************\r\n",iVar1);
  bl_printk("------------------------------------------------------------\r\n");
  return 0;
}



void _dump_rsa_data(uint8_t *data,int size)

{
  uint uVar1;
  
  uVar1 = 0;
  do {
    if (size <= (int)uVar1) {
      return;
    }
    if ((uVar1 & 0xf) == 0) {
      bl_printk("[%04X]:",uVar1);
LAB_2303415a:
      bl_printk(" %02X",(uint)data[uVar1]);
    }
    else {
      if ((uVar1 & 0xf) != 0xf) goto LAB_2303415a;
      bl_printk(" %02X",(uint)data[uVar1]);
      puts("\r\n");
    }
    uVar1 = uVar1 + 1;
  } while( true );
}



void _pka_test_case_xgcd(void)

{
  uint8_t "" [256];
  uint8_t n [256];
  uint8_t "" [256];
  uint8_t uStack273;
  undefined auStack272 [3];
  uint8_t pka_a_eq_0;
  uint32_t result [64];
  
  uStack273 = '\0';
  Sec_Eng_PKA_Reset();
  Sec_Eng_PKA_BigEndian_Enable();
  Sec_Eng_PKA_Write_Data
            (SEC_ENG_PKA_REG_SIZE_256,'\x01',(uint32_t *)(uint8_t *)&ram0x230839c4,0x40,'\0');
  Sec_Eng_PKA_CREG(SEC_ENG_PKA_REG_SIZE_256,'\x02','\0','\0');
  Sec_Eng_PKA_CREG(SEC_ENG_PKA_REG_SIZE_256,'\x03','\0','\x01');
  Sec_Eng_PKA_Write_Data(SEC_ENG_PKA_REG_SIZE_256,'\0',(uint32_t *)"",0x40,'\0');
  Sec_Eng_PKA_LMUL2N('\n','\x01','\b','\0',0x800,'\0');
  Sec_Eng_PKA_LDIV('\b','\0','\n','\x01','\b','\x01','\0');
  Sec_Eng_PKA_MREM('\b','\x04','\n','\x01','\b','\x01','\0');
  Sec_Eng_PKA_CREG(SEC_ENG_PKA_REG_SIZE_512,'\x01','\0','\x01');
  Sec_Eng_PKA_Move_Data('\b','\x02','\b','\x01','\0');
  Sec_Eng_PKA_Move_Data('\b','\x01','\b','\x04','\x01');
  Sec_Eng_PKA_Write_Data(SEC_ENG_PKA_REG_SIZE_256,'\x04',(uint32_t *)"",0x40,'\0');
  Sec_Eng_PKA_Write_Data(SEC_ENG_PKA_REG_SIZE_256,'\x05',(uint32_t *)0x23083ac4,0x40,'\0');
  Sec_Eng_PKA_Write_Data(SEC_ENG_PKA_REG_SIZE_256,'\x06',(uint32_t *)0x23083ac4,0x40,'\0');
  Sec_Eng_PKA_Write_Data(SEC_ENG_PKA_REG_SIZE_256,'\a',(uint32_t *)0x2308341c,0x40,'\0');
  Sec_Eng_PKA_LMUL('\b','\b','\b','\0','\b','\x05','\0');
  Sec_Eng_PKA_LSUB('\b','\b','\b','\x04','\b','\b','\0');
  Sec_Eng_PKA_LMUL('\b','\t','\b','\0','\b','\a','\0');
  Sec_Eng_PKA_LSUB('\b','\t','\b','\x06','\b','\t','\0');
  Sec_Eng_PKA_Move_Data('\b','\x04','\b','\x05','\0');
  Sec_Eng_PKA_Move_Data('\b','\x05','\b','\b','\0');
  Sec_Eng_PKA_Move_Data('\b','\x06','\b','\a','\0');
  Sec_Eng_PKA_Move_Data('\b','\a','\b','\t','\x01');
  while (uStack273 == '\0') {
    Sec_Eng_PKA_LDIV('\b','\0','\b','\x02','\b','\x01','\0');
    Sec_Eng_PKA_MREM('\b','\x03','\b','\x02','\b','\x01','\0');
    Sec_Eng_PKA_LMUL('\b','\b','\b','\0','\b','\x05','\0');
    Sec_Eng_PKA_LSUB('\b','\b','\b','\x04','\b','\b','\0');
    Sec_Eng_PKA_LMUL('\b','\t','\b','\0','\b','\a','\0');
    Sec_Eng_PKA_LSUB('\b','\t','\b','\x06','\b','\t','\0');
    Sec_Eng_PKA_Move_Data('\b','\x02','\b','\x01','\0');
    Sec_Eng_PKA_Move_Data('\b','\x04','\b','\x05','\0');
    Sec_Eng_PKA_Move_Data('\b','\x05','\b','\b','\0');
    Sec_Eng_PKA_Move_Data('\b','\x06','\b','\a','\0');
    Sec_Eng_PKA_Move_Data('\b','\a','\b','\t','\x01');
    Sec_Eng_PKA_Move_Data('\b','\x01','\b','\x03','\x01');
    Sec_Eng_PKA_Write_Data(SEC_ENG_PKA_REG_SIZE_256,'\n',(uint32_t *)0x23083ac4,0x40,'\0');
    Sec_Eng_PKA_LCMP(&uStack273,'\b','\x01','\b','\n');
  }
  Sec_Eng_PKA_Read_Data(SEC_ENG_PKA_REG_SIZE_256,'\x06',(uint32_t *)auStack272,'@');
  _dump_rsa_data(auStack272,0x100);
  return;
}



void _pka_test_case2(uint8_t param_1)

{
  bool bVar1;
  uint8_t encrypted [256];
  uint8_t inv_r [256];
  uint8_t m [256];
  uint8_t n [256];
  uint8_t nprime [256];
  uint8_t "" [4];
  uint32_t *puVar2;
  uint8_t *puVar3;
  char *format;
  undefined *puVar4;
  undefined4 uVar5;
  int iVar6;
  uint32_t local_130;
  uint32_t result [64];
  
  Sec_Eng_PKA_Reset();
  Sec_Eng_PKA_BigEndian_Enable();
  Sec_Eng_PKA_Write_Data
            (SEC_ENG_PKA_REG_SIZE_256,'\0',(uint32_t *)(uint8_t *)&ram0x230838c4,0x40,'\0');
  Sec_Eng_PKA_Write_Data
            (SEC_ENG_PKA_REG_SIZE_256,'\x01',(uint32_t *)(uint8_t *)&ram0x23083bc4,0x40,'\0');
  Sec_Eng_PKA_Write_Data
            (SEC_ENG_PKA_REG_SIZE_256,'\x02',(uint32_t *)(uint8_t *)0x230837c4,0x40,'\0');
  Sec_Eng_PKA_Write_Data(SEC_ENG_PKA_REG_SIZE_256,'\x03',(uint32_t *)"",1,'\0');
  Sec_Eng_PKA_CREG(SEC_ENG_PKA_REG_SIZE_256,'\x04','\0','\0');
  Sec_Eng_PKA_CREG(SEC_ENG_PKA_REG_SIZE_256,'\x05','\0','\x01');
  Sec_Eng_PKA_LMUL2N('\n','\x02','\b','\x02',0x800,'\0');
  Sec_Eng_PKA_MREM('\b','\x02','\n','\x02','\b','\0','\0');
  Sec_Eng_PKA_CREG(SEC_ENG_PKA_REG_SIZE_512,'\x02','\0','\x01');
  Sec_Eng_PKA_MEXP('\b','\x04','\b','\x02','\b','\x03','\b','\0',DAT_00000010);
  Sec_Eng_PKA_Move_Data('\b','\x02','\b','\x04','\x01');
  Sec_Eng_PKA_Write_Data
            (SEC_ENG_PKA_REG_SIZE_256,'\x01',(uint32_t *)(uint8_t *)&ram0x230836c4,0x40,'\0');
  Sec_Eng_PKA_CREG(SEC_ENG_PKA_REG_SIZE_256,'\x04','\0','\0');
  Sec_Eng_PKA_CREG(SEC_ENG_PKA_REG_SIZE_256,'\x05','\0','\x01');
  Sec_Eng_PKA_LMUL('\n','\x02','\b','\x02','\b','\x01','\0');
  Sec_Eng_PKA_MREM('\b','\x02','\n','\x02','\b','\0','\0');
  Sec_Eng_PKA_CREG(SEC_ENG_PKA_REG_SIZE_512,'\x02','\0','\x01');
  Sec_Eng_PKA_Read_Data(SEC_ENG_PKA_REG_SIZE_256,'\x02',&local_130,'@');
  _dump_rsa_data((uint8_t *)&local_130,0x100);
  puVar2 = &local_130;
  puVar3 = &ram0x230835c4;
  bVar1 = false;
  iVar6 = 0;
  while (iVar6 != 0x100) {
    if (((*(uint8_t *)puVar2 != *puVar3) && (bVar1 = true, _fsymc_level_hal_drv < BLOG_LEVEL_WARN))
       && (_fsymf_level_hal_drvbl_sec < BLOG_LEVEL_WARN)) {
      if (TrapNetCounter == 0) {
        xTaskGetTickCount();
      }
      else {
        xTaskGetTickCountFromISR();
      }
      puVar4 = (undefined *)0x2307b100;
      if (*(uint8_t *)puVar2 != *puVar3) {
        puVar4 = &UNK_23083384;
      }
      bl_printk("[%10u][%s: %s:%4d] %s[%02d], %02x %02x\r\n",&DAT_2307f16c,"bl_sec.c",0xf9,puVar4,
                iVar6);
      bVar1 = true;
    }
    iVar6 = iVar6 + 1;
    puVar2 = (uint32_t *)((int)puVar2 + 1);
    puVar3 = puVar3 + 1;
  }
  if (bVar1) {
    if (BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) {
      return;
    }
    if (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvbl_sec) {
      return;
    }
    if (TrapNetCounter == 0) {
      xTaskGetTickCount();
    }
    else {
      xTaskGetTickCountFromISR();
    }
    uVar5 = 0xfd;
    puVar4 = &DAT_23072bcc;
    format = "[%10u][%s: %s:%4d] ====== Failed %lu Bytes======\r\n";
  }
  else {
    if (BLOG_LEVEL_INFO < _fsymc_level_hal_drv) {
      return;
    }
    if (BLOG_LEVEL_INFO < _fsymf_level_hal_drvbl_sec) {
      return;
    }
    if (TrapNetCounter == 0) {
      xTaskGetTickCount();
    }
    else {
      xTaskGetTickCountFromISR();
    }
    uVar5 = 0xff;
    puVar4 = &DAT_2307f16c;
    format = "[%10u][%s: %s:%4d] ====== Success %lu Bytes=====\r\n";
  }
  bl_printk(format,puVar4,"bl_sec.c",uVar5,0x100);
  return;
}



int bl_pka_test(void)

{
  bl_irq_register(0x1b,bl_sec_pka_IRQHandler);
  bl_irq_enable(0x1b);
  _pka_test_case2();
  _pka_test_case_xgcd();
  _pka_test_case2();
  return 0;
}



void int_timer_cb(void)

{
  BaseType_t BVar1;
  
  TIMER_ClearIntStatus(TIMER_CH1,TIMER_COMP_ID_0);
  BVar1 = xTaskIncrementTick();
  if (BVar1 != 0) {
    vTaskSwitchContext();
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t bl_timer_now_us(void)

{
  uint32_t uVar1;
  
  uVar1 = _DAT_0200bff8;
  __udivdi3();
  return uVar1;
}



int bl_timer_tick_enable(void)

{
  TIMER_Chan_Type aTStack40 [4];
  TIMER_CFG_Type timerCh1Cfg;
  
  memcpy(aTStack40,&DAT_23083d64,0x18);
  TIMER_IntMask(TIMER_CH1,TIMER_INT_ALL,MASK);
  TIMER_Disable(aTStack40[0]);
  TIMER_Init((TIMER_CFG_Type *)aTStack40);
  TIMER_ClearIntStatus(aTStack40[0],TIMER_COMP_ID_0);
  TIMER_ClearIntStatus(aTStack40[0],TIMER_COMP_ID_1);
  TIMER_ClearIntStatus(aTStack40[0],TIMER_COMP_ID_2);
  TIMER_IntMask(aTStack40[0],TIMER_INT_COMP_0,UNMASK);
  TIMER_IntMask(aTStack40[0],TIMER_INT_COMP_1,MASK);
  TIMER_IntMask(aTStack40[0],TIMER_INT_COMP_2,MASK);
  TIMER_Enable(aTStack40[0]);
  bl_irq_enable(0x35);
  bl_irq_register(0x35,int_timer_cb);
  return 0;
}



// WARNING: Variable defined which should be unmapped: val

void cmd_gpio_get(char *buf,int len,int argc,char **argv)

{
  TickType_t TVar1;
  int iVar2;
  int iVar3;
  undefined *puVar4;
  uint8_t auStack17 [4];
  uint8_t val;
  
  if (argc == 2) {
    iVar2 = atoi(argv[1]);
    if (iVar2 < 0) {
      puts("Illegal arg\r\n");
    }
    else {
      iVar3 = bl_gpio_input_get((uint8_t)iVar2,auStack17);
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvbl_gpio_cli < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar1 = xTaskGetTickCount();
        }
        else {
          TVar1 = xTaskGetTickCountFromISR();
        }
        if (iVar3 == 0) {
          if (auStack17[0] == '\0') {
            puVar4 = &UNK_23083e38;
          }
          else {
            puVar4 = &UNK_23083e30;
          }
        }
        else {
          puVar4 = &UNK_23083e2c;
        }
        bl_printk("[%10u][%s: %s:%4d] GPIO%d val is %s\r\n",TVar1,&DAT_2307f16c,"bl_gpio_cli.c",0x72
                  ,iVar2,puVar4);
      }
    }
  }
  else {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
       (_fsymf_level_hal_drvbl_gpio_cli < BLOG_LEVEL_WARN)) {
      if (TrapNetCounter == 0) {
        TVar1 = xTaskGetTickCount();
      }
      else {
        TVar1 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] Usage: %s 24\r\n  get GPIO24 value\r\n",TVar1,&DAT_2307f16c,
                "bl_gpio_cli.c",0x66,*argv);
    }
  }
  return;
}



void cmd_gpio_set(char *buf,int len,int argc,char **argv)

{
  TickType_t TVar1;
  int iVar2;
  int iVar3;
  undefined *puVar4;
  
  if (argc == 3) {
    iVar2 = atoi(argv[1]);
    iVar3 = atoi(argv[2]);
    if ((-1 < iVar2) && (-1 < iVar3)) {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvbl_gpio_cli < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar1 = xTaskGetTickCount();
        }
        else {
          TVar1 = xTaskGetTickCountFromISR();
        }
        if (iVar3 == 0) {
          puVar4 = &UNK_23083ebc;
        }
        else {
          puVar4 = &UNK_23083e30;
        }
        bl_printk("[%10u][%s: %s:%4d] GPIO%d is set to %s\r\n",TVar1,&DAT_2307f16c,"bl_gpio_cli.c",
                  0x59,iVar2,puVar4);
      }
      bl_gpio_output_set((uint8_t)iVar2,iVar3 != 0);
      return;
    }
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
       (_fsymf_level_hal_drvbl_gpio_cli < BLOG_LEVEL_ASSERT)) {
      if (TrapNetCounter == 0) {
        TVar1 = xTaskGetTickCount();
      }
      else {
        TVar1 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] Illegal arg\r\n",TVar1,&DAT_23072bcc,"bl_gpio_cli.c",0x53);
      return;
    }
  }
  else {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
       (_fsymf_level_hal_drvbl_gpio_cli < BLOG_LEVEL_WARN)) {
      if (TrapNetCounter == 0) {
        TVar1 = xTaskGetTickCount();
      }
      else {
        TVar1 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] Usage: %s 24 1\r\n  set GPIO24 output to high\r\n",TVar1,
                &DAT_2307f16c,"bl_gpio_cli.c",0x4d,*argv);
      return;
    }
  }
  return;
}



void cmd_gpio_func(char *buf,int len,int argc,char **argv)

{
  TickType_t TVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  char *pcVar6;
  char *pcVar7;
  
  if (argc == 5) {
    iVar2 = atoi(argv[1]);
    iVar3 = atoi(argv[2]);
    iVar4 = atoi(argv[3]);
    iVar5 = atoi(argv[4]);
    if ((((-1 < iVar2) && (-1 < iVar3)) && (-1 < iVar4)) && (-1 < iVar5)) {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvbl_gpio_cli < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar1 = xTaskGetTickCount();
        }
        else {
          TVar1 = xTaskGetTickCountFromISR();
        }
        if (iVar3 == 0) {
          pcVar6 = "output";
        }
        else {
          pcVar6 = "input";
        }
        if (iVar4 == 0) {
          pcVar7 = "null";
        }
        else {
          pcVar7 = "Active";
        }
        bl_printk("[%10u][%s: %s:%4d] GPIO%d is set %s with %s pullup %s pulldown\r\n",TVar1,
                  &DAT_2307f16c,"bl_gpio_cli.c",0x3e,iVar2,pcVar6,pcVar7);
      }
      if (iVar3 != 0) {
        bl_gpio_enable_input((uint8_t)iVar2,iVar4 != 0,iVar5 != 0);
        return;
      }
      bl_gpio_enable_output((uint8_t)iVar2,iVar4 != 0,iVar5 != 0);
      return;
    }
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
       (_fsymf_level_hal_drvbl_gpio_cli < BLOG_LEVEL_ASSERT)) {
      if (TrapNetCounter == 0) {
        TVar1 = xTaskGetTickCount();
      }
      else {
        TVar1 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] Illegal arg\r\n",TVar1,&DAT_23072bcc,"bl_gpio_cli.c",0x36);
      return;
    }
  }
  else {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
       (_fsymf_level_hal_drvbl_gpio_cli < BLOG_LEVEL_WARN)) {
      if (TrapNetCounter == 0) {
        TVar1 = xTaskGetTickCount();
      }
      else {
        TVar1 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] Usage: %s 24 1 1 0\r\n  set GPIO24 to input with pullup\r\n",
                TVar1,&DAT_2307f16c,"bl_gpio_cli.c",0x2e,*argv);
      return;
    }
  }
  return;
}



int bl_gpio_cli_init(void)

{
  return 0;
}



int bl_efuse_read_mac(uint8_t *mac)

{
  EF_Ctrl_Read_MAC_Address(mac);
  return 0;
}



int bl_efuse_read_mac_factory(uint8_t *mac)

{
  int8_t iVar1;
  undefined3 extraout_var;
  
  iVar1 = mfg_media_read_macaddr(mac,'\x01');
  return -(uint)(CONCAT31(extraout_var,iVar1) != 0);
}



int bl_efuse_read_capcode(uint8_t *capcode)

{
  int8_t iVar1;
  undefined3 extraout_var;
  
  iVar1 = mfg_media_read_xtal_capcode(capcode,'\x01');
  return -(uint)(CONCAT31(extraout_var,iVar1) != 0);
}



int bl_efuse_read_pwroft(int8_t *poweroffset)

{
  int8_t iVar1;
  undefined3 extraout_var;
  
  iVar1 = mfg_media_read_poweroffset(poweroffset,'\x01');
  return -(uint)(CONCAT31(extraout_var,iVar1) != 0);
}



void Aes_Compare_Data(uint8_t *expected,uint8_t *input,uint32_t len)

{
  bool bVar1;
  uint32_t uVar2;
  TickType_t TVar3;
  char *format;
  undefined *puVar4;
  undefined4 uVar5;
  
  bVar1 = false;
  uVar2 = 0;
  while (uVar2 != len) {
    if (((input[uVar2] != expected[uVar2]) && (bVar1 = true, _fsymc_level_hal_drv < BLOG_LEVEL_WARN)
        ) && (_fsymf_level_hal_drvbl_sec_aes < BLOG_LEVEL_WARN)) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      puVar4 = (undefined *)0x2307b100;
      if (input[uVar2] != expected[uVar2]) {
        puVar4 = &UNK_23083384;
      }
      bl_printk("[%10u][%s: %s:%4d] %s[%02d], %02x %02x\r\n",TVar3,&DAT_2307f16c,"bl_sec_aes.c",0x3b
                ,puVar4,uVar2);
      bVar1 = true;
    }
    uVar2 = uVar2 + 1;
  }
  if (bVar1) {
    if ((BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) ||
       (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvbl_sec_aes)) {
      return;
    }
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    uVar5 = 0x3f;
    puVar4 = &DAT_23072bcc;
    format = "[%10u][%s: %s:%4d] ====== Failed %lu Bytes======\r\n";
  }
  else {
    if (BLOG_LEVEL_INFO < _fsymc_level_hal_drv) {
      return;
    }
    if (BLOG_LEVEL_INFO < _fsymf_level_hal_drvbl_sec_aes) {
      return;
    }
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    uVar5 = 0x41;
    puVar4 = &DAT_2307f16c;
    format = "[%10u][%s: %s:%4d] ====== Success %lu Bytes=====\r\n";
  }
  bl_printk(format,TVar3,puVar4,"bl_sec_aes.c",uVar5,len);
  return;
}



void _dump_iv_status(SEC_Eng_AES_Link_Config_Type_conflict1 *linkCfg)

{
  byte bVar1;
  uint32_t *puVar2;
  
  puVar2 = &linkCfg->aesIV0;
  do {
    bVar1 = *(byte *)puVar2;
    puVar2 = (uint32_t *)((int)puVar2 + 1);
    bl_printk("%02x",(uint)bVar1);
  } while (puVar2 != &linkCfg->aesKey0);
  bl_printk("\r\n");
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void bl_sec_aes_IRQHandler(void)

{
  bl_printk("--->>> AES IRQ\r\n");
  _DAT_40004100 = _DAT_40004100 | 0x200;
  return;
}



// WARNING: Could not reconcile some variable overlaps

void Sec_Eng_AES_Link_Case_CBC_128(SEC_ENG_AES_ID_Type aesId)

{
  uint8_t aesResult_entrypted_cbc_128 [64];
  TickType_t TVar1;
  uint8_t auStack124 [4];
  uint8_t aesDstBuf [32];
  SEC_Eng_AES_Link_Config_Type_conflict1 linkCfg;
  
  memset(aesDstBuf + 0x1c,0,0x3c);
  aesDstBuf._28_4_ = 0x12400;
  Sec_Eng_AES_Enable_Link(aesId);
  puts("[CBC] AES-128-CBC case...\r\n");
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_sec_aes < BLOG_LEVEL_WARN)
     ) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [CBC] IV Status Initial, %08lx\r\n",TVar1,&DAT_2307f16c,
              "bl_sec_aes.c",0x84,linkCfg._0_4_);
  }
  _dump_iv_status((SEC_Eng_AES_Link_Config_Type_conflict1 *)(aesDstBuf + 0x1c));
  Sec_Eng_AES_Link_Work(aesId,(uint32_t)(aesDstBuf + 0x1c),aesSrcBuf_data,0x20,auStack124);
  Aes_Compare_Data((uint8_t *)&ram0x23084198,(uint8_t *)linkCfg.aesSrcAddr,0x20);
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_sec_aes < BLOG_LEVEL_WARN)
     ) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [CBC] IV Status After, %08lx\r\n",TVar1,&DAT_2307f16c,
              "bl_sec_aes.c",0x88,linkCfg._0_4_);
  }
  _dump_iv_status((SEC_Eng_AES_Link_Config_Type_conflict1 *)(aesDstBuf + 0x1c));
  Sec_Eng_AES_Link_Work(aesId,(uint32_t)(aesDstBuf + 0x1c),aesSrcBuf_data + 0x20,0x10,auStack124);
  Aes_Compare_Data((uint8_t *)0x230841b8,(uint8_t *)linkCfg.aesSrcAddr,0x10);
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_sec_aes < BLOG_LEVEL_WARN)
     ) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [CBC] IV Status After %08lx\r\n",TVar1,&DAT_2307f16c,
              "bl_sec_aes.c",0x8d,linkCfg._0_4_);
  }
  _dump_iv_status((SEC_Eng_AES_Link_Config_Type_conflict1 *)(aesDstBuf + 0x1c));
  Sec_Eng_AES_Link_Work(aesId,(uint32_t)(aesDstBuf + 0x1c),aesSrcBuf_data + 0x30,0x10,auStack124);
  Aes_Compare_Data((uint8_t *)0x230841c8,(uint8_t *)linkCfg.aesSrcAddr,0x10);
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_sec_aes < BLOG_LEVEL_WARN)
     ) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [CBC] IV Status After, %08lx\r\n",TVar1,&DAT_2307f16c,
              "bl_sec_aes.c",0x92,linkCfg._0_4_);
  }
  _dump_iv_status((SEC_Eng_AES_Link_Config_Type_conflict1 *)(aesDstBuf + 0x1c));
  Sec_Eng_AES_Disable_Link(aesId);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void Sec_Eng_AES_Link_Case_CTR_128(SEC_ENG_AES_ID_Type aesId)

{
  uint8_t aesResult_entrypted_ctr_128 [64];
  TickType_t TVar1;
  uint8_t auStack124 [4];
  uint8_t aesDstBuf [32];
  SEC_Eng_AES_Link_Config_Type_conflict1 linkCfg;
  
  memset(aesDstBuf + 0x1c,0,0x3c);
  aesDstBuf._28_4_ = 0x11400;
  Sec_Eng_AES_Enable_Link(aesId);
  puts("[CTR] AES-128-CTR case...\r\n");
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_sec_aes < BLOG_LEVEL_WARN)
     ) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [CTR] IV Status Initial, %08lx\r\n",TVar1,&DAT_2307f16c,
              "bl_sec_aes.c",0xbe,linkCfg._0_4_);
  }
  _dump_iv_status((SEC_Eng_AES_Link_Config_Type_conflict1 *)(aesDstBuf + 0x1c));
  Sec_Eng_AES_Link_Work(aesId,(uint32_t)(aesDstBuf + 0x1c),aesSrcBuf_data,0x20,auStack124);
  Aes_Compare_Data((uint8_t *)&ram0x230841d8,(uint8_t *)linkCfg.aesSrcAddr,0x20);
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_sec_aes < BLOG_LEVEL_WARN)
     ) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [CTR] IV Status After %08lx\r\n",TVar1,&DAT_2307f16c,
              "bl_sec_aes.c",0xc4,linkCfg._0_4_);
  }
  _dump_iv_status((SEC_Eng_AES_Link_Config_Type_conflict1 *)(aesDstBuf + 0x1c));
  Sec_Eng_AES_Link_Work(aesId,(uint32_t)(aesDstBuf + 0x1c),aesSrcBuf_data + 0x20,0x10,auStack124);
  Aes_Compare_Data((uint8_t *)0x230841f8,(uint8_t *)linkCfg.aesSrcAddr,0x10);
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_sec_aes < BLOG_LEVEL_WARN)
     ) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [CTR] IV Status After %08lx\r\n",TVar1,&DAT_2307f16c,
              "bl_sec_aes.c",0xc9,linkCfg._0_4_);
  }
  _dump_iv_status((SEC_Eng_AES_Link_Config_Type_conflict1 *)(aesDstBuf + 0x1c));
  Sec_Eng_AES_Link_Work(aesId,(uint32_t)(aesDstBuf + 0x1c),aesSrcBuf_data + 0x30,0x10,auStack124);
  Aes_Compare_Data((uint8_t *)0x23084208,(uint8_t *)linkCfg.aesSrcAddr,0x10);
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_sec_aes < BLOG_LEVEL_WARN)
     ) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [CTR] IV Status After, %08lx\r\n",TVar1,&DAT_2307f16c,
              "bl_sec_aes.c",0xce,linkCfg._0_4_);
  }
  _dump_iv_status((SEC_Eng_AES_Link_Config_Type_conflict1 *)(aesDstBuf + 0x1c));
  Sec_Eng_AES_Disable_Link(aesId);
  return;
}



// WARNING: Variable defined which should be unmapped: linkCfg
// WARNING: Could not reconcile some variable overlaps

void Sec_Eng_AES_Link_Case_ECB_128(SEC_ENG_AES_ID_Type aesId)

{
  uint8_t aesResult_entrypted_ecb_128 [64];
  uint8_t auStack108 [4];
  uint8_t aesDstBuf [32];
  SEC_Eng_AES_Link_Config_Type_conflict1 linkCfg;
  
  memset(aesDstBuf + 0x1c,0,0x3c);
  aesDstBuf._28_4_ = 0x10400;
  puts("[ECB] AES-128-ECB case...\r\n");
  Sec_Eng_AES_Enable_Link(aesId);
  Sec_Eng_AES_Link_Work(aesId,(uint32_t)(aesDstBuf + 0x1c),aesSrcBuf_data,0x20,auStack108);
  Aes_Compare_Data((uint8_t *)&ram0x23084218,(uint8_t *)linkCfg.aesSrcAddr,0x20);
  Sec_Eng_AES_Link_Work(aesId,(uint32_t)(aesDstBuf + 0x1c),aesSrcBuf_data + 0x20,0x10,auStack108);
  Aes_Compare_Data((uint8_t *)0x23084238,(uint8_t *)linkCfg.aesSrcAddr,0x10);
  Sec_Eng_AES_Link_Work(aesId,(uint32_t)(aesDstBuf + 0x1c),aesSrcBuf_data + 0x30,0x10,auStack108);
  Aes_Compare_Data((uint8_t *)0x23084248,(uint8_t *)linkCfg.aesSrcAddr,0x10);
  Sec_Eng_AES_Disable_Link(aesId);
  return;
}



int bl_sec_aes_test(void)

{
  bl_irq_register(0x1d,bl_sec_aes_IRQHandler);
  bl_irq_enable(0x1d);
  bl_printk(
           "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n"
           );
  Sec_Eng_AES_Link_Case_CBC_128(SEC_ENG_AES_ID0);
  bl_printk(
           "####################################################################################\r\n"
           );
  Sec_Eng_AES_Link_Case_CTR_128(SEC_ENG_AES_ID0);
  bl_printk(
           "####################################################################################\r\n"
           );
  Sec_Eng_AES_Link_Case_ECB_128(SEC_ENG_AES_ID0);
  bl_printk(
           "------------------------------------------------------------------------------------\r\n"
           );
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void bl_sec_sha_IRQHandler(void)

{
  puts("--->>> SHA IRQ\r\n");
  _DAT_40004000 = _DAT_40004000 | 0x200;
  return;
}



int bl_sha_mutex_take(void)

{
  BaseType_t BVar1;
  TickType_t TVar2;
  int iVar3;
  
  BVar1 = xQueueSemaphoreTake((QueueHandle_t)g_bl_sec_sha_mutex,0xffffffff);
  iVar3 = 0;
  if (((BVar1 != 1) && (iVar3 = -1, _fsymc_level_hal_drv < BLOG_LEVEL_ASSERT)) &&
     (_fsymf_level_hal_drvbl_sec_sha < BLOG_LEVEL_ASSERT)) {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] sha semphr take failed\r\n",TVar2,&DAT_23072bcc,"bl_sec_sha.c",
              0x36);
    iVar3 = -1;
  }
  return iVar3;
}



int bl_sha_mutex_give(void)

{
  BaseType_t BVar1;
  TickType_t TVar2;
  int iVar3;
  
  BVar1 = xQueueGenericSend((QueueHandle_t)g_bl_sec_sha_mutex,(void *)0x0,0,0);
  iVar3 = 0;
  if (((BVar1 != 1) && (iVar3 = -1, _fsymc_level_hal_drv < BLOG_LEVEL_ASSERT)) &&
     (_fsymf_level_hal_drvbl_sec_sha < BLOG_LEVEL_ASSERT)) {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] sha semphr give failed\\n",TVar2,&DAT_23072bcc,"bl_sec_sha.c",0x3f
             );
    iVar3 = -1;
  }
  return iVar3;
}



void bl_sha_init(bl_sha_ctx_t *ctx,bl_sha_type_t type)

{
  Sec_Eng_SHA256_Init((SEC_Eng_SHA256_Ctx *)ctx,SEC_ENG_SHA_ID0,type,ctx->tmp,ctx->pad);
  Sec_Eng_SHA_Start(SEC_ENG_SHA_ID0);
  return;
}



int bl_sha_update(bl_sha_ctx_t *ctx,uint8_t *input,uint32_t len)

{
  BL_Err_Type BVar1;
  undefined3 extraout_var;
  
  BVar1 = Sec_Eng_SHA256_Update((SEC_Eng_SHA256_Ctx *)ctx,SEC_ENG_SHA_ID0,input,len);
  return CONCAT31(extraout_var,BVar1);
}



int bl_sha_finish(bl_sha_ctx_t *ctx,uint8_t *hash)

{
  BL_Err_Type BVar1;
  undefined3 extraout_var;
  
  BVar1 = Sec_Eng_SHA256_Finish((SEC_Eng_SHA256_Ctx *)ctx,SEC_ENG_SHA_ID0,hash);
  return CONCAT31(extraout_var,BVar1);
}



// WARNING: Could not reconcile some variable overlaps

void sha256_test_case0(void)

{
  uint8_t sha256_test_result [32];
  undefined *puVar1;
  int iVar2;
  char *format;
  bool bVar3;
  undefined auStack220 [4];
  sha256_link_item_t sha256_link;
  
  memset(auStack220,0,0xbc);
  sha256_link.ctx.linkAddr = 0x10400;
  sha256_link.linkCfg._0_4_ = 0x50020000;
  bl_irq_register(0x1e,bl_sec_sha_IRQHandler);
  bl_irq_enable(0x1e);
  Sec_Eng_SHA_Enable_Link(SEC_ENG_SHA_ID0);
  Sec_Eng_SHA256_Link_Init
            ((SEC_Eng_SHA256_Link_Ctx *)auStack220,SEC_ENG_SHA_ID0,
             (uint32_t)&sha256_link.ctx.linkAddr,sha256_link.linkCfg.result + 7,
             sha256_link.tmp + 0xf);
  Sec_Eng_SHA256_Link_Update
            ((SEC_Eng_SHA256_Link_Ctx *)auStack220,SEC_ENG_SHA_ID0,
             "1111111111111111111111111111111111111111111111111111111111111111hal_drv.bl_sec_sha",
             0x40);
  Sec_Eng_SHA256_Link_Finish
            ((SEC_Eng_SHA256_Link_Ctx *)auStack220,SEC_ENG_SHA_ID0,
             (uint8_t *)&sha256_link.linkCfg.shaSrcAddr);
  Sec_Eng_SHA_Disable_Link(SEC_ENG_SHA_ID0);
  puVar1 = auStack220;
  bVar3 = false;
  iVar2 = 0;
  do {
    if (((uint8_t *)&ram0x2308449c)[iVar2] != puVar1[0x1c]) {
      bl_printk("%s[%02d], %02x %02x\r\n",&UNK_23083384,iVar2);
      bVar3 = true;
    }
    iVar2 = iVar2 + 1;
    puVar1 = puVar1 + 1;
  } while (iVar2 != 0x20);
  if (bVar3) {
    format = "====== Failed %lu Bytes======\r\n";
  }
  else {
    format = "====== Success %lu Bytes=====\r\n";
  }
  bl_printk(format);
  return;
}



int bl_sec_sha_test(void)

{
  puts("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n");
  puts("^^^^^^^^^^^^^^^^^^^^^^^SHA256 TEST CASE^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n");
  sha256_test_case0();
  puts("------------------------------------------------------------------------------------\r\n");
  return 0;
}



int bl_wifi_clock_enable(void)

{
  int called;
  
  return 0;
}



int bl_wifi_enable_irq(void)

{
  bl_irq_register(0x46,mac_irq);
  bl_irq_register(0x4f,bl_irq_handler);
  bl_irq_enable(0x46);
  bl_irq_enable(0x4f);
  puts("Enable BMX IRQ\r\n");
  return 0;
}



int bl_wifi_sta_mac_addr_set(uint8_t *mac)

{
  memcpy(&wifi_env,mac,6);
  return 0;
}



int bl_wifi_ap_mac_addr_set(uint8_t *mac)

{
  memcpy(wifi_env.ap_mac_addr_board,mac,6);
  return 0;
}



int bl_wifi_mac_addr_get(uint8_t *mac)

{
  memcpy(mac,&wifi_env,6);
  return 0;
}



int bl_wifi_country_code_set(uint8_t country_code)

{
  wifi_env.country_code = country_code;
  return 0;
}



int bl_wifi_ap_info_set(uint8_t *ssid,uint8_t ssid_len,uint8_t *psk,uint8_t psk_len,uint8_t chan)

{
  undefined3 in_register_0000202d;
  undefined3 in_register_00002035;
  
  memset(&wifi_env.ap_info,0,99);
  memcpy(&wifi_env.ap_info,ssid,CONCAT31(in_register_0000202d,ssid_len));
  memcpy(wifi_env.ap_info.psk,psk,CONCAT31(in_register_00002035,psk_len));
  wifi_env.ap_info.chan = chan;
  wifi_env.ap_info_en = '\x01';
  return 0;
}



int bl_wifi_sta_info_set
              (uint8_t *ssid,uint8_t ssid_len,uint8_t *psk,uint8_t psk_len,int autoconnect)

{
  undefined3 in_register_0000202d;
  undefined3 in_register_00002035;
  
  memset(&wifi_env.sta_info,0,99);
  memcpy(&wifi_env.sta_info,ssid,CONCAT31(in_register_0000202d,ssid_len));
  memcpy(wifi_env.sta_info.psk,psk,CONCAT31(in_register_00002035,psk_len));
  wifi_env.sta_info_en = (uint8_t)autoconnect;
  return 0;
}



int bl_wifi_sta_info_get(bl_wifi_ap_info_t *sta_info)

{
  if (wifi_env.sta_info_en == '\x01') {
    memcpy(sta_info,&wifi_env.sta_info,99);
    return 0;
  }
  return -1;
}



int cmd_timer_start(void)

{
  TIMER_CFG_Type TStack40;
  
  memcpy(&TStack40,&DAT_23083d64,0x18);
  TIMER_IntMask(TIMER_CH1,TIMER_INT_ALL,MASK);
  TIMER_Disable(TStack40.timerCh);
  TIMER_Init(&TStack40);
  TIMER_ClearIntStatus(TStack40.timerCh,TIMER_COMP_ID_0);
  TIMER_ClearIntStatus(TStack40.timerCh,TIMER_COMP_ID_1);
  TIMER_ClearIntStatus(TStack40.timerCh,TIMER_COMP_ID_2);
  TIMER_IntMask(TStack40.timerCh,TIMER_INT_COMP_0,UNMASK);
  TIMER_IntMask(TStack40.timerCh,TIMER_INT_COMP_1,MASK);
  TIMER_IntMask(TStack40.timerCh,TIMER_INT_COMP_2,MASK);
  TIMER_Enable(TStack40.timerCh);
  bl_irq_enable(0x35);
  bl_irq_register(0x35,int_timer_cb);
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void cmd_wdt_disable(void)

{
  _DAT_4000a564 = _DAT_4000a564 & 0xfffffffe;
  _DAT_4000a59c = _DAT_4000a59c & 0xffff0000 | 0xbaba;
  _DAT_4000a5a0 = _DAT_4000a5a0 & 0xffff0000 | 0xeb10;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void cmd_wdt_feed(void)

{
  _DAT_4000a598 = _DAT_4000a598 | 1;
  _DAT_4000a59c = _DAT_4000a59c & 0xffff0000 | 0xbaba;
  _DAT_4000a5a0 = _DAT_4000a5a0 & 0xffff0000 | 0xeb10;
  return;
}



void cmd_wdt_init(int param_1,undefined4 *param_2)

{
  int ms;
  
  if (param_1 != 2) {
    if (TrapNetCounter == 0) {
      xTaskGetTickCount();
    }
    else {
      xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] Usage: %s ms\r\n",&DAT_2307f16c,"bl_wdt_cli.c",0x2a,*param_2);
    return;
  }
  ms = atoi((char *)param_2[1]);
  if (TrapNetCounter == 0) {
    xTaskGetTickCount();
  }
  else {
    xTaskGetTickCountFromISR();
  }
  bl_printk("[%10u][%s: %s:%4d] Init WDT with %dms\r\n",&DAT_2307f16c,"bl_wdt_cli.c",0x2e,ms);
  if (0 < ms) {
    bl_wdt_init(ms);
    return;
  }
  return;
}



int bl_wdt_cli_init(void)

{
  return 0;
}



uint32_t fdt32_to_cpu(fdt32_t x)

{
  return (x >> 0x10 & 0xff) << 8 | x << 0x18 | x >> 0x18 | (x >> 8 & 0xff) << 0x10;
}



int dev_uart_init(uint8_t id,char *path,uint32_t rx_buf_size,uint32_t tx_buf_size)

{
  uart_dev_t **ppuVar1;
  undefined3 in_register_00002029;
  uint uVar2;
  TickType_t TVar3;
  char *format;
  void *pvVar4;
  int iVar5;
  undefined4 uVar6;
  uart_dev_t *__s;
  
  uVar2 = CONCAT31(in_register_00002029,id);
  if ((uVar2 < 3) && (path != (char *)0x0)) {
    if (uVar2 == 0) {
      ppuVar1 = &dev_uart0;
      __s = dev_uart0;
    }
    else {
      if (uVar2 != 1) {
        if (BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) {
          return -1;
        }
        if (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvhal_uart) {
          return -1;
        }
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        uVar6 = 0x74;
        format = "[%10u][%s: %s:%4d] err.\r\n";
        goto LAB_23035abc;
      }
      ppuVar1 = &dev_uart1;
      __s = dev_uart1;
    }
    if (__s == (uart_dev_t *)0x0) {
      __s = (uart_dev_t *)pvPortMalloc(0x3c);
      *ppuVar1 = __s;
      if (__s == (uart_dev_t *)0x0) {
        if (BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) {
          return -1;
        }
        if (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvhal_uart) {
          return -1;
        }
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        uVar6 = 0x3c;
      }
      else {
        memset(__s,0,0x3c);
        (*ppuVar1)->read_block_flag = '\x02';
        (*ppuVar1)->priv = (void *)0x0;
        __s = *ppuVar1;
        pvVar4 = pvPortMalloc(4);
        __s->priv = pvVar4;
        if ((*ppuVar1)->priv != (void *)0x0) {
          memset((*ppuVar1)->priv,0,4);
          (*ppuVar1)->rx_buf_size = rx_buf_size;
          (*ppuVar1)->tx_buf_size = tx_buf_size;
          if (*ppuVar1 == (uart_dev_t *)0x0) {
            if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
               (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_ASSERT)) {
              if (TrapNetCounter == 0) {
                TVar3 = xTaskGetTickCount();
              }
              else {
                TVar3 = xTaskGetTickCountFromISR();
              }
              bl_printk("[%10u][%s: %s:%4d] mem err.\r\n",TVar3,&DAT_23072bcc,"hal_uart.c",0x50);
            }
          }
          else {
            (*ppuVar1)->port = id;
            (*ppuVar1)->read_block_flag = '\x02';
            ((*ppuVar1)->config).baud_rate = 0x1c200;
            ((*ppuVar1)->config).data_width = DATA_WIDTH_8BIT;
            ((*ppuVar1)->config).parity = NO_PARITY;
            ((*ppuVar1)->config).stop_bits = STOP_BITS_1;
            ((*ppuVar1)->config).flow_control = FLOW_CONTROL_DISABLED;
            ((*ppuVar1)->config).mode = MODE_TX_RX;
          }
          iVar5 = aos_register_driver(path,(file_ops_t *)&uart_ops,*ppuVar1);
          return iVar5;
        }
        if (BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) {
          return -1;
        }
        if (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvhal_uart) {
          return -1;
        }
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        uVar6 = 0x45;
      }
      format = "[%10u][%s: %s:%4d] mem err.\r\n";
      goto LAB_23035abc;
    }
    if (BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) {
      return -1;
    }
    if (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvhal_uart) {
      return -1;
    }
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    uVar6 = 0x36;
  }
  else {
    if (BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) {
      return -1;
    }
    if (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvhal_uart) {
      return -1;
    }
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    uVar6 = 0x65;
  }
  format = "[%10u][%s: %s:%4d] arg err.\r\n";
LAB_23035abc:
  bl_printk(format,TVar3,&DAT_23072bcc,"hal_uart.c",uVar6);
  return -1;
}



int32_t hal_uart_send_trigger(uart_dev_t *uart)

{
  bl_uart_int_tx_enable(uart->port);
  return 0;
}



int32_t hal_uart_send_trigger_off(uart_dev_t *uart)

{
  bl_uart_int_tx_disable(uart->port);
  return 0;
}



int32_t hal_uart_init(uart_dev_t *uart)

{
  int iVar1;
  int iVar2;
  hal_uart_parity_t ahStack17 [4];
  uint8_t parity;
  
  iVar2 = aos_mutex_new((aos_mutex_t *)uart->priv);
  iVar1 = -1;
  if (iVar2 == 0) {
    bl_uart_getdefconfig(uart->port,ahStack17);
    if (ahStack17[0] == NO_PARITY) {
      (uart->config).parity = NO_PARITY;
    }
    else {
      if (ahStack17[0] != ODD_PARITY) {
        ahStack17[0] = EVEN_PARITY;
      }
      (uart->config).parity = ahStack17[0];
    }
    bl_uart_int_enable(uart->port);
    iVar1 = iVar2;
  }
  return iVar1;
}



int32_t hal_uart_recv_II(uart_dev_t *uart,void *data,uint32_t expect_size,uint32_t *recv_size,
                        uint32_t timeout)

{
  uint32_t uVar1;
  int iVar2;
  
  uVar1 = 0;
  while (uVar1 != expect_size) {
    iVar2 = bl_uart_data_recv(uart->port);
    if (iVar2 < 0) break;
    *(undefined *)((int)data + uVar1) = (char)iVar2;
    uVar1 = uVar1 + 1;
  }
  *recv_size = uVar1;
  return 0;
}



int32_t hal_uart_send(uart_dev_t *uart,void *data,uint32_t size,uint32_t timeout)

{
  uint8_t data_00;
  uint8_t *puVar1;
  
  puVar1 = (uint8_t *)((int)data + size);
  while ((uint8_t *)data != puVar1) {
    data_00 = *(uint8_t *)data;
    data = (uint8_t *)data + 1;
    bl_uart_data_send(uart->port,data_00);
  }
  return 0;
}



int32_t hal_uart_finalize(uart_dev_t *uart)

{
  aos_mutex_t *mutex;
  
  mutex = (aos_mutex_t *)uart->priv;
  bl_uart_int_disable(uart->port);
  aos_mutex_free(mutex);
  return 0;
}



int32_t hal_uart_notify_register(uart_dev_t *uart,hal_uart_int_t type,anon_subr_void_void_ptr *cb)

{
  undefined3 in_register_0000202d;
  
  if (CONCAT31(in_register_0000202d,type) == 0) {
    bl_uart_int_tx_notify_register(uart->port,(cb_uart_notify_t *)cb,uart);
  }
  else {
    if (CONCAT31(in_register_0000202d,type) != 1) {
      return -1;
    }
    bl_uart_int_rx_notify_register(uart->port,(cb_uart_notify_t *)cb,uart);
  }
  return 0;
}



undefined4 vfs_uart_init(void *param_1,int param_2)

{
  int nodeoffset;
  char *property;
  int nodeoffset_00;
  TickType_t TVar1;
  fdt32_t *pfVar2;
  uint32_t baudrate;
  uint32_t uVar3;
  int iVar4;
  char *__s2;
  uint32_t uVar5;
  undefined4 uVar6;
  int iVar7;
  char *name;
  fdt32_t x;
  fdt32_t x_00;
  char **ppcVar8;
  uint32_t rx_buf_size;
  uint32_t tx_buf_size;
  fdt32_t x_01;
  uint8_t uStack152;
  char **ppcStack148;
  uint local_7c;
  char *pcStack120;
  char *pcStack116;
  char *local_70;
  undefined4 uStack108;
  byte bStack104;
  uint8_t uStack92;
  uint8_t uStack80;
  uint8_t uStack68;
  char *apcStack64 [3];
  
  if (inited == '\x01') {
    return 0;
  }
  pcStack120 = "uart@4000A000";
  pcStack116 = "uart@4000A100";
  local_7c = 0;
  memcpy(&local_70,&PTR_DAT_230845d0,0x30);
  ppcStack148 = &pcStack120;
  iVar7 = 0;
  do {
    name = *ppcStack148;
    nodeoffset = fdt_subnode_offset(param_1,param_2,name);
    if (nodeoffset < 1) {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          xTaskGetTickCount();
        }
        else {
          xTaskGetTickCountFromISR();
        }
        uVar6 = 300;
        goto LAB_23035e5a;
      }
    }
    else {
      name = (char *)fdt_stringlist_count(param_1,nodeoffset,"status");
      if (name == (char *)0x1) {
        name = fdt_stringlist_get(param_1,nodeoffset,"status",0,(int *)&local_7c);
        if ((local_7c == 4) && (nodeoffset_00 = memcmp(&DAT_23084714,name,4), nodeoffset_00 == 0)) {
          name = (char *)fdt_stringlist_count(param_1,nodeoffset,"path");
          if (name == (char *)0x1) {
            name = fdt_stringlist_get(param_1,nodeoffset,"path",0,(int *)&local_7c);
            if (((0x20 < local_7c) && (_fsymc_level_hal_drv < BLOG_LEVEL_WARN)) &&
               (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
              if (TrapNetCounter == 0) {
                TVar1 = xTaskGetTickCount();
              }
              else {
                TVar1 = xTaskGetTickCountFromISR();
              }
              bl_printk("[%10u][%s: %s:%4d] uart[%d] path lentmp = %d\r\n",TVar1,&DAT_2307f16c,
                        "hal_uart.c",0x144,iVar7,local_7c);
            }
            pfVar2 = (fdt32_t *)fdt_getprop(param_1,nodeoffset,"baudrate",(int *)&local_7c);
            if (pfVar2 == (fdt32_t *)0x0) {
              if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                 (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                if (TrapNetCounter == 0) {
                  xTaskGetTickCount();
                }
                else {
                  xTaskGetTickCountFromISR();
                }
                uVar6 = 0x14b;
                name = "[%10u][%s: %s:%4d] uart[%d] baudrate NULL.\r\n";
LAB_23036086:
                bl_printk(name,&DAT_2307f16c,"hal_uart.c",uVar6,iVar7);
              }
            }
            else {
              x_00 = *pfVar2;
              pfVar2 = (fdt32_t *)fdt_getprop(param_1,nodeoffset,"id",(int *)&local_7c);
              if (pfVar2 == (fdt32_t *)0x0) {
                if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                   (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                  if (TrapNetCounter == 0) {
                    xTaskGetTickCount();
                  }
                  else {
                    xTaskGetTickCountFromISR();
                  }
                  uVar6 = 0x153;
                  name = "[%10u][%s: %s:%4d] uart[%d] id NULL.\r\n";
                  goto LAB_23036086;
                }
              }
              else {
                x = *pfVar2;
                nodeoffset_00 = fdt_subnode_offset(param_1,nodeoffset,"buf_size");
                if (nodeoffset_00 < 1) {
                  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                     (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                    if (TrapNetCounter == 0) {
                      TVar1 = xTaskGetTickCount();
                    }
                    else {
                      TVar1 = xTaskGetTickCountFromISR();
                    }
                    bl_printk("[%10u][%s: %s:%4d] uart[%d] buf_size NULL, will use default.\r\n",
                              TVar1,&DAT_2307f16c,"hal_uart.c",0x15b,iVar7);
                  }
                  tx_buf_size = 0x200;
                  rx_buf_size = 0x200;
LAB_2303620a:
                  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                     (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                    if (TrapNetCounter == 0) {
                      TVar1 = xTaskGetTickCount();
                    }
                    else {
                      TVar1 = xTaskGetTickCountFromISR();
                    }
                    bl_printk("[%10u][%s: %s:%4d] uart[%d] rx_buf_size %d, tx_buf_size %d\r\n",TVar1
                              ,&DAT_2307f16c,"hal_uart.c",0x16c,iVar7,rx_buf_size,tx_buf_size);
                  }
                  baudrate = fdt32_to_cpu(x_00);
                  uVar3 = fdt32_to_cpu(x);
                  ppcVar8 = &local_70;
                  do {
                    nodeoffset_00 = fdt_subnode_offset(param_1,nodeoffset,"feature");
                    if (nodeoffset_00 < 1) {
                      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                         (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                        if (TrapNetCounter == 0) {
                          TVar1 = xTaskGetTickCount();
                        }
                        else {
                          TVar1 = xTaskGetTickCountFromISR();
                        }
                        bl_printk("[%10u][%s: %s:%4d] uart[%d] feature NULL.\r\n",TVar1,
                                  &DAT_2307f16c,"hal_uart.c",0x171,iVar7);
                      }
                    }
                    else {
                      property = *ppcVar8;
                      iVar4 = fdt_stringlist_count(param_1,nodeoffset_00,property);
                      if (iVar4 == 1) {
                        __s2 = fdt_stringlist_get(param_1,nodeoffset_00,property,0,(int *)&local_7c)
                        ;
                        if ((local_7c == 4) &&
                           (nodeoffset_00 = memcmp(&DAT_23084714,__s2,4), nodeoffset_00 == 0)) {
                          nodeoffset_00 = fdt_subnode_offset(param_1,nodeoffset,"pin");
                          if (nodeoffset_00 < 1) {
                            if ((BLOG_LEVEL_INFO < _fsymc_level_hal_drv) ||
                               (BLOG_LEVEL_INFO < _fsymf_level_hal_drvhal_uart)) goto LAB_230363c4;
                            if (TrapNetCounter == 0) {
                              TVar1 = xTaskGetTickCount();
                            }
                            else {
                              TVar1 = xTaskGetTickCountFromISR();
                            }
                            bl_printk("[%10u][%s: %s:%4d] uart[%d] pin NULL.\r\n",TVar1,
                                      &DAT_2307f16c,"hal_uart.c",0x182,iVar7);
                            break;
                          }
                          property = ppcVar8[1];
                          pfVar2 = (fdt32_t *)
                                   fdt_getprop(param_1,nodeoffset_00,property,(int *)&local_7c);
                          if (pfVar2 == (fdt32_t *)0x0) {
                            if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                               (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                              if (TrapNetCounter == 0) {
                                TVar1 = xTaskGetTickCount();
                              }
                              else {
                                TVar1 = xTaskGetTickCountFromISR();
                              }
                              bl_printk("[%10u][%s: %s:%4d] uart[%d] %s NULL.\r\n",TVar1,
                                        &DAT_2307f16c,"hal_uart.c",0x187,iVar7,property);
                            }
                          }
                          else {
                            uVar5 = fdt32_to_cpu(*pfVar2);
                            *(char *)(ppcVar8 + 2) = (char)uVar5;
                          }
                        }
                        else {
                          if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                             (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                            if (TrapNetCounter == 0) {
                              TVar1 = xTaskGetTickCount();
                            }
                            else {
                              TVar1 = xTaskGetTickCountFromISR();
                            }
                            bl_printk("[%10u][%s: %s:%4d] uart[%d] %s status = %s lentmp = %d\r\n",
                                      TVar1,&DAT_2307f16c,"hal_uart.c",0x17b,iVar7,property,__s2);
                          }
                        }
                      }
                      else {
                        if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                           (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                          if (TrapNetCounter == 0) {
                            TVar1 = xTaskGetTickCount();
                          }
                          else {
                            TVar1 = xTaskGetTickCountFromISR();
                          }
                          bl_printk("[%10u][%s: %s:%4d] uart[%d] %s countindex = %d.\r\n",TVar1,
                                    &DAT_2307f16c,"hal_uart.c",0x176,iVar7,property,iVar4);
                        }
                      }
                    }
                    ppcVar8 = ppcVar8 + 3;
                  } while (apcStack64 != ppcVar8);
                  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                     (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                    if (TrapNetCounter == 0) {
                      TVar1 = xTaskGetTickCount();
                    }
                    else {
                      TVar1 = xTaskGetTickCountFromISR();
                    }
                    bl_printk(
                              "[%10u][%s: %s:%4d] id = %d, %s = %d, %s = %d, %s = %d, %s = %d baudrate = %ld.\r\n"
                              ,TVar1,&DAT_2307f16c,"hal_uart.c",0x192,uVar3 & 0xff,uStack108,
                              (uint)bStack104);
                  }
LAB_230363c4:
                  uStack152 = (uint8_t)uVar3;
                  bl_uart_flush(uStack152);
                  bl_uart_init(uStack152,bStack104,uStack92,uStack80,uStack68,baudrate);
                  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                     (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                    if (TrapNetCounter == 0) {
                      TVar1 = xTaskGetTickCount();
                    }
                    else {
                      TVar1 = xTaskGetTickCountFromISR();
                    }
                    bl_printk("[%10u][%s: %s:%4d] bl_uart_init %d ok.\r\n",TVar1,&DAT_2307f16c,
                              "hal_uart.c",0x19a,uVar3 & 0xff);
                    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                       (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                      if (TrapNetCounter == 0) {
                        TVar1 = xTaskGetTickCount();
                      }
                      else {
                        TVar1 = xTaskGetTickCountFromISR();
                      }
                      bl_printk("[%10u][%s: %s:%4d] bl_uart_init %d baudrate = %ld ok.\r\n",TVar1,
                                &DAT_2307f16c,"hal_uart.c",0x19b,uVar3 & 0xff,baudrate);
                    }
                  }
                  nodeoffset = dev_uart_init(uStack152,name,rx_buf_size,tx_buf_size);
                  if (((nodeoffset != 0) && (_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT)) &&
                     (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_ASSERT)) {
                    if (TrapNetCounter == 0) {
                      xTaskGetTickCount();
                    }
                    else {
                      xTaskGetTickCountFromISR();
                    }
                    bl_printk("[%10u][%s: %s:%4d] dev_uart_init err.\r\n",&DAT_23072bcc,"hal_uart.c"
                              ,0x19e);
                  }
                }
                else {
                  pfVar2 = (fdt32_t *)fdt_getprop(param_1,nodeoffset_00,"rx_size",(int *)&local_7c);
                  if (pfVar2 == (fdt32_t *)0x0) {
                    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                       (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                      if (TrapNetCounter == 0) {
                        xTaskGetTickCount();
                      }
                      else {
                        xTaskGetTickCountFromISR();
                      }
                      name = "rx_size";
                      uVar6 = 0x161;
LAB_23035e5a:
                      property = "[%10u][%s: %s:%4d] uart[%d] %s NULL.\r\n";
                      goto LAB_23035ece;
                    }
                  }
                  else {
                    x_01 = *pfVar2;
                    pfVar2 = (fdt32_t *)
                             fdt_getprop(param_1,nodeoffset_00,"tx_size",(int *)&local_7c);
                    if (pfVar2 != (fdt32_t *)0x0) {
                      rx_buf_size = fdt32_to_cpu(x_01);
                      tx_buf_size = fdt32_to_cpu(*pfVar2);
                      goto LAB_2303620a;
                    }
                    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                       (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                      if (TrapNetCounter == 0) {
                        xTaskGetTickCount();
                      }
                      else {
                        xTaskGetTickCountFromISR();
                      }
                      name = "tx_size";
                      uVar6 = 0x167;
                      goto LAB_23035e5a;
                    }
                  }
                }
              }
            }
          }
          else {
            if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
               (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
              if (TrapNetCounter == 0) {
                xTaskGetTickCount();
              }
              else {
                xTaskGetTickCountFromISR();
              }
              uVar6 = 0x13e;
              property = "[%10u][%s: %s:%4d] uart[%d] path_countindex = %d NULL.\r\n";
              goto LAB_23035ece;
            }
          }
        }
        else {
          if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
             (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
            if (TrapNetCounter == 0) {
              xTaskGetTickCount();
            }
            else {
              xTaskGetTickCountFromISR();
            }
            uVar6 = 0x137;
            property = "[%10u][%s: %s:%4d] uart[%d] status = %s\r\n";
            goto LAB_23035ece;
          }
        }
      }
      else {
        if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
           (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
          if (TrapNetCounter == 0) {
            xTaskGetTickCount();
          }
          else {
            xTaskGetTickCountFromISR();
          }
          uVar6 = 0x132;
          property = "[%10u][%s: %s:%4d] uart[%d] status_countindex = %d NULL.\r\n";
LAB_23035ece:
          bl_printk(property,&DAT_2307f16c,"hal_uart.c",uVar6,iVar7,name);
        }
      }
    }
    ppcStack148 = ppcStack148 + 1;
    if (iVar7 != 0) {
      inited = (int8_t)iVar7;
      return 0;
    }
    iVar7 = 1;
  } while( true );
}



int32_t hal_uart_send_flush(uart_dev_t *uart,uint32_t timeout)

{
  bl_uart_flush(uart->port);
  return 0;
}



void hal_uart_setbaud(uart_dev_t *uart,uint32_t baud)

{
  bl_uart_setbaud(uart->port,baud);
  return;
}



void hal_uart_setconfig(uart_dev_t *uart,uint32_t baud,hal_uart_parity_t parity)

{
  bl_uart_setconfig(uart->port,baud,parity);
  return;
}



undefined4 hal_gpio_init_from_dts(void *param_1,int param_2)

{
  uint uVar1;
  uint *puVar2;
  int nodeoffset;
  char *format;
  TickType_t TVar3;
  int iVar4;
  char *format_00;
  undefined *puVar5;
  undefined4 uVar6;
  uint uVar7;
  int iVar8;
  int local_5c;
  char acStack88 [11];
  undefined uStack77;
  uint uStack76;
  char cStack72;
  byte bStack71;
  byte bStack70;
  undefined uStack69;
  uint uStack68;
  
  uStack76 = 0;
  puVar2 = (uint *)fdt_getprop(param_1,param_2,"max_num",(int *)&uStack76);
  uVar1 = 0xffffffff;
  if (puVar2 != (uint *)0x0) {
    uVar1 = *puVar2;
    uVar1 = uVar1 << 0x18 | uVar1 >> 0x18 | (uVar1 >> 8 & 0xff) << 0x10 |
            (uVar1 >> 0x10 & 0xff) << 8;
  }
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvhal_gpio < BLOG_LEVEL_WARN))
  {
    if (TrapNetCounter == 0) {
      xTaskGetTickCount();
    }
    else {
      xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [HAL] [GPIO] Max num is %d\r\n",&DAT_2307f16c,"hal_gpio.c",0xb5,
              uVar1);
  }
  iVar8 = 0;
  do {
    if ((int)uVar1 <= iVar8) {
      return 0;
    }
    snprintf(acStack88,0xb,"gpio%u",iVar8);
    uStack77 = 0;
    local_5c = 0;
    nodeoffset = fdt_subnode_offset(param_1,param_2,acStack88);
    if (nodeoffset < 0) {
      if (BLOG_LEVEL_INFO < _fsymc_level_hal_drv) {
        return 0;
      }
      if (BLOG_LEVEL_INFO < _fsymf_level_hal_drvhal_gpio) {
        return 0;
      }
      if (TrapNetCounter == 0) {
        xTaskGetTickCount();
      }
      else {
        xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] %s NOT found\r\n",&DAT_2307f16c,"hal_gpio.c",0x61,acStack88);
      return 0;
    }
    memset(&uStack76,0,0xc);
    cStack72 = '\0';
    format = fdt_stringlist_get(param_1,nodeoffset,"status",0,&local_5c);
    if ((local_5c == 4) && (iVar4 = memcmp(&DAT_23084714,format,4), iVar4 == 0)) {
      puVar2 = (uint *)fdt_getprop(param_1,nodeoffset,"pin",&local_5c);
      if (puVar2 == (uint *)0x0) {
        if ((BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) ||
           (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvhal_gpio)) goto LAB_2303678a;
        if (TrapNetCounter == 0) {
          xTaskGetTickCount();
        }
        else {
          xTaskGetTickCountFromISR();
        }
        uVar6 = 0x70;
        format = "[%10u][%s: %s:%4d] no pin found for %s\r\n";
LAB_23036848:
        bl_printk(format,&DAT_23072bcc,"hal_gpio.c",uVar6,acStack88);
      }
      else {
        uVar7 = *puVar2;
        uStack76 = (uVar7 >> 0x10 & 0xff) << 8 |
                   uVar7 << 0x18 | uVar7 >> 0x18 | (uVar7 >> 8 & 0xff) << 0x10;
        format = fdt_stringlist_get(param_1,nodeoffset,"feature",0,&local_5c);
        if ((local_5c != 3) || (iVar4 = memcmp("led",format,3), iVar4 != 0)) {
          if ((BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) ||
             (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvhal_gpio)) goto LAB_2303678a;
          if (TrapNetCounter == 0) {
            xTaskGetTickCount();
          }
          else {
            xTaskGetTickCountFromISR();
          }
          uVar6 = 0x79;
LAB_230369ca:
          puVar5 = &DAT_23072bcc;
          format_00 = "[%10u][%s: %s:%4d] %s: unvalid GPIO config %3s\r\n";
          goto LAB_2303687e;
        }
        bStack71 = 0;
        format = fdt_stringlist_get(param_1,nodeoffset,"active",0,&local_5c);
        if (local_5c == 2) {
          iVar4 = memcmp(&DAT_23084b70,format,2);
          if (iVar4 == 0) {
            bStack70 = 1;
          }
          else {
            if ((local_5c != 2) || (iVar4 = memcmp(&DAT_23084b74,format,2), iVar4 != 0))
            goto LAB_23036a06;
            bStack70 = 0;
          }
          format = fdt_stringlist_get(param_1,nodeoffset,"mode",0,&local_5c);
          if ((local_5c == 5) && (iVar4 = memcmp("blink",format,5), iVar4 == 0)) {
            uStack69 = 0;
          }
          else {
            if ((local_5c != 9) || (iVar4 = memcmp("heartbeat",format,9), iVar4 != 0)) {
              if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
                 (_fsymf_level_hal_drvhal_gpio < BLOG_LEVEL_ASSERT)) {
                if (TrapNetCounter == 0) {
                  xTaskGetTickCount();
                }
                else {
                  xTaskGetTickCountFromISR();
                }
                uVar6 = 0x8d;
                goto LAB_230369ca;
              }
              goto LAB_2303678a;
            }
            uStack69 = 1;
          }
          puVar2 = (uint *)fdt_getprop(param_1,nodeoffset,"time",&local_5c);
          if (puVar2 == (uint *)0x0) {
            if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
               (_fsymf_level_hal_drvhal_gpio < BLOG_LEVEL_ASSERT)) {
              if (TrapNetCounter == 0) {
                xTaskGetTickCount();
              }
              else {
                xTaskGetTickCountFromISR();
              }
              uVar6 = 0x93;
              format = "[%10u][%s: %s:%4d] %s: unvalid GPIO config\r\n";
              goto LAB_23036848;
            }
          }
          else {
            uVar7 = *puVar2;
            uStack68 = (uVar7 >> 0x10 & 0xff) << 8 |
                       uVar7 << 0x18 | uVar7 >> 0x18 | (uVar7 >> 8 & 0xff) << 0x10;
            cStack72 = '\x01';
          }
        }
        else {
LAB_23036a06:
          if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
             (_fsymf_level_hal_drvhal_gpio < BLOG_LEVEL_ASSERT)) {
            if (TrapNetCounter == 0) {
              xTaskGetTickCount();
            }
            else {
              xTaskGetTickCountFromISR();
            }
            uVar6 = 0x83;
            goto LAB_230369ca;
          }
        }
      }
    }
    else {
      if ((BLOG_LEVEL_INFO < _fsymc_level_hal_drv) ||
         (BLOG_LEVEL_INFO < _fsymf_level_hal_drvhal_gpio)) goto LAB_2303678a;
      if (TrapNetCounter == 0) {
        xTaskGetTickCount();
      }
      else {
        xTaskGetTickCountFromISR();
      }
      uVar6 = 0x6a;
      puVar5 = &DAT_2307f16c;
      format_00 = "[%10u][%s: %s:%4d] [%s] status = %s\r\n";
LAB_2303687e:
      bl_printk(format_00,puVar5,"hal_gpio.c",uVar6,acStack88,format);
    }
LAB_2303678a:
    if (cStack72 == '\x01') {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_gpio < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk(
                  "[%10u][%s: %s:%4d] New CONF: GPIO%02u: feature %u, active %u, mode %u, time %u\r\n"
                  ,TVar3,&DAT_2307f16c,"hal_gpio.c",0xa6,uStack76,(uint)bStack71,(uint)bStack70);
      }
      loopset_led_trigger(uStack76,uStack68);
    }
    else {
      if (((cStack72 == '\0') && (_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT)) &&
         (_fsymf_level_hal_drvhal_gpio < BLOG_LEVEL_ASSERT)) {
        if (TrapNetCounter == 0) {
          xTaskGetTickCount();
        }
        else {
          xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] %s: unvalid GPIO config\r\n",&DAT_23072bcc,"hal_gpio.c",0xc3,
                  acStack88);
      }
    }
    iVar8 = iVar8 + 1;
  } while( true );
}



void _dump_partition(void)

{
  int iVar1;
  anon_struct_conflict371 *paVar2;
  
  bl_printk("======= PtTable_Config @%p=======\r\n",0x4200d9cc);
  bl_printk("magicCode 0x%08X;",boot2_partition_table.table.ptTable.magicCode);
  bl_printk(" version 0x%04X;",(uint)boot2_partition_table.table.ptTable.version);
  bl_printk(" entryCnt %u;",(uint)boot2_partition_table.table.ptTable.entryCnt);
  bl_printk(" age %lu;",boot2_partition_table.table.ptTable.age);
  bl_printk(" crc32 0x%08X\r\n");
  bl_printk(
           "idx  type device activeIndex     name   Address[0]  Address[1]  Length[0]   Length[1]   age\r\n"
           );
  iVar1 = 0;
  paVar2 = &boot2_partition_table;
  while( true ) {
    if ((int)(uint)boot2_partition_table.table.ptTable.entryCnt <= iVar1) break;
    bl_printk("[%02d] ",iVar1);
    iVar1 = iVar1 + 1;
    bl_printk(" %02u",(uint)(paVar2->table).ptEntries[0].type);
    bl_printk("     %u",(uint)(paVar2->table).ptEntries[0].device);
    bl_printk("         %u",(uint)(paVar2->table).ptEntries[0].activeIndex);
    bl_printk("      %8s",(paVar2->table).ptEntries[0].name);
    bl_printk("  %p",(paVar2->table).ptEntries[0].Address[0]);
    bl_printk("  %p",(paVar2->table).ptEntries[0].Address[1]);
    bl_printk("  %p",(paVar2->table).ptEntries[0].maxLen[0]);
    bl_printk("  %p",(paVar2->table).ptEntries[0].maxLen[1]);
    bl_printk("  %lu\r\n");
    paVar2 = (anon_struct_conflict371 *)((paVar2->table).ptEntries[0].Address + 1);
  }
  return;
}



int hal_boot2_update_ptable(HALPartition_Entry_Config *ptEntry_hal)

{
  uint8_t uVar1;
  PtTable_Error_Type PVar2;
  undefined3 extraout_var;
  
  *(bool *)&ptEntry_hal->activeIndex = ptEntry_hal->activeIndex == '\0';
  uVar1 = boot2_partition_table.partition_active_idx;
  ptEntry_hal->age = ptEntry_hal->age + 1;
  PVar2 = PtTable_Update_Entry
                    ((SPI_Flash_Cfg_Type *)0x0,uVar1 == '\0',&boot2_partition_table.table,
                     (PtTable_Entry_Config *)ptEntry_hal);
  return CONCAT31(extraout_var,PVar2);
}



uint32_t hal_boot2_get_flash_addr(void)

{
  return (uint)boot2_partition_table.table.ptTable.entryCnt * 0x24 + 0x42049c18;
}



int hal_boot2_partition_bus_addr
              (char *name,uint32_t *addr0,uint32_t *addr1,uint32_t *size0,uint32_t *size1,
              int *active)

{
  byte bVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  anon_struct_conflict371 *paVar5;
  uint uVar6;
  uint uVar7;
  anon_struct_conflict371 *paVar8;
  
  if (boot2_partition_table.table.ptTable.magicCode != 0x54504642) {
    return -5;
  }
  paVar8 = &boot2_partition_table;
  paVar5 = &boot2_partition_table;
  uVar2 = 0;
  while ((int)uVar2 < (int)(uint)boot2_partition_table.table.ptTable.entryCnt) {
    iVar4 = strcmp((char *)(paVar5->table).ptEntries[0].name,name);
    paVar5 = (anon_struct_conflict371 *)((paVar5->table).ptEntries[0].Address + 1);
    if (iVar4 == 0) break;
    uVar2 = uVar2 + 1;
  }
  iVar4 = -2;
  if (uVar2 != (uint)boot2_partition_table.table.ptTable.entryCnt) {
    uVar7 = boot2_partition_table.table.ptEntries[uVar2].Address[0];
    uVar6 = boot2_partition_table.table.ptEntries[uVar2].Address[1];
    *active = (uint)boot2_partition_table.table.ptEntries[uVar2].activeIndex;
    *size0 = boot2_partition_table.table.ptEntries[uVar2].maxLen[0];
    uVar3 = 0;
    *size1 = *(uint32_t *)((int)&boot2_partition_table.table.ptTable + (uVar2 + 1) * 0x24 + 4);
    while ((int)uVar3 < (int)(uint)boot2_partition_table.table.ptTable.entryCnt) {
      iVar4 = strcmp((char *)(paVar8->table).ptEntries[0].name,"FW");
      paVar8 = (anon_struct_conflict371 *)((paVar8->table).ptEntries[0].Address + 1);
      if (iVar4 == 0) break;
      uVar3 = uVar3 + 1;
    }
    iVar4 = -0x8c;
    if (uVar3 != (uint)boot2_partition_table.table.ptTable.entryCnt) {
      if (uVar7 != 0) {
        if (uVar7 < boot2_partition_table.table.ptEntries[uVar3].Address[0]) {
          return -0x16;
        }
        if (uVar7 < boot2_partition_table.table.ptEntries[uVar3].Address[1]) {
          return -0x16;
        }
      }
      if (uVar6 != 0) {
        if (uVar6 < boot2_partition_table.table.ptEntries[uVar3].Address[0]) {
          return -0x16;
        }
        if (uVar6 < boot2_partition_table.table.ptEntries[uVar3].Address[1]) {
          return -0x16;
        }
      }
      iVar4 = -0xe;
      bVar1 = boot2_partition_table.table.ptEntries[uVar3].activeIndex;
      if (bVar1 < 2) {
        iVar4 = 0;
        *addr0 = (uVar7 + 0x22fff000) -
                 (&boot2_partition_table.table.ptTable.crc32)[(uint)bVar1 + uVar3 * 9 + 4];
        *addr1 = (uVar6 + 0x22fff000) -
                 (&boot2_partition_table.table.ptTable.crc32)
                 [uVar3 * 9 + (uint)boot2_partition_table.table.ptEntries[uVar3].activeIndex + 4];
      }
    }
  }
  return iVar4;
}



int hal_boot2_partition_bus_addr_active(char *name,uint32_t *addr,uint32_t *size)

{
  int iVar1;
  uint32_t uStack36;
  uint32_t addr0;
  uint32_t addr1;
  uint32_t size0;
  uint32_t size1;
  int active;
  
  iVar1 = hal_boot2_partition_bus_addr(name,&uStack36,&addr0,&addr1,&size0,(int *)&size1);
  if (iVar1 == 0) {
    if (size1 != 0) {
      uStack36 = addr0;
    }
    *addr = uStack36;
    if (size1 != 0) {
      addr1 = size0;
    }
    *size = addr1;
  }
  return iVar1;
}



int hal_boot2_partition_bus_addr_inactive(char *name,uint32_t *addr,uint32_t *size)

{
  int iVar1;
  uint32_t uStack36;
  uint32_t addr0;
  uint32_t addr1;
  uint32_t size0;
  uint32_t size1;
  int active;
  
  iVar1 = hal_boot2_partition_bus_addr(name,&uStack36,&addr0,&addr1,&size0,(int *)&size1);
  if (iVar1 == 0) {
    if (size1 != 0) {
      addr0 = uStack36;
    }
    *addr = addr0;
    if (size1 != 0) {
      size0 = addr1;
    }
    *size = size0;
  }
  return iVar1;
}



int hal_boot2_partition_addr
              (char *name,uint32_t *addr0,uint32_t *addr1,uint32_t *size0,uint32_t *size1,
              int *active)

{
  uint uVar1;
  anon_struct_conflict371 *paVar2;
  int iVar3;
  
  if (boot2_partition_table.table.ptTable.magicCode == 0x54504642) {
    paVar2 = &boot2_partition_table;
    uVar1 = 0;
    while ((int)uVar1 < (int)(uint)boot2_partition_table.table.ptTable.entryCnt) {
      iVar3 = strcmp((char *)(paVar2->table).ptEntries[0].name,name);
      paVar2 = (anon_struct_conflict371 *)((paVar2->table).ptEntries[0].Address + 1);
      if (iVar3 == 0) break;
      uVar1 = uVar1 + 1;
    }
    iVar3 = -2;
    if (uVar1 != (uint)boot2_partition_table.table.ptTable.entryCnt) {
      *addr0 = boot2_partition_table.table.ptEntries[uVar1].Address[0];
      *addr1 = boot2_partition_table.table.ptEntries[uVar1].Address[1];
      *size0 = boot2_partition_table.table.ptEntries[uVar1].maxLen[0];
      *size1 = *(uint32_t *)((int)&boot2_partition_table.table.ptTable + (uVar1 + 1) * 0x24 + 4);
      iVar3 = 0;
      *active = (uint)boot2_partition_table.table.ptEntries[uVar1].activeIndex;
    }
  }
  else {
    iVar3 = -5;
  }
  return iVar3;
}



int hal_boot2_partition_addr_active(char *name,uint32_t *addr,uint32_t *size)

{
  int iVar1;
  uint32_t uStack36;
  uint32_t addr0;
  uint32_t addr1;
  uint32_t size0;
  uint32_t size1;
  int active;
  
  iVar1 = hal_boot2_partition_addr(name,&uStack36,&addr0,&addr1,&size0,(int *)&size1);
  if (iVar1 == 0) {
    if (size1 != 0) {
      uStack36 = addr0;
    }
    *addr = uStack36;
    if (size1 != 0) {
      addr1 = size0;
    }
    *size = addr1;
  }
  return iVar1;
}



int hal_boot2_partition_addr_inactive(char *name,uint32_t *addr,uint32_t *size)

{
  int iVar1;
  uint32_t uStack36;
  uint32_t addr0;
  uint32_t addr1;
  uint32_t size0;
  uint32_t size1;
  int active;
  
  iVar1 = hal_boot2_partition_addr(name,&uStack36,&addr0,&addr1,&size0,(int *)&size1);
  if (iVar1 == 0) {
    if (size1 != 0) {
      addr0 = uStack36;
    }
    *addr = addr0;
    if (size1 != 0) {
      size0 = addr1;
    }
    *size = size0;
  }
  return iVar1;
}



uint8_t hal_boot2_get_active_partition(void)

{
  return boot2_partition_table.partition_active_idx;
}



int hal_boot2_get_active_entries(int type,HALPartition_Entry_Config *ptEntry_hal)

{
  PtTable_Error_Type PVar1;
  undefined3 extraout_var;
  
  PVar1 = PtTable_Get_Active_Entries
                    (&boot2_partition_table.table,(PtTable_Entry_Type)type,
                     (PtTable_Entry_Config *)ptEntry_hal);
  return -(uint)(CONCAT31(extraout_var,PVar1) != 0);
}



int hal_boot2_dump(void)

{
  _dump_partition();
  return 0;
}



int hal_boot2_init(void)

{
  TickType_t TVar1;
  
  boot2_partition_table.partition_active_idx = ram_heap[7232];
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvhal_boot2 < BLOG_LEVEL_WARN))
  {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [HAL] [BOOT2] Active Partition[%u] consumed %d Bytes\r\n",TVar1,
              &DAT_2307f16c,"hal_boot2.c",0x114,(uint)boot2_partition_table.partition_active_idx,
              0x254);
  }
  _dump_partition();
  bl_flash_config_update();
  return 0;
}



int hal_reboot(void)

{
  GLB_SW_POR_Reset();
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void hal_sys_reset(void)

{
  GLB_SW_System_Reset();
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void hal_poweroff(void)

{
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void hal_sys_capcode_update(uint8_t capin,uint8_t capout)

{
  uint8_t capin_static;
  uint8_t capout_static;
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  
  if ((CONCAT31(in_register_00002029,capin) != 0xff) &&
     (CONCAT31(in_register_0000202d,capout) != 0xff)) {
    (*_DAT_2101081c)();
    return;
  }
                    // WARNING: Could not recover jumptable at 0x230370ea. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_2101081c)((uint)capin_static,(uint)capout_static);
  return;
}



uint8_t hal_sys_capcode_get(void)

{
  uint8_t uVar1;
  
  uVar1 = AON_Get_Xtal_CapCode();
  return uVar1;
}



uint32_t fdt32_to_cpu(fdt32_t x)

{
  return (x >> 0x10 & 0xff) << 8 | x << 0x18 | x >> 0x18 | (x >> 8 & 0xff) << 0x10;
}



uint32_t hal_board_get_factory_addr(void)

{
  return factory_addr;
}



// WARNING: Could not reconcile some variable overlaps

undefined4 hal_board_cfg(void)

{
  char cVar1;
  byte bVar2;
  uint32_t fdt;
  int parentoffset;
  TickType_t TVar3;
  int nodeoffset;
  int iVar4;
  char *format;
  size_t sVar5;
  uint32_t uVar6;
  uint32_t uVar7;
  void *__src;
  uint32_t autoconnect;
  fdt32_t x;
  int iVar8;
  int iVar9;
  char *pcVar10;
  uint8_t chan;
  undefined4 uVar11;
  size_t *psVar12;
  size_t *psVar13;
  byte *pbVar14;
  fdt32_t *pfVar15;
  uint8_t capin;
  uint8_t psk_len;
  fdt32_t *pfVar16;
  int iStack220;
  byte local_c4 [4];
  uint32_t uStack192;
  int iStack188;
  size_t sStack184;
  size_t local_b4;
  size_t local_b0 [4];
  size_t local_a0 [3];
  size_t asStack146 [4];
  undefined4 local_80;
  byte bStack124;
  byte bStack123;
  
  parentoffset = hal_boot2_partition_addr_active("factory",&factory_addr,&uStack192);
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN))
  {
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [MAIN] [BOARD] [FLASH] addr from partition is %08x, ret is %d\r\n"
              ,TVar3,&DAT_2307f16c,"hal_board.c",0x376,factory_addr,parentoffset);
  }
  if (factory_addr == 0) {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
       (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      bl_printk(
                "[%10u][%s: %s:%4d] [MAIN] [BOARD] [FLASH] Dead loop. Reason: NO valid Param Parition found\r\n"
                ,TVar3,&DAT_23072bcc,"hal_board.c",0x378);
    }
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  parentoffset = hal_boot2_partition_bus_addr_active("factory",&factory_addr,&uStack192);
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN))
  {
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [MAIN] [BOARD] [XIP] addr from partition is %08x, ret is %d\r\n",
              TVar3,&DAT_2307f16c,"hal_board.c",0x37e,factory_addr,parentoffset);
  }
  fdt = factory_addr;
  if (factory_addr == 0) {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
       (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      bl_printk(
                "[%10u][%s: %s:%4d] [MAIN] [BOARD] [XIP] Dead loop. Reason: NO valid Param Parition found\r\n"
                ,TVar3,&DAT_23072bcc,"hal_board.c",0x380);
    }
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  iStack188 = 0;
  parentoffset = fdt_subnode_offset((void *)factory_addr,0,"wifi");
  if (((parentoffset < 1) && (_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT)) &&
     (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] wifi NULL.\r\n",TVar3,&DAT_23072bcc,"hal_board.c",0x242);
  }
  nodeoffset = fdt_subnode_offset((void *)fdt,parentoffset,"brd_rf");
  if (0 < nodeoffset) {
    local_a0[0] = 0;
    iVar4 = fdt_stringlist_count((void *)fdt,nodeoffset,"xtal_mode");
    if (iVar4 == 1) {
      format = fdt_stringlist_get((void *)fdt,nodeoffset,"xtal_mode",0,(int *)local_a0);
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] xtal_mode length %d\r\n",TVar3,&DAT_2307f16c,"hal_board.c",
                  0x141,local_a0[0]);
      }
      if ((int)local_a0[0] < 3) {
        memcpy(local_b0,format,local_a0[0]);
        local_b0[0] = local_b0[0] & 0xff00ffff;
        if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
           (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
          if (TrapNetCounter == 0) {
            TVar3 = xTaskGetTickCount();
          }
          else {
            TVar3 = xTaskGetTickCountFromISR();
          }
          bl_printk("[%10u][%s: %s:%4d] xtal_mode is %s\r\n",TVar3,&DAT_2307f16c,"hal_board.c",0x145
                    ,local_b0);
        }
        sVar5 = strlen((char *)local_b0);
        iVar4 = 0;
        while (iVar4 < (int)sVar5) {
          if (*(char *)((int)local_b0 + iVar4) == 'F') {
            local_80 = 0;
            pfVar15 = (fdt32_t *)fdt_getprop((void *)fdt,nodeoffset,"xtal",&local_80);
            if (local_80 == 0x14) {
              if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                 (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
                if (TrapNetCounter == 0) {
                  TVar3 = xTaskGetTickCount();
                }
                else {
                  TVar3 = xTaskGetTickCountFromISR();
                }
                autoconnect = fdt32_to_cpu(*pfVar15);
                uVar6 = fdt32_to_cpu(pfVar15[1]);
                uVar7 = fdt32_to_cpu(pfVar15[2]);
                fdt32_to_cpu(pfVar15[3]);
                fdt32_to_cpu(pfVar15[4]);
                bl_printk("[%10u][%s: %s:%4d] xtal dtb in DEC :%u %u %u %u %u\r\n",TVar3,
                          &DAT_2307f16c,"hal_board.c",0xf9,autoconnect & 0xff,uVar6 & 0xff,
                          uVar7 & 0xff);
              }
              autoconnect = fdt32_to_cpu(*pfVar15);
              capin = (uint8_t)autoconnect;
              autoconnect = fdt32_to_cpu(pfVar15[1]);
              local_80._0_1_ = (byte)autoconnect;
              if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) &&
                 (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO)) {
                if (TrapNetCounter == 0) {
                  TVar3 = xTaskGetTickCount();
                }
                else {
                  TVar3 = xTaskGetTickCountFromISR();
                }
                bl_printk("[%10u][%s: %s:%4d] get xtal from F ready\r\n",TVar3,"DEBUG ",
                          "hal_board.c",0x114);
              }
              goto LAB_23037596;
            }
            if (_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) {
              if (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT) {
                if (TrapNetCounter == 0) {
                  TVar3 = xTaskGetTickCount();
                }
                else {
                  TVar3 = xTaskGetTickCountFromISR();
                }
                bl_printk("[%10u][%s: %s:%4d] xtal dtb NULL.",TVar3,&DAT_23072bcc,"hal_board.c",
                          0x100);
              }
              if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) &&
                 (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO)) {
                if (TrapNetCounter == 0) {
                  TVar3 = xTaskGetTickCount();
                }
                else {
                  TVar3 = xTaskGetTickCountFromISR();
                }
                uVar11 = 0x117;
                format = "[%10u][%s: %s:%4d] get xtal from F failed\r\n";
                goto LAB_23037900;
              }
            }
          }
          else {
            if (*(char *)((int)local_b0 + iVar4) != 'M') {
              if (TrapNetCounter == 0) {
                TVar3 = xTaskGetTickCount();
              }
              else {
                TVar3 = xTaskGetTickCountFromISR();
              }
              bl_printk("[%10u][%s: %s:%4d] ASSERT: %s:%d\r\n",TVar3,&UNK_2307c064,"hal_board.c",
                        0x128,"hal_board.c",0x128);
              do {
                    // WARNING: Do nothing block with infinite loop
              } while( true );
            }
            local_80 = local_80 & 0xffffff00;
            iVar8 = bl_efuse_read_capcode((uint8_t *)&local_80);
            if (iVar8 == 0) {
              capin = (byte)local_80;
              if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) &&
                 (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO)) {
                if (TrapNetCounter == 0) {
                  TVar3 = xTaskGetTickCount();
                }
                else {
                  TVar3 = xTaskGetTickCountFromISR();
                }
                bl_printk("[%10u][%s: %s:%4d] get xtal from M ready\r\n",TVar3,"DEBUG ",
                          "hal_board.c",0x11f);
              }
              goto LAB_23037596;
            }
            if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) &&
               (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO)) {
              if (TrapNetCounter == 0) {
                TVar3 = xTaskGetTickCount();
              }
              else {
                TVar3 = xTaskGetTickCountFromISR();
              }
              uVar11 = 0x122;
              format = "[%10u][%s: %s:%4d] get xtal from M failed\r\n";
LAB_23037900:
              bl_printk(format,TVar3,"DEBUG ","hal_board.c",uVar11);
            }
          }
          iVar4 = iVar4 + 1;
          if (iVar4 == 2) break;
        }
        if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
           (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
          if (TrapNetCounter == 0) {
            TVar3 = xTaskGetTickCount();
          }
          else {
            TVar3 = xTaskGetTickCountFromISR();
          }
          bl_printk("[%10u][%s: %s:%4d] Using Default xtal\r\n",TVar3,&DAT_2307f16c,"hal_board.c",
                    0x12e);
        }
        local_80._0_1_ = '2';
        capin = '2';
LAB_23037596:
        hal_sys_capcode_update(capin,(byte)local_80);
      }
    }
    __src = fdt_getprop((void *)fdt,nodeoffset,"channel_div_table",&iStack188);
    if (iStack188 == 0x3c) {
      iVar4 = 0;
      do {
        autoconnect = fdt32_to_cpu(*(fdt32_t *)((int)__src + iVar4));
        *(uint32_t *)((int)&local_80 + iVar4) = autoconnect;
        iVar4 = iVar4 + 4;
      } while (iVar4 != 0x3c);
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] channel_div_table :\r\n",TVar3,&DAT_2307f16c,"hal_board.c",600
                 );
      }
      log_buf_out("hal_board.c",0x259,&local_80,0x3c,LOG_BUF_OUT_DATA_TYPE_HEX);
    }
    else {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] channel_div_table NULL.\r\n",TVar3,&DAT_23072bcc,"hal_board.c"
                  ,0x25b);
      }
    }
    pfVar15 = (fdt32_t *)fdt_getprop((void *)fdt,nodeoffset,"channel_cnt_table",&iStack188);
    if (iStack188 == 0x38) {
      pfVar16 = pfVar15 + 0xe;
      psVar12 = local_a0;
      do {
        x = *pfVar15;
        pfVar15 = pfVar15 + 1;
        autoconnect = fdt32_to_cpu(x);
        *(short *)psVar12 = (short)autoconnect;
        psVar12 = (size_t *)((int)psVar12 + 2);
      } while (pfVar16 != pfVar15);
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] channel_cnt_table :\r\n",TVar3,&DAT_2307f16c,"hal_board.c",
                  0x263);
      }
      log_buf_out("hal_board.c",0x264,local_a0,0x38,LOG_BUF_OUT_DATA_TYPE_HEX);
    }
    else {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] channel_cnt_table NULL.\r\n",TVar3,&DAT_23072bcc,"hal_board.c"
                  ,0x266);
      }
    }
    pfVar15 = (fdt32_t *)fdt_getprop((void *)fdt,nodeoffset,"lo_fcal_div",&iStack188);
    if (iStack188 == 4) {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        x = *pfVar15;
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        autoconnect = fdt32_to_cpu(x);
        bl_printk("[%10u][%s: %s:%4d] lo_fcal_div : %d\r\n",TVar3,&DAT_2307f16c,"hal_board.c",0x26c,
                  autoconnect & 0xffff);
      }
    }
    else {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] lo_fcal_div NULL.\r\n",TVar3,&DAT_23072bcc,"hal_board.c",0x26e
                 );
      }
    }
  }
  nodeoffset = fdt_subnode_offset((void *)fdt,parentoffset,"mac");
  if (0 < nodeoffset) {
    local_b4 = 0;
    iVar4 = fdt_stringlist_count((void *)fdt,nodeoffset,"mode");
    if (iVar4 == 1) {
      format = fdt_stringlist_get((void *)fdt,nodeoffset,"mode",0,(int *)&local_b4);
      bl_printk("MAC address mode length %d\r\n",local_b4);
      if ((int)local_b4 < 4) {
        memcpy(local_b0,format,local_b4);
        local_b0[0] = local_b0[0] & 0xffffff;
        bl_printk("MAC address mode is %s\r\n",local_b0);
        sVar5 = strlen((char *)local_b0);
        iVar4 = 0;
        do {
          if ((int)sVar5 <= iVar4) break;
          cVar1 = *(char *)((int)local_b0 + iVar4);
          if (cVar1 == 'F') {
            __src = fdt_getprop((void *)fdt,nodeoffset,"sta_mac_addr",(int *)local_a0);
            if (local_a0[0] == 6) {
              memcpy(&local_80,__src,6);
              bl_wifi_sta_mac_addr_set((uint8_t *)&local_80);
              __src = fdt_getprop((void *)fdt,nodeoffset,"ap_mac_addr",(int *)local_a0);
              if (local_a0[0] == 6) {
                memcpy(&local_80,__src,6);
                bl_wifi_ap_mac_addr_set((uint8_t *)&local_80);
                if (BLOG_LEVEL_DEBUG < _fsymc_level_hal_drv) goto LAB_23037b5a;
                if (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO) {
                  if (TrapNetCounter == 0) {
                    TVar3 = xTaskGetTickCount();
                  }
                  else {
                    TVar3 = xTaskGetTickCountFromISR();
                  }
                  uVar11 = 0x9b;
                  format = "[%10u][%s: %s:%4d] get MAC from F ready\r\n";
                  goto LAB_23037b56;
                }
                goto LAB_23037b64;
              }
              if (_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) {
                if (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT) {
                  if (TrapNetCounter == 0) {
                    TVar3 = xTaskGetTickCount();
                  }
                  else {
                    TVar3 = xTaskGetTickCountFromISR();
                  }
                  uVar11 = 0x54;
                  format = "[%10u][%s: %s:%4d] ap_mac_addr NULL.\r\n";
                  goto LAB_23038094;
                }
                goto LAB_23038098;
              }
            }
            else {
              if (_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) {
                if (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT) {
                  if (TrapNetCounter == 0) {
                    TVar3 = xTaskGetTickCount();
                  }
                  else {
                    TVar3 = xTaskGetTickCountFromISR();
                  }
                  uVar11 = 0x47;
                  format = "[%10u][%s: %s:%4d] sta_mac_addr NULL.\r\n";
LAB_23038094:
                  bl_printk(format,TVar3,&DAT_23072bcc,"hal_board.c",uVar11);
                }
LAB_23038098:
                if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) &&
                   (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO)) {
                  if (TrapNetCounter == 0) {
                    TVar3 = xTaskGetTickCount();
                  }
                  else {
                    TVar3 = xTaskGetTickCountFromISR();
                  }
                  uVar11 = 0x9e;
                  format = "[%10u][%s: %s:%4d] get MAC from F failed\r\n";
                  goto LAB_2303786a;
                }
              }
            }
          }
          else {
            if (cVar1 == 'M') {
              iVar8 = bl_efuse_read_mac_factory((uint8_t *)&local_80);
              if (iVar8 == 0) {
                if (((byte)(bStack123 |
                           bStack124 |
                           local_80._3_1_ | local_80._2_1_ | (byte)local_80 | local_80._1_1_) != 0)
                   && (((byte)local_80 & local_80._1_1_ & local_80._2_1_ & local_80._3_1_ &
                        bStack124 & bStack123) != 1)) {
                  if (BLOG_LEVEL_DEBUG < _fsymc_level_hal_drv) goto LAB_23037b5a;
                  if (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO) {
                    if (TrapNetCounter == 0) {
                      TVar3 = xTaskGetTickCount();
                    }
                    else {
                      TVar3 = xTaskGetTickCountFromISR();
                    }
                    uVar11 = 0xa6;
                    format = "[%10u][%s: %s:%4d] get MAC from M ready\r\n";
                    goto LAB_23037b56;
                  }
                  goto LAB_23037b64;
                }
              }
              if ((BLOG_LEVEL_DEBUG < _fsymc_level_hal_drv) ||
                 (BLOG_LEVEL_DEBUG < _fsymf_level_hal_drvhal_board)) goto LAB_2303786e;
              if (TrapNetCounter == 0) {
                TVar3 = xTaskGetTickCount();
              }
              else {
                TVar3 = xTaskGetTickCountFromISR();
              }
              uVar11 = 0xa9;
              format = "[%10u][%s: %s:%4d] get MAC from M failed\r\n";
            }
            else {
              if (cVar1 != 'B') {
                if (TrapNetCounter == 0) {
                  TVar3 = xTaskGetTickCount();
                }
                else {
                  TVar3 = xTaskGetTickCountFromISR();
                }
                bl_printk("[%10u][%s: %s:%4d] ASSERT: %s:%d\r\n",TVar3,&UNK_2307c064,"hal_board.c",
                          0xaf,"hal_board.c",0xaf);
                do {
                    // WARNING: Do nothing block with infinite loop
                } while( true );
              }
              bl_efuse_read_mac((uint8_t *)&local_80);
              if (((byte)(bStack123 |
                         bStack124 |
                         local_80._3_1_ | local_80._2_1_ | (byte)local_80 | local_80._1_1_) != 0) &&
                 (((byte)local_80 & local_80._1_1_ & local_80._2_1_ & local_80._3_1_ & bStack124 &
                  bStack123) != 1)) {
                if (BLOG_LEVEL_DEBUG < _fsymc_level_hal_drv) goto LAB_23037b5a;
                if (BLOG_LEVEL_DEBUG < _fsymf_level_hal_drvhal_board) goto LAB_23037b64;
                if (TrapNetCounter == 0) {
                  TVar3 = xTaskGetTickCount();
                }
                else {
                  TVar3 = xTaskGetTickCountFromISR();
                }
                uVar11 = 0x90;
                format = "[%10u][%s: %s:%4d] get MAC from B ready\r\n";
LAB_23037b56:
                bl_printk(format,TVar3,"DEBUG ","hal_board.c",uVar11);
                goto LAB_23037b5a;
              }
              if ((BLOG_LEVEL_DEBUG < _fsymc_level_hal_drv) ||
                 (BLOG_LEVEL_DEBUG < _fsymf_level_hal_drvhal_board)) goto LAB_2303786e;
              if (TrapNetCounter == 0) {
                TVar3 = xTaskGetTickCount();
              }
              else {
                TVar3 = xTaskGetTickCountFromISR();
              }
              uVar11 = 0x93;
              format = "[%10u][%s: %s:%4d] get MAC from B failed\r\n";
            }
LAB_2303786a:
            bl_printk(format,TVar3,"DEBUG ","hal_board.c",uVar11);
          }
LAB_2303786e:
          iVar4 = iVar4 + 1;
        } while (iVar4 != 3);
        if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
           (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
          if (TrapNetCounter == 0) {
            TVar3 = xTaskGetTickCount();
          }
          else {
            TVar3 = xTaskGetTickCountFromISR();
          }
          bl_printk("[%10u][%s: %s:%4d] Using Default MAC address\r\n",TVar3,&DAT_2307f16c,
                    "hal_board.c",0xb5);
        }
        memcpy(&local_80,&mac_default_3782,6);
LAB_23037b5a:
        if (_fsymc_level_hal_drv < BLOG_LEVEL_WARN) {
LAB_23037b64:
          if (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN) {
            if (TrapNetCounter == 0) {
              TVar3 = xTaskGetTickCount();
            }
            else {
              TVar3 = xTaskGetTickCountFromISR();
            }
            bl_printk("[%10u][%s: %s:%4d] Set MAC addrress %02X:%02X:%02X:%02X:%02X:%02X\r\n",TVar3,
                      &DAT_2307f16c,"hal_board.c",0xc0,local_80 & 0xff,local_80 >> 8 & 0xff,
                      local_80 >> 0x10 & 0xff);
          }
        }
        bl_wifi_ap_mac_addr_set((uint8_t *)&local_80);
        bl_wifi_sta_mac_addr_set((uint8_t *)&local_80);
      }
    }
  }
  nodeoffset = fdt_subnode_offset((void *)fdt,parentoffset,"region");
  if (0 < nodeoffset) {
    pfVar15 = (fdt32_t *)fdt_getprop((void *)fdt,nodeoffset,"country_code",&iStack188);
    if (iStack188 == 4) {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        autoconnect = fdt32_to_cpu(*pfVar15);
        bl_printk("[%10u][%s: %s:%4d] country_code : %d\r\n",TVar3,&DAT_2307f16c,"hal_board.c",0x27f
                  ,autoconnect & 0xff);
      }
      autoconnect = fdt32_to_cpu(*pfVar15);
      bl_wifi_country_code_set((uint8_t)autoconnect);
    }
    else {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] country_code NULL.\r\n",TVar3,&DAT_23072bcc,"hal_board.c",
                  0x283);
      }
    }
  }
  nodeoffset = fdt_subnode_offset((void *)fdt,parentoffset,"brd_rf");
  if (nodeoffset < 1) goto LAB_23038860;
  __src = fdt_getprop((void *)fdt,nodeoffset,"pwr_table_11b",&iStack188);
  if (iStack188 == 0x10) {
    iVar4 = 0;
    do {
      autoconnect = fdt32_to_cpu(*(fdt32_t *)(iVar4 * 4 + (int)__src));
      *(undefined *)((int)&local_80 + iVar4) = (char)autoconnect;
      iVar4 = iVar4 + 1;
    } while (iVar4 != 4);
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
       (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] pwr_table_11b :%u %u %u %u\r\n",TVar3,&DAT_2307f16c,
                "hal_board.c",0x298,local_80 & 0xff,local_80 >> 8 & 0xff,local_80 >> 0x10 & 0xff);
    }
    bl_tpc_update_power_rate_11b((int8_t *)&local_80);
  }
  else {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
       (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] pwr_table_11b NULL. lentmp = %d\r\n",TVar3,&DAT_23072bcc,
                "hal_board.c",0x29b,iStack188);
    }
  }
  __src = fdt_getprop((void *)fdt,nodeoffset,"pwr_table_11g",&iStack188);
  if (iStack188 == 0x20) {
    iVar4 = 0;
    do {
      autoconnect = fdt32_to_cpu(*(fdt32_t *)(iVar4 * 4 + (int)__src));
      *(undefined *)((int)&local_80 + iVar4) = (char)autoconnect;
      iVar4 = iVar4 + 1;
    } while (iVar4 != 8);
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
       (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] pwr_table_11g :%u %u %u %u %u %u %u %u\r\n",TVar3,&DAT_2307f16c,
                "hal_board.c",0x2ac,local_80 & 0xff,local_80 >> 8 & 0xff,local_80 >> 0x10 & 0xff);
    }
    bl_tpc_update_power_rate_11g((int8_t *)&local_80);
  }
  else {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
       (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] pwr_table_11g NULL. lentmp = %d\r\n",TVar3,&DAT_23072bcc,
                "hal_board.c",0x2af,iStack188);
    }
  }
  __src = fdt_getprop((void *)fdt,nodeoffset,"pwr_table_11n",&iStack188);
  if (iStack188 == 0x20) {
    iVar4 = 0;
    do {
      autoconnect = fdt32_to_cpu(*(fdt32_t *)(iVar4 * 4 + (int)__src));
      *(undefined *)((int)&local_80 + iVar4) = (char)autoconnect;
      iVar4 = iVar4 + 1;
    } while (iVar4 != 8);
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
       (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] pwr_table_11n :%u %u %u %u %u %u %u %u\r\n",TVar3,&DAT_2307f16c,
                "hal_board.c",0x2c0,local_80 & 0xff,local_80 >> 8 & 0xff,local_80 >> 0x10 & 0xff);
    }
    bl_tpc_update_power_rate_11n((int8_t *)&local_80);
  }
  else {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
       (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] pwr_table_11n NULL. lentmp = %d\r\n",TVar3,&DAT_23072bcc,
                "hal_board.c",0x2c3,iStack188);
    }
  }
  sStack184 = 0;
  iVar4 = fdt_stringlist_count((void *)fdt,nodeoffset,"pwr_mode");
  if (iVar4 != 1) goto LAB_23038860;
  format = fdt_stringlist_get((void *)fdt,nodeoffset,"pwr_mode",0,(int *)&sStack184);
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN))
  {
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] pwr_mode length %d\r\n",TVar3,&DAT_2307f16c,"hal_board.c",0x1c1,
              sStack184);
  }
  if (2 < (int)sStack184) goto LAB_23038860;
  memcpy(local_c4,format,sStack184);
  local_c4[2] = 0;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN))
  {
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] pwr_mode is %s\r\n",TVar3,&DAT_2307f16c,"hal_board.c",0x1c5,
              local_c4);
  }
  memset(local_b0,0,0xe);
  memset(local_a0,0,0xe);
  sVar5 = strlen((char *)local_c4);
  pbVar14 = local_c4;
  iStack220 = 0;
  iVar8 = 0;
  do {
    if ((int)sVar5 <= iVar8) break;
    bVar2 = *pbVar14;
    if (bVar2 == 0x46) {
LAB_230383fa:
      local_b4 = 0;
      __src = fdt_getprop((void *)fdt,nodeoffset,"pwr_offset",(int *)&local_b4);
      if (local_b4 != 0x38) {
        if (_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) {
          if (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT) {
            if (TrapNetCounter == 0) {
              TVar3 = xTaskGetTickCount();
            }
            else {
              TVar3 = xTaskGetTickCountFromISR();
            }
            bl_printk("[%10u][%s: %s:%4d] pwr_offset NULL. lentmp = %d\r\n",TVar3,&DAT_23072bcc,
                      "hal_board.c",0x15f,local_b4);
          }
          if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) &&
             (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO)) {
            if (TrapNetCounter == 0) {
              TVar3 = xTaskGetTickCount();
            }
            else {
              TVar3 = xTaskGetTickCountFromISR();
            }
            uVar11 = 0x1a0;
            format = "[%10u][%s: %s:%4d] get pwr offset from F(f) failed\r\n";
            goto LAB_23038748;
          }
        }
        goto LAB_230386be;
      }
      nodeoffset = 0;
      do {
        autoconnect = fdt32_to_cpu(*(fdt32_t *)(nodeoffset * 4 + (int)__src));
        *(undefined *)((int)local_a0 + nodeoffset) = (char)autoconnect;
        nodeoffset = nodeoffset + 1;
      } while (nodeoffset != 0xe);
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] pwr_offset from dtb:\r\n",TVar3,&DAT_2307f16c,"hal_board.c",
                  0x156);
      }
      log_buf_out("hal_board.c",0x157,local_a0,0xe,LOG_BUF_OUT_DATA_TYPE_HEX);
      psVar12 = local_a0;
      do {
        psVar13 = (size_t *)((int)psVar12 + 1);
        *(char *)psVar12 = *(char *)psVar12 + -10;
        psVar12 = psVar13;
      } while (asStack146 != psVar13);
      if (_fsymc_level_hal_drv < BLOG_LEVEL_WARN) {
        if (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN) {
          if (TrapNetCounter == 0) {
            TVar3 = xTaskGetTickCount();
          }
          else {
            TVar3 = xTaskGetTickCountFromISR();
          }
          bl_printk("[%10u][%s: %s:%4d] pwr_offset from dtb (rebase on %d):\r\n",TVar3,&DAT_2307f16c
                    ,"hal_board.c",0x15b,10);
        }
        if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) &&
           (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO)) {
          if (TrapNetCounter == 0) {
            TVar3 = xTaskGetTickCount();
          }
          else {
            TVar3 = xTaskGetTickCountFromISR();
          }
          bl_printk("[%10u][%s: %s:%4d] get pwr offset from F(f) ready\r\n",TVar3,"DEBUG ",
                    "hal_board.c",399);
        }
      }
      if (*pbVar14 == 0x42) {
        nodeoffset = 0;
        do {
          *(undefined *)((int)local_b0 + nodeoffset) = *(undefined *)((int)local_a0 + nodeoffset);
          nodeoffset = nodeoffset + 1;
        } while (nodeoffset != 0xe);
        if ((BLOG_LEVEL_DEBUG < _fsymc_level_hal_drv) ||
           (BLOG_LEVEL_DEBUG < _fsymf_level_hal_drvhal_board)) goto LAB_23038844;
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        uVar11 = 0x195;
        pcVar10 = "DEBUG ";
        format = "[%10u][%s: %s:%4d] Use pwr offset from F only\r\n";
        goto LAB_23038656;
      }
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] Use pwr offset from f in incremental mode\r\n",TVar3,"DEBUG ",
                  "hal_board.c",0x199);
      }
      nodeoffset = 0;
      psVar12 = local_b0;
      do {
        format = (char *)((int)local_a0 + nodeoffset);
        nodeoffset = nodeoffset + 1;
        *(char *)psVar12 = *format + *(char *)psVar12;
        psVar12 = (size_t *)((int)psVar12 + 1);
      } while (nodeoffset != 0xe);
      goto LAB_23038844;
    }
    if (bVar2 < 0x47) {
      if (bVar2 != 0x42) {
LAB_23037f9e:
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] ASSERT: %s:%d\r\n",TVar3,&UNK_2307c064,"hal_board.c",0x1a6,
                  "hal_board.c",0x1a6);
        do {
                    // WARNING: Do nothing block with infinite loop
        } while( true );
      }
    }
    else {
      if (bVar2 != 0x62) {
        if (bVar2 != 0x66) goto LAB_23037f9e;
        goto LAB_230383fa;
      }
    }
    iVar9 = bl_efuse_read_pwroft((int8_t *)local_a0);
    if (iVar9 != 0) {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        uVar11 = 0x186;
        format = "[%10u][%s: %s:%4d] get pwr offset from B(b) failed\r\n";
LAB_23038748:
        bl_printk(format,TVar3,"DEBUG ","hal_board.c",uVar11);
      }
      goto LAB_230386be;
    }
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
       (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] get pwr offset from B(b) ready\r\n",TVar3,&DAT_2307f16c,
                "hal_board.c",0x175);
    }
    log_buf_out("hal_board.c",0x176,local_a0,0xe,LOG_BUF_OUT_DATA_TYPE_INT8);
    if (*pbVar14 == 0x42) goto LAB_23038602;
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) &&
       (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO)) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] Use pwr offset from b in incremental mode\r\n",TVar3,"DEBUG ",
                "hal_board.c",0x180);
    }
    psVar12 = local_b0;
    do {
      format = (char *)((int)local_a0 + iVar9);
      iVar9 = iVar9 + 1;
      *(char *)psVar12 = *format + *(char *)psVar12;
      psVar12 = (size_t *)((int)psVar12 + 1);
      iStack220 = iVar4;
    } while (iVar9 != 0xe);
LAB_230386be:
    iVar8 = iVar8 + 1;
    pbVar14 = pbVar14 + 1;
  } while (iVar8 != 2);
  if (((iStack220 == 0) && (_fsymc_level_hal_drv < BLOG_LEVEL_WARN)) &&
     (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    uVar11 = 0x1ac;
    pcVar10 = "\x1b[32mINFO  \x1b[0m";
    format = "[%10u][%s: %s:%4d] Using Default pwr offset\r\n";
    goto LAB_23038656;
  }
LAB_23038844:
  log_buf_out("hal_board.c",0x1ae,local_b0,0xe,LOG_BUF_OUT_DATA_TYPE_INT8);
  phy_powroffset_set((int8_t *)local_b0);
LAB_23038860:
  local_b0[0] = 0;
  nodeoffset = fdt_subnode_offset((void *)fdt,parentoffset,"ap");
  if (0 < nodeoffset) {
    iVar4 = fdt_stringlist_count((void *)fdt,nodeoffset,"ssid");
    if ((iVar4 == 1) &&
       (format = fdt_stringlist_get((void *)fdt,nodeoffset,"ssid",0,(int *)local_b0),
       local_b0[0] - 1 < 0x1f)) {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] ap_ssid string[%d] = %s, ap_ssid_len = %d\r\n",TVar3,
                  &DAT_2307f16c,"hal_board.c",0x213,0,format,local_b0[0]);
      }
      memcpy(local_a0,format,local_b0[0]);
      *(undefined *)((int)local_a0 + local_b0[0]) = 0;
      capin = (uint8_t)local_b0[0];
    }
    else {
      capin = '\0';
    }
    iVar4 = fdt_stringlist_count((void *)fdt,nodeoffset,"pwd");
    if ((iVar4 == 1) &&
       (format = fdt_stringlist_get((void *)fdt,nodeoffset,"pwd",0,(int *)local_b0),
       local_b0[0] - 1 < 0x1f)) {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] ap_psk string[%d] = %s, ap_psk_len = %d\r\n",TVar3,
                  &DAT_2307f16c,"hal_board.c",0x21e,0,format,local_b0[0]);
      }
      memcpy(&local_80,format,local_b0[0]);
      *(undefined *)((int)&local_80 + local_b0[0]) = 0;
      psk_len = (uint8_t)local_b0[0];
    }
    else {
      psk_len = '\0';
    }
    pfVar15 = (fdt32_t *)fdt_getprop((void *)fdt,nodeoffset,"ap_channel",(int *)local_b0);
    if (pfVar15 == (fdt32_t *)0x0) {
      chan = '\0';
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
         (chan = '\0', _fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] ap_channel NULL.\r\n",TVar3,&DAT_23072bcc,"hal_board.c",0x22b)
        ;
        chan = '\0';
      }
    }
    else {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        autoconnect = fdt32_to_cpu(*pfVar15);
        bl_printk("[%10u][%s: %s:%4d] ap_channel = %ld\r\n",TVar3,&DAT_2307f16c,"hal_board.c",0x227,
                  autoconnect);
      }
      autoconnect = fdt32_to_cpu(*pfVar15);
      chan = (uint8_t)autoconnect;
    }
    bl_wifi_ap_info_set((uint8_t *)local_a0,capin,(uint8_t *)&local_80,psk_len,chan);
  }
  local_b0[0] = 0;
  parentoffset = fdt_subnode_offset((void *)fdt,parentoffset,"sta");
  if (0 < parentoffset) {
    nodeoffset = fdt_stringlist_count((void *)fdt,parentoffset,"ssid");
    if ((nodeoffset == 1) &&
       (format = fdt_stringlist_get((void *)fdt,parentoffset,"ssid",0,(int *)local_b0),
       local_b0[0] - 1 < 0x1f)) {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] [STA] ap_ssid string[%d] = %s, ap_ssid_len = %d\r\n",TVar3,
                  &DAT_2307f16c,"hal_board.c",0x1df,0,format,local_b0[0]);
      }
      memcpy(local_a0,format,local_b0[0]);
      *(undefined *)((int)local_a0 + local_b0[0]) = 0;
      capin = (uint8_t)local_b0[0];
    }
    else {
      capin = '\0';
    }
    nodeoffset = fdt_stringlist_count((void *)fdt,parentoffset,"pwd");
    if ((nodeoffset == 1) &&
       (format = fdt_stringlist_get((void *)fdt,parentoffset,"pwd",0,(int *)local_b0),
       local_b0[0] - 1 < 0x1f)) {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] [STA] ap_psk string[%d] = %s, ap_psk_len = %d\r\n",TVar3,
                  &DAT_2307f16c,"hal_board.c",0x1ea,0,format,local_b0[0]);
      }
      memcpy(&local_80,format,local_b0[0]);
      *(undefined *)((int)&local_80 + local_b0[0]) = 0;
      psk_len = (uint8_t)local_b0[0];
    }
    else {
      psk_len = '\0';
    }
    pfVar15 = (fdt32_t *)fdt_getprop((void *)fdt,parentoffset,"auto_connect_enable",(int *)local_b0)
    ;
    autoconnect = 0;
    if (pfVar15 != (fdt32_t *)0x0) {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        autoconnect = fdt32_to_cpu(*pfVar15);
        bl_printk("[%10u][%s: %s:%4d] auto_connect_enable = %ld\r\n",TVar3,&DAT_2307f16c,
                  "hal_board.c",0x1f2,autoconnect);
      }
      autoconnect = fdt32_to_cpu(*pfVar15);
    }
    bl_wifi_sta_info_set((uint8_t *)local_a0,capin,(uint8_t *)&local_80,psk_len,autoconnect);
  }
  parentoffset = fdt_subnode_offset((void *)fdt,0,"bluetooth");
  if (((parentoffset < 1) && (_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT)) &&
     (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] bt NULL.\r\n",TVar3,&DAT_23072bcc,"hal_board.c",0x2cd);
  }
  parentoffset = fdt_subnode_offset((void *)fdt,parentoffset,"brd_rf");
  if (0 < parentoffset) {
    pfVar15 = (fdt32_t *)fdt_getprop((void *)fdt,parentoffset,"pwr_table_ble",&iStack188);
    fdt = 0;
    if (pfVar15 != (fdt32_t *)0x0) {
      fdt = fdt32_to_cpu(*pfVar15);
    }
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
       (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
      if (TrapNetCounter == 0) {
        xTaskGetTickCount();
      }
      else {
        xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] set pwr_table_ble = %ld in dts\r\n",&DAT_2307f16c,"hal_board.c",
                0x2d9,fdt);
    }
  }
  return 0;
LAB_23038602:
  do {
    *(undefined *)((int)local_b0 + iVar9) = *(undefined *)((int)local_a0 + iVar9);
    iVar9 = iVar9 + 1;
  } while (iVar9 != 0xe);
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) && (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO))
  {
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    uVar11 = 0x17c;
    pcVar10 = "DEBUG ";
    format = "[%10u][%s: %s:%4d] Use pwr offset from B only\r\n";
LAB_23038656:
    bl_printk(format,TVar3,pcVar10,"hal_board.c",uVar11);
  }
  goto LAB_23038844;
}



// WARNING: Control flow encountered bad instruction data

void bl_tsen_adc_get(void)

{
                    // WARNING: Bad instruction - Truncating control flow here
  halt_baddata();
}



uint64_t bl_rtc_get_counter(void)

{
  uint64_t in_fa0;
  uint32_t uStack24;
  uint32_t valLow;
  uint32_t valHigh;
  
  HBN_Get_RTC_Timer_Val(&uStack24,&valLow);
  return in_fa0;
}



uint64_t bl_rtc_get_timestamp_ms(void)

{
  uint64_t uVar1;
  
  uVar1 = bl_rtc_get_counter();
  return uVar1;
}



int hal_wifi_start_firmware_task(void)

{
  StackType_t wifi_fw_stack [1536];
  StaticTask_t wifi_fw_task;
  
  xTaskCreateStatic(wifi_main,"fw",0x600,(void *)0x0,0x1e,(StackType_t *)&ram0x42012be8,
                    (StaticTask_t *)&ram0x420143e8);
  return 0;
}



int bl_sys_reset_por(void)

{
  GLB_SW_POR_Reset();
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void bl_sys_reset_system(void)

{
  GLB_SW_System_Reset();
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



int bl_sys_isxipaddr(uint32_t addr)

{
  return (uint)(((addr & 0xff000000) + 0xdd000000 & 0xdf000000) == 0);
}



PtTable_Error_Type
PtTable_Update_Entry
          (SPI_Flash_Cfg_Type *pFlashCfg,PtTable_ID_Type targetTableID,PtTable_Stuff_Config *ptStuff
          ,PtTable_Entry_Config *ptEntry)

{
  uint uVar1;
  PtTable_Error_Type PVar2;
  uint32_t len;
  uint32_t uVar3;
  undefined3 in_register_0000202d;
  PtTable_Entry_Config *__dest;
  PtTable_Entry_Config *dataIn;
  uint32_t addr;
  
  if ((ptEntry == (PtTable_Entry_Config *)0x0) || (ptStuff == (PtTable_Stuff_Config *)0x0)) {
    return PT_ERROR_PARAMETER;
  }
  dataIn = ptStuff->ptEntries;
  PVar2 = PT_ERROR_TABLE_NOT_VALID;
  if (CONCAT31(in_register_0000202d,targetTableID) != 2) {
    addr = 0xe000;
    if (CONCAT31(in_register_0000202d,targetTableID) != 0) {
      addr = 0xf000;
    }
    uVar1 = 0;
    __dest = dataIn;
    while (uVar1 < (ptStuff->ptTable).entryCnt) {
      if (__dest->type == ptEntry->type) {
        memcpy(__dest,ptEntry,0x24);
        break;
      }
      uVar1 = uVar1 + 1;
      __dest = __dest + 1;
    }
    if ((uint)(ptStuff->ptTable).entryCnt == uVar1) {
      if (0xf < uVar1) {
        return PT_ERROR_ENTRY_UPDATE_FAIL;
      }
      memcpy(dataIn + uVar1,ptEntry,0x24);
      (ptStuff->ptTable).entryCnt = (ptStuff->ptTable).entryCnt + 1;
    }
    (ptStuff->ptTable).age = (ptStuff->ptTable).age + 1;
    len = BFLB_Soft_CRC32(ptStuff,0xc);
    uVar1 = (uint)(ptStuff->ptTable).entryCnt;
    (ptStuff->ptTable).crc32 = len;
    len = uVar1 * 0x24;
    uVar3 = BFLB_Soft_CRC32(dataIn,len);
    *(uint32_t *)(dataIn + uVar1) = uVar3;
    uVar1 = bl_flash_erase(addr,len + 0x14);
    if ((uVar1 & 0xff) == 0) {
      uVar1 = bl_flash_write(addr,(uint8_t *)ptStuff,0x254);
      if ((uVar1 & 0xff) == 0) {
        return (PtTable_Error_Type)(uVar1 & 0xff);
      }
    }
    PVar2 = PT_ERROR_FALSH_WRITE;
  }
  return PVar2;
}



PtTable_Error_Type
PtTable_Get_Active_Entries
          (PtTable_Stuff_Config *ptStuff,PtTable_Entry_Type type,PtTable_Entry_Config *ptEntry)

{
  undefined3 in_register_0000202d;
  PtTable_Entry_Config *pPVar1;
  uint uVar2;
  
  if (ptStuff == (PtTable_Stuff_Config *)0x0) {
    return PT_ERROR_PARAMETER;
  }
  if (ptEntry != (PtTable_Entry_Config *)0x0) {
    uVar2 = 0;
    pPVar1 = ptStuff->ptEntries;
    while( true ) {
      if ((ptStuff->ptTable).entryCnt <= uVar2) {
        return PT_ERROR_ENTRY_NOT_FOUND;
      }
      if ((uint)pPVar1->type == CONCAT31(in_register_0000202d,type)) break;
      uVar2 = uVar2 + 1;
      pPVar1 = pPVar1 + 1;
    }
    memcpy(ptEntry,ptStuff->ptEntries + uVar2,0x24);
    return PT_ERROR_SUCCESS;
  }
  return PT_ERROR_PARAMETER;
}



// WARNING: Could not reconcile some variable overlaps

int bl_gpio_enable_output(uint8_t pin,uint8_t pullup,uint8_t pulldown)

{
  undefined3 in_register_0000202d;
  undefined3 in_register_00002031;
  uint8_t uStack24;
  uint8_t uStack23;
  uint8_t uStack22;
  uint8_t uStack21;
  GLB_GPIO_Cfg_Type cfg;
  
  cfg._0_2_ = 0x100;
  uStack23 = '\v';
  uStack22 = '\x01';
  if (CONCAT31(in_register_0000202d,pullup) == 0) {
    uStack21 = '\x02';
  }
  else {
    uStack21 = '\0';
  }
  if (CONCAT31(in_register_00002031,pulldown) != 0) {
    uStack21 = '\x01';
  }
  uStack24 = pin;
  GLB_GPIO_Init((GLB_GPIO_Cfg_Type *)&uStack24);
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

int bl_gpio_enable_input(uint8_t pin,uint8_t pullup,uint8_t pulldown)

{
  undefined3 in_register_0000202d;
  undefined3 in_register_00002031;
  uint8_t uStack24;
  uint8_t uStack23;
  uint8_t uStack22;
  uint8_t uStack21;
  GLB_GPIO_Cfg_Type cfg;
  
  cfg._0_2_ = 0x100;
  uStack23 = '\v';
  uStack22 = '\0';
  if (CONCAT31(in_register_0000202d,pullup) == 0) {
    uStack21 = '\x02';
  }
  else {
    uStack21 = '\0';
  }
  if (CONCAT31(in_register_00002031,pulldown) != 0) {
    uStack21 = '\x01';
  }
  uStack24 = pin;
  GLB_GPIO_Init((GLB_GPIO_Cfg_Type *)&uStack24);
  return 0;
}



int bl_gpio_output_set(uint8_t pin,uint8_t value)

{
  undefined3 in_register_0000202d;
  
  GLB_GPIO_Write(pin,(uint)(CONCAT31(in_register_0000202d,value) != 0));
  return 0;
}



int bl_gpio_input_get(uint8_t pin,uint8_t *value)

{
  uint32_t uVar1;
  
  uVar1 = GLB_GPIO_Read(pin);
  *value = (uint8_t)uVar1;
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int bl_flash_erase(uint32_t addr,int len)

{
  if (boot2_flashCfg.flashCfg.mid != '\0') {
    (*_DAT_21010ab0)(0x4200dc24,addr,len,_DAT_21010ab0);
    return 0;
  }
  return -1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int bl_flash_write(uint32_t addr,uint8_t *src,int len)

{
  if (boot2_flashCfg.flashCfg.mid != '\0') {
    (*_DAT_21010aac)(0x4200dc24,addr,src,len,_DAT_21010aac);
    return 0;
  }
  return -1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int bl_flash_read(uint32_t addr,uint8_t *dst,int len)

{
  if (boot2_flashCfg.flashCfg.mid != '\0') {
    (*_DAT_21010aa8)(0x4200dc24,addr,dst,len,_DAT_21010aa8);
    return 0;
  }
  return -1;
}



undefined4 bl_flash_config_update(void)

{
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_flash < BLOG_LEVEL_WARN))
  {
    if (TrapNetCounter == 0) {
      xTaskGetTickCount();
    }
    else {
      xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] ======= FlashCfg magiccode @%p, code 0x%08lX =======\r\n",
              &DAT_2307f16c,"bl_flash.c",0x60,0x42049c18,boot2_flashCfg.magic);
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_flash < BLOG_LEVEL_WARN)
       ) {
      if (TrapNetCounter == 0) {
        xTaskGetTickCount();
      }
      else {
        xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] mid \t\t0x%X\r\n",&DAT_2307f16c,"bl_flash.c",0x61,
                (uint)boot2_flashCfg.flashCfg.mid);
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvbl_flash < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          xTaskGetTickCount();
        }
        else {
          xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] clkDelay \t0x%X\r\n",&DAT_2307f16c,"bl_flash.c",0x62,
                  (uint)boot2_flashCfg.flashCfg.clkDelay);
        if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
           (_fsymf_level_hal_drvbl_flash < BLOG_LEVEL_WARN)) {
          if (TrapNetCounter == 0) {
            xTaskGetTickCount();
          }
          else {
            xTaskGetTickCountFromISR();
          }
          bl_printk("[%10u][%s: %s:%4d] clkInvert \t0x%X\r\n",&DAT_2307f16c,"bl_flash.c",99,
                    (uint)boot2_flashCfg.flashCfg.clkInvert);
          if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
             (_fsymf_level_hal_drvbl_flash < BLOG_LEVEL_WARN)) {
            if (TrapNetCounter == 0) {
              xTaskGetTickCount();
            }
            else {
              xTaskGetTickCountFromISR();
            }
            bl_printk("[%10u][%s: %s:%4d] sector size\t%uKBytes\r\n",&DAT_2307f16c,"bl_flash.c",100,
                      (uint)boot2_flashCfg.flashCfg.sectorSize);
            if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
               (_fsymf_level_hal_drvbl_flash < BLOG_LEVEL_WARN)) {
              if (TrapNetCounter == 0) {
                xTaskGetTickCount();
              }
              else {
                xTaskGetTickCountFromISR();
              }
              bl_printk("[%10u][%s: %s:%4d] page size\t%uBytes\r\n",&DAT_2307f16c,"bl_flash.c",0x65,
                        (uint)boot2_flashCfg.flashCfg.pageSize);
              if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                 (_fsymf_level_hal_drvbl_flash < BLOG_LEVEL_WARN)) {
                if (TrapNetCounter == 0) {
                  xTaskGetTickCount();
                }
                else {
                  xTaskGetTickCountFromISR();
                }
                bl_printk(
                          "[%10u][%s: %s:%4d] ---------------------------------------------------------------\r\n"
                          ,&DAT_2307f16c,"bl_flash.c",0x66);
              }
            }
          }
        }
      }
    }
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void bl_wdt_feed(void)

{
  _DAT_4000a598 = _DAT_4000a598 | 1;
  _DAT_4000a59c = _DAT_4000a59c & 0xffff0000 | 0xbaba;
  _DAT_4000a5a0 = _DAT_4000a5a0 & 0xffff0000 | 0xeb10;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void bl_wdt_disable(void)

{
  _DAT_4000a564 = _DAT_4000a564 & 0xfffffffe;
  _DAT_4000a59c = _DAT_4000a59c & 0xffff0000 | 0xbaba;
  _DAT_4000a5a0 = _DAT_4000a5a0 & 0xffff0000 | 0xeb10;
  return;
}



int bl_wdt_init(int ms)

{
  if (ms < 0xfff) {
    WDT_Disable();
    WDT_Set_Clock(TIMER_CLKSRC_32K,'\x01');
    WDT_SetCompValue((uint16_t)((uint)(ms << 0x14) >> 0x10));
    WDT_ResetCounterValue();
    WDT_IntMask(WDT_INT,MASK);
    WDT_Enable();
    return 0;
  }
  return -1;
}



err_t httpc_tcp_sent(void *arg,altcp_pcb *pcb,u16_t len)

{
  return '\0';
}



err_t httpc_get_internal_addr(httpc_state_t *req,ip_addr_t *ipaddr)

{
  err_t eVar1;
  
  if (&req->remote_addr != ipaddr) {
    (req->remote_addr).addr = ipaddr->addr;
  }
  eVar1 = altcp_connect(req->pcb,&req->remote_addr,req->remote_port,httpc_tcp_connected);
  return eVar1;
}



err_t httpc_free_state(httpc_state_t *req)

{
  altcp_pcb *conn;
  err_t eVar1;
  undefined3 extraout_var;
  
  if (req->request != (pbuf *)0x0) {
    pbuf_free(req->request);
    req->request = (pbuf *)0x0;
  }
  if (req->rx_hdrs != (pbuf *)0x0) {
    pbuf_free(req->rx_hdrs);
    req->rx_hdrs = (pbuf *)0x0;
  }
  conn = req->pcb;
  mem_free(req);
  if (conn != (altcp_pcb *)0x0) {
    altcp_arg(conn,(void *)0x0);
    altcp_recv(conn,(altcp_recv_fn *)0x0);
    altcp_err(conn,(altcp_err_fn *)0x0);
    altcp_poll(conn,(altcp_poll_fn *)0x0,'\0');
    altcp_sent(conn,(altcp_sent_fn *)0x0);
    eVar1 = altcp_close(conn);
    if (CONCAT31(extraout_var,eVar1) != 0) {
      altcp_abort(conn);
      return -0xd;
    }
  }
  return '\0';
}



err_t httpc_close(httpc_state_t *req,httpc_result_t result,u32_t server_response,err_t err)

{
  err_t eVar1;
  httpc_result_fn *phVar2;
  
  if (req != (httpc_state_t *)0x0) {
    if ((req->conn_settings != (httpc_connection_t_conflict *)0x0) &&
       (phVar2 = req->conn_settings->result_fn, phVar2 != (httpc_result_fn *)0x0)) {
      (*phVar2)(req->callback_arg,result,req->rx_content_len,server_response,err);
    }
    eVar1 = httpc_free_state(req);
    return eVar1;
  }
  return '\0';
}



err_t httpc_tcp_recv(void *arg,altcp_pcb *pcb,pbuf *p,err_t r)

{
  ushort uVar1;
  uint uVar2;
  err_t err;
  u8_t uVar3;
  byte bVar4;
  u16_t len;
  u16_t start_offset;
  undefined2 extraout_var_01;
  undefined2 extraout_var_02;
  undefined2 extraout_var_03;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined2 extraout_var_04;
  undefined2 extraout_var_05;
  undefined2 extraout_var_06;
  undefined2 extraout_var_07;
  undefined2 extraout_var_08;
  undefined2 extraout_var_09;
  httpc_result_t result;
  u16_t start_offset_00;
  undefined3 in_register_00002035;
  code *pcVar5;
  int iVar6;
  pbuf *p_00;
  char acStack64 [4];
  char status_num [10];
  
  *(undefined4 *)((int)arg + 0xc) = 0x1e;
  if (p == (pbuf *)0x0) {
    result = HTTPC_RESULT_ERR_CLOSED;
    if (*(char *)((int)arg + 0x30) == '\x02') {
      result = HTTPC_RESULT_OK;
      if ((*(int *)((int)arg + 0x2c) != -1) &&
         (*(int *)((int)arg + 0x2c) != *(int *)((int)arg + 0x28))) {
        result = HTTPC_RESULT_ERR_CONTENT_LEN;
      }
    }
    uVar1 = *(ushort *)((int)arg + 0x1a);
    err = '\0';
    goto LAB_2303957c;
  }
  if (*(char *)((int)arg + 0x30) == '\x02') goto LAB_230395a8;
  if (*(pbuf **)((int)arg + 0x14) == (pbuf *)0x0) {
    *(pbuf **)((int)arg + 0x14) = p;
  }
  else {
    pbuf_cat(*(pbuf **)((int)arg + 0x14),p);
  }
  if (*(char *)((int)arg + 0x30) == '\0') {
    p_00 = *(pbuf **)((int)arg + 0x14);
    len = pbuf_memfind(p_00,"\r\n",2,0);
    if (CONCAT22(extraout_var_01,len) == 0xffff) goto LAB_23039782;
    start_offset = pbuf_memfind(p_00," ",1,0);
    iVar6 = CONCAT22(extraout_var_02,start_offset);
    if (((iVar6 == 0xffff) ||
        (start_offset = pbuf_memcmp(p_00,0,&DAT_23085d2c,5),
        CONCAT22(extraout_var_03,start_offset) != 0)) ||
       (uVar3 = pbuf_get_at(p_00,6), CONCAT31(extraout_var,uVar3) != 0x2e)) goto LAB_23039782;
    bVar4 = pbuf_get_at(p_00,5);
    uVar3 = pbuf_get_at(p_00,7);
    *(ushort *)((int)arg + 0x18) =
         (short)CONCAT31(extraout_var_00,uVar3) - 0x30U |
         (ushort)(((uint)bVar4 - 0x30 & 0xffff) << 8);
    start_offset_00 = (u16_t)((uint)((iVar6 + 1) * 0x10000) >> 0x10);
    start_offset = pbuf_memfind(p_00," ",1,start_offset_00);
    if (CONCAT22(extraout_var_04,start_offset) == 0xffff) {
      iVar6 = CONCAT22(extraout_var_01,len) - iVar6;
    }
    else {
      iVar6 = CONCAT22(extraout_var_04,start_offset) - iVar6;
    }
    memset(acStack64,0,10);
    len = pbuf_copy_partial(p_00,acStack64,(u16_t)((uint)((iVar6 + -1) * 0x10000) >> 0x10),
                            start_offset_00);
    if ((iVar6 + -1 != CONCAT22(extraout_var_05,len)) ||
       (iVar6 = atoi(acStack64), 0xfffe < iVar6 - 1U)) goto LAB_23039782;
    *(undefined2 *)((int)arg + 0x1a) = (short)iVar6;
    *(undefined *)((int)arg + 0x30) = 1;
LAB_230396b8:
    p_00 = *(pbuf **)((int)arg + 0x14);
    len = pbuf_memfind(p_00,&DAT_2307b07c,4,0);
    if (CONCAT22(extraout_var_06,len) < 0xfffd) {
      *(undefined4 *)((int)arg + 0x2c) = 0xffffffff;
      start_offset = pbuf_memfind(p_00,"Content-Length: ",0x10,0);
      iVar6 = CONCAT22(extraout_var_07,start_offset);
      if (iVar6 != 0xffff) {
        start_offset = pbuf_memfind(p_00,"\r\n",2,start_offset);
        if (CONCAT22(extraout_var_08,start_offset) != 0xffff) {
          memset(acStack64,0,0x10);
          uVar2 = (CONCAT22(extraout_var_08,start_offset) - iVar6) - 0x10;
          start_offset = pbuf_copy_partial(p_00,acStack64,(u16_t)(uVar2 * 0x10000 >> 0x10),
                                           (u16_t)((uint)((iVar6 + 0x10) * 0x10000) >> 0x10));
          if (((uVar2 & 0xffff) == CONCAT22(extraout_var_09,start_offset)) &&
             (iVar6 = atoi(acStack64), -1 < iVar6)) {
            *(int *)((int)arg + 0x2c) = iVar6;
          }
        }
      }
      uVar2 = CONCAT22(extraout_var_06,len) + 4;
      len = (u16_t)(uVar2 * 0x10000 >> 0x10);
      altcp_recved(pcb,len);
      if ((*(int *)((int)arg + 0x20) != 0) &&
         (pcVar5 = *(code **)(*(int *)((int)arg + 0x20) + 0x18), pcVar5 != (code *)0x0)) {
        iVar6 = (*pcVar5)(arg,*(undefined4 *)((int)arg + 0x24),*(undefined4 *)((int)arg + 0x14),
                          uVar2 & 0xffff,*(undefined4 *)((int)arg + 0x2c));
        err = (err_t)iVar6;
        if (iVar6 != 0) {
          uVar1 = *(ushort *)((int)arg + 0x1a);
          result = HTTPC_RESULT_LOCAL_ABORT;
LAB_2303957c:
          err = httpc_close((httpc_state_t *)arg,result,(uint)uVar1,err);
          return err;
        }
      }
      p = pbuf_free_header(*(pbuf **)((int)arg + 0x14),len);
      *(undefined4 *)((int)arg + 0x14) = 0;
      *(undefined *)((int)arg + 0x30) = 2;
      if (p == (pbuf *)0x0) {
        return '\0';
      }
      goto LAB_230395a8;
    }
  }
  else {
LAB_23039782:
    if (*(char *)((int)arg + 0x30) == '\x01') goto LAB_230396b8;
  }
  if (*(char *)((int)arg + 0x30) != '\x02') {
    return '\0';
  }
LAB_230395a8:
  *(int *)((int)arg + 0x28) = *(int *)((int)arg + 0x28) + (uint)p->tot_len;
  if (*(code **)((int)arg + 0x1c) == (code *)0x0) {
    altcp_recved(pcb,p->tot_len);
    pbuf_free(p);
    return '\0';
  }
  err = (**(code **)((int)arg + 0x1c))
                  (*(undefined4 *)((int)arg + 0x24),pcb,p,CONCAT31(in_register_00002035,r));
  return err;
}



void httpc_dns_found(char *hostname,ip_addr_t *ipaddr,void *arg)

{
  err_t err;
  undefined3 extraout_var;
  httpc_result_t result;
  
  if (ipaddr == (ip_addr_t *)0x0) {
    result = HTTPC_RESULT_ERR_HOSTNAME;
    err = -0x10;
  }
  else {
    err = httpc_get_internal_addr((httpc_state_t *)arg,ipaddr);
    result = HTTPC_RESULT_ERR_CONNECT;
    if (CONCAT31(extraout_var,err) == 0) {
      return;
    }
  }
  httpc_close((httpc_state_t *)arg,result,0,err);
  return;
}



err_t httpc_tcp_poll(void *arg,altcp_pcb *pcb)

{
  err_t eVar1;
  int iVar2;
  
  if ((arg != (void *)0x0) &&
     ((*(int *)((int)arg + 0xc) == 0 ||
      (iVar2 = *(int *)((int)arg + 0xc) + -1, *(int *)((int)arg + 0xc) = iVar2, iVar2 == 0)))) {
    eVar1 = httpc_close((httpc_state_t *)arg,HTTPC_RESULT_ERR_TIMEOUT,0,'\0');
    return eVar1;
  }
  return '\0';
}



void httpc_tcp_err(void *arg,err_t err)

{
  if (arg != (void *)0x0) {
    *(undefined4 *)arg = 0;
    httpc_close((httpc_state_t *)arg,HTTPC_RESULT_ERR_CLOSED,0,err);
    return;
  }
  return;
}



err_t httpc_tcp_connected(void *arg,altcp_pcb *pcb,err_t err)

{
  err_t err_00;
  undefined3 extraout_var;
  
  err_00 = altcp_write(*(altcp_pcb **)arg,*(void **)(*(int *)((int)arg + 0x10) + 4),
                       (u16_t)(((uint)*(ushort *)(*(int *)((int)arg + 0x10) + 10) - 1) * 0x10000 >>
                              0x10),'\x01');
  if (CONCAT31(extraout_var,err_00) != 0) {
    err_00 = httpc_close((httpc_state_t *)arg,HTTPC_RESULT_ERR_MEM,0,err_00);
    return err_00;
  }
  pbuf_free(*(pbuf **)((int)arg + 0x10));
  *(undefined4 *)((int)arg + 0x10) = 0;
  altcp_output(*(altcp_pcb **)arg);
  return '\0';
}



int httpc_create_request_string
              (httpc_connection_t_conflict *settings,char *server_name,int server_port,char *uri,
              char *buffer,size_t buffer_size)

{
  int iVar1;
  size_t sVar2;
  char *pcVar3;
  
  if (settings->use_proxy == '\0') {
    if (settings->req_type == '\x01') {
      pcVar3 = (char *)0x0;
      if (settings->content_type < 4) {
        pcVar3 = g_cont_type[settings->content_type];
      }
      sVar2 = strlen((char *)settings->data);
      iVar1 = snprintf(buffer,buffer_size,
                                              
                       "POST %s HTTP/1.1\r\nContent-Type: %s\r\nContent-Length: %d\r\nUser-Agent: %s\r\nHost: %s\r\nAccept: */*\r\nConnection: Close\r\n\r\n%s"
                       ,uri,pcVar3,sVar2,&UNK_23085ba4,server_name);
      return iVar1;
    }
    iVar1 = snprintf(buffer,buffer_size,
                                          
                     "GET %s HTTP/1.1\r\nUser-Agent: %s\r\nAccept: */*\r\nHost: %s\r\nConnection: Close\r\n\r\n"
                     ,&UNK_23085ba4,server_name);
    return iVar1;
  }
  if (server_port != 0x50) {
    iVar1 = snprintf(buffer,buffer_size,
                                          
                     "GET http://%s:%d%s HTTP/1.1\r\nUser-Agent: %s\r\nAccept: */*\r\nHost: %s\r\nConnection: Close\r\n\r\n"
                     ,server_name,server_port,uri,&UNK_23085ba4);
    return iVar1;
  }
  iVar1 = snprintf(buffer,buffer_size,
                                      
                   "GET http://%s%s HTTP/1.1\r\nUser-Agent: %s\r\nAccept: */*\r\nHost: %s\r\nConnection: Close\r\n\r\n"
                   ,server_name,uri,&UNK_23085ba4,server_name);
  return iVar1;
}



err_t httpc_init_connection_common
                (httpc_state_t **connection,httpc_connection_t_conflict *settings,char *server_name,
                u16_t server_port,char *uri,altcp_recv_fn *recv_fn,void *callback_arg)

{
  uint uVar1;
  httpc_state_t *req;
  pbuf *ppVar2;
  altcp_pcb *conn;
  uint uVar3;
  undefined2 in_register_00002036;
  int server_port_00;
  err_t eVar4;
  
  server_port_00 = CONCAT22(in_register_00002036,server_port);
  uVar1 = httpc_create_request_string(settings,server_name,server_port_00,uri,(char *)0x0,0);
  if (uVar1 < 0xffff) {
    req = (httpc_state_t *)mem_malloc(0x34);
    if (req == (httpc_state_t *)0x0) {
      return -1;
    }
    memset(req,0,0x34);
    req->timeout_ticks = 0x1e;
    ppVar2 = pbuf_alloc(PBUF_RAW,(u16_t)((uVar1 + 1) * 0x10000 >> 0x10),PBUF_RAM);
    req->request = ppVar2;
    if ((ppVar2 != (pbuf *)0x0) && (ppVar2->next == (pbuf *)0x0)) {
      req->hdr_content_len = 0xffffffff;
      conn = altcp_new(settings->altcp_allocator);
      req->pcb = conn;
      if (conn != (altcp_pcb *)0x0) {
        if (settings->use_proxy != '\0') {
          server_port = settings->proxy_port;
        }
        req->remote_port = server_port;
        altcp_arg(conn,req);
        altcp_recv(req->pcb,httpc_tcp_recv);
        altcp_err(req->pcb,httpc_tcp_err);
        altcp_poll(req->pcb,httpc_tcp_poll,'\x01');
        altcp_sent(req->pcb,httpc_tcp_sent);
        uVar3 = httpc_create_request_string
                          (settings,server_name,server_port_00,uri,(char *)req->request->payload,
                           uVar1 + 1);
        if (uVar1 == uVar3) {
          req->recv_fn = recv_fn;
          req->conn_settings = settings;
          req->callback_arg = callback_arg;
          *connection = req;
          return '\0';
        }
        httpc_free_state(req);
        goto LAB_23039a74;
      }
    }
    httpc_free_state(req);
    eVar4 = -1;
  }
  else {
LAB_23039a74:
    eVar4 = -6;
  }
  return eVar4;
}



err_t httpc_get_file_dns(char *server_name,u16_t port,char *uri,
                        httpc_connection_t_conflict *settings,altcp_recv_fn *recv_fn,
                        void *callback_arg,httpc_state_t **connection)

{
  httpc_state_t *req_00;
  err_t eVar1;
  err_t eVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  httpc_state_t *phStack36;
  httpc_state_t *req;
  
  if (server_name == (char *)0x0) {
    return -0x10;
  }
  if (uri == (char *)0x0) {
    return -0x10;
  }
  if (recv_fn == (altcp_recv_fn *)0x0) {
    return -0x10;
  }
  eVar1 = httpc_init_connection_common
                    (&phStack36,settings,server_name,port,uri,recv_fn,callback_arg);
  req_00 = phStack36;
  if (CONCAT31(extraout_var,eVar1) != 0) {
    return eVar1;
  }
  if (settings->use_proxy == '\0') {
    settings = (httpc_connection_t_conflict *)&phStack36->remote_addr;
    eVar2 = dns_gethostbyname(server_name,(ip_addr_t *)settings,httpc_dns_found,phStack36);
    if (CONCAT31(extraout_var_01,eVar2) != 0) {
      if (CONCAT31(extraout_var_01,eVar2) == -5) goto LAB_23039b0a;
      goto LAB_23039ad0;
    }
  }
  eVar2 = httpc_get_internal_addr(req_00,(ip_addr_t *)settings);
  if (CONCAT31(extraout_var_00,eVar2) == 0) {
LAB_23039b0a:
    if (connection == (httpc_state_t **)0x0) {
      return eVar1;
    }
    *connection = phStack36;
    return eVar1;
  }
LAB_23039ad0:
  httpc_free_state(phStack36);
  return eVar2;
}



void proc_entry_looprt(void *pvParameters)

{
  bloop_run(&looprt);
  do {
    puts("--->>> Error terminated looprt\r\n");
    vTaskDelay(1000);
  } while( true );
}



void looprt_evt_notify_async(uint task,uint32_t evt_map)

{
  bloop_evt_set_async(&looprt,task,evt_map);
  return;
}



void looprt_evt_status_dump(void)

{
  bloop_status_dump(&looprt);
  return;
}



void looprt_evt_schedule(int task,uint32_t evt_map,int delay_ms)

{
  loop_timer *timer;
  
  timer = (loop_timer *)pvPortMalloc(0x24);
  if (timer != (loop_timer *)0x0) {
    bloop_timer_init(timer,1);
    bloop_timer_configure
              (timer,delay_ms,(anon_subr_void_loop_ctx_ptr_loop_timer_ptr_void_ptr *)0x0,(void *)0x0
               ,task,evt_map);
    bloop_timer_register(&looprt,timer);
    return;
  }
  return;
}



int looprt_start(StackType_t *proc_stack_looprt,int stack_count,StaticTask_t *proc_task_looprt)

{
  bloop_init(&looprt);
  bloop_handler_register(&looprt,&bloop_handler_sys,0x1f);
  looprt_evt_status_dump();
  xTaskCreateStatic(proc_entry_looprt,"bloop_rt",stack_count,(void *)0x0,0x1a,proc_stack_looprt,
                    proc_task_looprt);
  bloop_wait_startup(&looprt);
  return 0;
}



int looprt_start_auto(void)

{
  bloop_init(&looprt);
  bloop_handler_register(&looprt,&bloop_handler_sys,0x1f);
  looprt_evt_status_dump();
  xTaskCreate(proc_entry_looprt,"bloop_rt",0x1000,(void *)0x0,0x1a,(TaskHandle_t *)0x0);
  bloop_wait_startup(&looprt);
  return 0;
}



int looprt_handler_register(loop_evt_handler *handler,int priority)

{
  int iVar1;
  
  if (looprt.looper != (TaskHandle_t)0x0) {
    iVar1 = bloop_handler_register(&looprt,handler,priority);
    return iVar1;
  }
  return -1;
}



int looprt_timer_register(loop_timer *timer)

{
  bloop_timer_register(&looprt,timer);
  return 0;
}



void cmd_looprt_test(char *buf,int len,int argc,char **argv)

{
  puts("====== looprt test ======\r\n");
  printf("struct loop_ctx size is %d\r\n",0x4a0);
  printf("MSG size is %d\r\n",0x18);
  looprt_start_auto();
  return;
}



void cmd_looprt_test_status(char *buf,int len,int argc,char **argv)

{
  puts("====== looprt test status ======\r\n");
  looprt_evt_status_dump();
  return;
}



void cmd_looprt_test_evt(char *buf,int len,int argc,char **argv)

{
  puts("====== looprt EVT ======\r\n");
  looprt_evt_notify_async(0x1f,0);
  return;
}



void cmd_looprt_test_evt_dump(char *buf,int len,int argc,char **argv)

{
  puts("====== looprt EVT status ======\r\n");
  looprt_evt_notify_async(0x1f,1);
  return;
}



void cmd_looprt_test_schedule_evt1(char *buf,int len,int argc,char **argv)

{
  puts("====== looprt Schedule EVT1 ======\r\n");
  looprt_evt_schedule(0x1f,1,20000);
  return;
}



void cmd_looprt_test_schedule_evt2(char *buf,int len,int argc,char **argv)

{
  puts("====== looprt Schedule EVT2 ======\r\n");
  looprt_evt_schedule(0x1f,1,10000);
  return;
}



int looprt_test_cli_init(void)

{
  return 0;
}



void _cb_led_trigger(loop_ctx *loop,loop_timer *timer,void *arg)

{
  TickType_t TVar1;
  undefined *puVar2;
  
  bl_gpio_output_set(*(uint8_t *)((int)arg + 0x30),*(int *)((int)arg + 0x38) != 0);
  if ((_fsymc_level_loopset < BLOG_LEVEL_INFO) &&
     (_fsymf_level_loopsetloopset_led < BLOG_LEVEL_INFO)) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    if (*(int *)((int)arg + 0x38) == 0) {
      puVar2 = &DAT_23084b74;
    }
    else {
      puVar2 = &DAT_23084b70;
    }
    bl_printk("[%10u][%s: %s:%4d] [LED] [CB] Set pin %d to %s\r\n",TVar1,"DEBUG ","loopset_led.c",
              0x95,*(undefined4 *)((int)arg + 0x30),puVar2);
  }
  *(uint *)((int)arg + 0x38) = (uint)(*(int *)((int)arg + 0x38) == 0);
  return;
}



int _led_bloop_msg(loop_ctx *loop,loop_evt_handler *handler,loop_msg *msg)

{
  TickType_t TVar1;
  
  if ((_fsymc_level_loopset < BLOG_LEVEL_INFO) &&
     (_fsymf_level_loopsetloopset_led < BLOG_LEVEL_INFO)) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk(
              "[%10u][%s: %s:%4d] [LED] [MSG] called with msg info\r\n    priority %u\r\n    dst %u\r\n    msgid %u\r\n    src %u\r\n    arg1 %p\r\n    arg2 %p\r\n"
              ,TVar1,"DEBUG ","loopset_led.c",0x78,(uint)*(byte *)&msg->u,
              (uint)*(byte *)((int)&msg->u + 1),(uint)*(byte *)((int)&msg->u + 2));
    return 0;
  }
  return 0;
}



int _led_bloop_evt(loop_ctx *loop,loop_evt_handler *handler,uint32_t *bitmap_evt,
                  uint32_t *evt_type_map)

{
  char **ppcVar1;
  uint uVar2;
  TickType_t TVar3;
  char *pcVar4;
  undefined *puVar5;
  char *pcVar6;
  char **ppcVar7;
  char **ppcVar8;
  
  uVar2 = *evt_type_map;
  do {
    if ((uVar2 & 1) == 0) {
      if ((uVar2 & 2) == 0) {
        if (uVar2 != 0) {
          printf("[ASSERT] [ERR] %s:%d\r\n","loopset_led.c",0x5e);
          do {
                    // WARNING: Do nothing block with infinite loop
          } while( true );
        }
        break;
      }
      pcVar6 = handler[1].name;
      ppcVar7 = (char **)0x0;
      ppcVar1 = *(char ***)(pcVar6 + 0xc);
      if (ppcVar1 != (char **)0x0) {
        ppcVar7 = (char **)ppcVar1[1];
      }
      while (ppcVar8 = ppcVar7, ppcVar1 != (char **)(pcVar6 + 8)) {
        if ((_fsymc_level_loopset < BLOG_LEVEL_WARN) &&
           (_fsymf_level_loopsetloopset_led < BLOG_LEVEL_WARN)) {
          if (TrapNetCounter == 0) {
            TVar3 = xTaskGetTickCount();
          }
          else {
            TVar3 = xTaskGetTickCountFromISR(loop);
          }
          puVar5 = &DAT_23084b70;
          if (ppcVar1[0xd] == (char *)0x0) {
            puVar5 = &DAT_23084b74;
          }
          pcVar4 = "Hearbeat";
          if (ppcVar1[0xb] == (char *)0x0) {
            pcVar4 = "Blink";
          }
          bl_printk("[%10u][%s: %s:%4d] [LED] New Trigger: PIN %d, active level %s, type %s\r\n",
                    TVar3,&DAT_2307f16c,"loopset_led.c",0x4b,ppcVar1[0xc],puVar5,pcVar4);
        }
        loop = (loop_ctx *)looprt_timer_register((loop_timer *)(ppcVar1 + 2));
        ppcVar7 = (char **)ppcVar1[1];
        pcVar4 = *ppcVar1;
        *(char ***)(pcVar4 + 4) = ppcVar7;
        *ppcVar7 = pcVar4;
        ppcVar7 = *(char ***)(pcVar6 + 4);
        *ppcVar1 = pcVar6;
        *(char ***)(ppcVar1 + 1) = ppcVar7;
        *(char ***)(pcVar6 + 4) = ppcVar1;
        *(char ***)ppcVar7 = ppcVar1;
        ppcVar1 = ppcVar8;
        ppcVar7 = (char **)0x0;
        if (ppcVar8 != (char **)0x0) {
          ppcVar7 = (char **)ppcVar8[1];
        }
      }
      uVar2 = uVar2 & 0xfffffffd;
    }
    else {
      uVar2 = uVar2 & 0xfffffffe;
    }
  } while (uVar2 != 0);
  *evt_type_map = 0;
  return 0;
}



int loopset_led_hook_on_looprt(void)

{
  loop_evt_handler_holder _led_bloop_handler_holder;
  int iVar1;
  
  led_ctx.trigger_queue.next = &led_ctx;
  led_ctx.trigger_queue.prev = &led_ctx;
  led_ctx.waiting_queue.next = (utils_dlist_s *)&led_ctx.waiting_queue;
  led_ctx.waiting_queue.prev = (utils_dlist_s *)&led_ctx.waiting_queue;
  iVar1 = looprt_handler_register((loop_evt_handler *)(loop_evt_handler_holder *)&ram0x23086060,1);
  return iVar1;
}



void loopset_led_trigger(int pin,uint timeon_ms)

{
  utils_dlist_s **ppuVar1;
  loop_timer *timer;
  utils_dlist_s *__s;
  TickType_t TVar2;
  
  __s = (utils_dlist_s *)pvPortMalloc(0x3c);
  if (__s == (utils_dlist_s *)0x0) {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] ASSERT: %s:%d\r\n",TVar2,&UNK_2307c064,"loopset_led.c",0x9e,
              "loopset_led.c",0x9e);
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  memset(__s,0,0x3c);
  timer = (loop_timer *)(__s + 1);
  *(int *)&__s[6].prev = pin;
  bloop_timer_init(timer,0);
  bloop_timer_repeat_enable(timer);
  bloop_timer_configure(timer,timeon_ms,_cb_led_trigger,__s,1,1);
  bl_gpio_enable_output((uint8_t)pin,'\0','\0');
  vTaskEnterCritical();
  __s->prev = (utils_dlist_s *)0x420148f0;
  __s->next = led_ctx.waiting_queue.next;
  ppuVar1 = &(led_ctx.waiting_queue.next)->prev;
  led_ctx.waiting_queue.next = __s;
  *ppuVar1 = __s;
  vTaskExitCritical();
  looprt_evt_notify_async(1,2);
  return;
}



err_t sys_mbox_new(sys_mbox_t *mbox,int size)

{
  QueueHandle_t pQVar1;
  u16_t uVar2;
  
  pQVar1 = xQueueGenericCreate(0x32,4,'\0');
  *(QueueHandle_t *)mbox = pQVar1;
  uVar2 = (u16_t)(((uint)lwip_stats.sys.mbox.used + 1) * 0x10000 >> 0x10);
  if ((uint)lwip_stats.sys.mbox.max < ((uint)lwip_stats.sys.mbox.used + 1 & 0xffff)) {
    lwip_stats.sys.mbox.max = uVar2;
  }
  lwip_stats.sys.mbox.used = uVar2;
  return (err_t)-(*mbox == (sys_mbox_t)0x0);
}



void sys_mbox_free(sys_mbox_t *mbox)

{
  UBaseType_t UVar1;
  
  UVar1 = uxQueueMessagesWaiting((QueueHandle_t)*mbox);
  if (UVar1 != 0) {
    lwip_stats.sys.mbox.err = lwip_stats.sys.mbox.err + 1;
  }
  vQueueDelete((QueueHandle_t)*mbox);
  lwip_stats.sys.mbox.used = lwip_stats.sys.mbox.used - 1;
  return;
}



void sys_mbox_post(sys_mbox_t *mbox,void *data)

{
  BaseType_t BVar1;
  void *apvStack20 [2];
  
  apvStack20[0] = data;
  do {
    BVar1 = xQueueGenericSend((QueueHandle_t)*mbox,apvStack20,0xffffffff,0);
  } while (BVar1 != 1);
  return;
}



err_t sys_mbox_trypost(sys_mbox_t *mbox,void *msg)

{
  err_t eVar1;
  BaseType_t BVar2;
  void *apvStack20 [4];
  
  apvStack20[0] = msg;
  BVar2 = xQueueGenericSend((QueueHandle_t)*mbox,apvStack20,0,0);
  if (BVar2 == 1) {
    eVar1 = '\0';
  }
  else {
    eVar1 = -1;
    lwip_stats.sys.mbox.err = lwip_stats.sys.mbox.err + 1;
  }
  return eVar1;
}



u32_t sys_arch_mbox_fetch(sys_mbox_t *mbox,void **msg,u32_t timeout)

{
  TickType_t TVar1;
  BaseType_t BVar2;
  TickType_t TVar3;
  void *local_24;
  void *dummyptr;
  
  TVar1 = xTaskGetTickCount();
  if (msg == (void **)0x0) {
    msg = &local_24;
  }
  if (timeout == 0) {
    do {
      BVar2 = xQueueReceive((QueueHandle_t)*mbox,msg,0xffffffff);
    } while (BVar2 != 1);
  }
  else {
    BVar2 = xQueueReceive((QueueHandle_t)*mbox,msg,timeout);
    if (BVar2 != 1) {
      *msg = (void *)0x0;
      return 0xffffffff;
    }
  }
  TVar3 = xTaskGetTickCount();
  return TVar3 - TVar1;
}



u32_t sys_arch_mbox_tryfetch(sys_mbox_t *mbox,void **msg)

{
  BaseType_t BVar1;
  void *pvStack20;
  void *dummyptr;
  
  if (msg == (void **)0x0) {
    msg = &pvStack20;
  }
  BVar1 = xQueueReceive((QueueHandle_t)*mbox,msg,0);
  return -(uint)(BVar1 != 1);
}



uint sys_mbox_valid(int *param_1)

{
  return (uint)(*param_1 != 0);
}



void sys_mbox_set_invalid(undefined4 *param_1)

{
  *param_1 = 0;
  return;
}



err_t sys_sem_new(sys_sem_t *sem,u8_t count)

{
  err_t eVar1;
  QueueHandle_t xQueue;
  undefined3 in_register_0000202d;
  uint uVar2;
  
  xQueue = xQueueGenericCreate(1,0,'\x03');
  *(QueueHandle_t *)sem = xQueue;
  if (xQueue != (QueueHandle_t)0x0) {
    xQueueGenericSend(xQueue,(void *)0x0,0,0);
  }
  if ((QueueHandle_t)*sem == (QueueHandle_t)0x0) {
    lwip_stats.sys.sem.err = lwip_stats.sys.sem.err + 1;
    eVar1 = -1;
  }
  else {
    if (CONCAT31(in_register_0000202d,count) == 0) {
      xQueueSemaphoreTake((QueueHandle_t)*sem,1);
    }
    uVar2 = (uint)lwip_stats.sys.sem.used;
    lwip_stats.sys.sem.used = (u16_t)((uVar2 + 1) * 0x10000 >> 0x10);
    eVar1 = '\0';
    if ((uint)lwip_stats.sys.sem.max < (uVar2 + 1 & 0xffff)) {
      eVar1 = '\0';
      lwip_stats.sys.sem.max = lwip_stats.sys.sem.used;
    }
  }
  return eVar1;
}



u32_t sys_arch_sem_wait(sys_sem_t *sem,u32_t timeout)

{
  TickType_t TVar1;
  BaseType_t BVar2;
  TickType_t TVar3;
  
  TVar1 = xTaskGetTickCount();
  if (timeout == 0) {
    do {
      BVar2 = xQueueSemaphoreTake((QueueHandle_t)*sem,0xffffffff);
    } while (BVar2 != 1);
  }
  else {
    BVar2 = xQueueSemaphoreTake((QueueHandle_t)*sem,timeout);
    if (BVar2 != 1) {
      return 0xffffffff;
    }
  }
  TVar3 = xTaskGetTickCount();
  return TVar3 - TVar1;
}



void sys_sem_free(sys_sem_t *sem)

{
  lwip_stats.sys.sem.used = lwip_stats.sys.sem.used - 1;
  vQueueDelete((QueueHandle_t)*sem);
  return;
}



int sys_sem_valid(sys_sem_t *sem)

{
  return (uint)(*sem != (sys_sem_t)0x0);
}



void sys_sem_set_invalid(sys_sem_t *sem)

{
  *sem = (sys_sem_t)0x0;
  return;
}



void sys_init(void)

{
  s_nextthread = 0;
  return;
}



err_t sys_mutex_new(sys_mutex_t *mutex)

{
  err_t eVar1;
  QueueHandle_t pQVar2;
  uint uVar3;
  
  pQVar2 = xQueueCreateMutex('\x01');
  *(QueueHandle_t *)mutex = pQVar2;
  if (pQVar2 == (QueueHandle_t)0x0) {
    lwip_stats.sys.mutex.err = lwip_stats.sys.mutex.err + 1;
    eVar1 = -1;
  }
  else {
    uVar3 = (uint)lwip_stats.sys.mutex.used;
    lwip_stats.sys.mutex.used = (u16_t)((uVar3 + 1) * 0x10000 >> 0x10);
    eVar1 = '\0';
    if ((uint)lwip_stats.sys.mutex.max < (uVar3 + 1 & 0xffff)) {
      eVar1 = '\0';
      lwip_stats.sys.mutex.max = lwip_stats.sys.mutex.used;
    }
  }
  return eVar1;
}



void sys_mutex_lock(sys_mutex_t *mutex)

{
  sys_arch_sem_wait((sys_sem_t *)mutex,0);
  return;
}



void sys_mutex_unlock(sys_mutex_t *mutex)

{
  xQueueGenericSend((QueueHandle_t)*mutex,(void *)0x0,0,0);
  return;
}



void sys_sem_signal(sys_mutex_t *mutex)

{
  xQueueGenericSend((QueueHandle_t)*mutex,(void *)0x0,0,0);
  return;
}



sys_thread_t sys_thread_new(char *name,lwip_thread_fn *thread,void *arg,int stacksize,int prio)

{
  BaseType_t BVar1;
  TaskHandle_t ptStack20;
  TaskHandle_t CreatedTask;
  
  if (s_nextthread < 6) {
    BVar1 = xTaskCreate((TaskFunction_t *)thread,name,(uint16_t)stacksize,arg,prio,&ptStack20);
    if (BVar1 != 1) {
      ptStack20 = (sys_thread_t)0x0;
    }
    return ptStack20;
  }
  return (sys_thread_t)0x0;
}



sys_prot_t sys_arch_protect(void)

{
  vTaskEnterCritical();
  return 1;
}



void sys_arch_unprotect(void)

{
  if ((xSchedulerRunning != 0) && (pxCurrentTCB->uxCriticalNesting != 0)) {
    vTaskExitCritical();
    return;
  }
  return;
}



TickType_t sys_now(void)

{
  return xTickCount;
}



// WARNING: Variable defined which should be unmapped: addr

hostent * lwip_gethostbyname(char *name)

{
  char *s_aliases;
  ip_addr_t s_hostent_addr;
  ip_addr_t *s_phostent_addr [2];
  hostent s_hostent;
  char s_hostname [257];
  err_t eVar1;
  undefined3 extraout_var;
  hostent *phVar2;
  ip_addr_t iStack20;
  ip_addr_t addr;
  
  eVar1 = netconn_gethostbyname(name,&iStack20);
  if (CONCAT31(extraout_var,eVar1) == 0) {
    s_hostent_addr = (u32_t)iStack20;
    s_phostent_addr[0] = (ip_addr_t *)0x4200ded8;
    s_phostent_addr[1] = (ip_addr_t *)0x0;
    strncpy((char *)0x4201490c,name,0x100);
    phVar2 = (hostent *)0x420148f8;
  }
  else {
    h_errno = 0xd2;
    phVar2 = (hostent *)0x0;
  }
  return phVar2;
}



void lwip_freeaddrinfo(addrinfo *ai)

{
  addrinfo *paVar1;
  
  if (ai != (addrinfo *)0x0) {
    do {
      paVar1 = ai->ai_next;
      memp_free(MEMP_NETDB,ai);
      ai = paVar1;
    } while (paVar1 != (addrinfo *)0x0);
    return;
  }
  return;
}



// WARNING: Variable defined which should be unmapped: addr
// WARNING: Type propagation algorithm not settling

int lwip_getaddrinfo(char *nodename,char *servname,addrinfo *hints,addrinfo **res)

{
  err_t eVar1;
  u16_t n;
  int iVar2;
  size_t __n;
  undefined3 extraout_var;
  addrinfo *__s;
  size_t __n_00;
  uint uVar3;
  ip_addr_t iStack36;
  ip_addr_t addr;
  
  if (res == (addrinfo **)0x0) {
    return 0xca;
  }
  *res = (addrinfo *)0x0;
  if (nodename != (char *)0x0) {
    if (hints != (addrinfo *)0x0) goto LAB_2303a49a;
    n = 0;
    if (servname != (char *)0x0) goto LAB_2303a4ac;
    goto LAB_2303a502;
  }
  if (servname == (char *)0x0) {
    return 200;
  }
  if (hints == (addrinfo *)0x0) {
LAB_2303a4ac:
    iVar2 = atoi(servname);
    n = (u16_t)iVar2;
    if (0xfffe < iVar2 - 1U) {
      return 0xc9;
    }
    if (nodename != (char *)0x0) {
      if (hints == (addrinfo *)0x0) {
LAB_2303a502:
        eVar1 = netconn_gethostbyname(nodename,&iStack36);
        if (CONCAT31(extraout_var,eVar1) != 0) {
          return 0xca;
        }
      }
      else {
LAB_2303a4ca:
        if ((hints->ai_flags & 4U) == 0) goto LAB_2303a502;
        iVar2 = ip4addr_aton(nodename,(ip4_addr_t *)&iStack36);
        if (iVar2 == 0) {
          return 200;
        }
      }
      __n = strlen(nodename);
      __n_00 = __n + 0x31;
      if (0x100 < __n) {
        return 0xca;
      }
      goto LAB_2303a53c;
    }
  }
  else {
LAB_2303a49a:
    uVar3 = hints->ai_family & 0xfffffffd;
    n = (u16_t)uVar3;
    if (uVar3 != 0) {
      return 0xcc;
    }
    if (servname != (char *)0x0) goto LAB_2303a4ac;
    if (nodename != (char *)0x0) goto LAB_2303a4ca;
  }
  if ((hints == (addrinfo *)0x0) || ((hints->ai_flags & 1U) == 0)) {
    iStack36 = (ip4_addr_t)0x100007f;
  }
  else {
    iStack36 = (ip4_addr_t)0x0;
  }
  __n = 0;
  __n_00 = 0x30;
LAB_2303a53c:
  __s = (addrinfo *)memp_malloc(MEMP_NETDB);
  iVar2 = 0xcb;
  if (__s != (addrinfo *)0x0) {
    memset(__s,0,__n_00);
    *(ip4_addr_t *)&((ip4_addr_t *)&__s[1].ai_family)->addr = iStack36;
    *(undefined2 *)&__s[1].ai_flags = 0x210;
    n = lwip_htons(n);
    *(u16_t *)((int)&__s[1].ai_flags + 2) = n;
    __s->ai_family = 2;
    if (hints != (addrinfo *)0x0) {
      __s->ai_socktype = hints->ai_socktype;
      __s->ai_protocol = hints->ai_protocol;
    }
    if (nodename != (char *)0x0) {
      *(socklen_t **)&__s->ai_canonname = &__s[1].ai_addrlen;
      memcpy(&__s[1].ai_addrlen,nodename,__n);
      __s->ai_canonname[__n] = '\0';
    }
    __s->ai_addrlen = 0x10;
    *(addrinfo **)&__s->ai_addr = __s + 1;
    *res = __s;
    iVar2 = 0;
  }
  return iVar2;
}



err_t netifapi_do_netif_add(tcpip_api_call_data *m)

{
  err_t eVar1;
  netif *pnVar2;
  
  pnVar2 = netif_add(*(netif **)(m + 1),(ip4_addr_t *)m[1].sem,*(ip4_addr_t **)(m + 2),
                     (ip4_addr_t *)m[2].sem,*(void **)(m + 3),(netif_init_fn_conflict *)m[3].sem,
                     *(netif_input_fn **)(m + 4));
  if (pnVar2 == (netif *)0x0) {
    eVar1 = -0xc;
  }
  else {
    eVar1 = '\0';
  }
  return eVar1;
}



err_t netifapi_do_netif_set_addr(tcpip_api_call_data *m)

{
  netif_set_addr(*(netif **)(m + 1),(ip4_addr_t *)m[1].sem,*(ip4_addr_t **)(m + 2),
                 (ip4_addr_t *)m[2].sem);
  return '\0';
}



err_t netifapi_do_netif_common(tcpip_api_call_data *m)

{
  err_t eVar1;
  
  if (*(code **)(m + 2) != (code *)0x0) {
                    // WARNING: Could not recover jumptable at 0x2303a5f4. Too many branches
                    // WARNING: Treating indirect jump as call
    eVar1 = (**(code **)(m + 2))();
    return eVar1;
  }
  (*(code *)m[1].sem)(*(undefined4 *)(m + 1),m[1].sem);
  return '\0';
}



// WARNING: Could not reconcile some variable overlaps

err_t netifapi_netif_add(netif *netif,ip4_addr_t *ipaddr,ip4_addr_t *netmask,ip4_addr_t *gw,
                        void *state,netif_init_fn init,netif_input_fn *input)

{
  err_t eVar1;
  undefined auStack52 [4];
  netifapi_msg msg;
  
  if (ipaddr == (ip4_addr_t *)0x0) {
    ipaddr = (ip4_addr_t *)&ip_addr_any;
  }
  if (netmask == (ip4_addr_t *)0x0) {
    netmask = (ip4_addr_t *)&ip_addr_any;
  }
  if (gw == (ip4_addr_t *)0x0) {
    gw = (ip4_addr_t *)&ip_addr_any;
  }
  msg.call.sem = (sys_sem_t)netif;
  msg.netif = (netif *)ipaddr;
  msg.msg._0_4_ = netmask;
  msg.msg._4_4_ = gw;
  msg.msg._8_4_ = state;
  msg.msg._12_4_ = init;
  msg.msg._16_4_ = input;
  eVar1 = tcpip_api_call(netifapi_do_netif_add,(tcpip_api_call_data *)auStack52);
  return eVar1;
}



// WARNING: Could not reconcile some variable overlaps

err_t netifapi_netif_set_addr(netif *netif,ip4_addr_t *ipaddr,ip4_addr_t *netmask,ip4_addr_t *gw)

{
  err_t eVar1;
  undefined auStack52 [4];
  netifapi_msg msg;
  
  if (ipaddr == (ip4_addr_t *)0x0) {
    ipaddr = (ip4_addr_t *)&ip_addr_any;
  }
  if (netmask == (ip4_addr_t *)0x0) {
    netmask = (ip4_addr_t *)&ip_addr_any;
  }
  if (gw == (ip4_addr_t *)0x0) {
    gw = (ip4_addr_t *)&ip_addr_any;
  }
  msg.call.sem = (sys_sem_t)netif;
  msg.netif = (netif *)ipaddr;
  msg.msg._0_4_ = netmask;
  msg.msg._4_4_ = gw;
  eVar1 = tcpip_api_call(netifapi_do_netif_set_addr,(tcpip_api_call_data *)auStack52);
  return eVar1;
}



// WARNING: Could not reconcile some variable overlaps

err_t netifapi_netif_common(netif *netif,netifapi_void_fn voidfunc,netifapi_errt_fn errtfunc)

{
  err_t eVar1;
  undefined auStack52 [4];
  netifapi_msg msg;
  
  msg.call.sem = (sys_sem_t)netif;
  msg.netif = (netif *)voidfunc;
  msg.msg._0_4_ = errtfunc;
  eVar1 = tcpip_api_call(netifapi_do_netif_common,(tcpip_api_call_data *)auStack52);
  return eVar1;
}



int alloc_socket(netconn *newconn,int accepted)

{
  int iVar1;
  u16_t uVar2;
  lwip_sock *plVar3;
  
  uVar2 = (u16_t)accepted;
  plVar3 = sockets;
  iVar1 = 0;
  do {
    sys_arch_protect();
    if (plVar3->conn == (netconn *)0x0) {
      sockets[iVar1].conn = newconn;
      sys_arch_unprotect();
      sockets[iVar1].lastdata = 0;
      sockets[iVar1].rcvevent = 0;
      if ((newconn->type & 0xf0) != NETCONN_TCP) {
        uVar2 = 1;
      }
      sockets[iVar1].sendevent = uVar2;
      sockets[iVar1].errevent = 0;
      return iVar1;
    }
    iVar1 = iVar1 + 1;
    sys_arch_unprotect();
    plVar3 = plVar3 + 1;
  } while (iVar1 != 0x15);
  return -1;
}



void lwip_link_select_cb(lwip_select_cb *select_cb)

{
  sys_arch_protect();
  select_cb->next = select_cb_list;
  if (select_cb_list != (lwip_select_cb *)0x0) {
    select_cb_list->prev = select_cb;
  }
  select_cb_ctr = select_cb_ctr + 1;
  select_cb_list = select_cb;
  sys_arch_unprotect();
  return;
}



void lwip_unlink_select_cb(lwip_select_cb *select_cb)

{
  lwip_select_cb **pplVar1;
  
  sys_arch_protect();
  if (select_cb->next != (lwip_select_cb *)0x0) {
    select_cb->next->prev = select_cb->prev;
  }
  pplVar1 = &select_cb_list;
  if (select_cb_list != select_cb) {
    pplVar1 = (lwip_select_cb **)select_cb->prev;
  }
  ((lwip_select_cb *)pplVar1)->next = select_cb->next;
  select_cb_ctr = select_cb_ctr + 1;
  sys_arch_unprotect();
  return;
}



int lwip_selscan(int maxfdp1,_types_fd_set *readset_in,_types_fd_set *writeset_in,
                _types_fd_set *exceptset_in,_types_fd_set *readset_out,_types_fd_set *writeset_out,
                _types_fd_set *exceptset_out)

{
  short sVar1;
  u16_t uVar2;
  u16_t uVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  lwip_sock *plVar8;
  s16_t rcvevent;
  fd_mask local_58;
  _types_fd_set lreadset;
  _types_fd_set lwriteset;
  _types_fd_set lexceptset;
  
  iVar6 = 0;
  do {
    *(undefined *)((int)&local_58 + iVar6) = 0;
    iVar6 = iVar6 + 1;
  } while (iVar6 != 8);
  iVar6 = 0;
  do {
    *(undefined *)((int)lreadset.fds_bits + iVar6 + 4) = 0;
    iVar6 = iVar6 + 1;
  } while (iVar6 != 8);
  iVar6 = 0;
  do {
    *(undefined *)((int)lwriteset.fds_bits + iVar6 + 4) = 0;
    iVar6 = iVar6 + 1;
  } while (iVar6 != 8);
  plVar8 = sockets;
  iVar6 = 0;
  uVar4 = 0;
  do {
    if (maxfdp1 <= (int)uVar4) {
      readset_out->fds_bits[0] = local_58;
      readset_out->fds_bits[1] = lreadset.fds_bits[0];
      writeset_out->fds_bits[0] = lreadset.fds_bits[1];
      writeset_out->fds_bits[1] = lwriteset.fds_bits[0];
      exceptset_out->fds_bits[0] = lwriteset.fds_bits[1];
      exceptset_out->fds_bits[1] = lexceptset.fds_bits[0];
      return iVar6;
    }
    if ((((readset_in != (_types_fd_set *)0x0) &&
         ((1 << (uVar4 & 0x1f) & readset_in->fds_bits[uVar4 >> 5]) != 0)) ||
        ((writeset_in != (_types_fd_set *)0x0 &&
         ((1 << (uVar4 & 0x1f) & writeset_in->fds_bits[uVar4 >> 5]) != 0)))) ||
       ((exceptset_in != (_types_fd_set *)0x0 &&
        ((1 << (uVar4 & 0x1f) & exceptset_in->fds_bits[uVar4 >> 5]) != 0)))) {
      sys_arch_protect();
      if (0x14 < uVar4) {
        sys_arch_unprotect();
        return -1;
      }
      uVar2 = plVar8->sendevent;
      uVar3 = plVar8->errevent;
      iVar7 = plVar8->lastdata;
      sVar1 = plVar8->rcvevent;
      sys_arch_unprotect();
      if (((readset_in != (_types_fd_set *)0x0) &&
          (uVar5 = 1 << (uVar4 & 0x1f), (readset_in->fds_bits[0] & uVar5) != 0)) &&
         ((iVar7 != 0 || (0 < sVar1)))) {
        iVar6 = iVar6 + 1;
        local_58 = local_58 | uVar5;
      }
      if (((writeset_in != (_types_fd_set *)0x0) &&
          (uVar5 = 1 << (uVar4 & 0x1f), (writeset_in->fds_bits[0] & uVar5) != 0)) && (uVar2 != 0)) {
        iVar6 = iVar6 + 1;
        lreadset.fds_bits[1] = lreadset.fds_bits[1] | uVar5;
      }
      if (((exceptset_in != (_types_fd_set *)0x0) &&
          (uVar5 = 1 << (uVar4 & 0x1f), (exceptset_in->fds_bits[0] & uVar5) != 0)) && (uVar3 != 0))
      {
        iVar6 = iVar6 + 1;
        lwriteset.fds_bits[1] = lwriteset.fds_bits[1] | uVar5;
      }
    }
    uVar4 = uVar4 + 1;
    plVar8 = plVar8 + 1;
  } while( true );
}



ssize_t lwip_recv_tcp(lwip_sock *sock,void *mem,size_t len,int flags)

{
  size_t len_00;
  err_t err;
  pbuf *ppVar1;
  undefined3 extraout_var;
  int iVar2;
  void *dataptr;
  u8_t apiflags;
  uint uVar3;
  pbuf *ppStack52;
  pbuf *p;
  
  if ((int)len < 0) {
    len = 0x7fffffff;
  }
  apiflags = '\b';
  if ((flags & 8U) != 0) {
    apiflags = '\f';
  }
  len_00 = 0;
  do {
    ppVar1 = (pbuf *)sock->lastdata;
    if ((pbuf *)sock->lastdata == (pbuf *)0x0) {
      err = netconn_recv_tcp_pbuf_flags(sock->conn,&ppStack52,apiflags);
      if (CONCAT31(extraout_var,err) != 0) {
        if (len_00 == 0) {
          iVar2 = err_to_errno(err);
          if (iVar2 != 0) {
            errno = iVar2;
          }
          return -(uint)(CONCAT31(extraout_var,err) != -0xf);
        }
        if ((flags & 1U) != 0) {
          return len_00;
        }
        goto LAB_2303a9bc;
      }
      *(pbuf **)&sock->lastdata = ppStack52;
      ppVar1 = ppStack52;
    }
    ppStack52 = ppVar1;
    uVar3 = (uint)ppStack52->tot_len;
    if ((int)len <= (int)uVar3) {
      uVar3 = len & 0xffff;
    }
    dataptr = (void *)((int)mem + len_00);
    len_00 = uVar3 + len_00;
    pbuf_copy_partial(ppStack52,dataptr,(u16_t)uVar3,0);
    if ((flags & 1U) != 0) {
      if (len_00 != 0) {
        return len_00;
      }
      goto LAB_2303aa2c;
    }
    if ((int)(ppStack52->tot_len - uVar3) < 1) {
      sock->lastdata = 0;
      pbuf_free(ppStack52);
    }
    else {
      ppVar1 = pbuf_free_header(ppStack52,(u16_t)uVar3);
      *(pbuf **)&sock->lastdata = ppVar1;
    }
    len = len - uVar3;
    apiflags = '\x1c';
  } while (0 < (int)len);
  if (len_00 == 0) {
LAB_2303aa2c:
    len_00 = 0;
  }
  else {
LAB_2303a9bc:
    netconn_tcp_recvd(sock->conn,len_00);
  }
  return len_00;
}



// WARNING: Could not reconcile some variable overlaps

int lwip_sock_make_addr(u16_t port,sockaddr *from,socklen_t *fromlen)

{
  int iVar1;
  undefined2 in_register_0000202a;
  size_t *in_a3;
  uint uVar2;
  undefined2 uStack32;
  u16_t uStack30;
  sockaddr_aligned saddr;
  
  uStack32 = 0x210;
  uStack30 = lwip_htons((u16_t)from);
  saddr._0_4_ = *(undefined4 *)CONCAT22(in_register_0000202a,port);
  memset(saddr + 4,0,8);
  uVar2 = (uint)(byte)uStack32;
  iVar1 = 1;
  if ((uVar2 <= *in_a3) && (iVar1 = 0, uVar2 < *in_a3)) {
    *in_a3 = uVar2;
  }
  memcpy(fromlen,&uStack32,*in_a3);
  return iVar1;
}



void free_socket(lwip_sock *sock,int is_tcp)

{
  netbuf *buf;
  netconn *conn;
  
  sys_arch_protect();
  buf = (netbuf *)sock->lastdata;
  conn = sock->conn;
  sock->lastdata = 0;
  sock->conn = (netconn *)0x0;
  sys_arch_unprotect();
  if (buf != (netbuf *)0x0) {
    if (is_tcp == 0) {
      netbuf_delete(buf);
    }
    else {
      pbuf_free((pbuf *)buf);
    }
  }
  if (conn != (netconn *)0x0) {
    netconn_delete(conn);
    return;
  }
  return;
}



err_t lwip_recvfrom_udp_raw(lwip_sock *sock,int flags,msghdr *msg,u16_t *datagram_len)

{
  ushort uVar1;
  uint uVar2;
  err_t eVar3;
  undefined3 extraout_var;
  uint uVar4;
  uint uVar5;
  int iVar6;
  netbuf *pnStack52;
  netbuf *buf;
  
  if ((msg->msg_iov != (iovec *)0x0) || (eVar3 = -0x10, msg->msg_iovlen < 1)) {
    pnStack52 = (netbuf *)sock->lastdata;
    if (pnStack52 == (netbuf *)0x0) {
      eVar3 = netconn_recv_udp_raw_netbuf_flags(sock->conn,&pnStack52,((flags & 8U) != 0) << 2);
      if (CONCAT31(extraout_var,eVar3) != 0) {
        return eVar3;
      }
      *(netbuf **)&sock->lastdata = pnStack52;
    }
    iVar6 = 0;
    uVar2 = 0;
    uVar1 = pnStack52->p->tot_len;
    while ((iVar6 < msg->msg_iovlen && (uVar2 < uVar1))) {
      uVar4 = msg->msg_iov[iVar6].iov_len;
      uVar5 = uVar1 - uVar2 & 0xffff;
      if (uVar4 <= uVar5) {
        uVar5 = uVar4 & 0xffff;
      }
      pbuf_copy_partial(pnStack52->p,msg->msg_iov[iVar6].iov_base,(u16_t)uVar5,(u16_t)uVar2);
      uVar2 = uVar2 + uVar5 & 0xffff;
      iVar6 = iVar6 + 1;
    }
    if (((socklen_t *)msg->msg_name != (socklen_t *)0x0) && (msg->msg_namelen != 0)) {
      lwip_sock_make_addr((short)pnStack52 + 8,(sockaddr *)(uint)pnStack52->port,
                          (socklen_t *)msg->msg_name);
    }
    msg->msg_flags = 0;
    if (msg->msg_control != (void *)0x0) {
      msg->msg_controllen = 0;
    }
    if ((flags & 1U) == 0) {
      sock->lastdata = 0;
      netbuf_delete(pnStack52);
    }
    *datagram_len = uVar1;
    eVar3 = '\0';
  }
  return eVar3;
}



lwip_sock * get_socket(int fd)

{
  lwip_sock *plVar1;
  
  if ((0x14 < (uint)fd) || (plVar1 = sockets + fd, plVar1->conn == (netconn *)0x0)) {
    errno = 9;
    plVar1 = (lwip_sock *)0x0;
  }
  return plVar1;
}



// WARNING: Type propagation algorithm not settling

void lwip_setsockopt_callback(void *arg)

{
  ip4_addr_t iVar1;
  err_t eVar2;
  ip4_addr_t *name;
  sys_mutex_t mutex;
  lwip_sock *plVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  netif *netif;
  netconn *pnVar4;
  lwip_socket_multicast_pair *plVar5;
  uint uVar6;
  int iVar7;
  byte bVar8;
  netconn_type nVar9;
  int iVar10;
  u32_t uVar11;
  uint fd;
  ip4_addr_t iStack40;
  ip4_addr_t if_addr;
  ip4_addr_t multi_addr;
  
  fd = *(uint *)arg;
  iVar1 = (ip4_addr_t)((ip4_addr_t *)((int)arg + 4))->addr;
  iVar10 = *(int *)((int)arg + 8);
  bVar8 = (byte)iVar10;
  uVar6 = *(uint *)((int)arg + 0x10);
  name = *(ip4_addr_t **)((int)arg + 0xc);
  if ((0x14 < fd) || (pnVar4 = sockets[fd].conn, pnVar4 == (netconn *)0x0)) {
    iVar1 = (ip4_addr_t)0x9;
    goto LAB_2303ac7e;
  }
  if (iVar1 == (ip4_addr_t)0x6) {
    iVar1 = (ip4_addr_t)0x16;
    if ((((uVar6 < 4) || (iVar7 = pnVar4->pcb, iVar7 == 0)) ||
        (iVar1 = (ip4_addr_t)0x5c, (pnVar4->type & 0xf0) != NETCONN_TCP)) ||
       ((iVar1 = (ip4_addr_t)0x16, *(char *)(iVar7 + 0x14) == '\x01' ||
        (iVar1 = (ip4_addr_t)0x5c, 4 < iVar10 - 1U)))) goto LAB_2303ac7e;
    iVar1 = (ip4_addr_t)name->addr;
    switch(iVar10) {
    case 1:
      if (iVar1 == (ip4_addr_t)0x0) {
        *(ushort *)(iVar7 + 0x1a) = *(ushort *)(iVar7 + 0x1a) & 0xffbf;
        goto LAB_2303ac7e;
      }
      *(ushort *)(iVar7 + 0x1a) = *(ushort *)(iVar7 + 0x1a) | 0x40;
      break;
    case 3:
      iVar1 = (ip4_addr_t)((int)iVar1 * 1000);
    case 2:
      *(ip4_addr_t *)&((ip4_addr_t *)(iVar7 + 0x94))->addr = iVar1;
      break;
    case 4:
      *(int *)(iVar7 + 0x98) = (int)iVar1 * 1000;
      break;
    case 5:
      *(ip4_addr_t *)&((ip4_addr_t *)(iVar7 + 0x9c))->addr = iVar1;
    }
LAB_2303acfa:
    iVar1 = (ip4_addr_t)0x0;
    goto LAB_2303ac7e;
  }
  if (iVar1 == (ip4_addr_t)0xfff) {
    if (iVar10 == 0x1005) {
      iVar1 = (ip4_addr_t)0x16;
      if ((uVar6 < 0x10) || (iVar10 = name->addr * 1000 + *(int *)(name + 2) / 1000, iVar10 < 0))
      goto LAB_2303ac7e;
      pnVar4->send_timeout = iVar10;
    }
    else {
      if (iVar10 < 0x1006) {
        if (((iVar10 != 8) && (iVar10 != 0x20)) && (iVar10 != 4)) goto switchD_2303add6_caseD_7;
        if (iVar10 == 0x20) {
          iVar1 = (ip4_addr_t)0x5c;
          if ((pnVar4->type & 0xf0) != NETCONN_UDP) goto LAB_2303ac7e;
        }
        else {
          if ((iVar10 != 4) && (iVar10 != 8)) {
            bVar8 = 0;
          }
        }
        iVar1 = (ip4_addr_t)0x16;
        if ((uVar6 < 4) || (iVar10 = pnVar4->pcb, iVar1 = (ip4_addr_t)0x16, iVar10 == 0))
        goto LAB_2303ac7e;
        iVar1 = (ip4_addr_t)name->addr;
        if (iVar1 == (ip4_addr_t)0x0) {
          *(byte *)(iVar10 + 9) = *(byte *)(iVar10 + 9) & ~bVar8;
          goto LAB_2303ac7e;
        }
        *(byte *)(iVar10 + 9) = *(byte *)(iVar10 + 9) | bVar8;
      }
      else {
        if (iVar10 == 0x100a) {
          iVar1 = (ip4_addr_t)0x16;
          if (((uVar6 < 4) || (iVar10 = pnVar4->pcb, iVar10 == 0)) ||
             (iVar1 = (ip4_addr_t)0x5c, (pnVar4->type & 0xf0) != NETCONN_UDP)) goto LAB_2303ac7e;
          iVar1 = (ip4_addr_t)name->addr;
          if (iVar1 == (ip4_addr_t)0x0) {
            bVar8 = *(byte *)(iVar10 + 0x10) & 0xfe;
            goto LAB_2303ad60;
          }
          *(byte *)(iVar10 + 0x10) = *(byte *)(iVar10 + 0x10) | 1;
        }
        else {
          if (iVar10 == 0x100b) {
            iVar1 = (ip4_addr_t)0x16;
            if (uVar6 < 6) goto LAB_2303ac7e;
            netif = (netif *)0x0;
            if (*(char *)&name->addr != '\0') {
              netif = netif_find((char *)name);
              iVar1 = (ip4_addr_t)0x13;
              if (netif == (netif *)0x0) goto LAB_2303ac7e;
            }
            pnVar4 = sockets[fd].conn;
            nVar9 = pnVar4->type & 0xf0;
            if (nVar9 == NETCONN_UDP) {
              udp_bind_netif((udp_pcb *)pnVar4->pcb,netif);
            }
            else {
              if (nVar9 != NETCONN_RAW) {
                iVar1 = (ip4_addr_t)0x0;
                if (nVar9 == NETCONN_TCP) {
                  tcp_bind_netif((tcp_pcb *)pnVar4->pcb,netif);
                }
                goto LAB_2303ac7e;
              }
              raw_bind_netif((raw_pcb *)pnVar4->pcb,netif);
            }
          }
          else {
            if (iVar10 != 0x1006) goto switchD_2303add6_caseD_7;
            iVar1 = (ip4_addr_t)0x16;
            if ((uVar6 < 0x10) ||
               (uVar11 = name->addr * 1000 + *(int *)(name + 2) / 1000, (int)uVar11 < 0))
            goto LAB_2303ac7e;
            pnVar4->recv_timeout = uVar11;
          }
        }
      }
    }
    goto LAB_2303acfa;
  }
  if (iVar1 != (ip4_addr_t)0x0) goto switchD_2303add6_caseD_7;
  switch(iVar10) {
  case 1:
    if ((3 < uVar6) && (pnVar4->pcb != 0)) {
      *(undefined *)(pnVar4->pcb + 10) = (char)name->addr;
      goto LAB_2303ac7e;
    }
    goto LAB_2303afd4;
  case 2:
    if ((3 < uVar6) && (pnVar4->pcb != 0)) {
      *(undefined *)(pnVar4->pcb + 0xb) = (char)name->addr;
      goto LAB_2303ac7e;
    }
LAB_2303afd4:
    iVar1 = (ip4_addr_t)0x16;
    goto LAB_2303ac7e;
  case 3:
  case 4:
    if ((uVar6 < 8) || (pnVar4->pcb == 0)) goto LAB_2303afd4;
    if ((pnVar4->type & 0xf0) == NETCONN_UDP) {
      iStack40 = (ip4_addr_t)name[1].addr;
      if_addr = name->addr;
      if (iVar10 == 3) {
        plVar3 = get_socket(fd);
        if (plVar3 != (lwip_sock *)0x0) {
          plVar5 = socket_ipv4_multicast_memberships;
          iVar10 = 0;
          do {
            if (plVar5->sock == (lwip_sock *)0x0) {
              socket_ipv4_multicast_memberships[iVar10].sock = plVar3;
              *(ip4_addr_t *)&socket_ipv4_multicast_memberships[iVar10].if_addr.addr = iStack40;
              socket_ipv4_multicast_memberships[iVar10].multi_addr.addr = if_addr;
              eVar2 = igmp_joingroup(&iStack40,&if_addr);
              iVar10 = CONCAT31(extraout_var,eVar2);
              goto LAB_2303aed6;
            }
            iVar10 = iVar10 + 1;
            plVar5 = plVar5 + 1;
          } while (iVar10 != 0x15);
        }
        iVar1 = (ip4_addr_t)0xc;
      }
      else {
        eVar2 = igmp_leavegroup(&iStack40,&if_addr);
        iVar10 = CONCAT31(extraout_var_00,eVar2);
        plVar3 = get_socket(fd);
        if (plVar3 != (lwip_sock *)0x0) {
          plVar5 = socket_ipv4_multicast_memberships;
          iVar7 = 0;
          do {
            if (((plVar3 == plVar5->sock) && ((ip4_addr_t)(plVar5->if_addr).addr == iStack40)) &&
               ((plVar5->multi_addr).addr == if_addr)) {
              socket_ipv4_multicast_memberships[iVar7].sock = (lwip_sock *)0x0;
              socket_ipv4_multicast_memberships[iVar7].if_addr.addr = 0;
              socket_ipv4_multicast_memberships[iVar7].multi_addr.addr = 0;
              break;
            }
            iVar7 = iVar7 + 1;
            plVar5 = plVar5 + 1;
          } while (iVar7 != 0x15);
        }
LAB_2303aed6:
        if (iVar10 != 0) {
          iVar1 = (ip4_addr_t)0x63;
        }
      }
      goto LAB_2303ac7e;
    }
    break;
  case 5:
    if ((uVar6 == 0) || (pnVar4->pcb == 0)) goto LAB_2303afd4;
    if ((pnVar4->type & 0xf0) == NETCONN_UDP) {
      *(undefined *)(pnVar4->pcb + 0x1d) = *(undefined *)&name->addr;
      goto LAB_2303ac7e;
    }
    break;
  case 6:
    if ((uVar6 < 4) || (pnVar4->pcb == 0)) goto LAB_2303afd4;
    if ((pnVar4->type & 0xf0) == NETCONN_UDP) {
      ((ip4_addr_t *)(pnVar4->pcb + 0x18))->addr = name->addr;
      goto LAB_2303ac7e;
    }
    break;
  case 7:
    if ((uVar6 == 0) || (iVar10 = pnVar4->pcb, iVar10 == 0)) goto LAB_2303afd4;
    if ((pnVar4->type & 0xf0) == NETCONN_UDP) {
      if (*(char *)&name->addr == '\0') {
        bVar8 = *(byte *)(iVar10 + 0x10) & 0xf7;
      }
      else {
        bVar8 = *(byte *)(iVar10 + 0x10) | 8;
      }
LAB_2303ad60:
      *(byte *)(iVar10 + 0x10) = bVar8;
      goto LAB_2303ac7e;
    }
  }
switchD_2303add6_caseD_7:
  iVar1 = (ip4_addr_t)0x5c;
LAB_2303ac7e:
  mutex = *(sys_mutex_t *)((int)arg + 0x18);
  *(ip4_addr_t *)&((ip4_addr_t *)((int)arg + 0x14))->addr = iVar1;
  sys_sem_signal((sys_mutex_t *)mutex);
  return;
}



void event_callback(netconn *conn,netconn_evt evt,u16_t len)

{
  short sVar1;
  u16_t uVar2;
  u16_t uVar3;
  bool bVar4;
  lwip_select_cb *plVar5;
  lwip_select_cb *plVar6;
  uint fd;
  sys_prot_t sVar7;
  lwip_sock *plVar8;
  undefined3 in_register_0000202d;
  nfds_t nVar9;
  int iVar10;
  ushort *puVar11;
  uint uVar12;
  uint uVar13;
  
  if (conn == (netconn *)0x0) {
    return;
  }
  fd = conn->socket;
  if ((int)fd < 0) {
    sVar7 = sys_arch_protect();
    fd = conn->socket;
    if ((int)fd < 0) {
      if (CONCAT31(in_register_0000202d,evt) == 0) {
        conn->socket = fd - 1;
      }
      goto LAB_2303b018;
    }
    sys_arch_unprotect(sVar7);
  }
  plVar8 = get_socket(fd);
  if (plVar8 == (lwip_sock *)0x0) {
    return;
  }
  sVar7 = sys_arch_protect();
  bVar4 = true;
  switch(CONCAT31(in_register_0000202d,evt)) {
  case 0:
    iVar10 = ((uint)(ushort)plVar8->rcvevent + 1) * 0x10000;
    plVar8->rcvevent = (s16_t)((uint)iVar10 >> 0x10);
    bVar4 = iVar10 >> 0x10 < 2;
    break;
  case 1:
    plVar8->rcvevent = plVar8->rcvevent + -1;
    goto LAB_2303b0cc;
  case 2:
    uVar2 = plVar8->sendevent;
    plVar8->sendevent = 1;
    bVar4 = uVar2 == 0;
    break;
  case 3:
    plVar8->sendevent = 0;
LAB_2303b0cc:
    bVar4 = false;
    break;
  case 4:
    bVar4 = true;
    plVar8->errevent = 1;
  }
  if ((plVar8->select_waiting != '\0') && (bVar4)) {
    sVar1 = plVar8->rcvevent;
    uVar2 = plVar8->sendevent;
    uVar3 = plVar8->errevent;
    sys_arch_unprotect();
    sVar7 = sys_arch_protect();
    uVar12 = fd >> 5;
    uVar13 = 1 << (fd & 0x1f);
    plVar5 = select_cb_list;
    while (plVar6 = plVar5, iVar10 = select_cb_ctr, plVar6 != (lwip_select_cb *)0x0) {
      if (plVar6->sem_signalled == 0) {
        if (plVar6->poll_fds == (pollfd *)0x0) {
          if (((((0 < sVar1) && (plVar6->readset != (_types_fd_set *)0x0)) &&
               ((uVar13 & plVar6->readset->fds_bits[uVar12]) != 0)) ||
              (((uVar2 != 0 && (plVar6->writeset != (_types_fd_set *)0x0)) &&
               ((uVar13 & plVar6->writeset->fds_bits[uVar12]) != 0)))) ||
             (((uVar3 != 0 && (plVar6->exceptset != (_types_fd_set *)0x0)) &&
              ((uVar13 & plVar6->exceptset->fds_bits[uVar12]) != 0)))) {
LAB_2303b17c:
            plVar6->sem_signalled = 1;
            sys_sem_signal((sys_mutex_t *)&plVar6->sem);
          }
        }
        else {
          puVar11 = (ushort *)&plVar6->poll_fds->events;
          nVar9 = 0;
          while (nVar9 != plVar6->poll_nfds) {
            if ((fd == *(uint *)(puVar11 + -2)) &&
               ((((0 < sVar1 && ((*puVar11 & 1) != 0)) || ((uVar2 != 0 && ((*puVar11 & 2) != 0))))
                || (uVar3 != 0)))) goto LAB_2303b17c;
            nVar9 = nVar9 + 1;
            puVar11 = puVar11 + 4;
          }
        }
      }
      sys_arch_unprotect(sVar7);
      sVar7 = sys_arch_protect();
      plVar5 = select_cb_list;
      if (select_cb_ctr == iVar10) {
        plVar5 = plVar6->next;
      }
    }
  }
LAB_2303b018:
  sys_arch_unprotect(sVar7);
  return;
}



// WARNING: Could not reconcile some variable overlaps

int lwip_accept(int s,sockaddr *addr,socklen_t *addrlen)

{
  int iVar1;
  err_t err;
  lwip_sock *plVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  int iVar3;
  u16_t uStack58;
  u16_t port;
  netconn *pnStack56;
  netconn *newconn;
  ip_addr_t naddr;
  sockaddr_aligned tempaddr;
  
  uStack58 = 0;
  plVar2 = get_socket(s);
  if (plVar2 == (lwip_sock *)0x0) {
    return -1;
  }
  err = netconn_accept(plVar2->conn,(netconn **)&stack0xffffffc8);
  if (CONCAT31(extraout_var,err) == 0) {
    iVar3 = alloc_socket(pnStack56,1);
    if (iVar3 == -1) {
      netconn_delete(pnStack56);
      errno = 0x17;
      return -1;
    }
    sys_arch_protect();
    iVar1 = pnStack56->socket;
    pnStack56->socket = iVar3;
    sys_arch_unprotect();
    if (pnStack56->callback != (netconn_callback *)0x0) {
      iVar1 = (int)(short)~(ushort)iVar1;
      while (0 < iVar1) {
        iVar1 = iVar1 + -1;
        (*pnStack56->callback)(pnStack56,NETCONN_EVT_RCVPLUS,0);
      }
    }
    if (addr == (sockaddr *)0x0) {
      return iVar3;
    }
    if (addrlen == (socklen_t *)0x0) {
      return iVar3;
    }
    err = netconn_getaddr(pnStack56,(ip_addr_t *)&newconn,&uStack58,'\0');
    if (CONCAT31(extraout_var_00,err) == 0) {
      naddr.addr._0_2_ = 0x210;
      naddr.addr._2_2_ = lwip_htons(uStack58);
      tempaddr._0_4_ = (ip_addr_t)newconn;
      memset(tempaddr + 4,0,8);
      if ((uint)(byte)naddr.addr < *addrlen) {
        *addrlen = (uint)(byte)naddr.addr;
      }
      memcpy(addr,&naddr,*addrlen);
      return iVar3;
    }
    netconn_delete(pnStack56);
    free_socket(sockets + iVar3,1);
  }
  else {
    if ((plVar2->conn->type & 0xf0) != NETCONN_TCP) {
      errno = 0x5f;
      return -1;
    }
    if (CONCAT31(extraout_var,err) == -0xf) {
      errno = 0x16;
      return -1;
    }
  }
  iVar3 = err_to_errno(err);
  if (iVar3 != 0) {
    errno = iVar3;
  }
  return -1;
}



// WARNING: Type propagation algorithm not settling

int lwip_bind(int s,sockaddr *name,socklen_t namelen)

{
  err_t err;
  u16_t port;
  lwip_sock *plVar1;
  int iVar2;
  undefined3 extraout_var;
  ip_addr_t iStack20;
  ip_addr_t local_addr;
  
  plVar1 = get_socket(s);
  if (plVar1 != (lwip_sock *)0x0) {
    if (((namelen == 0x10) && (name->sa_family == '\x02')) && (((uint)name & 3) == 0)) {
      iStack20 = (ip_addr_t)((ip_addr_t *)(name->sa_data + 2))->addr;
      port = lwip_htons(*(u16_t *)name->sa_data);
      err = netconn_bind(plVar1->conn,&iStack20,port);
      if (CONCAT31(extraout_var,err) == 0) {
        return 0;
      }
    }
    else {
      err = -0x10;
    }
    iVar2 = err_to_errno(err);
    if (iVar2 != 0) {
      errno = iVar2;
    }
  }
  return -1;
}



// WARNING: Type propagation algorithm not settling

int lwip_close(int s)

{
  lwip_socket_multicast_pair *plVar1;
  uint is_tcp;
  err_t err;
  lwip_sock *sock;
  netconn *pnVar2;
  undefined3 extraout_var;
  int iVar3;
  ip_addr_t iStack40;
  ip_addr_t multi_addr;
  ip_addr_t if_addr;
  
  sock = get_socket(s);
  if (sock != (lwip_sock *)0x0) {
    is_tcp = 0;
    if (sock->conn != (netconn *)0x0) {
      is_tcp = (uint)((sock->conn->type & 0xf0) == NETCONN_TCP);
    }
    pnVar2 = (netconn *)get_socket(s);
    if (pnVar2 != (netconn *)0x0) {
      plVar1 = socket_ipv4_multicast_memberships;
      do {
        if (pnVar2 == ((lwip_sock *)plVar1)->conn) {
          iStack40 = (ip_addr_t)((ip_addr_t *)&((lwip_sock *)plVar1)->rcvevent)->addr;
          ((lwip_sock *)plVar1)->conn = (netconn *)0x0;
          *(undefined4 *)&((lwip_sock *)plVar1)->rcvevent = 0;
          multi_addr = ((ip_addr_t *)&((lwip_sock *)plVar1)->lastdata)->addr;
          ((lwip_sock *)plVar1)->lastdata = 0;
          netconn_join_leave_group(*(netconn **)&pnVar2->type,&iStack40,&multi_addr,NETCONN_LEAVE);
        }
        plVar1 = (lwip_socket_multicast_pair *)&((lwip_sock *)plVar1)->errevent;
      } while ((lwip_sock *)plVar1 != sockets);
    }
    err = netconn_prepare_delete(sock->conn);
    if (CONCAT31(extraout_var,err) == 0) {
      free_socket(sock,is_tcp);
      return 0;
    }
    iVar3 = err_to_errno(err);
    if (iVar3 != 0) {
      errno = iVar3;
    }
  }
  return -1;
}



// WARNING: Type propagation algorithm not settling

int lwip_connect(int s,sockaddr *name,socklen_t namelen)

{
  err_t err;
  u16_t port;
  lwip_sock *plVar1;
  undefined3 extraout_var;
  int iVar2;
  undefined3 extraout_var_00;
  ip_addr_t iStack20;
  ip_addr_t remote_addr;
  
  plVar1 = get_socket(s);
  if (plVar1 == (lwip_sock *)0x0) {
    return 0xffffffff;
  }
  if (name->sa_family == '\0') {
    err = netconn_disconnect(plVar1->conn);
    iVar2 = CONCAT31(extraout_var,err);
  }
  else {
    if (((namelen != 0x10) || (name->sa_family != '\x02')) || (((uint)name & 3) != 0)) {
      err = -0x10;
      goto LAB_2303b43e;
    }
    iStack20 = (ip_addr_t)((ip_addr_t *)(name->sa_data + 2))->addr;
    port = lwip_htons(*(u16_t *)name->sa_data);
    err = netconn_connect(plVar1->conn,&iStack20,port);
    iVar2 = CONCAT31(extraout_var_00,err);
  }
  err = (err_t)iVar2;
  if (iVar2 == 0) {
    return 0;
  }
LAB_2303b43e:
  iVar2 = err_to_errno(err);
  if (iVar2 != 0) {
    errno = iVar2;
  }
  return -1;
}



int lwip_listen(int s,int backlog)

{
  err_t err;
  lwip_sock *plVar1;
  undefined3 extraout_var;
  int iVar2;
  u8_t backlog_00;
  
  plVar1 = get_socket(s);
  if (plVar1 != (lwip_sock *)0x0) {
    if (backlog < 0) {
      backlog = 0;
    }
    backlog_00 = (u8_t)backlog;
    if (0xff < backlog) {
      backlog_00 = -1;
    }
    err = netconn_listen_with_backlog(plVar1->conn,backlog_00);
    if (CONCAT31(extraout_var,err) == 0) {
      return 0;
    }
    if ((plVar1->conn->type & 0xf0) == NETCONN_TCP) {
      iVar2 = err_to_errno(err);
      if (iVar2 != 0) {
        errno = iVar2;
      }
    }
    else {
      errno = 0x5f;
    }
  }
  return -1;
}



// WARNING: Could not reconcile some variable overlaps

ssize_t lwip_recvfrom(int s,void *mem,size_t len,int flags,sockaddr *from,socklen_t *fromlen)

{
  uint uVar1;
  err_t err;
  lwip_sock *sock;
  ssize_t sVar2;
  undefined3 extraout_var;
  int iVar3;
  socklen_t sVar4;
  u16_t uStack70;
  u16_t datagram_len;
  void *pvStack68;
  iovec vec;
  msghdr msg;
  
  sock = get_socket(s);
  if (sock != (lwip_sock *)0x0) {
    if ((sock->conn->type & 0xf0) == NETCONN_TCP) {
      sVar2 = lwip_recv_tcp(sock,mem,len,flags);
      if (from == (sockaddr *)0x0) {
        return sVar2;
      }
      if (fromlen == (socklen_t *)0x0) {
        return sVar2;
      }
      netconn_getaddr(sock->conn,(ip_addr_t *)&vec.iov_len,(u16_t *)&stack0xffffffbc,'\0');
      lwip_sock_make_addr((short)register0x00002008 - 0x3c,(sockaddr *)((uint)pvStack68 & 0xffff),
                          (socklen_t *)from);
      return sVar2;
    }
    uStack70 = 0;
    sVar4 = 0;
    if (fromlen != (socklen_t *)0x0) {
      sVar4 = *fromlen;
    }
    pvStack68 = mem;
    vec.iov_base = (void *)len;
    vec.iov_len = (size_t)from;
    err = lwip_recvfrom_udp_raw(sock,flags,(msghdr *)&vec.iov_len,&uStack70);
    if (CONCAT31(extraout_var,err) == 0) {
      uVar1 = (uint)uStack70;
      if (len < (uint)uStack70) {
        uVar1 = len;
      }
      if (fromlen == (socklen_t *)0x0) {
        return uVar1;
      }
      *fromlen = sVar4;
      return uVar1;
    }
    iVar3 = err_to_errno(err);
    if (iVar3 != 0) {
      errno = iVar3;
    }
  }
  return -1;
}



ssize_t lwip_read(int s,void *mem,size_t len)

{
  ssize_t sVar1;
  
  sVar1 = lwip_recvfrom(s,mem,len,0,(sockaddr *)0x0,(socklen_t *)0x0);
  return sVar1;
}



ssize_t lwip_recv(int s,void *mem,size_t len,int flags)

{
  ssize_t sVar1;
  
  sVar1 = lwip_recvfrom(s,mem,len,flags,(sockaddr *)0x0,(socklen_t *)0x0);
  return sVar1;
}



// WARNING: Could not reconcile some variable overlaps

ssize_t lwip_sendto(int s,void *data,size_t size,int flags,sockaddr *to,socklen_t tolen)

{
  err_t eVar1;
  lwip_sock *plVar2;
  ssize_t sVar3;
  int iVar4;
  void *pvVar5;
  undefined3 extraout_var;
  int iVar6;
  pbuf *ppStack52;
  netbuf buf;
  
  plVar2 = get_socket(s);
  if (plVar2 == (lwip_sock *)0x0) {
    return -1;
  }
  if ((plVar2->conn->type & 0xf0) == NETCONN_TCP) {
    sVar3 = lwip_send(s,data,size,flags);
    return sVar3;
  }
  if (0xffff < size) {
    errno = 0x5a;
    return -1;
  }
  if (to != (sockaddr *)0x0) {
    if ((tolen != 0x10) || (to->sa_family != '\x02')) goto LAB_2303b61c;
    tolen = (uint)to & 3;
  }
  if (tolen == 0) {
    buf.p = (pbuf *)0x0;
    ppStack52 = (pbuf *)0x0;
    buf.addr.addr._2_1_ = '\0';
    if (to == (sockaddr *)0x0) {
      buf.ptr = (pbuf *)0x0;
      buf.addr.addr._0_2_ = 0;
    }
    else {
      buf.ptr = *(pbuf **)(to->sa_data + 2);
      buf.addr.addr._0_2_ = lwip_htons(*(u16_t *)to->sa_data);
    }
    pvVar5 = netbuf_alloc((netbuf *)&ppStack52,(u16_t)size);
    iVar4 = -1;
    if (pvVar5 != (void *)0x0) {
      if ((plVar2->conn->type & 0xf0) == NETCONN_RAW) {
        memcpy(ppStack52->payload,data,size);
      }
      else {
        buf.port = lwip_chksum_copy(ppStack52->payload,data,(u16_t)size);
        buf.addr.addr._2_1_ = '\x02';
      }
      eVar1 = netconn_send(plVar2->conn,(netbuf *)&ppStack52);
      iVar4 = CONCAT31(extraout_var,eVar1);
    }
    netbuf_free((netbuf *)&ppStack52);
    iVar6 = err_to_errno((err_t)iVar4);
    if (iVar6 != 0) {
      errno = iVar6;
    }
    if (iVar4 != 0) {
      return -1;
    }
    return size;
  }
LAB_2303b61c:
  iVar4 = err_to_errno(-0x10);
  if (iVar4 != 0) {
    errno = iVar4;
  }
  return -1;
}



ssize_t lwip_send(int s,void *data,size_t size,int flags)

{
  err_t err;
  lwip_sock *plVar1;
  ssize_t sVar2;
  undefined3 extraout_var;
  int iVar3;
  byte bVar4;
  size_t sStack20;
  size_t written;
  
  plVar1 = get_socket(s);
  if (plVar1 != (lwip_sock *)0x0) {
    if ((plVar1->conn->type & 0xf0) != NETCONN_TCP) {
      sVar2 = lwip_sendto(s,data,size,flags,(sockaddr *)0x0,0);
      return sVar2;
    }
    bVar4 = 3;
    if ((flags & 0x10U) == 0) {
      bVar4 = 1;
    }
    sStack20 = 0;
    err = netconn_write_partly(plVar1->conn,data,size,bVar4 | (byte)(flags >> 1) & 4,&sStack20);
    iVar3 = err_to_errno(err);
    if (iVar3 != 0) {
      errno = iVar3;
    }
    if (CONCAT31(extraout_var,err) == 0) {
      return sStack20;
    }
  }
  return -1;
}



int lwip_socket(int domain,int type,int protocol)

{
  netconn_type t;
  netconn *newconn;
  int iVar1;
  u8_t proto;
  
  if (type == 2) {
    t = NETCONN_UDPLITE;
    if (protocol != 0x88) {
      t = NETCONN_UDP;
    }
    proto = '\0';
  }
  else {
    if (type == 3) {
      proto = (u8_t)protocol;
      t = NETCONN_RAW;
    }
    else {
      if (type != 1) {
        errno = 0x16;
        return -1;
      }
      proto = '\0';
      t = NETCONN_TCP;
    }
  }
  newconn = netconn_new_with_proto_and_callback(t,proto,event_callback);
  if (newconn == (netconn *)0x0) {
    errno = 0x69;
    return -1;
  }
  iVar1 = alloc_socket(newconn,0);
  if (iVar1 != -1) {
    newconn->socket = iVar1;
    return iVar1;
  }
  netconn_delete(newconn);
  errno = 0x17;
  return -1;
}



ssize_t lwip_write(int s,void *data,size_t size)

{
  ssize_t sVar1;
  
  sVar1 = lwip_send(s,data,size,0);
  return sVar1;
}



int lwip_select(int maxfdp1,_types_fd_set *readset,_types_fd_set *writeset,_types_fd_set *exceptset,
               timeval *timeout)

{
  uint uVar1;
  err_t eVar2;
  uint uVar3;
  undefined3 extraout_var;
  sys_prot_t sVar4;
  u8_t uVar5;
  u32_t timeout_00;
  lwip_sock *plVar6;
  uint uVar7;
  lwip_sock *plVar8;
  fd_mask local_7c;
  _types_fd_set lreadset;
  _types_fd_set lwriteset;
  _types_fd_set lexceptset;
  lwip_select_cb select_cb;
  
  if ((uint)maxfdp1 < 0x41) {
    uVar3 = lwip_selscan(maxfdp1,readset,writeset,exceptset,(_types_fd_set *)&local_7c,
                         (_types_fd_set *)(lreadset.fds_bits + 1),
                         (_types_fd_set *)(lwriteset.fds_bits + 1));
    if ((int)uVar3 < 0) {
      errno = 9;
    }
    else {
      uVar7 = uVar3;
      if ((uVar3 != 0) ||
         (((timeout != (timeval *)0x0 &&
           ((*(uint *)&timeout->tv_sec | *(uint *)((int)&timeout->tv_sec + 4)) == 0)) &&
          (uVar7 = timeout->tv_usec, uVar7 == 0)))) {
LAB_2303b9b6:
        if (readset != (_types_fd_set *)0x0) {
          readset->fds_bits[0] = local_7c;
          readset->fds_bits[1] = lreadset.fds_bits[0];
        }
        if (writeset != (_types_fd_set *)0x0) {
          writeset->fds_bits[0] = lreadset.fds_bits[1];
          writeset->fds_bits[1] = lwriteset.fds_bits[0];
        }
        if (exceptset == (_types_fd_set *)0x0) {
          return uVar7;
        }
        exceptset->fds_bits[0] = lwriteset.fds_bits[1];
        exceptset->fds_bits[1] = lexceptset.fds_bits[0];
        return uVar7;
      }
      memset(lexceptset.fds_bits + 1,0,0x24);
      select_cb.prev = (lwip_select_cb *)readset;
      select_cb.readset = writeset;
      select_cb.writeset = exceptset;
      eVar2 = sys_sem_new((sys_sem_t *)&select_cb.sem_signalled,'\0');
      if (CONCAT31(extraout_var,eVar2) == 0) {
        plVar6 = sockets;
        plVar8 = sockets;
        lwip_link_select_cb((lwip_select_cb *)(lexceptset.fds_bits + 1));
        uVar1 = 0;
        while (uVar1 != maxfdp1) {
          if ((((readset != (_types_fd_set *)0x0) &&
               ((1 << (uVar1 & 0x1f) & readset->fds_bits[uVar1 >> 5]) != 0)) ||
              ((writeset != (_types_fd_set *)0x0 &&
               ((1 << (uVar1 & 0x1f) & writeset->fds_bits[uVar1 >> 5]) != 0)))) ||
             ((exceptset != (_types_fd_set *)0x0 &&
              ((1 << (uVar1 & 0x1f) & exceptset->fds_bits[uVar1 >> 5]) != 0)))) {
            sys_arch_protect();
            if ((int)uVar1 < 0x15) {
              uVar5 = plVar8->select_waiting + '\x01';
              plVar8->select_waiting = uVar5;
              if (uVar5 != '\0') {
                sys_arch_unprotect();
                goto LAB_2303b9ec;
              }
              sockets[uVar1].select_waiting = -1;
              sys_arch_unprotect();
              errno = 0x10;
            }
            else {
              sys_arch_unprotect();
              errno = 9;
            }
            uVar7 = 0xffffffff;
            timeout_00 = 0;
            goto LAB_2303b986;
          }
LAB_2303b9ec:
          uVar1 = uVar1 + 1;
          plVar8 = plVar8 + 1;
        }
        uVar7 = lwip_selscan(maxfdp1,readset,writeset,exceptset,(_types_fd_set *)&local_7c,
                             (_types_fd_set *)(lreadset.fds_bits + 1),
                             (_types_fd_set *)(lwriteset.fds_bits + 1));
        timeout_00 = 0;
        if (uVar7 == 0) {
          timeout_00 = 0;
          if ((timeout != (timeval *)0x0) &&
             (timeout_00 = *(int *)&timeout->tv_sec * 1000 + (timeout->tv_usec + 500) / 1000,
             (int)timeout_00 < 1)) {
            timeout_00 = 1;
          }
          timeout_00 = sys_arch_sem_wait((sys_sem_t *)&select_cb.sem_signalled,timeout_00);
          uVar1 = maxfdp1;
        }
LAB_2303b986:
        while (uVar3 != uVar1) {
          if ((((readset != (_types_fd_set *)0x0) &&
               ((1 << (uVar3 & 0x1f) & readset->fds_bits[uVar3 >> 5]) != 0)) ||
              ((writeset != (_types_fd_set *)0x0 &&
               ((1 << (uVar3 & 0x1f) & writeset->fds_bits[uVar3 >> 5]) != 0)))) ||
             ((exceptset != (_types_fd_set *)0x0 &&
              ((1 << (uVar3 & 0x1f) & exceptset->fds_bits[uVar3 >> 5]) != 0)))) {
            sVar4 = sys_arch_protect();
            if ((int)uVar3 < 0x15) {
              if (plVar6->select_waiting != '\0') {
                plVar6->select_waiting = plVar6->select_waiting + -1;
              }
              sys_arch_unprotect(sVar4);
            }
            else {
              sys_arch_unprotect(sVar4);
              uVar7 = 0xffffffff;
              errno = 9;
            }
          }
          uVar3 = uVar3 + 1;
          plVar6 = plVar6 + 1;
        }
        lwip_unlink_select_cb((lwip_select_cb *)(lexceptset.fds_bits + 1));
        sys_sem_free((sys_sem_t *)&select_cb.sem_signalled);
        if (-1 < (int)uVar7) {
          if (timeout_00 != 0xffffffff) {
            uVar7 = lwip_selscan(maxfdp1,readset,writeset,exceptset,(_types_fd_set *)&local_7c,
                                 (_types_fd_set *)(lreadset.fds_bits + 1),
                                 (_types_fd_set *)(lwriteset.fds_bits + 1));
          }
          goto LAB_2303b9b6;
        }
      }
      else {
        errno = 0xc;
      }
    }
  }
  else {
    errno = 0x16;
  }
  return -1;
}



int lwip_shutdown(int s,int how)

{
  err_t err;
  lwip_sock *plVar1;
  netconn *conn;
  undefined3 extraout_var;
  int iVar2;
  u8_t shut_tx;
  u8_t shut_rx;
  
  plVar1 = get_socket(s);
  if (plVar1 != (lwip_sock *)0x0) {
    conn = plVar1->conn;
    if (conn == (netconn *)0x0) {
      errno = 0x6b;
    }
    else {
      if ((conn->type & 0xf0) == NETCONN_TCP) {
        if (how == 0) {
          shut_tx = '\0';
          shut_rx = '\x01';
        }
        else {
          shut_rx = '\x01';
          if (how == 1) {
            shut_tx = '\x01';
            shut_rx = '\0';
          }
          else {
            shut_tx = '\x01';
            if (how != 2) {
              errno = 0x16;
              return -1;
            }
          }
        }
        err = netconn_shutdown(conn,shut_rx,shut_tx);
        iVar2 = err_to_errno(err);
        if (iVar2 != 0) {
          errno = iVar2;
        }
        return -(uint)(CONCAT31(extraout_var,err) != 0);
      }
      errno = 0x5f;
    }
  }
  return -1;
}



int lwip_setsockopt(int s,int level,int optname,void *optval,socklen_t optlen)

{
  err_t err;
  lwip_sock *plVar1;
  undefined3 extraout_var;
  socklen_t sVar2;
  int iStack44;
  lwip_setgetsockopt_data data;
  
  plVar1 = get_socket(s);
  sVar2 = errno;
  if (plVar1 != (lwip_sock *)0x0) {
    if (optval == (void *)0x0) {
      errno = 0xe;
      sVar2 = errno;
    }
    else {
      data.optlen = 0;
      data.err = (int)&plVar1->conn->op_completed;
      iStack44 = s;
      data.s = level;
      data.level = optname;
      data.optname = (int)optval;
      data.optval = optlen;
      err = tcpip_callback(lwip_setsockopt_callback,&iStack44);
      if (CONCAT31(extraout_var,err) == 0) {
        sys_arch_sem_wait((sys_sem_t *)data.err,0);
        sVar2 = data.optlen;
        if (data.optlen == 0) {
          return 0;
        }
      }
      else {
        sVar2 = err_to_errno(err);
        if (sVar2 == 0) {
          return -1;
        }
      }
    }
  }
  errno = sVar2;
  return -1;
}



int lwip_fcntl(int s,int cmd,int val)

{
  ushort uVar1;
  uint uVar2;
  lwip_sock *plVar3;
  byte bVar4;
  int iVar5;
  
  plVar3 = get_socket(s);
  if (plVar3 != (lwip_sock *)0x0) {
    if (cmd == 3) {
      uVar2 = 6;
      bVar4 = plVar3->conn->flags;
      if ((plVar3->conn->type & 0xf0) == NETCONN_TCP) {
        sys_arch_protect();
        uVar2 = 0;
        iVar5 = plVar3->conn->pcb;
        if ((iVar5 != 0) &&
           (uVar1 = *(ushort *)(iVar5 + 0x1a), uVar2 = (uint)((uVar1 & 0x10) == 0) << 1,
           (uVar1 & 0x20) == 0)) {
          uVar2 = uVar2 | 4;
        }
        sys_arch_unprotect();
      }
      return uVar2 | (int)(uint)bVar4 >> 1 & 1U;
    }
    if ((cmd == 4) && ((val & 0xfffffff8U) == 0)) {
      bVar4 = plVar3->conn->flags;
      if ((val & 1U) == 0) {
        bVar4 = bVar4 & 0xfd;
      }
      else {
        bVar4 = bVar4 | 2;
      }
      plVar3->conn->flags = bVar4;
      return 0;
    }
    errno = 0x26;
  }
  return -1;
}



void tcpip_thread(void *arg)

{
  byte *mem;
  undefined uVar1;
  memp_t type;
  u32_t timeout;
  int iVar2;
  undefined *puVar3;
  byte *pbStack36;
  tcpip_msg *msg;
  
  if (tcpip_init_done != (tcpip_init_done_fn)0x0) {
    (*tcpip_init_done)(tcpip_init_done_arg);
  }
switchD_2303bc70_caseD_5:
  do {
    while (timeout = sys_timeouts_sleeptime(), timeout != 0xffffffff) {
      if ((timeout != 0) &&
         (timeout = sys_arch_mbox_fetch(&tcpip_mbox,&pbStack36,timeout), timeout != 0xffffffff))
      goto LAB_2303bc5e;
      sys_check_timeouts();
    }
    sys_arch_mbox_fetch(&tcpip_mbox,&pbStack36,0);
LAB_2303bc5e:
    mem = pbStack36;
  } while (pbStack36 == (byte *)0x0);
  switch(*pbStack36) {
  case 0:
  case 4:
    (**(code **)(pbStack36 + 4))(*(undefined4 *)(pbStack36 + 8),*(code **)(pbStack36 + 4));
    goto switchD_2303bc70_caseD_5;
  case 1:
    puVar3 = *(undefined **)(pbStack36 + 8);
    uVar1 = (**(code **)(pbStack36 + 4))(puVar3,*(code **)(pbStack36 + 4));
    *puVar3 = uVar1;
    sys_sem_signal((sys_mutex_t *)*(sys_mutex_t *)(mem + 0xc));
    goto switchD_2303bc70_caseD_5;
  case 2:
    iVar2 = (**(code **)(pbStack36 + 0xc))
                      (*(undefined4 *)(pbStack36 + 4),*(undefined4 *)(pbStack36 + 8),
                       *(code **)(pbStack36 + 0xc));
    if (iVar2 != 0) {
      pbuf_free(*(pbuf **)(mem + 4));
    }
    type = MEMP_TCPIP_MSG_INPKT;
    break;
  case 3:
    (**(code **)(pbStack36 + 4))(*(undefined4 *)(pbStack36 + 8),*(code **)(pbStack36 + 4));
    type = MEMP_TCPIP_MSG_API;
    break;
  default:
    goto switchD_2303bc70_caseD_5;
  }
  memp_free(type,mem);
  goto switchD_2303bc70_caseD_5;
}



err_t tcpip_inpkt(pbuf *p,netif *inp,netif_input_fn *input_fn)

{
  err_t eVar1;
  undefined *msg;
  undefined3 extraout_var;
  
  sys_mbox_valid(&tcpip_mbox);
  msg = (undefined *)memp_malloc(MEMP_TCPIP_MSG_INPKT);
  if (msg == (undefined *)0x0) {
    printf("[LWIP] NO TCP MSG\r\n");
  }
  else {
    *(netif **)(msg + 8) = inp;
    *msg = 2;
    *(pbuf **)(msg + 4) = p;
    *(netif_input_fn **)(msg + 0xc) = input_fn;
    eVar1 = sys_mbox_trypost(&tcpip_mbox,msg);
    if (CONCAT31(extraout_var,eVar1) == 0) {
      return eVar1;
    }
    printf("[LWIP] NO MBOX\r\n");
    memp_free(MEMP_TCPIP_MSG_INPKT,msg);
  }
  return -1;
}



err_t tcpip_input(pbuf *p,netif *inp)

{
  err_t eVar1;
  code *input_fn;
  
  if ((inp->flags & 0x18) == 0) {
    input_fn = ip4_input;
  }
  else {
    input_fn = ethernet_input;
  }
  eVar1 = tcpip_inpkt(p,inp,input_fn);
  return eVar1;
}



err_t tcpip_callback(tcpip_callback_fn function,void *ctx)

{
  err_t eVar1;
  undefined *data;
  
  sys_mbox_valid(&tcpip_mbox);
  data = (undefined *)memp_malloc(MEMP_TCPIP_MSG_API);
  if (data == (undefined *)0x0) {
    eVar1 = -1;
  }
  else {
    *data = 3;
    *(void **)(data + 8) = ctx;
    *(tcpip_callback_fn *)(data + 4) = function;
    sys_mbox_post(&tcpip_mbox,data);
    eVar1 = '\0';
  }
  return eVar1;
}



err_t tcpip_try_callback(tcpip_callback_fn function,void *ctx)

{
  err_t eVar1;
  undefined *msg;
  undefined3 extraout_var;
  
  sys_mbox_valid(&tcpip_mbox);
  msg = (undefined *)memp_malloc(MEMP_TCPIP_MSG_API);
  if (msg != (undefined *)0x0) {
    *(void **)(msg + 8) = ctx;
    *msg = 3;
    *(tcpip_callback_fn *)(msg + 4) = function;
    eVar1 = sys_mbox_trypost(&tcpip_mbox,msg);
    if (CONCAT31(extraout_var,eVar1) == 0) {
      return eVar1;
    }
    memp_free(MEMP_TCPIP_MSG_API,msg);
  }
  return -1;
}



// WARNING: Could not reconcile some variable overlaps

err_t tcpip_send_msg_wait_sem(tcpip_callback_fn fn,void *apimsg,sys_sem_t *sem)

{
  undefined auStack32 [4];
  tcpip_msg msg;
  
  sys_sem_valid(sem);
  sys_mbox_valid(&tcpip_mbox);
  auStack32[0] = 0;
  msg._0_4_ = fn;
  msg.msg._0_4_ = apimsg;
  sys_mbox_post(&tcpip_mbox,auStack32);
  sys_arch_sem_wait(sem,0);
  return '\0';
}



// WARNING: Could not reconcile some variable overlaps

err_t tcpip_api_call(tcpip_api_call_fn *fn,tcpip_api_call_data *call)

{
  sys_sem_t *sem;
  err_t eVar1;
  undefined3 extraout_var;
  undefined local_30 [4];
  tcpip_msg msg;
  
  sem = &call->sem;
  eVar1 = sys_sem_new(sem,'\0');
  if (CONCAT31(extraout_var,eVar1) == 0) {
    sys_mbox_valid(&tcpip_mbox);
    local_30[0] = 1;
    msg._0_4_ = fn;
    msg.msg._0_4_ = call;
    msg.msg._4_4_ = sem;
    sys_mbox_post(&tcpip_mbox,local_30);
    sys_arch_sem_wait(msg.msg._4_4_,0);
    sys_sem_free(sem);
    eVar1 = call->err;
  }
  return eVar1;
}



void tcpip_init(tcpip_init_done_fn initfunc,void *arg)

{
  lwip_init();
  tcpip_init_done = initfunc;
  tcpip_init_done_arg = arg;
  sys_mbox_new(&tcpip_mbox,0x32);
  sys_thread_new("TCP/IP",tcpip_thread,(void *)0x0,4000,0x1e);
  return;
}



altcp_pcb * altcp_alloc(void)

{
  altcp_pcb *__s;
  
  __s = (altcp_pcb *)memp_malloc(MEMP_ALTCP_PCB);
  if (__s != (altcp_pcb *)0x0) {
    memset(__s,0,0x2c);
  }
  return __s;
}



void altcp_free(altcp_pcb *conn)

{
  altcp_dealloc_fn paVar1;
  
  if (conn == (altcp_pcb *)0x0) {
    return;
  }
  if ((conn->fns != (altcp_functions *)0x0) &&
     (paVar1 = conn->fns->dealloc, paVar1 != (altcp_dealloc_fn)0x0)) {
    (*paVar1)(conn);
  }
  memp_free(MEMP_ALTCP_PCB,conn);
  return;
}



// WARNING: Exceeded maximum restarts with more pending

altcp_pcb * altcp_new_ip_type(altcp_allocator_t *allocator,u8_t ip_type)

{
  altcp_pcb *paVar1;
  
  if (allocator == (altcp_allocator_t *)0x0) {
    paVar1 = altcp_tcp_new_ip_type(ip_type);
    return paVar1;
  }
  if (allocator->alloc != (altcp_new_fn *)0x0) {
                    // WARNING: Could not recover jumptable at 0x2303bf52. Too many branches
                    // WARNING: Treating indirect jump as call
    paVar1 = (*allocator->alloc)(allocator->arg);
    return paVar1;
  }
  return (altcp_pcb *)0x0;
}



altcp_pcb * altcp_new(altcp_allocator_t *allocator)

{
  altcp_pcb *paVar1;
  
  paVar1 = altcp_new_ip_type(allocator,'\0');
  return paVar1;
}



void altcp_arg(altcp_pcb *conn,void *arg)

{
  if (conn != (altcp_pcb *)0x0) {
    conn->arg = arg;
  }
  return;
}



void altcp_recv(altcp_pcb *conn,altcp_recv_fn *recv)

{
  if (conn != (altcp_pcb *)0x0) {
    conn->recv = recv;
  }
  return;
}



void altcp_sent(altcp_pcb *conn,altcp_sent_fn *sent)

{
  if (conn != (altcp_pcb *)0x0) {
    conn->sent = sent;
  }
  return;
}



// WARNING: Exceeded maximum restarts with more pending

void altcp_poll(altcp_pcb *conn,altcp_poll_fn *poll,u8_t interval)

{
  altcp_set_poll_fn UNRECOVERED_JUMPTABLE;
  undefined3 in_register_00002031;
  
  if (conn != (altcp_pcb *)0x0) {
    conn->poll = poll;
    conn->pollinterval = interval;
    if ((conn->fns != (altcp_functions *)0x0) &&
       (UNRECOVERED_JUMPTABLE = conn->fns->set_poll, UNRECOVERED_JUMPTABLE != (altcp_set_poll_fn)0x0
       )) {
                    // WARNING: Could not recover jumptable at 0x2303bf86. Too many branches
                    // WARNING: Treating indirect jump as call
      (*UNRECOVERED_JUMPTABLE)((altcp_pcb *)CONCAT31(in_register_00002031,interval));
      return;
    }
  }
  return;
}



void altcp_err(altcp_pcb *conn,altcp_err_fn *err)

{
  if (conn != (altcp_pcb *)0x0) {
    conn->err = err;
  }
  return;
}



// WARNING: Exceeded maximum restarts with more pending

void altcp_recved(altcp_pcb *conn,u16_t len)

{
  altcp_recved_fn *UNRECOVERED_JUMPTABLE;
  
  if (((conn != (altcp_pcb *)0x0) && (conn->fns != (altcp_functions *)0x0)) &&
     (UNRECOVERED_JUMPTABLE = conn->fns->recved, UNRECOVERED_JUMPTABLE != (altcp_recved_fn *)0x0)) {
                    // WARNING: Could not recover jumptable at 0x2303bf9e. Too many branches
                    // WARNING: Treating indirect jump as call
    (*UNRECOVERED_JUMPTABLE)();
    return;
  }
  return;
}



// WARNING: Exceeded maximum restarts with more pending

err_t altcp_connect(altcp_pcb *conn,ip_addr_t *ipaddr,u16_t port,altcp_connected_fn connected)

{
  altcp_connect_fn *UNRECOVERED_JUMPTABLE;
  err_t eVar1;
  
  if (((conn != (altcp_pcb *)0x0) && (conn->fns != (altcp_functions *)0x0)) &&
     (UNRECOVERED_JUMPTABLE = conn->fns->connect, UNRECOVERED_JUMPTABLE != (altcp_connect_fn *)0x0))
  {
                    // WARNING: Could not recover jumptable at 0x2303bfb0. Too many branches
                    // WARNING: Treating indirect jump as call
    eVar1 = (*UNRECOVERED_JUMPTABLE)();
    return eVar1;
  }
  return -6;
}



// WARNING: Exceeded maximum restarts with more pending

void altcp_abort(altcp_pcb *conn)

{
  altcp_abort_fn UNRECOVERED_JUMPTABLE;
  
  if (((conn != (altcp_pcb *)0x0) && (conn->fns != (altcp_functions *)0x0)) &&
     (UNRECOVERED_JUMPTABLE = conn->fns->abort, UNRECOVERED_JUMPTABLE != (altcp_abort_fn)0x0)) {
                    // WARNING: Could not recover jumptable at 0x2303bfc4. Too many branches
                    // WARNING: Treating indirect jump as call
    (*UNRECOVERED_JUMPTABLE)();
    return;
  }
  return;
}



// WARNING: Exceeded maximum restarts with more pending

err_t altcp_close(altcp_pcb *conn)

{
  altcp_close_fn UNRECOVERED_JUMPTABLE;
  err_t eVar1;
  
  if (((conn != (altcp_pcb *)0x0) && (conn->fns != (altcp_functions *)0x0)) &&
     (UNRECOVERED_JUMPTABLE = conn->fns->close, UNRECOVERED_JUMPTABLE != (altcp_close_fn)0x0)) {
                    // WARNING: Could not recover jumptable at 0x2303bfd6. Too many branches
                    // WARNING: Treating indirect jump as call
    eVar1 = (*UNRECOVERED_JUMPTABLE)();
    return eVar1;
  }
  return -6;
}



// WARNING: Exceeded maximum restarts with more pending

err_t altcp_write(altcp_pcb *conn,void *dataptr,u16_t len,u8_t apiflags)

{
  altcp_write_fn *UNRECOVERED_JUMPTABLE;
  err_t eVar1;
  
  if (((conn != (altcp_pcb *)0x0) && (conn->fns != (altcp_functions *)0x0)) &&
     (UNRECOVERED_JUMPTABLE = conn->fns->write, UNRECOVERED_JUMPTABLE != (altcp_write_fn *)0x0)) {
                    // WARNING: Could not recover jumptable at 0x2303bfea. Too many branches
                    // WARNING: Treating indirect jump as call
    eVar1 = (*UNRECOVERED_JUMPTABLE)();
    return eVar1;
  }
  return -6;
}



// WARNING: Exceeded maximum restarts with more pending

err_t altcp_output(altcp_pcb *conn)

{
  altcp_output_fn UNRECOVERED_JUMPTABLE;
  err_t eVar1;
  
  if (((conn != (altcp_pcb *)0x0) && (conn->fns != (altcp_functions *)0x0)) &&
     (UNRECOVERED_JUMPTABLE = conn->fns->output, UNRECOVERED_JUMPTABLE != (altcp_output_fn)0x0)) {
                    // WARNING: Could not recover jumptable at 0x2303bffe. Too many branches
                    // WARNING: Treating indirect jump as call
    eVar1 = (*UNRECOVERED_JUMPTABLE)();
    return eVar1;
  }
  return -6;
}



err_t altcp_tcp_connected(void *arg,tcp_pcb *tpcb,err_t err)

{
  err_t eVar1;
  
  if ((arg != (void *)0x0) && (*(code **)((int)arg + 0x14) != (code *)0x0)) {
                    // WARNING: Could not recover jumptable at 0x2303c012. Too many branches
                    // WARNING: Treating indirect jump as call
    eVar1 = (**(code **)((int)arg + 0x14))(*(undefined4 *)((int)arg + 8),arg);
    return eVar1;
  }
  return '\0';
}



err_t altcp_tcp_sent(void *arg,tcp_pcb *tpcb,u16_t len)

{
  err_t eVar1;
  
  if ((arg != (void *)0x0) && (*(code **)((int)arg + 0x1c) != (code *)0x0)) {
                    // WARNING: Could not recover jumptable at 0x2303c026. Too many branches
                    // WARNING: Treating indirect jump as call
    eVar1 = (**(code **)((int)arg + 0x1c))(*(undefined4 *)((int)arg + 8),arg);
    return eVar1;
  }
  return '\0';
}



err_t altcp_tcp_poll(void *arg,tcp_pcb *tpcb)

{
  err_t eVar1;
  
  if ((arg != (void *)0x0) && (*(code **)((int)arg + 0x20) != (code *)0x0)) {
                    // WARNING: Could not recover jumptable at 0x2303c03a. Too many branches
                    // WARNING: Treating indirect jump as call
    eVar1 = (**(code **)((int)arg + 0x20))(*(undefined4 *)((int)arg + 8),arg);
    return eVar1;
  }
  return '\0';
}



u16_t altcp_tcp_mss(altcp_pcb *conn)

{
  if (conn != (altcp_pcb *)0x0) {
    return *(u16_t *)((int)conn->state + 0x32);
  }
  return 0;
}



u16_t altcp_tcp_sndbuf(altcp_pcb *conn)

{
  if (conn != (altcp_pcb *)0x0) {
    return *(u16_t *)((int)conn->state + 100);
  }
  return 0;
}



u16_t altcp_tcp_sndqueuelen(altcp_pcb *conn)

{
  if (conn != (altcp_pcb *)0x0) {
    return *(u16_t *)((int)conn->state + 0x66);
  }
  return 0;
}



void altcp_tcp_nagle_disable(altcp_pcb *conn)

{
  void *pvVar1;
  
  if ((conn != (altcp_pcb *)0x0) && (pvVar1 = conn->state, pvVar1 != (void *)0x0)) {
    *(ushort *)((int)pvVar1 + 0x1a) = *(ushort *)((int)pvVar1 + 0x1a) | 0x40;
  }
  return;
}



void altcp_tcp_nagle_enable(altcp_pcb *conn)

{
  void *pvVar1;
  
  if ((conn != (altcp_pcb *)0x0) && (pvVar1 = conn->state, pvVar1 != (void *)0x0)) {
    *(ushort *)((int)pvVar1 + 0x1a) = *(ushort *)((int)pvVar1 + 0x1a) & 0xffbf;
  }
  return;
}



int altcp_tcp_nagle_disabled(altcp_pcb *conn)

{
  if ((conn != (altcp_pcb *)0x0) && (conn->state != (void *)0x0)) {
    return (uint)(*(ushort *)((int)conn->state + 0x1a) >> 6) & 1;
  }
  return 0;
}



void altcp_tcp_dealloc(altcp_pcb *conn)

{
  return;
}



ip_addr_t * altcp_tcp_get_ip(altcp_pcb *conn,int local)

{
  if (((conn != (altcp_pcb *)0x0) && (conn = (altcp_pcb *)conn->state, conn != (altcp_pcb *)0x0)) &&
     (local == 0)) {
    conn = (altcp_pcb *)&conn->inner_conn;
  }
  return (ip_addr_t *)conn;
}



u16_t altcp_tcp_get_port(altcp_pcb *conn,int local)

{
  void *pvVar1;
  
  if ((conn != (altcp_pcb *)0x0) && (pvVar1 = conn->state, pvVar1 != (void *)0x0)) {
    if (local == 0) {
      return *(u16_t *)((int)pvVar1 + 0x18);
    }
    return *(u16_t *)((int)pvVar1 + 0x16);
  }
  return 0;
}



void altcp_tcp_setup_callbacks(altcp_pcb *conn,tcp_pcb *tpcb)

{
  tcp_arg(tpcb,conn);
  tcp_recv(tpcb,altcp_tcp_recv);
  tcp_sent(tpcb,altcp_tcp_sent);
  tcp_err(tpcb,altcp_tcp_err);
  return;
}



void altcp_tcp_err(void *arg,err_t err)

{
  if (arg != (void *)0x0) {
    *(undefined4 *)((int)arg + 0xc) = 0;
    if (*(code **)((int)arg + 0x24) != (code *)0x0) {
      (**(code **)((int)arg + 0x24))(*(undefined4 *)((int)arg + 8));
    }
    altcp_free((altcp_pcb *)arg);
    return;
  }
  return;
}



err_t altcp_tcp_get_tcp_addrinfo(altcp_pcb *conn,int local,ip_addr_t *addr,u16_t *port)

{
  err_t eVar1;
  
  if (conn != (altcp_pcb *)0x0) {
    eVar1 = tcp_tcp_get_tcp_addrinfo((tcp_pcb *)conn->state,local,addr,port);
    return eVar1;
  }
  return -6;
}



void altcp_tcp_setprio(altcp_pcb *conn,u8_t prio)

{
  if (conn != (altcp_pcb *)0x0) {
    tcp_setprio((tcp_pcb *)conn->state,prio);
    return;
  }
  return;
}



err_t altcp_tcp_output(altcp_pcb *conn)

{
  err_t eVar1;
  
  if (conn != (altcp_pcb *)0x0) {
    eVar1 = tcp_output((tcp_pcb *)conn->state);
    return eVar1;
  }
  return -6;
}



err_t altcp_tcp_write(altcp_pcb *conn,void *dataptr,u16_t len,u8_t apiflags)

{
  err_t eVar1;
  
  if (conn != (altcp_pcb *)0x0) {
    eVar1 = tcp_write((tcp_pcb *)conn->state,dataptr,len,apiflags);
    return eVar1;
  }
  return -6;
}



err_t altcp_tcp_shutdown(altcp_pcb *conn,int shut_rx,int shut_tx)

{
  err_t eVar1;
  
  if (conn != (altcp_pcb *)0x0) {
    eVar1 = tcp_shutdown((tcp_pcb *)conn->state,shut_rx,shut_tx);
    return eVar1;
  }
  return -6;
}



err_t altcp_tcp_close(altcp_pcb *conn)

{
  tcp_pcb *pcb;
  err_t eVar1;
  undefined3 extraout_var;
  tcp_poll_fn *poll;
  
  eVar1 = -6;
  if (conn != (altcp_pcb *)0x0) {
    pcb = (tcp_pcb *)conn->state;
    if (pcb != (tcp_pcb *)0x0) {
      poll = pcb->poll;
      tcp_arg(pcb,(void *)0x0);
      tcp_recv(pcb,(tcp_recv_fn *)0x0);
      tcp_sent(pcb,(tcp_sent_fn *)0x0);
      tcp_err(pcb,(tcp_err_fn *)0x0);
      tcp_poll(pcb,(tcp_poll_fn *)0x0,pcb->pollinterval);
      eVar1 = tcp_close(pcb);
      if (CONCAT31(extraout_var,eVar1) != 0) {
        altcp_tcp_setup_callbacks(conn,pcb);
        tcp_poll(pcb,poll,pcb->pollinterval);
        return eVar1;
      }
      conn->state = (void *)0x0;
    }
    altcp_free(conn);
    eVar1 = '\0';
  }
  return eVar1;
}



void altcp_tcp_abort(altcp_pcb *conn)

{
  if ((conn != (altcp_pcb *)0x0) && ((tcp_pcb *)conn->state != (tcp_pcb *)0x0)) {
    tcp_abort((tcp_pcb *)conn->state);
    return;
  }
  return;
}



altcp_pcb * altcp_tcp_listen(altcp_pcb *conn,u8_t backlog,err_t *err)

{
  tcp_pcb *pcb;
  
  if ((conn == (altcp_pcb *)0x0) ||
     (pcb = tcp_listen_with_backlog_and_err((tcp_pcb *)conn->state,backlog,err),
     pcb == (tcp_pcb *)0x0)) {
    conn = (altcp_pcb *)0x0;
  }
  else {
    *(tcp_pcb **)&conn->state = pcb;
    tcp_accept(pcb,altcp_tcp_accept);
  }
  return conn;
}



err_t altcp_tcp_connect(altcp_pcb *conn,ip_addr_t *ipaddr,u16_t port,altcp_connected_fn connected)

{
  err_t eVar1;
  
  if (conn != (altcp_pcb *)0x0) {
    conn->connected = connected;
    eVar1 = tcp_connect((tcp_pcb *)conn->state,ipaddr,port,altcp_tcp_connected);
    return eVar1;
  }
  return -6;
}



err_t altcp_tcp_bind(altcp_pcb *conn,ip_addr_t *ipaddr,u16_t port)

{
  err_t eVar1;
  
  if (conn != (altcp_pcb *)0x0) {
    eVar1 = tcp_bind((tcp_pcb *)conn->state,ipaddr,port);
    return eVar1;
  }
  return -6;
}



void altcp_tcp_recved(altcp_pcb *conn,u16_t len)

{
  if (conn != (altcp_pcb *)0x0) {
    tcp_recved((tcp_pcb *)conn->state,len);
    return;
  }
  return;
}



err_t altcp_tcp_recv(void *arg,tcp_pcb *tpcb,pbuf *p,err_t err)

{
  err_t eVar1;
  
  if ((arg != (void *)0x0) && (*(code **)((int)arg + 0x18) != (code *)0x0)) {
                    // WARNING: Could not recover jumptable at 0x2303c266. Too many branches
                    // WARNING: Treating indirect jump as call
    eVar1 = (**(code **)((int)arg + 0x18))(*(undefined4 *)((int)arg + 8));
    return eVar1;
  }
  if (p != (pbuf *)0x0) {
    pbuf_free(p);
    return '\0';
  }
  return '\0';
}



void altcp_tcp_set_poll(altcp_pcb *conn,u8_t interval)

{
  if (conn != (altcp_pcb *)0x0) {
    tcp_poll((tcp_pcb *)conn->state,altcp_tcp_poll,interval);
    return;
  }
  return;
}



err_t altcp_tcp_accept(void *arg,tcp_pcb *new_tpcb,err_t err)

{
  err_t eVar1;
  altcp_pcb *conn;
  undefined3 in_register_00002031;
  
  if ((arg != (void *)0x0) && (*(int *)((int)arg + 0x10) != 0)) {
    conn = altcp_alloc();
    if (conn != (altcp_pcb *)0x0) {
      altcp_tcp_setup_callbacks(conn,new_tpcb);
      *(tcp_pcb **)&conn->state = new_tpcb;
      conn->fns = (altcp_functions *)0x230861a8;
                    // WARNING: Could not recover jumptable at 0x2303c2dc. Too many branches
                    // WARNING: Treating indirect jump as call
      eVar1 = (**(code **)((int)arg + 0x10))
                        (*(undefined4 *)((int)arg + 8),conn,CONCAT31(in_register_00002031,err));
      return eVar1;
    }
    return -1;
  }
  return -0x10;
}



altcp_pcb * altcp_tcp_new_ip_type(u8_t ip_type)

{
  altcp_pcb *conn;
  tcp_pcb *pcb;
  
  pcb = tcp_new_ip_type(ip_type);
  conn = (altcp_pcb *)0x0;
  if (pcb != (tcp_pcb *)0x0) {
    conn = altcp_alloc();
    if (conn == (altcp_pcb *)0x0) {
      tcp_close(pcb);
    }
    else {
      altcp_tcp_setup_callbacks(conn,pcb);
      *(tcp_pcb **)&conn->state = pcb;
      conn->fns = (altcp_functions *)0x230861a8;
    }
  }
  return conn;
}



u16_t lwip_htons(u16_t n)

{
  undefined2 in_register_0000202a;
  
  return (u16_t)((ushort)(CONCAT22(in_register_0000202a,n) >> 8) | n << 8);
}



u32_t lwip_htonl(u32_t n)

{
  return n >> 8 & 0xff00 | n << 0x18 | n >> 0x18 | (n & 0xff00) << 8;
}



int lwip_strnicmp(char *str1,char *str2,size_t len)

{
  byte bVar1;
  int iVar2;
  
  iVar2 = 0;
  while( true ) {
    bVar1 = str1[iVar2];
    if ((bVar1 != str2[iVar2]) &&
       ((0x19 < (byte)((bVar1 | 0x20) + 0x9f) ||
        ((byte)(bVar1 | 0x20) != (byte)(str2[iVar2] | 0x20U))))) break;
    if ((len - 1 == iVar2) || (iVar2 = iVar2 + 1, bVar1 == 0)) {
      return 0;
    }
  }
  return 1;
}



void dns_call_found(u8_t idx,ip_addr_t *addr)

{
  undefined3 in_register_00002029;
  int iVar1;
  
  iVar1 = CONCAT31(in_register_00002029,idx);
  if (dns_requests[iVar1].found != (dns_found_callback *)0x0) {
    (*dns_requests[iVar1].found)(dns_table[iVar1].name,addr,dns_requests[iVar1].arg);
  }
  dns_requests[iVar1].found = (dns_found_callback *)0x0;
  return;
}



// WARNING: Variable defined which should be unmapped: hdr

err_t dns_send(u8_t idx)

{
  u8_t *dataptr;
  u8_t *puVar1;
  err_t eVar2;
  undefined3 in_register_00002029;
  int iVar3;
  size_t sVar4;
  pbuf *buf;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  undefined4 local_40;
  dns_query qry;
  dns_hdr hdr;
  
  iVar3 = CONCAT31(in_register_00002029,idx);
  if (dns_servers[dns_table[iVar3].server_idx].addr == 0) {
    dns_call_found(idx,(ip_addr_t *)0x0);
    eVar2 = '\0';
    dns_table[iVar3].state = '\0';
  }
  else {
    sVar4 = strlen(dns_table[iVar3].name);
    buf = pbuf_alloc(PBUF_TRANSPORT,(u16_t)((sVar4 + 0x12) * 0x10000 >> 0x10),PBUF_RAM);
    eVar2 = -1;
    if (buf != (pbuf *)0x0) {
      memset(&qry,0,0xc);
      qry.type = lwip_htons(dns_table[iVar3].txid);
      qry.cls._0_1_ = 1;
      puVar1 = &dns_table[iVar3].seqno;
      pbuf_take(buf,&qry,0xc);
      uVar6 = 0xc;
      do {
        dataptr = puVar1 + 1;
        uVar5 = 0;
        puVar1 = dataptr;
        while ((*puVar1 != '.' && (*puVar1 != '\0'))) {
          uVar5 = uVar5 + 1 & 0xff;
          puVar1 = puVar1 + 1;
        }
        if (0xfffe < uVar6 + uVar5) {
          pbuf_free(buf);
          return -6;
        }
        pbuf_put_at(buf,(u16_t)uVar6,(u8_t)uVar5);
        pbuf_take_at(buf,dataptr,(u16_t)((uint)((int)(puVar1 + -(int)dataptr) * 0x10000) >> 0x10),
                     (u16_t)((uVar6 + 1) * 0x10000 >> 0x10));
        uVar7 = uVar6 + uVar5 & 0xffff;
        uVar5 = uVar7 + 1;
        uVar6 = uVar5 & 0xffff;
      } while (*puVar1 != '\0');
      pbuf_put_at(buf,(u16_t)(uVar5 * 0x10000 >> 0x10),'\0');
      local_40 = 0x1000100;
      pbuf_take_at(buf,&local_40,4,(u16_t)((uVar7 + 2) * 0x10000 >> 0x10));
      eVar2 = udp_sendto(dns_pcbs,buf,dns_servers + dns_table[iVar3].server_idx,0x35);
      pbuf_free(buf);
    }
  }
  return eVar2;
}



void dns_check_entry(u8_t i)

{
  undefined3 in_register_00002029;
  int iVar1;
  u8_t uVar2;
  u16_t uVar3;
  uint uVar4;
  uint uVar5;
  u32_t uVar6;
  dns_table_entry_conflict1 *pdVar7;
  
  iVar1 = CONCAT31(in_register_00002029,i);
  uVar2 = dns_table[iVar1].state;
  if (uVar2 != '\x02') {
    if (uVar2 != '\x03') {
      if (uVar2 != '\x01') {
        return;
      }
      uVar4 = (uint)dns_txid;
      do {
        uVar5 = uVar4 + 1;
        uVar4 = uVar5 & 0xffff;
        pdVar7 = dns_table;
        while ((pdVar7->state != '\x02' || ((uint)pdVar7->txid != uVar4))) {
          pdVar7 = pdVar7 + 1;
          if (pdVar7 == (dns_table_entry_conflict1 *)arp_table) {
            uVar3 = (u16_t)(uVar5 * 0x10000 >> 0x10);
            dns_txid = uVar3;
            *(undefined2 *)&dns_table[iVar1].state = 2;
            dns_table[iVar1].txid = uVar3;
            *(undefined2 *)&dns_table[iVar1].tmr = 1;
            goto LAB_2303c5fe;
          }
        }
      } while( true );
    }
    uVar6 = dns_table[iVar1].ttl;
    if ((uVar6 != 0) && (uVar6 = uVar6 - 1, dns_table[iVar1].ttl = uVar6, uVar6 != 0)) {
      return;
    }
LAB_2303c65a:
    dns_table[iVar1].state = '\0';
    return;
  }
  uVar2 = dns_table[iVar1].tmr + -1;
  dns_table[iVar1].tmr = uVar2;
  if (uVar2 != '\0') {
    return;
  }
  uVar2 = dns_table[iVar1].retries + '\x01';
  dns_table[iVar1].retries = uVar2;
  if (uVar2 == '\x04') {
    if ((dns_table[iVar1].server_idx != '\0') || (dns_servers[1] == 0)) {
      dns_call_found(i,(ip_addr_t *)0x0);
      goto LAB_2303c65a;
    }
    dns_table[iVar1].server_idx = '\x01';
    *(undefined2 *)&dns_table[iVar1].tmr = 1;
  }
  else {
    dns_table[iVar1].tmr = uVar2;
  }
LAB_2303c5fe:
  dns_send(i);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void dns_recv(void *arg,udp_pcb *pcb,pbuf *p,ip_addr_t *addr,u16_t port)

{
  u8_t i;
  uint uVar1;
  u16_t uVar2;
  u16_t uVar3;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  undefined2 extraout_var_02;
  uint uVar4;
  int iVar5;
  undefined2 extraout_var_03;
  uint uVar6;
  undefined2 extraout_var_04;
  undefined2 extraout_var_05;
  u32_t uVar7;
  undefined2 extraout_var_06;
  dns_table_entry_conflict1 *pdVar8;
  byte *pbVar9;
  int iVar10;
  uint uVar11;
  byte *pbVar12;
  short sStack96;
  short sStack94;
  dns_query qry;
  ip4_addr_t ip4addr;
  dns_hdr hdr;
  dns_answer ans;
  
  if (0xf < p->tot_len) {
    uVar2 = pbuf_copy_partial(p,&ip4addr,0xc,0);
    uVar1 = CONCAT22(extraout_var,uVar2);
    if (uVar1 == 0xc) {
      iVar10 = 0;
      uVar2 = lwip_htons((u16_t)ip4addr.addr);
      pdVar8 = dns_table;
      do {
        i = (u8_t)iVar10;
        if ((pdVar8->state == '\x02') && ((uint)pdVar8->txid == CONCAT22(extraout_var_00,uVar2))) {
          uVar2 = lwip_htons(hdr.id);
          uVar3 = lwip_htons(hdr._2_2_);
          uVar11 = CONCAT22(extraout_var_02,uVar3);
          if ((ip4addr.addr._2_1_ < '\0') &&
             ((CONCAT22(extraout_var_01,uVar2) == 1 &&
              (addr->addr == dns_servers[dns_table[iVar10].server_idx].addr)))) {
            pbVar12 = (byte *)dns_table[iVar10].name;
            goto LAB_2303c752;
          }
          break;
        }
        iVar10 = iVar10 + 1;
        pdVar8 = pdVar8 + 1;
      } while (iVar10 != 4);
    }
  }
  goto ignore_packet;
  while( true ) {
    pbVar9 = pbVar12 + uVar4;
    while( true ) {
      uVar1 = uVar1 + 1 & 0xffff;
      if (pbVar12 == pbVar9) break;
      uVar4 = pbuf_try_get_at(p,(u16_t)uVar1);
      if ((int)uVar4 < 0) goto ignore_packet;
      uVar6 = (uint)*pbVar12;
      if ((_ctype_[uVar6 + 1] & 3) == 1) {
        uVar6 = uVar6 + 0x20;
      }
      uVar4 = uVar4 & 0xff;
      if ((_ctype_[uVar4 + 1] & 3) == 1) {
        uVar4 = uVar4 + 0x20;
      }
      if ((uVar6 != uVar4) || (uVar1 == 0xffff)) goto ignore_packet;
      pbVar12 = pbVar12 + 1;
    }
    pbVar12 = pbVar12 + 1;
    iVar5 = pbuf_try_get_at(p,(u16_t)uVar1);
    if (iVar5 < 0) goto ignore_packet;
    if (iVar5 == 0) break;
LAB_2303c752:
    uVar4 = pbuf_try_get_at(p,(u16_t)uVar1);
    if ((((int)uVar4 < 0) || (uVar1 == 0xffff)) || ((uVar4 & 0xc0) == 0xc0)) goto ignore_packet;
  }
  if (uVar1 != 0xffff) {
    uVar4 = uVar1 + 1 & 0xffff;
    if (((uVar4 != 0xffff) &&
        (uVar2 = pbuf_copy_partial(p,&sStack96,4,(u16_t)((uVar1 + 1) * 0x10000 >> 0x10)),
        CONCAT22(extraout_var_03,uVar2) == 4)) &&
       ((sStack94 == 0x100 && ((sStack96 == 0x100 && (uVar4 < 0xfffc)))))) {
      if ((ip4addr.addr._3_1_ & 0xf) == 0) {
        uVar1 = uVar1 + 5;
        while ((uVar1 = uVar1 & 0xffff, uVar11 != 0 && (uVar1 < p->tot_len))) {
          do {
            uVar4 = uVar1 + 1 & 0xffff;
            uVar6 = pbuf_try_get_at(p,(u16_t)uVar1);
            if (((int)uVar6 < 0) || (uVar4 == 0)) goto ignore_packet;
            if ((uVar6 & 0xc0) == 0xc0) break;
            uVar6 = uVar6 + uVar4;
            if ((int)(uint)p->tot_len <= (int)uVar6) goto ignore_packet;
            uVar1 = uVar6 & 0xffff;
            iVar5 = pbuf_try_get_at(p,(u16_t)(uVar6 * 0x10000 >> 0x10));
            if (iVar5 < 0) goto ignore_packet;
            uVar4 = uVar1;
          } while (iVar5 != 0);
          if (uVar4 == 0xffff) goto ignore_packet;
          uVar1 = uVar4 + 1 & 0xffff;
          if (((uVar1 == 0xffff) ||
              (uVar2 = pbuf_copy_partial(p,&hdr.numauthrr,10,(u16_t)((uVar4 + 1) * 0x10000 >> 0x10))
              , CONCAT22(extraout_var_04,uVar2) != 10)) || (0xfff5 < uVar1)) goto ignore_packet;
          uVar1 = uVar4 + 0xb & 0xffff;
          if (((hdr.numextrarr == 0x100) && (hdr.numauthrr == 0x100)) && ((u16_t)ans.ttl == 0x400))
          {
            uVar2 = pbuf_copy_partial(p,&qry,4,(u16_t)((uVar4 + 0xb) * 0x10000 >> 0x10));
            if (CONCAT22(extraout_var_05,uVar2) == 4) {
              *(dns_query *)&dns_table[iVar10].ipaddr = qry;
              pbuf_free(p);
              uVar7 = lwip_htonl(ans._0_4_);
              dns_table[iVar10].state = '\x03';
              if (uVar7 < 0x93a81) {
                dns_table[iVar10].ttl = uVar7;
              }
              else {
                dns_table[iVar10].ttl = 0x93a80;
              }
              dns_call_found(i,&dns_table[iVar10].ipaddr);
              if (dns_table[iVar10].ttl != 0) {
                return;
              }
              if (dns_table[iVar10].state != '\x03') {
                return;
              }
              dns_table[iVar10].state = '\0';
              return;
            }
            goto ignore_packet;
          }
          uVar2 = lwip_htons((u16_t)ans.ttl);
          if (0xffff < (int)(CONCAT22(extraout_var_06,uVar2) + uVar1)) goto ignore_packet;
          uVar2 = lwip_htons((u16_t)ans.ttl);
          uVar1 = uVar2 + uVar1;
          uVar11 = uVar11 - 1 & 0xffff;
        }
      }
      else {
        if ((dns_table[iVar10].server_idx == '\0') && (dns_servers[1] != 0)) {
          *(undefined2 *)&dns_table[iVar10].tmr = 0x301;
          dns_check_entry(i);
          goto ignore_packet;
        }
      }
      pbuf_free(p);
      dns_call_found(i,(ip_addr_t *)0x0);
      dns_table[iVar10].state = '\0';
      return;
    }
  }
ignore_packet:
  pbuf_free(p);
  return;
}



void dns_init(void)

{
  if (dns_pcbs == (udp_pcb *)0x0) {
    dns_pcbs = udp_new_ip_type();
    udp_bind(dns_pcbs,&ip_addr_any,0);
    udp_recv(dns_pcbs,dns_recv,(void *)0x0);
    return;
  }
  return;
}



void dns_setserver(u8_t numdns,ip_addr_t *dnsserver)

{
  undefined3 in_register_00002029;
  u32_t uVar1;
  
  if (CONCAT31(in_register_00002029,numdns) < 2) {
    if (dnsserver == (ip_addr_t *)0x0) {
      uVar1 = 0;
    }
    else {
      uVar1 = dnsserver->addr;
    }
    dns_servers[CONCAT31(in_register_00002029,numdns)].addr = uVar1;
  }
  return;
}



ip_addr_t * dns_getserver(u8_t numdns)

{
  undefined3 in_register_00002029;
  
  if (CONCAT31(in_register_00002029,numdns) < 2) {
    return dns_servers + CONCAT31(in_register_00002029,numdns);
  }
  return &ip_addr_any;
}



void dns_tmr(void)

{
  dns_check_entry('\0');
  dns_check_entry('\x01');
  dns_check_entry('\x02');
  dns_check_entry('\x03');
  return;
}



err_t dns_gethostbyname_addrtype
                (char *hostname,ip_addr_t *addr,dns_found_callback *found,void *callback_arg,
                u8_t dns_addrtype)

{
  u8_t uVar1;
  uint uVar2;
  size_t __n;
  int iVar3;
  int iVar4;
  uint uVar5;
  byte bVar6;
  err_t eVar7;
  byte bVar8;
  uint uVar9;
  dns_table_entry_conflict1 *pdVar10;
  dns_table_entry_conflict1 *pdVar11;
  
  if (addr == (ip_addr_t *)0x0) {
    return -0x10;
  }
  if ((((hostname == (char *)0x0) || (*hostname == '\0')) || (dns_pcbs == (udp_pcb *)0x0)) ||
     (__n = strlen(hostname), 0xff < __n)) {
    eVar7 = -0x10;
  }
  else {
    iVar3 = ip4addr_aton(hostname,(ip4_addr_t *)addr);
    eVar7 = '\0';
    if (iVar3 == 0) {
      pdVar10 = dns_table;
      pdVar11 = dns_table;
      iVar3 = 0;
      do {
        if ((pdVar11->state == '\x03') &&
           (iVar4 = lwip_strnicmp(hostname,pdVar11->name,0x100), iVar4 == 0)) {
          addr->addr = dns_table[iVar3].ipaddr.addr;
          return '\0';
        }
        uVar1 = dns_seqno;
        iVar3 = iVar3 + 1;
        pdVar11 = pdVar11 + 1;
      } while (iVar3 != 4);
      eVar7 = -6;
      if (dns_servers[0] != 0) {
        uVar9 = 0;
        uVar2 = 4;
        bVar6 = 0;
        do {
          uVar5 = uVar9 & 0xff;
          if (pdVar10->state == '\0') goto LAB_2303cba6;
          if ((pdVar10->state == '\x03') && (bVar8 = dns_seqno - pdVar10->seqno, bVar6 < bVar8)) {
            uVar2 = uVar5;
            bVar6 = bVar8;
          }
          uVar9 = uVar9 + 1;
          pdVar10 = pdVar10 + 1;
        } while (uVar9 != 4);
        eVar7 = -1;
        if ((uVar2 != 4) &&
           (eVar7 = -1, uVar5 = uVar2, uVar9 = uVar2, dns_table[uVar2].state == '\x03')) {
LAB_2303cba6:
          iVar3 = uVar9 * 0x110;
          (&dns_table[0].state)[iVar3] = '\x01';
          (&dns_table[0].seqno)[iVar3] = uVar1;
          dns_requests[uVar5].found = found;
          dns_requests[uVar5].arg = callback_arg;
          memcpy(dns_table[0].name + iVar3,hostname,__n);
          dns_table[0].name[iVar3 + __n] = '\0';
          dns_seqno = dns_seqno + '\x01';
          dns_check_entry((u8_t)uVar5);
          eVar7 = -5;
        }
      }
    }
  }
  return eVar7;
}



err_t dns_gethostbyname(char *hostname,ip_addr_t *addr,dns_found_callback *found,void *callback_arg)

{
  err_t eVar1;
  
  eVar1 = dns_gethostbyname_addrtype(hostname,addr,found,callback_arg,'\0');
  return eVar1;
}



u16_t lwip_standard_chksum(void *dataptr,int len)

{
  byte bVar1;
  ushort uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;
  u16_t t;
  ushort uStack2;
  
  uStack2 = 0;
  uVar3 = (uint)dataptr & 1;
  if ((uVar3 != 0) && (0 < len)) {
    bVar1 = *(byte *)dataptr;
    len = len + -1;
    dataptr = (void *)((int)dataptr + 1);
    uStack2 = (ushort)bVar1 << 8;
  }
  uVar5 = (uint)dataptr & 3;
  if ((uVar5 != 0) && (uVar5 = 0, 1 < len)) {
    uVar5 = (uint)*(ushort *)dataptr;
    len = len + -2;
    dataptr = (void *)((int)dataptr + 2);
  }
  while (7 < len) {
    uVar4 = *(int *)dataptr + uVar5;
    if (uVar4 < uVar5) {
      uVar4 = uVar4 + 1;
    }
    uVar5 = ((int *)dataptr)[1] + uVar4;
    if (uVar5 < uVar4) {
      uVar5 = uVar5 + 1;
    }
    len = len + -8;
    dataptr = (int *)dataptr + 2;
  }
  iVar6 = (uVar5 & 0xffff) + (uVar5 >> 0x10);
  while (1 < len) {
    len = len + -2;
    iVar6 = iVar6 + (uint)*(ushort *)dataptr;
    dataptr = (int *)((int)dataptr + 2);
  }
  if (len == 1) {
    uStack2 = uStack2 | *(byte *)dataptr;
  }
  uVar5 = ((uint)uStack2 + iVar6 >> 0x10) + ((uint)uStack2 + iVar6 & 0xffff);
  iVar6 = (uVar5 >> 0x10) + (uVar5 & 0xffff);
  uVar2 = (ushort)iVar6;
  if (uVar3 != 0) {
    uVar2 = (ushort)((uint)iVar6 >> 8) & 0xff | uVar2 * 0x100;
  }
  return (u16_t)uVar2;
}



u16_t inet_chksum_pseudo(pbuf *p,u8_t proto,u16_t proto_len,ip4_addr_t *src,ip4_addr_t *dest)

{
  bool bVar1;
  int iVar2;
  u16_t uVar3;
  u16_t uVar4;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  undefined3 in_register_0000202d;
  uint uVar5;
  
  uVar5 = (src->addr >> 0x10) + (dest->addr & 0xffff) + (dest->addr >> 0x10) + (src->addr & 0xffff);
  uVar5 = (uVar5 & 0xffff) + (uVar5 >> 0x10);
  uVar5 = (uVar5 >> 0x10) + (uVar5 & 0xffff);
  bVar1 = false;
  while (p != (pbuf *)0x0) {
    uVar3 = lwip_standard_chksum(p->payload,(uint)p->len);
    uVar5 = uVar5 + CONCAT22(extraout_var_01,uVar3);
    uVar5 = (uVar5 & 0xffff) + (uVar5 >> 0x10);
    if ((p->len & 1) != 0) {
      bVar1 = (bool)(bVar1 ^ 1);
      uVar5 = uVar5 >> 8 & 0xff | uVar5 * 0x100 & 0xffff;
    }
    p = p->next;
  }
  if (bVar1) {
    uVar5 = uVar5 >> 8 & 0xff | (uVar5 & 0xff) << 8;
  }
  uVar3 = lwip_htons((u16_t)CONCAT31(in_register_0000202d,proto));
  uVar4 = lwip_htons(proto_len);
  uVar5 = uVar5 + CONCAT22(extraout_var_00,uVar4) + CONCAT22(extraout_var,uVar3);
  iVar2 = (uVar5 & 0xffff) + (uVar5 >> 0x10);
  return (u16_t)~((short)iVar2 + (short)((uint)iVar2 >> 0x10));
}



u16_t ip_chksum_pseudo(pbuf *p,u8_t proto,u16_t proto_len,ip4_addr_t *src,ip4_addr_t *dest)

{
  bool bVar1;
  int iVar2;
  u16_t uVar3;
  u16_t uVar4;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  undefined3 in_register_0000202d;
  uint uVar5;
  
  uVar5 = (src->addr >> 0x10) + (dest->addr & 0xffff) + (dest->addr >> 0x10) + (src->addr & 0xffff);
  uVar5 = (uVar5 & 0xffff) + (uVar5 >> 0x10);
  uVar5 = (uVar5 >> 0x10) + (uVar5 & 0xffff);
  bVar1 = false;
  while (p != (pbuf *)0x0) {
    uVar3 = lwip_standard_chksum(p->payload,(uint)p->len);
    uVar5 = uVar5 + CONCAT22(extraout_var_01,uVar3);
    uVar5 = (uVar5 & 0xffff) + (uVar5 >> 0x10);
    if ((p->len & 1) != 0) {
      bVar1 = (bool)(bVar1 ^ 1);
      uVar5 = uVar5 >> 8 & 0xff | uVar5 * 0x100 & 0xffff;
    }
    p = p->next;
  }
  if (bVar1) {
    uVar5 = uVar5 >> 8 & 0xff | (uVar5 & 0xff) << 8;
  }
  uVar3 = lwip_htons((u16_t)CONCAT31(in_register_0000202d,proto));
  uVar4 = lwip_htons(proto_len);
  uVar5 = uVar5 + CONCAT22(extraout_var_00,uVar4) + CONCAT22(extraout_var,uVar3);
  iVar2 = (uVar5 & 0xffff) + (uVar5 >> 0x10);
  return (u16_t)~((short)iVar2 + (short)((uint)iVar2 >> 0x10));
}



u16_t inet_chksum_pseudo_partial
                (pbuf *p,u8_t proto,u16_t proto_len,u16_t chksum_len,ip4_addr_t *src,
                ip4_addr_t *dest)

{
  bool bVar1;
  int iVar2;
  u16_t uVar3;
  u16_t uVar4;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  undefined3 in_register_0000202d;
  undefined2 in_register_00002036;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  
  uVar5 = CONCAT22(in_register_00002036,chksum_len);
  uVar6 = (src->addr >> 0x10) + (dest->addr & 0xffff) + (dest->addr >> 0x10) + (src->addr & 0xffff);
  uVar6 = (uVar6 & 0xffff) + (uVar6 >> 0x10);
  uVar6 = (uVar6 >> 0x10) + (uVar6 & 0xffff);
  bVar1 = false;
  while ((p != (pbuf *)0x0 && (uVar5 != 0))) {
    uVar7 = (uint)p->len;
    if (uVar5 < (uint)p->len) {
      uVar7 = uVar5;
    }
    uVar3 = lwip_standard_chksum(p->payload,uVar7 & 0xffff);
    uVar6 = uVar6 + CONCAT22(extraout_var_01,uVar3);
    uVar6 = (uVar6 & 0xffff) + (uVar6 >> 0x10);
    uVar5 = uVar5 - (uVar7 & 0xffff) & 0xffff;
    if ((p->len & 1) != 0) {
      bVar1 = (bool)(bVar1 ^ 1);
      uVar6 = uVar6 >> 8 & 0xff | uVar6 * 0x100 & 0xffff;
    }
    p = p->next;
  }
  if (bVar1) {
    uVar6 = uVar6 >> 8 & 0xff | (uVar6 & 0xff) << 8;
  }
  uVar3 = lwip_htons((u16_t)CONCAT31(in_register_0000202d,proto));
  uVar4 = lwip_htons(proto_len);
  uVar6 = uVar6 + CONCAT22(extraout_var_00,uVar4) + CONCAT22(extraout_var,uVar3);
  iVar2 = (uVar6 & 0xffff) + (uVar6 >> 0x10);
  return (u16_t)~((short)iVar2 + (short)((uint)iVar2 >> 0x10));
}



u16_t ip_chksum_pseudo_partial
                (pbuf *p,u8_t proto,u16_t proto_len,u16_t chksum_len,ip4_addr_t *src,
                ip4_addr_t *dest)

{
  bool bVar1;
  int iVar2;
  u16_t uVar3;
  u16_t uVar4;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  undefined3 in_register_0000202d;
  uint uVar5;
  undefined2 in_register_00002036;
  uint uVar6;
  uint uVar7;
  
  uVar5 = CONCAT22(in_register_00002036,chksum_len);
  uVar6 = (src->addr >> 0x10) + (dest->addr & 0xffff) + (dest->addr >> 0x10) + (src->addr & 0xffff);
  uVar6 = (uVar6 & 0xffff) + (uVar6 >> 0x10);
  uVar6 = (uVar6 >> 0x10) + (uVar6 & 0xffff);
  bVar1 = false;
  while ((p != (pbuf *)0x0 && (uVar5 != 0))) {
    uVar7 = (uint)p->len;
    if (uVar5 < (uint)p->len) {
      uVar7 = uVar5;
    }
    uVar3 = lwip_standard_chksum(p->payload,uVar7 & 0xffff);
    uVar6 = uVar6 + CONCAT22(extraout_var_01,uVar3);
    uVar6 = (uVar6 & 0xffff) + (uVar6 >> 0x10);
    uVar5 = uVar5 - (uVar7 & 0xffff) & 0xffff;
    if ((p->len & 1) != 0) {
      bVar1 = (bool)(bVar1 ^ 1);
      uVar6 = uVar6 >> 8 & 0xff | uVar6 * 0x100 & 0xffff;
    }
    p = p->next;
  }
  if (bVar1) {
    uVar6 = uVar6 >> 8 & 0xff | (uVar6 & 0xff) << 8;
  }
  uVar3 = lwip_htons((u16_t)CONCAT31(in_register_0000202d,proto));
  uVar4 = lwip_htons(proto_len);
  uVar6 = uVar6 + CONCAT22(extraout_var_00,uVar4) + CONCAT22(extraout_var,uVar3);
  iVar2 = (uVar6 & 0xffff) + (uVar6 >> 0x10);
  return (u16_t)~((short)iVar2 + (short)((uint)iVar2 >> 0x10));
}



u16_t inet_chksum(void *dataptr,u16_t len)

{
  u16_t uVar1;
  undefined2 in_register_0000202e;
  
  uVar1 = lwip_standard_chksum(dataptr,CONCAT22(in_register_0000202e,len));
  return ~uVar1;
}



u16_t inet_chksum_pbuf(pbuf *p)

{
  bool bVar1;
  ushort uVar2;
  uint uVar3;
  u16_t uVar4;
  undefined2 extraout_var;
  
  bVar1 = false;
  uVar3 = 0;
  while (uVar2 = (ushort)uVar3, p != (pbuf *)0x0) {
    uVar4 = lwip_standard_chksum(p->payload,(uint)p->len);
    uVar3 = uVar3 + CONCAT22(extraout_var,uVar4);
    uVar3 = (uVar3 & 0xffff) + (uVar3 >> 0x10);
    if ((p->len & 1) != 0) {
      bVar1 = (bool)(bVar1 ^ 1);
      uVar3 = uVar3 >> 8 & 0xff | uVar3 * 0x100 & 0xffff;
    }
    p = p->next;
  }
  if (bVar1) {
    uVar2 = (ushort)(uVar3 >> 8) & 0xff | (ushort)((uVar3 & 0xff) << 8);
  }
  return (u16_t)~uVar2;
}



u16_t lwip_chksum_copy(void *dst,void *src,u16_t len)

{
  u16_t uVar1;
  undefined2 in_register_00002032;
  
  memcpy(dst,src,CONCAT22(in_register_00002032,len));
  uVar1 = lwip_standard_chksum(dst,CONCAT22(in_register_00002032,len));
  return uVar1;
}



void lwip_init(void)

{
  stats_init();
  sys_init();
  mem_init();
  memp_init();
  netif_init();
  udp_init();
  tcp_init();
  igmp_init();
  dns_init();
  sys_timeouts_init();
  return;
}



void dhcp_set_state(dhcp *dhcp,u8_t new_state)

{
  undefined3 in_register_0000202d;
  
  if ((uint)dhcp->state != CONCAT31(in_register_0000202d,new_state)) {
    dhcp->state = new_state;
    dhcp->tries = '\0';
    dhcp->request_timeout = 0;
  }
  return;
}



u16_t dhcp_option_short(u16_t options_out_len,u8_t *options,u16_t value)

{
  undefined2 in_register_0000202a;
  int iVar1;
  
  iVar1 = CONCAT22(in_register_0000202a,options_out_len);
  options[iVar1] = (u8_t)(value >> 8);
  options[iVar1 + 1U & 0xffff] = (u8_t)value;
  return (u16_t)((uint)((iVar1 + 2) * 0x10000) >> 0x10);
}



u16_t dhcp_option_long(u16_t options_out_len,u8_t *options,u32_t value)

{
  undefined2 in_register_0000202a;
  int iVar1;
  
  iVar1 = CONCAT22(in_register_0000202a,options_out_len);
  options[iVar1] = (u8_t)(value >> 0x18);
  options[iVar1 + 1U & 0xffff] = (u8_t)(value >> 0x10);
  options[iVar1 + 2U & 0xffff] = (u8_t)(value >> 8);
  options[iVar1 + 3U & 0xffff] = (u8_t)value;
  return (u16_t)((uint)((iVar1 + 4) * 0x10000) >> 0x10);
}



pbuf * dhcp_create_msg(netif *netif,dhcp *dhcp,u8_t message_type,u16_t *options_out_len)

{
  u8_t uVar1;
  u32_t xid;
  undefined *__s;
  u32_t uVar2;
  undefined3 in_register_00002031;
  int iVar3;
  u8_t *puVar4;
  u8_t *puVar5;
  pbuf *ppVar6;
  
  iVar3 = CONCAT31(in_register_00002031,message_type);
  if (((netif == (netif *)0x0) || (dhcp == (dhcp *)0x0)) ||
     (ppVar6 = pbuf_alloc(PBUF_TRANSPORT,0x134,PBUF_RAM), ppVar6 == (pbuf *)0x0)) {
    ppVar6 = (pbuf *)0x0;
  }
  else {
    if ((iVar3 != 3) || (dhcp->state == '\x03')) {
      if (dhcp->tries == '\0') {
        xid = bl_rand();
      }
      dhcp->xid = xid;
    }
    __s = (undefined *)ppVar6->payload;
    memset(__s,0,0x134);
    *__s = 1;
    __s[1] = 1;
    __s[2] = netif->hwaddr_len;
    uVar2 = lwip_htonl(dhcp->xid);
    __s[4] = (char)uVar2;
    __s[5] = (char)(uVar2 >> 8);
    __s[6] = (char)(uVar2 >> 0x10);
    __s[7] = (char)(uVar2 >> 0x18);
    if (((iVar3 == 4) || ((iVar3 - 7U & 0xff) < 2)) ||
       ((iVar3 == 3 && ((byte)(dhcp->state - 4) < 2)))) {
      uVar2 = (netif->ip_addr).addr;
      __s[0xc] = (char)uVar2;
      __s[0xd] = (char)(uVar2 >> 8);
      __s[0xe] = (char)(uVar2 >> 0x10);
      __s[0xf] = (char)(uVar2 >> 0x18);
    }
    puVar5 = netif->hwaddr;
    puVar4 = __s + 0x1c;
    do {
      uVar1 = *puVar5;
      puVar5 = puVar5 + 1;
      *puVar4 = uVar1;
      puVar4 = puVar4 + 1;
    } while (puVar5 != &netif->hwaddr_len);
    __s[0xec] = 99;
    __s[0xef] = 99;
    __s[0xed] = 0x82;
    __s[0xf0] = 0x35;
    __s[0xf1] = 1;
    __s[0xee] = 0x53;
    __s[0xf2] = message_type;
    *options_out_len = 3;
  }
  return ppVar6;
}



void dhcp_option_trailer(u16_t options_out_len,u8_t *options,pbuf *p_out)

{
  undefined2 in_register_0000202a;
  uint uVar1;
  
  uVar1 = CONCAT22(in_register_0000202a,options_out_len) + 1U & 0xffff;
  options[CONCAT22(in_register_0000202a,options_out_len)] = -1;
  options = options + uVar1;
  while (uVar1 < 0x44) {
    *options = '\0';
    uVar1 = uVar1 + 1 & 0xffff;
    options = options + 1;
  }
  pbuf_realloc(p_out,(u16_t)((uVar1 + 0xf0) * 0x10000 >> 0x10));
  return;
}



err_t dhcp_discover(netif *netif)

{
  u8_t *options;
  dhcp *dhcp;
  pbuf *p_out;
  undefined2 extraout_var;
  uint uVar1;
  int iVar2;
  u16_t auStack34 [2];
  u16_t options_out_len;
  
  dhcp = (dhcp *)netif->client_data[0];
  (dhcp->offered_ip_addr).addr = 0;
  dhcp_set_state(dhcp,'\x06');
  p_out = dhcp_create_msg(netif,dhcp,'\x01',auStack34);
  if (p_out != (pbuf *)0x0) {
    uVar1 = (uint)auStack34[0];
    options = (u8_t *)((int)p_out->payload + 0xf0);
    options[uVar1] = '9';
    options[uVar1 + 1 & 0xffff] = '\x02';
    auStack34[0] = (u16_t)((uVar1 + 2) * 0x10000 >> 0x10);
    auStack34[0] = dhcp_option_short(auStack34[0],options,netif->mtu);
    options[CONCAT22(extraout_var,auStack34[0])] = '7';
    options[CONCAT22(extraout_var,auStack34[0]) + 1U & 0xffff] = '\x04';
    auStack34[0] = auStack34[0] + 2;
    iVar2 = 0;
    do {
      options[(uint)auStack34[0]] = "\x01\x03\x1c\x06"[iVar2];
      auStack34[0] = (u16_t)(((uint)auStack34[0] + 1) * 0x10000 >> 0x10);
      iVar2 = iVar2 + 1;
    } while (iVar2 != 4);
    dhcp_option_trailer(auStack34[0],options,p_out);
    udp_sendto_if_src(dhcp_pcb,p_out,&ip_addr_broadcast,0x43,netif,&ip_addr_any);
    pbuf_free(p_out);
  }
  if (dhcp->tries != -1) {
    dhcp->tries = dhcp->tries + '\x01';
  }
  if (dhcp->tries < 6) {
    uVar1 = (uint)((1 << ((uint)dhcp->tries & 0x1f)) * 0x3e80000) >> 0x10;
  }
  else {
    uVar1 = 60000;
  }
  dhcp->request_timeout = (u16_t)((int)(uVar1 + 499) / 500);
  return '\0';
}



void dhcp_check(netif *netif)

{
  dhcp *dhcp;
  
  dhcp = (dhcp *)netif->client_data[0];
  dhcp_set_state(dhcp,'\b');
  etharp_query(netif,&dhcp->offered_ip_addr,(pbuf *)0x0);
  if (dhcp->tries != -1) {
    dhcp->tries = dhcp->tries + '\x01';
  }
  dhcp->request_timeout = 1;
  return;
}



// WARNING: Type propagation algorithm not settling

void dhcp_bind(netif *netif)

{
  byte bVar1;
  dhcp *dhcp;
  u16_t uVar2;
  uint uVar3;
  int iVar4;
  ip4_addr_t iStack24;
  ip4_addr_t sn_mask;
  ip4_addr_t gw_addr;
  
  if (netif == (netif *)0x0) {
    return;
  }
  dhcp = (dhcp *)netif->client_data[0];
  if (dhcp == (dhcp *)0x0) {
    return;
  }
  dhcp->lease_used = 0;
  if (dhcp->offered_t0_lease != 0xffffffff) {
    uVar3 = dhcp->offered_t0_lease + 0x1e;
    if (uVar3 < 0x3c0000) {
      uVar3 = uVar3 / 0x3c;
      uVar2 = (u16_t)uVar3;
      if (uVar3 == 0) {
        dhcp->t0_timeout = 1;
        goto LAB_2303d354;
      }
    }
    else {
      uVar2 = 0xffff;
    }
    dhcp->t0_timeout = uVar2;
  }
LAB_2303d354:
  if (dhcp->offered_t1_renew != 0xffffffff) {
    uVar3 = dhcp->offered_t1_renew + 0x1e;
    if (uVar3 < 0x3c0000) {
      uVar3 = uVar3 / 0x3c;
      uVar2 = (u16_t)uVar3;
      if (uVar3 != 0) goto LAB_2303d376;
      dhcp->t1_timeout = 1;
    }
    else {
      uVar2 = 0xffff;
LAB_2303d376:
      dhcp->t1_timeout = uVar2;
    }
    dhcp->t1_renew_time = dhcp->t1_timeout;
  }
  if (dhcp->offered_t2_rebind == 0xffffffff) goto LAB_2303d3b0;
  uVar3 = dhcp->offered_t2_rebind + 0x1e;
  if (uVar3 < 0x3c0000) {
    uVar3 = uVar3 / 0x3c;
    uVar2 = (u16_t)uVar3;
    if (uVar3 != 0) goto LAB_2303d3a4;
    dhcp->t2_timeout = 1;
  }
  else {
    uVar2 = 0xffff;
LAB_2303d3a4:
    dhcp->t2_timeout = uVar2;
  }
  dhcp->t2_rebind_time = dhcp->t2_timeout;
LAB_2303d3b0:
  if ((dhcp->t2_timeout <= dhcp->t1_timeout) && (dhcp->t2_timeout != 0)) {
    dhcp->t1_timeout = 0;
  }
  if (dhcp->subnet_mask_given == '\0') {
    bVar1 = *(byte *)&(dhcp->offered_ip_addr).addr;
    if ((char)bVar1 < '\0') {
      if (bVar1 < 0xc0) {
        iVar4 = 0x10000;
      }
      else {
        iVar4 = 0x1000000;
      }
      iStack24 = (ip4_addr_t)(iVar4 - 1);
    }
    else {
      iStack24 = (ip4_addr_t)0xff;
    }
  }
  else {
    iStack24 = (ip4_addr_t)(dhcp->offered_sn_mask).addr;
  }
  sn_mask = (dhcp->offered_gw_addr).addr;
  if ((ip4_addr_t)sn_mask == (ip4_addr_t)0x0) {
    sn_mask = (dhcp->offered_ip_addr).addr & (uint)iStack24 | 0x1000000;
  }
  dhcp_set_state(dhcp,'\n');
  netif_set_addr(netif,&dhcp->offered_ip_addr,&iStack24,&sn_mask);
  return;
}



err_t dhcp_inc_pcb_refcount(void)

{
  udp_pcb *pcb;
  
  if (dhcp_pcb_refcount == '\0') {
    pcb = udp_new();
    if (pcb == (udp_pcb *)0x0) {
      dhcp_pcb = pcb;
      return -1;
    }
    dhcp_pcb = pcb;
    pcb->so_options = pcb->so_options | 0x20;
    udp_bind(pcb,&ip_addr_any,0x44);
    udp_connect(dhcp_pcb,&ip_addr_any,0x43);
    udp_recv(dhcp_pcb,dhcp_recv,(void *)0x0);
  }
  dhcp_pcb_refcount = dhcp_pcb_refcount + '\x01';
  return '\0';
}



u16_t dhcp_option_hostname(u16_t options_out_len,u8_t *options)

{
  undefined2 in_register_0000202a;
  int iVar1;
  size_t sVar2;
  u8_t **in_a2;
  u8_t *puVar3;
  u8_t *puVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  
  iVar1 = CONCAT22(in_register_0000202a,options_out_len);
  if ((*in_a2 != (u8_t *)0x0) && (sVar2 = strlen((char *)*in_a2), sVar2 != 0)) {
    puVar3 = *in_a2;
    uVar6 = 0x41U - iVar1;
    if (sVar2 < 0x41U - iVar1) {
      uVar6 = sVar2;
    }
    options[iVar1] = '\f';
    uVar5 = iVar1 + 2U & 0xffff;
    options[iVar1 + 1U & 0xffff] = (u8_t)uVar6;
    puVar4 = puVar3;
    uVar7 = uVar5;
    while (puVar4 != puVar3 + uVar6) {
      options[uVar7] = *puVar4;
      uVar7 = uVar7 + 1 & 0xffff;
      puVar4 = puVar4 + 1;
    }
    options_out_len = (short)uVar5 + (short)uVar6;
  }
  return options_out_len;
}



err_t dhcp_reboot(netif *netif)

{
  u8_t *options;
  dhcp *dhcp;
  err_t eVar1;
  u16_t options_out_len_00;
  pbuf *p_out;
  undefined2 extraout_var;
  u32_t value;
  undefined2 extraout_var_00;
  uint uVar2;
  int iVar3;
  u16_t auStack34 [2];
  u16_t options_out_len;
  
  dhcp = (dhcp *)netif->client_data[0];
  dhcp_set_state(dhcp,'\x03');
  p_out = dhcp_create_msg(netif,dhcp,'\x03',auStack34);
  eVar1 = -1;
  if (p_out != (pbuf *)0x0) {
    uVar2 = (uint)auStack34[0];
    options = (u8_t *)((int)p_out->payload + 0xf0);
    options[uVar2] = '9';
    options[uVar2 + 1 & 0xffff] = '\x02';
    auStack34[0] = (u16_t)((uVar2 + 2) * 0x10000 >> 0x10);
    options_out_len_00 = dhcp_option_short(auStack34[0],options,0x240);
    iVar3 = CONCAT22(extraout_var,options_out_len_00);
    options[iVar3] = '2';
    options[iVar3 + 1U & 0xffff] = '\x04';
    options_out_len_00 = (u16_t)((uint)((iVar3 + 2) * 0x10000) >> 0x10);
    auStack34[0] = options_out_len_00;
    value = lwip_htonl((dhcp->offered_ip_addr).addr);
    auStack34[0] = dhcp_option_long(options_out_len_00,options,value);
    options[CONCAT22(extraout_var_00,auStack34[0])] = '7';
    options[CONCAT22(extraout_var_00,auStack34[0]) + 1U & 0xffff] = '\x04';
    auStack34[0] = auStack34[0] + 2;
    iVar3 = 0;
    do {
      options[(uint)auStack34[0]] = "\x01\x03\x1c\x06"[iVar3];
      auStack34[0] = (u16_t)(((uint)auStack34[0] + 1) * 0x10000 >> 0x10);
      iVar3 = iVar3 + 1;
    } while (iVar3 != 4);
    auStack34[0] = dhcp_option_hostname(auStack34[0],options);
    dhcp_option_trailer(auStack34[0],options,p_out);
    eVar1 = udp_sendto_if(dhcp_pcb,p_out,&ip_addr_broadcast,0x43,netif);
    pbuf_free(p_out);
  }
  if (dhcp->tries != -1) {
    dhcp->tries = dhcp->tries + '\x01';
  }
  if (dhcp->tries < 10) {
    uVar2 = (uint)dhcp->tries * 0x3e80000 >> 0x10;
  }
  else {
    uVar2 = 10000;
  }
  dhcp->request_timeout = (u16_t)((int)(uVar2 + 499) / 500);
  return eVar1;
}



err_t dhcp_select(netif *netif)

{
  u8_t *options;
  dhcp *dhcp;
  err_t eVar1;
  u16_t options_out_len_00;
  pbuf *p_out;
  undefined2 extraout_var;
  u32_t value;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  uint uVar2;
  int iVar3;
  u16_t auStack34 [2];
  u16_t options_out_len;
  
  eVar1 = -0x10;
  if (netif != (netif *)0x0) {
    dhcp = (dhcp *)netif->client_data[0];
    eVar1 = -6;
    if (dhcp != (dhcp *)0x0) {
      dhcp_set_state(dhcp,'\x01');
      p_out = dhcp_create_msg(netif,dhcp,'\x03',auStack34);
      eVar1 = -1;
      if (p_out != (pbuf *)0x0) {
        uVar2 = (uint)auStack34[0];
        options = (u8_t *)((int)p_out->payload + 0xf0);
        options[uVar2] = '9';
        options[uVar2 + 1 & 0xffff] = '\x02';
        auStack34[0] = (u16_t)((uVar2 + 2) * 0x10000 >> 0x10);
        options_out_len_00 = dhcp_option_short(auStack34[0],options,netif->mtu);
        iVar3 = CONCAT22(extraout_var,options_out_len_00);
        options[iVar3] = '2';
        options[iVar3 + 1U & 0xffff] = '\x04';
        options_out_len_00 = (u16_t)((uint)((iVar3 + 2) * 0x10000) >> 0x10);
        auStack34[0] = options_out_len_00;
        value = lwip_htonl((dhcp->offered_ip_addr).addr);
        options_out_len_00 = dhcp_option_long(options_out_len_00,options,value);
        iVar3 = CONCAT22(extraout_var_00,options_out_len_00);
        options[iVar3] = '6';
        options[iVar3 + 1U & 0xffff] = '\x04';
        options_out_len_00 = (u16_t)((uint)((iVar3 + 2) * 0x10000) >> 0x10);
        auStack34[0] = options_out_len_00;
        value = lwip_htonl((dhcp->server_ip_addr).addr);
        auStack34[0] = dhcp_option_long(options_out_len_00,options,value);
        options[CONCAT22(extraout_var_01,auStack34[0])] = '7';
        options[CONCAT22(extraout_var_01,auStack34[0]) + 1U & 0xffff] = '\x04';
        auStack34[0] = auStack34[0] + 2;
        iVar3 = 0;
        do {
          options[(uint)auStack34[0]] = "\x01\x03\x1c\x06"[iVar3];
          auStack34[0] = (u16_t)(((uint)auStack34[0] + 1) * 0x10000 >> 0x10);
          iVar3 = iVar3 + 1;
        } while (iVar3 != 4);
        auStack34[0] = dhcp_option_hostname(auStack34[0],options);
        dhcp_option_trailer(auStack34[0],options,p_out);
        eVar1 = udp_sendto_if_src(dhcp_pcb,p_out,&ip_addr_broadcast,0x43,netif,&ip_addr_any);
        pbuf_free(p_out);
      }
      if (dhcp->tries != -1) {
        dhcp->tries = dhcp->tries + '\x01';
      }
      if (dhcp->tries < 6) {
        uVar2 = (uint)((1 << ((uint)dhcp->tries & 0x1f)) * 0x3e80000) >> 0x10;
      }
      else {
        uVar2 = 60000;
      }
      dhcp->request_timeout = (u16_t)((int)(uVar2 + 499) / 500);
    }
  }
  return eVar1;
}



void dhcp_dec_pcb_refcount(void)

{
  dhcp_pcb_refcount = dhcp_pcb_refcount + -1;
  if (dhcp_pcb_refcount == '\0') {
    udp_remove(dhcp_pcb);
    dhcp_pcb = (udp_pcb *)0x0;
    return;
  }
  return;
}



void dhcp_handle_ack(dhcp_msg *msg_in)

{
  u8_t uVar1;
  u32_t uVar2;
  int in_a1;
  uint uVar3;
  ip_addr_t iStack20;
  ip_addr_t dns_addr;
  
  uVar1 = dhcp_rx_options_given[3];
  *(undefined4 *)(msg_in->chaddr + 4) = 0;
  *(undefined4 *)(msg_in->chaddr + 8) = 0;
  if (uVar1 != '\0') {
    *(u32_t *)(msg_in->chaddr + 0xc) = dhcp_rx_options_val[3];
  }
  uVar3 = dhcp_rx_options_val[4];
  if (dhcp_rx_options_given[4] == '\0') {
    uVar3 = *(uint *)(msg_in->chaddr + 0xc) >> 1;
  }
  *(uint *)msg_in->sname = uVar3;
  uVar3 = dhcp_rx_options_val[5];
  if (dhcp_rx_options_given[5] == '\0') {
    uVar3 = (uint)(*(int *)(msg_in->chaddr + 0xc) * 7) >> 3;
  }
  *(uint *)(msg_in->sname + 4) = uVar3;
  *(undefined4 *)msg_in->chaddr = *(undefined4 *)(in_a1 + 0x10);
  if (dhcp_rx_options_given[6] == '\0') {
    *(undefined *)((int)&msg_in->xid + 3) = 0;
  }
  else {
    uVar2 = lwip_htonl(dhcp_rx_options_val[6]);
    *(u32_t *)(msg_in->chaddr + 4) = uVar2;
    *(undefined *)((int)&msg_in->xid + 3) = 1;
  }
  if (dhcp_rx_options_given[7] != '\0') {
    uVar2 = lwip_htonl(dhcp_rx_options_val[7]);
    *(u32_t *)(msg_in->chaddr + 8) = uVar2;
  }
  if (dhcp_rx_options_given[8] != '\0') {
    iStack20 = (ip_addr_t)lwip_htonl(dhcp_rx_options_val[8]);
    dns_setserver('\0',&iStack20);
    if (dhcp_rx_options_given[9] != '\0') {
      iStack20 = (ip_addr_t)lwip_htonl(dhcp_rx_options_val[9]);
      dns_setserver('\x01',&iStack20);
    }
  }
  return;
}



void dhcp_recv(void *arg,udp_pcb *pcb,pbuf *p,ip_addr_t *addr,u16_t port)

{
  byte bVar1;
  byte bVar2;
  bool bVar3;
  pbuf **pppVar4;
  netif *netif;
  uint uVar5;
  void *pvVar6;
  u16_t uVar7;
  u32_t uVar8;
  undefined2 extraout_var;
  void *pvVar9;
  uint uVar10;
  char *pcVar11;
  uint uVar12;
  u8_t *puVar13;
  u32_t *puVar14;
  pbuf *buf;
  uint uVar15;
  uint uVar16;
  int iVar17;
  uint uVar18;
  void *pvStack96;
  u32_t uStack68;
  u32_t value;
  
  netif = ip_data.current_input_netif;
  puVar14 = (u32_t *)(ip_data.current_input_netif)->client_data[0];
  if ((((puVar14 != (u32_t *)0x0) && (*(char *)(puVar14 + 1) != '\0')) && (0x2b < p->len)) &&
     (pcVar11 = (char *)p->payload, *pcVar11 == '\x02')) {
    uVar16 = 0;
    do {
      if (((uint)(ip_data.current_input_netif)->hwaddr_len <= (uVar16 & 0xff)) || (uVar16 == 6)) {
        uVar8 = lwip_htonl(*(u32_t *)(pcVar11 + 4));
        if ((uVar8 == *puVar14) && (memset(dhcp_rx_options_given,0,10), 0x2b < p->len)) {
          uVar16 = (uint)p->tot_len;
          bVar3 = false;
          uVar18 = 0xf0;
          buf = p;
          goto LAB_2303da8a;
        }
        break;
      }
      puVar13 = (ip_data.current_input_netif)->hwaddr + uVar16;
      iVar17 = uVar16 + 0x1c;
      uVar16 = uVar16 + 1;
    } while (pcVar11[iVar17] == *puVar13);
  }
free_pbuf_and_return:
  pbuf_free(p);
  return;
LAB_2303da8a:
  do {
    uVar12 = (uint)buf->len;
    if (uVar18 < uVar12) {
      pvStack96 = buf->payload;
      uVar12 = uVar18;
LAB_2303dccc:
      if (uVar16 <= uVar12) goto LAB_2303dce2;
      bVar2 = *(byte *)((int)pvStack96 + uVar12);
      if (bVar2 == 0xff) goto LAB_2303dce2;
      uVar15 = uVar12 + 2 & 0xffff;
      if (uVar15 < uVar12) break;
      if (uVar12 + 1 < (uint)buf->len) {
        bVar1 = ((byte *)((int)pvStack96 + uVar12))[1];
LAB_2303db20:
        uVar10 = (uint)bVar1;
        if (bVar2 == 0x33) {
          if (bVar1 != 4) break;
          uVar5 = 4;
          iVar17 = 3;
        }
        else {
          if (bVar2 < 0x34) {
            if (bVar2 == 1) {
              if (bVar1 == 4) {
                uVar5 = 4;
                iVar17 = 6;
                goto LAB_2303dba6;
              }
              break;
            }
            if (bVar2 == 0) goto LAB_2303dc92;
            if (bVar2 != 3) goto LAB_2303db3e;
            if (uVar10 <= bVar2) break;
            iVar17 = 7;
            uVar5 = 4;
          }
          else {
            if (bVar2 == 0x36) {
LAB_2303dc78:
              if (uVar10 != 4) break;
              uVar5 = 4;
              iVar17 = 2;
            }
            else {
              if (bVar2 < 0x37) {
                if (bVar2 == 0x34) goto LAB_2303dc62;
LAB_2303db70:
                if (bVar2 == 0x35) {
                  if (uVar10 != 1) break;
                  uVar5 = 1;
                  iVar17 = 1;
                }
                else {
LAB_2303db42:
                  iVar17 = -1;
                  uVar5 = 0;
                }
              }
              else {
                if (bVar2 == 0x3a) goto LAB_2303dc86;
LAB_2303db8c:
                if (bVar2 != 0x3b) goto LAB_2303db42;
                if (uVar10 != 4) break;
                uVar5 = 4;
                iVar17 = 5;
              }
            }
          }
        }
      }
      else {
        if (buf->next != (pbuf *)0x0) {
          bVar1 = *(byte *)buf->next->payload;
          goto LAB_2303db20;
        }
        if (bVar2 == 0x33) break;
        if (bVar2 < 0x34) {
          if (bVar2 == 1) break;
          if (bVar2 != 0) {
            if (bVar2 != 3) {
              uVar10 = 0;
LAB_2303db3e:
              if (bVar2 != 6) goto LAB_2303db42;
              if ((uVar10 & 3) == 0) {
                uVar5 = uVar10;
                if (8 < uVar10) {
                  uVar5 = 8;
                }
                if (uVar5 <= uVar10) {
                  iVar17 = 8;
                  goto LAB_2303dba6;
                }
              }
            }
            break;
          }
LAB_2303dc92:
          uVar12 = uVar12 + 1 & 0xffff;
          goto LAB_2303dc9a;
        }
        if (bVar2 == 0x36) {
          uVar10 = 0;
          goto LAB_2303dc78;
        }
        if (bVar2 < 0x37) {
          if (bVar2 != 0x34) {
            uVar10 = 0;
            goto LAB_2303db70;
          }
          uVar10 = 0;
LAB_2303dc62:
          if ((uVar10 != 1) || (uVar18 != 0xf0)) break;
          uVar5 = 1;
          iVar17 = 0;
        }
        else {
          if (bVar2 != 0x3a) {
            uVar10 = 0;
            goto LAB_2303db8c;
          }
          uVar10 = 0;
LAB_2303dc86:
          if (uVar10 != 4) break;
          uVar5 = 4;
          iVar17 = 4;
        }
      }
LAB_2303dba6:
      if (0xfffd < uVar10 + uVar12) break;
      uVar12 = uVar10 + uVar15 & 0xffff;
      if (uVar5 != 0) {
        uStack68 = 0;
        puVar13 = dhcp_rx_options_given + iVar17;
        while (*puVar13 == '\0') {
          uVar10 = uVar5;
          if (4 < uVar5) {
            uVar10 = 4;
          }
          uVar7 = pbuf_copy_partial(buf,&uStack68,(u16_t)uVar10,(u16_t)uVar15);
          if (uVar10 != CONCAT22(extraout_var,uVar7)) goto free_pbuf_and_return;
          if (uVar5 < 5) {
            if (uVar5 == 4) {
              uStack68 = lwip_htonl(uStack68);
            }
            else {
              if (uVar5 != 1) goto free_pbuf_and_return;
              uStack68 = uStack68 & 0xff;
            }
            dhcp_rx_options_given[iVar17] = '\x01';
            dhcp_rx_options_val[iVar17] = uStack68;
            break;
          }
          if ((uVar5 & 3) != 0) goto free_pbuf_and_return;
          *puVar13 = '\x01';
          uVar8 = lwip_htonl(uStack68);
          dhcp_rx_options_val[iVar17] = uVar8;
          uVar10 = uVar15 + 4 & 0xffff;
          uVar5 = uVar5 - 4 & 0xff;
          puVar13 = puVar13 + 1;
          if (uVar10 < uVar15) goto free_pbuf_and_return;
          iVar17 = iVar17 + 1;
          uVar15 = uVar10;
        }
      }
LAB_2303dc9a:
      uVar15 = (uint)buf->len;
      if (uVar15 <= uVar12) {
        uVar12 = uVar12 - uVar15 & 0xffff;
        uVar16 = uVar16 - uVar15 & 0xffff;
        if ((uVar16 <= uVar12) || (buf = buf->next, buf == (pbuf *)0x0)) break;
        pvStack96 = buf->payload;
      }
      goto LAB_2303dccc;
    }
    pppVar4 = &buf->next;
    uVar18 = uVar18 - uVar12 & 0xffff;
    uVar16 = uVar16 - uVar12 & 0xffff;
    buf = *pppVar4;
  } while (*pppVar4 != (pbuf *)0x0);
  goto free_pbuf_and_return;
LAB_2303dce2:
  if (dhcp_rx_options_given[0] != '\0') {
    dhcp_rx_options_given[0] = '\0';
    if (dhcp_rx_options_val[0] == 1) {
LAB_2303dd96:
      uVar16 = 0xec;
      uVar18 = 0x6c;
      buf = p;
      goto LAB_2303da8a;
    }
    if (dhcp_rx_options_val[0] == 2) goto LAB_2303dd80;
    if (dhcp_rx_options_val[0] == 3) {
      bVar3 = true;
      goto LAB_2303dd96;
    }
  }
  if (!bVar3) {
    if (dhcp_rx_options_given[1] == '\0') goto free_pbuf_and_return;
    pvVar9 = p->payload;
    if ((char)dhcp_rx_options_val[1] != '\x05') {
      if ((char)dhcp_rx_options_val[1] == '\x06') {
        if (((byte)(*(char *)((int)puVar14 + 5) - 3U) < 3) ||
           (*(char *)((int)puVar14 + 5) == '\x01')) {
          dhcp_set_state((dhcp *)netif->client_data[0],'\f');
          netif_set_addr(netif,(ip4_addr_t *)&ip_addr_any,(ip4_addr_t *)&ip_addr_any,
                         (ip4_addr_t *)&ip_addr_any);
          dhcp_discover(netif);
        }
      }
      else {
        if ((((char)dhcp_rx_options_val[1] == '\x02') && (*(char *)((int)puVar14 + 5) == '\x06')) &&
           (dhcp_rx_options_given[2] != '\0')) {
          pvVar6 = netif->client_data[0];
          *(undefined2 *)((int)pvVar6 + 8) = 0;
          uVar8 = lwip_htonl(dhcp_rx_options_val[2]);
          *(u32_t *)((int)pvVar6 + 0x18) = uVar8;
          *(undefined4 *)((int)pvVar6 + 0x1c) = *(undefined4 *)((int)pvVar9 + 0x10);
          dhcp_select(netif);
        }
      }
      goto free_pbuf_and_return;
    }
    if (*(char *)((int)puVar14 + 5) == '\x01') {
      dhcp_handle_ack((dhcp_msg *)netif->client_data[0]);
      if ((netif->flags & 8) != 0) {
        dhcp_check(netif);
        goto free_pbuf_and_return;
      }
    }
    else {
      if (2 < (byte)(*(char *)((int)puVar14 + 5) - 3U)) goto free_pbuf_and_return;
      dhcp_handle_ack((dhcp_msg *)netif->client_data[0]);
    }
    dhcp_bind(netif);
    goto free_pbuf_and_return;
  }
LAB_2303dd80:
  bVar3 = false;
  uVar16 = 0x6c;
  uVar18 = 0x2c;
  buf = p;
  goto LAB_2303da8a;
}



void dhcp_network_changed(netif *netif)

{
  byte bVar1;
  void *pvVar2;
  
  pvVar2 = netif->client_data[0];
  if (pvVar2 == (void *)0x0) {
    return;
  }
  bVar1 = *(byte *)((int)pvVar2 + 5);
  if (bVar1 < 6) {
    if (2 < bVar1) {
LAB_2303dec6:
      *(undefined *)((int)pvVar2 + 6) = 0;
      dhcp_reboot(netif);
      return;
    }
    if (bVar1 == 0) {
      return;
    }
  }
  else {
    if (bVar1 == 10) goto LAB_2303dec6;
  }
  *(undefined *)((int)pvVar2 + 6) = 0;
  dhcp_discover(netif);
  return;
}



void dhcp_arp_reply(netif *netif,ip4_addr_t *addr)

{
  dhcp *dhcp;
  u8_t *options;
  pbuf *p_out;
  u32_t value;
  uint uVar1;
  u16_t options_out_len_00;
  u16_t auStack34 [2];
  u16_t options_out_len;
  
  if (netif != (netif *)0x0) {
    dhcp = (dhcp *)netif->client_data[0];
    if (((dhcp != (dhcp *)0x0) && (dhcp->state == '\b')) &&
       (addr->addr == (dhcp->offered_ip_addr).addr)) {
      dhcp_set_state(dhcp,'\f');
      p_out = dhcp_create_msg(netif,dhcp,'\x04',auStack34);
      if (p_out != (pbuf *)0x0) {
        uVar1 = (uint)auStack34[0];
        options = (u8_t *)((int)p_out->payload + 0xf0);
        options[uVar1] = '2';
        options[uVar1 + 1 & 0xffff] = '\x04';
        options_out_len_00 = (u16_t)((uVar1 + 2) * 0x10000 >> 0x10);
        auStack34[0] = options_out_len_00;
        value = lwip_htonl((dhcp->offered_ip_addr).addr);
        auStack34[0] = dhcp_option_long(options_out_len_00,options,value);
        dhcp_option_trailer(auStack34[0],options,p_out);
        udp_sendto_if_src(dhcp_pcb,p_out,&ip_addr_broadcast,0x43,netif,&ip_addr_any);
        pbuf_free(p_out);
      }
      if (dhcp->tries != -1) {
        dhcp->tries = dhcp->tries + '\x01';
      }
      dhcp->request_timeout = 0x14;
    }
    return;
  }
  return;
}



err_t dhcp_renew(netif *netif)

{
  u8_t *options;
  dhcp *dhcp;
  err_t eVar1;
  pbuf *p_out;
  undefined2 extraout_var;
  uint uVar2;
  int iVar3;
  u16_t auStack34 [2];
  u16_t options_out_len;
  
  dhcp = (dhcp *)netif->client_data[0];
  dhcp_set_state(dhcp,'\x05');
  p_out = dhcp_create_msg(netif,dhcp,'\x03',auStack34);
  eVar1 = -1;
  if (p_out != (pbuf *)0x0) {
    uVar2 = (uint)auStack34[0];
    options = (u8_t *)((int)p_out->payload + 0xf0);
    options[uVar2] = '9';
    options[uVar2 + 1 & 0xffff] = '\x02';
    auStack34[0] = (u16_t)((uVar2 + 2) * 0x10000 >> 0x10);
    auStack34[0] = dhcp_option_short(auStack34[0],options,netif->mtu);
    options[CONCAT22(extraout_var,auStack34[0])] = '7';
    options[CONCAT22(extraout_var,auStack34[0]) + 1U & 0xffff] = '\x04';
    auStack34[0] = auStack34[0] + 2;
    iVar3 = 0;
    do {
      options[(uint)auStack34[0]] = "\x01\x03\x1c\x06"[iVar3];
      auStack34[0] = (u16_t)(((uint)auStack34[0] + 1) * 0x10000 >> 0x10);
      iVar3 = iVar3 + 1;
    } while (iVar3 != 4);
    auStack34[0] = dhcp_option_hostname(auStack34[0],options);
    dhcp_option_trailer(auStack34[0],options,p_out);
    eVar1 = udp_sendto_if(dhcp_pcb,p_out,&dhcp->server_ip_addr,0x43,netif);
    pbuf_free(p_out);
  }
  if (dhcp->tries != -1) {
    dhcp->tries = dhcp->tries + '\x01';
  }
  if (dhcp->tries < 10) {
    uVar2 = (uint)dhcp->tries * 0x7d00000 >> 0x10;
  }
  else {
    uVar2 = 20000;
  }
  dhcp->request_timeout = (u16_t)((int)(uVar2 + 499) / 500);
  return eVar1;
}



u8_t dhcp_supplied_address(netif *netif)

{
  byte bVar1;
  bool bVar2;
  
  if ((netif != (netif *)0x0) && (netif->client_data[0] != (void *)0x0)) {
    bVar1 = *(byte *)((int)netif->client_data[0] + 5);
    bVar2 = true;
    if (bVar1 != 10) {
      bVar2 = (uint)bVar1 - 4 < 2;
    }
    return (u8_t)bVar2;
  }
  return '\0';
}



// WARNING: Type propagation algorithm not settling
// WARNING: Could not reconcile some variable overlaps

void dhcp_release_and_stop(netif *netif)

{
  dhcp *dhcp;
  u8_t uVar1;
  undefined3 extraout_var;
  pbuf *p_out;
  u32_t value;
  uint uVar2;
  u8_t *options;
  u16_t options_out_len_00;
  u16_t uStack38;
  u16_t options_out_len;
  ip_addr_t n;
  ip_addr_t server_ip_addr;
  
  dhcp = (dhcp *)netif->client_data[0];
  if ((dhcp != (dhcp *)0x0) && (dhcp->state != '\0')) {
    n = (ip_addr_t)(dhcp->server_ip_addr).addr;
    (dhcp->offered_ip_addr).addr = 0;
    (dhcp->server_ip_addr).addr = 0;
    (dhcp->offered_sn_mask).addr = 0;
    (dhcp->offered_gw_addr).addr = 0;
    dhcp->offered_t2_rebind = 0;
    dhcp->offered_t1_renew = 0;
    dhcp->offered_t0_lease = 0;
    dhcp->t1_renew_time = 0;
    *(undefined4 *)&dhcp->t2_rebind_time = 0;
    dhcp->t0_timeout = 0;
    uVar1 = dhcp_supplied_address(netif);
    if ((CONCAT31(extraout_var,uVar1) != 0) &&
       (p_out = dhcp_create_msg(netif,dhcp,'\a',&uStack38), p_out != (pbuf *)0x0)) {
      uVar2 = (uint)uStack38;
      options = (u8_t *)((int)p_out->payload + 0xf0);
      options[uVar2] = '6';
      options[uVar2 + 1 & 0xffff] = '\x04';
      options_out_len_00 = (u16_t)((uVar2 + 2) * 0x10000 >> 0x10);
      uStack38 = options_out_len_00;
      value = lwip_htonl((u32_t)n);
      uStack38 = dhcp_option_long(options_out_len_00,options,value);
      dhcp_option_trailer(uStack38,options,p_out);
      udp_sendto_if(dhcp_pcb,p_out,(ip_addr_t *)&stack0xffffffdc,0x43,netif);
      pbuf_free(p_out);
    }
    netif_set_addr(netif,(ip4_addr_t *)&ip_addr_any,(ip4_addr_t *)&ip_addr_any,
                   (ip4_addr_t *)&ip_addr_any);
    dhcp_set_state(dhcp,'\0');
    if (dhcp->pcb_allocated != '\0') {
      dhcp_dec_pcb_refcount();
      dhcp->pcb_allocated = '\0';
    }
  }
  return;
}



err_t dhcp_start(netif *netif)

{
  err_t eVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  dhcp *dhcp;
  
  if (netif == (netif *)0x0) {
    return -0x10;
  }
  if ((netif->flags & 1) == 0) {
    return -0x10;
  }
  dhcp = (dhcp *)netif->client_data[0];
  if (0x23f < netif->mtu) {
    if (dhcp == (dhcp *)0x0) {
      dhcp = (dhcp *)mem_malloc(0x34);
      if (dhcp == (dhcp *)0x0) {
        return -1;
      }
      *(dhcp **)netif->client_data = dhcp;
    }
    else {
      if (dhcp->pcb_allocated != '\0') {
        dhcp_dec_pcb_refcount();
      }
    }
    memset(dhcp,0,0x34);
    eVar1 = dhcp_inc_pcb_refcount();
    if (CONCAT31(extraout_var,eVar1) == 0) {
      dhcp->pcb_allocated = '\x01';
      if ((netif->flags & 4) == 0) {
        dhcp_set_state(dhcp,'\x02');
        return eVar1;
      }
      eVar1 = dhcp_discover(netif);
      if (CONCAT31(extraout_var_00,eVar1) == 0) {
        return eVar1;
      }
      dhcp_release_and_stop(netif);
    }
  }
  return -1;
}



void dhcp_coarse_tmr(void)

{
  short sVar1;
  netif *netif;
  dhcp *dhcp;
  pbuf *p_out;
  undefined2 extraout_var;
  uint uVar2;
  void *pvVar3;
  int iVar4;
  u8_t *options;
  u16_t auStack50 [2];
  u16_t options_out_len;
  
  netif = netif_list;
  while (netif != (netif *)0x0) {
    pvVar3 = netif->client_data[0];
    if ((pvVar3 != (void *)0x0) && (*(char *)((int)pvVar3 + 5) != '\0')) {
      if ((*(ushort *)((int)pvVar3 + 0x14) == 0) ||
         (uVar2 = (uint)*(ushort *)((int)pvVar3 + 0x12) + 1,
         *(undefined2 *)((int)pvVar3 + 0x12) = (short)(uVar2 * 0x10000 >> 0x10),
         (uint)*(ushort *)((int)pvVar3 + 0x14) != (uVar2 & 0xffff))) {
        sVar1 = *(short *)((int)pvVar3 + 0x10);
        if ((sVar1 == 0) || (*(short *)((int)pvVar3 + 0x10) = sVar1 + -1, sVar1 != 1)) {
          sVar1 = *(short *)((int)pvVar3 + 0xe);
          if ((sVar1 != 0) && (*(short *)((int)pvVar3 + 0xe) = sVar1 + -1, sVar1 == 1)) {
            pvVar3 = netif->client_data[0];
            if (((*(byte *)((int)pvVar3 + 5) & 0xfb) == 1) || (*(byte *)((int)pvVar3 + 5) == 10)) {
              dhcp_renew(netif);
              iVar4 = (uint)*(ushort *)((int)pvVar3 + 0xc) - (uint)*(ushort *)((int)pvVar3 + 0x12);
              if (1 < iVar4) {
                *(undefined2 *)((int)pvVar3 + 0xe) = (short)(iVar4 >> 1);
              }
            }
          }
        }
        else {
          dhcp = (dhcp *)netif->client_data[0];
          if ((dhcp->state < 0xb) && ((0x432U >> ((uint)dhcp->state & 0x1f) & 1) != 0)) {
            dhcp_set_state(dhcp,'\x04');
            p_out = dhcp_create_msg(netif,dhcp,'\x03',auStack50);
            if (p_out != (pbuf *)0x0) {
              uVar2 = (uint)auStack50[0];
              options = (u8_t *)((int)p_out->payload + 0xf0);
              options[uVar2] = '9';
              options[uVar2 + 1 & 0xffff] = '\x02';
              auStack50[0] = (u16_t)((uVar2 + 2) * 0x10000 >> 0x10);
              auStack50[0] = dhcp_option_short(auStack50[0],options,netif->mtu);
              options[CONCAT22(extraout_var,auStack50[0])] = '7';
              options[CONCAT22(extraout_var,auStack50[0]) + 1U & 0xffff] = '\x04';
              auStack50[0] = auStack50[0] + 2;
              iVar4 = 0;
              do {
                options[(uint)auStack50[0]] = "\x01\x03\x1c\x06"[iVar4];
                auStack50[0] = (u16_t)(((uint)auStack50[0] + 1) * 0x10000 >> 0x10);
                iVar4 = iVar4 + 1;
              } while (iVar4 != 4);
              auStack50[0] = dhcp_option_hostname(auStack50[0],options);
              dhcp_option_trailer(auStack50[0],options,p_out);
              udp_sendto_if(dhcp_pcb,p_out,&ip_addr_broadcast,0x43,netif);
              pbuf_free(p_out);
            }
            if (dhcp->tries != -1) {
              dhcp->tries = dhcp->tries + '\x01';
            }
            uVar2 = 10000;
            if (dhcp->tries < 10) {
              uVar2 = (uint)dhcp->tries * 0x3e80000 >> 0x10;
            }
            dhcp->request_timeout = (u16_t)((int)(uVar2 + 499) / 500);
            iVar4 = (uint)dhcp->t0_timeout - (uint)dhcp->lease_used;
            if (1 < iVar4) {
              dhcp->t2_rebind_time = (u16_t)(iVar4 >> 1);
            }
          }
        }
      }
      else {
        dhcp_release_and_stop(netif);
        dhcp_start(netif);
      }
    }
    netif = netif->next;
  }
  return;
}



void dhcp_fine_tmr(void)

{
  char cVar1;
  ushort uVar2;
  netif *netif;
  void *pvVar3;
  
  netif = netif_list;
  do {
    if (netif == (netif *)0x0) {
      return;
    }
    pvVar3 = netif->client_data[0];
    if (pvVar3 != (void *)0x0) {
      uVar2 = *(ushort *)((int)pvVar3 + 8);
      if (uVar2 < 2) {
        if (uVar2 == 1) {
          *(undefined2 *)((int)pvVar3 + 8) = 0;
          pvVar3 = netif->client_data[0];
          cVar1 = *(char *)((int)pvVar3 + 5);
          if ((cVar1 == '\f') || (cVar1 == '\x06')) {
LAB_2303e534:
            dhcp_discover(netif);
          }
          else {
            if (cVar1 == '\x01') {
              if (*(byte *)((int)pvVar3 + 6) < 6) {
                dhcp_select(netif);
              }
              else {
                dhcp_release_and_stop(netif);
                dhcp_start(netif);
              }
            }
            else {
              if (cVar1 == '\b') {
                if (*(byte *)((int)pvVar3 + 6) < 2) {
                  dhcp_check(netif);
                }
                else {
                  dhcp_bind(netif);
                }
              }
              else {
                if (cVar1 == '\x03') {
                  if (1 < *(byte *)((int)pvVar3 + 6)) goto LAB_2303e534;
                  dhcp_reboot(netif);
                }
              }
            }
          }
        }
      }
      else {
        *(short *)((int)pvVar3 + 8) = uVar2 - 1;
      }
    }
    netif = netif->next;
  } while( true );
}



// WARNING: Type propagation algorithm not settling

void dhcp_stop(netif *netif)

{
  dhcp *dhcp;
  u8_t uVar1;
  undefined3 extraout_var;
  pbuf *p_out;
  u32_t value;
  uint uVar2;
  u8_t *options;
  u16_t options_out_len;
  u16_t uStack38;
  ip_addr_t aiStack36 [3];
  
  dhcp = (dhcp *)netif->client_data[0];
  if ((dhcp != (dhcp *)0x0) && (dhcp->state != '\0')) {
    aiStack36[0] = (ip_addr_t)(dhcp->server_ip_addr).addr;
    (dhcp->offered_ip_addr).addr = 0;
    (dhcp->server_ip_addr).addr = 0;
    (dhcp->offered_sn_mask).addr = 0;
    (dhcp->offered_gw_addr).addr = 0;
    dhcp->offered_t2_rebind = 0;
    dhcp->offered_t1_renew = 0;
    dhcp->offered_t0_lease = 0;
    dhcp->t1_renew_time = 0;
    *(undefined4 *)&dhcp->t2_rebind_time = 0;
    dhcp->t0_timeout = 0;
    uVar1 = dhcp_supplied_address(netif);
    if ((CONCAT31(extraout_var,uVar1) != 0) &&
       (p_out = dhcp_create_msg(netif,dhcp,'\a',&uStack38), p_out != (pbuf *)0x0)) {
      uVar2 = (uint)uStack38;
      options = (u8_t *)((int)p_out->payload + 0xf0);
      options[uVar2] = '6';
      options[uVar2 + 1 & 0xffff] = '\x04';
      options_out_len = (u16_t)((uVar2 + 2) * 0x10000 >> 0x10);
      uStack38 = options_out_len;
      value = lwip_htonl((u32_t)aiStack36[0]);
      uStack38 = dhcp_option_long(options_out_len,options,value);
      dhcp_option_trailer(uStack38,options,p_out);
      udp_sendto_if(dhcp_pcb,p_out,aiStack36,0x43,netif);
      pbuf_free(p_out);
    }
    netif_set_addr(netif,(ip4_addr_t *)&ip_addr_any,(ip4_addr_t *)&ip_addr_any,
                   (ip4_addr_t *)&ip_addr_any);
    dhcp_set_state(dhcp,'\0');
    if (dhcp->pcb_allocated != '\0') {
      dhcp_dec_pcb_refcount();
      dhcp->pcb_allocated = '\0';
    }
  }
  return;
}



void etharp_free_entry(int i)

{
  pbuf *p;
  
  p = arp_table[i].q;
  if (p != (pbuf *)0x0) {
    pbuf_free(p);
    arp_table[i].q = (pbuf *)0x0;
  }
  arp_table[i].state = '\0';
  return;
}



s16_t etharp_find_entry(ip4_addr_t *ipaddr,u8_t flags,netif *netif)

{
  ushort uVar1;
  ushort uVar2;
  int iVar3;
  int iVar4;
  int i;
  undefined3 in_register_0000202d;
  etharp_entry *peVar5;
  int iVar6;
  s16_t sVar7;
  int iVar8;
  uint uVar9;
  int iVar10;
  ushort uVar11;
  ushort uVar12;
  
  peVar5 = arp_table;
  uVar2 = 0;
  uVar12 = 0;
  uVar11 = 0;
  iVar3 = 10;
  iVar8 = 0;
  iVar10 = 10;
  iVar4 = 10;
  iVar6 = 10;
  do {
    i = iVar6;
    if (iVar6 == 10) {
      i = iVar8;
    }
    if (peVar5->state != '\0') {
      if ((ipaddr != (ip4_addr_t *)0x0) && (ipaddr->addr == (peVar5->ipaddr).addr)) {
        if (netif == (netif *)0x0) {
          return (s16_t)iVar8;
        }
        if (peVar5->netif == netif) {
          return (s16_t)iVar8;
        }
      }
      uVar1 = peVar5->ctime;
      if (peVar5->state == '\x01') {
        if (peVar5->q == (pbuf *)0x0) {
          i = iVar6;
          if (uVar12 <= uVar1) {
            iVar4 = iVar8;
            uVar12 = uVar1;
          }
        }
        else {
          i = iVar6;
          if (uVar11 <= uVar1) {
            iVar3 = iVar8;
            uVar11 = uVar1;
          }
        }
      }
      else {
        i = iVar6;
        if (uVar2 <= uVar1) {
          iVar10 = iVar8;
          uVar2 = uVar1;
        }
      }
    }
    uVar9 = iVar8 + 1U & 0xffff;
    peVar5 = peVar5 + 1;
    iVar8 = (int)(short)uVar9;
    iVar6 = i;
    if (uVar9 == 10) {
      sVar7 = -1;
      if (CONCAT31(in_register_0000202d,flags) == 1) {
        if (i == 10) {
          i = iVar10;
          if (((iVar10 == 10) && (i = iVar4, iVar4 == 10)) && (i = iVar3, iVar3 == 10)) {
            return -1;
          }
          etharp_free_entry(i);
        }
        sVar7 = (s16_t)i;
        if (ipaddr != (ip4_addr_t *)0x0) {
          arp_table[i].ipaddr.addr = ipaddr->addr;
        }
        arp_table[i].ctime = 0;
        arp_table[i].netif = netif;
      }
      return sVar7;
    }
  } while( true );
}



err_t etharp_raw(netif *netif,eth_addr *ethsrc_addr,eth_addr *ethdst_addr,eth_addr *hwsrc_addr,
                ip4_addr_t *ipsrc_addr,eth_addr *hwdst_addr,ip4_addr_t *ipdst_addr,u16_t opcode)

{
  undefined *puVar1;
  err_t eVar2;
  u16_t uVar3;
  pbuf *p;
  
  p = pbuf_alloc(PBUF_LINK,0x1c,PBUF_RAM);
  if (p == (pbuf *)0x0) {
    eVar2 = -1;
    lwip_stats.etharp.memerr = lwip_stats.etharp.memerr + 1;
  }
  else {
    puVar1 = (undefined *)p->payload;
    uVar3 = lwip_htons(opcode);
    puVar1[6] = (char)uVar3;
    puVar1[7] = (char)(uVar3 >> 8);
    memcpy(puVar1 + 8,hwsrc_addr,6);
    memcpy(puVar1 + 0x12,hwdst_addr,6);
    memcpy(puVar1 + 0xe,ipsrc_addr,4);
    memcpy(puVar1 + 0x18,ipdst_addr,4);
    puVar1[1] = 1;
    puVar1[2] = 8;
    puVar1[4] = 6;
    puVar1[5] = 4;
    *puVar1 = 0;
    puVar1[3] = 0;
    ethernet_output(netif,p,ethsrc_addr,ethdst_addr,0x806);
    lwip_stats.etharp.xmit = lwip_stats.etharp.xmit + 1;
    pbuf_free(p);
    eVar2 = '\0';
  }
  return eVar2;
}



void etharp_cleanup_netif(netif *netif)

{
  etharp_entry *peVar1;
  int i;
  
  peVar1 = arp_table;
  i = 0;
  do {
    if ((peVar1->state != '\0') && (peVar1->netif == netif)) {
      etharp_free_entry(i);
    }
    i = i + 1;
    peVar1 = peVar1 + 1;
  } while (i != 10);
  return;
}



// WARNING: Type propagation algorithm not settling

void etharp_input(pbuf *p,netif *netif)

{
  bool bVar1;
  short *psVar2;
  u8_t uVar3;
  s16_t sVar4;
  undefined3 extraout_var;
  short extraout_var_00;
  ip4_addr_t iVar5;
  eth_addr *dst;
  u8_t flags;
  pbuf *p_00;
  ip4_addr_t iStack56;
  ip4_addr_t sipaddr;
  ip4_addr_t dipaddr;
  
  if (netif != (netif *)0x0) {
    psVar2 = (short *)p->payload;
    if ((((*psVar2 == 0x100) && (*(char *)(psVar2 + 2) == '\x06')) &&
        (*(char *)((int)psVar2 + 5) == '\x04')) && (psVar2[1] == 8)) {
      lwip_stats.etharp.recv = lwip_stats.etharp.recv + 1;
      memcpy(&iStack56,psVar2 + 7,4);
      memcpy(&sipaddr,psVar2 + 0xc,4);
      iVar5 = (ip4_addr_t)(netif->ip_addr).addr;
      dst = (eth_addr *)(psVar2 + 4);
      if ((iVar5 == (ip4_addr_t)0x0) || (iVar5 != (ip4_addr_t)sipaddr)) {
        bVar1 = false;
        flags = '\x02';
      }
      else {
        bVar1 = true;
        flags = '\x01';
      }
      if (((iStack56 != (ip4_addr_t)0x0) &&
          (uVar3 = ip4_addr_isbroadcast_u32((u32_t)iStack56,netif),
          CONCAT31(extraout_var,uVar3) == 0)) && (((uint)iStack56 & 0xf0) != 0xe0)) {
        sVar4 = etharp_find_entry(&iStack56,flags,netif);
        _sVar4 = CONCAT22(extraout_var_00,sVar4);
        if (-1 < extraout_var_00) {
          arp_table[_sVar4].state = '\x02';
          arp_table[_sVar4].netif = netif;
          memcpy(&arp_table[_sVar4].ethaddr,dst,6);
          p_00 = arp_table[_sVar4].q;
          arp_table[_sVar4].ctime = 0;
          if (p_00 != (pbuf *)0x0) {
            arp_table[_sVar4].q = (pbuf *)0x0;
            ethernet_output(netif,p_00,(eth_addr *)netif->hwaddr,dst,0x800);
            pbuf_free(p_00);
          }
        }
      }
      if (psVar2[3] == 0x100) {
        if (bVar1) {
          etharp_raw(netif,(eth_addr *)netif->hwaddr,dst,(eth_addr *)netif->hwaddr,
                     (ip4_addr_t *)&netif->ip_addr,dst,&iStack56,2);
        }
      }
      else {
        if (psVar2[3] == 0x200) {
          dhcp_arp_reply(netif,&iStack56);
        }
        else {
          lwip_stats.etharp.err = lwip_stats.etharp.err + 1;
        }
      }
    }
    else {
      lwip_stats.etharp.proterr = lwip_stats.etharp.proterr + 1;
      lwip_stats.etharp.drop = lwip_stats.etharp.drop + 1;
    }
    pbuf_free(p);
    return;
  }
  return;
}



err_t etharp_request(netif *netif,ip4_addr_t *ipaddr)

{
  err_t eVar1;
  
  eVar1 = etharp_raw(netif,(eth_addr *)netif->hwaddr,&ethbroadcast,(eth_addr *)netif->hwaddr,
                     (ip4_addr_t *)&netif->ip_addr,&ethzero,ipaddr,1);
  return eVar1;
}



void etharp_tmr(void)

{
  u8_t uVar1;
  etharp_entry *peVar2;
  int i;
  uint uVar3;
  uint uVar4;
  
  peVar2 = arp_table;
  i = 0;
  do {
    uVar1 = peVar2->state;
    if (uVar1 != '\0') {
      uVar3 = (uint)peVar2->ctime + 1;
      uVar4 = uVar3 & 0xffff;
      peVar2->ctime = (u16_t)(uVar3 * 0x10000 >> 0x10);
      if (uVar4 < 300) {
        if (uVar1 == '\x01') {
          if (4 < uVar4) goto LAB_2303ea08;
          etharp_request(peVar2->netif,&peVar2->ipaddr);
        }
        else {
          if (uVar1 == '\x03') {
            peVar2->state = '\x04';
          }
          else {
            if (uVar1 == '\x04') {
              peVar2->state = '\x02';
            }
          }
        }
      }
      else {
LAB_2303ea08:
        etharp_free_entry(i);
      }
    }
    i = i + 1;
    peVar2 = peVar2 + 1;
    if (i == 10) {
      return;
    }
  } while( true );
}



err_t etharp_output_to_arp_index(netif *netif,pbuf *q,netif_addr_idx_t arp_idx)

{
  err_t eVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 in_register_00002031;
  int iVar2;
  eth_addr *ethsrc_addr;
  
  iVar2 = CONCAT31(in_register_00002031,arp_idx);
  ethsrc_addr = (eth_addr *)netif->hwaddr;
  if (arp_table[iVar2].state == '\x02') {
    if (arp_table[iVar2].ctime < 0x11d) {
      if (arp_table[iVar2].ctime < 0x10e) goto LAB_2303eaa0;
      eVar1 = etharp_raw(netif,ethsrc_addr,&arp_table[iVar2].ethaddr,ethsrc_addr,
                         (ip4_addr_t *)&netif->ip_addr,&ethzero,&arp_table[iVar2].ipaddr,1);
      _eVar1 = CONCAT31(extraout_var_00,eVar1);
    }
    else {
      eVar1 = etharp_request(netif,&arp_table[iVar2].ipaddr);
      _eVar1 = CONCAT31(extraout_var,eVar1);
    }
    if (_eVar1 == 0) {
      arp_table[iVar2].state = '\x03';
    }
  }
LAB_2303eaa0:
  eVar1 = ethernet_output(netif,q,ethsrc_addr,&arp_table[iVar2].ethaddr,0x800);
  return eVar1;
}



err_t etharp_query(netif *netif,ip4_addr_t *ipaddr,pbuf *q)

{
  pbuf **pppVar1;
  u8_t uVar2;
  err_t eVar3;
  ushort uVar4;
  undefined3 extraout_var;
  short extraout_var_00;
  pbuf *ppVar5;
  uint uVar6;
  
  uVar2 = ip4_addr_isbroadcast_u32(ipaddr->addr,netif);
  if (((CONCAT31(extraout_var,uVar2) != 0) || ((ipaddr->addr & 0xf0) == 0xe0)) ||
     (ipaddr->addr == 0)) {
    return -0x10;
  }
  uVar4 = etharp_find_entry(ipaddr,'\x01',netif);
  if (extraout_var_00 < 0) {
    if (q != (pbuf *)0x0) {
      lwip_stats.etharp.memerr = lwip_stats.etharp.memerr + 1;
    }
    return (err_t)uVar4;
  }
  uVar6 = (uint)uVar4 & 0xff;
  if (arp_table[uVar6].state == '\0') {
    arp_table[uVar6].state = '\x01';
    arp_table[uVar6].netif = netif;
  }
  else {
    eVar3 = -1;
    if (q != (pbuf *)0x0) goto LAB_2303eb7e;
  }
  eVar3 = etharp_request(netif,ipaddr);
  if (q == (pbuf *)0x0) {
    return eVar3;
  }
LAB_2303eb7e:
  if (1 < arp_table[uVar6].state) {
    etharp_cached_entry = (netif_addr_idx_t)uVar6;
    eVar3 = ethernet_output(netif,q,(eth_addr *)netif->hwaddr,&arp_table[uVar6].ethaddr,0x800);
    return eVar3;
  }
  ppVar5 = q;
  if (arp_table[uVar6].state == 1) {
    do {
      if ((ppVar5->type_internal & 0x40) != 0) {
        q = pbuf_clone(PBUF_LINK,PBUF_RAM,q);
        if (q == (pbuf *)0x0) {
          lwip_stats.etharp.memerr = lwip_stats.etharp.memerr + 1;
          return -1;
        }
        goto LAB_2303ebe4;
      }
      pppVar1 = &ppVar5->next;
      ppVar5 = *pppVar1;
    } while (*pppVar1 != (pbuf *)0x0);
    pbuf_ref(q);
LAB_2303ebe4:
    if (arp_table[uVar6].q != (pbuf *)0x0) {
      pbuf_free(arp_table[uVar6].q);
    }
    arp_table[uVar6].q = q;
    eVar3 = '\0';
  }
  return eVar3;
}



// WARNING: Variable defined which should be unmapped: mcastaddr

err_t etharp_output(netif *netif,pbuf *q,ip4_addr_t *ipaddr)

{
  netif_addr_idx_t nVar1;
  u8_t uVar2;
  err_t eVar3;
  undefined3 extraout_var;
  eth_addr *dst;
  uint uVar4;
  uint uVar5;
  etharp_entry *peVar6;
  undefined2 uStack24;
  u8_t uStack22;
  byte bStack21;
  eth_addr mcastaddr;
  
  uVar2 = ip4_addr_isbroadcast_u32(ipaddr->addr,netif);
  uVar4 = CONCAT31(extraout_var,uVar2);
  if (uVar4 == 0) {
    uVar5 = ipaddr->addr;
    if ((uVar5 & 0xf0) != 0xe0) {
      if (((((netif->ip_addr).addr ^ uVar5) & (netif->netmask).addr) != 0) &&
         ((uVar5 & 0xffff) != 0xfea9)) {
        if ((netif->gw).addr == 0) {
          return -4;
        }
        ipaddr = (ip4_addr_t *)&netif->gw;
      }
      uVar5 = (uint)etharp_cached_entry;
      peVar6 = arp_table;
      if (((arp_table[uVar5].state < 2) || (arp_table[uVar5].netif != netif)) ||
         (ipaddr->addr != arp_table[uVar5].ipaddr.addr)) {
        while (((peVar6->state < 2 || (peVar6->netif != netif)) ||
               (nVar1 = (netif_addr_idx_t)uVar4, ipaddr->addr != (peVar6->ipaddr).addr))) {
          uVar4 = uVar4 + 1 & 0xff;
          peVar6 = peVar6 + 1;
          if (uVar4 == 10) {
            eVar3 = etharp_query(netif,ipaddr,q);
            return eVar3;
          }
        }
      }
      else {
        lwip_stats.etharp.cachehit = lwip_stats.etharp.cachehit + 1;
        nVar1 = etharp_cached_entry;
      }
      etharp_cached_entry = nVar1;
      eVar3 = etharp_output_to_arp_index(netif,q,etharp_cached_entry);
      return eVar3;
    }
    uStack24 = 1;
    uStack22 = '^';
    dst = (eth_addr *)&uStack24;
    bStack21 = *(byte *)((int)&ipaddr->addr + 1) & 0x7f;
    mcastaddr.addr[0] = *(u8_t *)((int)&ipaddr->addr + 2);
    mcastaddr.addr[1] = *(u8_t *)((int)&ipaddr->addr + 3);
  }
  else {
    dst = &ethbroadcast;
  }
  eVar3 = ethernet_output(netif,q,(eth_addr *)netif->hwaddr,dst,0x800);
  return eVar3;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void igmp_send(netif *netif,igmp_group *group,u8_t type)

{
  u8_t *dataptr;
  u16_t uVar1;
  pbuf *p;
  undefined3 in_register_00002031;
  ip4_addr_t *dest;
  u8_t uVar2;
  u8_t uVar3;
  u8_t uVar4;
  u32_t uVar5;
  ip4_addr_t iStack40;
  ip4_addr_t src;
  u16_t ra [2];
  
  iStack40 = (ip4_addr_t)0;
  p = pbuf_alloc(PBUF_TRANSPORT,8,PBUF_RAM);
  if (p == (pbuf *)0x0) {
    lwip_stats.igmp.memerr = lwip_stats.igmp.memerr + 1;
  }
  else {
    iStack40 = (ip4_addr_t)(netif->ip_addr).addr;
    uVar5 = (group->group_address).addr;
    dataptr = (u8_t *)p->payload;
    uVar4 = (u8_t)(uVar5 >> 0x18);
    uVar2 = (u8_t)(uVar5 >> 8);
    uVar3 = (u8_t)(uVar5 >> 0x10);
    if (CONCAT31(in_register_00002031,type) == 0x16) {
      dataptr[7] = uVar4;
      dataptr[4] = (u8_t)uVar5;
      dataptr[5] = uVar2;
      dataptr[6] = uVar3;
      dest = &group->group_address;
      group->last_reporter_flag = '\x01';
    }
    else {
      dataptr[4] = (u8_t)uVar5;
      dataptr[5] = uVar2;
      dataptr[6] = uVar3;
      dataptr[7] = uVar4;
      dest = &allrouters;
    }
    *dataptr = type;
    dataptr[1] = '\0';
    dataptr[2] = '\0';
    dataptr[3] = '\0';
    uVar1 = inet_chksum(dataptr,8);
    dataptr[2] = (u8_t)uVar1;
    dataptr[3] = (u8_t)(uVar1 >> 8);
    src = 0x494;
    lwip_stats.igmp.xmit = lwip_stats.igmp.xmit + 1;
    ip4_output_if_opt(p,&iStack40,dest,'\x01','\0','\x02',netif,&src,_DAT_00000010);
    pbuf_free(p);
  }
  return;
}



void igmp_delaying_member(igmp_group *group,u8_t maxresp)

{
  uint uVar1;
  undefined3 in_register_0000202d;
  uint uVar2;
  
  uVar2 = CONCAT31(in_register_0000202d,maxresp);
  if ((group->group_state != '\x02') &&
     ((group->group_state != '\x01' || ((group->timer != 0 && (group->timer <= uVar2)))))) {
    return;
  }
  if (2 < uVar2) {
    uVar1 = bl_rand();
    group->timer = (u16_t)(uVar1 % uVar2);
    if (uVar1 % uVar2 != 0) goto LAB_2303ee92;
  }
  group->timer = 1;
LAB_2303ee92:
  group->group_state = '\x01';
  return;
}



void igmp_init(void)

{
  allrouters = 0x20000e0;
  allsystems = 0x10000e0;
  return;
}



err_t igmp_stop(netif *netif)

{
  void **mem;
  void *pvVar1;
  
  mem = (void **)netif->client_data[1];
  netif->client_data[1] = (void *)0x0;
  while (mem != (void **)0x0) {
    pvVar1 = *mem;
    if (netif->igmp_mac_filter != (netif_igmp_mac_filter_fn *)0x0) {
      (*netif->igmp_mac_filter)(netif,(ip4_addr_t *)(mem + 1),NETIF_DEL_MAC_FILTER);
    }
    memp_free(MEMP_IGMP_GROUP,mem);
    mem = (void **)pvVar1;
  }
  return '\0';
}



// WARNING: Type propagation algorithm not settling

void igmp_report_groups(netif *netif)

{
  igmp_group *group;
  
  if ((igmp_group *)netif->client_data[1] != (igmp_group *)0x0) {
    group = ((igmp_group *)netif->client_data[1])->next;
    while (group != (igmp_group *)0x0) {
      igmp_delaying_member(group,'\x05');
      group = group->next;
    }
    return;
  }
  return;
}



igmp_group * igmp_lookfor_group(netif *ifp,ip4_addr_t *addr)

{
  igmp_group *piVar1;
  
  piVar1 = (igmp_group *)ifp->client_data[1];
  while ((piVar1 != (igmp_group *)0x0 && ((piVar1->group_address).addr != addr->addr))) {
    piVar1 = piVar1->next;
  }
  return piVar1;
}



// WARNING: Type propagation algorithm not settling

igmp_group * igmp_lookup_group(netif *ifp,ip4_addr_t *addr)

{
  igmp_group *piVar1;
  igmp_group *piVar2;
  u32_t uVar3;
  
  piVar2 = igmp_lookfor_group(ifp,addr);
  if (piVar2 == (igmp_group *)0x0) {
    piVar1 = (igmp_group *)ifp->client_data[1];
    piVar2 = (igmp_group *)memp_malloc(MEMP_IGMP_GROUP);
    if (piVar2 != (igmp_group *)0x0) {
      uVar3 = 0;
      if (addr != (ip4_addr_t *)0x0) {
        uVar3 = addr->addr;
      }
      (piVar2->group_address).addr = uVar3;
      *(undefined4 *)&piVar2->last_reporter_flag = 0;
      piVar2->use = '\0';
      if (piVar1 == (igmp_group *)0x0) {
        piVar2->next = (igmp_group *)0x0;
        *(igmp_group **)(ifp->client_data + 1) = piVar2;
      }
      else {
        piVar2->next = piVar1->next;
        piVar1->next = piVar2;
      }
    }
  }
  return piVar2;
}



err_t igmp_start(netif *netif)

{
  err_t eVar1;
  igmp_group *piVar2;
  
  piVar2 = igmp_lookup_group(netif,&allsystems);
  if (piVar2 == (igmp_group *)0x0) {
    eVar1 = -1;
  }
  else {
    piVar2->group_state = '\x02';
    piVar2->use = piVar2->use + '\x01';
    eVar1 = '\0';
    if (netif->igmp_mac_filter != (netif_igmp_mac_filter_fn *)0x0) {
      (*netif->igmp_mac_filter)(netif,&allsystems,NETIF_ADD_MAC_FILTER);
      eVar1 = '\0';
    }
  }
  return eVar1;
}



// WARNING: Type propagation algorithm not settling

void igmp_input(pbuf *p,netif *inp,ip4_addr_t *dest)

{
  ip4_addr_t iVar1;
  char *dataptr;
  u16_t uVar2;
  undefined2 extraout_var;
  igmp_group *group;
  ip4_addr_t iStack36;
  ip4_addr_t groupaddr;
  
  lwip_stats.igmp.recv = lwip_stats.igmp.recv + 1;
  if (p->len < 8) {
    pbuf_free(p);
    lwip_stats.igmp.lenerr = lwip_stats.igmp.lenerr + 1;
    return;
  }
  dataptr = (char *)p->payload;
  uVar2 = inet_chksum(dataptr,p->len);
  if (CONCAT22(extraout_var,uVar2) != 0) {
    pbuf_free(p);
    lwip_stats.igmp.chkerr = lwip_stats.igmp.chkerr + 1;
    return;
  }
  group = igmp_lookfor_group(inp,dest);
  if (group == (igmp_group *)0x0) {
    pbuf_free(p);
    lwip_stats.igmp.drop = lwip_stats.igmp.drop + 1;
    return;
  }
  if (*dataptr == '\x11') {
    iVar1 = (ip4_addr_t)((ip4_addr_t *)(dataptr + 4))->addr;
    if (dest->addr == allsystems) {
      if (iVar1 == (ip4_addr_t)0x0) {
        if (dataptr[1] == '\0') {
          lwip_stats.igmp.rx_v1 = lwip_stats.igmp.rx_v1 + 1;
          dataptr[1] = '\n';
        }
        else {
          lwip_stats.igmp.rx_general = lwip_stats.igmp.rx_general + 1;
        }
        if ((igmp_group *)inp->client_data[1] != (igmp_group *)0x0) {
          group = ((igmp_group *)inp->client_data[1])->next;
          while (group != (igmp_group *)0x0) {
            igmp_delaying_member(group,dataptr[1]);
            group = group->next;
          }
        }
        goto LAB_2303f0da;
      }
      iStack36 = iVar1;
      group = igmp_lookfor_group(inp,&iStack36);
      if (group == (igmp_group *)0x0) {
        lwip_stats.igmp.drop = lwip_stats.igmp.drop + 1;
        goto LAB_2303f0da;
      }
    }
    else {
      if (iVar1 == (ip4_addr_t)0x0) goto LAB_2303f07c;
    }
    lwip_stats.igmp.rx_group = lwip_stats.igmp.rx_group + 1;
    igmp_delaying_member(group,dataptr[1]);
  }
  else {
    if (*dataptr == '\x16') {
      lwip_stats.igmp.rx_report = lwip_stats.igmp.rx_report + 1;
      if (group->group_state == '\x01') {
        *(undefined4 *)&group->last_reporter_flag = 0x200;
      }
      goto LAB_2303f0da;
    }
LAB_2303f07c:
    lwip_stats.igmp.proterr = lwip_stats.igmp.proterr + 1;
  }
LAB_2303f0da:
  pbuf_free(p);
  return;
}



err_t igmp_joingroup_netif(netif *netif,ip4_addr_t *groupaddr)

{
  u16_t uVar1;
  igmp_group *group;
  uint uVar2;
  err_t eVar3;
  
  if (((groupaddr->addr & 0xf0) == 0xe0) && (eVar3 = -6, groupaddr->addr != allsystems)) {
    if ((netif->flags & 0x20) != 0) {
      group = igmp_lookup_group(netif,groupaddr);
      eVar3 = -1;
      if (group != (igmp_group *)0x0) {
        if (group->group_state == '\0') {
          if ((group->use == '\0') && (netif->igmp_mac_filter != (netif_igmp_mac_filter_fn *)0x0)) {
            (*netif->igmp_mac_filter)(netif,groupaddr,NETIF_ADD_MAC_FILTER);
          }
          lwip_stats.igmp.tx_join = lwip_stats.igmp.tx_join + 1;
          igmp_send(netif,group,'\x16');
          uVar2 = bl_rand();
          uVar1 = (u16_t)(uVar2 % 5);
          if (uVar2 % 5 == 0) {
            uVar1 = 1;
          }
          group->timer = uVar1;
          group->group_state = '\x01';
        }
        group->use = group->use + '\x01';
        eVar3 = '\0';
      }
    }
    return eVar3;
  }
  return -6;
}



err_t igmp_joingroup(ip4_addr_t *ifaddr,ip4_addr_t *groupaddr)

{
  netif *netif;
  err_t eVar1;
  int iVar2;
  undefined3 extraout_var;
  
  if ((groupaddr->addr & 0xf0) != 0xe0) {
    return -6;
  }
  iVar2 = -6;
  eVar1 = -6;
  netif = netif_list;
  if (groupaddr->addr != allsystems) {
    while (eVar1 = (err_t)iVar2, netif != (netif *)0x0) {
      if (((netif->flags & 0x20) != 0) &&
         (((ifaddr == (ip4_addr_t *)0x0 || (ifaddr->addr == 0)) ||
          (ifaddr->addr == (netif->ip_addr).addr)))) {
        eVar1 = igmp_joingroup_netif(netif,groupaddr);
        iVar2 = CONCAT31(extraout_var,eVar1);
        if (iVar2 != 0) {
          return eVar1;
        }
      }
      netif = netif->next;
    }
  }
  return eVar1;
}



err_t igmp_leavegroup_netif(netif *netif,ip4_addr_t *groupaddr)

{
  igmp_group *piVar1;
  igmp_group *group;
  err_t eVar2;
  igmp_group *piVar3;
  
  if (((groupaddr->addr & 0xf0) != 0xe0) || (eVar2 = -6, groupaddr->addr == allsystems)) {
    return -6;
  }
  if ((netif->flags & 0x20) != 0) {
    group = igmp_lookfor_group(netif,groupaddr);
    eVar2 = -6;
    if (group != (igmp_group *)0x0) {
      if (group->use < 2) {
        piVar1 = (igmp_group *)netif->client_data[1];
        do {
          piVar3 = piVar1;
          if (piVar3 == (igmp_group *)0x0) goto LAB_2303f2b0;
          piVar1 = piVar3->next;
        } while (group != piVar3->next);
        piVar3->next = group->next;
LAB_2303f2b0:
        if (group->last_reporter_flag != '\0') {
          lwip_stats.igmp.tx_leave = lwip_stats.igmp.tx_leave + 1;
          igmp_send(netif,group,'\x17');
        }
        if (netif->igmp_mac_filter != (netif_igmp_mac_filter_fn *)0x0) {
          (*netif->igmp_mac_filter)(netif,groupaddr,NETIF_DEL_MAC_FILTER);
        }
        memp_free(MEMP_IGMP_GROUP,group);
      }
      else {
        group->use = group->use - 1;
      }
      eVar2 = '\0';
    }
  }
  return eVar2;
}



err_t igmp_leavegroup(ip4_addr_t *ifaddr,ip4_addr_t *groupaddr)

{
  netif *netif;
  int iVar1;
  err_t eVar2;
  undefined3 extraout_var;
  
  eVar2 = -6;
  if ((groupaddr->addr & 0xf0) == 0xe0) {
    iVar1 = -6;
    eVar2 = -6;
    netif = netif_list;
    if (groupaddr->addr != allsystems) {
      while (eVar2 = (err_t)iVar1, netif != (netif *)0x0) {
        if (((netif->flags & 0x20) != 0) &&
           (((ifaddr == (ip4_addr_t *)0x0 || (ifaddr->addr == 0)) ||
            (ifaddr->addr == (netif->ip_addr).addr)))) {
          eVar2 = igmp_leavegroup_netif(netif,groupaddr);
          if (iVar1 != 0) {
            iVar1 = CONCAT31(extraout_var,eVar2);
          }
        }
        netif = netif->next;
      }
    }
  }
  return eVar2;
}



void igmp_tmr(void)

{
  igmp_group *group;
  netif *netif;
  uint uVar1;
  
  netif = netif_list;
  while (netif != (netif *)0x0) {
    group = (igmp_group *)netif->client_data[1];
    while (group != (igmp_group *)0x0) {
      if ((((group->timer != 0) &&
           (uVar1 = (uint)group->timer - 1, group->timer = (u16_t)(uVar1 * 0x10000 >> 0x10),
           (uVar1 & 0xffff) == 0)) && (group->group_state == '\x01')) &&
         ((group->group_address).addr != allsystems)) {
        group->group_state = '\x02';
        lwip_stats.igmp.tx_report = lwip_stats.igmp.tx_report + 1;
        igmp_send(netif,group,'\x16');
      }
      group = group->next;
    }
    netif = netif->next;
  }
  return;
}



int ip4_input_accept(netif *netif)

{
  u8_t uVar1;
  int iVar2;
  undefined3 extraout_var;
  u32_t uVar3;
  
  if ((netif->flags & 1) == 0) {
    return 0;
  }
  uVar3 = (netif->ip_addr).addr;
  iVar2 = 0;
  if (uVar3 != 0) {
    iVar2 = 1;
    if (uVar3 != ip_data.current_iphdr_dest) {
      uVar1 = ip4_addr_isbroadcast_u32(ip_data.current_iphdr_dest,netif);
      return (uint)(CONCAT31(extraout_var,uVar1) != 0);
    }
  }
  return iVar2;
}



netif * ip4_route(ip4_addr_t *dest)

{
  byte bVar1;
  netif *pnVar2;
  netif *pnVar3;
  uint uVar4;
  uint uVar5;
  
  uVar5 = dest->addr;
  pnVar2 = netif_list;
  if (((uVar5 & 0xf0) != 0xe0) ||
     (pnVar3 = ip4_default_multicast_netif, ip4_default_multicast_netif == (netif *)0x0)) {
    while (pnVar2 != (netif *)0x0) {
      bVar1 = pnVar2->flags;
      if ((((bVar1 & 1) != 0) && ((bVar1 >> 2 & 1) != 0)) &&
         (uVar4 = (pnVar2->ip_addr).addr, uVar4 != 0)) {
        if (((uVar4 ^ uVar5) & (pnVar2->netmask).addr) == 0) {
          return pnVar2;
        }
        if (((bVar1 & 2) == 0) && (uVar5 == (pnVar2->gw).addr)) {
          return pnVar2;
        }
      }
      pnVar2 = pnVar2->next;
    }
    if (((netif_default == (netif *)0x0) || ((netif_default->flags & 5) != 5)) ||
       (((netif_default->ip_addr).addr == 0 || (pnVar3 = netif_default, (uVar5 & 0xff) == 0x7f)))) {
      lwip_stats.ip.rterr = lwip_stats.ip.rterr + 1;
      return (netif *)0x0;
    }
  }
  return pnVar3;
}



err_t ip4_input(pbuf *p,netif *inp)

{
  byte bVar1;
  uint uVar2;
  u8_t uVar3;
  raw_input_state_t rVar4;
  u16_t new_len;
  undefined2 extraout_var_02;
  undefined2 extraout_var_03;
  igmp_group *piVar5;
  undefined3 extraout_var;
  int iVar6;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  ip_hdr *dataptr;
  netif *netif;
  uint uVar7;
  
  lwip_stats.ip.recv = lwip_stats.ip.recv + 1;
  dataptr = (ip_hdr *)p->payload;
  bVar1 = dataptr->_v_hl;
  if (bVar1 >> 4 != 4) {
    pbuf_free(p);
    lwip_stats.ip.drop = lwip_stats.ip.drop + 1;
    lwip_stats.ip.err = lwip_stats.ip.err + 1;
    return '\0';
  }
  new_len = lwip_htons(dataptr->_len);
  uVar7 = (uint)bVar1 & 0xf;
  uVar2 = (uVar7 << 0x12) >> 0x10;
  if (CONCAT22(extraout_var_02,new_len) < (uint)p->tot_len) {
    pbuf_realloc(p,new_len);
  }
  if (((p->len < uVar2) || ((uint)p->tot_len < CONCAT22(extraout_var_02,new_len))) || (uVar2 < 0x14)
     ) {
    pbuf_free(p);
    lwip_stats.ip.lenerr = lwip_stats.ip.lenerr + 1;
    goto LAB_2303f588;
  }
  new_len = inet_chksum(dataptr,(u16_t)((uVar7 << 0x12) >> 0x10));
  if (CONCAT22(extraout_var_03,new_len) != 0) {
    pbuf_free(p);
    lwip_stats.ip.chkerr = lwip_stats.ip.chkerr + 1;
    goto LAB_2303f588;
  }
  ip_data.current_iphdr_dest = (dataptr->dest).addr;
  ip_data.current_iphdr_src = (dataptr->src).addr;
  netif = inp;
  if ((ip_data.current_iphdr_dest & 0xf0) == 0xe0) {
    if (((inp->flags & 0x20) == 0) ||
       (piVar5 = igmp_lookfor_group(inp,(ip4_addr_t *)&ip_data.current_iphdr_dest),
       piVar5 == (igmp_group *)0x0)) goto LAB_2303f60e;
    if ((ip_data.current_iphdr_dest != 0x10000e0) || (ip_data.current_iphdr_src != 0))
    goto LAB_2303f63e;
  }
  else {
    iVar6 = ip4_input_accept(inp);
    if (iVar6 == 0) {
      netif = netif_list;
      if ((char)ip_data.current_iphdr_dest.addr != '\x7f') {
        while (netif != (netif *)0x0) {
          if ((netif != inp) && (iVar6 = ip4_input_accept(netif), iVar6 != 0)) goto LAB_2303f63e;
          netif = netif->next;
        }
      }
    }
    else {
      if (inp != (netif *)0x0) goto LAB_2303f63e;
    }
LAB_2303f60e:
    if ((dataptr->_proto != '\x11') || (netif = inp, (&dataptr->_len)[uVar7 * 2] != 0x4400)) {
      netif = (netif *)0x0;
LAB_2303f63e:
      if ((ip_data.current_iphdr_src != 0) &&
         ((uVar3 = ip4_addr_isbroadcast_u32(ip_data.current_iphdr_src,inp),
          CONCAT31(extraout_var,uVar3) != 0 || ((ip_data.current_iphdr_src & 0xf0) == 0xe0)))) {
        pbuf_free(p);
        goto LAB_2303f588;
      }
    }
    if (netif == (netif *)0x0) {
      lwip_stats.ip.drop = lwip_stats.ip.drop + 1;
      pbuf_free(p);
      return '\0';
    }
  }
  if (((uint)*(byte *)&dataptr->_offset & 0x3f | (uint)*(byte *)((int)&dataptr->_offset + 1) << 8)
      == 0) {
    ip_data.current_ip_header_tot_len = (u16_t)(((uint)dataptr->_v_hl & 0xf) << 2);
    ip_data.current_netif = netif;
    ip_data.current_input_netif = inp;
    ip_data.current_ip4_header = dataptr;
    rVar4 = raw_input(p,inp);
    if (CONCAT31(extraout_var_00,rVar4) != 1) {
      pbuf_remove_header(p,uVar7 * 4);
      bVar1 = dataptr->_proto;
      if (bVar1 == 2) {
        igmp_input(p,inp,(ip4_addr_t *)&ip_data.current_iphdr_dest);
      }
      else {
        if (bVar1 < 3) {
          if (bVar1 == 1) {
            icmp_input(p,inp);
            ip_data.current_netif = (netif *)0x0;
            ip_data.current_input_netif = (netif *)0x0;
            ip_data.current_ip4_header = (ip_hdr *)0x0;
            ip_data.current_ip_header_tot_len = 0;
            ip_data.current_iphdr_src = 0;
            ip_data.current_iphdr_dest = 0;
            return '\0';
          }
        }
        else {
          if (bVar1 == 6) {
            tcp_input(p,inp);
            ip_data.current_netif = (netif *)0x0;
            ip_data.current_input_netif = (netif *)0x0;
            ip_data.current_ip4_header = (ip_hdr *)0x0;
            ip_data.current_ip_header_tot_len = 0;
            ip_data.current_iphdr_src = 0;
            ip_data.current_iphdr_dest = 0;
            return '\0';
          }
          if (bVar1 == 0x11) {
            udp_input(p,inp);
            ip_data.current_netif = (netif *)0x0;
            ip_data.current_input_netif = (netif *)0x0;
            ip_data.current_ip4_header = (ip_hdr *)0x0;
            ip_data.current_ip_header_tot_len = 0;
            ip_data.current_iphdr_src = 0;
            ip_data.current_iphdr_dest = 0;
            return '\0';
          }
        }
        if (CONCAT31(extraout_var_00,rVar4) != 2) {
          uVar3 = ip4_addr_isbroadcast_u32(ip_data.current_iphdr_dest,netif);
          if ((CONCAT31(extraout_var_01,uVar3) == 0) &&
             ((ip_data.current_iphdr_dest & 0xf0) != 0xe0)) {
            pbuf_header_force(p,(s16_t)(uVar7 * 4));
            icmp_dest_unreach(p,ICMP_DUR_PROTO);
          }
          lwip_stats.ip.proterr = lwip_stats.ip.proterr + 1;
          lwip_stats.ip.drop = lwip_stats.ip.drop + 1;
        }
        pbuf_free(p);
      }
    }
    ip_data.current_netif = (netif *)0x0;
    ip_data.current_input_netif = (netif *)0x0;
    ip_data.current_ip4_header = (ip_hdr *)0x0;
    ip_data.current_ip_header_tot_len = 0;
    ip_data.current_iphdr_src = 0;
    ip_data.current_iphdr_dest = 0;
    return '\0';
  }
  pbuf_free(p);
  lwip_stats.ip.opterr = lwip_stats.ip.opterr + 1;
LAB_2303f588:
  lwip_stats.ip.drop = lwip_stats.ip.drop + 1;
  return '\0';
}



// WARNING: Type propagation algorithm not settling

err_t ip4_output_if_opt_src
                (pbuf *p,ip4_addr_t *src,ip4_addr_t *dest,u8_t ttl,u8_t tos,u8_t proto,netif *netif,
                void *ip_options,u16_t optlen)

{
  uint header_size_increment;
  undefined *puVar1;
  uint uVar2;
  u8_t uVar3;
  err_t eVar4;
  u16_t uVar5;
  u16_t n;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined2 extraout_var_01;
  undefined2 extraout_var_02;
  undefined3 in_register_00002035;
  undefined3 in_register_00002039;
  int iVar6;
  undefined3 in_register_0000203d;
  int iVar7;
  uint uVar8;
  uint __n;
  int iVar9;
  ushort in_stack_00000000;
  ip4_addr_t iStack52;
  ip4_addr_t dest_addr;
  
  __n = (uint)in_stack_00000000;
  if (dest == (ip4_addr_t *)0x0) {
    if (0x13 < p->len) {
      dest = &iStack52;
      iStack52 = (ip4_addr_t)((ip4_addr_t *)((int)p->payload + 0x10))->addr;
      goto LAB_2303f9c0;
    }
  }
  else {
    if (in_stack_00000000 == 0) {
      uVar2 = 0x14;
      iVar9 = 0;
    }
    else {
      if (0x28 < in_stack_00000000) {
        lwip_stats.ip.err = lwip_stats.ip.err + 1;
        return -6;
      }
      header_size_increment = __n + 3 & 0xfffc;
      uVar3 = pbuf_add_header(p,header_size_increment);
      uVar2 = header_size_increment + 0x14 & 0xffff;
      if (CONCAT31(extraout_var,uVar3) != 0) goto LAB_2303f856;
      memcpy(p->payload,ip_options,__n);
      if (__n < header_size_increment) {
        memset((void *)((int)p->payload + __n),0,header_size_increment - __n);
      }
      iVar7 = 0;
      iVar9 = 0;
      do {
        iVar6 = iVar7 * 2;
        iVar7 = iVar7 + 1;
        iVar9 = iVar9 + (uint)*(ushort *)(iVar6 + (int)p->payload);
      } while (iVar7 < (int)(header_size_increment >> 1));
    }
    uVar3 = pbuf_add_header(p,0x14);
    if (CONCAT31(extraout_var_00,uVar3) == 0) {
      puVar1 = (undefined *)p->payload;
      puVar1[8] = ttl;
      puVar1[9] = proto;
      header_size_increment = dest->addr;
      uVar8 = CONCAT31(in_register_00002035,ttl) << 8 | CONCAT31(in_register_0000203d,proto);
      puVar1[0x10] = (char)header_size_increment;
      puVar1[0x11] = (char)(header_size_increment >> 8);
      puVar1[0x12] = (char)(header_size_increment >> 0x10);
      __n = uVar2 >> 2 & 0xff | 0x40;
      *puVar1 = (char)__n;
      __n = __n << 8 | CONCAT31(in_register_00002039,tos);
      puVar1[0x13] = (char)(header_size_increment >> 0x18);
      puVar1[1] = tos;
      uVar5 = lwip_htons(p->tot_len);
      puVar1[2] = (char)uVar5;
      n = ip_id;
      puVar1[3] = (char)(uVar5 >> 8);
      puVar1[6] = 0;
      puVar1[7] = 0;
      n = lwip_htons(n);
      puVar1[5] = (char)(n >> 8);
      puVar1[4] = (char)n;
      ip_id = ip_id + 1;
      if (src == (ip4_addr_t *)0x0) {
        uVar2 = 0;
      }
      else {
        uVar2 = src->addr;
      }
      puVar1[0xf] = (char)(uVar2 >> 0x18);
      puVar1[0xc] = (char)uVar2;
      puVar1[0xd] = (char)(uVar2 >> 8);
      __n = (uVar2 & 0xffff) +
            CONCAT22(extraout_var_02,n) +
            (((int)__n >> 8 | __n << 8) & 0xffff) +
            ((uVar8 << 8 | (int)uVar8 >> 8) & 0xffff) +
            (header_size_increment & 0xffff) + (header_size_increment >> 0x10) + iVar9 +
            CONCAT22(extraout_var_01,uVar5) + (uVar2 >> 0x10);
      puVar1[0xe] = (char)(uVar2 >> 0x10);
      __n = (__n & 0xffff) + (__n >> 0x10);
      __n = ~((__n >> 0x10) + __n);
      puVar1[10] = (char)__n;
      puVar1[0xb] = (char)(__n >> 8);
LAB_2303f9c0:
      lwip_stats.ip.xmit = lwip_stats.ip.xmit + 1;
      eVar4 = (*netif->output)(netif,p,dest);
      return eVar4;
    }
  }
LAB_2303f856:
  lwip_stats.ip.err = lwip_stats.ip.err + 1;
  return -2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

err_t ip4_output_if_opt(pbuf *p,ip4_addr_t *src,ip4_addr_t *dest,u8_t ttl,u8_t tos,u8_t proto,
                       netif *netif,void *ip_options,u16_t optlen)

{
  err_t eVar1;
  
  if ((dest != (ip4_addr_t *)0x0) && ((src == (ip4_addr_t *)0x0 || (src->addr == 0)))) {
    src = (ip4_addr_t *)&netif->ip_addr;
  }
  eVar1 = ip4_output_if_opt_src(p,src,dest,ttl,tos,proto,netif,ip_options,optlen);
  return eVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

err_t ip4_output_if(pbuf *p,ip4_addr_t *src,ip4_addr_t *dest,u8_t ttl,u8_t tos,u8_t proto,
                   netif *netif)

{
  err_t eVar1;
  
  eVar1 = ip4_output_if_opt(p,src,dest,ttl,tos,proto,netif,(void *)0x0,_DAT_00000010);
  return eVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

err_t ip4_output_if_src(pbuf *p,ip4_addr_t *src,ip4_addr_t *dest,u8_t ttl,u8_t tos,u8_t proto,
                       netif *netif)

{
  err_t eVar1;
  
  eVar1 = ip4_output_if_opt_src(p,src,dest,ttl,tos,proto,netif,(void *)0x0,_DAT_00000010);
  return eVar1;
}



u8_t ip4_addr_isbroadcast_u32(u32_t addr,netif *netif)

{
  byte bVar1;
  uint uVar2;
  uint uVar3;
  
  if (addr - 1 < 0xfffffffe) {
    bVar1 = netif->flags & 2;
    if ((netif->flags & 2) != 0) {
      uVar3 = (netif->ip_addr).addr;
      bVar1 = 0;
      if ((uVar3 != addr) && (uVar2 = (netif->netmask).addr, ((uVar3 ^ addr) & uVar2) == 0)) {
        uVar2 = ~uVar2;
        return (u8_t)((uVar2 & addr) == uVar2);
      }
    }
  }
  else {
    bVar1 = 1;
  }
  return (u8_t)bVar1;
}



int ip4addr_aton(char *cp,ip4_addr_t *addr)

{
  byte bVar1;
  int iVar2;
  u32_t n;
  u32_t *puVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;
  u32_t uStack32;
  u32_t parts [4];
  
  bVar1 = *cp;
  puVar3 = &uStack32;
LAB_2303fabc:
  uVar5 = (uint)bVar1;
  if ((_ctype_[uVar5 + 1] & 4) == 0) {
    return 0;
  }
  iVar6 = 10;
  if (bVar1 == 0x30) {
    uVar5 = (uint)(byte)cp[1];
    if ((uVar5 & 0xdf) == 0x58) {
      uVar5 = (uint)(byte)cp[2];
      iVar6 = 0x10;
      cp = cp + 2;
    }
    else {
      cp = cp + 1;
      iVar6 = 8;
    }
  }
  n = 0;
  do {
    bVar1 = _ctype_[uVar5 + 1];
    if ((bVar1 & 4) == 0) {
      if ((iVar6 != 0x10) || ((bVar1 & 0x44) == 0)) break;
      iVar2 = 0x61;
      if ((bVar1 & 3) != 2) {
        iVar2 = 0x41;
      }
      n = n << 4 | (uVar5 + 10) - iVar2;
    }
    else {
      n = (iVar6 * n + uVar5) - 0x30;
    }
    uVar5 = (uint)(byte)cp[1];
    cp = cp + 1;
  } while( true );
  if (uVar5 == 0x2e) {
    if (puVar3 == parts + 2) {
      return 0;
    }
    *puVar3 = n;
    bVar1 = cp[1];
    cp = cp + 1;
    puVar3 = puVar3 + 1;
    goto LAB_2303fabc;
  }
  if ((uVar5 != 0) && ((bVar1 & 8) == 0)) {
    return 0;
  }
  iVar6 = (int)((int)puVar3 - (int)&uStack32) >> 2;
  iVar2 = iVar6 + 1;
  if (iVar2 == 2) {
    if (0xffffff < n) {
      return 0;
    }
    if (0xff < uStack32) {
      return 0;
    }
    uVar5 = uStack32 << 0x18;
  }
  else {
    if (iVar2 < 3) {
      if (iVar6 == -1) {
        return 0;
      }
      goto LAB_2303fb6a;
    }
    if (iVar2 == 3) {
      if (0xffff < n) {
        return 0;
      }
      if (0xff < uStack32) {
        return 0;
      }
      if (0xff < parts[0]) {
        return 0;
      }
      uVar5 = uStack32 << 0x18;
      uVar4 = parts[0] << 0x10;
    }
    else {
      if (iVar2 != 4) goto LAB_2303fb6a;
      if (0xff < n) {
        return 0;
      }
      if (0xff < uStack32) {
        return 0;
      }
      if (0xff < parts[0]) {
        return 0;
      }
      if (0xff < parts[1]) {
        return 0;
      }
      uVar5 = uStack32 << 0x18 | parts[0] << 0x10;
      uVar4 = parts[1] << 8;
    }
    uVar5 = uVar5 | uVar4;
  }
  n = n | uVar5;
LAB_2303fb6a:
  if (addr != (ip4_addr_t *)0x0) {
    n = lwip_htonl(n);
    addr->addr = n;
    return 1;
  }
  return 1;
}



u32_t ipaddr_addr(char *cp)

{
  int iVar1;
  ip4_addr_t iStack20;
  ip4_addr_t val;
  
  iVar1 = ip4addr_aton(cp,&iStack20);
  if (iVar1 == 0) {
    iStack20 = (ip4_addr_t)0xffffffff;
  }
  return (u32_t)iStack20;
}



// WARNING: Could not reconcile some variable overlaps

char * ip4addr_ntoa_r(ip4_addr_t *addr,char *buf,int buflen)

{
  bool bVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  byte *pbVar5;
  uint uVar6;
  char *pcVar7;
  uint uVar8;
  uint uVar9;
  char *pcVar10;
  u32_t s_addr;
  char local_8 [4];
  char inv [3];
  
  _inv = addr->addr;
  iVar3 = 0;
  pbVar5 = (byte *)inv;
  pcVar10 = buf;
  while( true ) {
    uVar2 = 0;
    uVar9 = (uint)*pbVar5;
    do {
      uVar8 = uVar2;
      uVar6 = uVar9 / 10;
      local_8[uVar8] = (char)(uVar9 % 10) + '0';
      bVar1 = 9 < uVar9;
      uVar2 = uVar8 + 1 & 0xff;
      uVar9 = uVar6;
    } while (bVar1);
    *pbVar5 = (byte)uVar6;
    iVar4 = iVar3;
    pcVar7 = pcVar10;
    while (iVar3 = iVar4 + 1, uVar8 != 0xff) {
      if (buflen <= iVar4) {
        return (char *)0x0;
      }
      *pcVar7 = local_8[uVar8];
      iVar4 = iVar3;
      pcVar7 = pcVar7 + 1;
      uVar8 = uVar8 - 1 & 0xff;
    }
    if (buflen <= iVar4) break;
    *pcVar7 = '.';
    pbVar5 = pbVar5 + 1;
    pcVar10 = pcVar7 + 1;
    if (pbVar5 == (byte *)register0x00002008) {
      *pcVar7 = '\0';
      return buf;
    }
  }
  return (char *)0x0;
}



char * ip4addr_ntoa(ip4_addr_t *addr)

{
  char str [16];
  char *pcVar1;
  
  pcVar1 = ip4addr_ntoa_r(addr,(char *)&ram0x420151ac,0x10);
  return pcVar1;
}



void mem_init(void)

{
  ram = ram_heap;
  ram_heap._0_4_ = 0x2000;
  ram_heap[4] = '\0';
  ram_end = (mem *)(ram_heap + 0x2000);
  ram_heap._8192_4_ = 0x20002000;
  ram_heap[8196] = '\x01';
  lfree = (mem *)ram_heap;
  lwip_stats.mem.avail = 0x2000;
  sys_mutex_new(&mem_mutex);
  return;
}



void mem_free(uint param_1)

{
  ushort uVar1;
  ushort uVar2;
  short sVar3;
  u8_t *puVar4;
  mem *pmVar5;
  mem *pmVar6;
  mem *pmVar7;
  uint uVar8;
  mem *pmVar9;
  
  if (param_1 == 0) {
    return;
  }
  if ((((param_1 & 3) == 0) && (pmVar6 = (mem *)(param_1 - 8), ram <= pmVar6)) &&
     ((mem *)(param_1 + 0xc) <= ram_end)) {
    sys_mutex_lock(&mem_mutex);
    pmVar5 = ram_end;
    puVar4 = ram;
    pmVar9 = lfree;
    if (*(char *)(param_1 - 4) != '\0') {
      uVar1 = *(ushort *)(param_1 - 8);
      if ((uVar1 < 0x2001) && (uVar2 = *(ushort *)(param_1 - 6), uVar2 < 0x2001)) {
        pmVar7 = (mem *)((int)pmVar6 - (int)ram);
        uVar8 = (uint)pmVar7 & 0xffff;
        if ((uVar8 == (uint)uVar2) || ((uint)*(ushort *)(ram + (uint)uVar2) == uVar8)) {
          if (((mem *)(ram + uVar1) == ram_end) || ((uint)((mem *)(ram + uVar1))->prev == uVar8)) {
            *(undefined *)(param_1 - 4) = 0;
            if (pmVar6 < pmVar9) {
              lfree = pmVar6;
            }
            sVar3 = (short)((uint)((int)pmVar7 * 0x10000) >> 0x10);
            lwip_stats.mem.used = (lwip_stats.mem.used - uVar1) + sVar3;
            pmVar9 = (mem *)(puVar4 + *(ushort *)(param_1 - 8));
            if (((pmVar6 != pmVar9) && (pmVar9->used == '\0')) && (pmVar5 != pmVar9)) {
              if (pmVar9 == lfree) {
                lfree = pmVar6;
              }
              *(mem_size_t *)(param_1 - 8) = pmVar9->next;
              if (pmVar9->next != 0x2000) {
                *(short *)(puVar4 + (uint)pmVar9->next + 2) = sVar3;
              }
            }
            uVar1 = *(ushort *)(param_1 - 6);
            pmVar9 = (mem *)(puVar4 + uVar1);
            if ((pmVar6 != pmVar9) && (pmVar9->used == '\0')) {
              if (pmVar6 == lfree) {
                lfree = pmVar9;
              }
              pmVar9->next = *(mem_size_t *)(param_1 - 8);
              if (*(ushort *)(param_1 - 8) != 0x2000) {
                *(ushort *)(puVar4 + (uint)*(ushort *)(param_1 - 8) + 2) = uVar1;
              }
            }
            sys_mutex_unlock(&mem_mutex);
            return;
          }
        }
      }
    }
    sys_mutex_unlock(&mem_mutex);
  }
  sys_arch_protect();
  lwip_stats.mem.illegal = lwip_stats.mem.illegal + 1;
  sys_arch_unprotect();
  return;
}



mem * mem_trim(mem *param_1,uint param_2)

{
  mem_size_t mVar1;
  short sVar2;
  u8_t *puVar3;
  uint uVar4;
  mem_size_t mVar5;
  uint uVar6;
  uint uVar7;
  mem *pmVar8;
  mem *pmVar9;
  undefined2 uVar10;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  
  uVar4 = param_2 + 3 & 0xfffc;
  if (uVar4 < 0xc) {
    uVar4 = 0xc;
  }
  else {
    if (0x2000 < uVar4) {
      return (mem *)0;
    }
  }
  if (uVar4 < param_2) {
    return (mem *)0;
  }
  if ((param_1 < ram) || (ram_end <= param_1)) {
    sys_arch_protect();
    lwip_stats.mem.illegal = lwip_stats.mem.illegal + 1;
    sys_arch_unprotect();
    return param_1;
  }
  uVar6 = (int)param_1 + (-8 - (int)ram);
  uVar11 = (uint)*(ushort *)&param_1[-2].used - 8;
  uVar7 = uVar6 & 0xffff;
  uVar12 = uVar11 & 0xffff;
  uVar13 = uVar12 - uVar7 & 0xffff;
  if (uVar13 < uVar4) {
    return (mem *)0;
  }
  if (uVar13 == uVar4) {
    return param_1;
  }
  sys_mutex_lock(&mem_mutex);
  puVar3 = ram;
  pmVar8 = (mem *)(ram + *(ushort *)&param_1[-2].used);
  mVar5 = (mem_size_t)uVar7;
  if (pmVar8->used == '\0') {
    uVar6 = uVar7 + 8 + uVar4;
    mVar1 = pmVar8->next;
    pmVar9 = (mem *)(ram + (uVar6 & 0xffff));
    if (lfree == pmVar8) {
      lfree = pmVar9;
    }
    pmVar9->used = '\0';
    pmVar9->next = mVar1;
    pmVar9->prev = mVar5;
    uVar10 = (undefined2)(uVar6 * 0x10000 >> 0x10);
    *(undefined2 *)&param_1[-2].used = uVar10;
    if (pmVar9->next != 0x2000) {
      *(undefined2 *)(puVar3 + (uint)pmVar9->next + 2) = uVar10;
    }
    sVar2 = (mVar5 - (short)uVar12) + lwip_stats.mem.used;
  }
  else {
    if (uVar13 < uVar4 + 0x14) goto LAB_2303ff8e;
    uVar7 = uVar7 + 8 + uVar4;
    pmVar8 = (mem *)(ram + (uVar7 & 0xffff));
    if (pmVar8 < lfree) {
      lfree = pmVar8;
    }
    pmVar8->used = '\0';
    mVar1 = *(mem_size_t *)&param_1[-2].used;
    pmVar8->prev = mVar5;
    pmVar8->next = mVar1;
    uVar10 = (undefined2)(uVar7 * 0x10000 >> 0x10);
    *(undefined2 *)&param_1[-2].used = uVar10;
    if (pmVar8->next != 0x2000) {
      *(undefined2 *)(puVar3 + (uint)pmVar8->next + 2) = uVar10;
    }
    sVar2 = ((short)(uVar6 * 0x10000 >> 0x10) - (short)(uVar11 * 0x10000 >> 0x10)) +
            lwip_stats.mem.used;
  }
  lwip_stats.mem.used = (short)uVar4 + sVar2;
LAB_2303ff8e:
  sys_mutex_unlock(&mem_mutex);
  return param_1;
}



mem_size_t * mem_malloc(uint param_1)

{
  ushort uVar1;
  u8_t *puVar2;
  mem_size_t *pmVar3;
  mem *pmVar4;
  uint uVar5;
  uint uVar6;
  ushort *puVar7;
  mem_size_t mVar8;
  uint uVar9;
  uint uVar10;
  mem *pmVar11;
  
  if (param_1 == 0) {
LAB_23040080:
    pmVar3 = (mem_size_t *)0x0;
  }
  else {
    uVar5 = param_1 + 3 & 0xfffc;
    if (uVar5 < 0xc) {
      uVar5 = 0xc;
    }
    else {
      if (0x2000 < uVar5) {
        return (mem_size_t *)0;
      }
    }
    pmVar3 = (mem_size_t *)0x0;
    if (param_1 <= uVar5) {
      sys_mutex_lock(&mem_mutex);
      puVar2 = ram;
      pmVar11 = lfree;
      uVar9 = (uint)((int)lfree - (int)ram) & 0xffff;
      do {
        uVar10 = uVar9;
        if (0x2000 - uVar5 <= uVar10) {
          lwip_stats.mem.err = lwip_stats.mem.err + 1;
          sys_mutex_unlock(&mem_mutex);
          goto LAB_23040080;
        }
        pmVar4 = (mem *)(ram + uVar10);
        uVar9 = (uint)pmVar4->next;
      } while ((pmVar4->used != '\0') || (uVar6 = (-8 - uVar10) + uVar9, uVar6 < uVar5));
      if (uVar6 < uVar5 + 0x14) {
        pmVar4->used = '\x01';
        uVar10 = (uVar9 + lwip_stats.mem.used) - uVar10;
        lwip_stats.mem.used = (mem_size_t)(uVar10 * 0x10000 >> 0x10);
        if ((uint)lwip_stats.mem.max < (uVar10 & 0xffff)) {
          lwip_stats.mem.max = lwip_stats.mem.used;
        }
      }
      else {
        uVar9 = uVar5 + 8 + uVar10;
        puVar7 = (ushort *)(ram + (uVar9 & 0xffff));
        *(undefined *)(puVar7 + 2) = 0;
        uVar1 = pmVar4->next;
        puVar7[1] = (ushort)uVar10;
        *puVar7 = uVar1;
        mVar8 = (mem_size_t)(uVar9 * 0x10000 >> 0x10);
        pmVar4->next = mVar8;
        pmVar4->used = '\x01';
        if (*puVar7 != 0x2000) {
          *(mem_size_t *)(puVar2 + (uint)*puVar7 + 2) = mVar8;
        }
        uVar5 = uVar5 + (uint)lwip_stats.mem.used + 8;
        lwip_stats.mem.used = (mem_size_t)(uVar5 * 0x10000 >> 0x10);
        if ((uint)lwip_stats.mem.max < (uVar5 & 0xffff)) {
          lwip_stats.mem.max = lwip_stats.mem.used;
        }
      }
      if (pmVar11 == pmVar4) {
        while ((lfree = pmVar11, pmVar11->used != '\0' && (ram_end != pmVar11))) {
          pmVar11 = (mem *)(puVar2 + pmVar11->next);
        }
      }
      sys_mutex_unlock(&mem_mutex);
      pmVar3 = &pmVar4[1].prev;
    }
  }
  return pmVar3;
}



// WARNING: Type propagation algorithm not settling

void * do_memp_malloc_pool(memp_desc *desc)

{
  memp mVar1;
  sys_prot_t sVar2;
  stats_mem *psVar3;
  
  sVar2 = sys_arch_protect();
  mVar1 = (memp)((memp *)desc->tab)->next;
  if (mVar1 == (memp)0x0) {
    desc->stats->err = desc->stats->err + 1;
  }
  else {
    *(memp *)&((memp *)desc->tab)->next = *(memp *)mVar1;
    desc->stats->used = desc->stats->used + 1;
    psVar3 = desc->stats;
    if (psVar3->max < psVar3->used) {
      psVar3->max = psVar3->used;
    }
  }
  sys_arch_unprotect(sVar2);
  return (void *)mVar1;
}



// WARNING: Type propagation algorithm not settling

void memp_init_pool(memp_desc *desc)

{
  int iVar1;
  memp mVar2;
  
  iVar1 = 0;
  *desc->tab = (memp *)0x0;
  mVar2 = (memp)((uint)(desc->base + 3) & 0xfffffffc);
  while (iVar1 < (int)(uint)desc->num) {
    iVar1 = iVar1 + 1;
    *(memp **)mVar2 = ((memp *)desc->tab)->next;
    *(memp *)&((memp *)desc->tab)->next = mVar2;
    mVar2 = (memp)((int)mVar2 + (uint)desc->size);
  }
  desc->stats->avail = desc->num;
  return;
}



void memp_init(void)

{
  stats_ *psVar1;
  int iVar2;
  memp_desc *desc;
  
  iVar2 = 0;
  psVar1 = &lwip_stats;
  do {
    desc = *(memp_desc **)((int)memp_pools + iVar2);
    iVar2 = iVar2 + 4;
    memp_init_pool(desc);
    psVar1->memp[0] = desc->stats;
    psVar1 = (stats_ *)&(psVar1->link).fw;
  } while (iVar2 != 0x3c);
  return;
}



void * memp_malloc(memp_t type)

{
  undefined3 in_register_00002029;
  void *pvVar1;
  
  if (CONCAT31(in_register_00002029,type) < 0xf) {
    pvVar1 = do_memp_malloc_pool(memp_pools[CONCAT31(in_register_00002029,type)]);
    return pvVar1;
  }
  return (void *)0x0;
}



void memp_free(memp_t type,void *mem)

{
  memp_desc *pmVar1;
  undefined3 in_register_00002029;
  
  if ((CONCAT31(in_register_00002029,type) < 0xf) && (mem != (void *)0x0)) {
    pmVar1 = memp_pools[CONCAT31(in_register_00002029,type)];
    sys_arch_protect();
    pmVar1->stats->used = pmVar1->stats->used - 1;
    *(memp **)mem = *pmVar1->tab;
    *pmVar1->tab = mem;
    sys_arch_unprotect();
    return;
  }
  return;
}



err_t netif_null_output_ip4(netif *netif,pbuf *p,ip4_addr_t *ipaddr)

{
  return -0xc;
}



void netif_issue_reports(netif *netif,u8_t report_type)

{
  if (((netif->flags & 5) != 5) || ((report_type & 1) == 0)) {
    return;
  }
  if ((netif->ip_addr).addr != 0) {
    if ((netif->flags & 8) != 0) {
      etharp_request(netif,(ip4_addr_t *)&netif->ip_addr);
    }
    if ((netif->flags & 0x20) != 0) {
      igmp_report_groups(netif);
      return;
    }
  }
  return;
}



// WARNING: Variable defined which should be unmapped: new_addr
// WARNING: Type propagation algorithm not settling

int netif_do_set_ipaddr(netif *netif,ip4_addr_t *ipaddr,ip_addr_t *old_addr)

{
  ip_addr_t iVar1;
  ip_addr_t iStack20;
  ip_addr_t new_addr;
  
  iVar1 = (ip_addr_t)(netif->ip_addr).addr;
  iStack20 = (ip_addr_t)ipaddr->addr;
  if (iStack20 != iVar1) {
    *(ip_addr_t *)&old_addr->addr = iVar1;
    tcp_netif_ip_addr_changed(old_addr,&iStack20);
    udp_netif_ip_addr_changed(old_addr,&iStack20);
    raw_netif_ip_addr_changed(old_addr,&iStack20);
    (netif->ip_addr).addr = ipaddr->addr;
    netif_issue_reports(netif,'\x01');
    if (netif->status_callback != (netif_status_callback_fn *)0x0) {
      (*netif->status_callback)(netif);
    }
    return 1;
  }
  return 0;
}



void netif_init(void)

{
  return;
}



void netif_set_ipaddr(netif *netif,ip4_addr_t *ipaddr)

{
  ip_addr_t iStack20;
  ip_addr_t old_addr;
  
  if (netif != (netif *)0x0) {
    if (ipaddr == (ip4_addr_t *)0x0) {
      ipaddr = (ip4_addr_t *)&ip_addr_any;
    }
    netif_do_set_ipaddr(netif,ipaddr,&iStack20);
    return;
  }
  return;
}



void netif_set_netmask(netif *netif,ip4_addr_t *netmask)

{
  if (netif != (netif *)0x0) {
    if (netmask == (ip4_addr_t *)0x0) {
      netmask = (ip4_addr_t *)&ip_addr_any;
    }
    if (netmask->addr != (netif->netmask).addr) {
      (netif->netmask).addr = netmask->addr;
    }
  }
  return;
}



void netif_set_gw(netif *netif,ip4_addr_t *gw)

{
  if (netif != (netif *)0x0) {
    if (gw == (ip4_addr_t *)0x0) {
      gw = (ip4_addr_t *)&ip_addr_any;
    }
    if (gw->addr != (netif->gw).addr) {
      (netif->gw).addr = gw->addr;
    }
  }
  return;
}



// WARNING: Variable defined which should be unmapped: old_addr

void netif_set_addr(netif *netif,ip4_addr_t *ipaddr,ip4_addr_t *netmask,ip4_addr_t *gw)

{
  bool bVar1;
  ip_addr_t iStack20;
  ip_addr_t old_addr;
  
  if (ipaddr == (ip4_addr_t *)0x0) {
    ipaddr = (ip4_addr_t *)&ip_addr_any;
  }
  if (netmask == (ip4_addr_t *)0x0) {
    netmask = (ip4_addr_t *)&ip_addr_any;
  }
  if (gw == (ip4_addr_t *)0x0) {
    gw = (ip4_addr_t *)&ip_addr_any;
  }
  bVar1 = ipaddr->addr == 0;
  if (bVar1) {
    netif_do_set_ipaddr(netif,ipaddr,&iStack20);
  }
  if (netmask->addr != (netif->netmask).addr) {
    (netif->netmask).addr = netmask->addr;
  }
  if (gw->addr != (netif->gw).addr) {
    (netif->gw).addr = gw->addr;
  }
  if (!bVar1) {
    netif_do_set_ipaddr(netif,ipaddr,&iStack20);
  }
  return;
}



netif * netif_add(netif *netif,ip4_addr_t *ipaddr,ip4_addr_t *netmask,ip4_addr_t *gw,void *state,
                 netif_init_fn_conflict *init,netif_input_fn *input)

{
  u8_t uVar1;
  err_t eVar2;
  undefined3 extraout_var;
  netif *pnVar3;
  
  if ((netif != (netif *)0x0) && (init != (netif_init_fn_conflict *)0x0)) {
    if (ipaddr == (ip4_addr_t *)0x0) {
      ipaddr = (ip4_addr_t *)&ip_addr_any;
    }
    if (netmask == (ip4_addr_t *)0x0) {
      netmask = (ip4_addr_t *)&ip_addr_any;
    }
    if (gw == (ip4_addr_t *)0x0) {
      gw = (ip4_addr_t *)&ip_addr_any;
    }
    netif->output = netif_null_output_ip4;
    (netif->ip_addr).addr = 0;
    (netif->netmask).addr = 0;
    (netif->gw).addr = 0;
    netif->mtu = 0;
    netif->flags = '\0';
    memset(netif->client_data,0,0xc);
    netif->state = state;
    uVar1 = netif_num;
    netif->input = input;
    netif->num = uVar1;
    netif->status_callback = (netif_status_callback_fn *)0x0;
    netif->link_callback = (netif_status_callback_fn *)0x0;
    netif->igmp_mac_filter = (netif_igmp_mac_filter_fn *)0x0;
    netif_set_addr(netif,ipaddr,netmask,gw);
    eVar2 = (*init)(netif);
    if (CONCAT31(extraout_var,eVar2) == 0) {
      do {
        if (netif->num == -1) {
          netif->num = '\0';
        }
        uVar1 = netif->num;
        pnVar3 = netif_list;
        while( true ) {
          if (pnVar3 == (netif *)0x0) {
            netif_num = '\0';
            if (uVar1 != -2) {
              netif_num = uVar1 + '\x01';
            }
            netif->next = netif_list;
            if ((netif->flags & 0x20) == 0) {
              netif_list = netif;
              return netif;
            }
            netif_list = netif;
            igmp_start(netif);
            return netif;
          }
          if (pnVar3->num == uVar1) break;
          pnVar3 = pnVar3->next;
        }
        netif->num = uVar1 + '\x01';
      } while( true );
    }
  }
  return (netif *)0x0;
}



void netif_set_default(netif *netif)

{
  netif_default = netif;
  return;
}



void netif_set_up(netif *netif)

{
  if (netif == (netif *)0x0) {
    return;
  }
  if ((netif->flags & 1) == 0) {
    netif->flags = netif->flags | 1;
    if (netif->status_callback != (netif_status_callback_fn *)0x0) {
      (*netif->status_callback)(netif);
    }
    netif_issue_reports(netif,'\x03');
    return;
  }
  return;
}



void netif_set_down(netif *netif)

{
  byte bVar1;
  
  if (netif == (netif *)0x0) {
    return;
  }
  bVar1 = netif->flags;
  if ((bVar1 & 1) != 0) {
    netif->flags = bVar1 & 0xfe;
    if ((bVar1 & 8) != 0) {
      etharp_cleanup_netif(netif);
    }
    if (netif->status_callback != (netif_status_callback_fn *)0x0) {
                    // WARNING: Could not recover jumptable at 0x23040594. Too many branches
                    // WARNING: Treating indirect jump as call
      (*netif->status_callback)(netif);
      return;
    }
  }
  return;
}



void netif_remove(netif *netif)

{
  netif *pnVar1;
  ip_addr_t *old_addr;
  netif *pnVar2;
  
  if (netif == (netif *)0x0) {
    return;
  }
  if ((netif->ip_addr).addr != 0) {
    old_addr = &netif->ip_addr;
    tcp_netif_ip_addr_changed(old_addr,(ip_addr_t *)0x0);
    udp_netif_ip_addr_changed(old_addr,(ip_addr_t *)0x0);
    raw_netif_ip_addr_changed(old_addr,(ip_addr_t *)0x0);
  }
  if ((netif->flags & 0x20) != 0) {
    igmp_stop(netif);
  }
  if ((netif->flags & 1) != 0) {
    netif_set_down(netif);
  }
  if (netif_default == netif) {
    netif_default = (netif *)0x0;
  }
  pnVar1 = netif_list;
  if (netif_list == netif) {
    netif_list = netif->next;
  }
  else {
    do {
      pnVar2 = pnVar1;
      if (pnVar2 == (netif *)0x0) {
        return;
      }
      pnVar1 = pnVar2->next;
    } while (pnVar2->next != netif);
    pnVar2->next = netif->next;
  }
  return;
}



void netif_set_status_callback(netif *netif,netif_status_callback_fn *status_callback)

{
  if (netif != (netif *)0x0) {
    netif->status_callback = status_callback;
  }
  return;
}



void netif_set_link_up(netif *netif)

{
  if (netif == (netif *)0x0) {
    return;
  }
  if ((netif->flags & 4) == 0) {
    netif->flags = netif->flags | 4;
    dhcp_network_changed(netif);
    netif_issue_reports(netif,'\x03');
    if (netif->link_callback != (netif_status_callback_fn *)0x0) {
                    // WARNING: Could not recover jumptable at 0x23040666. Too many branches
                    // WARNING: Treating indirect jump as call
      (*netif->link_callback)(netif);
      return;
    }
  }
  return;
}



// WARNING: Exceeded maximum restarts with more pending

void netif_set_link_down(netif *netif)

{
  if (netif != (netif *)0x0) {
    if ((netif->flags & 4) != 0) {
      netif->flags = netif->flags & 0xfb;
      if (netif->link_callback != (netif_status_callback_fn *)0x0) {
                    // WARNING: Could not recover jumptable at 0x2304068c. Too many branches
                    // WARNING: Treating indirect jump as call
        (*netif->link_callback)();
        return;
      }
    }
  }
  return;
}



netif * netif_get_by_index(u8_t idx)

{
  undefined3 in_register_00002029;
  netif *pnVar1;
  netif *pnVar2;
  
  pnVar1 = netif_list;
  pnVar2 = (netif *)0x0;
  if (CONCAT31(in_register_00002029,idx) != 0) {
    while ((pnVar2 = pnVar1, pnVar1 != (netif *)0x0 &&
           (((uint)pnVar1->num + 1 & 0xff) != CONCAT31(in_register_00002029,idx)))) {
      pnVar1 = pnVar1->next;
    }
  }
  return pnVar2;
}



netif * netif_find(char *name)

{
  uint uVar1;
  netif *pnVar2;
  
  if (name == (char *)0x0) {
    return (netif *)0x0;
  }
  uVar1 = atoi(name + 2);
  pnVar2 = netif_list;
  while( true ) {
    if (pnVar2 == (netif *)0x0) {
      return (netif *)0x0;
    }
    if ((((uint)pnVar2->num == (uVar1 & 0xff)) && (*name == pnVar2->name[0])) &&
       (name[1] == pnVar2->name[1])) break;
    pnVar2 = pnVar2->next;
  }
  return pnVar2;
}



pbuf * pbuf_skip_const(pbuf *in,u16_t in_offset,u16_t *out_offset)

{
  pbuf *ppVar1;
  undefined2 in_register_0000202e;
  
  if ((in != (pbuf *)0x0) && ((uint)in->len <= CONCAT22(in_register_0000202e,in_offset))) {
    ppVar1 = pbuf_skip_const(in->next,(u16_t)((CONCAT22(in_register_0000202e,in_offset) -
                                              (uint)in->len) * 0x10000 >> 0x10),out_offset);
    return ppVar1;
  }
  if (out_offset != (u16_t *)0x0) {
    *out_offset = in_offset;
  }
  return in;
}



void pbuf_free_ooseq_callback(void *arg)

{
  tcp_pcb *pcb;
  
  sys_arch_protect();
  pbuf_free_ooseq_pending = '\0';
  sys_arch_unprotect();
  pcb = tcp_active_pcbs;
  while( true ) {
    if (pcb == (tcp_pcb *)0x0) {
      return;
    }
    if (pcb->ooseq != (tcp_seg *)0x0) break;
    pcb = pcb->next;
  }
  tcp_free_ooseq(pcb);
  return;
}



u8_t pbuf_add_header_impl(pbuf *p,size_t header_size_increment,u8_t force)

{
  u8_t uVar1;
  pbuf *ppVar2;
  undefined3 in_register_00002031;
  uint uVar3;
  
  if (p == (pbuf *)0x0) {
    uVar1 = '\x01';
  }
  else {
    uVar1 = '\x01';
    if ((header_size_increment < 0x10000) && (uVar1 = '\0', header_size_increment != 0)) {
      uVar3 = (uint)p->tot_len + (header_size_increment & 0xffff);
      uVar1 = '\x01';
      if ((header_size_increment & 0xffff) <= (uVar3 & 0xffff)) {
        if ((char)p->type_internal < '\0') {
          ppVar2 = (pbuf *)((int)p->payload - header_size_increment);
          if (ppVar2 < p + 1) {
            return '\x01';
          }
        }
        else {
          if (CONCAT31(in_register_00002031,force) == 0) {
            return '\x01';
          }
          ppVar2 = (pbuf *)((int)p->payload - header_size_increment);
        }
        *(pbuf **)&p->payload = ppVar2;
        p->tot_len = (u16_t)(uVar3 * 0x10000 >> 0x10);
        p->len = (short)header_size_increment + p->len;
        return '\0';
      }
    }
  }
  return uVar1;
}



pbuf * pbuf_alloc_reference(void *payload,u16_t length,pbuf_type type)

{
  pbuf *ppVar1;
  
  ppVar1 = (pbuf *)memp_malloc(MEMP_PBUF);
  if (ppVar1 != (pbuf *)0x0) {
    ppVar1->next = (pbuf *)0x0;
    ppVar1->payload = payload;
    ppVar1->tot_len = length;
    ppVar1->len = length;
    ppVar1->type_internal = (u8_t)type;
    ppVar1->flags = '\0';
    *(undefined2 *)&ppVar1->ref = 1;
  }
  return ppVar1;
}



pbuf * pbuf_alloced_custom(pbuf_layer l,u16_t length,pbuf_type type,pbuf_custom *p,void *payload_mem
                          ,u16_t payload_mem_len)

{
  undefined3 in_register_00002029;
  uint uVar1;
  undefined2 in_register_0000202e;
  undefined2 in_register_0000203e;
  
  uVar1 = CONCAT31(in_register_00002029,l) + 3U & 0xfffffffc;
  if (CONCAT22(in_register_0000202e,length) + uVar1 <=
      CONCAT22(in_register_0000203e,payload_mem_len)) {
    if (payload_mem != (void *)0x0) {
      payload_mem = (void *)((int)payload_mem + uVar1);
    }
    (p->pbuf).flags = '\x02';
    (p->pbuf).next = (pbuf *)0x0;
    (p->pbuf).payload = payload_mem;
    (p->pbuf).tot_len = length;
    (p->pbuf).len = length;
    (p->pbuf).type_internal = (u8_t)type;
    *(undefined2 *)&(p->pbuf).ref = 1;
    return (pbuf *)p;
  }
  return (pbuf *)0x0;
}



u8_t pbuf_add_header(pbuf *p,size_t header_size_increment)

{
  u8_t uVar1;
  
  uVar1 = pbuf_add_header_impl(p,header_size_increment,'\0');
  return uVar1;
}



u8_t pbuf_remove_header(pbuf *p,size_t header_size_decrement)

{
  u8_t uVar1;
  
  if (p == (pbuf *)0x0) {
    uVar1 = '\x01';
  }
  else {
    uVar1 = '\x01';
    if ((header_size_decrement < 0x10000) && (uVar1 = '\0', header_size_decrement != 0)) {
      uVar1 = '\x01';
      if ((header_size_decrement & 0xffff) <= (uint)p->len) {
        p->len = p->len - (short)header_size_decrement;
        p->payload = (void *)(header_size_decrement + (int)p->payload);
        p->tot_len = p->tot_len - (short)header_size_decrement;
        return '\0';
      }
    }
  }
  return uVar1;
}



u8_t pbuf_header(pbuf *p,s16_t header_size_increment)

{
  u8_t uVar1;
  short in_register_0000202e;
  
  if (in_register_0000202e < 0) {
    uVar1 = pbuf_remove_header(p,-CONCAT22(in_register_0000202e,header_size_increment));
    return uVar1;
  }
  uVar1 = pbuf_add_header_impl(p,CONCAT22(in_register_0000202e,header_size_increment),'\0');
  return uVar1;
}



u8_t pbuf_header_force(pbuf *p,s16_t header_size_increment)

{
  u8_t uVar1;
  short in_register_0000202e;
  
  if (in_register_0000202e < 0) {
    uVar1 = pbuf_remove_header(p,-CONCAT22(in_register_0000202e,header_size_increment));
    return uVar1;
  }
  uVar1 = pbuf_add_header_impl(p,CONCAT22(in_register_0000202e,header_size_increment),'\x01');
  return uVar1;
}



u8_t pbuf_free(pbuf *p)

{
  u8_t uVar1;
  u8_t uVar2;
  pbuf *ppVar3;
  memp_t type;
  byte bVar4;
  
  uVar1 = '\0';
  if (p != (pbuf *)0x0) {
    uVar1 = '\0';
    do {
      sys_arch_protect();
      uVar2 = p->ref + -1;
      p->ref = uVar2;
      sys_arch_unprotect();
      if (uVar2 != '\0') {
        return uVar1;
      }
      ppVar3 = p->next;
      if ((p->flags & 2) == 0) {
        type = MEMP_PBUF_POOL;
        bVar4 = p->type_internal & 0xf;
        if (bVar4 != 2) {
          if (bVar4 != 1) {
            if ((p->type_internal & 0xf) == 0) {
              mem_free(p);
            }
            goto LAB_230408d6;
          }
          type = MEMP_PBUF;
        }
        memp_free(type,p);
      }
      else {
        (*(code *)p[1].next)(p,p[1].next);
      }
LAB_230408d6:
      uVar1 = uVar1 + '\x01';
      p = ppVar3;
    } while (ppVar3 != (pbuf *)0x0);
  }
  return uVar1;
}



pbuf * pbuf_alloc(pbuf_layer layer,u16_t length,pbuf_type type)

{
  u8_t uVar1;
  uint uVar2;
  uint uVar3;
  pbuf *ppVar4;
  err_t eVar5;
  undefined3 in_register_00002029;
  pbuf *p;
  pbuf *ppVar6;
  undefined3 extraout_var;
  undefined2 in_register_0000202e;
  undefined2 in_register_00002032;
  uint uVar7;
  pbuf *ppVar8;
  
  uVar7 = CONCAT22(in_register_00002032,type);
  uVar3 = CONCAT22(in_register_0000202e,length);
  if (uVar7 != 0x41) {
    if (uVar7 < 0x42) {
      if (uVar7 == 1) goto LAB_230409bc;
    }
    else {
      uVar2 = CONCAT31(in_register_00002029,layer) & 0xffff;
      if (uVar7 == 0x182) {
        p = (pbuf *)0x0;
        ppVar8 = (pbuf *)0x0;
        while (ppVar6 = (pbuf *)memp_malloc(MEMP_PBUF_POOL), ppVar6 != (pbuf *)0x0) {
          uVar7 = 0x2f8 - (uVar2 + 3 & 0xfffffffc);
          if (uVar3 < (uVar7 & 0xffff)) {
            uVar7 = uVar3;
          }
          ppVar6->next = (pbuf *)0x0;
          ppVar6->payload = (void *)((int)&ppVar6[1].next + uVar2 + 3 & 0xfffffffc);
          ppVar6->tot_len = (u16_t)uVar3;
          ppVar6->len = (u16_t)uVar7;
          *(undefined4 *)&ppVar6->type_internal = 0x10082;
          ppVar4 = ppVar6;
          if (p != (pbuf *)0x0) {
            ppVar8->next = ppVar6;
            ppVar4 = p;
          }
          uVar3 = uVar3 - (uVar7 & 0xffff) & 0xffff;
          uVar2 = 0;
          p = ppVar4;
          ppVar8 = ppVar6;
          if (uVar3 == 0) {
            return ppVar4;
          }
        }
        sys_arch_protect();
        uVar1 = pbuf_free_ooseq_pending;
        pbuf_free_ooseq_pending = '\x01';
        sys_arch_unprotect();
        if ((uVar1 == '\0') &&
           (eVar5 = tcpip_try_callback(pbuf_free_ooseq_callback,(void *)0x0),
           CONCAT31(extraout_var,eVar5) != 0)) {
          sys_arch_protect();
          pbuf_free_ooseq_pending = '\0';
          sys_arch_unprotect();
        }
        if (p != (pbuf *)0x0) {
          pbuf_free(p);
        }
      }
      else {
        if (uVar7 == 0x280) {
          uVar7 = uVar3 + 3 & 0xfffffffc;
          uVar3 = (uVar2 + 3 & 0xfffffffc) + uVar7 & 0xffff;
          if ((uVar7 <= uVar3) && (uVar7 <= (uVar3 + 0x10 & 0xffff))) {
            p = (pbuf *)mem_malloc();
            if (p == (pbuf *)0x0) {
              return (pbuf *)0x0;
            }
            p->next = (pbuf *)0x0;
            p->payload = (void *)((int)&p[1].next + CONCAT31(in_register_00002029,layer) + 3 &
                                 0xfffffffc);
            p->tot_len = length;
            p->len = length;
            *(undefined4 *)&p->type_internal = 0x10080;
            return p;
          }
        }
      }
    }
    return (pbuf *)0x0;
  }
LAB_230409bc:
  p = pbuf_alloc_reference((void *)0x0,length,type);
  return p;
}



void pbuf_realloc(pbuf *p,u16_t new_len)

{
  ushort uVar1;
  uint uVar2;
  undefined2 in_register_0000202e;
  uint uVar3;
  
  uVar2 = CONCAT22(in_register_0000202e,new_len);
  uVar1 = p->tot_len;
  if (uVar2 < uVar1) {
    while (uVar3 = (uint)p->len, uVar3 < uVar2) {
      p->tot_len = p->tot_len + (new_len - uVar1);
      uVar2 = uVar2 - uVar3 & 0xffff;
      p = p->next;
    }
    if ((((p->type_internal & 0xf) == 0) && (uVar3 != uVar2)) && ((p->flags & 2) == 0)) {
      p = (pbuf *)mem_trim(p,(int)p->payload + (uVar2 - (int)p) & 0xffff);
    }
    p->len = (u16_t)uVar2;
    p->tot_len = (u16_t)uVar2;
    if (p->next != (pbuf *)0x0) {
      pbuf_free(p->next);
    }
    p->next = (pbuf *)0x0;
    return;
  }
  return;
}



pbuf * pbuf_free_header(pbuf *q,u16_t size)

{
  pbuf *ppVar1;
  undefined2 in_register_0000202e;
  uint header_size_decrement;
  
  header_size_decrement = CONCAT22(in_register_0000202e,size);
  while( true ) {
    if (header_size_decrement == 0) {
      return q;
    }
    if (q == (pbuf *)0x0) break;
    if (header_size_decrement < q->len) {
      pbuf_remove_header(q,header_size_decrement);
      return q;
    }
    ppVar1 = q->next;
    header_size_decrement = header_size_decrement - q->len & 0xffff;
    q->next = (pbuf *)0x0;
    pbuf_free(q);
    q = ppVar1;
  }
  return (pbuf *)0x0;
}



u16_t pbuf_clen(pbuf *p)

{
  u16_t uVar1;
  
  uVar1 = 0;
  while (p != (pbuf *)0x0) {
    uVar1 = uVar1 + 1;
    p = p->next;
  }
  return uVar1;
}



void pbuf_ref(pbuf *p)

{
  if (p != (pbuf *)0x0) {
    sys_arch_protect();
    p->ref = p->ref + '\x01';
    sys_arch_unprotect();
    return;
  }
  return;
}



void pbuf_cat(pbuf *h,pbuf *t)

{
  pbuf *ppVar1;
  
  if (h != (pbuf *)0x0) {
    if (t == (pbuf *)0x0) {
      return;
    }
    do {
      ppVar1 = h;
      ppVar1->tot_len = (u16_t)(((uint)ppVar1->tot_len + (uint)t->tot_len) * 0x10000 >> 0x10);
      h = ppVar1->next;
    } while (ppVar1->next != (pbuf *)0x0);
    ppVar1->next = t;
  }
  return;
}



void pbuf_chain(pbuf *h,pbuf *t)

{
  pbuf_cat(h,t);
  pbuf_ref(t);
  return;
}



err_t pbuf_copy(pbuf *p_to,pbuf *p_from)

{
  err_t eVar1;
  uint uVar2;
  uint __n;
  uint uVar3;
  uint uVar4;
  
  if (p_to == (pbuf *)0x0) {
    return -0x10;
  }
  if ((p_from == (pbuf *)0x0) || (p_to->tot_len < p_from->tot_len)) {
LAB_23040c06:
    eVar1 = -0x10;
  }
  else {
    uVar4 = 0;
    uVar3 = 0;
    do {
      __n = p_to->len - uVar3;
      uVar2 = p_from->len - uVar4;
      if (uVar2 < __n) {
        __n = uVar2;
      }
      memcpy((void *)((int)p_to->payload + uVar3),(void *)((int)p_from->payload + uVar4),__n);
      uVar4 = uVar4 + __n;
      uVar3 = uVar3 + __n;
      if (p_from->len <= uVar4) {
        p_from = p_from->next;
        uVar4 = 0;
      }
      if (uVar3 == (uint)p_to->len) {
        p_to = p_to->next;
        if (p_to == (pbuf *)0x0) {
          if (p_from == (pbuf *)0x0) {
            return '\0';
          }
          goto LAB_23040c06;
        }
        uVar3 = 0;
      }
      if ((((p_from != (pbuf *)0x0) && (p_from->len == p_from->tot_len)) &&
          (p_from->next != (pbuf *)0x0)) ||
         ((p_to->len == p_to->tot_len && (p_to->next != (pbuf *)0x0)))) {
        return -6;
      }
    } while (p_from != (pbuf *)0x0);
    eVar1 = '\0';
  }
  return eVar1;
}



u16_t pbuf_copy_partial(pbuf *buf,void *dataptr,u16_t len,u16_t offset)

{
  u16_t uVar1;
  uint uVar2;
  uint uVar3;
  uint __n;
  undefined2 in_register_00002032;
  undefined2 in_register_00002036;
  uint uVar4;
  
  uVar4 = CONCAT22(in_register_00002036,offset);
  uVar3 = CONCAT22(in_register_00002032,len);
  uVar1 = 0;
  if (buf != (pbuf *)0x0) {
    uVar2 = 0;
    uVar1 = 0;
    if (dataptr != (void *)0x0) {
      while ((uVar1 = (u16_t)uVar2, uVar3 != 0 && (buf != (pbuf *)0x0))) {
        __n = (uint)buf->len;
        if ((uVar4 == 0) || (uVar4 < __n)) {
          __n = __n - uVar4 & 0xffff;
          if (uVar3 < __n) {
            __n = uVar3;
          }
          __n = __n & 0xffff;
          memcpy((void *)((int)dataptr + uVar2),(void *)((int)buf->payload + uVar4),__n);
          uVar2 = uVar2 + __n & 0xffff;
          uVar3 = uVar3 - __n & 0xffff;
          uVar4 = 0;
        }
        else {
          uVar4 = uVar4 - __n & 0xffff;
        }
        buf = buf->next;
      }
    }
  }
  return uVar1;
}



err_t pbuf_take(pbuf *buf,void *dataptr,u16_t len)

{
  uint uVar1;
  err_t eVar2;
  undefined2 in_register_00002032;
  uint __n;
  int iVar3;
  
  uVar1 = CONCAT22(in_register_00002032,len);
  if (buf != (pbuf *)0x0) {
    eVar2 = -0x10;
    if (dataptr != (void *)0x0) {
      eVar2 = -1;
      iVar3 = 0;
      if (uVar1 <= buf->tot_len) {
        while (uVar1 != 0) {
          __n = (uint)buf->len;
          if (uVar1 < (uint)buf->len) {
            __n = uVar1;
          }
          memcpy(buf->payload,(void *)((int)dataptr + iVar3),__n);
          buf = buf->next;
          uVar1 = uVar1 - __n;
          iVar3 = iVar3 + __n;
        }
        eVar2 = '\0';
      }
    }
    return eVar2;
  }
  return -0x10;
}



err_t pbuf_take_at(pbuf *buf,void *dataptr,u16_t len,u16_t offset)

{
  err_t eVar1;
  pbuf *ppVar2;
  undefined2 in_register_00002032;
  size_t sVar3;
  uint uVar4;
  uint uVar5;
  size_t __n;
  u16_t auStack34 [2];
  u16_t target_offset;
  
  sVar3 = CONCAT22(in_register_00002032,len);
  ppVar2 = pbuf_skip_const(buf,offset,auStack34);
  if (ppVar2 == (pbuf *)0x0) {
    eVar1 = -1;
  }
  else {
    uVar4 = (uint)auStack34[0];
    eVar1 = -1;
    if ((int)(uVar4 + sVar3) <= (int)(uint)ppVar2->tot_len) {
      uVar5 = ppVar2->len - uVar4;
      __n = sVar3;
      if ((int)uVar5 < (int)sVar3) {
        __n = uVar5 & 0xffff;
      }
      memcpy((void *)((int)ppVar2->payload + uVar4),dataptr,__n);
      eVar1 = '\0';
      if ((sVar3 - __n & 0xffff) != 0) {
        eVar1 = pbuf_take(ppVar2->next,(void *)((int)dataptr + __n),
                          (u16_t)((sVar3 - __n) * 0x10000 >> 0x10));
      }
    }
  }
  return eVar1;
}



pbuf * pbuf_clone(pbuf_layer layer,pbuf_type type,pbuf *p)

{
  pbuf *p_to;
  
  p_to = pbuf_alloc(layer,p->tot_len,type);
  if (p_to != (pbuf *)0x0) {
    pbuf_copy(p_to,p);
  }
  return p_to;
}



int pbuf_try_get_at(pbuf *p,u16_t offset)

{
  pbuf *ppVar1;
  uint uVar2;
  u16_t auStack18 [2];
  u16_t q_idx;
  
  ppVar1 = pbuf_skip_const(p,offset,auStack18);
  uVar2 = 0xffffffff;
  if (ppVar1 != (pbuf *)0x0) {
    uVar2 = 0xffffffff;
    if ((uint)auStack18[0] < (uint)ppVar1->len) {
      uVar2 = (uint)*(byte *)((int)ppVar1->payload + (uint)auStack18[0]);
    }
  }
  return uVar2;
}



u8_t pbuf_get_at(pbuf *p,u16_t offset)

{
  u8_t uVar1;
  
  _uVar1 = pbuf_try_get_at(p,offset);
  uVar1 = (u8_t)_uVar1;
  if (_uVar1 < 0) {
    uVar1 = '\0';
  }
  return uVar1;
}



void pbuf_put_at(pbuf *p,u16_t offset,u8_t data)

{
  pbuf *ppVar1;
  u16_t auStack18 [2];
  u16_t q_idx;
  
  ppVar1 = pbuf_skip_const(p,offset,auStack18);
  if ((ppVar1 != (pbuf *)0x0) && ((uint)auStack18[0] < (uint)ppVar1->len)) {
    *(u8_t *)((int)ppVar1->payload + (uint)auStack18[0]) = data;
  }
  return;
}



u16_t pbuf_memcmp(pbuf *p,u16_t offset,void *s2,u16_t n)

{
  byte *pbVar1;
  ushort *puVar2;
  uint uVar3;
  u8_t uVar4;
  undefined3 extraout_var;
  undefined2 in_register_0000202e;
  undefined2 in_register_00002036;
  short sVar5;
  uint uVar6;
  
  uVar3 = CONCAT22(in_register_0000202e,offset);
  if ((int)(uint)p->tot_len < (int)(uVar3 + CONCAT22(in_register_00002036,n))) {
    return 0xffff;
  }
  do {
    puVar2 = &p->len;
    if (uVar3 < *puVar2) break;
    p = p->next;
    uVar3 = uVar3 - *puVar2 & 0xffff;
  } while (p != (pbuf *)0x0);
  uVar6 = 0;
  do {
    _sVar5 = uVar6 & 0xffff;
    sVar5 = (short)_sVar5;
    if (CONCAT22(in_register_00002036,n) <= _sVar5) {
      return 0;
    }
    uVar4 = pbuf_get_at(p,(u16_t)((_sVar5 + uVar3) * 0x10000 >> 0x10));
    pbVar1 = (byte *)((int)s2 + uVar6);
    uVar6 = uVar6 + 1;
  } while ((uint)*pbVar1 == CONCAT31(extraout_var,uVar4));
  if (0xfffe < _sVar5) {
    sVar5 = -2;
  }
  return sVar5 + 1;
}



u16_t pbuf_memfind(pbuf *p,void *mem,u16_t mem_len,u16_t start_offset)

{
  ushort uVar1;
  uint uVar2;
  u16_t uVar3;
  undefined2 extraout_var;
  undefined2 in_register_00002032;
  undefined2 in_register_00002036;
  
  uVar2 = CONCAT22(in_register_00002036,start_offset);
  uVar1 = p->tot_len;
  if ((int)(CONCAT22(in_register_00002032,mem_len) + uVar2) <= (int)(uint)uVar1) {
    while (uVar2 <= ((uint)uVar1 - CONCAT22(in_register_00002032,mem_len) & 0xffff)) {
      uVar3 = pbuf_memcmp(p,(u16_t)uVar2,mem,mem_len);
      if (CONCAT22(extraout_var,uVar3) == 0) {
        return (u16_t)uVar2;
      }
      uVar2 = uVar2 + 1 & 0xffff;
    }
  }
  return 0xffff;
}



raw_input_state_t raw_input(pbuf *p,netif *inp)

{
  u8_t uVar1;
  raw_pcb *prVar2;
  raw_pcb *prVar3;
  u8_t uVar4;
  raw_input_state_t rVar5;
  u8_t uVar6;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  u32_t uVar7;
  raw_pcb *prVar8;
  
  uVar4 = ip4_addr_isbroadcast_u32(ip_data.current_iphdr_dest,ip_data.current_netif);
  uVar1 = *(u8_t *)((int)p->payload + 9);
  rVar5 = RAW_INPUT_NONE;
  prVar2 = raw_pcbs;
  prVar8 = (raw_pcb *)0x0;
  do {
    prVar3 = prVar2;
    if (prVar3 == (raw_pcb *)0x0) {
      return rVar5;
    }
    if ((prVar3->protocol == uVar1) &&
       ((prVar3->netif_idx == '\0' ||
        (prVar3->netif_idx == (u8_t)((ip_data.current_input_netif)->num + '\x01'))))) {
      uVar7 = (prVar3->local_ip).addr;
      if (CONCAT31(extraout_var,uVar4) == 0) {
        if ((uVar7 == 0) || (ip_data.current_iphdr_dest == uVar7)) goto LAB_23040f92;
      }
      else {
        if (uVar7 == 0) {
LAB_23040f92:
          if ((((prVar3->flags & 1) == 0) || ((prVar3->remote_ip).addr == ip_data.current_iphdr_src)
              ) && (prVar3->recv != (raw_recv_fn *)0x0)) {
            uVar6 = (*prVar3->recv)(prVar3->recv_arg,prVar3,p,(ip_addr_t *)0x4201fed0);
            if (CONCAT31(extraout_var_00,uVar6) != 0) {
              if (prVar8 == (raw_pcb *)0x0) {
                return RAW_INPUT_EATEN;
              }
              prVar8->next = prVar3->next;
              prVar3->next = raw_pcbs;
              raw_pcbs = prVar3;
              return RAW_INPUT_EATEN;
            }
            rVar5 = RAW_INPUT_DELIVERED;
          }
        }
      }
    }
    prVar2 = prVar3->next;
    prVar8 = prVar3;
  } while( true );
}



err_t raw_bind(raw_pcb *pcb,ip_addr_t *ipaddr)

{
  err_t eVar1;
  
  eVar1 = -6;
  if ((pcb != (raw_pcb *)0x0) && (ipaddr != (ip_addr_t *)0x0)) {
    (pcb->local_ip).addr = ipaddr->addr;
    eVar1 = '\0';
  }
  return eVar1;
}



void raw_bind_netif(raw_pcb *pcb,netif *netif)

{
  u8_t uVar1;
  
  uVar1 = '\0';
  if (netif != (netif *)0x0) {
    uVar1 = netif->num + '\x01';
  }
  pcb->netif_idx = uVar1;
  return;
}



err_t raw_connect(raw_pcb *pcb,ip_addr_t *ipaddr)

{
  if ((pcb != (raw_pcb *)0x0) && (ipaddr != (ip_addr_t *)0x0)) {
    (pcb->remote_ip).addr = ipaddr->addr;
    pcb->flags = pcb->flags | 1;
    return '\0';
  }
  return -6;
}



void raw_recv(raw_pcb *pcb,raw_recv_fn *recv,void *recv_arg)

{
  pcb->recv = recv;
  pcb->recv_arg = recv_arg;
  return;
}



err_t raw_sendto_if_src(raw_pcb *pcb,pbuf *p,ip_addr_t *dst_ip,netif *netif,ip_addr_t *src_ip)

{
  err_t eVar1;
  u8_t ttl;
  undefined3 extraout_var;
  pbuf *h;
  undefined3 extraout_var_00;
  
  if ((((pcb == (raw_pcb *)0x0) || (dst_ip == (ip_addr_t *)0x0)) || (netif == (netif *)0x0)) ||
     (src_ip == (ip_addr_t *)0x0)) {
    return -6;
  }
  if ((pcb->flags & 2) != 0) {
    if (p->len < 0x14) {
      return -6;
    }
    eVar1 = ip4_output_if(p,(ip4_addr_t *)src_ip,(ip4_addr_t *)0x0,'\0','\0','\0',netif);
    return eVar1;
  }
  if (0xffeb < p->tot_len) {
    return -1;
  }
  ttl = pbuf_add_header(p,0x14);
  if (CONCAT31(extraout_var,ttl) == 0) {
    ttl = pbuf_remove_header(p,0x14);
    h = p;
    if (CONCAT31(extraout_var_00,ttl) != 0) {
      return -1;
    }
  }
  else {
    h = pbuf_alloc(PBUF_IP,0,PBUF_RAM);
    if (h == (pbuf *)0x0) {
      return -1;
    }
    if (p->tot_len != 0) {
      pbuf_chain(h,p);
    }
  }
  if ((pcb->flags & 4) == 0) {
LAB_23041106:
    if ((dst_ip->addr & 0xf0) == 0xe0) {
      ttl = pcb->mcast_ttl;
      goto LAB_2304111a;
    }
  }
  else {
    if ((dst_ip->addr & 0xf0) == 0xe0) {
      h->flags = h->flags | 4;
      goto LAB_23041106;
    }
  }
  ttl = pcb->ttl;
LAB_2304111a:
  eVar1 = ip4_output_if(h,(ip4_addr_t *)src_ip,(ip4_addr_t *)dst_ip,ttl,pcb->tos,pcb->protocol,netif
                       );
  if (p != h) {
    pbuf_free(h);
    return eVar1;
  }
  return eVar1;
}



err_t raw_sendto(raw_pcb *pcb,pbuf *p,ip_addr_t *ipaddr)

{
  err_t eVar1;
  netif *netif;
  raw_pcb *src_ip;
  uint uVar2;
  
  if ((pcb == (raw_pcb *)0x0) || (ipaddr == (ip_addr_t *)0x0)) {
    return -6;
  }
  if (pcb->netif_idx == '\0') {
    if (((ipaddr->addr & 0xf0) == 0xe0) &&
       (netif = netif_get_by_index(pcb->mcast_ifindex), netif != (netif *)0x0)) goto LAB_230411a2;
    netif = ip4_route((ip4_addr_t *)ipaddr);
  }
  else {
    netif = netif_get_by_index(pcb->netif_idx);
  }
  if (netif == (netif *)0x0) {
    return -4;
  }
LAB_230411a2:
  uVar2 = (pcb->local_ip).addr;
  if ((uVar2 == 0) || (src_ip = pcb, (uVar2 & 0xf0) == 0xe0)) {
    src_ip = (raw_pcb *)&netif->ip_addr;
  }
  eVar1 = raw_sendto_if_src(pcb,p,ipaddr,netif,(ip_addr_t *)src_ip);
  return eVar1;
}



err_t raw_send(raw_pcb *pcb,pbuf *p)

{
  err_t eVar1;
  
  eVar1 = raw_sendto(pcb,p,&pcb->remote_ip);
  return eVar1;
}



void raw_remove(raw_pcb *pcb)

{
  raw_pcb *prVar1;
  raw_pcb *prVar2;
  
  prVar1 = raw_pcbs;
  if (raw_pcbs == pcb) {
    raw_pcbs = pcb->next;
  }
  else {
    do {
      prVar2 = prVar1;
      if ((prVar2 == (raw_pcb *)0x0) || (prVar1 = prVar2->next, prVar1 == (raw_pcb *)0x0))
      goto LAB_230411f0;
    } while (prVar1 != pcb);
    prVar2->next = pcb->next;
  }
LAB_230411f0:
  memp_free(MEMP_RAW_PCB,pcb);
  return;
}



raw_pcb * raw_new(u8_t proto)

{
  raw_pcb *prVar1;
  raw_pcb *__s;
  
  __s = (raw_pcb *)memp_malloc(MEMP_RAW_PCB);
  if (__s != (raw_pcb *)0x0) {
    memset(__s,0,0x1c);
    __s->ttl = -1;
    __s->mcast_ttl = -1;
    __s->protocol = proto;
    prVar1 = __s;
    __s->next = raw_pcbs;
    raw_pcbs = prVar1;
  }
  return __s;
}



raw_pcb * raw_new_ip_type(u8_t type,u8_t proto)

{
  raw_pcb *prVar1;
  
  prVar1 = raw_new(proto);
  return prVar1;
}



void raw_netif_ip_addr_changed(ip_addr_t *old_addr,ip_addr_t *new_addr)

{
  raw_pcb *prVar1;
  
  if ((((old_addr != (ip_addr_t *)0x0) && (old_addr->addr != 0)) && (new_addr != (ip_addr_t *)0x0))
     && (prVar1 = raw_pcbs, new_addr->addr != 0)) {
    while (prVar1 != (raw_pcb *)0x0) {
      if ((prVar1->local_ip).addr == old_addr->addr) {
        (prVar1->local_ip).addr = new_addr->addr;
      }
      prVar1 = prVar1->next;
    }
  }
  return;
}



raw_pcb * raw_get_pcbs(void)

{
  return raw_pcbs;
}



void stats_init(void)

{
  return;
}



// WARNING: Variable defined which should be unmapped: ip_str
// WARNING: Type propagation algorithm not settling

void stats_netstat(void *ctx)

{
  ushort uVar1;
  ip4_addr_t addr;
  int iVar2;
  udp_pcb *addr_00;
  raw_pcb *addr_01;
  char *pcVar3;
  int iVar4;
  tcp_pcb ***ppptStack164;
  tcp_pcb ***_tcp_pcb_list;
  char ip_str [128];
  
  memset(&_tcp_pcb_list,0,0x80);
  ppptStack164 = (tcp_pcb ***)0x0;
  iVar2 = tcp_get_pcbs(&ppptStack164);
  addr_00 = udp_get_pcbs();
  addr_01 = raw_get_pcbs();
  printf("netstat tools\r\n");
  iVar4 = 0;
  while (iVar4 < iVar2) {
    addr = (ip4_addr_t)((ip4_addr_t *)ppptStack164[iVar4])->addr;
    while (addr != (ip4_addr_t)0x0) {
      ip4addr_ntoa_r((ip4_addr_t *)addr,(char *)&_tcp_pcb_list,0x80);
      printf("TCP\t%s:%hu\t",&_tcp_pcb_list,
             (uint)*(ushort *)((int)&((ip4_addr_t *)((int)addr + 0x14))->addr + 2));
      ip4addr_ntoa_r((ip4_addr_t *)((int)addr + 4),(char *)&_tcp_pcb_list,0x80);
      uVar1 = *(ushort *)&((ip4_addr_t *)((int)addr + 0x18))->addr;
      pcVar3 = tcp_debug_state_str(*(tcp_state *)&((ip4_addr_t *)((int)addr + 0x14))->addr);
      printf("%s:%hu\t%s\r\n",&_tcp_pcb_list,(uint)uVar1,pcVar3);
      addr = (ip4_addr_t)((ip4_addr_t *)&((ip4_addr_t *)((int)addr + 0xc))->addr)->addr;
    }
    iVar4 = iVar4 + 1;
  }
  while (addr_00 != (udp_pcb *)0x0) {
    ip4addr_ntoa_r((ip4_addr_t *)addr_00,(char *)&_tcp_pcb_list,0x80);
    printf("UDP\t%s:%hu\t",&_tcp_pcb_list,(uint)addr_00->local_port);
    ip4addr_ntoa_r((ip4_addr_t *)&addr_00->remote_ip,(char *)&_tcp_pcb_list,0x80);
    printf("%s:%hu\r\n",&_tcp_pcb_list,(uint)addr_00->remote_port);
    addr_00 = addr_00->next;
  }
  while (addr_01 != (raw_pcb *)0x0) {
    ip4addr_ntoa_r((ip4_addr_t *)addr_01,(char *)&_tcp_pcb_list,0x80);
    printf("RAW\t%s\t",&_tcp_pcb_list);
    ip4addr_ntoa_r((ip4_addr_t *)&addr_01->remote_ip,(char *)&_tcp_pcb_list,0x80);
    printf("%s\t%d\r\n",&_tcp_pcb_list,(uint)addr_01->protocol);
    addr_01 = addr_01->next;
  }
  return;
}



u16_t tcp_new_port(void)

{
  uint uVar1;
  uint uVar2;
  u32_t uVar3;
  tcp_pcb ***ppptVar4;
  
  uVar2 = 0x4000;
again:
  tcp_port = tcp_port + 1;
  if (tcp_port == 0xffff) {
    tcp_port = 0xc000;
  }
  ppptVar4 = tcp_pcb_lists;
  do {
    uVar3 = (((tcp_pcb *)*ppptVar4)->local_ip).addr;
    while (uVar3 != 0) {
      if (*(u16_t *)(uVar3 + 0x16) == tcp_port) {
        uVar1 = uVar2 - 1;
        uVar2 = uVar1 & 0xffff;
        if (uVar2 == 0) {
          return (u16_t)(uVar1 * 0x10000 >> 0x10);
        }
        goto again;
      }
      uVar3 = *(u32_t *)(uVar3 + 0xc);
    }
    ppptVar4 = (tcp_pcb ***)((tcp_pcb **)ppptVar4 + 1);
    if (ppptVar4 == (tcp_pcb ***)tcp_state_str) {
      return tcp_port;
    }
  } while( true );
}



err_t tcp_close_shutdown_fin(tcp_pcb *pcb)

{
  err_t eVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  tcp_state tVar2;
  
  tVar2 = pcb->state;
  if (tVar2 != ESTABLISHED) {
    if (tVar2 == CLOSE_WAIT) {
      eVar1 = tcp_send_fin(pcb);
      _eVar1 = CONCAT31(extraout_var_00,eVar1);
      if (_eVar1 != 0) goto LAB_2304146c;
      tVar2 = LAST_ACK;
      goto LAB_2304144a;
    }
    if (tVar2 != SYN_RCVD) {
      return '\0';
    }
  }
  eVar1 = tcp_send_fin(pcb);
  _eVar1 = CONCAT31(extraout_var,eVar1);
  if (_eVar1 != 0) {
LAB_2304146c:
    if (_eVar1 == -1) {
      pcb->flags = pcb->flags | 8;
      return '\0';
    }
    return (err_t)_eVar1;
  }
  tVar2 = FIN_WAIT_1;
LAB_2304144a:
  pcb->state = tVar2;
  tcp_output(pcb);
  return '\0';
}



void tcp_init(void)

{
  uint uVar1;
  
  uVar1 = bl_rand();
  tcp_port = (u16_t)(((uVar1 & 0x3fff) - 0x4000) * 0x10000 >> 0x10);
  printf("-------------------->>>>>>>> LWIP tcp_port %u\r\n");
  return;
}



void tcp_free(tcp_pcb *pcb)

{
  memp_free(MEMP_TCP_PCB,pcb);
  return;
}



err_t tcp_bind(tcp_pcb *pcb,ip_addr_t *ipaddr,u16_t port)

{
  tcp_pcb *ptVar1;
  err_t eVar2;
  undefined2 extraout_var;
  int iVar3;
  undefined2 in_register_00002032;
  tcp_pcb ***ppptVar4;
  u32_t *puVar5;
  
  if (ipaddr == (ip_addr_t *)0x0) {
    ipaddr = &ip_addr_any;
  }
  eVar2 = -0x10;
  if ((pcb != (tcp_pcb *)0x0) && (eVar2 = -6, pcb->state == CLOSED)) {
    if (CONCAT22(in_register_00002032,port) == 0) {
      port = tcp_new_port();
      if (CONCAT22(extraout_var,port) == 0) {
        return -2;
      }
    }
    else {
      ppptVar4 = tcp_pcb_lists;
      iVar3 = 0;
      do {
        puVar5 = (u32_t *)(((tcp_pcb *)*ppptVar4)->local_ip).addr;
        while (puVar5 != (u32_t *)0x0) {
          if ((((uint)*(ushort *)((int)puVar5 + 0x16) == CONCAT22(in_register_00002032,port)) &&
              (((pcb->so_options & 4) == 0 || ((*(byte *)((int)puVar5 + 9) & 4) == 0)))) &&
             ((*puVar5 == 0 || ((ipaddr->addr == 0 || (*puVar5 == ipaddr->addr)))))) {
            return -8;
          }
          puVar5 = (u32_t *)puVar5[3];
        }
        iVar3 = iVar3 + 1;
        ppptVar4 = (tcp_pcb ***)((tcp_pcb **)ppptVar4 + 1);
      } while ((uint)((pcb->so_options & 4) == 0) + 3 != iVar3);
    }
    if (ipaddr->addr != 0) {
      (pcb->local_ip).addr = ipaddr->addr;
    }
    pcb->local_port = port;
    ptVar1 = pcb;
    pcb->next = tcp_bound_pcbs;
    tcp_bound_pcbs = ptVar1;
    tcp_timer_needed();
    eVar2 = '\0';
  }
  return eVar2;
}



void tcp_bind_netif(tcp_pcb *pcb,netif *netif)

{
  u8_t uVar1;
  
  uVar1 = '\0';
  if (netif != (netif *)0x0) {
    uVar1 = netif->num + '\x01';
  }
  pcb->netif_idx = uVar1;
  return;
}



tcp_pcb * tcp_listen_with_backlog_and_err(tcp_pcb *pcb,u8_t backlog,err_t *err)

{
  u8_t uVar1;
  tcp_pcb *ptVar2;
  tcp_pcb *ptVar3;
  err_t eVar4;
  tcp_pcb *ptVar5;
  
  if (pcb == (tcp_pcb *)0x0) {
    ptVar3 = (tcp_pcb *)0x0;
    eVar4 = -0x10;
  }
  else {
    if (pcb->state == CLOSED) {
      ptVar3 = tcp_listen_pcbs;
      if ((pcb->so_options & 4) != 0) {
        while (ptVar3 != (tcp_pcb *)0x0) {
          if ((ptVar3->local_port == pcb->local_port) &&
             ((ptVar3->local_ip).addr == (pcb->local_ip).addr)) {
            eVar4 = -8;
            goto LAB_2304166a;
          }
          ptVar3 = ptVar3->next;
        }
      }
      ptVar3 = (tcp_pcb *)memp_malloc(MEMP_TCP_PCB_LISTEN);
      eVar4 = -1;
      if (ptVar3 != (tcp_pcb *)0x0) {
        ptVar3->callback_arg = pcb->callback_arg;
        ptVar3->local_port = pcb->local_port;
        ptVar3->state = LISTEN;
        ptVar3->prio = pcb->prio;
        uVar1 = pcb->so_options;
        ptVar3->netif_idx = '\0';
        ptVar3->so_options = uVar1;
        ptVar3->ttl = pcb->ttl;
        ptVar3->tos = pcb->tos;
        (ptVar3->local_ip).addr = (pcb->local_ip).addr;
        if (pcb->local_port != 0) {
          ptVar2 = tcp_bound_pcbs;
          if (tcp_bound_pcbs == pcb) {
            tcp_bound_pcbs = pcb->next;
          }
          else {
            do {
              ptVar5 = ptVar2;
              if (ptVar5 == (tcp_pcb *)0x0) goto LAB_230415fc;
              ptVar2 = ptVar5->next;
            } while (ptVar5->next != pcb);
            ptVar5->next = pcb->next;
          }
LAB_230415fc:
          pcb->next = (tcp_pcb *)0x0;
        }
        tcp_free(pcb);
        *(undefined4 *)&ptVar3->remote_port = 0x23041bc6;
        ptVar2 = ptVar3;
        ptVar3->next = tcp_listen_pcbs;
        tcp_listen_pcbs = ptVar2;
        tcp_timer_needed();
        eVar4 = '\0';
      }
    }
    else {
      eVar4 = -0xf;
LAB_2304166a:
      ptVar3 = (tcp_pcb *)0x0;
    }
  }
  if (err != (err_t *)0x0) {
    *err = eVar4;
  }
  return ptVar3;
}



u32_t tcp_update_rcv_ann_wnd(tcp_pcb *pcb)

{
  u32_t uVar1;
  u32_t uVar2;
  u32_t uVar3;
  uint uVar4;
  
  uVar3 = pcb->rcv_ann_right_edge;
  uVar2 = pcb->rcv_nxt;
  uVar4 = (uint)pcb->mss;
  uVar1 = (pcb->rcv_wnd - uVar3) + uVar2;
  if (0x408 < pcb->mss) {
    uVar4 = 0x408;
  }
  if (-1 < (int)(uVar1 - uVar4)) {
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
    return uVar1;
  }
  if ((int)(uVar2 - uVar3) < 1) {
    pcb->rcv_ann_wnd = (short)uVar3 - (short)uVar2;
  }
  else {
    pcb->rcv_ann_wnd = 0;
  }
  return 0;
}



void tcp_recved(tcp_pcb *pcb,u16_t len)

{
  u32_t uVar1;
  tcpwnd_size_t tVar2;
  
  if (pcb == (tcp_pcb *)0x0) {
    return;
  }
  tVar2 = len + pcb->rcv_wnd;
  if ((0x810 < tVar2) || (tVar2 < pcb->rcv_wnd)) {
    tVar2 = 0x810;
  }
  pcb->rcv_wnd = tVar2;
  uVar1 = tcp_update_rcv_ann_wnd(pcb);
  if (0x407 < uVar1) {
    pcb->flags = pcb->flags | 2;
    tcp_output(pcb);
    return;
  }
  return;
}



void tcp_seg_free(tcp_seg *seg)

{
  if (seg == (tcp_seg *)0x0) {
    return;
  }
  if (seg->p != (pbuf *)0x0) {
    pbuf_free(seg->p);
  }
  memp_free(MEMP_TCP_SEG,seg);
  return;
}



void tcp_segs_free(tcp_seg *seg)

{
  tcp_seg *ptVar1;
  
  if (seg != (tcp_seg *)0x0) {
    do {
      ptVar1 = seg->next;
      tcp_seg_free(seg);
      seg = ptVar1;
    } while (ptVar1 != (tcp_seg *)0x0);
    return;
  }
  return;
}



void tcp_setprio(tcp_pcb *pcb,u8_t prio)

{
  if (pcb != (tcp_pcb *)0x0) {
    pcb->prio = prio;
  }
  return;
}



tcp_seg * tcp_seg_copy(tcp_seg *seg)

{
  tcp_seg *__dest;
  
  __dest = (tcp_seg *)memp_malloc(MEMP_TCP_SEG);
  if (__dest != (tcp_seg *)0x0) {
    memcpy(__dest,seg,0x14);
    pbuf_ref(__dest->p);
  }
  return __dest;
}



void tcp_arg(tcp_pcb *pcb,void *arg)

{
  if (pcb != (tcp_pcb *)0x0) {
    pcb->callback_arg = arg;
  }
  return;
}



void tcp_recv(tcp_pcb *pcb,tcp_recv_fn *recv)

{
  if (pcb != (tcp_pcb *)0x0) {
    pcb->recv = recv;
  }
  return;
}



void tcp_sent(tcp_pcb *pcb,tcp_sent_fn *sent)

{
  if (pcb != (tcp_pcb *)0x0) {
    pcb->sent = sent;
  }
  return;
}



void tcp_err(tcp_pcb *pcb,tcp_err_fn *err)

{
  if (pcb != (tcp_pcb *)0x0) {
    pcb->errf = err;
  }
  return;
}



void tcp_accept(tcp_pcb *pcb,tcp_accept_fn accept)

{
  if ((pcb != (tcp_pcb *)0x0) && (pcb->state == LISTEN)) {
    *(tcp_accept_fn *)&pcb->remote_port = accept;
  }
  return;
}



void tcp_poll(tcp_pcb *pcb,tcp_poll_fn *poll,u8_t interval)

{
  if (pcb != (tcp_pcb *)0x0) {
    pcb->poll = poll;
    pcb->pollinterval = interval;
  }
  return;
}



u32_t tcp_next_iss(tcp_pcb *pcb)

{
  u32_t iss;
  
  return iss + tcp_ticks;
}



u16_t tcp_eff_send_mss_netif(u16_t sendmss,netif *outif,ip_addr_t *dest)

{
  ushort uVar1;
  u16_t uVar2;
  undefined2 in_register_0000202a;
  uint uVar3;
  
  uVar2 = sendmss;
  if (outif != (netif *)0x0) {
    uVar1 = outif->mtu;
    if (((uVar1 != 0) && (uVar2 = 0, 0x28 < uVar1)) &&
       (uVar3 = (uint)uVar1 - 0x28 & 0xffff, uVar2 = (u16_t)uVar3,
       CONCAT22(in_register_0000202a,sendmss) < uVar3)) {
      uVar2 = sendmss;
    }
  }
  return uVar2;
}



err_t tcp_connect(tcp_pcb *pcb,ip_addr_t *ipaddr,u16_t port,tcp_connected_fn connected)

{
  u16_t uVar1;
  err_t eVar2;
  u16_t uVar3;
  netif *outif;
  undefined2 extraout_var_00;
  u32_t uVar4;
  undefined3 extraout_var;
  undefined2 in_register_00002032;
  tcp_pcb *ptVar5;
  tcp_pcb *ptVar6;
  
  eVar2 = -0x10;
  if (((pcb != (tcp_pcb *)0x0) && (ipaddr != (ip_addr_t *)0x0)) &&
     (eVar2 = -10, pcb->state == CLOSED)) {
    (pcb->remote_ip).addr = ipaddr->addr;
    pcb->remote_port = port;
    if (pcb->netif_idx == '\0') {
      outif = ip4_route((ip4_addr_t *)&pcb->remote_ip);
    }
    else {
      outif = netif_get_by_index(pcb->netif_idx);
    }
    eVar2 = -4;
    if (outif != (netif *)0x0) {
      if ((pcb->local_ip).addr == 0) {
        (pcb->local_ip).addr = (outif->ip_addr).addr;
      }
      uVar1 = pcb->local_port;
      if (uVar1 == 0) {
        uVar3 = tcp_new_port();
        pcb->local_port = uVar3;
        if (CONCAT22(extraout_var_00,uVar3) == 0) {
          return -2;
        }
      }
      else {
        ptVar5 = tcp_active_pcbs;
        if ((pcb->so_options & 4) != 0) {
          while (ptVar6 = tcp_tw_pcbs, ptVar5 != (tcp_pcb *)0x0) {
            if (((ptVar5->local_port == uVar1) &&
                ((uint)ptVar5->remote_port == CONCAT22(in_register_00002032,port))) &&
               (((ptVar5->local_ip).addr == (pcb->local_ip).addr &&
                ((ptVar5->remote_ip).addr == ipaddr->addr)))) {
              return -8;
            }
            ptVar5 = ptVar5->next;
          }
          while (ptVar6 != (tcp_pcb *)0x0) {
            if (((ptVar6->local_port == uVar1) &&
                ((uint)ptVar6->remote_port == CONCAT22(in_register_00002032,port))) &&
               (((ptVar6->local_ip).addr == (pcb->local_ip).addr &&
                ((ptVar6->remote_ip).addr == ipaddr->addr)))) {
              return -8;
            }
            ptVar6 = ptVar6->next;
          }
        }
      }
      uVar4 = tcp_next_iss(pcb);
      *(undefined4 *)&pcb->rcv_wnd = 0x8100810;
      pcb->snd_nxt = uVar4;
      pcb->snd_wnd = 0x810;
      uVar4 = uVar4 - 1;
      pcb->lastack = uVar4;
      pcb->snd_wl2 = uVar4;
      pcb->snd_lbb = uVar4;
      pcb->mss = 0x218;
      pcb->rcv_nxt = 0;
      pcb->rcv_ann_right_edge = 0;
      uVar3 = tcp_eff_send_mss_netif(0x218,outif,&pcb->remote_ip);
      pcb->mss = uVar3;
      pcb->cwnd = 1;
      pcb->connected = connected;
      eVar2 = tcp_enqueue_flags(pcb,'\x02');
      if (CONCAT31(extraout_var,eVar2) == 0) {
        pcb->state = SYN_SENT;
        if (uVar1 != 0) {
          ptVar5 = tcp_bound_pcbs;
          if (tcp_bound_pcbs == pcb) {
            tcp_bound_pcbs = pcb->next;
          }
          else {
            do {
              ptVar6 = ptVar5;
              if (ptVar6 == (tcp_pcb *)0x0) goto LAB_2304193a;
              ptVar5 = ptVar6->next;
            } while (ptVar6->next != pcb);
            ptVar6->next = pcb->next;
          }
        }
LAB_2304193a:
        ptVar5 = pcb;
        pcb->next = tcp_active_pcbs;
        tcp_active_pcbs = ptVar5;
        tcp_timer_needed();
        tcp_active_pcbs_changed = '\x01';
        tcp_output(pcb);
      }
    }
  }
  return eVar2;
}



char * tcp_debug_state_str(tcp_state s)

{
  undefined3 in_register_00002029;
  
  return tcp_state_str[CONCAT31(in_register_00002029,s)];
}



err_t tcp_tcp_get_tcp_addrinfo(tcp_pcb *pcb,int local,ip_addr_t *addr,u16_t *port)

{
  u16_t uVar1;
  
  if (pcb == (tcp_pcb *)0x0) {
    return -6;
  }
  if (local == 0) {
    if (addr != (ip_addr_t *)0x0) {
      addr->addr = (pcb->remote_ip).addr;
    }
    if (port == (u16_t *)0x0) {
      return '\0';
    }
    uVar1 = pcb->remote_port;
  }
  else {
    if (addr != (ip_addr_t *)0x0) {
      addr->addr = (pcb->local_ip).addr;
    }
    if (port == (u16_t *)0x0) {
      return '\0';
    }
    uVar1 = pcb->local_port;
  }
  *port = uVar1;
  return '\0';
}



void tcp_free_ooseq(tcp_pcb *pcb)

{
  if (pcb->ooseq != (tcp_seg *)0x0) {
    tcp_segs_free(pcb->ooseq);
    pcb->ooseq = (tcp_seg *)0x0;
    return;
  }
  return;
}



void tcp_pcb_purge(tcp_pcb *pcb)

{
  if (((pcb != (tcp_pcb *)0x0) && (LISTEN < pcb->state)) && (pcb->state != TIME_WAIT)) {
    if (pcb->refused_data != (pbuf *)0x0) {
      pbuf_free(pcb->refused_data);
      pcb->refused_data = (pbuf *)0x0;
    }
    if (pcb->ooseq != (tcp_seg *)0x0) {
      tcp_free_ooseq(pcb);
    }
    pcb->rtime = -1;
    tcp_segs_free(pcb->unsent);
    tcp_segs_free(pcb->unacked);
    pcb->unsent = (tcp_seg *)0x0;
    pcb->unacked = (tcp_seg *)0x0;
    pcb->unsent_oversize = 0;
    return;
  }
  return;
}



void tcp_pcb_remove(tcp_pcb **pcblist,tcp_pcb *pcb)

{
  tcp_pcb *ptVar1;
  tcp_pcb *ptVar2;
  
  ptVar1 = *pcblist;
  if (*pcblist == pcb) {
    *pcblist = pcb->next;
  }
  else {
    do {
      ptVar2 = ptVar1;
      if (ptVar2 == (tcp_pcb *)0x0) goto LAB_23041a5a;
      ptVar1 = ptVar2->next;
    } while (ptVar2->next != pcb);
    ptVar2->next = pcb->next;
  }
LAB_23041a5a:
  pcb->next = (tcp_pcb *)0x0;
  tcp_pcb_purge(pcb);
  if (((pcb->state != TIME_WAIT) && (pcb->state != LISTEN)) && ((pcb->flags & 1) != 0)) {
    pcb->flags = pcb->flags | 2;
    tcp_output(pcb);
  }
  pcb->state = CLOSED;
  pcb->local_port = 0;
  return;
}



void tcp_abandon(tcp_pcb *pcb,int reset)

{
  tcp_pcb *ptVar1;
  u16_t uVar2;
  tcp_pcb *ptVar3;
  tcp_err_fn *UNRECOVERED_JUMPTABLE;
  void *pvVar4;
  u32_t seqno;
  u32_t ackno;
  
  if (pcb == (tcp_pcb *)0x0) {
    return;
  }
  if (pcb->state == TIME_WAIT) {
    tcp_pcb_remove(&tcp_tw_pcbs,pcb);
    tcp_free(pcb);
    return;
  }
  seqno = pcb->snd_nxt;
  ackno = pcb->rcv_nxt;
  UNRECOVERED_JUMPTABLE = pcb->errf;
  pvVar4 = pcb->callback_arg;
  uVar2 = pcb->local_port;
  if (pcb->state == CLOSED) {
    reset = 0;
    if (uVar2 != 0) {
      ptVar1 = tcp_bound_pcbs;
      if (tcp_bound_pcbs == pcb) {
        tcp_bound_pcbs = pcb->next;
      }
      else {
        do {
          ptVar3 = ptVar1;
          if (ptVar3 == (tcp_pcb *)0x0) goto LAB_23041b20;
          ptVar1 = ptVar3->next;
        } while (ptVar3->next != pcb);
        ptVar3->next = pcb->next;
      }
LAB_23041b20:
      pcb->next = (tcp_pcb *)0x0;
      uVar2 = 0;
      reset = 0;
    }
  }
  else {
    tcp_pcb_remove(&tcp_active_pcbs,pcb);
    tcp_active_pcbs_changed = '\x01';
  }
  if (pcb->unacked != (tcp_seg *)0x0) {
    tcp_segs_free(pcb->unacked);
  }
  if (pcb->unsent != (tcp_seg *)0x0) {
    tcp_segs_free(pcb->unsent);
  }
  if (pcb->ooseq != (tcp_seg *)0x0) {
    tcp_segs_free(pcb->ooseq);
  }
  if (reset != 0) {
    tcp_rst(pcb,seqno,ackno,(ip_addr_t *)pcb,&pcb->remote_ip,uVar2,pcb->remote_port);
  }
  tcp_free(pcb);
  if (UNRECOVERED_JUMPTABLE == (tcp_err_fn *)0x0) {
    return;
  }
                    // WARNING: Could not recover jumptable at 0x23041b7c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*UNRECOVERED_JUMPTABLE)(pvVar4,-0xd);
  return;
}



void tcp_abort(tcp_pcb *pcb)

{
  tcp_abandon(pcb,1);
  return;
}



err_t tcp_accept_null(void *arg,tcp_pcb *pcb,err_t err)

{
  tcp_abort(pcb);
  return -0xd;
}



void tcp_netif_ip_addr_changed_pcblist(tcp_pcb *pcb_list)

{
  tcp_pcb *in_a1;
  tcp_pcb *pcb;
  
  while (pcb = in_a1, pcb != (tcp_pcb *)0x0) {
    in_a1 = pcb->next;
    if ((pcb->local_ip).addr == (pcb_list->local_ip).addr) {
      tcp_abort(pcb);
    }
  }
  return;
}



void tcp_netif_ip_addr_changed(ip_addr_t *old_addr,ip_addr_t *new_addr)

{
  u32_t *puVar1;
  
  if (old_addr == (ip_addr_t *)0x0) {
    return;
  }
  if (old_addr->addr != 0) {
    tcp_netif_ip_addr_changed_pcblist((tcp_pcb *)old_addr);
    tcp_netif_ip_addr_changed_pcblist((tcp_pcb *)old_addr);
    if ((new_addr != (ip_addr_t *)0x0) && (puVar1 = tcp_listen_pcbs, new_addr->addr != 0)) {
      while (puVar1 != (u32_t *)0x0) {
        if (*puVar1 == old_addr->addr) {
          *puVar1 = new_addr->addr;
        }
        puVar1 = (u32_t *)puVar1[3];
      }
    }
  }
  return;
}



void tcp_kill_state(tcp_state state)

{
  undefined3 in_register_00002029;
  uint uVar1;
  tcp_pcb *pcb;
  uint uVar2;
  tcp_pcb *ptVar3;
  
  uVar1 = 0;
  pcb = (tcp_pcb *)0x0;
  ptVar3 = tcp_active_pcbs;
  while (ptVar3 != (tcp_pcb *)0x0) {
    if (((uint)ptVar3->state == CONCAT31(in_register_00002029,state)) &&
       (uVar2 = tcp_ticks - ptVar3->tmr, uVar1 <= uVar2)) {
      uVar1 = uVar2;
      pcb = ptVar3;
    }
    ptVar3 = ptVar3->next;
  }
  if (pcb != (tcp_pcb *)0x0) {
    tcp_abandon(pcb,0);
    return;
  }
  return;
}



tcp_pcb * tcp_alloc(u8_t prio)

{
  u32_t uVar1;
  tcp_pcb *pcb;
  undefined3 in_register_00002029;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  tcp_pcb *ptVar5;
  int iVar6;
  
  iVar6 = CONCAT31(in_register_00002029,prio);
  pcb = (tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
  ptVar5 = tcp_active_pcbs;
  if (pcb != (tcp_pcb *)0x0) goto LAB_23041d62;
  while (pcb = ptVar5, pcb != (tcp_pcb *)0x0) {
    ptVar5 = pcb->next;
    if ((pcb->flags & 8) != 0) {
      pcb->flags = pcb->flags & 0xfff7;
      tcp_close_shutdown_fin(pcb);
    }
  }
  uVar3 = 0;
  ptVar5 = tcp_tw_pcbs;
  while (ptVar5 != (tcp_pcb *)0x0) {
    uVar4 = tcp_ticks - ptVar5->tmr;
    if (uVar3 <= uVar4) {
      pcb = ptVar5;
      uVar3 = uVar4;
    }
    ptVar5 = ptVar5->next;
  }
  if (pcb != (tcp_pcb *)0x0) {
    tcp_abort(pcb);
  }
  pcb = (tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
  if (pcb == (tcp_pcb *)0x0) {
    tcp_kill_state(LAST_ACK);
    pcb = (tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    if (pcb == (tcp_pcb *)0x0) {
      tcp_kill_state(CLOSING);
      pcb = (tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
      if (pcb == (tcp_pcb *)0x0) {
        if ((char)prio < '\0') {
          iVar6 = 0x7f;
LAB_23041e24:
          uVar3 = iVar6 - 1U & 0xff;
          uVar4 = 0;
          ptVar5 = tcp_active_pcbs;
          while (ptVar5 != (tcp_pcb *)0x0) {
            uVar2 = (uint)ptVar5->prio;
            if ((uVar2 < uVar3) || ((uVar2 == uVar3 && (uVar4 <= tcp_ticks - ptVar5->tmr)))) {
              uVar4 = tcp_ticks - ptVar5->tmr;
              pcb = ptVar5;
              uVar3 = uVar2;
            }
            ptVar5 = ptVar5->next;
          }
          if (pcb != (tcp_pcb *)0x0) {
            tcp_abort(pcb);
          }
        }
        else {
          if (iVar6 != 0) goto LAB_23041e24;
        }
        pcb = (tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
        if (pcb == (tcp_pcb *)0x0) {
          return (tcp_pcb *)0x0;
        }
        lwip_stats.memp[2]->err = lwip_stats.memp[2]->err - 1;
      }
      lwip_stats.memp[2]->err = lwip_stats.memp[2]->err - 1;
    }
    lwip_stats.memp[2]->err = lwip_stats.memp[2]->err - 1;
  }
  lwip_stats.memp[2]->err = lwip_stats.memp[2]->err - 1;
LAB_23041d62:
  memset(pcb,0,0xa4);
  pcb->snd_buf = 0x1580;
  *(undefined4 *)&pcb->rcv_wnd = 0x8100810;
  pcb->ttl = -1;
  pcb->rto = 6;
  pcb->sv = 6;
  *(undefined4 *)&pcb->rtime = 0x218ffff;
  uVar1 = tcp_ticks;
  pcb->prio = prio;
  pcb->tmr = uVar1;
  pcb->last_timer = tcp_timer_ctr;
  *(undefined4 *)&pcb->cwnd = 0x15800001;
  pcb->recv = tcp_recv_null;
  pcb->keep_idle = 7200000;
  pcb->keep_intvl = 75000;
  pcb->keep_cnt = 9;
  return pcb;
}



tcp_pcb * tcp_new_ip_type(u8_t type)

{
  tcp_pcb *ptVar1;
  
  ptVar1 = tcp_alloc('@');
  return ptVar1;
}



err_t tcp_close_shutdown(tcp_pcb *pcb,u8_t rst_on_unacked_data)

{
  tcp_state tVar1;
  err_t eVar2;
  undefined3 in_register_0000202d;
  tcp_pcb *ptVar3;
  tcp_pcb *ptVar4;
  tcp_pcb ***ppptVar5;
  
  tVar1 = pcb->state;
  if (((CONCAT31(in_register_0000202d,rst_on_unacked_data) == 0) ||
      ((tVar1 != ESTABLISHED && (tVar1 != CLOSE_WAIT)))) ||
     ((pcb->refused_data == (pbuf *)0x0 && (pcb->rcv_wnd == 0x810)))) {
    if (tVar1 == LISTEN) {
      ppptVar5 = tcp_pcb_lists;
      do {
        ptVar3 = *ppptVar5[1];
        while (ptVar3 != (tcp_pcb *)0x0) {
          if (pcb == (tcp_pcb *)ptVar3->listener) {
            ptVar3->listener = (tcp_pcb_listen *)0x0;
          }
          ptVar3 = ptVar3->next;
        }
        ppptVar5 = ppptVar5 + 1;
      } while (ppptVar5 != (tcp_pcb ***)0x2308643c);
      tcp_pcb_remove((tcp_pcb **)&tcp_listen_pcbs,pcb);
      memp_free(MEMP_TCP_PCB_LISTEN,pcb);
      return '\0';
    }
    if (tVar1 == CLOSED) {
      if (pcb->local_port != 0) {
        ptVar3 = tcp_bound_pcbs;
        if (tcp_bound_pcbs == pcb) {
          tcp_bound_pcbs = pcb->next;
        }
        else {
          do {
            ptVar4 = ptVar3;
            if (ptVar4 == (tcp_pcb *)0x0) goto LAB_23041f3a;
            ptVar3 = ptVar4->next;
          } while (ptVar4->next != pcb);
          ptVar4->next = pcb->next;
        }
LAB_23041f3a:
        pcb->next = (tcp_pcb *)0x0;
      }
    }
    else {
      if (tVar1 != SYN_SENT) {
        eVar2 = tcp_close_shutdown_fin(pcb);
        return eVar2;
      }
      tcp_pcb_remove(&tcp_active_pcbs,pcb);
      tcp_active_pcbs_changed = '\x01';
    }
  }
  else {
    tcp_rst(pcb,pcb->snd_nxt,pcb->rcv_nxt,(ip_addr_t *)pcb,&pcb->remote_ip,pcb->local_port,
            pcb->remote_port);
    tcp_pcb_purge(pcb);
    ptVar3 = tcp_active_pcbs;
    if (tcp_active_pcbs == pcb) {
      tcp_active_pcbs = pcb->next;
    }
    else {
      do {
        ptVar4 = ptVar3;
        if (ptVar4 == (tcp_pcb *)0x0) goto LAB_23041ecc;
        ptVar3 = ptVar4->next;
      } while (ptVar4->next != pcb);
      ptVar4->next = pcb->next;
    }
LAB_23041ecc:
    ptVar3 = tcp_input_pcb;
    tcp_active_pcbs_changed = '\x01';
    pcb->next = (tcp_pcb *)0x0;
    if (ptVar3 == pcb) {
      tcp_trigger_input_pcb_close();
      return '\0';
    }
  }
  tcp_free(pcb);
  return '\0';
}



err_t tcp_close(tcp_pcb *pcb)

{
  err_t eVar1;
  
  if (pcb != (tcp_pcb *)0x0) {
    if (pcb->state != LISTEN) {
      pcb->flags = pcb->flags | 0x10;
    }
    eVar1 = tcp_close_shutdown(pcb,'\x01');
    return eVar1;
  }
  return -0x10;
}



err_t tcp_recv_null(void *arg,tcp_pcb *pcb,pbuf *p,err_t err)

{
  err_t eVar1;
  undefined3 in_register_00002035;
  
  if (pcb == (tcp_pcb *)0x0) {
    return -0x10;
  }
  if (p != (pbuf *)0x0) {
    tcp_recved(pcb,p->tot_len);
    pbuf_free(p);
    return '\0';
  }
  if (CONCAT31(in_register_00002035,err) == 0) {
    eVar1 = tcp_close(pcb);
    return eVar1;
  }
  return '\0';
}



err_t tcp_process_refused_data(tcp_pcb *pcb)

{
  byte bVar1;
  err_t eVar2;
  err_t eVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  pbuf *p;
  
  if (pcb == (tcp_pcb *)0x0) {
    return -0x10;
  }
  p = pcb->refused_data;
  bVar1 = p->flags;
  pcb->refused_data = (pbuf *)0x0;
  if (pcb->recv == (tcp_recv_fn *)0x0) {
    eVar2 = tcp_recv_null((void *)0x0,pcb,p,'\0');
    _eVar2 = CONCAT31(extraout_var_01,eVar2);
  }
  else {
    eVar2 = (*pcb->recv)(pcb->callback_arg,pcb,p,'\0');
    _eVar2 = CONCAT31(extraout_var,eVar2);
  }
  eVar2 = (err_t)_eVar2;
  if (_eVar2 == 0) {
    if ((bVar1 & 0x20) == 0) {
      return eVar2;
    }
    if (pcb->rcv_wnd != 0x810) {
      pcb->rcv_wnd = pcb->rcv_wnd + 1;
    }
    if (pcb->recv == (tcp_recv_fn *)0x0) {
      return eVar2;
    }
    eVar3 = (*pcb->recv)(pcb->callback_arg,pcb,(pbuf *)0x0,'\0');
    if (CONCAT31(extraout_var_00,eVar3) != -0xd) {
      return eVar2;
    }
  }
  else {
    if (_eVar2 != -0xd) {
      pcb->refused_data = p;
      return -5;
    }
  }
  return -0xd;
}



void tcp_fasttmr(void)

{
  tcp_pcb *pcb;
  tcp_pcb *ptVar1;
  
  tcp_timer_ctr = tcp_timer_ctr + '\x01';
  pcb = tcp_active_pcbs;
  while( true ) {
    if (pcb == (tcp_pcb *)0x0) {
      return;
    }
    if (pcb->last_timer == tcp_timer_ctr) break;
    pcb->last_timer = tcp_timer_ctr;
    if ((pcb->flags & 1) != 0) {
      pcb->flags = pcb->flags | 2;
      tcp_output(pcb);
      pcb->flags = pcb->flags & 0xfffc;
    }
    if ((pcb->flags & 8) != 0) {
      pcb->flags = pcb->flags & 0xfff7;
      tcp_close_shutdown_fin(pcb);
    }
    ptVar1 = pcb->next;
    if (pcb->refused_data == (pbuf *)0x0) goto LAB_23042130;
    tcp_active_pcbs_changed = '\0';
    tcp_process_refused_data(pcb);
    pcb = tcp_active_pcbs;
    if (tcp_active_pcbs_changed == '\0') {
LAB_23042130:
      pcb = ptVar1;
    }
  }
  ptVar1 = pcb->next;
  goto LAB_23042130;
}



err_t tcp_shutdown(tcp_pcb *pcb,int shut_rx,int shut_tx)

{
  tcp_state tVar1;
  err_t eVar2;
  u8_t rst_on_unacked_data;
  
  rst_on_unacked_data = (u8_t)shut_rx;
  if (pcb == (tcp_pcb *)0x0) {
    return -0x10;
  }
  tVar1 = pcb->state;
  if (tVar1 == LISTEN) {
LAB_23042196:
    eVar2 = -0xb;
  }
  else {
    if (shut_rx == 0) {
      if (shut_tx != 0) {
        if ((tVar1 < CLOSING) && ((1 << ((uint)tVar1 & 0x1f) & 0x98U) != 0)) goto LAB_23042188;
        goto LAB_23042196;
      }
    }
    else {
      rst_on_unacked_data = '\x01';
      pcb->flags = pcb->flags | 0x10;
      if (shut_tx != 0) {
LAB_23042188:
        eVar2 = tcp_close_shutdown(pcb,rst_on_unacked_data);
        return eVar2;
      }
      if (pcb->refused_data != (pbuf *)0x0) {
        pbuf_free(pcb->refused_data);
        pcb->refused_data = (pbuf *)0x0;
      }
    }
    eVar2 = '\0';
  }
  return eVar2;
}



void tcp_slowtmr(void)

{
  tcp_state tVar1;
  short sVar2;
  tcp_pcb *pcb;
  uint uVar3;
  tcp_err_fn *ptVar4;
  err_t eVar5;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  uint uVar6;
  byte bVar7;
  uint uVar8;
  u32_t uVar9;
  byte bVar10;
  s16_t sVar11;
  void *pvVar12;
  tcp_pcb *ptVar13;
  tcp_pcb *pcb_00;
  
  tcp_ticks = tcp_ticks + 1;
  tcp_timer_ctr = tcp_timer_ctr + '\x01';
  do {
    pcb_00 = tcp_active_pcbs;
    ptVar13 = (tcp_pcb *)0x0;
LAB_23042200:
    do {
      while( true ) {
        pcb = pcb_00;
        pcb_00 = tcp_tw_pcbs;
        if (pcb == (tcp_pcb *)0x0) {
          while (pcb_00 != (tcp_pcb *)0x0) {
            if (tcp_ticks - pcb_00->tmr < 0xf1) {
              pcb = pcb_00;
              pcb_00 = pcb_00->next;
            }
            else {
              tcp_pcb_purge(pcb_00);
              ptVar13 = pcb_00->next;
              if (pcb != (tcp_pcb *)0x0) {
                pcb->next = pcb_00->next;
                ptVar13 = tcp_tw_pcbs;
              }
              tcp_tw_pcbs = ptVar13;
              ptVar13 = pcb_00->next;
              tcp_free(pcb_00);
              pcb_00 = ptVar13;
            }
          }
          return;
        }
        if (pcb->last_timer != tcp_timer_ctr) break;
        pcb_00 = pcb->next;
        ptVar13 = pcb;
      }
      pcb->last_timer = tcp_timer_ctr;
      if (pcb->state == SYN_SENT) {
        bVar7 = 5;
      }
      else {
        bVar7 = 0xb;
      }
      uVar3 = 1;
      if (pcb->nrtx <= bVar7) {
        uVar3 = (uint)pcb->persist_backoff;
        if (pcb->persist_backoff == 0) {
          sVar2 = pcb->rtime;
          if (sVar2 < 0) {
LAB_23042456:
            if (pcb->rtime < pcb->rto) goto LAB_230422b0;
          }
          else {
            if (sVar2 != 0x7fff) {
              pcb->rtime = sVar2 + 1;
              goto LAB_23042456;
            }
          }
          eVar5 = tcp_rexmit_rto_prepare(pcb);
          if ((CONCAT31(extraout_var_02,eVar5) == 0) ||
             ((pcb->unacked == (tcp_seg *)0x0 && (pcb->unsent != (tcp_seg *)0x0)))) {
            if (pcb->state != SYN_SENT) {
              uVar6 = (uint)pcb->nrtx;
              if (0xc < pcb->nrtx) {
                uVar6 = 0xc;
              }
              _sVar11 = ((int)pcb->sa >> 3) + (int)pcb->sv <<
                        ((uint)"\x01\x02\x03\x04\x05\x06\a\a\a\a\a\a\a"[uVar6] & 0x1f);
              sVar11 = (s16_t)_sVar11;
              if (0x7ffe < _sVar11) {
                sVar11 = 0x7fff;
              }
              pcb->rto = sVar11;
            }
            pcb->rtime = 0;
            uVar6 = (uint)pcb->snd_wnd;
            if ((uint)pcb->cwnd < (uint)pcb->snd_wnd) {
              uVar6 = (uint)pcb->cwnd;
            }
            uVar8 = (uint)pcb->mss << 0x11;
            pcb->ssthresh = (tcpwnd_size_t)(uVar6 >> 1);
            if (uVar6 >> 1 < uVar8 >> 0x10) {
              pcb->ssthresh = (tcpwnd_size_t)(uVar8 >> 0x10);
            }
            pcb->cwnd = pcb->mss;
            pcb->bytes_acked = 0;
            tcp_rexmit_rto_commit(pcb);
            goto LAB_230422b2;
          }
        }
        else {
          if (0xb < pcb->persist_probe) {
            uVar3 = 1;
            goto LAB_230422b2;
          }
          bVar7 = *(byte *)((int)&ip_addr_broadcast.addr + uVar3 + 3);
          if ((bVar7 <= pcb->persist_cnt) ||
             (bVar10 = pcb->persist_cnt + 1, pcb->persist_cnt = bVar10, bVar7 <= bVar10)) {
            if (pcb->snd_wnd == 0) {
              eVar5 = tcp_zero_window_probe(pcb);
              if (CONCAT31(extraout_var_01,eVar5) == 0) goto LAB_230423a0;
            }
            else {
              eVar5 = tcp_split_unsent_seg(pcb,pcb->snd_wnd);
              if ((CONCAT31(extraout_var,eVar5) != 0) ||
                 (eVar5 = tcp_output(pcb), CONCAT31(extraout_var_00,eVar5) != 0)) {
LAB_230423a0:
                pcb->persist_cnt = '\0';
                if (pcb->persist_backoff < 7) {
                  pcb->persist_backoff = pcb->persist_backoff + 1;
                }
              }
            }
          }
        }
LAB_230422b0:
        uVar3 = 0;
      }
LAB_230422b2:
      tVar1 = pcb->state;
      if (((tVar1 == FIN_WAIT_2) && ((pcb->flags & 0x10) != 0)) && (0x28 < tcp_ticks - pcb->tmr)) {
        uVar3 = uVar3 + 1 & 0xff;
      }
      bVar7 = pcb->so_options & 8;
      if (((pcb->so_options & 8) != 0) &&
         ((tVar1 == ESTABLISHED || (bVar7 = 0, tVar1 == CLOSE_WAIT)))) {
        uVar6 = tcp_ticks - pcb->tmr;
        if ((pcb->keep_intvl * pcb->keep_cnt + pcb->keep_idle) / 500 < uVar6) {
          uVar3 = uVar3 + 1 & 0xff;
          bVar7 = 1;
        }
        else {
          bVar7 = 0;
          if ((((uint)pcb->keep_cnt_sent * pcb->keep_intvl + pcb->keep_idle) / 500 < uVar6) &&
             (eVar5 = tcp_keepalive(pcb), bVar7 = 0, CONCAT31(extraout_var_03,eVar5) == 0)) {
            pcb->keep_cnt_sent = pcb->keep_cnt_sent + '\x01';
          }
        }
      }
      if ((pcb->ooseq != (tcp_seg *)0x0) && ((uint)((int)pcb->rto * 6) <= tcp_ticks - pcb->tmr)) {
        tcp_free_ooseq(pcb);
      }
      tVar1 = pcb->state;
      if (tVar1 == SYN_RCVD) {
        if (0x28 < tcp_ticks - pcb->tmr) {
          uVar3 = uVar3 + 1 & 0xff;
        }
LAB_23042362:
        if (uVar3 == 0) {
          pcb_00 = pcb->next;
          bVar7 = pcb->polltmr + 1;
          pcb->polltmr = bVar7;
          ptVar13 = pcb;
          if (pcb->pollinterval <= bVar7) {
            pcb->polltmr = '\0';
            tcp_active_pcbs_changed = '\0';
            if (pcb->poll != (tcp_poll_fn *)0x0) {
              eVar5 = (*pcb->poll)(pcb->callback_arg,pcb);
              if (tcp_active_pcbs_changed != '\0') break;
              if (CONCAT31(extraout_var_04,eVar5) != 0) goto LAB_23042200;
            }
            tcp_output(pcb);
          }
          goto LAB_23042200;
        }
      }
      else {
        if (tVar1 == LAST_ACK) {
          uVar9 = pcb->tmr;
          uVar6 = 0xf0;
        }
        else {
          if ((tVar1 != FIN_WAIT_1) && (tVar1 != CLOSING)) goto LAB_23042362;
          uVar9 = pcb->tmr;
          uVar6 = 10;
        }
        if (tcp_ticks - uVar9 <= uVar6) goto LAB_23042362;
      }
      ptVar4 = pcb->errf;
      tcp_pcb_purge(pcb);
      pcb_00 = pcb->next;
      if (ptVar13 != (tcp_pcb *)0x0) {
        ptVar13->next = pcb->next;
        pcb_00 = tcp_active_pcbs;
      }
      tcp_active_pcbs = pcb_00;
      if (bVar7 != 0) {
        tcp_rst(pcb,pcb->snd_nxt,pcb->rcv_nxt,(ip_addr_t *)pcb,&pcb->remote_ip,pcb->local_port,
                pcb->remote_port);
      }
      pvVar12 = pcb->callback_arg;
      pcb_00 = pcb->next;
      tcp_free(pcb);
      tcp_active_pcbs_changed = '\0';
    } while ((ptVar4 == (tcp_err_fn *)0x0) ||
            ((*ptVar4)(pvVar12,-0xd), tcp_active_pcbs_changed == '\0'));
  } while( true );
}



void tcp_tmr(void)

{
  tcp_fasttmr();
  tcp_timer = tcp_timer + 1;
  if ((tcp_timer & 1) != 0) {
    tcp_slowtmr();
    return;
  }
  return;
}



int tcp_get_pcbs(tcp_pcb ****list)

{
  *list = tcp_pcb_lists;
  return 4;
}



u8_t tcp_get_next_optbyte(void)

{
  uint uVar1;
  
  uVar1 = (uint)tcp_optidx;
  if ((tcphdr_opt2 != (u8_t *)0x0) && (tcphdr_opt1len <= uVar1)) {
    tcp_optidx = tcp_optidx + 1;
    return tcphdr_opt2[uVar1 - tcphdr_opt1len & 0xff];
  }
  tcp_optidx = tcp_optidx + 1;
  return *(u8_t *)((int)&tcphdr[1].src + uVar1);
}



void tcp_oos_insert_segment(tcp_seg *cseg,tcp_seg *next)

{
  u32_t uVar1;
  ushort uVar2;
  tcp_seg *ptVar3;
  u16_t new_len;
  int iVar4;
  tcp_hdr *ptVar5;
  
  new_len = lwip_htons(cseg->tcphdr->_hdrlen_rsvd_flags);
  if ((new_len & 1) == 0) {
    do {
      iVar4 = cseg->len + seqno;
      uVar1 = next->tcphdr->seqno;
      if ((int)(iVar4 - (next->len + uVar1)) < 0) {
        if (0 < (int)(iVar4 - uVar1)) {
          new_len = (u16_t)((uVar1 - seqno) * 0x10000 >> 0x10);
          cseg->len = new_len;
          pbuf_realloc(cseg->p,new_len);
        }
        goto LAB_23042662;
      }
      new_len = lwip_htons(next->tcphdr->_hdrlen_rsvd_flags);
      if ((new_len & 1) != 0) {
        uVar2 = cseg->tcphdr->_hdrlen_rsvd_flags;
        new_len = lwip_htons(1);
        ptVar5 = cseg->tcphdr;
        uVar2 = new_len | uVar2;
        *(char *)&ptVar5->_hdrlen_rsvd_flags = (char)uVar2;
        *(undefined *)((int)&ptVar5->_hdrlen_rsvd_flags + 1) = (char)((uint)uVar2 >> 8);
      }
      ptVar3 = next->next;
      tcp_seg_free(next);
      next = ptVar3;
    } while (ptVar3 != (tcp_seg *)0x0);
  }
  else {
    tcp_segs_free(next);
  }
  next = (tcp_seg *)0x0;
LAB_23042662:
  cseg->next = next;
  return;
}



void tcp_parseopt(undefined2 *param_1)

{
  uint uVar1;
  u8_t uVar2;
  byte bVar3;
  undefined2 uVar4;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  
  tcp_optidx = 0;
  while( true ) {
    while( true ) {
      do {
        uVar1 = (uint)tcphdr_optlen;
        if (uVar1 <= tcp_optidx) {
          return;
        }
        uVar2 = tcp_get_next_optbyte();
      } while (CONCAT31(extraout_var,uVar2) == 1);
      if (uVar2 == '\0') {
        return;
      }
      if (CONCAT31(extraout_var,uVar2) == 2) break;
      uVar2 = tcp_get_next_optbyte();
      if (CONCAT31(extraout_var_02,uVar2) < 2) {
        return;
      }
      tcp_optidx = (tcp_optidx - 2) + (short)CONCAT31(extraout_var_02,uVar2);
    }
    uVar2 = tcp_get_next_optbyte();
    if (CONCAT31(extraout_var_00,uVar2) != 4) {
      return;
    }
    if (uVar1 <= (uint)tcp_optidx + 1) break;
    bVar3 = tcp_get_next_optbyte();
    uVar2 = tcp_get_next_optbyte();
    uVar1 = CONCAT31(extraout_var_01,uVar2) & 0xffff | ((uint)bVar3 << 0x18) >> 0x10;
    uVar4 = (undefined2)uVar1;
    if (0x2af < (uVar1 - 1 & 0xffff)) {
      uVar4 = 0x2b0;
    }
    *param_1 = uVar4;
  }
  return;
}



int tcp_input_delayed_close(tcp_pcb *pcb)

{
  if ((recv_flags & 0x10) != 0) {
    if (((pcb->flags & 0x10) == 0) && (pcb->errf != (tcp_err_fn *)0x0)) {
      (*pcb->errf)(pcb->callback_arg,-0xf);
    }
    tcp_pcb_remove(&tcp_active_pcbs,pcb);
    tcp_free(pcb);
    return 1;
  }
  return 0;
}



tcp_seg * tcp_free_acked_segments(tcp_seg *seg_list)

{
  ushort uVar1;
  tcp_seg *ptVar2;
  u16_t uVar3;
  u32_t uVar4;
  tcp_seg *in_a1;
  
  while( true ) {
    if (in_a1 == (tcp_seg *)0x0) {
      return (tcp_seg *)0x0;
    }
    uVar4 = lwip_htonl(in_a1->tcphdr->seqno);
    uVar1 = in_a1->len;
    uVar3 = lwip_htons(in_a1->tcphdr->_hdrlen_rsvd_flags);
    if (0 < (int)((uVar1 - ackno) + uVar4 + (uint)((uVar3 & 3) != 0))) break;
    ptVar2 = in_a1->next;
    uVar3 = pbuf_clen(in_a1->p);
    *(u16_t *)&seg_list->next = *(short *)&seg_list->next - uVar3;
    recv_acked = in_a1->len + recv_acked;
    tcp_seg_free(in_a1);
    in_a1 = ptVar2;
  }
  return in_a1;
}



void tcp_receive(tcp_pcb *pcb)

{
  ushort n;
  ushort uVar1;
  short sVar2;
  tcp_seg *cseg;
  tcp_seg *next;
  u16_t new_len;
  u16_t uVar3;
  int iVar4;
  u32_t uVar5;
  pbuf *p;
  u32_t uVar6;
  uint header_size_decrement;
  u32_t uVar7;
  uint uVar8;
  tcp_hdr *ptVar9;
  tcpwnd_size_t tVar10;
  short sVar11;
  tcpflags_t tVar12;
  uint uVar13;
  uint uVar14;
  tcp_seg *ptVar15;
  
  uVar5 = seqno;
  uVar7 = ackno;
  if ((flags & 0x10) != 0) {
    n = pcb->snd_wnd;
    uVar6 = pcb->snd_wl2;
    if ((((int)(pcb->snd_wl1 - seqno) < 0) ||
        ((pcb->snd_wl1 == seqno && ((int)(uVar6 - ackno) < 0)))) ||
       ((uVar6 == ackno && ((uint)n < (uint)tcphdr->wnd)))) {
      uVar1 = tcphdr->wnd;
      pcb->snd_wnd = uVar1;
      if (pcb->snd_wnd_max < uVar1) {
        pcb->snd_wnd_max = uVar1;
      }
      pcb->snd_wl1 = uVar5;
      pcb->snd_wl2 = uVar7;
    }
    uVar13 = uVar7 - pcb->lastack;
    if ((int)uVar13 < 1) {
      if ((((tcplen == 0) && ((uint)pcb->snd_wnd + pcb->snd_wl2 == (uint)n + uVar6)) &&
          (-1 < pcb->rtime)) && (pcb->lastack == uVar7)) {
        if (pcb->dupacks != -1) {
          pcb->dupacks = pcb->dupacks + '\x01';
        }
        if (pcb->dupacks < 4) {
          if (pcb->dupacks != 3) goto LAB_2304299c;
        }
        else {
          tVar10 = pcb->mss + pcb->cwnd;
          if (tVar10 < pcb->cwnd) {
            tVar10 = 0xffff;
          }
          pcb->cwnd = tVar10;
        }
        tcp_rexmit_fast(pcb);
      }
      else {
        pcb->dupacks = '\0';
      }
    }
    else {
      if ((int)(uVar7 - pcb->snd_nxt) < 1) {
        if ((pcb->flags & 4) != 0) {
          pcb->flags = pcb->flags & 0xfffb;
          pcb->bytes_acked = 0;
          pcb->cwnd = pcb->ssthresh;
        }
        pcb->lastack = uVar7;
        pcb->rto = (pcb->sa >> 3) + pcb->sv;
        *(undefined2 *)&pcb->nrtx = 0;
        if (SYN_RCVD < pcb->state) {
          header_size_decrement = (uint)pcb->cwnd;
          uVar13 = uVar13 & 0xffff;
          if (header_size_decrement < pcb->ssthresh) {
            uVar8 = ((uint)((pcb->flags & 0x800) == 0) + 1) * (uint)pcb->mss;
            if (uVar13 < (uVar8 & 0xffff)) {
              uVar8 = uVar13;
            }
          }
          else {
            uVar13 = uVar13 + pcb->bytes_acked;
            uVar8 = uVar13 & 0xffff;
            sVar11 = (short)uVar8;
            if (uVar8 < pcb->bytes_acked) {
              sVar11 = -1;
            }
            else {
              if (uVar8 < header_size_decrement) {
                pcb->bytes_acked = (tcpwnd_size_t)(uVar13 * 0x10000 >> 0x10);
                goto LAB_23042cf8;
              }
            }
            pcb->bytes_acked = sVar11 - pcb->cwnd;
            uVar8 = (uint)pcb->mss;
          }
          uVar13 = header_size_decrement + uVar8 & 0xffff;
          tVar10 = (tcpwnd_size_t)uVar13;
          if (uVar13 < header_size_decrement) {
            tVar10 = 0xffff;
          }
          pcb->cwnd = tVar10;
        }
LAB_23042cf8:
        cseg = tcp_free_acked_segments((tcp_seg *)&pcb->snd_queuelen);
        pcb->unacked = cseg;
        cseg = tcp_free_acked_segments((tcp_seg *)&pcb->snd_queuelen);
        ptVar15 = pcb->unacked;
        pcb->unsent = cseg;
        pcb->polltmr = '\0';
        pcb->rtime = -(ushort)(ptVar15 == (tcp_seg *)0x0);
        if (cseg == (tcp_seg *)0x0) {
          pcb->unsent_oversize = 0;
        }
        pcb->snd_buf = pcb->snd_buf + recv_acked;
        if ((int)((uint)pcb->flags << 0x14) < 0) {
          if (ptVar15 == (tcp_seg *)0x0) {
            if (cseg != (tcp_seg *)0x0) {
              uVar7 = pcb->rto_end;
              ptVar9 = cseg->tcphdr;
              goto LAB_23042d74;
            }
          }
          else {
            uVar7 = pcb->rto_end;
            ptVar9 = ptVar15->tcphdr;
LAB_23042d74:
            uVar5 = lwip_htonl(ptVar9->seqno);
            if (0 < (int)(uVar7 - uVar5)) goto LAB_2304299c;
          }
          pcb->flags = pcb->flags & 0xf7ff;
        }
      }
      else {
        tcp_send_empty_ack(pcb);
      }
    }
LAB_2304299c:
    if ((pcb->rttest != 0) && ((int)(pcb->rtseq - ackno) < 0)) {
      uVar8 = (uint)(ushort)tcp_ticks;
      header_size_decrement = pcb->rttest & 0xffff;
      uVar13 = (int)pcb->sa >> 3 & 0xffff;
      uVar14 = (uVar8 - header_size_decrement) - uVar13 & 0xffff;
      iVar4 = (int)(short)uVar14;
      sVar11 = (short)((uVar14 + (int)pcb->sa) * 0x10000 >> 0x10);
      pcb->sa = sVar11;
      if (iVar4 < 0) {
        iVar4 = (int)(((header_size_decrement - uVar8) + uVar13) * 0x10000) >> 0x10;
      }
      pcb->rttest = 0;
      sVar2 = (short)((uint)((((int)pcb->sv - ((int)pcb->sv >> 2)) + iVar4) * 0x10000) >> 0x10);
      pcb->sv = sVar2;
      pcb->rto = (sVar11 >> 3) + sVar2;
    }
  }
  uVar7 = pcb->rcv_nxt;
  if ((tcplen == 0) || (FIN_WAIT_2 < pcb->state)) {
    if ((-1 < (int)(seqno - uVar7)) && ((int)(((seqno + 1) - uVar7) - (uint)pcb->rcv_wnd) < 1)) {
      return;
    }
    tVar12 = pcb->flags;
  }
  else {
    uVar13 = uVar7 - seqno;
    if (((int)(uVar13 - 1) < 0) || (0 < (int)(((1 - seqno) - (uint)tcplen) + uVar7))) {
      if ((int)(seqno - uVar7) < 0) {
        pcb->flags = pcb->flags | 2;
      }
    }
    else {
      header_size_decrement = uVar13 & 0xffff;
      inseg.len = inseg.len - (short)(uVar13 * 0x10000 >> 0x10);
      iVar4 = (inseg.p)->tot_len - header_size_decrement;
      p = inseg.p;
      while (n = p->len, n < header_size_decrement) {
        p->tot_len = (u16_t)((uint)(iVar4 * 0x10000) >> 0x10);
        p->len = 0;
        header_size_decrement = header_size_decrement - n & 0xffff;
        p = p->next;
      }
      pbuf_remove_header(p,header_size_decrement);
      ptVar9 = inseg.tcphdr;
      uVar7 = pcb->rcv_nxt;
      seqno = uVar7;
      *(char *)&(inseg.tcphdr)->seqno = (char)uVar7;
      *(undefined *)((int)&ptVar9->seqno + 1) = (char)(uVar7 >> 8);
      *(undefined *)((int)&ptVar9->seqno + 2) = (char)(uVar7 >> 0x10);
      *(undefined *)((int)&ptVar9->seqno + 3) = (char)(uVar7 >> 0x18);
    }
    uVar7 = pcb->rcv_nxt;
    if (((int)(seqno - uVar7) < 0) || (0 < (int)(((seqno + 1) - uVar7) - (uint)pcb->rcv_wnd))) {
LAB_23042ffc:
      tcp_send_empty_ack(pcb);
      return;
    }
    if (seqno != uVar7) {
      cseg = pcb->ooseq;
      ptVar15 = (tcp_seg *)0x0;
      if (pcb->ooseq == (tcp_seg *)0x0) {
        cseg = tcp_seg_copy(&inseg);
        pcb->ooseq = cseg;
      }
      else {
        do {
          next = cseg;
          uVar7 = next->tcphdr->seqno;
          if (seqno == uVar7) {
            if ((next->len < inseg.len) && (cseg = tcp_seg_copy(&inseg), cseg != (tcp_seg *)0x0)) {
              if (ptVar15 == (tcp_seg *)0x0) {
                pcb->ooseq = cseg;
              }
              else {
                ptVar15->next = cseg;
              }
LAB_23043062:
              tcp_oos_insert_segment(cseg,next);
            }
            goto LAB_23042ffc;
          }
          if (ptVar15 == (tcp_seg *)0x0) {
            if ((int)(seqno - uVar7) < 0) {
              cseg = tcp_seg_copy(&inseg);
              if (cseg != (tcp_seg *)0x0) {
                pcb->ooseq = cseg;
                goto LAB_23043062;
              }
              goto LAB_23042ffc;
            }
          }
          else {
            if ((-1 < (int)((seqno - 1) - ptVar15->tcphdr->seqno)) &&
               ((int)((seqno + 1) - uVar7) < 1)) {
              cseg = tcp_seg_copy(&inseg);
              if (cseg != (tcp_seg *)0x0) {
                uVar7 = ptVar15->tcphdr->seqno;
                if (0 < (int)((ptVar15->len + uVar7) - seqno)) {
                  new_len = (u16_t)((seqno - uVar7) * 0x10000 >> 0x10);
                  ptVar15->len = new_len;
                  pbuf_realloc(ptVar15->p,new_len);
                }
                ptVar15->next = cseg;
                goto LAB_23043062;
              }
              goto LAB_23042ffc;
            }
          }
          cseg = next->next;
          ptVar15 = next;
        } while (next->next != (tcp_seg *)0x0);
        if ((0 < (int)(seqno - uVar7)) &&
           (new_len = lwip_htons(next->tcphdr->_hdrlen_rsvd_flags), (new_len & 1) == 0)) {
          cseg = tcp_seg_copy(&inseg);
          next->next = cseg;
          if (cseg != (tcp_seg *)0x0) {
            uVar7 = next->tcphdr->seqno;
            if (0 < (int)((next->len + uVar7) - seqno)) {
              new_len = (u16_t)((seqno - uVar7) * 0x10000 >> 0x10);
              next->len = new_len;
              pbuf_realloc(next->p,new_len);
            }
            if (0 < (int)(((tcplen + seqno) - pcb->rcv_nxt) - (uint)pcb->rcv_wnd)) {
              new_len = lwip_htons(next->next->tcphdr->_hdrlen_rsvd_flags);
              if ((new_len & 1) != 0) {
                n = next->next->tcphdr->_hdrlen_rsvd_flags;
                new_len = lwip_htons(n);
                new_len = lwip_htons(new_len & 0x3e);
                ptVar9 = next->next->tcphdr;
                uVar13 = (uint)n & 0xffffc0ff | (uint)new_len;
                *(char *)&ptVar9->_hdrlen_rsvd_flags = (char)uVar13;
                *(undefined *)((int)&ptVar9->_hdrlen_rsvd_flags + 1) = (char)(uVar13 >> 8);
              }
              next->next->len = (pcb->rcv_wnd - (short)seqno) + (short)pcb->rcv_nxt;
              pbuf_realloc(next->next->p,next->next->len);
              new_len = next->next->len;
              uVar3 = lwip_htons(next->next->tcphdr->_hdrlen_rsvd_flags);
              tcplen = new_len + ((uVar3 & 3) != 0);
            }
          }
        }
      }
      goto LAB_23042ffc;
    }
    uVar13 = (uint)inseg.len;
    new_len = lwip_htons((inseg.tcphdr)->_hdrlen_rsvd_flags);
    uVar13 = ((new_len & 3) != 0) + uVar13;
    tcplen = (u16_t)(uVar13 * 0x10000 >> 0x10);
    if ((uint)pcb->rcv_wnd < (uVar13 & 0xffff)) {
      new_len = lwip_htons((inseg.tcphdr)->_hdrlen_rsvd_flags);
      if ((new_len & 1) != 0) {
        n = (inseg.tcphdr)->_hdrlen_rsvd_flags;
        new_len = lwip_htons(n);
        new_len = lwip_htons(new_len & 0x3e);
        ptVar9 = inseg.tcphdr;
        uVar13 = (uint)n & 0xffffc0ff | (uint)new_len;
        *(char *)&(inseg.tcphdr)->_hdrlen_rsvd_flags = (char)uVar13;
        *(undefined *)((int)&ptVar9->_hdrlen_rsvd_flags + 1) = (char)(uVar13 >> 8);
      }
      inseg.len = pcb->rcv_wnd;
      new_len = lwip_htons((inseg.tcphdr)->_hdrlen_rsvd_flags);
      if ((new_len & 2) != 0) {
        inseg.len = inseg.len - 1;
      }
      pbuf_realloc(inseg.p,inseg.len);
      new_len = inseg.len;
      uVar3 = lwip_htons((inseg.tcphdr)->_hdrlen_rsvd_flags);
      tcplen = new_len + ((uVar3 & 3) != 0);
    }
    if (pcb->ooseq != (tcp_seg *)0x0) {
      new_len = lwip_htons((inseg.tcphdr)->_hdrlen_rsvd_flags);
      if ((new_len & 1) == 0) {
        cseg = pcb->ooseq;
        while (cseg != (tcp_seg *)0x0) {
          uVar7 = cseg->tcphdr->seqno;
          if ((int)((tcplen + seqno) - (cseg->len + uVar7)) < 0) {
            if (0 < (int)((tcplen + seqno) - uVar7)) {
              inseg.len = (short)uVar7 - (short)seqno;
              new_len = lwip_htons((inseg.tcphdr)->_hdrlen_rsvd_flags);
              if ((new_len & 2) != 0) {
                inseg.len = inseg.len - 1;
              }
              pbuf_realloc(inseg.p,inseg.len);
              new_len = inseg.len;
              uVar3 = lwip_htons((inseg.tcphdr)->_hdrlen_rsvd_flags);
              tcplen = new_len + ((uVar3 & 3) != 0);
            }
            break;
          }
          new_len = lwip_htons(cseg->tcphdr->_hdrlen_rsvd_flags);
          if (((new_len & 1) != 0) &&
             (new_len = lwip_htons((inseg.tcphdr)->_hdrlen_rsvd_flags), (new_len & 2) == 0)) {
            n = (inseg.tcphdr)->_hdrlen_rsvd_flags;
            new_len = lwip_htons(1);
            ptVar9 = inseg.tcphdr;
            n = n | new_len;
            *(char *)&(inseg.tcphdr)->_hdrlen_rsvd_flags = (char)n;
            *(undefined *)((int)&ptVar9->_hdrlen_rsvd_flags + 1) = (char)((uint)n >> 8);
            new_len = inseg.len;
            uVar3 = lwip_htons((inseg.tcphdr)->_hdrlen_rsvd_flags);
            tcplen = new_len + ((uVar3 & 3) != 0);
          }
          ptVar15 = cseg->next;
          tcp_seg_free(cseg);
          cseg = ptVar15;
        }
        pcb->ooseq = cseg;
      }
      else {
        while (cseg = pcb->ooseq, cseg != (tcp_seg *)0x0) {
          pcb->ooseq = cseg->next;
          tcp_seg_free(cseg);
        }
      }
    }
    tVar10 = pcb->rcv_wnd - tcplen;
    pcb->rcv_nxt = seqno + tcplen;
    pcb->rcv_wnd = tVar10;
    tcp_update_rcv_ann_wnd(pcb);
    if ((inseg.p)->tot_len != 0) {
      recv_data = inseg.p;
      inseg.p = (pbuf *)0x0;
    }
    new_len = lwip_htons((inseg.tcphdr)->_hdrlen_rsvd_flags);
    if ((new_len & 1) != 0) {
      recv_flags = recv_flags | 0x20;
    }
    while (cseg = pcb->ooseq, cseg != (tcp_seg *)0x0) {
      uVar7 = cseg->tcphdr->seqno;
      if (uVar7 != pcb->rcv_nxt) break;
      n = cseg->len;
      seqno = uVar7;
      new_len = lwip_htons(cseg->tcphdr->_hdrlen_rsvd_flags);
      pcb->rcv_nxt = (uint)((new_len & 3) != 0) + (uint)n + pcb->rcv_nxt;
      lwip_htons(cseg->tcphdr->_hdrlen_rsvd_flags);
      new_len = cseg->len;
      uVar3 = lwip_htons(cseg->tcphdr->_hdrlen_rsvd_flags);
      pcb->rcv_wnd = pcb->rcv_wnd - (((uVar3 & 3) != 0) + new_len);
      tcp_update_rcv_ann_wnd(pcb);
      p = cseg->p;
      if (p->tot_len != 0) {
        if (recv_data != (pbuf *)0x0) {
          pbuf_cat(recv_data,p);
          p = recv_data;
        }
        recv_data = p;
        cseg->p = (pbuf *)0x0;
      }
      new_len = lwip_htons(cseg->tcphdr->_hdrlen_rsvd_flags);
      if (((new_len & 1) != 0) && (recv_flags = recv_flags | 0x20, pcb->state == ESTABLISHED)) {
        pcb->state = CLOSE_WAIT;
      }
      pcb->ooseq = cseg->next;
      tcp_seg_free(cseg);
    }
    n = pcb->flags;
    if ((n & 1) == 0) {
      tVar12 = n | 1;
      goto LAB_23042fca;
    }
    tVar12 = n & 0xfffe;
  }
  tVar12 = tVar12 | 2;
LAB_23042fca:
  pcb->flags = tVar12;
  return;
}



// WARNING: Restarted to delay deadcode elimination for space: ram

void tcp_input(pbuf *p,netif *inp)

{
  ushort uVar1;
  u16_t uVar2;
  byte bVar3;
  tcp_hdr *ptVar4;
  tcp_hdr *ptVar5;
  tcp_pcb *ptVar6;
  u8_t uVar7;
  err_t eVar8;
  u16_t sendmss;
  tcpwnd_size_t tVar9;
  undefined3 extraout_var;
  undefined2 extraout_var_08;
  undefined2 extraout_var_09;
  undefined3 extraout_var_00;
  tcp_pcb *pcb;
  u32_t uVar10;
  netif *outif;
  undefined3 extraout_var_01;
  undefined2 extraout_var_10;
  tcp_seg *seg;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  undefined3 extraout_var_05;
  undefined3 extraout_var_06;
  undefined3 extraout_var_07;
  uint header_size_decrement;
  u32_t ackno;
  int iVar11;
  tcp_state tVar12;
  u16_t uVar13;
  tcpflags_t tVar14;
  uint uVar15;
  void *pvVar16;
  tcp_accept_fn paVar17;
  uint uVar18;
  tcp_pcb *ptVar19;
  pbuf *p_00;
  u16_t remote_port;
  tcp_pcb *ptVar20;
  tcp_pcb *pcb_00;
  
  lwip_stats.tcp.recv = lwip_stats.tcp.recv + 1;
  tcphdr = (tcp_hdr *)p->payload;
  if (p->len < 0x14) goto LAB_230432a4;
  uVar7 = ip4_addr_isbroadcast_u32(ip_data.current_iphdr_dest,ip_data.current_netif);
  if ((CONCAT31(extraout_var,uVar7) == 0) && ((ip_data.current_iphdr_dest & 0xf0) != 0xe0)) {
    sendmss = ip_chksum_pseudo(p,'\x06',p->tot_len,(ip4_addr_t *)&ip_data.current_iphdr_src,
                               (ip4_addr_t *)&ip_data.current_iphdr_dest);
    if (CONCAT22(extraout_var_08,sendmss) == 0) {
      sendmss = lwip_htons(tcphdr->_hdrlen_rsvd_flags);
      header_size_decrement = CONCAT22(extraout_var_09,sendmss) >> 10 & 0xfc;
      if ((0x13 < header_size_decrement) && (header_size_decrement <= p->tot_len)) {
        tcphdr_optlen = (u16_t)((header_size_decrement - 0x14) * 0x10000 >> 0x10);
        tcphdr_opt2 = (u8_t *)0x0;
        if (p->len < header_size_decrement) {
          pbuf_remove_header(p,0x14);
          sendmss = tcphdr_optlen;
          uVar1 = p->len;
          header_size_decrement = (uint)tcphdr_optlen;
          tcphdr_opt1len = uVar1;
          pbuf_remove_header(p,(uint)uVar1);
          p_00 = p->next;
          header_size_decrement = header_size_decrement - (uint)uVar1 & 0xffff;
          if (p_00->len < header_size_decrement) goto LAB_230432a4;
          tcphdr_opt2 = (u8_t *)p_00->payload;
          pbuf_remove_header(p_00,header_size_decrement);
          p->tot_len = (uVar1 + p->tot_len) - sendmss;
        }
        else {
          tcphdr_opt1len = tcphdr_optlen;
          pbuf_remove_header(p,header_size_decrement);
        }
        ptVar4 = tcphdr;
        sendmss = lwip_htons(tcphdr->src);
        *(char *)&ptVar4->src = (char)sendmss;
        *(undefined *)((int)&ptVar4->src + 1) = (char)(sendmss >> 8);
        ptVar4 = tcphdr;
        sendmss = lwip_htons(tcphdr->dest);
        *(char *)&ptVar4->dest = (char)sendmss;
        *(undefined *)((int)&ptVar4->dest + 1) = (char)(sendmss >> 8);
        ptVar4 = tcphdr;
        seqno = lwip_htonl(tcphdr->seqno);
        *(undefined *)((int)&ptVar4->seqno + 1) = (char)(seqno >> 8);
        *(undefined *)((int)&ptVar4->seqno + 2) = (char)(seqno >> 0x10);
        *(char *)&ptVar4->seqno = (char)seqno;
        *(undefined *)((int)&ptVar4->seqno + 3) = (char)(seqno >> 0x18);
        ptVar4 = tcphdr;
        ackno = lwip_htonl(tcphdr->ackno);
        *(undefined *)((int)&ptVar4->ackno + 1) = (char)(ackno >> 8);
        *(undefined *)((int)&ptVar4->ackno + 2) = (char)(ackno >> 0x10);
        *(char *)&ptVar4->ackno = (char)ackno;
        *(undefined *)((int)&ptVar4->ackno + 3) = (char)(ackno >> 0x18);
        ptVar4 = tcphdr;
        sendmss = lwip_htons(tcphdr->wnd);
        ptVar5 = tcphdr;
        *(char *)&ptVar4->wnd = (char)sendmss;
        *(undefined *)((int)&ptVar4->wnd + 1) = (char)(sendmss >> 8);
        sendmss = lwip_htons(ptVar5->_hdrlen_rsvd_flags);
        ptVar19 = tcp_active_pcbs;
        ptVar6 = tcp_listen_pcbs;
        ptVar4 = tcphdr;
        flags = (byte)sendmss & 0x3f;
        tcplen = p->tot_len;
        header_size_decrement = (uint)tcplen;
        if (((sendmss & 3) == 0) ||
           (uVar15 = header_size_decrement + 1, tcplen = (u16_t)(uVar15 * 0x10000 >> 0x10),
           header_size_decrement <= (uVar15 & 0xffff))) {
          uVar2 = tcplen;
          pcb = tcp_active_pcbs;
          ptVar20 = (tcp_pcb *)0x0;
LAB_230434e6:
          pcb_00 = pcb;
          pcb = tcp_tw_pcbs;
          if (pcb_00 == (tcp_pcb *)0x0) goto LAB_2304374c;
          if (((((pcb_00->netif_idx != '\0') &&
                (pcb_00->netif_idx != (u8_t)((ip_data.current_input_netif)->num + '\x01'))) ||
               (pcb_00->remote_port != tcphdr->src)) ||
              ((pcb_00->local_port != tcphdr->dest ||
               ((pcb_00->remote_ip).addr != ip_data.current_iphdr_src)))) ||
             ((pcb_00->local_ip).addr != ip_data.current_iphdr_dest)) goto LAB_23043672;
          if (ptVar20 == (tcp_pcb *)0x0) {
            lwip_stats.tcp.cachehit = lwip_stats.tcp.cachehit + 1;
          }
          else {
            tcp_active_pcbs = pcb_00;
            ptVar20->next = pcb_00->next;
            pcb_00->next = ptVar19;
          }
          inseg.len = p->tot_len;
          recv_data = (pbuf *)0x0;
          recv_flags = '\0';
          recv_acked = 0;
          inseg.next = (tcp_seg *)0x0;
          inseg.tcphdr = ptVar4;
          inseg.p = p;
          if ((sendmss & 8) != 0) {
            p->flags = p->flags | 1;
          }
          if ((pcb_00->refused_data != (pbuf *)0x0) &&
             ((eVar8 = tcp_process_refused_data(pcb_00), CONCAT31(extraout_var_00,eVar8) == -0xd ||
              ((pcb_00->refused_data != (pbuf *)0x0 && (tcplen != 0)))))) {
            if (pcb_00->rcv_ann_wnd == 0) {
              tcp_send_empty_ack(pcb_00);
            }
            lwip_stats.tcp.drop = lwip_stats.tcp.drop + 1;
            goto aborted;
          }
          uVar7 = flags;
          tcp_input_pcb = pcb_00;
          if ((flags & 4) != 0) {
            if (pcb_00->state == SYN_SENT) {
              if (pcb_00->snd_nxt != ackno) goto switchD_23043a08_caseD_8;
            }
            else {
              if (pcb_00->rcv_nxt != seqno) {
                iVar11 = seqno - pcb_00->rcv_nxt;
                if ((-1 < iVar11) && ((int)(iVar11 - (uint)pcb_00->rcv_wnd) < 1)) goto LAB_23043994;
                goto switchD_23043a08_caseD_8;
              }
            }
            recv_flags = recv_flags | 8;
            tVar14 = pcb_00->flags & 0xfffe;
LAB_2304394e:
            pcb_00->flags = tVar14;
            goto switchD_23043a08_caseD_8;
          }
          bVar3 = flags & 2;
          tVar14 = pcb_00->flags;
          if (((flags & 2) != 0) && (1 < (byte)(pcb_00->state + ~LISTEN))) {
LAB_230439b6:
            tVar14 = tVar14 | 2;
            goto LAB_2304394e;
          }
          if ((tVar14 & 0x10) == 0) {
            pcb_00->tmr = tcp_ticks;
          }
          *(undefined2 *)&pcb_00->persist_probe = 0;
          if (tcphdr_optlen != 0) {
            tcp_parseopt(&pcb_00->mss);
          }
          ackno = seqno;
          switch((uint)pcb_00->state - 2 & 0xff) {
          case 0:
            if (((uVar7 & 0x12) != 0x12) || (uVar10 = pcb_00->lastack + 1, uVar10 != ackno)) {
              if (((uVar7 & 0x10) != 0) &&
                 (tcp_rst(pcb_00,ackno,seqno + tcplen,&ip_data.current_iphdr_dest,
                          &ip_data.current_iphdr_src,tcphdr->dest,tcphdr->src), pcb_00->nrtx < 6)) {
                pcb_00->rtime = 0;
                tcp_rexmit_rto(pcb_00);
              }
              goto switchD_23043a08_caseD_8;
            }
            pcb_00->lastack = uVar10;
            uVar10 = ackno + 1;
            pcb_00->rcv_nxt = uVar10;
            pcb_00->rcv_ann_right_edge = uVar10;
            sendmss = pcb_00->mss;
            uVar2 = tcphdr->wnd;
            pcb_00->snd_wl1 = ackno - 1;
            pcb_00->snd_wnd = uVar2;
            pcb_00->snd_wnd_max = uVar2;
            pcb_00->state = ESTABLISHED;
            outif = ip4_route((ip4_addr_t *)&pcb_00->remote_ip);
            sendmss = tcp_eff_send_mss_netif
                                (sendmss,outif,(ip_addr_t *)(ip4_addr_t *)&pcb_00->remote_ip);
            iVar11 = CONCAT22(extraout_var_10,sendmss);
            uVar15 = iVar11 << 1;
            pcb_00->mss = sendmss;
            tVar9 = 0x111c;
            header_size_decrement = uVar15;
            if (uVar15 < 0x111c) {
              header_size_decrement = 0x111c;
            }
            if ((uint)(iVar11 << 2) < header_size_decrement) {
              tVar9 = (tcpwnd_size_t)((uint)(iVar11 << 0x12) >> 0x10);
            }
            else {
              if (0x111c < uVar15) {
                tVar9 = (tcpwnd_size_t)((uint)(iVar11 << 0x11) >> 0x10);
              }
            }
            pcb_00->cwnd = tVar9;
            seg = pcb_00->unacked;
            pcb_00->snd_queuelen = pcb_00->snd_queuelen - 1;
            if (seg == (tcp_seg *)0x0) {
              seg = pcb_00->unsent;
              pcb_00->unsent = seg->next;
            }
            else {
              pcb_00->unacked = seg->next;
            }
            tcp_seg_free(seg);
            if (pcb_00->unacked == (tcp_seg *)0x0) {
              pcb_00->rtime = -1;
            }
            else {
              pcb_00->rtime = 0;
              pcb_00->nrtx = '\0';
            }
            if ((pcb_00->connected == (tcp_connected_fn)0x0) ||
               (eVar8 = (*pcb_00->connected)(pcb_00->callback_arg,pcb_00,'\0'),
               CONCAT31(extraout_var_02,eVar8) != -0xd)) {
LAB_23043994:
              tVar14 = pcb_00->flags;
              goto LAB_230439b6;
            }
            goto aborted;
          case 1:
            if ((uVar7 & 0x10) == 0) {
              if ((bVar3 != 0) && (pcb_00->rcv_nxt - 1 == seqno)) {
                tcp_rexmit(pcb_00);
              }
              goto switchD_23043a08_caseD_8;
            }
            if (((int)((ackno - 1) - pcb_00->lastack) < 0) || (0 < (int)(ackno - pcb_00->snd_nxt)))
            {
              tcp_rst(pcb_00,ackno,seqno + tcplen,&ip_data.current_iphdr_dest,
                      &ip_data.current_iphdr_src,tcphdr->dest,tcphdr->src);
              goto switchD_23043a08_caseD_8;
            }
            pcb_00->state = ESTABLISHED;
            if ((pcb_00->listener == (tcp_pcb_listen *)0x0) ||
               (paVar17 = pcb_00->listener->accept, paVar17 == (tcp_accept_fn)0x0))
            goto LAB_23043b68;
            eVar8 = (*paVar17)(pcb_00->callback_arg,pcb_00,'\0');
            if (CONCAT31(extraout_var_03,eVar8) != 0) {
              if (CONCAT31(extraout_var_03,eVar8) == -0xd) goto aborted;
              goto LAB_23043b68;
            }
            tcp_receive(pcb_00);
            if (recv_acked != 0) {
              recv_acked = recv_acked - 1;
            }
            uVar18 = (uint)pcb_00->mss;
            uVar15 = uVar18 << 1;
            tVar9 = 0x111c;
            header_size_decrement = uVar15;
            if (uVar15 < 0x111c) {
              header_size_decrement = 0x111c;
            }
            if (uVar18 << 2 < header_size_decrement) {
              tVar9 = (tcpwnd_size_t)((uVar18 << 0x12) >> 0x10);
            }
            else {
              if (0x111c < uVar15) {
                tVar9 = (tcpwnd_size_t)((uVar18 << 0x11) >> 0x10);
              }
            }
            pcb_00->cwnd = tVar9;
            break;
          case 2:
          case 5:
            tcp_receive(pcb_00);
            break;
          case 3:
            tcp_receive(pcb_00);
            if ((recv_flags & 0x20) != 0) {
              if ((((flags & 0x10) == 0) || (pcb_00->snd_nxt != ackno)) ||
                 (pcb_00->unsent != (tcp_seg *)0x0)) {
                pcb_00->flags = pcb_00->flags | 2;
                tVar12 = CLOSING;
                goto LAB_23043bda;
              }
              pcb_00->flags = pcb_00->flags | 2;
              tcp_pcb_purge(pcb_00);
              ptVar6 = tcp_active_pcbs;
              if (pcb_00 == tcp_active_pcbs) goto LAB_23043c86;
              goto LAB_23043c9c;
            }
            if ((((flags & 0x10) == 0) || (pcb_00->snd_nxt != ackno)) ||
               (pcb_00->unsent != (tcp_seg *)0x0)) goto switchD_23043a08_caseD_8;
            tVar12 = FIN_WAIT_2;
            goto LAB_23043bda;
          case 4:
            tcp_receive(pcb_00);
            if ((recv_flags & 0x20) == 0) goto switchD_23043a08_caseD_8;
            pcb_00->flags = pcb_00->flags | 2;
            tcp_pcb_purge(pcb_00);
            ptVar6 = tcp_active_pcbs;
            if (pcb_00 == tcp_active_pcbs) goto LAB_23043c86;
            goto LAB_23043d18;
          case 6:
            tcp_receive(pcb_00);
            if ((((flags & 0x10) == 0) || (pcb_00->snd_nxt != ackno)) ||
               (pcb_00->unsent != (tcp_seg *)0x0)) goto switchD_23043a08_caseD_8;
            tcp_pcb_purge(pcb_00);
            ptVar6 = tcp_active_pcbs;
            if (pcb_00 != tcp_active_pcbs) goto LAB_23043d52;
LAB_23043c86:
            tcp_active_pcbs = pcb_00->next;
            goto LAB_23043c9e;
          case 7:
            tcp_receive(pcb_00);
            if ((((flags & 0x10) != 0) && (pcb_00->snd_nxt == ackno)) &&
               (pcb_00->unsent == (tcp_seg *)0x0)) {
              recv_flags = recv_flags | 0x10;
            }
          default:
            goto switchD_23043a08_caseD_8;
          }
          if ((recv_flags & 0x20) == 0) goto switchD_23043a08_caseD_8;
          pcb_00->flags = pcb_00->flags | 2;
          tVar12 = CLOSE_WAIT;
LAB_23043bda:
          pcb_00->state = tVar12;
          goto switchD_23043a08_caseD_8;
        }
      }
LAB_230432a4:
      lwip_stats.tcp.lenerr = lwip_stats.tcp.lenerr + 1;
    }
    else {
      lwip_stats.tcp.chkerr = lwip_stats.tcp.chkerr + 1;
    }
  }
  else {
    lwip_stats.tcp.proterr = lwip_stats.tcp.proterr + 1;
  }
  lwip_stats.tcp.drop = lwip_stats.tcp.drop + 1;
LAB_23043728:
  pbuf_free(p);
  return;
LAB_2304374c:
  if (pcb == (tcp_pcb *)0x0) goto code_r0x2304374e;
  if ((((pcb->netif_idx == '\0') ||
       (pcb->netif_idx == (u8_t)((ip_data.current_input_netif)->num + '\x01'))) &&
      ((remote_port = pcb->remote_port, remote_port == tcphdr->src &&
       ((uVar13 = pcb->local_port, uVar13 == tcphdr->dest &&
        (ip_data.current_iphdr_src == (pcb->remote_ip).addr)))))) &&
     (ip_data.current_iphdr_dest == (pcb->local_ip).addr)) {
    if ((sendmss & 4) != 0) goto LAB_23043728;
    if ((sendmss & 2) == 0) {
      if ((sendmss & 1) != 0) {
        pcb->tmr = tcp_ticks;
      }
    }
    else {
      iVar11 = seqno - pcb->rcv_nxt;
      if ((-1 < iVar11) && ((int)(iVar11 - (uint)pcb->rcv_wnd) < 1)) {
        ackno = tcplen + seqno;
        goto LAB_23043702;
      }
    }
    if (uVar2 == 0) goto LAB_23043728;
    pcb->flags = pcb->flags | 2;
    goto LAB_23043724;
  }
  pcb = pcb->next;
  goto LAB_2304374c;
code_r0x2304374e:
  ptVar20 = (tcp_pcb *)0x0;
  pcb_00 = (tcp_pcb *)0x0;
  ptVar19 = tcp_listen_pcbs;
  while (ptVar19 != (tcp_pcb *)0x0) {
    if (((ptVar19->netif_idx == '\0') ||
        (ptVar19->netif_idx == (u8_t)((ip_data.current_input_netif)->num + '\x01'))) &&
       (ptVar19->local_port == tcphdr->dest)) {
      ackno = (ptVar19->local_ip).addr;
      if (ip_data.current_iphdr_dest == ackno) goto LAB_230437aa;
      if (ackno == 0) {
        ptVar20 = ptVar19;
        pcb_00 = pcb;
      }
    }
    pcb = ptVar19;
    ptVar19 = ptVar19->next;
  }
  pcb = pcb_00;
  ptVar19 = ptVar20;
  if (ptVar20 == (tcp_pcb *)0x0) {
    sendmss = lwip_htons(tcphdr->_hdrlen_rsvd_flags);
    if ((sendmss & 4) != 0) goto LAB_23043728;
    lwip_stats.tcp.proterr = lwip_stats.tcp.proterr + 1;
    lwip_stats.tcp.drop = lwip_stats.tcp.drop + 1;
    remote_port = tcphdr->src;
    uVar13 = tcphdr->dest;
    ackno = seqno + tcplen;
    pcb = (tcp_pcb *)0x0;
  }
  else {
LAB_230437aa:
    if (pcb == (tcp_pcb *)0x0) {
      lwip_stats.tcp.cachehit = lwip_stats.tcp.cachehit + 1;
    }
    else {
      tcp_listen_pcbs = ptVar19;
      pcb->next = ptVar19->next;
      ptVar19->next = ptVar6;
    }
    if ((sendmss & 4) != 0) goto LAB_23043728;
    if ((sendmss & 0x10) == 0) {
      if ((sendmss & 2) != 0) {
        pcb = tcp_alloc(ptVar19->prio);
        ptVar4 = tcphdr;
        if (pcb == (tcp_pcb *)0x0) {
          lwip_stats.tcp.memerr = lwip_stats.tcp.memerr + 1;
          if (*(code **)&ptVar19->remote_port != (code *)0x0) {
            (**(code **)&ptVar19->remote_port)(ptVar19->callback_arg,0,0xffffffff);
          }
        }
        else {
          (pcb->local_ip).addr = ip_data.current_iphdr_dest;
          (pcb->remote_ip).addr = ip_data.current_iphdr_src;
          pcb->local_port = ptVar19->local_port;
          pcb->remote_port = ptVar4->src;
          pcb->state = SYN_RCVD;
          ackno = seqno + 1;
          pcb->rcv_nxt = ackno;
          pcb->rcv_ann_right_edge = ackno;
          uVar10 = tcp_next_iss(pcb);
          ackno = seqno;
          pcb->snd_wl2 = uVar10;
          pcb->snd_nxt = uVar10;
          pcb->lastack = uVar10;
          pcb->snd_lbb = uVar10;
          pcb->snd_wl1 = ackno - 1;
          pvVar16 = ptVar19->callback_arg;
          *(tcp_pcb **)&pcb->listener = ptVar19;
          pcb->callback_arg = pvVar16;
          pcb->so_options = ptVar19->so_options & 0xc;
          pcb->netif_idx = ptVar19->netif_idx;
          ptVar6 = pcb;
          pcb->next = tcp_active_pcbs;
          tcp_active_pcbs = ptVar6;
          tcp_timer_needed();
          tcp_active_pcbs_changed = '\x01';
          if (tcphdr_optlen != 0) {
            tcp_parseopt(&pcb->mss);
          }
          uVar2 = tcphdr->wnd;
          sendmss = pcb->mss;
          pcb->snd_wnd = uVar2;
          pcb->snd_wnd_max = uVar2;
          outif = ip4_route((ip4_addr_t *)&pcb->remote_ip);
          sendmss = tcp_eff_send_mss_netif(sendmss,outif,(ip_addr_t *)(ip4_addr_t *)&pcb->remote_ip)
          ;
          pcb->mss = sendmss;
          eVar8 = tcp_enqueue_flags(pcb,'\x12');
          if (CONCAT31(extraout_var_01,eVar8) == 0) {
LAB_23043724:
            tcp_output(pcb);
          }
          else {
            tcp_abandon(pcb,0);
          }
        }
      }
      goto LAB_23043728;
    }
    remote_port = tcphdr->src;
    uVar13 = tcphdr->dest;
    ackno = seqno + tcplen;
    pcb = ptVar19;
  }
LAB_23043702:
  tcp_rst(pcb,ackno,ackno,&ip_data.current_iphdr_dest,&ip_data.current_iphdr_src,uVar13,remote_port)
  ;
  goto LAB_23043728;
LAB_23043672:
  pcb = pcb_00->next;
  ptVar20 = pcb_00;
  goto LAB_230434e6;
  while (ptVar6 = ptVar19->next, pcb_00 != ptVar19->next) {
LAB_23043d52:
    ptVar19 = ptVar6;
    if (ptVar19 == (tcp_pcb *)0x0) goto LAB_23043c9e;
  }
  goto LAB_23043c94;
  while (ptVar6 = ptVar19->next, pcb_00 != ptVar19->next) {
LAB_23043d18:
    ptVar19 = ptVar6;
    if (ptVar19 == (tcp_pcb *)0x0) goto LAB_23043c9e;
  }
  goto LAB_23043c94;
  while (ptVar6 = ptVar19->next, pcb_00 != ptVar19->next) {
LAB_23043c9c:
    ptVar19 = ptVar6;
    if (ptVar19 == (tcp_pcb *)0x0) goto LAB_23043c9e;
  }
LAB_23043c94:
  ptVar19->next = pcb_00->next;
LAB_23043c9e:
  tcp_active_pcbs_changed = '\x01';
  pcb_00->state = TIME_WAIT;
  ptVar6 = pcb_00;
  pcb_00->next = tcp_tw_pcbs;
  tcp_tw_pcbs = ptVar6;
  tcp_timer_needed();
switchD_23043a08_caseD_8:
  if ((recv_flags & 8) == 0) {
    if (recv_acked != 0) {
      if ((pcb_00->sent != (tcp_sent_fn *)0x0) &&
         (eVar8 = (*pcb_00->sent)(pcb_00->callback_arg,pcb_00,recv_acked),
         CONCAT31(extraout_var_04,eVar8) == -0xd)) goto aborted;
      recv_acked = 0;
    }
    iVar11 = tcp_input_delayed_close(pcb_00);
    if (iVar11 == 0) {
      if (recv_data != (pbuf *)0x0) {
        if ((pcb_00->flags & 0x10) != 0) {
          pbuf_free(recv_data);
LAB_23043b68:
          tcp_abort(pcb_00);
          goto aborted;
        }
        if (pcb_00->recv == (tcp_recv_fn *)0x0) {
          eVar8 = tcp_recv_null((void *)0x0,pcb_00,recv_data,'\0');
          iVar11 = CONCAT31(extraout_var_06,eVar8);
        }
        else {
          eVar8 = (*pcb_00->recv)(pcb_00->callback_arg,pcb_00,recv_data,'\0');
          iVar11 = CONCAT31(extraout_var_05,eVar8);
        }
        if (iVar11 == -0xd) goto aborted;
        if (iVar11 != 0) {
          pcb_00->refused_data = recv_data;
        }
      }
      if ((recv_flags & 0x20) != 0) {
        p_00 = pcb_00->refused_data;
        if (p_00 == (pbuf *)0x0) {
          if (pcb_00->rcv_wnd != 0x810) {
            pcb_00->rcv_wnd = pcb_00->rcv_wnd + 1;
          }
          if ((pcb_00->recv != (tcp_recv_fn *)0x0) &&
             (eVar8 = (*pcb_00->recv)(pcb_00->callback_arg,pcb_00,(pbuf *)0x0,'\0'),
             CONCAT31(extraout_var_07,eVar8) == -0xd)) goto aborted;
        }
        else {
          p_00->flags = p_00->flags | 0x20;
        }
      }
      tcp_input_pcb = (tcp_pcb *)0x0;
      iVar11 = tcp_input_delayed_close(pcb_00);
      if (iVar11 == 0) {
        tcp_output(pcb_00);
      }
    }
  }
  else {
    if (pcb_00->errf != (tcp_err_fn *)0x0) {
      (*pcb_00->errf)(pcb_00->callback_arg,-0xe);
    }
    tcp_pcb_remove(&tcp_active_pcbs,pcb_00);
    tcp_free(pcb_00);
  }
aborted:
  tcp_input_pcb = (tcp_pcb *)0x0;
  recv_data = (pbuf *)0x0;
  if (inseg.p != (pbuf *)0x0) {
    pbuf_free(inseg.p);
    inseg.p = (pbuf *)0x0;
  }
  return;
}



void tcp_trigger_input_pcb_close(void)

{
  recv_flags = recv_flags | 0x10;
  return;
}



void tcp_seg_add_chksum(u16_t chksum,u16_t len,u16_t *seg_chksum,u8_t *seg_chksum_swapped)

{
  ushort uVar1;
  undefined2 in_register_0000202a;
  uint uVar2;
  
  uVar2 = CONCAT22(in_register_0000202a,chksum) + (uint)*seg_chksum;
  uVar2 = uVar2 + (uVar2 >> 0x10) & 0xffff;
  uVar1 = (ushort)uVar2;
  if ((len & 1) != 0) {
    *seg_chksum_swapped = '\x01' - *seg_chksum_swapped;
    uVar1 = (ushort)(uVar2 >> 8) | (ushort)(uVar2 << 8);
  }
  *seg_chksum = uVar1;
  return;
}



tcp_seg * tcp_create_segment(tcp_pcb *pcb,pbuf *p,u8_t hdrflags,u32_t seqno,u8_t optflags)

{
  tcp_seg *seg;
  u8_t uVar1;
  u16_t uVar2;
  undefined3 extraout_var;
  u32_t uVar3;
  undefined3 in_register_00002031;
  tcp_hdr *ptVar4;
  
  seg = (tcp_seg *)memp_malloc(MEMP_TCP_SEG);
  if (seg == (tcp_seg *)0x0) {
    pbuf_free(p);
  }
  else {
    seg->flags = optflags;
    seg->next = (tcp_seg *)0x0;
    seg->p = p;
    uVar2 = p->tot_len;
    seg->chksum = 0;
    seg->len = uVar2 + ((ushort)optflags & 1) * -4;
    seg->chksum_swapped = '\0';
    uVar1 = pbuf_add_header(p,0x14);
    if (CONCAT31(extraout_var,uVar1) == 0) {
      ptVar4 = (tcp_hdr *)seg->p->payload;
      seg->tcphdr = ptVar4;
      uVar2 = lwip_htons(pcb->local_port);
      *(char *)&ptVar4->src = (char)uVar2;
      *(undefined *)((int)&ptVar4->src + 1) = (char)(uVar2 >> 8);
      ptVar4 = seg->tcphdr;
      uVar2 = lwip_htons(pcb->remote_port);
      *(char *)&ptVar4->dest = (char)uVar2;
      *(undefined *)((int)&ptVar4->dest + 1) = (char)(uVar2 >> 8);
      ptVar4 = seg->tcphdr;
      uVar3 = lwip_htonl(seqno);
      *(char *)&ptVar4->seqno = (char)uVar3;
      *(undefined *)((int)&ptVar4->seqno + 1) = (char)(uVar3 >> 8);
      *(undefined *)((int)&ptVar4->seqno + 3) = (char)(uVar3 >> 0x18);
      *(undefined *)((int)&ptVar4->seqno + 2) = (char)(uVar3 >> 0x10);
      ptVar4 = seg->tcphdr;
      uVar2 = lwip_htons((((ushort)optflags & 1) + 5) * 0x1000 |
                         (ushort)CONCAT31(in_register_00002031,hdrflags));
      *(char *)&ptVar4->_hdrlen_rsvd_flags = (char)uVar2;
      *(undefined *)((int)&ptVar4->_hdrlen_rsvd_flags + 1) = (char)(uVar2 >> 8);
      ptVar4 = seg->tcphdr;
      *(undefined *)&ptVar4->urgp = 0;
      *(undefined *)((int)&ptVar4->urgp + 1) = 0;
    }
    else {
      lwip_stats.tcp.err = lwip_stats.tcp.err + 1;
      tcp_seg_free(seg);
      seg = (tcp_seg *)0x0;
    }
  }
  return seg;
}



pbuf * tcp_output_alloc_header_common
                 (u32_t ackno,u16_t datalen,u32_t seqno_be,u16_t src_port,u16_t dst_port,u8_t flags,
                 u16_t wnd)

{
  undefined *puVar1;
  u16_t uVar2;
  pbuf *ppVar3;
  u32_t uVar4;
  undefined2 in_register_0000202e;
  undefined3 in_register_0000203d;
  
  ppVar3 = pbuf_alloc(PBUF_IP,(u16_t)((uint)((CONCAT22(in_register_0000202e,datalen) + 0x14) *
                                            0x10000) >> 0x10),PBUF_RAM);
  if (ppVar3 != (pbuf *)0x0) {
    puVar1 = (undefined *)ppVar3->payload;
    uVar2 = lwip_htons(src_port);
    *puVar1 = (char)uVar2;
    puVar1[1] = (char)(uVar2 >> 8);
    uVar2 = lwip_htons(dst_port);
    puVar1[2] = (char)uVar2;
    puVar1[4] = (char)seqno_be;
    puVar1[5] = (char)(seqno_be >> 8);
    puVar1[3] = (char)(uVar2 >> 8);
    puVar1[6] = (char)(seqno_be >> 0x10);
    puVar1[7] = (char)(seqno_be >> 0x18);
    uVar4 = lwip_htonl(ackno);
    puVar1[8] = (char)uVar4;
    puVar1[9] = (char)(uVar4 >> 8);
    puVar1[0xb] = (char)(uVar4 >> 0x18);
    puVar1[10] = (char)(uVar4 >> 0x10);
    uVar2 = lwip_htons((ushort)CONCAT31(in_register_0000203d,flags) | 0x5000);
    puVar1[0xc] = (char)uVar2;
    puVar1[0xd] = (char)(uVar2 >> 8);
    uVar2 = lwip_htons(wnd);
    puVar1[0xe] = (char)uVar2;
    puVar1[0xf] = (char)(uVar2 >> 8);
    puVar1[0x10] = 0;
    puVar1[0x11] = 0;
    puVar1[0x12] = 0;
    puVar1[0x13] = 0;
  }
  return ppVar3;
}



pbuf * tcp_output_alloc_header(tcp_pcb *pcb,u16_t datalen,u32_t seqno_be)

{
  pbuf *ppVar1;
  
  ppVar1 = tcp_output_alloc_header_common
                     (pcb->rcv_nxt,datalen,seqno_be,pcb->local_port,pcb->remote_port,'\x10',
                      pcb->rcv_ann_wnd);
  if (ppVar1 != (pbuf *)0x0) {
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + (uint)pcb->rcv_ann_wnd;
  }
  return ppVar1;
}



err_t tcp_output_control_segment(tcp_pcb *pcb,pbuf *p,ip_addr_t *src,ip_addr_t *dst)

{
  err_t eVar1;
  u16_t uVar2;
  netif *netif;
  u8_t ttl;
  u8_t tos;
  void *pvVar3;
  
  if ((pcb == (tcp_pcb *)0x0) || (pcb->netif_idx == '\0')) {
    netif = ip4_route((ip4_addr_t *)dst);
  }
  else {
    netif = netif_get_by_index(pcb->netif_idx);
  }
  eVar1 = -4;
  if (netif != (netif *)0x0) {
    pvVar3 = p->payload;
    uVar2 = ip_chksum_pseudo(p,'\x06',p->tot_len,(ip4_addr_t *)src,(ip4_addr_t *)dst);
    *(undefined *)((int)pvVar3 + 0x10) = (char)uVar2;
    *(undefined *)((int)pvVar3 + 0x11) = (char)(uVar2 >> 8);
    if (pcb == (tcp_pcb *)0x0) {
      tos = '\0';
      ttl = -1;
    }
    else {
      ttl = pcb->ttl;
      tos = pcb->tos;
    }
    lwip_stats.tcp.xmit = lwip_stats.tcp.xmit + 1;
    eVar1 = ip4_output_if(p,(ip4_addr_t *)src,(ip4_addr_t *)dst,ttl,tos,'\x06',netif);
  }
  pbuf_free(p);
  return eVar1;
}



err_t tcp_write(tcp_pcb *pcb,void *arg,u16_t len,u8_t apiflags)

{
  ushort uVar1;
  tcp_seg *ptVar2;
  u16_t chksum_00;
  u16_t uVar3;
  u16_t len_00;
  undefined2 in_register_00002032;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  tcp_hdr *ptVar8;
  err_t eVar9;
  err_t eVar10;
  uint uVar11;
  tcp_seg *ptVar12;
  tcp_seg *seg;
  tcp_seg *ptVar13;
  uint uVar14;
  pbuf *p;
  tcp_seg *ptVar15;
  u8_t uStack67;
  u16_t uStack66;
  u8_t chksum_swapped;
  u16_t chksum;
  
  uVar4 = CONCAT22(in_register_00002032,len);
  if (pcb == (tcp_pcb *)0x0) {
    return -0x10;
  }
  uVar5 = (uint)pcb->mss;
  uVar7 = (uint)(pcb->snd_wnd_max >> 1);
  if (uVar5 < uVar7) {
    uVar7 = uVar5;
  }
  if (uVar7 == 0) {
    uVar7 = uVar5;
  }
  if (arg == (void *)0x0) {
    return -0x10;
  }
  if ((pcb->state != CLOSE_WAIT) && (2 < (byte)(pcb->state + ~LISTEN))) {
    return -0xb;
  }
  if (uVar4 == 0) {
LAB_23044268:
    ptVar2 = pcb->unsent;
    uVar3 = pcb->snd_queuelen;
    if (ptVar2 == (tcp_seg *)0x0) {
      ptVar15 = (tcp_seg *)0x0;
      uVar5 = 0;
      uVar11 = 0;
    }
    else {
      do {
        ptVar15 = ptVar2;
        ptVar2 = ptVar15->next;
      } while (ptVar2 != (tcp_seg *)0x0);
      uVar5 = (uint)pcb->unsent_oversize;
      uVar11 = 0;
      if (pcb->unsent_oversize != 0) {
        uVar11 = (uVar7 - ptVar15->len) + ((uint)ptVar15->flags & 1) * -4;
        uVar14 = uVar5;
        if (uVar4 < uVar5) {
          uVar14 = uVar4;
        }
        if ((uVar14 & 0xffff) < (uVar11 & 0xffff)) {
          uVar11 = uVar14;
        }
        uVar11 = uVar11 & 0xffff;
        uVar5 = uVar5 - uVar11 & 0xffff;
        ptVar2 = ptVar15;
      }
    }
    seg = (tcp_seg *)0x0;
    ptVar13 = (tcp_seg *)0x0;
    uVar14 = uVar11;
    while (uVar14 < uVar4) {
      uVar6 = uVar4 - uVar14;
      if (uVar7 < (uVar4 - uVar14 & 0xffff)) {
        uVar6 = uVar7;
      }
      uStack66 = 0;
      uStack67 = '\0';
      p = pbuf_alloc(PBUF_TRANSPORT,(u16_t)uVar7,PBUF_RAM);
      if (p == (pbuf *)0x0) {
memerr:
        pcb->flags = pcb->flags | 0x80;
        lwip_stats.tcp.memerr = lwip_stats.tcp.memerr + 1;
        if (seg != (tcp_seg *)0x0) {
          tcp_segs_free(seg);
        }
        goto LAB_23044228;
      }
      uVar1 = p->len;
      len_00 = (u16_t)uVar6;
      p->tot_len = len_00;
      p->len = len_00;
      chksum_00 = lwip_chksum_copy(p->payload,(void *)((int)arg + uVar14),len_00);
      tcp_seg_add_chksum(chksum_00,len_00,&uStack66,&uStack67);
      chksum_00 = pbuf_clen(p);
      uVar3 = uVar3 + chksum_00;
      uVar5 = (uint)uVar1 - (uVar6 & 0xffff) & 0xffff;
      if (0x10 < uVar3) {
        pbuf_free(p);
        goto memerr;
      }
      ptVar2 = tcp_create_segment(pcb,p,'\0',pcb->snd_lbb + uVar14,'\0');
      if (ptVar2 == (tcp_seg *)0x0) goto memerr;
      ptVar2->chksum = uStack66;
      ptVar2->chksum_swapped = uStack67;
      ptVar2->flags = ptVar2->flags | 4;
      ptVar12 = ptVar2;
      if (seg != (tcp_seg *)0x0) {
        ptVar13->next = ptVar2;
        ptVar12 = seg;
      }
      uVar14 = uVar14 + (uVar6 & 0xffff) & 0xffff;
      seg = ptVar12;
      ptVar13 = ptVar2;
    }
    if (uVar11 != 0) {
      p = ptVar15->p;
      while (chksum_00 = (u16_t)uVar11, p != (pbuf *)0x0) {
        p->tot_len = p->tot_len + chksum_00;
        if (p->next == (pbuf *)0x0) {
          len_00 = lwip_chksum_copy((void *)((int)p->payload + (uint)p->len),arg,chksum_00);
          tcp_seg_add_chksum(len_00,chksum_00,&ptVar15->chksum,&ptVar15->chksum_swapped);
          ptVar15->flags = ptVar15->flags | 4;
          p->len = p->len + chksum_00;
        }
        p = p->next;
      }
      ptVar15->len = chksum_00 + ptVar15->len;
    }
    pcb->unsent_oversize = (u16_t)uVar5;
    if (ptVar15 == (tcp_seg *)0x0) {
      pcb->unsent = seg;
    }
    else {
      ptVar15->next = seg;
    }
    pcb->snd_queuelen = uVar3;
    pcb->snd_lbb = pcb->snd_lbb + uVar4;
    pcb->snd_buf = pcb->snd_buf - len;
    eVar10 = '\0';
    eVar9 = '\0';
    if (((ptVar2 != (tcp_seg *)0x0) && (eVar9 = eVar10, ptVar2->tcphdr != (tcp_hdr *)0x0)) &&
       ((apiflags & 2) == 0)) {
      uVar1 = ptVar2->tcphdr->_hdrlen_rsvd_flags;
      uVar3 = lwip_htons(8);
      ptVar8 = ptVar2->tcphdr;
      uVar1 = uVar3 | uVar1;
      *(char *)&ptVar8->_hdrlen_rsvd_flags = (char)uVar1;
      *(undefined *)((int)&ptVar8->_hdrlen_rsvd_flags + 1) = (char)((uint)uVar1 >> 8);
    }
  }
  else {
    if (uVar4 <= pcb->snd_buf) {
      if (pcb->snd_queuelen < 0x10) goto LAB_23044268;
      lwip_stats.tcp.memerr = lwip_stats.tcp.memerr + 1;
    }
    pcb->flags = pcb->flags | 0x80;
LAB_23044228:
    eVar9 = -1;
  }
  return eVar9;
}



err_t tcp_split_unsent_seg(tcp_pcb *pcb,u16_t split)

{
  byte bVar1;
  ushort *puVar2;
  ushort uVar3;
  tcp_seg *ptVar4;
  uint uVar5;
  u16_t len;
  u16_t uVar6;
  pbuf *p;
  undefined2 extraout_var;
  u32_t uVar7;
  tcp_seg *ptVar8;
  undefined2 in_register_0000202e;
  byte hdrflags;
  tcp_hdr *ptVar9;
  int iVar10;
  uint uVar11;
  uint uVar12;
  u8_t uStack51;
  u16_t uStack50;
  u8_t chksum_swapped;
  u16_t chksum;
  
  uVar5 = CONCAT22(in_register_0000202e,split);
  ptVar4 = pcb->unsent;
  uStack50 = 0;
  uStack51 = '\0';
  if (ptVar4 != (tcp_seg *)0x0) {
    if (uVar5 == 0) {
      return -6;
    }
    uVar11 = (uint)ptVar4->len;
    if (uVar11 <= uVar5) {
      return '\0';
    }
    bVar1 = ptVar4->flags;
    iVar10 = ((uint)bVar1 & 1) * 4;
    uVar12 = uVar11 - uVar5 & 0xffff;
    p = pbuf_alloc(PBUF_TRANSPORT,(u16_t)((uVar12 + iVar10) * 0x10000 >> 0x10),PBUF_RAM);
    if ((p != (pbuf *)0x0) &&
       (len = pbuf_copy_partial(ptVar4->p,(void *)((int)p->payload + iVar10),
                                (u16_t)((uVar11 - uVar5) * 0x10000 >> 0x10),
                                (u16_t)((((uint)ptVar4->p->tot_len - (uint)ptVar4->len) + uVar5) *
                                        0x10000 >> 0x10)), CONCAT22(extraout_var,len) == uVar12)) {
      uVar6 = inet_chksum((void *)((int)p->payload + iVar10),len);
      tcp_seg_add_chksum(~uVar6,len,&uStack50,&uStack51);
      len = lwip_htons(ptVar4->tcphdr->_hdrlen_rsvd_flags);
      hdrflags = (byte)len & 8;
      if ((len & 8) == 0) {
        len = len & 0x3f;
      }
      else {
        len = len & 0x37;
        hdrflags = 8;
      }
      if ((len & 1) != 0) {
        len = len & 0xfe;
        hdrflags = hdrflags | 1;
      }
      uVar7 = lwip_htonl(ptVar4->tcphdr->seqno);
      ptVar8 = tcp_create_segment(pcb,p,hdrflags,uVar5 + uVar7,bVar1 & 0xfb);
      if (ptVar8 != (tcp_seg *)0x0) {
        ptVar8->chksum = uStack50;
        ptVar8->chksum_swapped = uStack51;
        ptVar8->flags = ptVar8->flags | 4;
        uVar6 = pbuf_clen(ptVar4->p);
        pcb->snd_queuelen = pcb->snd_queuelen - uVar6;
        pbuf_realloc(ptVar4->p,
                     (u16_t)(((uint)ptVar4->p->tot_len + (uVar5 - uVar11 & 0xffff)) * 0x10000 >>
                            0x10));
        ptVar4->len = (short)((uVar5 - uVar11) * 0x10000 >> 0x10) + ptVar4->len;
        uVar3 = ptVar4->tcphdr->_hdrlen_rsvd_flags;
        len = lwip_htons(len);
        ptVar9 = ptVar4->tcphdr;
        uVar3 = uVar3 | len;
        *(char *)&ptVar9->_hdrlen_rsvd_flags = (char)uVar3;
        *(undefined *)((int)&ptVar9->_hdrlen_rsvd_flags + 1) = (char)((uint)uVar3 >> 8);
        len = pbuf_clen(ptVar4->p);
        pcb->snd_queuelen = len + pcb->snd_queuelen;
        p = ptVar4->p;
        ptVar4->chksum = 0;
        ptVar4->chksum_swapped = '\0';
        uVar5 = (uint)p->tot_len - (uint)ptVar4->len;
        while( true ) {
          uVar5 = uVar5 & 0xffff;
          puVar2 = &p->len;
          if (uVar5 <= *puVar2) break;
          p = p->next;
          uVar5 = uVar5 - *puVar2;
          if (p == (pbuf *)0x0) goto LAB_230446e4;
        }
        do {
          len = inet_chksum((void *)((int)p->payload + uVar5),
                            (u16_t)((p->len - uVar5) * 0x10000 >> 0x10));
          tcp_seg_add_chksum(~len,(u16_t)((p->len - uVar5) * 0x10000 >> 0x10),&ptVar4->chksum,
                             &ptVar4->chksum_swapped);
          p = p->next;
          uVar5 = 0;
        } while (p != (pbuf *)0x0);
LAB_230446e4:
        len = pbuf_clen(ptVar8->p);
        pcb->snd_queuelen = len + pcb->snd_queuelen;
        ptVar8->next = ptVar4->next;
        ptVar4->next = ptVar8;
        ptVar4 = ptVar8->next;
        if (ptVar4 != (tcp_seg *)0x0) {
          return '\0';
        }
        pcb->unsent_oversize = 0;
        return (err_t)ptVar4;
      }
    }
    lwip_stats.tcp.memerr = lwip_stats.tcp.memerr + 1;
    if (p != (pbuf *)0x0) {
      pbuf_free(p);
    }
  }
  return -1;
}



err_t tcp_enqueue_flags(tcp_pcb *pcb,u8_t flags)

{
  err_t eVar1;
  u16_t uVar2;
  pbuf *p;
  tcp_seg *ptVar3;
  uint uVar4;
  tcp_seg *ptVar5;
  tcp_seg *ptVar6;
  
  uVar4 = ((uint)flags & 2) >> 1;
  p = pbuf_alloc(PBUF_TRANSPORT,(u16_t)(uVar4 << 2),PBUF_RAM);
  if ((p == (pbuf *)0x0) ||
     (ptVar3 = tcp_create_segment(pcb,p,flags,pcb->snd_lbb,(u8_t)uVar4), ptVar3 == (tcp_seg *)0x0))
  {
    eVar1 = -1;
    pcb->flags = pcb->flags | 0x80;
    lwip_stats.tcp.memerr = lwip_stats.tcp.memerr + 1;
  }
  else {
    ptVar5 = pcb->unsent;
    if (pcb->unsent == (tcp_seg *)0x0) {
      pcb->unsent = ptVar3;
    }
    else {
      do {
        ptVar6 = ptVar5;
        ptVar5 = ptVar6->next;
      } while (ptVar5 != (tcp_seg *)0x0);
      ptVar6->next = ptVar3;
    }
    pcb->unsent_oversize = 0;
    if ((flags & 3) != 0) {
      pcb->snd_lbb = pcb->snd_lbb + 1;
    }
    if ((flags & 1) != 0) {
      pcb->flags = pcb->flags | 0x20;
    }
    uVar2 = pbuf_clen(ptVar3->p);
    pcb->snd_queuelen = uVar2 + pcb->snd_queuelen;
    eVar1 = '\0';
  }
  return eVar1;
}



err_t tcp_send_fin(tcp_pcb *pcb)

{
  ushort uVar1;
  tcp_seg *ptVar2;
  tcp_seg *ptVar3;
  err_t eVar4;
  u16_t uVar5;
  tcp_hdr *ptVar6;
  
  ptVar2 = pcb->unsent;
  if (pcb->unsent != (tcp_seg *)0x0) {
    do {
      ptVar3 = ptVar2;
      ptVar2 = ptVar3->next;
    } while (ptVar3->next != (tcp_seg *)0x0);
    uVar5 = lwip_htons(ptVar3->tcphdr->_hdrlen_rsvd_flags);
    if ((uVar5 & 7) == 0) {
      uVar1 = ptVar3->tcphdr->_hdrlen_rsvd_flags;
      uVar5 = lwip_htons(1);
      ptVar6 = ptVar3->tcphdr;
      uVar1 = uVar5 | uVar1;
      *(char *)&ptVar6->_hdrlen_rsvd_flags = (char)uVar1;
      *(undefined *)((int)&ptVar6->_hdrlen_rsvd_flags + 1) = (char)((uint)uVar1 >> 8);
      pcb->flags = pcb->flags | 0x20;
      return '\0';
    }
  }
  eVar4 = tcp_enqueue_flags(pcb,'\x01');
  return eVar4;
}



err_t tcp_rexmit_rto_prepare(tcp_pcb *pcb)

{
  u8_t uVar1;
  ushort uVar2;
  tcp_seg *ptVar3;
  u16_t uVar4;
  u32_t uVar5;
  tcp_seg *ptVar6;
  
  ptVar3 = pcb->unacked;
  if (pcb->unacked != (tcp_seg *)0x0) {
    do {
      uVar1 = ptVar3->p->ref;
      if (ptVar3->next == (tcp_seg *)0x0) {
        if (uVar1 != '\x01') {
          return -6;
        }
        ptVar3->next = pcb->unsent;
        ptVar6 = pcb->unacked;
        pcb->unacked = (tcp_seg *)0x0;
        pcb->unsent = ptVar6;
        pcb->flags = pcb->flags | 0x800;
        uVar5 = lwip_htonl(ptVar3->tcphdr->seqno);
        uVar2 = ptVar3->len;
        uVar4 = lwip_htons(ptVar3->tcphdr->_hdrlen_rsvd_flags);
        pcb->rto_end = (uint)((uVar4 & 3) != 0) + uVar5 + uVar2;
        pcb->rttest = 0;
        return '\0';
      }
      ptVar3 = ptVar3->next;
    } while (uVar1 == '\x01');
  }
  return -6;
}



err_t tcp_rexmit(tcp_pcb *pcb)

{
  tcp_seg *ptVar1;
  u32_t uVar2;
  u32_t uVar3;
  err_t eVar4;
  tcp_seg *ptVar5;
  
  ptVar1 = pcb->unacked;
  eVar4 = -6;
  if ((ptVar1 != (tcp_seg *)0x0) && (eVar4 = -6, ptVar1->p->ref == '\x01')) {
    ptVar5 = (tcp_seg *)&pcb->unsent;
    pcb->unacked = ptVar1->next;
    while (ptVar5->next != (tcp_seg *)0x0) {
      uVar2 = lwip_htonl(ptVar5->next->tcphdr->seqno);
      uVar3 = lwip_htonl(ptVar1->tcphdr->seqno);
      if (-1 < (int)(uVar2 - uVar3)) break;
      ptVar5 = ptVar5->next;
    }
    ptVar1->next = ptVar5->next;
    ptVar5->next = ptVar1;
    if (ptVar1->next == (tcp_seg *)0x0) {
      pcb->unsent_oversize = 0;
    }
    if (pcb->nrtx != -1) {
      pcb->nrtx = pcb->nrtx + '\x01';
    }
    pcb->rttest = 0;
    eVar4 = '\0';
  }
  return eVar4;
}



void tcp_rexmit_fast(tcp_pcb *pcb)

{
  err_t eVar1;
  undefined3 extraout_var;
  uint uVar2;
  uint uVar3;
  
  if (pcb->unacked != (tcp_seg *)0x0) {
    if (((pcb->flags & 4) == 0) && (eVar1 = tcp_rexmit(pcb), CONCAT31(extraout_var,eVar1) == 0)) {
      uVar3 = (uint)pcb->snd_wnd;
      if ((uint)pcb->cwnd < (uint)pcb->snd_wnd) {
        uVar3 = (uint)pcb->cwnd;
      }
      pcb->ssthresh = (tcpwnd_size_t)((int)uVar3 >> 1);
      uVar2 = (uint)pcb->mss << 1;
      if ((uint)((int)uVar3 >> 1) < uVar2) {
        pcb->ssthresh = (tcpwnd_size_t)uVar2;
      }
      pcb->rtime = 0;
      pcb->cwnd = pcb->mss * 3 + pcb->ssthresh;
      pcb->flags = pcb->flags | 4;
    }
    return;
  }
  return;
}



void tcp_rst(tcp_pcb *pcb,u32_t seqno,u32_t ackno,ip_addr_t *param_4,ip_addr_t *remote_ip,
            u16_t param_6,u16_t remote_port)

{
  u32_t seqno_be;
  pbuf *p;
  
  seqno_be = lwip_htonl(seqno);
  p = tcp_output_alloc_header_common(ackno,0,seqno_be,param_6,remote_port,'\x14',0x1008);
  if (p != (pbuf *)0x0) {
    tcp_output_control_segment(pcb,p,param_4,remote_ip);
    return;
  }
  return;
}



err_t tcp_send_empty_ack(tcp_pcb *pcb)

{
  err_t eVar1;
  u32_t seqno_be;
  pbuf *p;
  undefined3 extraout_var;
  tcpflags_t tVar2;
  
  seqno_be = lwip_htonl(pcb->snd_nxt);
  p = tcp_output_alloc_header(pcb,0,seqno_be);
  if (p == (pbuf *)0x0) {
    eVar1 = -2;
    pcb->flags = pcb->flags | 3;
  }
  else {
    eVar1 = tcp_output_control_segment(pcb,p,(ip_addr_t *)pcb,&pcb->remote_ip);
    if (CONCAT31(extraout_var,eVar1) == 0) {
      tVar2 = pcb->flags & 0xfffc;
    }
    else {
      tVar2 = pcb->flags | 3;
    }
    pcb->flags = tVar2;
  }
  return eVar1;
}



err_t tcp_output(tcp_pcb *pcb)

{
  ushort uVar1;
  ushort uVar2;
  bool bVar3;
  short sVar4;
  tcp_seg *ptVar5;
  tcp_seg *seg;
  err_t eVar6;
  u16_t proto_len;
  u16_t uVar7;
  netif *outif;
  u32_t uVar8;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  uint uVar9;
  undefined3 extraout_var;
  u32_t uVar10;
  tcp_hdr *ptVar11;
  pbuf *p;
  tcp_seg *ptVar12;
  tcp_seg *ptVar13;
  uint uVar14;
  ip4_addr_t *dest;
  
  if (tcp_input_pcb == pcb) {
    return '\0';
  }
  seg = pcb->unsent;
  if (seg == (tcp_seg *)0x0) {
    uVar1 = pcb->flags;
  }
  else {
    uVar1 = pcb->cwnd;
    uVar2 = pcb->snd_wnd;
    dest = (ip4_addr_t *)&pcb->remote_ip;
    if (pcb->netif_idx == '\0') {
      outif = ip4_route(dest);
    }
    else {
      outif = netif_get_by_index(pcb->netif_idx);
    }
    if (outif == (netif *)0x0) {
      return -4;
    }
    if ((pcb->local_ip).addr == 0) {
      (pcb->local_ip).addr = (outif->ip_addr).addr;
    }
    uVar14 = (uint)uVar1;
    if ((uint)uVar2 < (uint)uVar1) {
      uVar14 = (uint)uVar2;
    }
    uVar8 = lwip_htonl(seg->tcphdr->seqno);
    if (uVar8 + ((uint)seg->len - pcb->lastack) <= uVar14) {
      pcb->persist_backoff = '\0';
      ptVar12 = pcb->unacked;
      ptVar13 = pcb->unacked;
      while (ptVar5 = ptVar12, ptVar5 != (tcp_seg *)0x0) {
        ptVar12 = ptVar5->next;
        ptVar13 = ptVar5;
      }
      do {
        uVar8 = lwip_htonl(seg->tcphdr->seqno);
        if ((uVar14 < (uVar8 - pcb->lastack) + (uint)seg->len) ||
           (((((lwip_htons(seg->tcphdr->_hdrlen_rsvd_flags), pcb->unacked != (tcp_seg *)0x0 &&
               ((pcb->flags & 0x44) == 0)) &&
              ((ptVar12 = pcb->unsent, ptVar12 == (tcp_seg *)0x0 ||
               ((ptVar12->next == (tcp_seg *)0x0 && (ptVar12->len < pcb->mss)))))) &&
             (pcb->snd_buf != 0)) && ((pcb->snd_queuelen < 0x10 && ((pcb->flags & 0xa0) == 0)))))) {
          if (pcb->unsent != (tcp_seg *)0x0) goto output_done;
          break;
        }
        if (pcb->state != SYN_SENT) {
          uVar1 = seg->tcphdr->_hdrlen_rsvd_flags;
          proto_len = lwip_htons(0x10);
          ptVar11 = seg->tcphdr;
          uVar1 = proto_len | uVar1;
          *(char *)&ptVar11->_hdrlen_rsvd_flags = (char)uVar1;
          *(undefined *)((int)&ptVar11->_hdrlen_rsvd_flags + 1) = (char)((uint)uVar1 >> 8);
        }
        if (seg->p->ref == '\x01') {
          ptVar11 = seg->tcphdr;
          uVar8 = lwip_htonl(pcb->rcv_nxt);
          *(char *)&ptVar11->ackno = (char)uVar8;
          *(undefined *)((int)&ptVar11->ackno + 1) = (char)(uVar8 >> 8);
          *(undefined *)((int)&ptVar11->ackno + 2) = (char)(uVar8 >> 0x10);
          *(undefined *)((int)&ptVar11->ackno + 3) = (char)(uVar8 >> 0x18);
          ptVar11 = seg->tcphdr;
          proto_len = lwip_htons(pcb->rcv_ann_wnd);
          *(char *)&ptVar11->wnd = (char)proto_len;
          *(undefined *)((int)&ptVar11->wnd + 1) = (char)(proto_len >> 8);
          pcb->rcv_ann_right_edge = pcb->rcv_nxt + (uint)pcb->rcv_ann_wnd;
          if ((seg->flags & 1) != 0) {
            ptVar11 = seg->tcphdr;
            proto_len = tcp_eff_send_mss_netif(0x2b0,outif,(ip_addr_t *)dest);
            uVar8 = lwip_htonl(CONCAT22(extraout_var_00,proto_len) | 0x2040000);
            *(u32_t *)(ptVar11 + 1) = uVar8;
          }
          if (pcb->rtime < 0) {
            pcb->rtime = 0;
          }
          if (pcb->rttest == 0) {
            pcb->rttest = tcp_ticks;
            uVar8 = lwip_htonl(seg->tcphdr->seqno);
            pcb->rtseq = uVar8;
          }
          p = seg->p;
          sVar4 = (short)((uint)((int)((int)seg->tcphdr - (int)p->payload) * 0x10000) >> 0x10);
          p->len = p->len - sVar4;
          seg->p->tot_len = seg->p->tot_len - sVar4;
          ptVar11 = seg->tcphdr;
          *(tcp_hdr **)&seg->p->payload = ptVar11;
          *(undefined *)&ptVar11->chksum = 0;
          *(undefined *)((int)&ptVar11->chksum + 1) = 0;
          if ((seg->flags & 4) == 0) {
            lwip_htons(seg->tcphdr->_hdrlen_rsvd_flags);
          }
          p = seg->p;
          proto_len = p->tot_len;
          uVar7 = lwip_htons(seg->tcphdr->_hdrlen_rsvd_flags);
          proto_len = ip_chksum_pseudo_partial
                                (p,'\x06',proto_len,
                                 (ushort)(CONCAT22(extraout_var_01,uVar7) >> 10) & 0xfc,
                                 (ip4_addr_t *)pcb,dest);
          bVar3 = seg->chksum_swapped != '\0';
          if (bVar3) {
            seg->chksum_swapped = '\0';
            seg->chksum = seg->chksum >> 8 | seg->chksum << 8;
          }
          ptVar11 = seg->tcphdr;
          uVar9 = (uint)seg->chksum + (~(uint)proto_len & 0xffff);
          uVar9 = ~((uVar9 >> 0x10) + uVar9);
          *(char *)&ptVar11->chksum = (char)uVar9;
          *(undefined *)((int)&ptVar11->chksum + 1) = (char)(uVar9 >> 8);
          lwip_stats.tcp.xmit = lwip_stats.tcp.xmit + 1;
          eVar6 = ip4_output_if(seg->p,(ip4_addr_t *)pcb,dest,pcb->ttl,pcb->tos,'\x06',outif);
          if (bVar3) {
            seg->chksum_swapped = '\x01';
            seg->chksum = seg->chksum >> 8 | seg->chksum << 8;
          }
          if (CONCAT31(extraout_var,eVar6) != 0) {
            pcb->flags = pcb->flags | 0x80;
            return eVar6;
          }
        }
        pcb->unsent = seg->next;
        if (pcb->state != SYN_SENT) {
          pcb->flags = pcb->flags & 0xfffc;
        }
        uVar8 = lwip_htonl(seg->tcphdr->seqno);
        uVar1 = seg->len;
        proto_len = lwip_htons(seg->tcphdr->_hdrlen_rsvd_flags);
        uVar8 = (uint)((proto_len & 3) != 0) + uVar8 + uVar1;
        if ((int)(pcb->snd_nxt - uVar8) < 0) {
          pcb->snd_nxt = uVar8;
        }
        uVar1 = seg->len;
        proto_len = lwip_htons(seg->tcphdr->_hdrlen_rsvd_flags);
        if ((uint)((proto_len & 3) != 0) + (uint)uVar1 == 0) {
          tcp_seg_free(seg);
        }
        else {
          seg->next = (tcp_seg *)0x0;
          if (pcb->unacked == (tcp_seg *)0x0) {
            pcb->unacked = seg;
            ptVar13 = seg;
          }
          else {
            uVar8 = lwip_htonl(seg->tcphdr->seqno);
            uVar10 = lwip_htonl(ptVar13->tcphdr->seqno);
            ptVar12 = (tcp_seg *)&pcb->unacked;
            if ((int)(uVar8 - uVar10) < 0) {
              while (ptVar12->next != (tcp_seg *)0x0) {
                uVar8 = lwip_htonl(ptVar12->next->tcphdr->seqno);
                uVar10 = lwip_htonl(seg->tcphdr->seqno);
                if (-1 < (int)(uVar8 - uVar10)) break;
                ptVar12 = ptVar12->next;
              }
              seg->next = ptVar12->next;
              ptVar12->next = seg;
            }
            else {
              ptVar13->next = seg;
              ptVar13 = seg;
            }
          }
        }
        seg = pcb->unsent;
      } while (seg != (tcp_seg *)0x0);
      pcb->unsent_oversize = 0;
      goto output_done;
    }
    if ((((uint)pcb->snd_wnd == uVar14) && (pcb->unacked == (tcp_seg *)0x0)) &&
       (pcb->persist_backoff == '\0')) {
      *(undefined2 *)&pcb->persist_cnt = 0x100;
      pcb->persist_probe = '\0';
    }
    uVar1 = pcb->flags;
  }
  if ((uVar1 & 2) != 0) {
    eVar6 = tcp_send_empty_ack(pcb);
    return eVar6;
  }
output_done:
  pcb->flags = pcb->flags & 0xff7f;
  return '\0';
}



void tcp_rexmit_rto_commit(tcp_pcb *pcb)

{
  if (pcb->nrtx != -1) {
    pcb->nrtx = pcb->nrtx + '\x01';
  }
  tcp_output(pcb);
  return;
}



void tcp_rexmit_rto(tcp_pcb *pcb)

{
  err_t eVar1;
  undefined3 extraout_var;
  
  eVar1 = tcp_rexmit_rto_prepare(pcb);
  if (CONCAT31(extraout_var,eVar1) == 0) {
    tcp_rexmit_rto_commit(pcb);
    return;
  }
  return;
}



err_t tcp_keepalive(tcp_pcb *pcb)

{
  err_t eVar1;
  u32_t seqno_be;
  pbuf *p;
  
  seqno_be = lwip_htonl(pcb->snd_nxt - 1);
  p = tcp_output_alloc_header(pcb,0,seqno_be);
  if (p != (pbuf *)0x0) {
    eVar1 = tcp_output_control_segment(pcb,p,(ip_addr_t *)pcb,&pcb->remote_ip);
    return eVar1;
  }
  return -1;
}



err_t tcp_zero_window_probe(tcp_pcb *pcb)

{
  ushort uVar1;
  uint uVar2;
  err_t eVar3;
  u16_t uVar4;
  pbuf *p;
  u32_t uVar5;
  tcp_seg *ptVar6;
  void *pvVar7;
  
  ptVar6 = pcb->unsent;
  if (ptVar6 == (tcp_seg *)0x0) {
    eVar3 = '\0';
  }
  else {
    if (pcb->persist_probe != -1) {
      pcb->persist_probe = pcb->persist_probe + '\x01';
    }
    uVar2 = 0;
    uVar4 = lwip_htons(ptVar6->tcphdr->_hdrlen_rsvd_flags);
    if ((uVar4 & 1) != 0) {
      uVar2 = (uint)(ptVar6->len == 0);
    }
    p = tcp_output_alloc_header(pcb,(ushort)uVar2 ^ 1,ptVar6->tcphdr->seqno);
    if (p != (pbuf *)0x0) {
      pvVar7 = p->payload;
      if (uVar2 == 0) {
        pbuf_copy_partial(ptVar6->p,(void *)((int)pvVar7 + 0x14),1,
                          (u16_t)(((uint)ptVar6->p->tot_len - (uint)ptVar6->len) * 0x10000 >> 0x10))
        ;
      }
      else {
        uVar1 = *(ushort *)((int)pvVar7 + 0xc);
        uVar4 = lwip_htons(0x11);
        uVar2 = (int)(short)(uVar1 & 0xc0ff) | (uint)uVar4;
        *(undefined *)((int)pvVar7 + 0xc) = (char)uVar2;
        *(undefined *)((int)pvVar7 + 0xd) = (char)(uVar2 >> 8);
      }
      uVar5 = lwip_htonl(ptVar6->tcphdr->seqno);
      if ((int)(pcb->snd_nxt - (uVar5 + 1)) < 0) {
        pcb->snd_nxt = uVar5 + 1;
      }
      eVar3 = tcp_output_control_segment(pcb,p,(ip_addr_t *)pcb,&pcb->remote_ip);
      return eVar3;
    }
    eVar3 = -1;
  }
  return eVar3;
}



void sys_timeout_abs(u32_t abs_time,sys_timeout_handler *handler,void *arg)

{
  sys_timeo *psVar1;
  sys_timeo *psVar2;
  sys_timeo *psVar3;
  
  psVar1 = (sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
  psVar2 = next_timeout;
  psVar3 = next_timeout;
  if (psVar1 != (sys_timeo *)0x0) {
    psVar1->next = (sys_timeo *)0x0;
    psVar1->h = handler;
    psVar1->arg = arg;
    psVar1->time = abs_time;
    psVar3 = psVar1;
    if (psVar2 != (sys_timeo *)0x0) {
      if ((int)(abs_time - psVar2->time) < 0) {
        psVar1->next = psVar2;
      }
      else {
        do {
          psVar3 = psVar2;
          psVar2 = psVar3->next;
          if (psVar2 == (sys_timeo *)0x0) break;
        } while (-1 < (int)(abs_time - psVar2->time));
        psVar1->next = psVar2;
        psVar3->next = psVar1;
        psVar3 = next_timeout;
      }
    }
  }
  next_timeout = psVar3;
  return;
}



void lwip_cyclic_timer(void *arg)

{
  TickType_t TVar1;
  u32_t abs_time;
  u32_t uVar2;
  
  (**(code **)((int)arg + 4))(*(code **)((int)arg + 4));
  TVar1 = sys_now();
  uVar2 = current_timeout_due_time + *(int *)arg;
  abs_time = TVar1 + *(int *)arg;
  if (-1 < (int)(uVar2 - TVar1)) {
    abs_time = uVar2;
  }
  sys_timeout_abs(abs_time,lwip_cyclic_timer,arg);
  return;
}



void sys_timeout(u32_t msecs,sys_timeout_handler *handler,void *arg)

{
  TickType_t TVar1;
  
  TVar1 = sys_now();
  sys_timeout_abs(TVar1 + msecs,handler,arg);
  return;
}



void tcp_timer_needed(void)

{
  if ((tcpip_tcp_timer_active == 0) &&
     ((tcp_active_pcbs != (tcp_pcb *)0x0 || (tcp_tw_pcbs != (tcp_pcb *)0x0)))) {
    tcpip_tcp_timer_active = 1;
    sys_timeout(0xfa,tcpip_tcp_timer,(void *)0x0);
    return;
  }
  return;
}



void tcpip_tcp_timer(void *arg)

{
  tcp_tmr();
  if ((tcp_active_pcbs == (tcp_pcb *)0x0) && (tcp_tw_pcbs == (tcp_pcb *)0x0)) {
    tcpip_tcp_timer_active = 0;
    return;
  }
  sys_timeout(0xfa,tcpip_tcp_timer,(void *)0x0);
  return;
}



void sys_timeouts_init(void)

{
  u32_t *arg;
  u32_t *puVar1;
  
  arg = &DAT_23086494;
  do {
    puVar1 = arg + 2;
    sys_timeout(*arg,lwip_cyclic_timer,arg);
    arg = puVar1;
  } while (puVar1 != (u32_t *)CSWTCH_13);
  return;
}



void sys_untimeout(sys_timeout_handler *handler,void *arg)

{
  sys_timeo *psVar1;
  sys_timeo *psVar2;
  sys_timeo *mem;
  
  psVar1 = (sys_timeo *)0x0;
  mem = next_timeout;
  if (next_timeout != (sys_timeo *)0x0) {
    do {
      psVar2 = mem->next;
      if ((mem->h == handler) && (mem->arg == arg)) {
        if (psVar1 != (sys_timeo *)0x0) {
          psVar1->next = psVar2;
          psVar2 = next_timeout;
        }
        next_timeout = psVar2;
        memp_free(MEMP_SYS_TIMEOUT,mem);
        return;
      }
      psVar1 = mem;
      mem = psVar2;
    } while (psVar2 != (sys_timeo *)0x0);
  }
  return;
}



void sys_check_timeouts(void)

{
  sys_timeo *mem;
  sys_timeout_handler *psVar1;
  void *pvVar2;
  TickType_t TVar3;
  
  TVar3 = sys_now();
  while ((mem = next_timeout, next_timeout != (sys_timeo *)0x0 &&
         (-1 < (int)(TVar3 - next_timeout->time)))) {
    psVar1 = next_timeout->h;
    pvVar2 = next_timeout->arg;
    current_timeout_due_time = next_timeout->time;
    next_timeout = next_timeout->next;
    memp_free(MEMP_SYS_TIMEOUT,mem);
    if (psVar1 != (sys_timeout_handler *)0x0) {
      (*psVar1)(pvVar2);
    }
  }
  return;
}



u32_t sys_timeouts_sleeptime(void)

{
  u32_t uVar1;
  TickType_t TVar2;
  
  uVar1 = 0xffffffff;
  if (next_timeout != (sys_timeo *)0x0) {
    TVar2 = sys_now();
    uVar1 = next_timeout->time - TVar2;
    if ((int)uVar1 < 0) {
      uVar1 = 0;
    }
  }
  return uVar1;
}



void udp_init(void)

{
  int iVar1;
  
  iVar1 = bl_rand();
  udp_port = (ushort)((uint)(iVar1 << 0x12) >> 0x12) + 0xc000;
  return;
}



void udp_input(pbuf *p,netif *inp)

{
  udp_pcb *puVar1;
  udp_pcb *puVar2;
  u8_t uVar3;
  u16_t uVar4;
  u16_t uVar5;
  undefined3 extraout_var;
  undefined2 extraout_var_01;
  undefined2 extraout_var_02;
  undefined2 extraout_var_03;
  undefined3 extraout_var_00;
  u32_t uVar6;
  uint uVar7;
  udp_pcb *puVar8;
  udp_pcb *puVar9;
  udp_pcb *puVar10;
  u16_t *puVar11;
  
  lwip_stats.udp.recv = lwip_stats.udp.recv + 1;
  if (p->len < 8) {
    lwip_stats.udp.lenerr = lwip_stats.udp.lenerr + 1;
    lwip_stats.udp.drop = lwip_stats.udp.drop + 1;
  }
  else {
    puVar11 = (u16_t *)p->payload;
    uVar3 = ip4_addr_isbroadcast_u32(ip_data.current_iphdr_dest,ip_data.current_netif);
    _uVar3 = CONCAT31(extraout_var,uVar3);
    uVar4 = lwip_htons(*puVar11);
    uVar5 = lwip_htons(puVar11[1]);
    puVar1 = udp_pcbs;
    puVar9 = (udp_pcb *)0x0;
    puVar2 = udp_pcbs;
    puVar8 = (udp_pcb *)0x0;
    while (puVar10 = puVar2, puVar10 != (udp_pcb *)0x0) {
      if (((uint)puVar10->local_port == CONCAT22(extraout_var_02,uVar5)) &&
         ((puVar10->netif_idx == '\0' ||
          (puVar10->netif_idx == (u8_t)((ip_data.current_input_netif)->num + '\x01'))))) {
        uVar7 = (puVar10->local_ip).addr;
        if (_uVar3 == 0) {
          if ((uVar7 == 0) || (uVar7 == ip_data.current_iphdr_dest)) goto LAB_230454fc;
        }
        else {
          if ((uVar7 == 0) ||
             ((ip_data.current_iphdr_dest == 0xffffffff ||
              (((uVar7 ^ ip_data.current_iphdr_dest) & (inp->netmask).addr) == 0)))) {
LAB_230454fc:
            if ((puVar10->flags & 4) != 0) goto LAB_23045532;
            if (puVar9 == (udp_pcb *)0x0) {
LAB_23045520:
              puVar9 = puVar10;
            }
            else {
              if ((_uVar3 == 0) || (ip_data.current_iphdr_dest != 0xffffffff)) {
                if (uVar7 != 0) goto LAB_23045520;
              }
              else {
                uVar6 = (inp->ip_addr).addr;
                if (((puVar9->local_ip).addr != uVar6) && (uVar6 == uVar7)) goto LAB_23045520;
              }
            }
LAB_23045532:
            if (((uint)puVar10->remote_port == CONCAT22(extraout_var_01,uVar4)) &&
               ((uVar6 = (puVar10->remote_ip).addr, uVar6 == 0 ||
                (uVar6 == ip_data.current_iphdr_src)))) {
              if (puVar8 == (udp_pcb *)0x0) {
                lwip_stats.udp.cachehit = lwip_stats.udp.cachehit + 1;
              }
              else {
                udp_pcbs = puVar10;
                puVar8->next = puVar10->next;
                puVar10->next = puVar1;
              }
              goto LAB_23045556;
            }
          }
        }
      }
      puVar2 = puVar10->next;
      puVar8 = puVar10;
    }
    puVar10 = puVar9;
    if ((puVar9 != (udp_pcb *)0x0) || ((inp->ip_addr).addr == ip_data.current_iphdr_dest)) {
LAB_23045556:
      if ((puVar11[3] == 0) ||
         (uVar5 = ip_chksum_pseudo(p,'\x11',p->tot_len,(ip4_addr_t *)&ip_data.current_iphdr_src,
                                   (ip4_addr_t *)&ip_data.current_iphdr_dest),
         CONCAT22(extraout_var_03,uVar5) == 0)) {
        uVar3 = pbuf_remove_header(p,8);
        if (CONCAT31(extraout_var_00,uVar3) == 0) {
          if (puVar10 != (udp_pcb *)0x0) {
            if (puVar10->recv != (udp_recv_fn *)0x0) {
                    // WARNING: Could not recover jumptable at 0x230455e0. Too many branches
                    // WARNING: Treating indirect jump as call
              (*puVar10->recv)(puVar10->recv_arg,puVar10,p,(ip_addr_t *)0x4201fed0,uVar4);
              return;
            }
            goto LAB_23045438;
          }
          if ((_uVar3 == 0) && ((ip_data.current_iphdr_dest & 0xf0) != 0xe0)) {
            pbuf_header_force(p,(s16_t)(((uint)ip_data.current_ip_header_tot_len + 8) * 0x10000 >>
                                       0x10));
            icmp_dest_unreach(p,ICMP_DUR_PORT);
          }
          lwip_stats.udp.proterr = lwip_stats.udp.proterr + 1;
        }
      }
      else {
        lwip_stats.udp.chkerr = lwip_stats.udp.chkerr + 1;
      }
      lwip_stats.udp.drop = lwip_stats.udp.drop + 1;
    }
  }
LAB_23045438:
  pbuf_free(p);
  return;
}



err_t udp_bind(udp_pcb *pcb,ip_addr_t *ipaddr,u16_t port)

{
  bool bVar1;
  err_t eVar2;
  undefined2 in_register_00002032;
  u32_t uVar3;
  udp_pcb *puVar4;
  short sVar5;
  
  if (ipaddr == (ip_addr_t *)0x0) {
    ipaddr = &ip_addr_any;
  }
  eVar2 = -0x10;
  puVar4 = udp_pcbs;
  if (pcb != (udp_pcb *)0x0) {
    while (puVar4 != (udp_pcb *)0x0) {
      if (puVar4 == pcb) {
        bVar1 = true;
        goto LAB_23045638;
      }
      puVar4 = puVar4->next;
    }
    bVar1 = false;
LAB_23045638:
    puVar4 = udp_pcbs;
    if (CONCAT22(in_register_00002032,port) == 0) {
      sVar5 = 0x4000;
      do {
        puVar4 = udp_pcbs;
        if (udp_port == 0xffff) {
          port = 0xc000;
        }
        else {
          port = udp_port + 1;
        }
        while( true ) {
          udp_port = port;
          if (puVar4 == (udp_pcb *)0x0) goto LAB_23045660;
          if (puVar4->local_port == port) break;
          puVar4 = puVar4->next;
        }
        sVar5 = sVar5 + -1;
        if (sVar5 == 0) {
          return -8;
        }
      } while( true );
    }
    while (puVar4 != (udp_pcb *)0x0) {
      if ((puVar4 != pcb) &&
         ((((pcb->so_options & 4) == 0 || ((puVar4->so_options & 4) == 0)) &&
          ((uint)puVar4->local_port == CONCAT22(in_register_00002032,port))))) {
        uVar3 = (puVar4->local_ip).addr;
        if (uVar3 == ipaddr->addr) {
          return -8;
        }
        if (ipaddr->addr == 0) {
          return -8;
        }
        if (uVar3 == 0) {
          return -8;
        }
      }
      puVar4 = puVar4->next;
    }
LAB_23045660:
    uVar3 = ipaddr->addr;
    pcb->local_port = port;
    (pcb->local_ip).addr = uVar3;
    if (!bVar1) {
      puVar4 = pcb;
      pcb->next = udp_pcbs;
      udp_pcbs = puVar4;
    }
    eVar2 = '\0';
  }
  return eVar2;
}



err_t udp_sendto_if_src_chksum
                (udp_pcb *pcb,pbuf *p,ip_addr_t *dst_ip,u16_t dst_port,netif *netif,u8_t have_chksum
                ,u16_t chksum,ip_addr_t *src_ip)

{
  u8_t ttl;
  err_t eVar1;
  u16_t uVar2;
  undefined2 uVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  pbuf *h;
  undefined2 extraout_var_01;
  uint uVar4;
  undefined2 extraout_var_02;
  undefined3 in_register_0000203d;
  undefined *puVar5;
  
  if (pcb == (udp_pcb *)0x0) {
    return -0x10;
  }
  if (p == (pbuf *)0x0) {
    return -0x10;
  }
  if (dst_ip == (ip_addr_t *)0x0) {
    return -0x10;
  }
  if (src_ip == (ip_addr_t *)0x0) {
    return -0x10;
  }
  if (netif == (netif *)0x0) {
    return -0x10;
  }
  if ((pcb->local_port == 0) &&
     (eVar1 = udp_bind(pcb,(ip_addr_t *)pcb,0), CONCAT31(extraout_var,eVar1) != 0)) {
    return eVar1;
  }
  if (p->tot_len < 0xfff8) {
    ttl = pbuf_add_header(p,8);
    h = p;
    if (CONCAT31(extraout_var_00,ttl) != 0) {
      h = pbuf_alloc(PBUF_IP,8,PBUF_RAM);
      if (h == (pbuf *)0x0) goto LAB_23045726;
      if (p->tot_len != 0) {
        pbuf_chain(h,p);
      }
    }
    puVar5 = (undefined *)h->payload;
    uVar2 = lwip_htons(pcb->local_port);
    *puVar5 = (char)uVar2;
    puVar5[1] = (char)(uVar2 >> 8);
    uVar2 = lwip_htons(dst_port);
    puVar5[2] = (char)uVar2;
    puVar5[3] = (char)(uVar2 >> 8);
    puVar5[6] = 0;
    puVar5[7] = 0;
    if (((pcb->flags & 8) != 0) && ((dst_ip->addr & 0xf0) == 0xe0)) {
      h->flags = h->flags | 4;
    }
    uVar2 = lwip_htons(h->tot_len);
    puVar5[4] = (char)uVar2;
    puVar5[5] = (char)(uVar2 >> 8);
    if ((pcb->flags & 1) == 0) {
      if (CONCAT31(in_register_0000203d,have_chksum) == 0) {
        uVar2 = ip_chksum_pseudo(h,'\x11',h->tot_len,(ip4_addr_t *)src_ip,(ip4_addr_t *)dst_ip);
        uVar4 = CONCAT22(extraout_var_02,uVar2);
      }
      else {
        uVar2 = ip_chksum_pseudo_partial
                          (h,'\x11',h->tot_len,8,(ip4_addr_t *)src_ip,(ip4_addr_t *)dst_ip);
        uVar4 = CONCAT22(extraout_var_01,uVar2) + (~(uint)chksum & 0xffff);
        uVar4 = uVar4 + (uVar4 >> 0x10) & 0xffff;
      }
      uVar3 = (undefined2)uVar4;
      if (uVar4 == 0) {
        uVar3 = 0xffff;
      }
      puVar5[6] = (char)uVar3;
      puVar5[7] = (char)((ushort)uVar3 >> 8);
    }
    if ((dst_ip->addr & 0xf0) == 0xe0) {
      ttl = pcb->mcast_ttl;
    }
    else {
      ttl = pcb->ttl;
    }
    eVar1 = ip4_output_if_src(h,(ip4_addr_t *)src_ip,(ip4_addr_t *)dst_ip,ttl,pcb->tos,'\x11',netif)
    ;
    if (h != p) {
      pbuf_free(h);
    }
    lwip_stats.udp.xmit = lwip_stats.udp.xmit + 1;
  }
  else {
LAB_23045726:
    eVar1 = -1;
  }
  return eVar1;
}



err_t udp_sendto_if_chksum
                (udp_pcb *pcb,pbuf *p,ip_addr_t *dst_ip,u16_t dst_port,netif *netif,u8_t have_chksum
                ,u16_t chksum)

{
  err_t eVar1;
  uint uVar2;
  udp_pcb *src_ip;
  
  if ((((pcb != (udp_pcb *)0x0) && (p != (pbuf *)0x0)) && (dst_ip != (ip_addr_t *)0x0)) &&
     (netif != (netif *)0x0)) {
    uVar2 = (pcb->local_ip).addr;
    if ((uVar2 == 0) || ((uVar2 & 0xf0) == 0xe0)) {
      src_ip = (udp_pcb *)&netif->ip_addr;
    }
    else {
      src_ip = pcb;
      if (uVar2 != (netif->ip_addr).addr) {
        return -4;
      }
    }
    eVar1 = udp_sendto_if_src_chksum
                      (pcb,p,dst_ip,dst_port,netif,have_chksum,chksum,(ip_addr_t *)src_ip);
    return eVar1;
  }
  return -0x10;
}



err_t udp_sendto_chksum(udp_pcb *pcb,pbuf *p,ip_addr_t *dst_ip,u16_t dst_port,u8_t have_chksum,
                       u16_t chksum)

{
  err_t eVar1;
  netif *netif;
  u32_t uVar2;
  
  if (((pcb == (udp_pcb *)0x0) || (p == (pbuf *)0x0)) || (dst_ip == (ip_addr_t *)0x0)) {
    return -0x10;
  }
  if (pcb->netif_idx == '\0') {
    if ((dst_ip->addr & 0xf0) == 0xe0) {
      if (pcb->mcast_ifindex == '\0') {
        uVar2 = (pcb->mcast_ip4).addr;
        if ((uVar2 == 0) || (uVar2 == 0xffffffff)) goto LAB_2304591a;
        netif = ip4_route(&pcb->mcast_ip4);
      }
      else {
        netif = netif_get_by_index(pcb->mcast_ifindex);
      }
      if (netif != (netif *)0x0) goto LAB_2304592e;
    }
LAB_2304591a:
    netif = ip4_route((ip4_addr_t *)dst_ip);
  }
  else {
    netif = netif_get_by_index(pcb->netif_idx);
  }
  if (netif == (netif *)0x0) {
    lwip_stats.udp.rterr = lwip_stats.udp.rterr + 1;
    return -4;
  }
LAB_2304592e:
  eVar1 = udp_sendto_if_chksum(pcb,p,dst_ip,dst_port,netif,have_chksum,chksum);
  return eVar1;
}



err_t udp_send_chksum(udp_pcb *pcb,pbuf *p,u8_t have_chksum,u16_t chksum)

{
  err_t eVar1;
  
  if ((pcb != (udp_pcb *)0x0) && (p != (pbuf *)0x0)) {
    eVar1 = udp_sendto_chksum(pcb,p,&pcb->remote_ip,pcb->remote_port,have_chksum,chksum);
    return eVar1;
  }
  return -0x10;
}



err_t udp_sendto(udp_pcb *pcb,pbuf *p,ip_addr_t *dst_ip,u16_t dst_port)

{
  err_t eVar1;
  
  eVar1 = udp_sendto_chksum(pcb,p,dst_ip,dst_port,'\0',0);
  return eVar1;
}



err_t udp_sendto_if(udp_pcb *pcb,pbuf *p,ip_addr_t *dst_ip,u16_t dst_port,netif *netif)

{
  err_t eVar1;
  
  eVar1 = udp_sendto_if_chksum(pcb,p,dst_ip,dst_port,netif,'\0',0);
  return eVar1;
}



err_t udp_sendto_if_src(udp_pcb *pcb,pbuf *p,ip_addr_t *dst_ip,u16_t dst_port,netif *netif,
                       ip_addr_t *src_ip)

{
  err_t eVar1;
  
  eVar1 = udp_sendto_if_src_chksum(pcb,p,dst_ip,dst_port,netif,'\0',0,src_ip);
  return eVar1;
}



void udp_bind_netif(udp_pcb *pcb,netif *netif)

{
  u8_t uVar1;
  
  uVar1 = '\0';
  if (netif != (netif *)0x0) {
    uVar1 = netif->num + '\x01';
  }
  pcb->netif_idx = uVar1;
  return;
}



err_t udp_connect(udp_pcb *pcb,ip_addr_t *ipaddr,u16_t port)

{
  err_t eVar1;
  undefined3 extraout_var;
  udp_pcb *puVar2;
  u32_t uVar3;
  
  if ((pcb == (udp_pcb *)0x0) || (ipaddr == (ip_addr_t *)0x0)) {
    return -0x10;
  }
  if ((pcb->local_port != 0) ||
     (eVar1 = udp_bind(pcb,(ip_addr_t *)pcb,0), CONCAT31(extraout_var,eVar1) == 0)) {
    uVar3 = ipaddr->addr;
    pcb->remote_port = port;
    (pcb->remote_ip).addr = uVar3;
    pcb->flags = pcb->flags | 4;
    puVar2 = udp_pcbs;
    while (puVar2 != (udp_pcb *)0x0) {
      if (puVar2 == pcb) goto LAB_230459f6;
      puVar2 = puVar2->next;
    }
    pcb->next = udp_pcbs;
    udp_pcbs = pcb;
LAB_230459f6:
    eVar1 = '\0';
  }
  return eVar1;
}



void udp_disconnect(udp_pcb *pcb)

{
  byte bVar1;
  
  if (pcb != (udp_pcb *)0x0) {
    bVar1 = pcb->flags;
    (pcb->remote_ip).addr = 0;
    pcb->remote_port = 0;
    pcb->netif_idx = '\0';
    pcb->flags = bVar1 & 0xfb;
  }
  return;
}



void udp_recv(udp_pcb *pcb,udp_recv_fn *recv,void *recv_arg)

{
  if (pcb != (udp_pcb *)0x0) {
    pcb->recv = recv;
    pcb->recv_arg = recv_arg;
  }
  return;
}



void udp_remove(udp_pcb *pcb)

{
  udp_pcb *puVar1;
  udp_pcb *puVar2;
  
  if (pcb == (udp_pcb *)0x0) {
    return;
  }
  puVar1 = udp_pcbs;
  if (udp_pcbs == pcb) {
    udp_pcbs = pcb->next;
  }
  else {
    do {
      puVar2 = puVar1;
      if ((puVar2 == (udp_pcb *)0x0) || (puVar1 = puVar2->next, puVar1 == (udp_pcb *)0x0))
      goto LAB_23045a58;
    } while (puVar1 != pcb);
    puVar2->next = pcb->next;
  }
LAB_23045a58:
  memp_free(MEMP_UDP_PCB,pcb);
  return;
}



udp_pcb * udp_new(void)

{
  udp_pcb *__s;
  
  __s = (udp_pcb *)memp_malloc(MEMP_UDP_PCB);
  if (__s != (udp_pcb *)0x0) {
    memset(__s,0,0x28);
    __s->ttl = -1;
    __s->mcast_ttl = -1;
  }
  return __s;
}



udp_pcb * udp_new_ip_type(void)

{
  udp_pcb *__s;
  
  __s = (udp_pcb *)memp_malloc(MEMP_UDP_PCB);
  if (__s != (udp_pcb *)0x0) {
    memset(__s,0,0x28);
    __s->ttl = -1;
    __s->mcast_ttl = -1;
  }
  return __s;
}



void udp_netif_ip_addr_changed(ip_addr_t *old_addr,ip_addr_t *new_addr)

{
  udp_pcb *puVar1;
  
  if ((((old_addr != (ip_addr_t *)0x0) && (old_addr->addr != 0)) && (new_addr != (ip_addr_t *)0x0))
     && (puVar1 = udp_pcbs, new_addr->addr != 0)) {
    while (puVar1 != (udp_pcb *)0x0) {
      if ((puVar1->local_ip).addr == old_addr->addr) {
        (puVar1->local_ip).addr = new_addr->addr;
      }
      puVar1 = puVar1->next;
    }
  }
  return;
}



udp_pcb * udp_get_pcbs(void)

{
  return udp_pcbs;
}



err_t ethernet_input(pbuf *p,netif *netif)

{
  short sVar1;
  u8_t uVar2;
  byte *__s1;
  undefined3 extraout_var;
  int iVar3;
  undefined3 extraout_var_00;
  byte bVar4;
  
  if (p->len < 0xf) {
LAB_23045aec:
    lwip_stats.etharp.proterr = lwip_stats.etharp.proterr + 1;
  }
  else {
    if (p->if_idx == '\0') {
      p->if_idx = netif->num + '\x01';
    }
    __s1 = (byte *)p->payload;
    sVar1 = *(short *)(__s1 + 0xc);
    if ((*__s1 & 1) != 0) {
      if (*__s1 == 1) {
        if ((__s1[1] == 0) && (__s1[2] == 0x5e)) {
          bVar4 = p->flags | 0x10;
LAB_23045b4a:
          p->flags = bVar4;
        }
      }
      else {
        iVar3 = memcmp(__s1,&ethbroadcast,6);
        if (iVar3 == 0) {
          bVar4 = p->flags | 8;
          goto LAB_23045b4a;
        }
      }
    }
    if (sVar1 == 8) {
      if (((netif->flags & 8) != 0) &&
         (uVar2 = pbuf_remove_header(p,0xe), CONCAT31(extraout_var_00,uVar2) == 0)) {
        ip4_input(p,netif);
        return '\0';
      }
      goto free_and_return;
    }
    if (sVar1 != 0x608) goto LAB_23045aec;
    if ((netif->flags & 8) == 0) goto free_and_return;
    uVar2 = pbuf_remove_header(p,0xe);
    if (CONCAT31(extraout_var,uVar2) == 0) {
      etharp_input(p,netif);
      return '\0';
    }
    lwip_stats.etharp.lenerr = lwip_stats.etharp.lenerr + 1;
  }
  lwip_stats.etharp.drop = lwip_stats.etharp.drop + 1;
free_and_return:
  pbuf_free(p);
  return '\0';
}



err_t ethernet_output(netif *netif,pbuf *p,eth_addr *src,eth_addr *dst,u16_t eth_type)

{
  void *__dest;
  u8_t uVar1;
  err_t eVar2;
  u16_t uVar3;
  undefined3 extraout_var;
  
  uVar3 = lwip_htons(eth_type);
  uVar1 = pbuf_add_header(p,0xe);
  if (CONCAT31(extraout_var,uVar1) == 0) {
    __dest = p->payload;
    *(undefined *)((int)__dest + 0xc) = (char)uVar3;
    *(undefined *)((int)__dest + 0xd) = (char)(uVar3 >> 8);
    memcpy(__dest,dst,6);
    memcpy((void *)((int)__dest + 6),src,6);
                    // WARNING: Could not recover jumptable at 0x23045c42. Too many branches
                    // WARNING: Treating indirect jump as call
    eVar2 = (*netif->linkoutput)(netif,p);
    return eVar2;
  }
  lwip_stats.link.lenerr = lwip_stats.link.lenerr + 1;
  return -2;
}



err_t netconn_apimsg(tcpip_callback_fn_conflict *fn,api_msg *apimsg)

{
  err_t eVar1;
  undefined3 extraout_var;
  
  eVar1 = tcpip_send_msg_wait_sem((tcpip_callback_fn)fn,apimsg,&apimsg->conn->op_completed);
  if (CONCAT31(extraout_var,eVar1) == 0) {
    eVar1 = apimsg->err;
  }
  return eVar1;
}



// WARNING: Could not reconcile some variable overlaps

err_t netconn_close_shutdown(netconn *conn,u8_t how)

{
  err_t eVar1;
  netconn *pnStack52;
  api_msg msg;
  
  if (conn != (netconn *)0x0) {
    pnStack52 = conn;
    msg.err = how;
    msg.msg._0_4_ = sys_now();
    eVar1 = netconn_apimsg(lwip_netconn_do_close,(api_msg *)&pnStack52);
    return eVar1;
  }
  return -0x10;
}



// WARNING: Variable defined which should be unmapped: msg

netconn * netconn_new_with_proto_and_callback(netconn_type t,u8_t proto,netconn_callback *callback)

{
  err_t eVar1;
  netconn *mem;
  undefined3 extraout_var;
  netconn *pnStack52;
  api_msg msg;
  
  mem = netconn_alloc(t,callback);
  if (mem != (netconn *)0x0) {
    pnStack52 = mem;
    msg.err = proto;
    eVar1 = netconn_apimsg(lwip_netconn_do_newconn,(api_msg *)&pnStack52);
    if (CONCAT31(extraout_var,eVar1) != 0) {
      sys_mbox_valid(&mem->recvmbox);
      sys_mbox_valid(&mem->acceptmbox);
      sys_sem_valid(&mem->op_completed);
      sys_sem_free(&mem->op_completed);
      sys_mbox_free(&mem->recvmbox);
      memp_free(MEMP_NETCONN,mem);
      mem = (netconn *)0x0;
    }
  }
  return mem;
}



// WARNING: Could not reconcile some variable overlaps

err_t netconn_prepare_delete(netconn *conn)

{
  err_t eVar1;
  netconn *pnStack52;
  api_msg msg;
  
  if (conn != (netconn *)0x0) {
    pnStack52 = conn;
    msg.msg._0_4_ = sys_now();
    eVar1 = netconn_apimsg(lwip_netconn_do_delconn,(api_msg *)&pnStack52);
    return eVar1;
  }
  return '\0';
}



err_t netconn_delete(netconn *conn)

{
  err_t eVar1;
  undefined3 extraout_var;
  
  eVar1 = '\0';
  if ((conn != (netconn *)0x0) &&
     (eVar1 = netconn_prepare_delete(conn), CONCAT31(extraout_var,eVar1) == 0)) {
    netconn_free(conn);
  }
  return eVar1;
}



// WARNING: Could not reconcile some variable overlaps

err_t netconn_getaddr(netconn *conn,ip_addr_t *addr,u16_t *port,u8_t local)

{
  err_t eVar1;
  netconn *pnStack52;
  api_msg msg;
  
  if (conn == (netconn *)0x0) {
    return -0x10;
  }
  if ((addr != (ip_addr_t *)0x0) && (port != (u16_t *)0x0)) {
    pnStack52 = conn;
    msg._4_4_ = addr;
    msg.msg._0_4_ = port;
    msg.msg[4] = local;
    eVar1 = netconn_apimsg(lwip_netconn_do_getaddr,(api_msg *)&pnStack52);
    return eVar1;
  }
  return -0x10;
}



// WARNING: Could not reconcile some variable overlaps

err_t netconn_bind(netconn *conn,ip_addr_t *addr,u16_t port)

{
  err_t eVar1;
  netconn *pnStack52;
  api_msg msg;
  
  if (conn != (netconn *)0x0) {
    if (addr == (ip_addr_t *)0x0) {
      addr = &ip_addr_any;
    }
    pnStack52 = conn;
    msg._4_4_ = addr;
    msg.msg._0_2_ = port;
    eVar1 = netconn_apimsg(lwip_netconn_do_bind,(api_msg *)&pnStack52);
    return eVar1;
  }
  return -0x10;
}



// WARNING: Could not reconcile some variable overlaps

err_t netconn_connect(netconn *conn,ip_addr_t *addr,u16_t port)

{
  err_t eVar1;
  netconn *pnStack52;
  api_msg msg;
  
  if (conn != (netconn *)0x0) {
    if (addr == (ip_addr_t *)0x0) {
      addr = &ip_addr_any;
    }
    pnStack52 = conn;
    msg._4_4_ = addr;
    msg.msg._0_2_ = port;
    eVar1 = netconn_apimsg(lwip_netconn_do_connect,(api_msg *)&pnStack52);
    return eVar1;
  }
  return -0x10;
}



err_t netconn_disconnect(netconn *conn)

{
  err_t eVar1;
  netconn *pnStack52;
  api_msg msg;
  
  if (conn != (netconn *)0x0) {
    pnStack52 = conn;
    eVar1 = netconn_apimsg(lwip_netconn_do_disconnect,(api_msg *)&pnStack52);
    return eVar1;
  }
  return -0x10;
}



err_t netconn_listen_with_backlog(netconn *conn,u8_t backlog)

{
  err_t eVar1;
  netconn *pnStack52;
  api_msg msg;
  
  if (conn != (netconn *)0x0) {
    pnStack52 = conn;
    eVar1 = netconn_apimsg(lwip_netconn_do_listen,(api_msg *)&pnStack52);
    return eVar1;
  }
  return -0x10;
}



// WARNING: Could not reconcile some variable overlaps

err_t netconn_tcp_recvd(netconn *conn,size_t len)

{
  err_t eVar1;
  netconn *pnStack52;
  api_msg msg;
  
  if (conn == (netconn *)0x0) {
    return -0x10;
  }
  if ((conn->type & 0xf0) == NETCONN_TCP) {
    pnStack52 = conn;
    msg._4_4_ = len;
    eVar1 = netconn_apimsg(lwip_netconn_do_recv,(api_msg *)&pnStack52);
    return eVar1;
  }
  return -0x10;
}



// WARNING: Could not reconcile some variable overlaps

err_t netconn_send(netconn *conn,netbuf *buf)

{
  err_t eVar1;
  netconn *pnStack52;
  api_msg msg;
  
  if (conn != (netconn *)0x0) {
    pnStack52 = conn;
    msg._4_4_ = buf;
    eVar1 = netconn_apimsg(lwip_netconn_do_send,(api_msg *)&pnStack52);
    return eVar1;
  }
  return -0x10;
}



// WARNING: Could not reconcile some variable overlaps

err_t netconn_write_vectors_partly
                (netconn *conn,netvector *vectors,u16_t vectorcnt,u8_t apiflags,
                size_t *bytes_written)

{
  err_t eVar1;
  int iVar2;
  undefined3 extraout_var;
  undefined2 in_register_00002032;
  size_t *psVar3;
  uint uVar4;
  netconn *pnStack52;
  api_msg msg;
  
  if (conn == (netconn *)0x0) {
    return -0x10;
  }
  eVar1 = -6;
  if ((conn->type & 0xf0) == NETCONN_TCP) {
    if ((((uint)((conn->flags & 2 | apiflags & 4) != 0) | conn->send_timeout) != 0) &&
       (bytes_written == (size_t *)0x0)) {
      return -6;
    }
    psVar3 = &vectors->len;
    iVar2 = 0;
    msg.msg._8_4_ = 0;
    while (iVar2 < CONCAT22(in_register_00002032,vectorcnt)) {
      uVar4 = *psVar3;
      psVar3 = psVar3 + 2;
      msg.msg._8_4_ = msg.msg._8_4_ + uVar4;
      if (msg.msg._8_4_ < uVar4) {
        return -6;
      }
      iVar2 = iVar2 + 1;
    }
    if (msg.msg._8_4_ != 0) {
      if ((int)msg.msg._8_4_ < 0) {
        if (bytes_written == (size_t *)0x0) {
          return -6;
        }
        msg.msg._8_4_ = 0x7fffffff;
      }
      msg.msg._4_4_ = 0;
      msg.msg._12_4_ = 0;
      pnStack52 = conn;
      msg._4_4_ = vectors;
      msg.msg._0_2_ = vectorcnt;
      msg.msg[16] = apiflags;
      if (conn->send_timeout == 0) {
        msg.msg._20_4_ = 0;
      }
      else {
        msg.msg._20_4_ = sys_now();
      }
      eVar1 = netconn_apimsg(lwip_netconn_do_write,(api_msg *)&pnStack52);
      if (CONCAT31(extraout_var,eVar1) == 0) {
        if (bytes_written == (size_t *)0x0) {
          eVar1 = '\0';
        }
        else {
          *bytes_written = msg.msg._12_4_;
        }
      }
      return eVar1;
    }
    eVar1 = '\0';
  }
  return eVar1;
}



err_t netconn_write_partly
                (netconn *conn,void *dataptr,size_t size,u8_t apiflags,size_t *bytes_written)

{
  err_t eVar1;
  void *pvStack24;
  netvector vector;
  
  pvStack24 = dataptr;
  vector.ptr = (void *)size;
  eVar1 = netconn_write_vectors_partly(conn,(netvector *)&pvStack24,1,apiflags,bytes_written);
  return eVar1;
}



err_t netconn_err(netconn *conn)

{
  err_t eVar1;
  
  eVar1 = '\0';
  if (conn != (netconn *)0x0) {
    sys_arch_protect();
    eVar1 = conn->pending_err;
    conn->pending_err = '\0';
    sys_arch_unprotect();
  }
  return eVar1;
}



// WARNING: Could not reconcile some variable overlaps

err_t netconn_accept(netconn *conn,netconn **new_conn)

{
  err_t eVar1;
  undefined3 extraout_var;
  int iVar2;
  u32_t uVar3;
  sys_mbox_t *mbox;
  err_t eStack37;
  err_t err;
  netconn *pnStack36;
  void *accept_ptr;
  
  if ((new_conn == (netconn **)0x0) || (*new_conn = (netconn *)0x0, conn == (netconn *)0x0)) {
    eVar1 = -0x10;
  }
  else {
    eVar1 = netconn_err(conn);
    if (CONCAT31(extraout_var,eVar1) == 0) {
      mbox = &conn->acceptmbox;
      eStack37 = eVar1;
      iVar2 = sys_mbox_valid(mbox);
      if ((iVar2 != 0) && ((conn->flags & 1) == 0)) {
        if ((conn->flags & 2) == 0) {
          uVar3 = sys_arch_mbox_fetch(mbox,(void **)&stack0xffffffdc,conn->recv_timeout);
          if (uVar3 == 0xffffffff) {
            return -3;
          }
        }
        else {
          uVar3 = sys_arch_mbox_tryfetch(mbox,(void **)&stack0xffffffdc);
          if (uVar3 == 0xffffffff) {
            return -7;
          }
        }
        if (conn->callback != (netconn_callback *)0x0) {
          (*conn->callback)(conn,NETCONN_EVT_RCVMINUS,0);
        }
        iVar2 = lwip_netconn_is_err_msg(pnStack36,&eStack37);
        if (iVar2 != 0) {
          return eStack37;
        }
        if (pnStack36 != (netconn *)0x0) {
          *new_conn = pnStack36;
          return eVar1;
        }
      }
      eVar1 = -0xf;
    }
  }
  return eVar1;
}



// WARNING: Could not reconcile some variable overlaps

err_t netconn_recv_data(netconn *conn,void **new_buf,u8_t apiflags)

{
  err_t eVar1;
  int iVar2;
  undefined3 extraout_var;
  u32_t uVar3;
  undefined3 extraout_var_00;
  void **ppvVar4;
  sys_mbox_t *mbox;
  err_t eStack37;
  err_t err;
  void **msg;
  void *buf;
  
  msg = (void **)0x0;
  if ((new_buf == (void **)0x0) || (*new_buf = (void *)0x0, conn == (netconn *)0x0)) {
    return -0x10;
  }
  mbox = &conn->recvmbox;
  iVar2 = sys_mbox_valid(mbox);
  if (iVar2 == 0) {
    eVar1 = netconn_err(conn);
    if (CONCAT31(extraout_var,eVar1) == 0) {
      return -0xb;
    }
    return eVar1;
  }
  if (((apiflags & 4 | conn->flags & 3) == 0) && (conn->pending_err == '\0')) {
    uVar3 = sys_arch_mbox_fetch(mbox,(void **)&stack0xffffffdc,conn->recv_timeout);
    if (uVar3 == 0xffffffff) {
      return -3;
    }
  }
  else {
    uVar3 = sys_arch_mbox_tryfetch(mbox,(void **)&stack0xffffffdc);
    if (uVar3 == 0xffffffff) {
      eVar1 = netconn_err(conn);
      if (CONCAT31(extraout_var_00,eVar1) != 0) {
        return eVar1;
      }
      if ((conn->flags & 1) != 0) {
        return -0xb;
      }
      return -7;
    }
  }
  if ((conn->type & 0xf0) == NETCONN_TCP) {
    iVar2 = lwip_netconn_is_err_msg(msg,&eStack37);
    ppvVar4 = msg;
    if (iVar2 != 0) {
      if (eStack37 == -0xf) {
        return '\0';
      }
      return eStack37;
    }
  }
  else {
    ppvVar4 = (void **)*msg;
  }
  if (conn->callback != (netconn_callback *)0x0) {
    (*conn->callback)(conn,NETCONN_EVT_RCVMINUS,*(u16_t *)(ppvVar4 + 2));
  }
  *(void ***)new_buf = msg;
  return '\0';
}



err_t netconn_recv_udp_raw_netbuf_flags(netconn *conn,netbuf **new_buf,u8_t apiflags)

{
  err_t eVar1;
  
  if ((conn != (netconn *)0x0) && ((conn->type & 0xf0) != NETCONN_TCP)) {
    eVar1 = netconn_recv_data(conn,new_buf,apiflags);
    return eVar1;
  }
  return -0x10;
}



// WARNING: Could not reconcile some variable overlaps

err_t netconn_recv_data_tcp(netconn *conn,pbuf **new_buf,u8_t apiflags)

{
  err_t eVar1;
  int iVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  uint uVar3;
  pbuf *ppVar4;
  netconn *pnStack68;
  api_msg msg;
  
  iVar2 = sys_mbox_valid(&conn->recvmbox);
  if (iVar2 == 0) {
    return -0xb;
  }
  if ((char)conn->flags < '\0') {
    conn->flags = conn->flags & 0x7f;
  }
  else {
    eVar1 = netconn_recv_data(conn,new_buf,apiflags);
    if (CONCAT31(extraout_var_00,eVar1) != 0) {
      return eVar1;
    }
    ppVar4 = *new_buf;
    if ((apiflags & 8) == 0) {
      uVar3 = 1;
      if (ppVar4 != (pbuf *)0x0) {
        uVar3 = (uint)ppVar4->tot_len;
      }
      if ((conn->type & 0xf0) == NETCONN_TCP) {
        pnStack68 = conn;
        msg._4_4_ = uVar3;
        netconn_apimsg(lwip_netconn_do_recv,(api_msg *)&pnStack68);
      }
    }
    if (ppVar4 != (pbuf *)0x0) {
      return eVar1;
    }
    if ((apiflags & 0x10) != 0) {
      conn->flags = conn->flags | 0x80;
      return -7;
    }
  }
  if (conn->callback != (netconn_callback *)0x0) {
    (*conn->callback)(conn,NETCONN_EVT_RCVMINUS,0);
  }
  if (conn->pcb == 0) {
    eVar1 = netconn_err(conn);
    if (CONCAT31(extraout_var,eVar1) == 0) {
      eVar1 = -0xe;
    }
  }
  else {
    netconn_close_shutdown(conn,'\x01');
    eVar1 = -0xf;
  }
  return eVar1;
}



err_t netconn_recv_tcp_pbuf_flags(netconn *conn,pbuf **new_buf,u8_t apiflags)

{
  err_t eVar1;
  
  if ((conn != (netconn *)0x0) && ((conn->type & 0xf0) == NETCONN_TCP)) {
    eVar1 = netconn_recv_data_tcp(conn,new_buf,apiflags);
    return eVar1;
  }
  return -0x10;
}



err_t netconn_shutdown(netconn *conn,u8_t shut_rx,u8_t shut_tx)

{
  err_t eVar1;
  undefined3 in_register_0000202d;
  undefined3 in_register_00002031;
  
  eVar1 = netconn_close_shutdown
                    (conn,CONCAT31(in_register_0000202d,shut_rx) != 0 |
                          (CONCAT31(in_register_00002031,shut_tx) != 0) << 1);
  return eVar1;
}



// WARNING: Could not reconcile some variable overlaps

err_t netconn_join_leave_group
                (netconn *conn,ip_addr_t *multiaddr,ip_addr_t *netif_addr,netconn_igmp join_or_leave
                )

{
  err_t eVar1;
  netconn *pnStack52;
  api_msg msg;
  
  if (conn != (netconn *)0x0) {
    if (multiaddr == (ip_addr_t *)0x0) {
      multiaddr = &ip_addr_any;
    }
    if (netif_addr == (ip_addr_t *)0x0) {
      netif_addr = &ip_addr_any;
    }
    pnStack52 = conn;
    msg._4_4_ = multiaddr;
    msg.msg._0_4_ = netif_addr;
    msg.msg[5] = join_or_leave;
    eVar1 = netconn_apimsg(lwip_netconn_do_join_leave_group,(api_msg *)&pnStack52);
    return eVar1;
  }
  return -0x10;
}



err_t netconn_gethostbyname(char *name,ip_addr_t *addr)

{
  err_t eVar1;
  err_t eVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined auStack36 [3];
  err_t err;
  sys_sem_t sem;
  dns_api_msg msg;
  
  eVar2 = -0x10;
  if ((name != (char *)0x0) && (addr != (ip_addr_t *)0x0)) {
    sem = (sys_sem_t)name;
    eVar1 = sys_sem_new((sys_sem_t *)auStack36,'\0');
    eVar2 = eVar1;
    if (CONCAT31(extraout_var,eVar1) == 0) {
      eVar2 = tcpip_send_msg_wait_sem(lwip_netconn_do_gethostbyname,&sem,(sys_sem_t *)auStack36);
      sys_sem_free((sys_sem_t *)auStack36);
      if (CONCAT31(extraout_var_00,eVar2) == 0) {
        eVar2 = eVar1;
      }
    }
  }
  return eVar2;
}



void lwip_netconn_do_dns_found(char *name,ip_addr_t *ipaddr,void *arg)

{
  if (ipaddr == (ip_addr_t *)0x0) {
    **(undefined **)((int)arg + 0xc) = 0xfa;
  }
  else {
    **(undefined **)((int)arg + 0xc) = 0;
    **(u32_t **)((int)arg + 4) = ipaddr->addr;
  }
  sys_sem_signal((sys_mutex_t *)*(sys_mutex_t *)((int)arg + 8));
  return;
}



void recv_udp(void *arg,udp_pcb *pcb,pbuf *p,ip_addr_t *addr,u16_t port)

{
  ushort uVar1;
  err_t eVar2;
  int iVar3;
  netbuf *buf;
  undefined3 extraout_var;
  u32_t uVar4;
  
  if (arg != (void *)0x0) {
    iVar3 = sys_mbox_valid((sys_mbox_t *)((int)arg + 0x10));
    if ((iVar3 != 0) && (buf = (netbuf *)memp_malloc(MEMP_NETBUF), buf != (netbuf *)0x0)) {
      buf->p = p;
      buf->ptr = p;
      uVar4 = 0;
      if (addr != (ip_addr_t *)0x0) {
        uVar4 = addr->addr;
      }
      (buf->addr).addr = uVar4;
      buf->port = port;
      uVar1 = p->tot_len;
      eVar2 = sys_mbox_trypost((sys_mbox_t *)((int)arg + 0x10),buf);
      if (CONCAT31(extraout_var,eVar2) != 0) {
        netbuf_delete(buf);
        return;
      }
      if (*(code **)((int)arg + 0x2c) != (code *)0x0) {
                    // WARNING: Could not recover jumptable at 0x2304635c. Too many branches
                    // WARNING: Treating indirect jump as call
        (**(code **)((int)arg + 0x2c))(arg,0,(uint)uVar1);
        return;
      }
      return;
    }
  }
  pbuf_free(p);
  return;
}



void setup_tcp(netconn *conn)

{
  tcp_pcb *pcb;
  
  pcb = (tcp_pcb *)conn->pcb;
  tcp_arg(pcb,conn);
  tcp_recv(pcb,recv_tcp);
  tcp_sent(pcb,sent_tcp);
  tcp_poll(pcb,poll_tcp,'\x02');
  tcp_err(pcb,err_tcp);
  return;
}



err_t lwip_netconn_do_connected(void *arg,tcp_pcb *pcb,err_t err)

{
  byte bVar1;
  err_t eVar2;
  sys_mutex_t mutex;
  undefined3 in_register_00002031;
  
  eVar2 = -6;
  if (arg != (void *)0x0) {
    mutex = *(sys_mutex_t *)((int)arg + 0x28);
    if (mutex != (sys_mutex_t)0x0) {
      *(err_t *)&mutex->pcWriteTo = err;
      mutex = (sys_mutex_t)(**(int **)((int)arg + 0x28) + 0xc);
    }
    if (((*(byte *)arg & 0xf0) == 0x10) && (CONCAT31(in_register_00002031,err) == 0)) {
      setup_tcp((netconn *)arg);
    }
    bVar1 = *(byte *)((int)arg + 0x24);
    *(undefined4 *)((int)arg + 0x28) = 0;
    *(undefined *)((int)arg + 1) = 0;
    *(byte *)((int)arg + 0x24) = bVar1 & 0xfb;
    if (*(code **)((int)arg + 0x2c) != (code *)0x0) {
      (**(code **)((int)arg + 0x2c))(arg,2,0);
    }
    eVar2 = '\0';
    if ((bVar1 & 4) == 0) {
      sys_sem_signal((sys_mutex_t *)mutex);
    }
  }
  return eVar2;
}



void err_tcp(void *arg,err_t err)

{
  char cVar1;
  byte bVar2;
  sys_sem_t *sem;
  int iVar3;
  uint uVar4;
  void *msg;
  
  sys_arch_protect();
  cVar1 = *(char *)((int)arg + 1);
  *(undefined4 *)((int)arg + 4) = 0;
  *(byte *)((int)arg + 0x24) = *(byte *)((int)arg + 0x24) | 1;
  *(err_t *)((int)arg + 8) = err;
  *(undefined *)((int)arg + 1) = 0;
  sys_arch_unprotect();
  if (*(code **)((int)arg + 0x2c) != (code *)0x0) {
    (**(code **)((int)arg + 0x2c))(arg,4,0);
  }
  if (*(code **)((int)arg + 0x2c) != (code *)0x0) {
    (**(code **)((int)arg + 0x2c))(arg,0,0);
  }
  if (*(code **)((int)arg + 0x2c) != (code *)0x0) {
    (**(code **)((int)arg + 0x2c))(arg,2,0);
  }
  uVar4 = (uint)(byte)err + 0xf & 0xff;
  msg = (void *)0x0;
  if (uVar4 < 3) {
    msg = *(void **)(CSWTCH_13 + uVar4 * 4);
  }
  iVar3 = sys_mbox_valid((sys_mbox_t *)((int)arg + 0x10));
  if (iVar3 != 0) {
    sys_mbox_trypost((sys_mbox_t *)((int)arg + 0x10),msg);
  }
  iVar3 = sys_mbox_valid((sys_mbox_t *)((int)arg + 0x14));
  if (iVar3 != 0) {
    sys_mbox_trypost((sys_mbox_t *)((int)arg + 0x14),msg);
  }
  if (((cVar1 == '\x01') || ((byte)(cVar1 - 3U) < 2)) &&
     (bVar2 = *(byte *)((int)arg + 0x24), *(byte *)((int)arg + 0x24) = bVar2 & 0xfb,
     (bVar2 & 4) == 0)) {
    if (cVar1 == '\x04') {
      err = '\0';
    }
    *(err_t *)(*(int *)((int)arg + 0x28) + 4) = err;
    sem = (sys_sem_t *)(**(int **)((int)arg + 0x28) + 0xc);
    sys_sem_valid(sem);
    *(undefined4 *)((int)arg + 0x28) = 0;
    sys_sem_signal((sys_mutex_t *)sem);
    return;
  }
  return;
}



err_t lwip_netconn_do_writemore(netconn *conn)

{
  ushort uVar1;
  bool bVar2;
  err_t eVar3;
  TickType_t TVar4;
  netconn *pnVar5;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  uint uVar6;
  api_msg *paVar7;
  int iVar8;
  uint uVar9;
  int iVar10;
  uint uVar11;
  byte apiflags;
  byte bVar12;
  
  apiflags = conn->current_msg->msg[0x14];
  bVar12 = conn->flags & 2 | apiflags & 4;
  if (conn->send_timeout == 0) {
LAB_23046596:
    do {
      paVar7 = conn->current_msg;
      uVar9 = (*(int **)paVar7->msg)[1] - *(int *)(paVar7->msg + 8);
      if (uVar9 < 0x10000) {
        uVar11 = uVar9 & 0xffff;
      }
      else {
        apiflags = apiflags | 2;
        uVar11 = 0xffff;
      }
      uVar1 = ((tcp_pcb *)conn->pcb)->snd_buf;
      uVar6 = (uint)uVar1;
      if (uVar6 < uVar11) {
        if (bVar12 == 0) {
          apiflags = apiflags | 2;
        }
        else {
          if (uVar1 == 0) {
            iVar8 = -7;
            if (*(int *)(paVar7->msg + 0x10) != 0) {
              iVar8 = 0;
            }
            goto LAB_230465ce;
          }
        }
LAB_2304662c:
        bVar2 = false;
        if (((uVar9 & 0xffff) == uVar6) && (1 < *(ushort *)(paVar7->msg + 4))) goto LAB_2304663e;
      }
      else {
        uVar6 = uVar11;
        if ((uVar11 != 0xffff) || (uVar9 < 0x10000)) goto LAB_2304662c;
LAB_2304663e:
        apiflags = apiflags | 2;
        bVar2 = true;
      }
      eVar3 = tcp_write((tcp_pcb *)conn->pcb,
                        (void *)(**(int **)paVar7->msg + *(int *)(paVar7->msg + 8)),(u16_t)uVar6,
                        apiflags);
      iVar8 = CONCAT31(extraout_var_00,eVar3);
      if (iVar8 != 0) {
        if (1 < (iVar8 + 1U & 0xff)) goto LAB_2304657e;
        iVar8 = -1;
        break;
      }
      *(uint *)(conn->current_msg->msg + 0x10) = *(int *)(conn->current_msg->msg + 0x10) + uVar6;
      *(uint *)(conn->current_msg->msg + 8) = uVar6 + *(int *)(conn->current_msg->msg + 8);
      paVar7 = conn->current_msg;
      if (*(int *)(paVar7->msg + 8) == *(int *)(*(int *)paVar7->msg + 4)) {
        *(short *)(paVar7->msg + 4) = *(short *)(paVar7->msg + 4) + -1;
        paVar7 = conn->current_msg;
        if (*(short *)(paVar7->msg + 4) != 0) {
          *(int *)paVar7->msg = *(int *)paVar7->msg + 8;
          *(undefined4 *)(conn->current_msg->msg + 8) = 0;
        }
      }
    } while (bVar2);
    if (bVar12 == 0) {
LAB_230466a6:
      if (((*(ushort *)(conn->pcb + 100) < 0xac1) || (7 < *(ushort *)(conn->pcb + 0x66))) &&
         (conn->callback != (netconn_callback *)0x0)) {
        (*conn->callback)(conn,NETCONN_EVT_SENDMINUS,0);
      }
    }
    else {
LAB_230465ce:
      if (*(uint *)(conn->current_msg->msg + 0xc) <= *(uint *)(conn->current_msg->msg + 0x10))
      goto LAB_230466a6;
      if (conn->callback != (netconn_callback *)0x0) {
        (*conn->callback)(conn,NETCONN_EVT_SENDMINUS,0);
      }
      conn->flags = conn->flags | 0x10;
    }
    eVar3 = (err_t)iVar8;
    if (iVar8 != 0) {
      if (iVar8 != -1) goto LAB_2304657e;
      eVar3 = tcp_output((tcp_pcb *)conn->pcb);
      if (CONCAT31(extraout_var_01,eVar3) == -4) goto LAB_2304660e;
      if (bVar12 == 0) {
        return '\0';
      }
      iVar8 = *(int *)(conn->current_msg->msg + 0x10);
      goto LAB_23046578;
    }
    iVar8 = *(int *)(conn->current_msg->msg + 0x10);
    iVar10 = *(int *)(conn->current_msg->msg + 0xc);
    eVar3 = tcp_output((tcp_pcb *)conn->pcb);
    if (CONCAT31(extraout_var,eVar3) == -4) {
LAB_2304660e:
      eVar3 = -4;
      goto LAB_2304657e;
    }
    if (iVar8 != iVar10 && bVar12 == 0) {
      return '\0';
    }
  }
  else {
    TVar4 = sys_now();
    if ((int)(TVar4 - *(int *)(conn->current_msg->msg + 0x18)) < conn->send_timeout)
    goto LAB_23046596;
    iVar8 = *(int *)(conn->current_msg->msg + 0x10);
LAB_23046578:
    eVar3 = -7;
    if (iVar8 == 0) goto LAB_2304657e;
  }
  eVar3 = '\0';
LAB_2304657e:
  pnVar5 = conn->current_msg->conn;
  conn->current_msg->err = eVar3;
  conn->current_msg = (api_msg *)0x0;
  conn->state = NETCONN_NONE;
  sys_sem_signal((sys_mutex_t *)&pnVar5->op_completed);
  return '\0';
}



err_t lwip_netconn_do_close_internal(netconn *conn)

{
  byte bVar1;
  bool bVar2;
  tcp_pcb *pcb;
  netconn *pnVar3;
  err_t eVar4;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  TickType_t TVar5;
  int iVar6;
  int iVar7;
  
  bVar1 = conn->current_msg->msg[0];
  pcb = (tcp_pcb *)conn->pcb;
  if (((bVar1 == 3) ||
      (((bVar1 & 1) != 0 && (((byte)(pcb->state + ~ESTABLISHED) < 2 || (pcb->state == CLOSING))))))
     || ((bVar2 = false, (bVar1 & 2) != 0 && ((pcb->flags & 0x10) != 0)))) {
    tcp_arg(pcb,(void *)0x0);
    bVar2 = true;
  }
  if (pcb->state == LISTEN) {
    tcp_accept(pcb,(tcp_accept_fn)0x0);
    if (!bVar2) {
LAB_2304677c:
      eVar4 = tcp_shutdown(pcb,(uint)bVar1 & 1,(uint)bVar1 & 2);
      iVar6 = CONCAT31(extraout_var,eVar4);
      goto LAB_230467c4;
    }
  }
  else {
    if ((bVar1 & 1) != 0) {
      tcp_recv(pcb,(tcp_recv_fn *)0x0);
      tcp_accept(pcb,(tcp_accept_fn)0x0);
    }
    if ((bVar1 & 2) != 0) {
      tcp_sent(pcb,(tcp_sent_fn *)0x0);
    }
    if (!bVar2) goto LAB_2304677c;
    tcp_poll(pcb,(tcp_poll_fn *)0x0,'\0');
    tcp_err(pcb,(tcp_err_fn *)0x0);
  }
  eVar4 = tcp_close(pcb);
  iVar6 = CONCAT31(extraout_var_00,eVar4);
LAB_230467c4:
  if ((iVar6 != 0) && (iVar6 == -1)) {
    iVar7 = conn->send_timeout;
    if (iVar7 < 1) {
      iVar7 = 5000;
    }
    TVar5 = sys_now();
    if ((int)(TVar5 - *(int *)(conn->current_msg->msg + 4)) < iVar7) {
      if ((bVar1 & 2) != 0) {
        tcp_sent(pcb,sent_tcp);
      }
      tcp_poll(pcb,poll_tcp,'\x01');
      tcp_err(pcb,err_tcp);
      tcp_arg(pcb,conn);
      return (err_t)iVar6;
    }
    if (bVar2) {
      tcp_abort(pcb);
      iVar6 = 0;
    }
  }
  pnVar3 = conn->current_msg->conn;
  conn->current_msg->err = (err_t)iVar6;
  conn->current_msg = (api_msg *)0x0;
  conn->state = NETCONN_NONE;
  if (iVar6 == 0) {
    if (bVar2) {
      conn->pcb = 0;
      if (conn->callback != (netconn_callback *)0x0) {
        (*conn->callback)(conn,NETCONN_EVT_ERROR,0);
      }
    }
    if (((bVar1 & 1) != 0) && (conn->callback != (netconn_callback *)0x0)) {
      (*conn->callback)(conn,NETCONN_EVT_RCVPLUS,0);
    }
    if (((bVar1 & 2) != 0) && (conn->callback != (netconn_callback *)0x0)) {
      (*conn->callback)(conn,NETCONN_EVT_SENDPLUS,0);
    }
  }
  sys_sem_signal((sys_mutex_t *)&pnVar3->op_completed);
  return '\0';
}



err_t poll_tcp(void *arg,tcp_pcb *pcb)

{
  int iVar1;
  
  if (*(char *)((int)arg + 1) == '\x01') {
    lwip_netconn_do_writemore((netconn *)arg);
  }
  else {
    if (*(char *)((int)arg + 1) == '\x04') {
      lwip_netconn_do_close_internal((netconn *)arg);
    }
  }
  if (((((*(byte *)((int)arg + 0x24) & 0x10) != 0) && (iVar1 = *(int *)((int)arg + 4), iVar1 != 0))
      && (0xac0 < *(ushort *)(iVar1 + 100))) && (*(ushort *)(iVar1 + 0x66) < 8)) {
    *(byte *)((int)arg + 0x24) = *(byte *)((int)arg + 0x24) & 0xef;
    if (*(code **)((int)arg + 0x2c) != (code *)0x0) {
      (**(code **)((int)arg + 0x2c))(arg,2,0);
    }
  }
  return '\0';
}



u8_t recv_raw(void *arg,raw_pcb *pcb,pbuf *p,ip_addr_t *addr)

{
  ushort uVar1;
  err_t eVar2;
  int iVar3;
  pbuf *p_00;
  netbuf *buf;
  undefined3 extraout_var;
  u16_t len;
  
  if (arg != (void *)0x0) {
    iVar3 = sys_mbox_valid((sys_mbox_t *)((int)arg + 0x10));
    if ((iVar3 != 0) && (p_00 = pbuf_clone(PBUF_RAW,PBUF_RAM,p), p_00 != (pbuf *)0x0)) {
      buf = (netbuf *)memp_malloc(MEMP_NETBUF);
      if (buf == (netbuf *)0x0) {
        pbuf_free(p_00);
      }
      else {
        buf->p = p_00;
        buf->ptr = p_00;
        (buf->addr).addr = ip_data.current_iphdr_src;
        buf->port = (ushort)pcb->protocol;
        uVar1 = p_00->tot_len;
        eVar2 = sys_mbox_trypost((sys_mbox_t *)((int)arg + 0x10),buf);
        if (CONCAT31(extraout_var,eVar2) == 0) {
          if (*(code **)((int)arg + 0x2c) != (code *)0x0) {
            (**(code **)((int)arg + 0x2c))(arg,0,(uint)uVar1);
          }
        }
        else {
          netbuf_delete(buf);
        }
      }
    }
    return '\0';
  }
  return '\0';
}



err_t sent_tcp(void *arg,tcp_pcb *pcb,u16_t len)

{
  undefined2 in_register_00002032;
  int iVar1;
  
  if (arg != (void *)0x0) {
    if (*(char *)((int)arg + 1) == '\x01') {
      lwip_netconn_do_writemore((netconn *)arg);
    }
    else {
      if (*(char *)((int)arg + 1) == '\x04') {
        lwip_netconn_do_close_internal((netconn *)arg);
      }
    }
    iVar1 = *(int *)((int)arg + 4);
    if (((iVar1 != 0) && (0xac0 < *(ushort *)(iVar1 + 100))) && (*(ushort *)(iVar1 + 0x66) < 8)) {
      *(byte *)((int)arg + 0x24) = *(byte *)((int)arg + 0x24) & 0xef;
      if (*(code **)((int)arg + 0x2c) != (code *)0x0) {
        (**(code **)((int)arg + 0x2c))(arg,2,CONCAT22(in_register_00002032,len));
      }
    }
    return '\0';
  }
  return '\0';
}



err_t recv_tcp(void *arg,tcp_pcb *pcb,pbuf *p,err_t err)

{
  err_t eVar1;
  int iVar2;
  undefined3 extraout_var;
  uint uVar3;
  
  if (arg == (void *)0x0) {
    return -6;
  }
  iVar2 = sys_mbox_valid((sys_mbox_t *)((int)arg + 0x10));
  if (iVar2 == 0) {
    if (p != (pbuf *)0x0) {
      tcp_recved(pcb,p->tot_len);
      pbuf_free(p);
    }
  }
  else {
    if (p == (pbuf *)0x0) {
      uVar3 = 0;
      p = (pbuf *)"";
    }
    else {
      uVar3 = (uint)p->tot_len;
    }
    eVar1 = sys_mbox_trypost((sys_mbox_t *)((int)arg + 0x10),p);
    if (CONCAT31(extraout_var,eVar1) != 0) {
      return -1;
    }
    if (*(code **)((int)arg + 0x2c) != (code *)0x0) {
      (**(code **)((int)arg + 0x2c))(arg,0,uVar3);
      return eVar1;
    }
  }
  return '\0';
}



int lwip_netconn_is_err_msg(void *msg,err_t *err)

{
  err_t eVar1;
  
  if ((u8_t *)msg == "") {
    eVar1 = -0xd;
  }
  else {
    if ((u8_t *)msg == "") {
      eVar1 = -0xe;
    }
    else {
      if ((u8_t *)msg != "") {
        return 0;
      }
      eVar1 = -0xf;
    }
  }
  *err = eVar1;
  return 1;
}



void lwip_netconn_do_newconn(void *m)

{
  byte *pbVar1;
  tcp_pcb *ptVar2;
  raw_pcb *pcb;
  udp_pcb *puVar3;
  byte bVar4;
  undefined uVar5;
  int iVar6;
  
  pbVar1 = *(byte **)m;
  *(undefined *)((int)m + 4) = 0;
  if (*(int *)(pbVar1 + 4) != 0) goto LAB_23046b1c;
  bVar4 = *pbVar1 & 0xf0;
  if (bVar4 == 0x20) {
    puVar3 = udp_new_ip_type();
    *(udp_pcb **)(pbVar1 + 4) = puVar3;
    iVar6 = *(int *)(*(char **)m + 4);
    if (iVar6 != 0) {
      if (**(char **)m == '\"') {
        *(undefined *)(iVar6 + 0x10) = 1;
      }
      udp_recv(*(udp_pcb **)((int)*(void **)m + 4),recv_udp,*(void **)m);
LAB_23046b16:
      if (*(int *)(*(int *)m + 4) != 0) goto LAB_23046b1c;
    }
LAB_23046b66:
    uVar5 = 0xff;
  }
  else {
    if (bVar4 == 0x40) {
      pcb = raw_new_ip_type('\0',*(u8_t *)((int)m + 8));
      *(raw_pcb **)(pbVar1 + 4) = pcb;
      pcb = *(raw_pcb **)((int)*(void **)m + 4);
      if (pcb != (raw_pcb *)0x0) {
        raw_recv(pcb,recv_raw,*(void **)m);
        goto LAB_23046b16;
      }
      goto LAB_23046b66;
    }
    if (bVar4 == 0x10) {
      ptVar2 = tcp_new_ip_type('\0');
      *(tcp_pcb **)(pbVar1 + 4) = ptVar2;
      if ((*(netconn **)m)->pcb != 0) {
        setup_tcp(*(netconn **)m);
        goto LAB_23046b16;
      }
      goto LAB_23046b66;
    }
    uVar5 = 0xfa;
  }
  *(undefined *)((int)m + 4) = uVar5;
LAB_23046b1c:
  sys_sem_signal((sys_mutex_t *)(*(int *)m + 0xc));
  return;
}



netconn * netconn_alloc(netconn_type t,netconn_callback *callback)

{
  err_t eVar1;
  netconn *mem;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  int size;
  
  mem = (netconn *)memp_malloc(MEMP_NETCONN);
  if (mem == (netconn *)0x0) {
    return (netconn *)0x0;
  }
  mem->pending_err = '\0';
  mem->type = t;
  mem->pcb = 0;
  t = t & 0xf0;
  if (t == NETCONN_UDP) {
LAB_23046ba8:
    size = 2000;
  }
  else {
    if (t != NETCONN_RAW) {
      if (t != NETCONN_TCP) goto free_and_return;
      goto LAB_23046ba8;
    }
    size = 0;
  }
  eVar1 = sys_mbox_new(&mem->recvmbox,size);
  if (CONCAT31(extraout_var,eVar1) == 0) {
    eVar1 = sys_sem_new(&mem->op_completed,'\0');
    if (CONCAT31(extraout_var_00,eVar1) == 0) {
      sys_mbox_set_invalid(&mem->acceptmbox);
      mem->state = NETCONN_NONE;
      mem->socket = -1;
      mem->callback = callback;
      mem->current_msg = (api_msg *)0x0;
      mem->send_timeout = 0;
      mem->recv_timeout = 0;
      mem->flags = '\0';
      return mem;
    }
    sys_mbox_free(&mem->recvmbox);
  }
free_and_return:
  memp_free(MEMP_NETCONN,mem);
  return (netconn *)0x0;
}



void netconn_free(netconn *conn)

{
  sys_mbox_valid(&conn->recvmbox);
  sys_mbox_valid(&conn->acceptmbox);
  sys_sem_free(&conn->op_completed);
  sys_sem_set_invalid(&conn->op_completed);
  memp_free(MEMP_NETCONN,conn);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void netconn_drain(netconn *conn)

{
  netconn *conn_00;
  sys_mbox_t *mbox;
  int iVar1;
  u32_t uVar2;
  err_t eStack37;
  err_t err;
  netconn *pnStack36;
  void *mem;
  
  mbox = &conn->recvmbox;
  iVar1 = sys_mbox_valid(mbox);
  if (iVar1 != 0) {
    while (uVar2 = sys_arch_mbox_tryfetch(mbox,(void **)&stack0xffffffdc), uVar2 != 0xffffffff) {
      if ((conn->type & 0xf0) == NETCONN_TCP) {
        iVar1 = lwip_netconn_is_err_msg(pnStack36,&eStack37);
        if (iVar1 == 0) {
          pbuf_free((pbuf *)pnStack36);
        }
      }
      else {
        netbuf_delete((netbuf *)pnStack36);
      }
    }
    sys_mbox_free(mbox);
    sys_mbox_set_invalid(mbox);
  }
  mbox = &conn->acceptmbox;
  iVar1 = sys_mbox_valid(mbox);
  if (iVar1 != 0) {
    while (uVar2 = sys_arch_mbox_tryfetch(mbox,(void **)&stack0xffffffdc), uVar2 != 0xffffffff) {
      iVar1 = lwip_netconn_is_err_msg(pnStack36,&eStack37);
      conn_00 = pnStack36;
      if (iVar1 == 0) {
        netconn_drain(pnStack36);
        if ((tcp_pcb *)conn_00->pcb != (tcp_pcb *)0x0) {
          tcp_abort((tcp_pcb *)conn_00->pcb);
          conn_00->pcb = 0;
        }
        netconn_free(conn_00);
      }
    }
    sys_mbox_free(mbox);
    sys_mbox_set_invalid(mbox);
  }
  return;
}



err_t accept_function(void *arg,tcp_pcb *newpcb,err_t err)

{
  tcp_pcb *pcb;
  err_t eVar1;
  err_t eVar2;
  int iVar3;
  undefined3 extraout_var;
  netconn *conn;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 in_register_00002031;
  sys_mbox_t *mbox;
  
  if (arg != (void *)0x0) {
    mbox = (sys_mbox_t *)((int)arg + 0x14);
    iVar3 = sys_mbox_valid(mbox,CONCAT31(in_register_00002031,err));
    if (iVar3 != 0) {
      if (newpcb != (tcp_pcb *)0x0) {
        conn = netconn_alloc(*(netconn_type *)arg,*(netconn_callback **)((int)arg + 0x2c));
        if (conn == (netconn *)0x0) {
          eVar2 = sys_mbox_trypost(mbox,"");
          eVar1 = -1;
          if (CONCAT31(extraout_var_00,eVar2) != 0) {
            return -1;
          }
        }
        else {
          *(tcp_pcb **)&conn->pcb = newpcb;
          setup_tcp(conn);
          eVar1 = sys_mbox_trypost(mbox,conn);
          if (CONCAT31(extraout_var_01,eVar1) != 0) {
            pcb = (tcp_pcb *)conn->pcb;
            tcp_arg(pcb,(void *)0x0);
            tcp_recv(pcb,(tcp_recv_fn *)0x0);
            tcp_sent(pcb,(tcp_sent_fn *)0x0);
            tcp_poll(pcb,(tcp_poll_fn *)0x0,'\0');
            tcp_err(pcb,(tcp_err_fn *)0x0);
            conn->pcb = 0;
            sys_mbox_free(&conn->recvmbox);
            sys_mbox_set_invalid(&conn->recvmbox);
            netconn_free(conn);
            return -1;
          }
        }
        if (*(code **)((int)arg + 0x2c) == (code *)0x0) {
          return eVar1;
        }
        (**(code **)((int)arg + 0x2c))(arg,0,0);
        return eVar1;
      }
      eVar1 = sys_mbox_trypost(mbox,"");
      if ((CONCAT31(extraout_var,eVar1) == 0) && (*(code **)((int)arg + 0x2c) != (code *)0x0)) {
        (**(code **)((int)arg + 0x2c))(arg,0,0);
      }
    }
  }
  return -6;
}



void lwip_netconn_do_delconn(void *m)

{
  netconn *conn;
  int iVar1;
  raw_pcb *pcb;
  byte *pbVar2;
  byte bVar3;
  
  conn = *(netconn **)m;
  if (((conn->state & ~NETCONN_LISTEN) == NETCONN_NONE) ||
     ((conn->state == NETCONN_CONNECT && ((conn->flags & 4) != 0)))) {
    *(undefined *)((int)m + 4) = 0;
    netconn_drain(conn);
    pbVar2 = *(byte **)m;
    pcb = *(raw_pcb **)(pbVar2 + 4);
    if (pcb != (raw_pcb *)0x0) {
      bVar3 = *pbVar2 & 0xf0;
      if (bVar3 == 0x20) {
        *(undefined4 *)&pcb[1].netif_idx = 0;
        udp_remove(*(udp_pcb **)(*(int *)m + 4));
      }
      else {
        if (bVar3 == 0x40) {
          raw_remove(pcb);
        }
        else {
          if (bVar3 == 0x10) {
            pbVar2[1] = 4;
            *(undefined *)((int)m + 8) = 3;
            *(void **)(*(int *)m + 0x28) = m;
            lwip_netconn_do_close_internal(*(netconn **)m);
            return;
          }
        }
      }
      *(undefined4 *)(*(int *)m + 4) = 0;
    }
    if (*(code **)(*(int *)m + 0x2c) != (code *)0x0) {
      (**(code **)(*(int *)m + 0x2c))(0,0);
    }
    if (*(code **)(*(int *)m + 0x2c) != (code *)0x0) {
      (**(code **)(*(int *)m + 0x2c))(2,0);
    }
  }
  else {
    *(undefined *)((int)m + 4) = 0xfb;
  }
  iVar1 = sys_sem_valid((sys_sem_t *)(*(int *)m + 0xc));
  if (iVar1 != 0) {
    sys_sem_signal((sys_mutex_t *)(*(int *)m + 0xc));
    return;
  }
  return;
}



void lwip_netconn_do_bind(void *m)

{
  err_t eVar1;
  tcp_pcb *pcb;
  byte bVar2;
  
  eVar1 = -6;
  pcb = *(tcp_pcb **)(*(byte **)m + 4);
  if (pcb != (tcp_pcb *)0x0) {
    bVar2 = **(byte **)m & 0xf0;
    if (bVar2 == 0x20) {
      eVar1 = udp_bind((udp_pcb *)pcb,*(ip_addr_t **)((int)m + 8),*(u16_t *)((int)m + 0xc));
    }
    else {
      if (bVar2 == 0x40) {
        eVar1 = raw_bind((raw_pcb *)pcb,*(ip_addr_t **)((int)m + 8));
      }
      else {
        if (bVar2 == 0x10) {
          eVar1 = tcp_bind(pcb,*(ip_addr_t **)((int)m + 8),*(u16_t *)((int)m + 0xc));
        }
        else {
          eVar1 = -6;
        }
      }
    }
  }
  *(err_t *)((int)m + 4) = eVar1;
  sys_sem_signal((sys_mutex_t *)(*(int *)m + 0xc));
  return;
}



void lwip_netconn_do_connect(void *m)

{
  err_t eVar1;
  udp_pcb *pcb;
  undefined3 extraout_var;
  netconn *conn;
  netconn_type nVar2;
  int iVar3;
  int iVar4;
  
  conn = *(netconn **)m;
  pcb = (udp_pcb *)conn->pcb;
  if (pcb == (udp_pcb *)0x0) {
    eVar1 = -0xf;
  }
  else {
    nVar2 = conn->type & 0xf0;
    if (nVar2 == NETCONN_UDP) {
      eVar1 = udp_connect(pcb,*(ip_addr_t **)((int)m + 8),*(u16_t *)((int)m + 0xc));
    }
    else {
      if (nVar2 == NETCONN_RAW) {
        eVar1 = raw_connect((raw_pcb *)pcb,*(ip_addr_t **)((int)m + 8));
      }
      else {
        eVar1 = -6;
        if (nVar2 == NETCONN_TCP) {
          if (conn->state == NETCONN_CONNECT) {
            eVar1 = -9;
          }
          else {
            eVar1 = -10;
            if (conn->state == NETCONN_NONE) {
              setup_tcp(conn);
              eVar1 = tcp_connect(*(tcp_pcb **)(*(int *)m + 4),*(ip_addr_t **)((int)m + 8),
                                  *(u16_t *)((int)m + 0xc),lwip_netconn_do_connected);
              if (CONCAT31(extraout_var,eVar1) == 0) {
                iVar3 = *(int *)m;
                *(undefined *)(iVar3 + 1) = 3;
                iVar4 = *(int *)m;
                if ((*(byte *)(iVar3 + 0x24) & 2) == 0) {
                  *(byte *)(iVar4 + 0x24) = *(byte *)(iVar4 + 0x24) & 0xfb;
                  *(void **)(*(int *)m + 0x28) = m;
                  return;
                }
                eVar1 = -5;
                *(byte *)(iVar4 + 0x24) = *(byte *)(iVar4 + 0x24) | 4;
              }
            }
          }
        }
      }
    }
  }
  *(err_t *)((int)m + 4) = eVar1;
  sys_sem_signal((sys_mutex_t *)(*(int *)m + 0xc));
  return;
}



void lwip_netconn_do_disconnect(void *m)

{
  if ((**(byte **)m & 0xf0) == 0x20) {
    udp_disconnect(*(udp_pcb **)(*(byte **)m + 4));
    *(undefined *)((int)m + 4) = 0;
  }
  else {
    *(undefined *)((int)m + 4) = 0xfa;
  }
  sys_sem_signal((sys_mutex_t *)(*(int *)m + 0xc));
  return;
}



void lwip_netconn_do_listen(void *m)

{
  tcp_pcb *pcb;
  int iVar1;
  byte *pbVar2;
  err_t aeStack17 [4];
  err_t err;
  
  pbVar2 = *(byte **)m;
  pcb = *(tcp_pcb **)(pbVar2 + 4);
  if (pcb != (tcp_pcb *)0x0) {
    if ((*pbVar2 & 0xf0) != 0x10) {
      aeStack17[0] = -0x10;
      goto LAB_2304709c;
    }
    if (pbVar2[1] == 0) {
      if (pcb->state == CLOSED) {
        pcb = tcp_listen_with_backlog_and_err(pcb,-1,aeStack17);
        if (pcb != (tcp_pcb *)0x0) {
          iVar1 = sys_mbox_valid(*(int *)m + 0x10);
          if (iVar1 != 0) {
            sys_mbox_free((sys_mbox_t *)(*(int *)m + 0x10));
            sys_mbox_set_invalid(*(int *)m + 0x10);
          }
          aeStack17[0] = '\0';
          iVar1 = sys_mbox_valid(*(int *)m + 0x14);
          if (iVar1 == 0) {
            aeStack17[0] = sys_mbox_new((sys_mbox_t *)(*(int *)m + 0x14),2000);
          }
          if (aeStack17[0] == '\0') {
            *(undefined *)(*(int *)m + 1) = 2;
            *(tcp_pcb **)(*(int *)m + 4) = pcb;
            tcp_arg(*(tcp_pcb **)((int)*(void **)m + 4),*(void **)m);
            tcp_accept(*(tcp_pcb **)(*(int *)m + 4),accept_function);
          }
          else {
            tcp_close(pcb);
            *(undefined4 *)(*(int *)m + 4) = 0;
          }
        }
      }
      else {
        aeStack17[0] = -6;
      }
      goto LAB_2304709c;
    }
    if (pbVar2[1] == 2) {
      aeStack17[0] = '\0';
      goto LAB_2304709c;
    }
  }
  aeStack17[0] = -0xb;
LAB_2304709c:
  *(char *)((int)m + 4) = aeStack17[0];
  sys_sem_signal((sys_mutex_t *)(*(int *)m + 0xc));
  return;
}



// WARNING: Type propagation algorithm not settling

void lwip_netconn_do_send(void *m)

{
  err_t eVar1;
  undefined3 extraout_var;
  byte have_chksum;
  pbuf *ppVar2;
  udp_pcb *pcb;
  
  eVar1 = netconn_err(*(netconn **)m);
  if (CONCAT31(extraout_var,eVar1) == 0) {
    eVar1 = -0xb;
    pcb = *(udp_pcb **)(*(byte **)m + 4);
    if (pcb != (udp_pcb *)0x0) {
      have_chksum = **(byte **)m & 0xf0;
      if (have_chksum == 0x20) {
        ppVar2 = *(pbuf **)((int)m + 8);
        have_chksum = ppVar2->ref & 2;
        if (((ip_addr_t *)&ppVar2->tot_len == (ip_addr_t *)0x0) ||
           (*(pbuf **)&ppVar2->tot_len == (pbuf *)0x0)) {
          eVar1 = udp_send_chksum(pcb,ppVar2->next,have_chksum,*(u16_t *)&ppVar2[1].next);
        }
        else {
          eVar1 = udp_sendto_chksum(pcb,ppVar2->next,(ip_addr_t *)&ppVar2->tot_len,
                                    *(u16_t *)&ppVar2->type_internal,have_chksum,
                                    *(u16_t *)&ppVar2[1].next);
        }
      }
      else {
        if (have_chksum == 0x40) {
          ppVar2 = *(pbuf **)((int)m + 8);
          if (((ip_addr_t *)&ppVar2->tot_len == (ip_addr_t *)0x0) ||
             (*(pbuf **)&ppVar2->tot_len == (pbuf *)0x0)) {
            eVar1 = raw_send((raw_pcb *)pcb,ppVar2->next);
          }
          else {
            eVar1 = raw_sendto((raw_pcb *)pcb,ppVar2->next,(ip_addr_t *)&ppVar2->tot_len);
          }
        }
      }
    }
  }
  *(err_t *)((int)m + 4) = eVar1;
  sys_sem_signal((sys_mutex_t *)(*(int *)m + 0xc));
  return;
}



void lwip_netconn_do_recv(void *m)

{
  uint uVar1;
  uint uVar2;
  
  *(undefined *)((int)m + 4) = 0;
  if ((*(int *)(*(byte **)m + 4) != 0) && ((**(byte **)m & 0xf0) == 0x10)) {
    uVar1 = *(uint *)((int)m + 8);
    do {
      uVar2 = uVar1;
      if (0xffff < uVar1) {
        uVar2 = 0xffff;
      }
      uVar1 = uVar1 - uVar2;
      tcp_recved(*(tcp_pcb **)(*(int *)m + 4),(u16_t)uVar2);
    } while (uVar1 != 0);
  }
  sys_sem_signal((sys_mutex_t *)(*(int *)m + 0xc));
  return;
}



void lwip_netconn_do_write(void *m)

{
  err_t eVar1;
  undefined3 extraout_var;
  byte *pbVar2;
  
  eVar1 = netconn_err(*(netconn **)m);
  pbVar2 = *(byte **)m;
  if ((CONCAT31(extraout_var,eVar1) == 0) && (eVar1 = -6, (*pbVar2 & 0xf0) == 0x10)) {
    if (pbVar2[1] == 0) {
      eVar1 = -0xb;
      if (*(int *)(pbVar2 + 4) != 0) {
        pbVar2[1] = 1;
        *(void **)(*(int *)m + 0x28) = m;
        lwip_netconn_do_writemore(*(netconn **)m);
        return;
      }
    }
    else {
      eVar1 = -5;
    }
  }
  *(err_t *)((int)m + 4) = eVar1;
  sys_sem_signal((sys_mutex_t *)(pbVar2 + 0xc));
  return;
}



void lwip_netconn_do_getaddr(void *m)

{
  byte *pbVar1;
  undefined2 *puVar2;
  byte bVar3;
  undefined2 uVar4;
  undefined4 *puVar5;
  undefined4 uVar6;
  int iVar7;
  
  puVar5 = *(undefined4 **)(*(int *)m + 4);
  if (puVar5 == (undefined4 *)0x0) {
LAB_23047272:
    *(undefined *)((int)m + 4) = 0xf5;
  }
  else {
    if (*(char *)((int)m + 0x10) == '\0') {
      uVar6 = puVar5[1];
    }
    else {
      uVar6 = *puVar5;
    }
    **(undefined4 **)((int)m + 8) = uVar6;
    pbVar1 = *(byte **)m;
    *(undefined *)((int)m + 4) = 0;
    bVar3 = *pbVar1 & 0xf0;
    if (bVar3 == 0x20) {
      iVar7 = *(int *)(pbVar1 + 4);
      if (*(char *)((int)m + 0x10) == '\0') {
        if ((*(byte *)(iVar7 + 0x10) & 4) == 0) goto LAB_23047272;
        puVar2 = *(undefined2 **)((int)m + 0xc);
        uVar4 = *(undefined2 *)(iVar7 + 0x14);
      }
      else {
        puVar2 = *(undefined2 **)((int)m + 0xc);
        uVar4 = *(undefined2 *)(iVar7 + 0x12);
      }
    }
    else {
      if (bVar3 == 0x40) {
        if (*(char *)((int)m + 0x10) != '\0') {
          **(ushort **)((int)m + 0xc) = (ushort)*(byte *)(*(int *)(pbVar1 + 4) + 0x10);
          goto LAB_23047290;
        }
        goto LAB_23047272;
      }
      if (bVar3 != 0x10) goto LAB_23047290;
      iVar7 = *(int *)(pbVar1 + 4);
      if (*(char *)((int)m + 0x10) == '\0') {
        if (*(byte *)(iVar7 + 0x14) < 2) goto LAB_23047272;
        uVar4 = *(undefined2 *)(iVar7 + 0x18);
      }
      else {
        uVar4 = *(undefined2 *)(iVar7 + 0x16);
      }
      puVar2 = *(undefined2 **)((int)m + 0xc);
    }
    *puVar2 = uVar4;
  }
LAB_23047290:
  sys_sem_signal((sys_mutex_t *)(*(int *)m + 0xc));
  return;
}



void lwip_netconn_do_close(void *m)

{
  netconn_state nVar1;
  netconn *conn;
  undefined uVar2;
  
  conn = *(netconn **)m;
  if ((conn->pcb != 0) && ((conn->type & 0xf0) == NETCONN_TCP)) {
    nVar1 = conn->state;
    if (((*(byte *)((int)m + 8) == 3) || (nVar1 != NETCONN_LISTEN)) && (nVar1 != NETCONN_CONNECT)) {
      if (nVar1 != NETCONN_WRITE) {
        if ((*(byte *)((int)m + 8) & 1) != 0) {
          netconn_drain(conn);
        }
        *(undefined *)(*(int *)m + 1) = 4;
        *(void **)(*(int *)m + 0x28) = m;
        lwip_netconn_do_close_internal(*(netconn **)m);
        return;
      }
      uVar2 = 0xfb;
      goto LAB_23047302;
    }
  }
  uVar2 = 0xf5;
LAB_23047302:
  *(undefined *)((int)m + 4) = uVar2;
  sys_sem_signal((sys_mutex_t *)&conn->op_completed);
  return;
}



void lwip_netconn_do_join_leave_group(void *m)

{
  err_t eVar1;
  
  *(undefined *)((int)m + 4) = 0xf5;
  if (*(int *)(*(byte **)m + 4) != 0) {
    if ((**(byte **)m & 0xf0) == 0x20) {
      if (*(char *)((int)m + 0x11) == '\0') {
        eVar1 = igmp_joingroup(*(ip4_addr_t **)((int)m + 0xc),*(ip4_addr_t **)((int)m + 8));
      }
      else {
        eVar1 = igmp_leavegroup(*(ip4_addr_t **)((int)m + 0xc),*(ip4_addr_t **)((int)m + 8));
      }
      *(err_t *)((int)m + 4) = eVar1;
    }
    else {
      *(undefined *)((int)m + 4) = 0xfa;
    }
  }
  sys_sem_signal((sys_mutex_t *)(*(int *)m + 0xc));
  return;
}



void lwip_netconn_do_gethostbyname(void *arg)

{
  err_t *peVar1;
  err_t eVar2;
  
  peVar1 = *(err_t **)((int)arg + 0xc);
  eVar2 = dns_gethostbyname_addrtype
                    (*(char **)arg,*(ip_addr_t **)((int)arg + 4),lwip_netconn_do_dns_found,arg,'\0')
  ;
  *peVar1 = eVar2;
  if (**(char **)((int)arg + 0xc) != -5) {
    sys_sem_signal((sys_mutex_t *)*(sys_mutex_t *)((int)arg + 8));
    return;
  }
  return;
}



int err_to_errno(err_t err)

{
  undefined3 in_register_00002029;
  
  if ((CONCAT31(in_register_00002029,err) + 0x10U & 0xff) < 0x11) {
    return err_to_errno_table[CONCAT31(in_register_00002029,err) * 0x3fffffff];
  }
  return 5;
}



void netbuf_delete(netbuf *buf)

{
  if (buf == (netbuf *)0x0) {
    return;
  }
  if (buf->p != (pbuf *)0x0) {
    pbuf_free(buf->p);
    buf->ptr = (pbuf *)0x0;
    buf->p = (pbuf *)0x0;
  }
  memp_free(MEMP_NETBUF,buf);
  return;
}



void * netbuf_alloc(netbuf *buf,u16_t size)

{
  pbuf *ppVar1;
  void *pvVar2;
  
  if (buf == (netbuf *)0x0) {
    return (void *)0x0;
  }
  if (buf->p != (pbuf *)0x0) {
    pbuf_free(buf->p);
  }
  ppVar1 = pbuf_alloc(PBUF_TRANSPORT,size,PBUF_RAM);
  buf->p = ppVar1;
  if (ppVar1 == (pbuf *)0x0) {
    pvVar2 = (void *)0x0;
  }
  else {
    buf->ptr = ppVar1;
    pvVar2 = ppVar1->payload;
  }
  return pvVar2;
}



void netbuf_free(netbuf *buf)

{
  if (buf != (netbuf *)0x0) {
    if (buf->p != (pbuf *)0x0) {
      pbuf_free(buf->p);
    }
    buf->ptr = (pbuf *)0x0;
    buf->p = (pbuf *)0x0;
    buf->flags = '\0';
    buf->toport_chksum = 0;
    return;
  }
  return;
}



void icmp_input(pbuf *p,netif *inp)

{
  ip_hdr *__src;
  u32_t uVar1;
  uint uVar2;
  uint __n;
  void *dataptr;
  u8_t uVar3;
  err_t eVar4;
  u16_t uVar5;
  undefined3 extraout_var;
  undefined2 extraout_var_05;
  undefined3 extraout_var_00;
  pbuf *p_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  uint uVar6;
  short sVar7;
  undefined *puVar8;
  
  __src = ip_data.current_ip4_header;
  lwip_stats.icmp.recv = lwip_stats.icmp.recv + 1;
  uVar2 = (uint)(ip_data.current_ip4_header)->_v_hl & 0xf;
  __n = uVar2 * 4;
  if ((__n < 0x14) || (p->len < 4)) {
lenerr:
    pbuf_free(p);
    lwip_stats.icmp.lenerr = lwip_stats.icmp.lenerr + 1;
  }
  else {
    if (*(char *)p->payload == '\0') goto LAB_2304767c;
    if (*(char *)p->payload != '\b') {
      lwip_stats.icmp.proterr = lwip_stats.icmp.proterr + 1;
      lwip_stats.icmp.drop = lwip_stats.icmp.drop + 1;
      goto LAB_2304767c;
    }
    if (((ip_data.current_iphdr_dest & 0xf0) != 0xe0) &&
       (uVar3 = ip4_addr_isbroadcast_u32(ip_data.current_iphdr_dest,ip_data.current_netif),
       CONCAT31(extraout_var,uVar3) == 0)) {
      if (p->tot_len < 8) goto lenerr;
      uVar5 = inet_chksum_pbuf(p);
      if (CONCAT22(extraout_var_05,uVar5) != 0) {
        pbuf_free(p);
        lwip_stats.icmp.chkerr = lwip_stats.icmp.chkerr + 1;
        return;
      }
      uVar2 = uVar2 << 0x12;
      uVar3 = pbuf_add_header(p,__n + 0x8e);
      if (CONCAT31(extraout_var_00,uVar3) == 0) {
        uVar3 = pbuf_remove_header(p,__n + 0x8e);
        if (CONCAT31(extraout_var_04,uVar3) == 0) {
LAB_230475c4:
          puVar8 = (undefined *)p->payload;
          uVar3 = pbuf_add_header(p,__n);
          uVar1 = ip_data.current_iphdr_dest;
          if (CONCAT31(extraout_var_03,uVar3) == 0) {
            dataptr = p->payload;
            *(undefined *)((int)dataptr + 0xc) = (char)ip_data.current_iphdr_dest;
            *(undefined *)((int)dataptr + 0xd) = (char)(uVar1 >> 8);
            *(undefined *)((int)dataptr + 0xe) = (char)(uVar1 >> 0x10);
            *(undefined *)((int)dataptr + 0xf) = (char)(uVar1 >> 0x18);
            uVar1 = ip_data.current_iphdr_src;
            *(undefined *)((int)dataptr + 0x10) = (char)ip_data.current_iphdr_src;
            *(undefined *)((int)dataptr + 0x11) = (char)(uVar1 >> 8);
            *(undefined *)((int)dataptr + 0x12) = (char)(uVar1 >> 0x10);
            *(undefined *)((int)dataptr + 0x13) = (char)(uVar1 >> 0x18);
            *puVar8 = 0;
            if (*(ushort *)(puVar8 + 2) < 0xfff8) {
              sVar7 = 8;
            }
            else {
              sVar7 = 9;
            }
            sVar7 = *(ushort *)(puVar8 + 2) + sVar7;
            puVar8[2] = (char)sVar7;
            puVar8[3] = (char)((ushort)sVar7 >> 8);
            *(undefined *)((int)dataptr + 8) = 0xff;
            *(undefined *)((int)dataptr + 10) = 0;
            *(undefined *)((int)dataptr + 0xb) = 0;
            uVar5 = inet_chksum(dataptr,(u16_t)(uVar2 >> 0x10));
            *(undefined *)((int)dataptr + 10) = (char)uVar5;
            *(undefined *)((int)dataptr + 0xb) = (char)(uVar5 >> 8);
            lwip_stats.icmp.xmit = lwip_stats.icmp.xmit + 1;
            ip4_output_if(p,(ip4_addr_t *)&ip_data.current_iphdr_dest,(ip4_addr_t *)0x0,-1,'\0',
                          '\x01',inp);
          }
LAB_2304767c:
          pbuf_free(p);
          return;
        }
      }
      else {
        uVar6 = (uint)p->tot_len + (uVar2 >> 0x10);
        if (((uint)p->tot_len <= (uVar6 & 0xffff)) &&
           (p_00 = pbuf_alloc(PBUF_LINK,(u16_t)(uVar6 * 0x10000 >> 0x10),PBUF_RAM),
           p_00 != (pbuf *)0x0)) {
          if (__n + 8 <= (uint)p_00->len) {
            memcpy(p_00->payload,__src,__n);
            uVar3 = pbuf_remove_header(p_00,__n);
            if ((CONCAT31(extraout_var_01,uVar3) == 0) &&
               (eVar4 = pbuf_copy(p_00,p), CONCAT31(extraout_var_02,eVar4) == 0)) {
              pbuf_free(p);
              p = p_00;
              goto LAB_230475c4;
            }
          }
          pbuf_free(p_00);
        }
      }
    }
    pbuf_free(p);
    lwip_stats.icmp.err = lwip_stats.icmp.err + 1;
  }
  return;
}



// WARNING: Type propagation algorithm not settling

void icmp_dest_unreach(pbuf *p,icmp_dur_type t)

{
  undefined *dataptr;
  u16_t uVar1;
  pbuf *p_00;
  netif *netif;
  void *pvVar2;
  ip4_addr_t iStack36;
  ip4_addr_t iphdr_src;
  
  p_00 = pbuf_alloc(PBUF_IP,0x24,PBUF_RAM);
  if (p_00 != (pbuf *)0x0) {
    dataptr = (undefined *)p_00->payload;
    pvVar2 = p->payload;
    *dataptr = 3;
    dataptr[1] = t;
    dataptr[4] = 0;
    dataptr[5] = 0;
    dataptr[6] = 0;
    dataptr[7] = 0;
    memcpy((void *)((int)p_00->payload + 8),p->payload,0x1c);
    iStack36 = (ip4_addr_t)((ip4_addr_t *)((int)pvVar2 + 0xc))->addr;
    netif = ip4_route(&iStack36);
    if (netif != (netif *)0x0) {
      dataptr[2] = 0;
      dataptr[3] = 0;
      uVar1 = inet_chksum(dataptr,p_00->len);
      dataptr[2] = (char)uVar1;
      dataptr[3] = (char)(uVar1 >> 8);
      lwip_stats.icmp.xmit = lwip_stats.icmp.xmit + 1;
      ip4_output_if(p_00,(ip4_addr_t *)0x0,&iStack36,-1,'\0','\x01',netif);
    }
    pbuf_free(p_00);
  }
  return;
}



u8_t * dhcp_server_option_find(u8_t *buf,u16_t len,u8_t option)

{
  undefined2 in_register_0000202e;
  byte *pbVar1;
  undefined3 in_register_00002031;
  
  pbVar1 = buf + CONCAT22(in_register_0000202e,len);
  while ((buf < pbVar1 && (*buf != 0xff))) {
    if ((uint)*buf == CONCAT31(in_register_00002031,option)) {
      return buf;
    }
    buf = buf + (uint)buf[1] + 2;
  }
  return (u8_t *)0x0;
}



// WARNING: Type propagation algorithm not settling

dhcp_client_node * dhcp_client_find_by_ip(uint8_t *ip)

{
  dhcp_client_node *pdVar1;
  void *in_a1;
  ip4_addr_t iStack20;
  uint32_t ipval;
  
  memcpy(&iStack20,in_a1,4);
  pdVar1 = *(dhcp_client_node **)ip;
  while ((pdVar1 != (dhcp_client_node *)0x0 && (iStack20 != (ip4_addr_t)(pdVar1->ipaddr).addr))) {
    pdVar1 = pdVar1->next;
  }
  return pdVar1;
}



// WARNING: Type propagation algorithm not settling

void dhcp_server_recv(void *arg,udp_pcb *pcb,pbuf *p,ip_addr_t *recv_addr,u16_t port)

{
  byte bVar1;
  u8_t uVar2;
  char *pcVar3;
  pbuf *p_to;
  u8_t *puVar4;
  u32_t n;
  u32_t uVar5;
  int iVar6;
  u16_t len;
  undefined4 *puVar7;
  dhcp_client_node *pdVar8;
  undefined4 *puVar9;
  undefined4 *puVar10;
  u8_t *buf;
  ip_addr_t iStack56;
  ip_addr_t addr;
  u32_t tmp;
  
  iStack56 = (ip_addr_t)recv_addr->addr;
  if (((p->len < 0x2c) || (p_to = pbuf_alloc(PBUF_TRANSPORT,0x5dc,PBUF_RAM), p_to == (pbuf *)0x0))
     || (p_to->tot_len < p->tot_len)) goto LAB_2304781c;
  pbuf_copy(p_to,p);
  pbuf_free(p);
  pcVar3 = (char *)p_to->payload;
  p = p_to;
  if (((*pcVar3 != '\x01') || (*(int *)(pcVar3 + 0xec) != 0x63538263)) ||
     (bVar1 = pcVar3[2], 6 < bVar1)) goto LAB_2304781c;
  buf = (u8_t *)(pcVar3 + 0xf0);
  len = (u16_t)(((uint)p_to->tot_len - 0xf0) * 0x10000 >> 0x10);
  puVar4 = dhcp_server_option_find(buf,len,'5');
  if (puVar4 == (u8_t *)0x0) goto LAB_2304781c;
  uVar2 = puVar4[2];
  if (uVar2 == '\x01') {
    pdVar8 = *(dhcp_client_node **)((int)arg + 0xc);
    while (pdVar8 != (dhcp_client_node *)0x0) {
      iVar6 = memcmp(pdVar8->chaddr,pcVar3 + 0x1c,(uint)bVar1);
      if (iVar6 == 0) goto LAB_23047970;
      pdVar8 = pdVar8->next;
    }
    puVar4 = dhcp_server_option_find(buf,len,'2');
    if ((puVar4 == (u8_t *)0x0) ||
       (pdVar8 = dhcp_client_find_by_ip((uint8_t *)((int)arg + 0xc)),
       pdVar8 == (dhcp_client_node *)0x0)) {
      while (pdVar8 = dhcp_client_find_by_ip((uint8_t *)((int)arg + 0xc)),
            pdVar8 != (dhcp_client_node *)0x0) {
        n = lwip_htonl(*(u32_t *)((int)arg + 0x18));
        n = n + 1;
        uVar5 = lwip_htonl(*(u32_t *)((int)arg + 0x14));
        if (uVar5 < n) {
          n = lwip_htonl(*(u32_t *)((int)arg + 0x10));
        }
        uVar5 = lwip_htonl(n);
        *(u32_t *)((int)arg + 0x18) = uVar5;
      }
      pdVar8 = (dhcp_client_node *)mem_malloc(0x14);
      if (pdVar8 == (dhcp_client_node *)0x0) goto LAB_2304781c;
      memcpy(pdVar8->chaddr,pcVar3 + 0x1c,(uint)(byte)pcVar3[2]);
      (pdVar8->ipaddr).addr = *(u32_t *)((int)arg + 0x18);
      pdVar8->next = *(dhcp_client_node **)((int)arg + 0xc);
      *(dhcp_client_node **)((int)arg + 0xc) = pdVar8;
    }
LAB_23047970:
    pdVar8->lease_end = 0x80510100;
    *pcVar3 = '\x02';
    pcVar3[3] = '\0';
    pcVar3[8] = '\0';
    pcVar3[9] = '\0';
    memcpy(pcVar3 + 0x14,(void *)(*(int *)((int)arg + 4) + 4),4);
    pcVar3[0xed] = -0x7e;
    pcVar3[0xec] = 'c';
    pcVar3[0xef] = 'c';
    pcVar3[0x2c] = '\0';
    pcVar3[0x6c] = '\0';
    pcVar3[0xee] = 'S';
    memcpy(pcVar3 + 0x10,&pdVar8->ipaddr,4);
    pcVar3[0xf0] = '5';
    pcVar3[0xf1] = '\x01';
    pcVar3[0xf2] = '\x02';
LAB_230479e0:
    pcVar3[0xf3] = '6';
    pcVar3[0xf4] = '\x04';
    memcpy(pcVar3 + 0xf5,(void *)(*(int *)((int)arg + 4) + 4),4);
    pcVar3[0xf9] = '3';
    pcVar3[0xfa] = '\x04';
    addr = 0x15180;
    memcpy(pcVar3 + 0xfb,&addr,4);
    pcVar3[0xff] = '\x01';
    pcVar3[0x100] = '\x04';
    memcpy(pcVar3 + 0x101,(void *)(*(int *)((int)arg + 4) + 8),4);
    pcVar3[0x105] = '\x06';
    pcVar3[0x106] = '\x04';
    memcpy(pcVar3 + 0x107,(void *)(*(int *)((int)arg + 4) + 4),4);
    pcVar3[0x10b] = '\x03';
    pcVar3[0x10c] = '\x04';
    memcpy(pcVar3 + 0x10d,(void *)(*(int *)((int)arg + 4) + 4),4);
    pcVar3[0x111] = -1;
    if (0x112 < p_to->tot_len) {
      len = 0x112;
LAB_23047a78:
      pbuf_realloc(p_to,len);
    }
  }
  else {
    if (uVar2 != '\x03') {
      if (uVar2 == '\a') {
        puVar7 = *(undefined4 **)((int)arg + 0xc);
        puVar10 = (undefined4 *)0x0;
        while (puVar9 = puVar7, puVar9 != (undefined4 *)0x0) {
          iVar6 = memcmp(puVar9 + 1,pcVar3 + 0x1c,(uint)(byte)pcVar3[2]);
          puVar7 = (undefined4 *)*puVar9;
          if (iVar6 == 0) {
            if (*(undefined4 **)((int)arg + 0xc) == puVar9) {
              *(undefined4 **)((int)arg + 0xc) = puVar7;
            }
            else {
              *(undefined4 **)puVar10 = puVar7;
            }
            mem_free(puVar9);
            break;
          }
          puVar7 = (undefined4 *)*puVar7;
          puVar10 = puVar9;
        }
      }
      goto LAB_2304781c;
    }
    pdVar8 = *(dhcp_client_node **)((int)arg + 0xc);
    while (pdVar8 != (dhcp_client_node *)0x0) {
      iVar6 = memcmp(pdVar8->chaddr,pcVar3 + 0x1c,(uint)bVar1);
      if (iVar6 == 0) goto LAB_23047bd2;
      pdVar8 = pdVar8->next;
    }
    puVar4 = dhcp_server_option_find(buf,len,'2');
    if ((puVar4 != (u8_t *)0x0) &&
       (pdVar8 = dhcp_client_find_by_ip((uint8_t *)((int)arg + 0xc)),
       pdVar8 != (dhcp_client_node *)0x0)) {
      iVar6 = memcmp(pdVar8->chaddr,pcVar3 + 0x1c,(uint)(byte)pcVar3[2]);
      if (iVar6 == 0) {
LAB_23047bd2:
        pdVar8->lease_end = 0x80510100;
        *pcVar3 = '\x02';
        pcVar3[3] = '\0';
        pcVar3[8] = '\0';
        pcVar3[9] = '\0';
        memcpy(pcVar3 + 0x14,(void *)(*(int *)((int)arg + 4) + 4),4);
        pcVar3[0xed] = -0x7e;
        pcVar3[0xec] = 'c';
        pcVar3[0xef] = 'c';
        pcVar3[0x2c] = '\0';
        pcVar3[0x6c] = '\0';
        pcVar3[0xee] = 'S';
        memcpy(pcVar3 + 0x10,&pdVar8->ipaddr,4);
        pcVar3[0xf0] = '5';
        pcVar3[0xf1] = '\x01';
        pcVar3[0xf2] = '\x05';
        goto LAB_230479e0;
      }
      puts("IP Found, but MAC address is NOT the same\r\n");
    }
    *pcVar3 = '\x02';
    pcVar3[3] = '\0';
    pcVar3[8] = '\0';
    pcVar3[9] = '\0';
    memcpy(pcVar3 + 0x14,(void *)(*(int *)((int)arg + 4) + 4),4);
    pcVar3[0xed] = -0x7e;
    pcVar3[0xee] = 'S';
    pcVar3[0xec] = 'c';
    pcVar3[0xef] = 'c';
    pcVar3[0x2c] = '\0';
    pcVar3[0x6c] = '\0';
    memset(pcVar3 + 0x10,0,4);
    pcVar3[0xf0] = '5';
    pcVar3[0xf1] = '\x01';
    pcVar3[0xf2] = '\x06';
    pcVar3[0xf3] = '6';
    pcVar3[0xf4] = '\x04';
    memcpy(pcVar3 + 0xf5,(void *)(*(int *)((int)arg + 4) + 4),4);
    pcVar3[0xf9] = -1;
    if (0xfa < p_to->tot_len) {
      len = 0xfa;
      goto LAB_23047a78;
    }
  }
  iStack56 = (ip_addr_t)0xffffffff;
  udp_sendto_if(pcb,p_to,&iStack56,port,*(netif **)((int)arg + 4));
LAB_2304781c:
  pbuf_free(p);
  return;
}



err_t dhcp_server_start(netif *netif,ip4_addr_t *start,ip4_addr_t *end)

{
  udp_pcb *puVar1;
  dhcp_server *__s;
  
  __s = lw_dhcp_server;
  while (__s != (dhcp_server *)0x0) {
    if (__s->netif == netif) {
      (__s->start).addr = start->addr;
      (__s->end).addr = end->addr;
      (__s->current).addr = start->addr;
      return '\0';
    }
    __s = __s->next;
  }
  __s = (dhcp_server *)mem_malloc(0x1c);
  if (__s != (dhcp_server *)0x0) {
    memset(__s,0,0x1c);
    __s->netif = netif;
    __s->node_list = (dhcp_client_node *)0x0;
    __s->next = lw_dhcp_server;
    lw_dhcp_server = __s;
    (__s->start).addr = start->addr;
    (__s->end).addr = end->addr;
    (__s->current).addr = start->addr;
    puVar1 = udp_new();
    __s->pcb = puVar1;
    if (puVar1 != (udp_pcb *)0x0) {
      puVar1->so_options = puVar1->so_options | 0x20;
      udp_bind(__s->pcb,&ip_addr_any,0x43);
      udp_recv(__s->pcb,dhcp_server_recv,__s);
      return '\0';
    }
  }
  return -1;
}



err_t dhcp_server_stop(netif *netif)

{
  dhcp_server *pdVar1;
  
  pdVar1 = lw_dhcp_server;
  while( true ) {
    if (pdVar1 == (dhcp_server *)0x0) {
      printf("[DHCP] [DHCPD] CRITICAL: no dhcp_server instance found\r\n");
      return -6;
    }
    if (pdVar1->netif == netif) break;
    pdVar1 = pdVar1->next;
  }
  if (pdVar1->pcb != (udp_pcb *)0x0) {
    udp_remove(pdVar1->pcb);
  }
  lw_dhcp_server = (dhcp_server *)0x0;
  mem_free(pdVar1);
  return '\0';
}



void dhcpd_start(netif *netif)

{
  err_t eVar1;
  char *__format;
  undefined3 extraout_var;
  ip4_addr_t *piVar2;
  ip4_addr_t iStack60;
  ip4_addr_t ip_start;
  ip4_addr_t ip_end;
  char str_tmp [20];
  
  dhcp_stop(netif);
  set_if(netif,"192.168.169.1","0.0.0.0","255.255.255.0");
  netif_set_up(netif);
  memcpy(&ip_end,"192.168.169.1",0xe);
  __format = strchr((char *)&ip_end,0x2e);
  if (((__format == (char *)0x0) || (__format = strchr(__format + 1,0x2e), __format == (char *)0x0))
     || (__format = strchr(__format + 1,0x2e), __format == (char *)0x0)) {
    piVar2 = &ip_end;
    __format = "[DHCP] DHCPD_SERVER_IP: %s error!\r\n";
  }
  else {
    sprintf(__format + 1,"%d",2);
    ip4addr_aton((char *)&ip_end,&iStack60);
    printf("[DHCP] ip_start: [%s]\r\n",&ip_end);
    sprintf(__format + 1,"%d",0xfe);
    ip4addr_aton((char *)&ip_end,&ip_start);
    printf("[DHCP] ip_start: [%s]\r\n",&ip_end);
    eVar1 = dhcp_server_start(netif,&iStack60,&ip_start);
    piVar2 = (ip4_addr_t *)CONCAT31(extraout_var,eVar1);
    if (piVar2 == (ip4_addr_t *)0x0) {
      return;
    }
    __format = "[DHCP] dhcp_server_start res: %d.\r\n";
  }
  printf(__format,piVar2);
  return;
}



void tcpc_entry(void *arg)

{
  int iVar1;
  int counter_shared;
  char *__s;
  int s;
  int iVar2;
  ssize_t sVar3;
  char *__format;
  undefined4 uStack68;
  int flag;
  sockaddr_in addr;
  
  iVar1 = counter_shared;
  counter_shared = counter_shared + 1;
  printf("[TCPC] [THREAD] [%d] host is %s, counter is %d\r\n",iVar1,arg,iVar1);
  __s = (char *)pvPortMalloc(0x400);
  if (__s == (char *)0x0) {
    printf("[TCPC] [THREAD] [%d] [%d] NO mem for holding data\r\n",iVar1,counter_shared);
  }
  else {
    s = lwip_socket(2,1,6);
    if (s < 0) {
      printf("[TCPC] [THREAD] [%d] [%d] create socket failed, ret is sock %d!\r\n",iVar1,
             counter_shared,s);
    }
    else {
      flag._1_1_ = '\x02';
      flag._2_2_ = lwip_htons(7000);
      ipaddr_addr((char *)arg);
      iVar2 = lwip_connect(s,(sockaddr *)&flag,0x10);
      if (iVar2 < 0) {
        printf("[TCPC] [THREAD] [%d] [%d] Connect failed!\n",iVar1,counter_shared);
      }
      else {
        printf("[TCPC] [THREAD] [%d] [%d] Connect to iperf server successful!\n",iVar1,
               counter_shared);
        uStack68 = 1;
        lwip_setsockopt(s,6,1,&uStack68,4);
        memset(__s,0,0x400);
        iVar2 = 0;
        while( true ) {
          snprintf(__s,0x400,"Data Seq %d",iVar2);
          sVar3 = lwip_write(s,__s,0x400);
          if (sVar3 < 0) break;
          printf("[TCPC] [THREAD] [%d] [%d] send success with ret %d, %s\r\n",iVar1,counter_shared,
                 sVar3,__s);
          sVar3 = lwip_read(s,__s,0x400);
          if (sVar3 < 0) {
            __format = "[TCPC] [THREAD] [%d] [%d] recv failed with ret %d\r\n";
            goto LAB_23047f9a;
          }
          printf("[TCPC] [THREAD] [%d] [%d] recv success with ret %d, %s\r\n",iVar1,counter_shared,
                 sVar3,__s);
          vTaskDelay(1000);
          iVar2 = iVar2 + 1;
        }
        __format = "[TCPC] [THREAD] [%d] [%d] send failed with ret %d\r\n";
LAB_23047f9a:
        printf(__format,iVar1,counter_shared,sVar3);
      }
      lwip_close(s);
    }
    vPortFree(__s);
  }
  vPortFree(arg);
  return;
}



void tcpclient_cmd(char *buf,int len,int argc,char **argv)

{
  size_t sVar1;
  char *__dest;
  char acStack48 [4];
  char names [32];
  
  if (argc == 2) {
    sVar1 = strlen(argv[1]);
    __dest = (char *)pvPortMalloc(sVar1 + 4);
    if (__dest == (char *)0x0) {
      printf("[TCPC] run out of mem for host alloc\r\n");
    }
    strcpy(__dest,argv[1]);
    counter_4093 = counter_4093 + '\x01';
    snprintf(acStack48,0x20,"tcp%u");
    aos_task_new(acStack48,tcpc_entry,__dest,0x800);
  }
  else {
    printf("[TCPC] host IP address is required. Ex. 192.168.1.1\r\n");
  }
  return;
}



int network_netutils_tcpclinet_cli_register(void)

{
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

void TCP_Server(void *pvParameters)

{
  uint *puVar1;
  u16_t uVar2;
  void *__s;
  uint uVar3;
  int iVar4;
  char *__format;
  TickType_t TVar5;
  int iVar6;
  size_t size;
  ssize_t sVar7;
  undefined2 extraout_var;
  TickType_t *pTVar8;
  int *piVar9;
  uint s;
  int iVar10;
  uint uVar11;
  uint s_00;
  uint *puVar12;
  socklen_t sStack208;
  uint32_t client_addrlen;
  int yes;
  _types_fd_set fdsr;
  timeval tv;
  sockaddr_in server_addr;
  sockaddr_in client_addr;
  int connect_time [5];
  int time_diff [5];
  int time_last [5];
  int client_fd [5];
  
  client_addrlen = 1;
  __s = pvPortMalloc(0x2800);
  memset(__s,0,0x2800);
  memset(time_last + 4,0,0x14);
  memset(connect_time + 4,0,0x14);
  memset(time_diff + 4,0,0x14);
  memset(client_addr.sin_zero + 4,0,0x14);
  uVar3 = lwip_socket(2,1,6);
  s_00 = uVar3 >> 0x1f;
  if ((int)uVar3 < 0) {
    printf("socket creat failed\r\n");
    vPortFree(__s);
    vTaskDelete((TaskHandle_t)0x0);
  }
  else {
    printf("socket:%d\r\n",0);
  }
  iVar4 = lwip_setsockopt(s_00,0xfff,4,&client_addrlen,4);
  if (iVar4 == -1) {
    __format = "setsockopt failed\r\n";
  }
  else {
    tv._13_1_ = 2;
    tv._14_2_ = lwip_htons(0x141e);
    server_addr._0_4_ = lwip_htonl(0);
    iVar4 = lwip_bind(s_00,(sockaddr *)&tv.field_0xc,0x10);
    if (iVar4 < 0) {
      __format = "bind failed\r\n";
    }
    else {
      iVar4 = lwip_listen(s_00,5);
      if (iVar4 < 0) {
        __format = "listen failed\r\n";
      }
      else {
        printf("We are waiting a connection on port 5150.\r\n");
        printf("Listen()...\r\n");
        sStack208 = 0x10;
        TVar5 = xTaskGetTickCount();
        iVar4 = 0;
        do {
          *(TickType_t *)((int)time_diff + iVar4 + 0x10) = TVar5;
          iVar6 = atoi((char *)pvParameters);
          *(int *)(client_addr.sin_zero + iVar4 + 4) = iVar6;
          iVar4 = iVar4 + 4;
        } while (iVar4 != 0x14);
        iVar4 = 0;
        uVar3 = s_00;
LAB_23048202:
        iVar6 = 0;
        do {
          *(undefined *)((int)&yes + iVar6) = 0;
          iVar6 = iVar6 + 1;
        } while (iVar6 != 8);
        fdsr.fds_bits[1] = 1;
        tv.tv_sec._0_4_ = 0;
        yes = yes | 1 << s_00;
        tv.tv_sec._4_4_ = 0;
        iVar6 = 0;
        do {
          puVar1 = (uint *)((int)time_last + iVar6 + 0x10);
          s = *puVar1;
          if (s != 0) {
            (&yes)[s >> 5] = 1 << (s & 0x1f) | (&yes)[s >> 5];
            TVar5 = xTaskGetTickCount();
            pTVar8 = (TickType_t *)((int)time_diff + iVar6 + 0x10);
            s = TVar5 - *pTVar8;
            *(uint *)((int)connect_time + iVar6 + 0x10) = s;
            if (999 < s) {
              *pTVar8 = TVar5;
              piVar9 = (int *)(client_addr.sin_zero + iVar6 + 4);
              iVar10 = *piVar9;
              *piVar9 = iVar10 + -1;
              if (iVar10 + -1 < 1) {
                iVar4 = iVar4 + -1;
                lwip_close(*puVar1);
                iVar10 = atoi((char *)pvParameters);
                uVar11 = *puVar1;
                *puVar1 = 0;
                *piVar9 = iVar10;
                s = uVar11 >> 5;
                (&yes)[s] = ~(1 << (uVar11 & 0x1f)) & (&yes)[s];
                printf("disconnect becase time out\r\n");
              }
            }
          }
          iVar6 = iVar6 + 4;
        } while (iVar6 != 0x14);
        iVar6 = lwip_select(uVar3 + 1,(_types_fd_set *)&yes,(_types_fd_set *)0x0,
                            (_types_fd_set *)0x0,(timeval *)(fdsr.fds_bits + 1));
        if (-1 < iVar6) {
          if (iVar6 != 0) {
            puVar12 = (uint *)(time_last + 4);
            iVar6 = 0;
            puVar1 = puVar12;
            do {
              s = *puVar1;
              if ((s != s_00) && ((1 << (s & 0x1f) & (&yes)[s >> 5]) != 0)) {
                TVar5 = xTaskGetTickCount();
                memset(__s,0,0x2800);
                size = lwip_recv(*puVar1,__s,0x2800,0);
                if ((int)size < 1) {
                  printf("recv failed:%d\r\n",size);
                  lwip_close(*puVar1);
                  iVar10 = atoi((char *)pvParameters);
                  *(int *)(client_addr.sin_zero + iVar6 * 4 + 4) = iVar10;
                  s = *puVar1 >> 5;
                  (&yes)[s] = ~(1 << (*puVar1 & 0x1f)) & (&yes)[s];
                }
                else {
                  iVar10 = atoi((char *)pvParameters);
                  *(int *)(client_addr.sin_zero + iVar6 * 4 + 4) = iVar10;
                  time_diff[iVar6 + 4] = TVar5;
                  printf("We successfully received %d bytes from %d client\r\n",size,iVar6);
                  printf("%s\r\n",__s);
                  sVar7 = lwip_send(*puVar1,__s,size,0);
                  if (0 < sVar7) {
                    printf("We successfully send %d bytes to %d client\r\n",sVar7,iVar6);
                    printf("\r\n");
                    goto LAB_2304837e;
                  }
                  printf("send failed\r\n",sVar7);
                  lwip_close(*puVar1);
                  iVar10 = atoi((char *)pvParameters);
                  s = *puVar1;
                  *(int *)(client_addr.sin_zero + iVar6 * 4 + 4) = iVar10;
                  uVar11 = s >> 5;
                  (&yes)[uVar11] = ~(1 << (s & 0x1f)) & (&yes)[uVar11];
                }
                *puVar1 = 0;
                iVar4 = iVar4 + -1;
              }
LAB_2304837e:
              iVar6 = iVar6 + 1;
              puVar1 = puVar1 + 1;
            } while (iVar6 != 5);
            if ((yes & 1 << s_00) != 0) {
              s = lwip_accept(s_00,(sockaddr *)(server_addr.sin_zero + 4),&sStack208);
              if ((int)s < 1) {
                printf("accept failed\r\n");
              }
              else {
                printf("new_sock:%d\r\n",s);
                __format = ip4addr_ntoa((ip4_addr_t *)&client_addr);
                uVar2 = lwip_htons(server_addr.sin_zero._6_2_);
                printf("We successfully got a connection from %s:%d\r\n",__format,
                       CONCAT22(extraout_var,uVar2));
                printf("We are waiting to receive data\r\n");
                if (iVar4 < 5) {
                  iVar6 = 0;
                  do {
                    if (*puVar12 == 0) {
                      TVar5 = xTaskGetTickCount();
                      time_diff[iVar6 + 4] = TVar5;
                      iVar10 = atoi((char *)pvParameters);
                      *(int *)(client_addr.sin_zero + iVar6 * 4 + 4) = iVar10;
                      time_last[iVar6 + 4] = s;
                      if ((int)uVar3 < (int)s) {
                        uVar3 = s;
                      }
                      iVar4 = iVar4 + 1;
                      printf("amount:%d\r\n",iVar4);
                      break;
                    }
                    iVar6 = iVar6 + 1;
                    puVar12 = puVar12 + 1;
                  } while (iVar6 != 5);
                }
                else {
                  printf("Max connections arrived!\r\n");
                  lwip_send(s,&DAT_23086a6c,4,0);
                  lwip_close(s);
                }
              }
            }
          }
          goto LAB_23048202;
        }
        __format = "select failed\r\n";
      }
    }
  }
  printf(__format);
  vPortFree(__s);
  lwip_close(s_00);
  vTaskDelete((TaskHandle_t)0x0);
  return;
}



void cmd_tcp_server(char *buf,int len,int argc,char **argv)

{
  if (argc != 2) {
    printf("Please Input Parameter!\r\n");
    return;
  }
  xTaskCreate(TCP_Server,"TCP Server",0x400,argv[1],0x14,(TaskHandle_t *)0x0);
  return;
}



int network_netutils_tcpserver_cli_register(void)

{
  return 0;
}



void iperf_server_udp_entry(char *name)

{
  size_t sVar1;
  char *__dest;
  
  sVar1 = strlen(name);
  __dest = (char *)pvPortMalloc(sVar1 + 1);
  strcpy(__dest,name);
  aos_task_new("ipus",iperf_server_udp,__dest,0x1000);
  return;
}



void iperf_client_udp_entry(char *name)

{
  size_t sVar1;
  char *__dest;
  
  sVar1 = strlen(name);
  __dest = (char *)pvPortMalloc(sVar1 + 4);
  strcpy(__dest,name);
  aos_task_new("ipu",iperf_client_udp,__dest,0x1000);
  return;
}



void iperf_server_entry(char *name)

{
  size_t sVar1;
  char *__dest;
  
  sVar1 = strlen(name);
  __dest = (char *)pvPortMalloc(sVar1 + 4);
  strcpy(__dest,name);
  aos_task_new("ips",iperf_server,__dest,0x1000);
  return;
}



void iperf_client_tcp_entry(char *name)

{
  size_t sVar1;
  char *__dest;
  
  sVar1 = strlen(name);
  __dest = (char *)pvPortMalloc(sVar1 + 4);
  strcpy(__dest,name);
  aos_task_new("ipc",iperf_client_tcp,__dest,0x1000);
  return;
}



// WARNING: Control flow encountered bad instruction data

void iperf_server_udp(void *arg)

{
  err_t eVar1;
  udp_pcb *pcb;
  undefined3 extraout_var;
  ip_addr_t iStack84;
  ip_addr_t source_ip;
  iperf_server_udp_ctx context;
  
  if (arg == (void *)0x0) {
    vAssertCalled();
  }
  pcb = udp_new();
  if (pcb == (udp_pcb *)0x0) {
    printf("Create UDP Control block failed!\r\n");
  }
  else {
    iStack84 = (ip_addr_t)ipaddr_addr((char *)arg);
    eVar1 = udp_bind(pcb,&iStack84,0x1389);
    if (CONCAT31(extraout_var,eVar1) == 0) {
      printf("bind UDP socket successfully!\r\n");
      memset(&source_ip,0,0x40);
                    // WARNING: Bad instruction - Truncating control flow here
      halt_baddata();
    }
    printf("Bind failed!\r\n");
    udp_remove(pcb);
  }
  vPortFree(arg);
  return;
}



// WARNING: Control flow encountered bad instruction data

void iperf_server_udp_recv_fn(void *arg,udp_pcb *pcb,pbuf *p,ip_addr_t *addr,u16_t port)

{
  char speed [32];
  
                    // WARNING: Bad instruction - Truncating control flow here
  halt_baddata();
}



// WARNING: Control flow encountered bad instruction data

void iperf_client_udp(void *arg)

{
  sockaddr_in laddr;
  sockaddr_in raddr;
  char speed [64];
  
                    // WARNING: Bad instruction - Truncating control flow here
  halt_baddata();
}



// WARNING: Control flow encountered bad instruction data

void iperf_server(void *arg)

{
  uint32_t sin_size;
  int flag;
  sockaddr_in server_addr;
  sockaddr_in client_addr;
  char speed [32];
  
                    // WARNING: Bad instruction - Truncating control flow here
  halt_baddata();
}



// WARNING: Control flow encountered bad instruction data

void iperf_client_tcp(void *arg)

{
  int flag;
  sockaddr_in addr;
  char speed [32];
  
                    // WARNING: Bad instruction - Truncating control flow here
  halt_baddata();
}



void ipus_test_cmd(char *buf,int len,int argc,char **argv)

{
  char *name;
  
  if (argc == 1) {
    printf("[NET] [IPC] [IPUS] Connecting with default address 0.0.0.0\r\n");
    name = "0.0.0.0";
  }
  else {
    if (argc != 2) {
      printf("[NET] [IPC] [IPUS] illegal address\r\n");
      return;
    }
    name = argv[1];
  }
  iperf_server_udp_entry(name);
  return;
}



void ipu_test_cmd(char *buf,int len,int argc,char **argv)

{
  char *name;
  
  if (argc == 1) {
    printf("[NET] [IPC] [IPU] Connecting with default address 192.168.11.1\r\n");
    name = "192.168.11.1";
  }
  else {
    if (argc != 2) {
      printf("[NET] [IPC] [IPU] illegal address\r\n");
      return;
    }
    name = argv[1];
  }
  iperf_client_udp_entry(name);
  return;
}



void ipc_test_cmd(char *buf,int len,int argc,char **argv)

{
  char *name;
  
  if (argc == 1) {
    printf("[NET] [IPC] [IPC] Connecting with default address 192.168.11.1\r\n");
    name = "192.168.11.1";
  }
  else {
    if (argc != 2) {
      printf("[NET] [IPC] [IPC] illegal address\r\n");
      return;
    }
    name = argv[1];
  }
  iperf_client_tcp_entry(name);
  return;
}



void ips_test_cmd(char *buf,int len,int argc,char **argv)

{
  char *name;
  
  if (argc == 1) {
    puts("[NET] [IPC] [IPS] Starting iperf server on 0.0.0.0\r\n");
    name = "192.168.11.1";
  }
  else {
    if (argc != 2) {
      printf("[NET] [IPC] [IPS] illegal address\r\n");
      return;
    }
    name = argv[1];
  }
  iperf_server_entry(name);
  return;
}



int network_netutils_iperf_cli_register(void)

{
  return 0;
}



void cmd_netstat(char *buf,int len,int argc,char **argv)

{
  tcpip_callback(stats_netstat,(void *)0x0);
  return;
}



int network_netutils_netstat_cli_register(void)

{
  return 0;
}



void ping_usage(void)

{
  printf("%s");
  return;
}



void ping_free(void *arg)

{
  u16_t uVar1;
  undefined2 extraout_var;
  utils_list_hdr *node;
  utils_memp_pool_t *pool;
  
  while (*(int *)((int)arg + 0x20) != 0) {
    uVar1 = lwip_htons(*(u16_t *)(*(int *)((int)arg + 0x20) + 4));
    printf("The sequence number %d timed out\r\n",CONCAT22(extraout_var,uVar1));
    pool = *(utils_memp_pool_t **)((int)arg + 0x18);
    node = utils_list_pop_front((utils_list *)((int)arg + 0x20));
    utils_memp_free(pool,node);
    *(char *)((int)arg + 0x12) = *(char *)((int)arg + 0x12) + -1;
  }
  raw_remove(*(raw_pcb **)((int)arg + 0x1c));
  utils_memp_deinit(*(utils_memp_pool_t **)((int)arg + 0x18));
  vPortFree(arg);
  return;
}



void ping_timeout(void *arg)

{
  undefined2 uVar1;
  utils_memp_pool_t *pool;
  undefined *dataptr;
  u16_t n;
  u16_t length;
  utils_list_hdr *list_hdr;
  pbuf *p;
  utils_list_hdr *puVar2;
  TickType_t TVar3;
  undefined2 extraout_var;
  uint uVar4;
  uint uVar5;
  
  while (*(int *)((int)arg + 0x20) != 0) {
    TVar3 = sys_now();
    if (TVar3 - *(int *)(*(int *)((int)arg + 0x20) + 8) <= (uint)*(ushort *)((int)arg + 0x10))
    break;
    length = lwip_htons(*(u16_t *)(*(int *)((int)arg + 0x20) + 4));
    printf("The sequence number %d timed out\r\n",CONCAT22(extraout_var,length));
    pool = *(utils_memp_pool_t **)((int)arg + 0x18);
    list_hdr = utils_list_pop_front((utils_list *)((int)arg + 0x20));
    utils_memp_free(pool,list_hdr);
    *(char *)((int)arg + 0x12) = *(char *)((int)arg + 0x12) + -1;
  }
  if (*(char *)((int)arg + 0x12) == '\n') {
    pool = *(utils_memp_pool_t **)((int)arg + 0x18);
    list_hdr = utils_list_pop_front((utils_list *)((int)arg + 0x20));
    utils_memp_free(pool,list_hdr);
    *(char *)((int)arg + 0x12) = *(char *)((int)arg + 0x12) + -1;
  }
  uVar5 = (uint)*(ushort *)((int)arg + 10) + 8;
  length = (u16_t)(uVar5 * 0x10000 >> 0x10);
  p = pbuf_alloc(PBUF_IP,length,PBUF_RAM);
  if (p != (pbuf *)0x0) {
    if ((p->len == p->tot_len) && (p->next == (pbuf *)0x0)) {
      dataptr = (undefined *)p->payload;
      list_hdr = (utils_list_hdr *)utils_memp_malloc(*(utils_memp_pool_t **)((int)arg + 0x18));
      if (list_hdr != (utils_list_hdr *)0x0) {
        *dataptr = 8;
        dataptr[1] = 0;
        dataptr[2] = 0;
        dataptr[3] = 0;
        uVar1 = *(undefined2 *)((int)arg + 0xe);
        dataptr[4] = (char)uVar1;
        dataptr[5] = (char)((ushort)uVar1 >> 8);
        n = (u16_t)(((uint)*(ushort *)((int)arg + 0xc) + 1) * 0x10000 >> 0x10);
        *(u16_t *)((int)arg + 0xc) = n;
        n = lwip_htons(n);
        dataptr[6] = (char)n;
        dataptr[7] = (char)(n >> 8);
        uVar4 = 0;
        while (uVar4 < (uVar5 & 0xffff) - 8) {
          dataptr[uVar4 + 8] = (char)uVar4;
          uVar4 = uVar4 + 1;
        }
        length = inet_chksum(dataptr,length);
        dataptr[2] = (char)length;
        dataptr[3] = (char)(length >> 8);
        *(undefined2 *)&list_hdr[1].next = *(undefined2 *)(dataptr + 6);
        raw_sendto(*(raw_pcb **)((int)arg + 0x1c),p,(ip_addr_t *)((int)arg + 0x14));
        puVar2 = (utils_list_hdr *)sys_now();
        list_hdr[2].next = puVar2;
        utils_list_push_back((utils_list *)((int)arg + 0x20),list_hdr);
        *(char *)((int)arg + 0x12) = *(char *)((int)arg + 0x12) + '\x01';
        *(int *)((int)arg + 4) = *(int *)((int)arg + 4) + 1;
      }
    }
    pbuf_free(p);
  }
  sys_timeout((uint)*(ushort *)((int)arg + 8),ping_timeout,arg);
  if (*(int *)((int)arg + 4) == *(int *)arg) {
    sys_untimeout(ping_timeout,arg);
    sys_timeout((uint)*(ushort *)((int)arg + 0x10),ping_free,arg);
    return;
  }
  return;
}



// WARNING: Variable defined which should be unmapped: echo_hdr
// WARNING: Could not reconcile some variable overlaps

u8_t ping_recv(void *arg,raw_pcb *pcb,pbuf *p,ip_addr_t *addr)

{
  byte bVar1;
  ushort uVar2;
  void **node;
  void **ppvVar3;
  u16_t uVar4;
  char *pcVar5;
  undefined2 extraout_var;
  TickType_t TVar6;
  byte bStack24;
  byte bStack23;
  icmp_echo_hdr echo_hdr;
  
  if (((uint)p->tot_len != (uint)*(ushort *)((int)arg + 10) + 0x1c) ||
     (*(u32_t *)((int)arg + 0x14) != addr->addr)) {
    return '\0';
  }
  memcpy(&bStack24,(void *)((int)p->payload + 0x14),8);
  bStack24 = bStack24 | bStack23;
  if (bStack24 == 0) {
    if ((((echo_hdr._0_2_ == *(short *)((int)arg + 0xe)) && (*(char *)((int)arg + 0x12) != '\0')) &&
        (node = *(void ***)((int)arg + 0x20), node != (void **)0x0)) &&
       (*(ushort *)(node + 1) <= echo_hdr.chksum)) {
      if (echo_hdr.chksum == *(ushort *)(node + 1)) {
        *(void **)((int)arg + 0x20) = *node;
      }
      else {
        do {
          ppvVar3 = node;
          node = (void **)*ppvVar3;
          if (node == (void **)0x0) {
            return '\0';
          }
        } while (*(ushort *)(node + 1) < echo_hdr.chksum);
        if (echo_hdr.chksum != *(ushort *)(node + 1)) {
          return '\0';
        }
        if (node == *(void ***)((int)arg + 0x24)) {
          *(void ***)((int)arg + 0x24) = ppvVar3;
        }
        node = (void **)*ppvVar3;
        *ppvVar3 = *node;
      }
      uVar2 = p->tot_len;
      pcVar5 = ip4addr_ntoa((ip4_addr_t *)((int)arg + 0x14));
      uVar4 = lwip_htons(echo_hdr.chksum);
      bVar1 = *(byte *)((int)p->payload + 8);
      TVar6 = sys_now();
      printf("%d bytes from %s: icmp_seq=%d ttl=%d time=%lu ms\r\n ",(uint)uVar2,pcVar5,
             CONCAT22(extraout_var,uVar4),(uint)bVar1,TVar6 - (int)node[2]);
      utils_memp_free(*(utils_memp_pool_t **)((int)arg + 0x18),node);
      *(char *)((int)arg + 0x12) = *(char *)((int)arg + 0x12) + -1;
      pbuf_free(p);
      bStack24 = 1;
    }
  }
  else {
    bStack24 = 0;
  }
  return (u8_t)bStack24;
}



ping_var * ping_api_init(u16_t interval,u16_t size,u32_t count,u16_t timeout,ip_addr_t *dest)

{
  ping_var *recv_arg;
  int iVar1;
  char *__format;
  raw_pcb *pcb;
  
  recv_arg = (ping_var *)pvPortMalloc(0x28);
  if (recv_arg == (ping_var *)0x0) {
    printf("mem malloc failed!\r\n");
  }
  else {
    recv_arg->total_count = count;
    recv_arg->data_size = size;
    recv_arg->requests_count = 0;
    recv_arg->interval = interval;
    recv_arg->seq_num = 0;
    iVar1 = bl_rand();
    recv_arg->id = (u16_t)iVar1;
    recv_arg->timeout = timeout;
    recv_arg->node_num = '\0';
    (recv_arg->dest).addr = dest->addr;
    iVar1 = utils_memp_init(&recv_arg->pool,0xc,10,'\x04');
    if (iVar1 == 0) {
      utils_list_init(&recv_arg->req_list);
      pcb = raw_new('\x01');
      if (pcb != (raw_pcb *)0x0) {
        recv_arg->pcb = pcb;
        raw_recv(pcb,ping_recv,recv_arg);
        raw_bind(pcb,&ip_addr_any);
        sys_timeout(0,ping_timeout,recv_arg);
        return recv_arg;
      }
      __format = "pcb null, maybe the pcb pool or sys_timeout pool is empty\r\n";
    }
    else {
      __format = "pool_alloc failed\n";
    }
    printf(__format);
    printf("ping_init failed\r\n");
    vPortFree(recv_arg);
  }
  return recv_arg;
}



// WARNING: Type propagation algorithm not settling

void ping_cmd(char *buf,int len,int argc,char **argv)

{
  uint uVar1;
  int iVar2;
  hostent *phVar3;
  char *__format;
  char *pcVar4;
  uint uVar5;
  uint uVar6;
  u32_t count;
  char *pcStack84;
  getopt_env_t getopt_env;
  
  uVar1 = 5000;
  utils_getopt_init((getopt_env_t *)&pcStack84,0);
  count = 0;
  uVar6 = 0x20;
  uVar5 = 1000;
  do {
    while( true ) {
      while( true ) {
        while( true ) {
          iVar2 = utils_getopt((getopt_env_t *)&pcStack84,argc,argv,":i:s:c:W:h");
          if (iVar2 == -1) {
            if (getopt_env.optarg + 1 == (char *)argc) {
              phVar3 = lwip_gethostbyname(argv[(int)getopt_env.optarg]);
              if (phVar3 == (hostent *)0x0) {
                printf("Failed to resolve domain name\r\n");
                return;
              }
              ping_api_init((u16_t)uVar5,(u16_t)uVar6,count,(u16_t)uVar1,
                            (ip_addr_t *)((ip_addr_t *)phVar3->h_addr_list)->addr);
              return;
            }
            printf("Need target address\r\n");
            goto LAB_23049676;
          }
          if (iVar2 != 99) break;
          count = atoi(pcStack84);
        }
        if (iVar2 < 100) break;
        if (iVar2 == 0x69) {
          uVar5 = atoi(pcStack84);
          uVar5 = uVar5 & 0xffff;
        }
        else {
          if (iVar2 == 0x73) {
            uVar6 = atoi(pcStack84);
            uVar6 = uVar6 & 0xffff;
          }
          else {
            if (iVar2 == 0x68) goto LAB_23049676;
          }
        }
      }
      if (iVar2 == 0x3f) {
        pcVar4 = *argv;
        __format = "%s: unknown option %c\r\n";
        goto LAB_23049664;
      }
      if (iVar2 != 0x57) break;
      uVar1 = atoi(pcStack84);
      uVar1 = uVar1 & 0xffff;
    }
  } while (iVar2 != 0x3a);
  pcVar4 = *argv;
  __format = "%s: %c requires an argument\r\n";
LAB_23049664:
  printf(__format,pcVar4,getopt_env.opterr);
LAB_23049676:
  ping_usage();
  return;
}



int network_netutils_ping_cli_register(void)

{
  return 0;
}



int dirent_type(void *addr)

{
  int iVar1;
  byte bVar2;
  
  bVar2 = *(byte *)((int)addr + 3) & 7;
  if ((*(byte *)((int)addr + 3) & 7) == 0) {
    iVar1 = 0;
  }
  else {
    iVar1 = 2;
    if ((bVar2 != 2) && (iVar1 = 3, bVar2 == 1)) {
      return 1;
    }
  }
  return iVar1;
}



uint32_t dirent_hardfh(void *addr)

{
  uint uVar1;
  
  uVar1 = *(uint *)addr;
  return uVar1 << 0x18 | uVar1 >> 0x18 & 0xfffffff0 | (uVar1 & 0xff00) << 8 | uVar1 >> 8 & 0xff00;
}



uint32_t dirent_childaddr(void *addr)

{
  uint uVar1;
  
  uVar1 = *(uint *)((int)addr + 4);
  return uVar1 << 0x18 | uVar1 >> 0x18 & 0xfffffff0 | (uVar1 & 0xff00) << 8 | uVar1 >> 8 & 0xff00;
}



uint32_t dirent_size(void *addr)

{
  uint uVar1;
  
  uVar1 = *(uint *)((int)addr + 8);
  return uVar1 << 0x18 | uVar1 >> 0x18 | (uVar1 & 0xff00) << 8 | uVar1 >> 8 & 0xff00;
}



int romfs_close(file_t *fp)

{
  fp->f_arg = (void *)0x0;
  fp->offset = 0;
  return -1;
}



int romfs_ioctl(file_t *fp,int cmd,ulong arg)

{
  size_t sVar1;
  uint32_t uVar2;
  int iVar3;
  void *pvVar4;
  
  iVar3 = -2;
  if (((fp != (file_t *)0x0) && (arg != 0)) && (iVar3 = -3, cmd == 1)) {
    pvVar4 = fp->f_arg;
    sVar1 = strlen((char *)((int)pvVar4 + 0x10));
    *(size_t *)arg = (sVar1 + 0x10 & 0xfffffff0) + 0x10 + (int)pvVar4;
    uVar2 = dirent_size(fp->f_arg);
    *(uint32_t *)(arg + 4) = uVar2;
    return 0;
  }
  return iVar3;
}



ssize_t romfs_read(file_t *fp,char *buf,size_t length)

{
  size_t sVar1;
  uint32_t uVar2;
  uint uVar3;
  void *__src;
  
  __src = fp->f_arg;
  sVar1 = strlen((char *)((int)__src + 0x10));
  uVar2 = dirent_size(fp->f_arg);
  uVar3 = fp->offset;
  if (uVar3 < uVar2) {
    __src = (void *)((sVar1 + 0x10 & 0xfffffff0) + 0x10 + uVar3 + (int)__src);
    if (uVar3 + length < uVar2) {
      memcpy(buf,__src,length);
      fp->offset = fp->offset + length;
    }
    else {
      length = uVar2 - uVar3;
      memcpy(buf,__src,length);
      fp->offset = uVar2;
    }
  }
  else {
    length = 0;
  }
  return length;
}



undefined4 file_info(char *param_1,char **param_2,char **param_3)

{
  char *addr;
  char *pcVar1;
  char *pcVar2;
  size_t __n;
  int iVar3;
  uint32_t uVar4;
  TickType_t TVar5;
  
  addr = *param_2;
  pcVar1 = *param_3;
  __n = strlen(param_1);
  if (__n < 0x41) {
    if (romfs_root == addr) {
      __n = strlen(addr + 0x10);
      addr = addr + (__n + 0x10 & 0xfffffff0) + 0x50;
    }
    do {
      iVar3 = dirent_type(addr);
      if (iVar3 == 1) {
        __n = strlen(param_1);
        iVar3 = memcmp(param_1,addr + 0x10,__n);
        if ((iVar3 == 0) && (__n = strlen(param_1), addr[__n + 0x10] == '\0')) {
          uVar4 = dirent_hardfh(addr);
          pcVar2 = romfs_root;
          if (uVar4 == 0) goto LAB_230498ec;
LAB_230498ea:
          pcVar1 = pcVar2 + uVar4;
LAB_230498ec:
          *param_2 = addr;
          *param_3 = pcVar1;
          return 0;
        }
      }
      else {
        if (iVar3 == 2) {
          __n = strlen(param_1);
          iVar3 = memcmp(param_1,addr + 0x10,__n);
          if ((iVar3 == 0) && (__n = strlen(param_1), pcVar2 = romfs_root, addr[__n + 0x10] == '\0')
             ) {
            uVar4 = dirent_hardfh(addr);
            goto LAB_230498ea;
          }
        }
        else {
          if (iVar3 != 0) {
            if (TrapNetCounter == 0) {
              TVar5 = xTaskGetTickCount();
            }
            else {
              TVar5 = xTaskGetTickCountFromISR();
            }
            iVar3 = dirent_type(addr);
            bl_printk("[%10u][%s: %s:%4d] addr_start = %p, dirent_type(addr_start) = %d\r\n",TVar5,
                      &DAT_23072bcc,"bl_romfs.c",0xe6,addr,iVar3);
            log_buf_out("bl_romfs.c",0xe7,addr,8,LOG_BUF_OUT_DATA_TYPE_HEX);
            if (TrapNetCounter == 0) {
              xTaskGetTickCount();
            }
            else {
              xTaskGetTickCountFromISR();
            }
            bl_printk("[%10u][%s: %s:%4d] unknow the dirent_type.\r\n",&DAT_23072bcc,"bl_romfs.c",
                      0xe8);
            return 0xffffffff;
          }
        }
      }
      pcVar2 = romfs_root;
      uVar4 = dirent_hardfh(addr);
      addr = pcVar2 + uVar4;
    } while (addr < pcVar1);
    if (TrapNetCounter == 0) {
      xTaskGetTickCount();
    }
    else {
      xTaskGetTickCountFromISR();
    }
    bl_printk(
              "[%10u][%s: %s:%4d] start >= end, not found path = %s, addr_start = %p, addr_end = %p\r\n"
              ,&DAT_23081ce8,"bl_romfs.c",0xef,param_1,addr,pcVar1);
  }
  return 0xffffffff;
}



int romfs_closedir(file_t *fp,aos_dir_t *dir)

{
  if (dir != (aos_dir_t *)0x0) {
    aos_free(dir);
    return 0;
  }
  return -1;
}



off_t romfs_lseek(file_t *fp,off_t off,int whence)

{
  size_t sVar1;
  uint32_t uVar2;
  
  if (fp == (file_t *)0x0) {
    return -1;
  }
  uVar2 = dirent_size(fp->f_arg);
  if (whence == 0) {
    if (off < 0) {
      printf("not support whence.\r\n");
      return -2;
    }
  }
  else {
    if (whence == 2) {
      sVar1 = uVar2;
      if (0 < off) {
        printf("not support whence.\r\n");
        return -3;
      }
    }
    else {
      if (whence != 1) {
        printf("not support whence.\r\n");
        return -4;
      }
      sVar1 = fp->offset;
    }
    off = off + sVar1;
    if (off < 0) goto LAB_23049a8a;
  }
  if ((uint)off <= uVar2) {
    fp->offset = off;
    return off;
  }
LAB_23049a8a:
  printf("not support whence.\r\n");
  return -5;
}



aos_dirent_t * romfs_readdir(file_t *fp,aos_dir_t *dir)

{
  uint32_t uVar1;
  int iVar2;
  char *pcVar3;
  uint uVar4;
  void *addr;
  void *addr_00;
  
  if (dir == (aos_dir_t *)0x0) {
    return (aos_dirent_t *)0x0;
  }
LAB_23049af6:
  do {
    pcVar3 = romfs_root;
    if ((void *)dir[2].dd_vfs_fd == (void *)0x0) {
      dir[2].dd_vfs_fd = dir[1].dd_vfs_fd;
    }
    else {
      addr_00 = (void *)dir[1].dd_rsv;
      if (addr_00 <= (void *)dir[2].dd_vfs_fd) {
        return (aos_dirent_t *)0x0;
      }
      while( true ) {
        addr = (void *)dir[2].dd_vfs_fd;
        if (addr_00 <= addr) {
          return (aos_dirent_t *)0x0;
        }
        uVar1 = dirent_hardfh(addr);
        if (uVar1 == 0) break;
        if (addr == (void *)0x0) {
          return (aos_dirent_t *)0x0;
        }
        iVar2 = dirent_type(addr);
        if (iVar2 - 1U < 2) break;
        *(char **)&dir[2].dd_vfs_fd = pcVar3 + uVar1;
      }
    }
    strncpy((char *)((int)&dir[3].dd_vfs_fd + 1),(char *)(dir[2].dd_vfs_fd + 0x10),0x40);
    addr_00 = (void *)dir[2].dd_vfs_fd;
    *(undefined *)((int)&dir[0xb].dd_vfs_fd + 1) = 0;
    uVar1 = dirent_hardfh(addr_00);
    if (uVar1 == 0) {
      pcVar3 = (char *)dir[1].dd_rsv;
    }
    else {
      pcVar3 = romfs_root + uVar1;
    }
    *(char **)&dir[2].dd_vfs_fd = pcVar3;
    uVar4 = dir[3].dd_vfs_fd & 0xffff00;
    if (uVar4 == 0x2e2e00) {
      if (*(char *)((int)&dir[3].dd_vfs_fd + 3) != '\0') goto LAB_23049b2c;
      goto LAB_23049af6;
    }
    if (uVar4 != 0x2e00) {
LAB_23049b2c:
      return (aos_dirent_t *)&dir[2].dd_rsv;
    }
  } while( true );
}



uint32_t dirent_file(char *path,void **p_addr_start_input,void **p_addr_end_input)

{
  bool bVar1;
  char *pcVar2;
  size_t __n;
  size_t sVar3;
  int iVar4;
  TickType_t TVar5;
  char *format;
  char *pcVar6;
  uint32_t uVar7;
  undefined4 uVar8;
  uint uVar9;
  char *pcStack124;
  char *addr_start;
  char *addr_end;
  char name [65];
  
  __n = strlen(path);
  sVar3 = strlen("/romfs");
  if (sVar3 <= __n) {
    __n = strlen("/romfs");
    iVar4 = memcmp(path,"/romfs",__n);
    if (iVar4 == 0) {
      __n = strlen("/romfs");
      path = path + __n;
      if (*path == '/') {
        path = path + 1;
LAB_23049c4c:
        bVar1 = false;
        uVar9 = *(uint *)(romfs_root + 8);
        pcStack124 = romfs_root;
        addr_start = romfs_root +
                     (uVar9 >> 8 & 0xff00 | uVar9 << 0x18 | uVar9 >> 0x18 | (uVar9 & 0xff00) << 8);
        do {
          if (*path == '\0') {
LAB_23049da2:
            *(char **)p_addr_start_input = pcStack124;
            *(char **)p_addr_end_input = addr_start;
            return 0;
          }
          pcVar6 = strchr(path,0x2f);
          pcVar2 = pcStack124;
          format = romfs_root;
          if (bVar1) {
            uVar7 = dirent_childaddr(pcStack124);
            pcStack124 = format + uVar7;
            if (pcVar2 == pcStack124) {
              return 0xfffffffe;
            }
          }
          if (pcVar6 == (char *)0x0) {
            __n = strlen(path);
            if (0x40 < __n) {
              if (TrapNetCounter == 0) {
                TVar5 = xTaskGetTickCount();
              }
              else {
                TVar5 = xTaskGetTickCountFromISR();
              }
              uVar8 = 0x138;
              format = "[%10u][%s: %s:%4d] name too long!\r\n";
              goto LAB_23049c0a;
            }
            iVar4 = file_info(path,&pcStack124,&addr_start);
            if (iVar4 != 0) {
              if (TrapNetCounter == 0) {
                TVar5 = xTaskGetTickCount();
              }
              else {
                TVar5 = xTaskGetTickCountFromISR();
              }
              bl_printk(
                        "[%10u][%s: %s:%4d] file info error, p_name = %s, addr_start = %p, addr_end = %p\r\n"
                        ,TVar5,&DAT_23081ce8,"bl_romfs.c",0x13c,path,pcStack124,addr_start);
              return 0xffffffff;
            }
            goto LAB_23049da2;
          }
          memset(&addr_end,0,0x41);
          memcpy(&addr_end,path,(size_t)(pcVar6 + -(int)path));
          iVar4 = file_info(&addr_end,&pcStack124,&addr_start);
          if (iVar4 != 0) {
            if (TrapNetCounter == 0) {
              TVar5 = xTaskGetTickCount();
            }
            else {
              TVar5 = xTaskGetTickCountFromISR();
            }
            uVar8 = 0x147;
            format = "[%10u][%s: %s:%4d] file info error.\r\n";
            goto LAB_23049c0a;
          }
          path = pcVar6 + 1;
          bVar1 = true;
        } while( true );
      }
      if (*path == '\0') goto LAB_23049c4c;
      if (TrapNetCounter == 0) {
        TVar5 = xTaskGetTickCount();
      }
      else {
        TVar5 = xTaskGetTickCountFromISR();
      }
      uVar8 = 0x11a;
    }
    else {
      if (TrapNetCounter == 0) {
        TVar5 = xTaskGetTickCount();
      }
      else {
        TVar5 = xTaskGetTickCountFromISR();
      }
      uVar8 = 0x115;
    }
    format = "[%10u][%s: %s:%4d] not support path.\r\n";
LAB_23049c0a:
    bl_printk(format,TVar5,&DAT_23072bcc,"bl_romfs.c",uVar8);
  }
  return 0xffffffff;
}



// WARNING: Variable defined which should be unmapped: end_addr

aos_dir_t * romfs_opendir(file_t *fp,char *path)

{
  char *pcVar1;
  TickType_t TVar2;
  aos_dir_t *__s;
  uint32_t uVar3;
  size_t sVar4;
  char *pcStack24;
  char *start_addr;
  char *end_addr;
  
  if (romfs_root == (char *)0x0) {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] romfs_root is null.\r\n",TVar2,&DAT_23072bcc,"bl_romfs.c",0x20d);
    return (aos_dir_t *)0x0;
  }
  __s = (aos_dir_t *)aos_malloc(0x5d);
  if (__s != (aos_dir_t *)0x0) {
    memset(__s,0,0x5d);
    uVar3 = dirent_file(path,&pcStack24,&start_addr);
    pcVar1 = romfs_root;
    if (uVar3 == 0) {
      if (pcStack24 == romfs_root) {
        sVar4 = strlen(pcStack24 + 0x10);
        *(char **)&__s[1].dd_vfs_fd = pcStack24 + (sVar4 + 0x10 & 0xfffffff0) + 0x50;
      }
      else {
        uVar3 = dirent_childaddr(pcStack24);
        if (uVar3 == 0) {
          return (aos_dir_t *)0x0;
        }
        *(char **)&__s[1].dd_vfs_fd = pcVar1 + uVar3;
      }
      __s[2].dd_vfs_fd = 0;
      *(char **)&__s[1].dd_rsv = start_addr;
      return __s;
    }
    aos_free(__s);
  }
  return (aos_dir_t *)0x0;
}



// WARNING: Variable defined which should be unmapped: end_addr

int romfs_stat(file_t *fp,char *path,stat *st)

{
  char *addr;
  uint32_t uVar1;
  TickType_t TVar2;
  int iVar3;
  uint32_t uVar4;
  mode_t mVar5;
  char *pcStack24;
  char *start_addr;
  char *end_addr;
  
  pcStack24 = (char *)0x0;
  start_addr = (char *)0x0;
  uVar1 = dirent_file(path,&pcStack24,&start_addr);
  addr = pcStack24;
  if (uVar1 == 0) {
    if (pcStack24 == romfs_root) {
      st->st_size = 0;
    }
    else {
      iVar3 = dirent_type(pcStack24);
      if (iVar3 == 1) {
        st->st_size = 0;
        mVar5 = 0x4000;
      }
      else {
        if (iVar3 != 2) {
          if (TrapNetCounter == 0) {
            TVar2 = xTaskGetTickCount();
          }
          else {
            TVar2 = xTaskGetTickCountFromISR();
          }
          bl_printk("[%10u][%s: %s:%4d] dirent_type err.\r\n",TVar2,&DAT_23081ce8,"bl_romfs.c",0x1fa
                   );
          return -2;
        }
        uVar4 = dirent_size(addr);
        st->st_size = uVar4;
        mVar5 = 0x8000;
      }
      st->st_mode = mVar5;
    }
  }
  else {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] dirent_file res = %d\r\n",TVar2,&DAT_23081ce8,"bl_romfs.c",0x1ea,
              uVar1);
    uVar1 = 0xffffffff;
  }
  return uVar1;
}



int romfs_open(file_t *fp,char *path,int flags)

{
  bool bVar1;
  char cVar2;
  TickType_t TVar3;
  char *format;
  size_t sVar4;
  size_t __n;
  int iVar5;
  uint32_t uVar6;
  undefined4 uVar7;
  size_t unaff_s4;
  void *pvStack40;
  char *start_addr;
  char *end_addr;
  
  if (romfs_root == (char *)0x0) {
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    uVar7 = 0x162;
    format = "[%10u][%s: %s:%4d] romfs_root is null.\r\n";
  }
  else {
    sVar4 = strlen(path);
    __n = strlen("/romfs");
    iVar5 = strncmp(path,"/romfs",__n);
    if (iVar5 == 0) {
      __n = 0;
      do {
        if (sVar4 == __n) {
          uVar6 = dirent_file(path,&pvStack40,&start_addr);
          if (uVar6 != 0) {
            return -2;
          }
          fp->offset = 0;
          fp->f_arg = pvStack40;
          return 0;
        }
        cVar2 = path[__n];
        if (0x19 < (byte)(cVar2 + 0x9fU)) {
          if (((byte)(cVar2 + 0xbfU) < 0x1a) || ((byte)(cVar2 - 0x30U) < 10)) {
            if (cVar2 == '/') goto LAB_2304a102;
          }
          else {
            if (cVar2 == '/') {
LAB_2304a102:
              if (__n == 0) {
                unaff_s4 = 0;
              }
              else {
                bVar1 = __n == unaff_s4;
                unaff_s4 = __n;
                if (bVar1) {
                  if (TrapNetCounter == 0) {
                    TVar3 = xTaskGetTickCount();
                  }
                  else {
                    TVar3 = xTaskGetTickCountFromISR();
                  }
                  uVar7 = 0x73;
                  format = "[%10u][%s: %s:%4d] format error.\r\n";
                  goto LAB_2304a048;
                }
              }
            }
            else {
              if ((cVar2 != '_') && (1 < (byte)(cVar2 - 0x2dU))) {
                if (TrapNetCounter == 0) {
                  TVar3 = xTaskGetTickCount();
                }
                else {
                  TVar3 = xTaskGetTickCountFromISR();
                }
                bl_printk("[%10u][%s: %s:%4d] is_path_ch. i = %d\r\n",TVar3,&DAT_23072bcc,
                          "bl_romfs.c",0x69,__n);
                goto LAB_2304a0d4;
              }
            }
          }
        }
        __n = __n + 1;
      } while( true );
    }
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    uVar7 = 0x61;
    format = "[%10u][%s: %s:%4d] format is error.\r\n";
LAB_2304a048:
    bl_printk(format,TVar3,&DAT_23072bcc,"bl_romfs.c",uVar7);
LAB_2304a0d4:
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    uVar7 = 0x168;
    format = "[%10u][%s: %s:%4d] path format is error.\r\n";
  }
  bl_printk(format,TVar3,&DAT_23072bcc,"bl_romfs.c",uVar7);
  return -1;
}



// WARNING: Variable defined which should be unmapped: info

int romfs_register(void)

{
  uint __s1;
  int iVar1;
  TickType_t TVar2;
  char *format;
  size_t __n;
  undefined4 uVar3;
  undefined auStack44 [4];
  bl_mtd_info_t info;
  
  iVar1 = bl_mtd_open("media",&handle_romfs,2);
  if (iVar1 == 0) {
    memset(auStack44,0,0x1c);
    bl_mtd_info(handle_romfs,(bl_mtd_info_t *)auStack44);
    __s1 = info.size;
    if ((void *)info.size == (void *)0x0) {
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      uVar3 = 0x8d;
      format = "[%10u][%s: %s:%4d] romfs has no XIP-Addr\r\n";
    }
    else {
      __n = strlen("-rom1fs-");
      iVar1 = memcmp((void *)__s1,"-rom1fs-",__n);
      if (iVar1 == 0) {
        romfs_root = (char *)info.size;
        log_buf_out("bl_romfs.c",0x98,(void *)info.size,0x40,LOG_BUF_OUT_DATA_TYPE_HEX);
        iVar1 = aos_register_fs("/romfs",&romfs_ops,(void *)0x0);
        return iVar1;
      }
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      uVar3 = 0x92;
      format = "[%10u][%s: %s:%4d] romfs magic is NOT correct\r\n";
    }
    bl_printk(format,TVar2,&DAT_23072bcc,"bl_romfs.c",uVar3);
  }
  else {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [EF] [PART] [XIP] error when get romfs partition %d\r\n",TVar2,
              &DAT_23072bcc,"bl_romfs.c",0x86,iVar1);
  }
  return -1;
}



void _startup_sntp(void *arg)

{
  puts("--------------------------------------- Start NTP now\r\n");
  sntp_setoperatingmode('\0');
  sntp_setservername('\0',"0.asia.pool.ntp.org");
  sntp_init();
  puts("--------------------------------------- Start NTP Done\r\n");
  return;
}



// WARNING: Could not reconcile some variable overlaps

void cmd_sntp_date(char *buf,int len,int argc,char **argv)

{
  uint32_t uStack44;
  uint32_t seconds;
  uint32_t frags;
  utils_time_date_t date;
  
  uStack44 = 0;
  seconds = 0;
  puts("test epoch from 1581863713 --->>>\r\n");
  puts("Should be Sunday, February 16, 2020 2:35:13 PM\r\n");
  utils_time_date_from_epoch(0x5e495321,&frags);
  printf("Date & time is: %u-%02u-%02u %02u:%02u:%02u (Day %u of week, Day %u of Year)\r\n",
         date._4_4_,(uint)date.ntp_minute,(uint)date.ntp_hour,(uint)(byte)frags,(uint)frags._1_1_,
         (uint)frags._2_1_,(uint)frags._3_1_);
  puts("SNTP GMT time is\r\n");
  sntp_get_time(&uStack44,&seconds);
  utils_time_date_from_epoch(uStack44,&frags);
  printf("Date & time is: %u-%02u-%02u %02u:%02u:%02u (Day %u of week, Day %u of Year)\r\n",
         date._4_4_,(uint)date.ntp_minute,(uint)date.ntp_hour,(uint)(byte)frags,(uint)frags._1_1_,
         (uint)frags._2_1_,(uint)frags._3_1_);
  return;
}



void cmd_sntp_time(char *buf,int len,int argc,char **argv)

{
  uint32_t uStack24;
  uint32_t seconds;
  uint32_t frags;
  
  uStack24 = 0;
  seconds = 0;
  sntp_get_time(&uStack24,&seconds);
  printf("[NTP] time is %lu:%lu\r\n",uStack24,seconds);
  return;
}



void cmd_sntp_start(char *buf,int len,int argc,char **argv)

{
  tcpip_callback(_startup_sntp,(void *)0x0);
  return;
}



int sntp_cli_init(void)

{
  return 0;
}



void sntp_retry(void *arg)

{
  uint uVar1;
  
  sys_timeout(sntp_retry_timeout,sntp_request,(void *)0x0);
  uVar1 = sntp_retry_timeout << 1;
  if ((uVar1 < 0x249f1) && (sntp_retry_timeout < uVar1)) {
    sntp_retry_timeout = uVar1;
  }
  return;
}



void sntp_recv(void *arg,udp_pcb *pcb,pbuf *p,ip_addr_t *addr,u16_t port)

{
  int iVar1;
  byte bVar2;
  u8_t uVar3;
  undefined3 extraout_var;
  u32_t uVar4;
  u32_t uVar5;
  uint uVar6;
  undefined2 in_register_0000203a;
  u32_t uStack40;
  sntp_timestamps timestamps;
  
  printf("SNTP time now\r\n",CONCAT22(in_register_0000203a,port));
  iVar1 = -0x10;
  if (p->tot_len == 0x30) {
    bVar2 = pbuf_get_at(p,0);
    if (sntp_opmode == '\0') {
      iVar1 = -3;
      if ((bVar2 & 7) != 4) goto LAB_2304a444;
    }
    else {
      iVar1 = -3;
      if ((sntp_opmode != '\x01') || ((bVar2 & 7) != 5)) goto LAB_2304a444;
    }
    uVar3 = pbuf_get_at(p,1);
    if (CONCAT31(extraout_var,uVar3) == 0) {
      printf("sntp_recv: Received Kiss-of-Death\r\n");
      iVar1 = 1;
    }
    else {
      pbuf_copy_partial(p,&uStack40,8,0x28);
      iVar1 = 0;
    }
  }
LAB_2304a444:
  pbuf_free(p);
  printf("Try process\r\n");
  if (iVar1 == 0) {
    uVar4 = lwip_htonl(uStack40);
    uVar5 = lwip_htonl(timestamps.xmit.sec);
    printf("Processing...\r\n");
    vTaskEnterCritical();
    ntp_frag = uVar5;
    ntp_sec = uVar4 + 0x7c558180;
    time_obtained = xTaskGetTickCount();
    uVar6 = ntp_frag / 1000 + ntp_sec * 1000;
    bl_sys_time_update(uVar6,(int)((ulonglong)ntp_sec * 1000 >> 0x20) +
                             (uint)(uVar6 < ntp_sec * 1000));
    vTaskExitCritical();
    printf("sntp_process: %ld, %lu us\r\n",uVar4 + 0x7c558180,
           (int)((ulonglong)uVar5 * 1000000 >> 0x20));
    sntp_servers[0].reachability = sntp_servers[0].reachability | 1;
    if (sntp_opmode == '\0') {
      sys_untimeout(sntp_retry,(void *)0x0);
      sys_untimeout(sntp_request,(void *)0x0);
      sntp_retry_timeout = 15000;
      sys_timeout(3600000,sntp_request,(void *)0x0);
    }
  }
  else {
    if ((iVar1 == 1) && (sntp_opmode == '\0')) {
      sntp_retry((void *)0x0);
    }
  }
  return;
}



void sntp_send_request(ip_addr_t *server_addr)

{
  undefined *__s;
  pbuf *p;
  code *handler;
  
  p = pbuf_alloc(PBUF_TRANSPORT,0x30,PBUF_RAM);
  if (p == (pbuf *)0x0) {
    handler = sntp_request;
  }
  else {
    __s = (undefined *)p->payload;
    memset(__s,0,0x30);
    *__s = 0x23;
    udp_sendto(sntp_pcb,p,server_addr,0x7b);
    pbuf_free(p);
    sntp_servers[0].reachability = sntp_servers[0].reachability << 1;
    handler = sntp_retry;
  }
  sys_timeout(15000,handler,(void *)0x0);
  return;
}



void sntp_request(void *arg)

{
  err_t eVar1;
  undefined3 extraout_var;
  ip_addr_t iStack20;
  ip_addr_t sntp_server_address;
  
  if (sntp_servers[0].name == (char *)0x0) {
    iStack20 = (ip_addr_t)sntp_servers[0].addr;
    if (sntp_servers[0].addr == 0) goto LAB_2304a64e;
  }
  else {
    sntp_servers[0].addr = 0;
    eVar1 = dns_gethostbyname(sntp_servers[0].name,&iStack20,sntp_dns_found,(void *)0x0);
    if (CONCAT31(extraout_var,eVar1) == -5) {
      return;
    }
    if (CONCAT31(extraout_var,eVar1) != 0) {
LAB_2304a64e:
      sys_timeout(15000,sntp_retry,(void *)0x0);
      return;
    }
  }
  sntp_servers[0].addr = (u32_t)iStack20;
  sntp_send_request(&iStack20);
  return;
}



void sntp_dns_found(char *hostname,ip_addr_t *ipaddr,void *arg)

{
  if (ipaddr != (ip_addr_t *)0x0) {
    sntp_servers[0].addr = ipaddr->addr;
    sntp_send_request(ipaddr);
    return;
  }
  sntp_retry((void *)0x0);
  return;
}



void sntp_init(void)

{
  udp_pcb *pcb;
  uint uVar1;
  
  if (sntp_pcb == (udp_pcb *)0x0) {
    sntp_pcb = udp_new_ip_type();
    printf("[SNTP] pcb isready, %p\r\n");
    if (sntp_pcb != (udp_pcb *)0x0) {
      udp_recv(sntp_pcb,sntp_recv,(void *)0x0);
      pcb = sntp_pcb;
      if (sntp_opmode == '\0') {
        sntp_retry_timeout = 15000;
        uVar1 = bl_rand();
        sys_timeout(uVar1 % 5000,sntp_request,(void *)0x0);
        return;
      }
      if (sntp_opmode == '\x01') {
        sntp_pcb->so_options = sntp_pcb->so_options | 0x20;
        udp_bind(pcb,&ip_addr_any,0x7b);
        return;
      }
    }
  }
  return;
}



void sntp_setoperatingmode(u8_t operating_mode)

{
  sntp_opmode = operating_mode;
  return;
}



int sntp_get_time(uint32_t *seconds,uint32_t *frags)

{
  TickType_t TVar1;
  int iVar2;
  uint uVar3;
  
  vTaskEnterCritical();
  if (ntp_sec == 0) {
    *seconds = 0;
    *frags = 0;
  }
  else {
    TVar1 = xTaskGetTickCount();
    iVar2 = TVar1 - time_obtained;
    uVar3 = ntp_frag / 1000;
    *seconds = iVar2 / 1000 + ntp_sec;
    *frags = iVar2 % 1000 + uVar3;
  }
  vTaskExitCritical();
  return 0;
}



void sntp_setservername(u8_t idx,char *server)

{
  undefined3 in_register_00002029;
  
  if (CONCAT31(in_register_00002029,idx) == 0) {
    sntp_servers[0].name = server;
  }
  return;
}



char * utils_bin2hex(char *dst,void *src,size_t count)

{
  char cVar1;
  byte *pbVar2;
  char *pcVar3;
  
  pbVar2 = (byte *)src;
  pcVar3 = dst;
  while (pbVar2 != (byte *)((int)src + count)) {
    cVar1 = "0123456789ABCDEF"[(uint)*pbVar2 & 0xf];
    *pcVar3 = "0123456789ABCDEF"[*pbVar2 >> 4];
    pcVar3[1] = cVar1;
    pbVar2 = pbVar2 + 1;
    pcVar3 = pcVar3 + 2;
  }
  return dst + count * 2;
}



void utils_sha256_init(iot_sha256_context *ctx)

{
  memset(ctx,0,0x6c);
  return;
}



void utils_sha256_free(iot_sha256_context *ctx)

{
  iot_sha256_context *piVar1;
  
  piVar1 = ctx + 1;
  if (ctx != (iot_sha256_context *)0x0) {
    while (ctx != piVar1) {
      *(undefined *)ctx->total = 0;
      ctx = (iot_sha256_context *)((int)ctx->total + 1);
    }
  }
  return;
}



void utils_sha256_starts(iot_sha256_context *ctx)

{
  ctx->state[0] = 0x6a09e667;
  ctx->state[1] = 0xbb67ae85;
  ctx->state[2] = 0x3c6ef372;
  ctx->state[3] = 0xa54ff53a;
  ctx->state[4] = 0x510e527f;
  ctx->state[5] = 0x9b05688c;
  ctx->state[6] = 0x1f83d9ab;
  ctx->total[0] = 0;
  ctx->total[1] = 0;
  ctx->state[7] = 0x5be0cd19;
  ctx->is224 = 0;
  return;
}



void utils_sha256_process(iot_sha256_context *ctx,uchar *data)

{
  uint uVar1;
  uint32_t *puVar2;
  byte *pbVar3;
  byte *pbVar4;
  uint uVar5;
  uint uVar6;
  uint32_t uVar7;
  uint uVar8;
  uint32_t *puVar9;
  uint uVar10;
  uint32_t *puVar11;
  uint uVar12;
  int iVar13;
  uint uVar14;
  uint uVar15;
  uint uVar16;
  uint uVar17;
  uint32_t *puVar18;
  uint uVar19;
  uint uVar20;
  uint uVar21;
  uint32_t *puVar22;
  uint uVar23;
  uint32_t uVar24;
  uint uVar25;
  uint32_t *puVar26;
  uint32_t uVar27;
  uint32_t local_150;
  uint32_t A [8];
  uint32_t W [64];
  
  puVar18 = &local_150;
  puVar9 = &local_150;
  puVar11 = ctx->state;
  do {
    uVar7 = *puVar11;
    puVar11 = puVar11 + 1;
    *puVar9 = uVar7;
    puVar9 = puVar9 + 1;
  } while ((uint32_t *)ctx->buffer != puVar11);
  puVar11 = A + 7;
  pbVar3 = data;
  puVar9 = puVar11;
  do {
    pbVar4 = pbVar3 + 4;
    *puVar9 = (uint)*pbVar3 << 0x18 | (uint)pbVar3[1] << 0x10 | (uint)pbVar3[3] |
              (uint)pbVar3[2] << 8;
    pbVar3 = pbVar4;
    puVar9 = puVar9 + 1;
  } while (data + 0x40 != pbVar4);
  puVar2 = K;
  puVar9 = K;
  puVar26 = puVar11;
  do {
    puVar22 = puVar9 + 8;
    iVar13 = A[6] + ((A[3] >> 6 | A[3] << 0x1a) ^ (A[3] >> 0xb | A[3] << 0x15) ^
                    (A[3] << 7 | A[3] >> 0x19)) + *puVar9 + *puVar26 + ((A[5] ^ A[4]) & A[3] ^ A[5])
    ;
    uVar12 = A[2] + iVar13;
    uVar14 = iVar13 + ((local_150 >> 2 | local_150 << 0x1e) ^ (local_150 >> 0xd | local_150 << 0x13)
                      ^ (local_150 << 10 | local_150 >> 0x16)) +
                      ((local_150 | A[0]) & A[1] | local_150 & A[0]);
    iVar13 = ((uVar12 >> 6 | uVar12 * 0x4000000) ^ (uVar12 >> 0xb | uVar12 * 0x200000) ^
             (uVar12 * 0x80 | uVar12 >> 0x19)) +
             A[5] + puVar9[1] + puVar26[1] + ((A[3] ^ A[4]) & uVar12 ^ A[4]);
    uVar1 = ((uVar14 >> 2 | uVar14 * 0x40000000) ^ (uVar14 >> 0xd | uVar14 * 0x80000) ^
            (uVar14 * 0x400 | uVar14 >> 0x16)) + ((uVar14 | local_150) & A[0] | uVar14 & local_150)
            + iVar13;
    uVar10 = A[1] + iVar13;
    iVar13 = ((uVar10 >> 6 | uVar10 * 0x4000000) ^ (uVar10 >> 0xb | uVar10 * 0x200000) ^
             (uVar10 * 0x80 | uVar10 >> 0x19)) +
             A[4] + puVar9[2] + puVar26[2] + ((uVar12 ^ A[3]) & uVar10 ^ A[3]);
    uVar5 = ((uVar1 >> 2 | uVar1 * 0x40000000) ^ (uVar1 >> 0xd | uVar1 * 0x80000) ^
            (uVar1 * 0x400 | uVar1 >> 0x16)) + ((uVar14 | uVar1) & local_150 | uVar14 & uVar1) +
            iVar13;
    uVar8 = A[0] + iVar13;
    iVar13 = ((uVar8 >> 6 | uVar8 * 0x4000000) ^ (uVar8 >> 0xb | uVar8 * 0x200000) ^
             (uVar8 * 0x80 | uVar8 >> 0x19)) +
             A[3] + puVar9[3] + puVar26[3] + ((uVar12 ^ uVar10) & uVar8 ^ uVar12);
    uVar16 = ((uVar5 >> 2 | uVar5 * 0x40000000) ^ (uVar5 >> 0xd | uVar5 * 0x80000) ^
             (uVar5 * 0x400 | uVar5 >> 0x16)) + ((uVar1 | uVar5) & uVar14 | uVar1 & uVar5) + iVar13;
    uVar6 = local_150 + iVar13;
    iVar13 = ((uVar6 >> 6 | uVar6 * 0x4000000) ^ (uVar6 >> 0xb | uVar6 * 0x200000) ^
             (uVar6 * 0x80 | uVar6 >> 0x19)) +
             uVar12 + puVar9[4] + puVar26[4] + ((uVar10 ^ uVar8) & uVar6 ^ uVar10);
    A[2] = ((uVar16 >> 2 | uVar16 * 0x40000000) ^ (uVar16 >> 0xd | uVar16 * 0x80000) ^
           (uVar16 * 0x400 | uVar16 >> 0x16)) + ((uVar5 | uVar16) & uVar1 | uVar5 & uVar16) + iVar13
    ;
    A[6] = uVar14 + iVar13;
    iVar13 = ((A[6] >> 6 | A[6] * 0x4000000) ^ (A[6] >> 0xb | A[6] * 0x200000) ^
             (A[6] * 0x80 | A[6] >> 0x19)) +
             uVar10 + puVar9[5] + puVar26[5] + ((uVar8 ^ uVar6) & A[6] ^ uVar8);
    A[1] = ((A[2] >> 2 | A[2] * 0x40000000) ^ (A[2] >> 0xd | A[2] * 0x80000) ^
           (A[2] * 0x400 | A[2] >> 0x16)) + ((uVar16 | A[2]) & uVar5 | uVar16 & A[2]) + iVar13;
    A[5] = uVar1 + iVar13;
    iVar13 = ((A[5] >> 6 | A[5] * 0x4000000) ^ (A[5] >> 0xb | A[5] * 0x200000) ^
             (A[5] * 0x80 | A[5] >> 0x19)) +
             uVar8 + puVar9[6] + puVar26[6] + ((uVar6 ^ A[6]) & A[5] ^ uVar6);
    A[0] = ((A[1] >> 2 | A[1] * 0x40000000) ^ (A[1] >> 0xd | A[1] * 0x80000) ^
           (A[1] * 0x400 | A[1] >> 0x16)) + ((A[2] | A[1]) & uVar16 | A[2] & A[1]) + iVar13;
    A[4] = uVar5 + iVar13;
    iVar13 = ((A[4] >> 6 | A[4] * 0x4000000) ^ (A[4] >> 0xb | A[4] * 0x200000) ^
             (A[4] * 0x80 | A[4] >> 0x19)) +
             uVar6 + puVar9[7] + puVar26[7] + ((A[6] ^ A[5]) & A[4] ^ A[6]);
    A[3] = uVar16 + iVar13;
    local_150 = ((A[0] >> 2 | A[0] * 0x40000000) ^ (A[0] >> 0xd | A[0] * 0x80000) ^
                (A[0] * 0x400 | A[0] >> 0x16)) + ((A[1] | A[0]) & A[2] | A[1] & A[0]) + iVar13;
    puVar9 = puVar22;
    puVar26 = puVar26 + 8;
  } while (puVar22 != K + 0x10);
  do {
    uVar19 = puVar11[0xe];
    uVar1 = puVar11[1];
    uVar20 = puVar11[0xf];
    uVar23 = ((uVar19 << 0xf | uVar19 >> 0x11) ^ (uVar19 << 0xd | uVar19 >> 0x13) ^ uVar19 >> 10) +
             puVar11[9] + *puVar11 +
             ((uVar1 >> 7 | uVar1 << 0x19) ^ (uVar1 << 0xe | uVar1 >> 0x12) ^ uVar1 >> 3);
    uVar10 = puVar11[3];
    iVar13 = A[6] + ((A[3] >> 6 | A[3] << 0x1a) ^ (A[3] >> 0xb | A[3] << 0x15) ^
                    (A[3] << 7 | A[3] >> 0x19)) + ((A[5] ^ A[4]) & A[3] ^ A[5]) + puVar2[0x10] +
                    uVar23;
    uVar16 = A[2] + iVar13;
    uVar15 = iVar13 + ((local_150 >> 2 | local_150 << 0x1e) ^ (local_150 >> 0xd | local_150 << 0x13)
                      ^ (local_150 << 10 | local_150 >> 0x16)) +
                      ((local_150 | A[0]) & A[1] | local_150 & A[0]);
    uVar6 = puVar11[2];
    uVar1 = ((uVar20 << 0xf | uVar20 >> 0x11) ^ (uVar20 << 0xd | uVar20 >> 0x13) ^ uVar20 >> 10) +
            uVar1 + puVar11[10] +
            ((uVar6 >> 7 | uVar6 << 0x19) ^ (uVar6 << 0xe | uVar6 >> 0x12) ^ uVar6 >> 3);
    iVar13 = ((A[3] ^ A[4]) & uVar16 ^ A[4]) + A[5] + puVar2[0x11] + uVar1 +
             ((uVar16 >> 6 | uVar16 * 0x4000000) ^ (uVar16 >> 0xb | uVar16 * 0x200000) ^
             (uVar16 * 0x80 | uVar16 >> 0x19));
    uVar5 = ((uVar15 >> 2 | uVar15 * 0x40000000) ^ (uVar15 >> 0xd | uVar15 * 0x80000) ^
            (uVar15 * 0x400 | uVar15 >> 0x16)) + ((local_150 | uVar15) & A[0] | local_150 & uVar15)
            + iVar13;
    uVar14 = A[1] + iVar13;
    uVar6 = ((uVar23 * 0x8000 | uVar23 >> 0x11) ^ (uVar23 * 0x2000 | uVar23 >> 0x13) ^ uVar23 >> 10)
            + uVar6 + puVar11[0xb] +
            ((uVar10 >> 7 | uVar10 << 0x19) ^ (uVar10 << 0xe | uVar10 >> 0x12) ^ uVar10 >> 3);
    iVar13 = ((A[3] ^ uVar16) & uVar14 ^ A[3]) + A[4] + puVar2[0x12] + uVar6 +
             ((uVar14 >> 6 | uVar14 * 0x4000000) ^ (uVar14 >> 0xb | uVar14 * 0x200000) ^
             (uVar14 * 0x80 | uVar14 >> 0x19));
    puVar11[0x11] = uVar1;
    uVar8 = ((uVar5 >> 2 | uVar5 * 0x40000000) ^ (uVar5 >> 0xd | uVar5 * 0x80000) ^
            (uVar5 * 0x400 | uVar5 >> 0x16)) + ((uVar15 | uVar5) & local_150 | uVar15 & uVar5) +
            iVar13;
    uVar12 = A[0] + iVar13;
    uVar25 = puVar11[4];
    uVar1 = ((uVar1 * 0x8000 | uVar1 >> 0x11) ^ (uVar1 * 0x2000 | uVar1 >> 0x13) ^ uVar1 >> 10) +
            uVar10 + puVar11[0xc] +
            ((uVar25 >> 7 | uVar25 << 0x19) ^ (uVar25 << 0xe | uVar25 >> 0x12) ^ uVar25 >> 3);
    iVar13 = ((uVar16 ^ uVar14) & uVar12 ^ uVar16) + A[3] + puVar2[0x13] + uVar1 +
             ((uVar12 >> 6 | uVar12 * 0x4000000) ^ (uVar12 >> 0xb | uVar12 * 0x200000) ^
             (uVar12 * 0x80 | uVar12 >> 0x19));
    uVar17 = ((uVar8 >> 2 | uVar8 * 0x40000000) ^ (uVar8 >> 0xd | uVar8 * 0x80000) ^
             (uVar8 * 0x400 | uVar8 >> 0x16)) + ((uVar5 | uVar8) & uVar15 | uVar5 & uVar8) + iVar13;
    uVar10 = local_150 + iVar13;
    puVar11[0x12] = uVar6;
    uVar21 = puVar11[5];
    uVar25 = ((uVar6 * 0x8000 | uVar6 >> 0x11) ^ (uVar6 * 0x2000 | uVar6 >> 0x13) ^ uVar6 >> 10) +
             uVar25 + puVar11[0xd] +
             ((uVar21 >> 7 | uVar21 << 0x19) ^ (uVar21 << 0xe | uVar21 >> 0x12) ^ uVar21 >> 3);
    iVar13 = ((uVar10 >> 6 | uVar10 * 0x4000000) ^ (uVar10 >> 0xb | uVar10 * 0x200000) ^
             (uVar10 * 0x80 | uVar10 >> 0x19)) +
             ((uVar14 ^ uVar12) & uVar10 ^ uVar14) + uVar16 + puVar2[0x14] + uVar25;
    A[2] = ((uVar17 >> 2 | uVar17 * 0x40000000) ^ (uVar17 >> 0xd | uVar17 * 0x80000) ^
           (uVar17 * 0x400 | uVar17 >> 0x16)) + ((uVar8 | uVar17) & uVar5 | uVar8 & uVar17) + iVar13
    ;
    A[6] = uVar15 + iVar13;
    uVar6 = puVar11[6];
    puVar11[0x13] = uVar1;
    uVar16 = ((uVar1 * 0x8000 | uVar1 >> 0x11) ^ (uVar1 * 0x2000 | uVar1 >> 0x13) ^ uVar1 >> 10) +
             uVar19 + uVar21 +
             ((uVar6 >> 7 | uVar6 << 0x19) ^ (uVar6 << 0xe | uVar6 >> 0x12) ^ uVar6 >> 3);
    iVar13 = ((A[6] >> 6 | A[6] * 0x4000000) ^ (A[6] >> 0xb | A[6] * 0x200000) ^
             (A[6] * 0x80 | A[6] >> 0x19)) +
             ((uVar12 ^ uVar10) & A[6] ^ uVar12) + uVar14 + puVar2[0x15] + uVar16;
    A[1] = ((A[2] >> 2 | A[2] * 0x40000000) ^ (A[2] >> 0xd | A[2] * 0x80000) ^
           (A[2] * 0x400 | A[2] >> 0x16)) + ((uVar17 | A[2]) & uVar8 | uVar17 & A[2]) + iVar13;
    A[5] = uVar5 + iVar13;
    uVar1 = puVar11[7];
    puVar11[0x14] = uVar25;
    uVar7 = uVar20 + uVar6 +
            ((uVar25 * 0x8000 | uVar25 >> 0x11) ^ (uVar25 * 0x2000 | uVar25 >> 0x13) ^ uVar25 >> 10)
            + ((uVar1 >> 7 | uVar1 << 0x19) ^ (uVar1 << 0xe | uVar1 >> 0x12) ^ uVar1 >> 3);
    iVar13 = ((A[5] >> 6 | A[5] * 0x4000000) ^ (A[5] >> 0xb | A[5] * 0x200000) ^
             (A[5] * 0x80 | A[5] >> 0x19)) +
             ((uVar10 ^ A[6]) & A[5] ^ uVar10) + uVar12 + puVar2[0x16] + uVar7;
    A[0] = ((A[1] >> 2 | A[1] * 0x40000000) ^ (A[1] >> 0xd | A[1] * 0x80000) ^
           (A[1] * 0x400 | A[1] >> 0x16)) + ((A[2] | A[1]) & uVar17 | A[2] & A[1]) + iVar13;
    A[4] = uVar8 + iVar13;
    uVar5 = puVar11[8];
    puVar11[0x15] = uVar16;
    puVar11[0x10] = uVar23;
    uVar27 = puVar2[0x17];
    uVar24 = uVar23 + uVar1 +
             ((uVar16 * 0x8000 | uVar16 >> 0x11) ^ (uVar16 * 0x2000 | uVar16 >> 0x13) ^ uVar16 >> 10
             ) + ((uVar5 >> 7 | uVar5 << 0x19) ^ (uVar5 << 0xe | uVar5 >> 0x12) ^ uVar5 >> 3);
    puVar11[0x17] = uVar24;
    iVar13 = ((A[4] >> 6 | A[4] * 0x4000000) ^ (A[4] >> 0xb | A[4] * 0x200000) ^
             (A[4] * 0x80 | A[4] >> 0x19)) +
             uVar10 + uVar27 + uVar24 + ((A[6] ^ A[5]) & A[4] ^ A[6]);
    puVar11[0x16] = uVar7;
    puVar11 = puVar11 + 8;
    A[3] = uVar17 + iVar13;
    local_150 = ((A[0] >> 2 | A[0] * 0x40000000) ^ (A[0] >> 0xd | A[0] * 0x80000) ^
                (A[0] * 0x400 | A[0] >> 0x16)) + ((A[1] | A[0]) & A[2] | A[1] & A[0]) + iVar13;
    puVar2 = puVar2 + 8;
  } while (W + 0x2f != puVar11);
  puVar9 = ctx->state;
  do {
    iVar13 = *puVar18;
    puVar11 = puVar9 + 1;
    puVar18 = (uint32_t *)((int *)puVar18 + 1);
    *puVar9 = *puVar9 + iVar13;
    puVar9 = puVar11;
  } while ((uint32_t *)ctx->buffer != puVar11);
  return;
}



void utils_sha256_update(iot_sha256_context *ctx,uchar *input,uint32_t ilen)

{
  size_t __n;
  uint uVar1;
  uint uVar2;
  uint __n_00;
  
  uVar2 = ctx->total[0] & 0x3f;
  uVar1 = ctx->total[0] + ilen;
  ctx->total[0] = uVar1;
  if (uVar1 < ilen) {
    ctx->total[1] = ctx->total[1] + 1;
  }
  uVar1 = ilen;
  if ((uVar2 != 0) && (__n_00 = 0x40 - uVar2, __n_00 <= ilen)) {
    memcpy(ctx->buffer + uVar2,input,__n_00);
    ilen = (ilen - 0x40) + uVar2;
    utils_sha256_process(ctx,ctx->buffer);
    input = input + __n_00;
    uVar2 = 0;
    uVar1 = ilen;
  }
  while (0x3f < ilen) {
    utils_sha256_process(ctx,input + (uVar1 - ilen));
    ilen = ilen - 0x40;
  }
  __n = (uVar1 >> 6) * -0x40 + uVar1;
  if (__n == 0) {
    return;
  }
  memcpy(ctx->buffer + uVar2,input + (uVar1 & 0xffffffc0),__n);
  return;
}



void utils_sha256_update(iot_sha256_context *ctx,uchar *input,uint32_t ilen)

{
  if (ilen != 0) {
    utils_sha256_update(ctx,input,ilen);
    return;
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

void utils_sha256_finish(iot_sha256_context *ctx,uint8_t *output)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  uchar uStack24;
  undefined uStack23;
  ushort uStack22;
  uchar msglen [8];
  
  uVar1 = ctx->total[0];
  uVar2 = ctx->total[1] << 3;
  uStack24 = (uchar)(uVar2 >> 0x18);
  uStack23 = (undefined)(uVar2 >> 0x10);
  uStack22 = (ushort)(uVar2 >> 8) & 0xff | (ushort)((uVar2 | uVar1 >> 0x1d) << 8);
  msglen[0] = (uchar)((uVar1 << 3) >> 0x18);
  msglen[1] = (uchar)((uVar1 << 3) >> 0x10);
  msglen._2_2_ = (ushort)((uVar1 << 0x13) >> 0x18) | (ushort)(uVar1 << 0xb);
  if ((uVar1 & 0x3f) < 0x38) {
    iVar3 = 0x38;
  }
  else {
    iVar3 = 0x78;
  }
  utils_sha256_update(ctx,sha256_padding,iVar3 - (uVar1 & 0x3f));
  utils_sha256_update(ctx,&uStack24,8);
  *output = *(uint8_t *)((int)ctx->state + 3);
  output[1] = (uint8_t)*(undefined2 *)((int)ctx->state + 2);
  output[2] = (uint8_t)(ctx->state[0] >> 8);
  output[3] = (uint8_t)ctx->state[0];
  output[4] = *(uint8_t *)((int)ctx->state + 7);
  output[5] = (uint8_t)*(undefined2 *)((int)ctx->state + 6);
  output[6] = (uint8_t)(ctx->state[1] >> 8);
  output[7] = (uint8_t)ctx->state[1];
  output[8] = *(uint8_t *)((int)ctx->state + 0xb);
  output[9] = (uint8_t)*(undefined2 *)((int)ctx->state + 10);
  output[10] = (uint8_t)(ctx->state[2] >> 8);
  output[0xb] = (uint8_t)ctx->state[2];
  output[0xc] = *(uint8_t *)((int)ctx->state + 0xf);
  output[0xd] = (uint8_t)*(undefined2 *)((int)ctx->state + 0xe);
  output[0xe] = (uint8_t)(ctx->state[3] >> 8);
  output[0xf] = (uint8_t)ctx->state[3];
  output[0x10] = *(uint8_t *)((int)ctx->state + 0x13);
  output[0x11] = (uint8_t)*(undefined2 *)((int)ctx->state + 0x12);
  output[0x12] = (uint8_t)(ctx->state[4] >> 8);
  output[0x13] = (uint8_t)ctx->state[4];
  output[0x14] = *(uint8_t *)((int)ctx->state + 0x17);
  output[0x15] = (uint8_t)*(undefined2 *)((int)ctx->state + 0x16);
  output[0x16] = (uint8_t)(ctx->state[5] >> 8);
  output[0x17] = (uint8_t)ctx->state[5];
  output[0x18] = *(uint8_t *)((int)ctx->state + 0x1b);
  output[0x19] = (uint8_t)*(undefined2 *)((int)ctx->state + 0x1a);
  output[0x1a] = (uint8_t)(ctx->state[6] >> 8);
  output[0x1b] = (uint8_t)ctx->state[6];
  if (ctx->is224 == 0) {
    output[0x1c] = *(uint8_t *)((int)ctx->state + 0x1f);
    output[0x1d] = (uint8_t)*(undefined2 *)((int)ctx->state + 0x1e);
    output[0x1e] = (uint8_t)(ctx->state[7] >> 8);
    output[0x1f] = (uint8_t)ctx->state[7];
  }
  return;
}



void bl_printk(char *format,...)

{
  undefined4 in_a1;
  undefined4 in_a2;
  undefined4 in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list args;
  undefined4 uStack28;
  undefined4 uStack24;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  undefined4 uStack8;
  undefined4 uStack4;
  
  if (sys_log_all_enable != false) {
    uStack28 = in_a1;
    uStack24 = in_a2;
    uStack20 = in_a3;
    uStack16 = in_a4;
    uStack12 = in_a5;
    uStack8 = in_a6;
    uStack4 = in_a7;
    vprint(format,&uStack28);
  }
  return;
}



int log_buf_out(char *file,int line,void *inbuf,int len,LOG_BUF_OUT_DATA_TYPE_T type)

{
  bool bVar1;
  int iVar2;
  int iVar3;
  TickType_t TVar4;
  char *__format;
  uint uVar5;
  undefined3 in_register_00002039;
  int iVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  void *pvVar10;
  
  iVar6 = CONCAT31(in_register_00002039,type);
  if (len < 1) {
    return -1;
  }
  iVar9 = len / 0x32;
  if (len % 0x32 == 0) {
    pvVar10 = (void *)(iVar9 * 0x32 + (int)inbuf);
    while (pvVar10 != inbuf) {
      iVar7 = 0;
      iVar9 = 0;
      do {
        uVar5 = (uint)*(byte *)((int)inbuf + iVar9);
        if (iVar6 == 1) {
          uVar5 = SEXT14((char)*(byte *)((int)inbuf + iVar9));
          __format = "%3d ";
        }
        else {
          __format = "%3u ";
          if (iVar6 != 2) {
            __format = "%02x ";
          }
        }
        iVar3 = sprintf(log_buf + iVar7,__format,uVar5);
        iVar9 = iVar9 + 1;
        iVar7 = iVar7 + iVar3;
      } while (iVar9 != 0x32);
      if (TrapNetCounter == 0) {
        TVar4 = xTaskGetTickCount();
      }
      else {
        TVar4 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] %.*s\r\n",TVar4,&UNK_2308789c,file,line,iVar7,log_buf);
      inbuf = (void *)((int)inbuf + 0x32);
    }
  }
  else {
    iVar7 = 0;
    do {
      iVar3 = 0;
      iVar8 = 0;
      if (iVar9 == iVar7) {
        do {
          uVar5 = (uint)*(byte *)((int)inbuf + iVar8);
          if (iVar6 == 1) {
            uVar5 = SEXT14((char)*(byte *)((int)inbuf + iVar8));
            __format = "%3d ";
          }
          else {
            __format = "%3u ";
            if (iVar6 != 2) {
              __format = "%02x ";
            }
          }
          iVar2 = sprintf(log_buf + iVar3,__format,uVar5);
          iVar8 = iVar8 + 1;
          iVar3 = iVar3 + iVar2;
        } while (len % 0x32 != iVar8);
      }
      else {
        do {
          uVar5 = (uint)*(byte *)((int)inbuf + iVar8);
          if (iVar6 == 1) {
            uVar5 = SEXT14((char)*(byte *)((int)inbuf + iVar8));
            __format = "%3d ";
          }
          else {
            __format = "%3u ";
            if (iVar6 != 2) {
              __format = "%02x ";
            }
          }
          iVar2 = sprintf(log_buf + iVar3,__format,uVar5);
          iVar8 = iVar8 + 1;
          iVar3 = iVar3 + iVar2;
        } while (iVar8 != 0x32);
      }
      if (TrapNetCounter == 0) {
        TVar4 = xTaskGetTickCount();
      }
      else {
        TVar4 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] %.*s\r\n",TVar4,&UNK_2308789c,file,line,iVar3,log_buf);
      inbuf = (void *)((int)inbuf + 0x32);
      bVar1 = iVar7 < iVar9;
      iVar7 = iVar7 + 1;
    } while (bVar1);
  }
  return 0;
}



int utils_dns_domain_get(uint8_t *records,uint8_t *buf,int *len)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  
  iVar6 = *len;
  uVar3 = (uint)*records;
  iVar2 = 1;
  iVar5 = 0;
  while ((iVar4 = iVar5, iVar1 = iVar2, uVar3 != 0 && (0 < iVar6))) {
    uVar3 = uVar3 - 1;
    buf[iVar4] = records[iVar1];
    iVar2 = iVar1 + 1;
    iVar5 = iVar4 + 1;
    iVar6 = iVar6 + -1;
    if ((uVar3 == 0) && (iVar6 != 0)) {
      buf[iVar5] = '.';
      uVar3 = (uint)records[iVar2];
      iVar2 = iVar1 + 2;
      iVar5 = iVar4 + 2;
    }
  }
  *len = iVar4;
  return 0;
}



void utils_list_init(utils_list *list)

{
  list->first = (utils_list_hdr *)0x0;
  list->last = (utils_list_hdr *)0x0;
  return;
}



void utils_list_push_back(utils_list *list,utils_list_hdr *list_hdr)

{
  if (list->first == (utils_list_hdr *)0x0) {
    list->first = list_hdr;
  }
  else {
    list->last->next = list_hdr;
  }
  list->last = list_hdr;
  list_hdr->next = (utils_list_hdr *)0x0;
  return;
}



utils_list_hdr * utils_list_pop_front(utils_list *list)

{
  utils_list_hdr *puVar1;
  
  puVar1 = list->first;
  if (puVar1 != (utils_list_hdr *)0x0) {
    list->first = puVar1->next;
  }
  return puVar1;
}



void utils_hexdump(void *mem,uint len)

{
  uint uVar1;
  int iVar2;
  uint c;
  int iVar3;
  uint uVar4;
  uint uVar5;
  
  iVar2 = 0;
  if ((len & 0xf) != 0) {
    iVar2 = 0x10 - (len & 0xf);
  }
  uVar4 = 0;
  while (uVar1 = uVar4, iVar2 + len != uVar1) {
    if ((uVar1 & 0xf) == 0) {
      printf("0x%06x: ",uVar1);
    }
    if (uVar1 < len) {
      printf("%02x ",(uint)*(byte *)((int)mem + uVar1));
    }
    else {
      printf("   ");
    }
    uVar4 = uVar1 + 1;
    if ((uVar1 & 0xf) == 0xf) {
      uVar5 = uVar1 - 0xf;
      iVar3 = 0x11;
      if (uVar4 < uVar5) {
        iVar3 = 1;
      }
      while (uVar5 != (uVar1 - 0x10) + iVar3) {
        c = 0x20;
        if ((uVar5 < len) && (c = (uint)*(byte *)((int)mem + uVar5), (_ctype_[c + 1] & 0x97) == 0))
        {
          c = 0x2e;
        }
        bl_putchar(c);
        uVar5 = uVar5 + 1;
      }
      puts("\r\n");
    }
  }
  return;
}



undefined4 utils_time_date_from_epoch(uint param_1,undefined *param_2)

{
  byte bVar1;
  byte bVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  undefined4 uStack20;
  undefined2 uStack16;
  undefined uStack14;
  char cStack13;
  undefined4 uStack12;
  undefined4 uStack8;
  undefined4 uStack4;
  
  uStack12 = 0x1e1f1c1f;
  uStack8 = 0x1f1f1e1f;
  uStack4 = 0x1f1e1f1e;
  uStack20 = 0x60504;
  uStack16 = 0x201;
  uStack14 = 3;
  *(undefined2 *)(param_2 + 6) = 0;
  param_2[2] = (char)(param_1 % 0x3c);
  param_2[1] = (char)((param_1 / 0x3c) % 0x3c);
  *param_2 = (char)((param_1 / 0xe10) % 0x18);
  uVar5 = param_1 / 0x15180;
  *(uint *)(param_2 + 0xc) = uVar5;
  param_2[3] = *(undefined *)((int)&uStack20 + uVar5 % 7);
  uVar4 = 0x7b4;
  uVar3 = param_1 / 0x1e13380 + 0x7b2;
  *(uint *)(param_2 + 8) = uVar3;
  while (uVar4 < uVar3) {
    if (((int)uVar4 % 100 != 0) || ((int)uVar4 % 400 == 0)) {
      param_2[6] = param_2[6] + '\x01';
    }
    uVar4 = uVar4 + 4;
  }
  uVar3 = (uVar5 - (byte)param_2[6]) / 0x16d + 0x7b2;
  *(uint *)(param_2 + 8) = uVar3;
  uVar4 = (uVar5 - (byte)param_2[6]) % 0x16d + 1;
  *(uint *)(param_2 + 0x10) = uVar4;
  if ((((uVar3 & 3) == 0) && (uVar3 % 100 != 0)) || (uVar3 % 400 == 0)) {
    uStack12 = 0x1e1f1d1f;
    param_2[7] = 1;
  }
  param_2[5] = 0;
  uVar3 = 0;
  while( true ) {
    bVar1 = param_2[5];
    if ((0xb < bVar1) || (uVar4 <= uVar3)) break;
    bVar2 = *(byte *)((int)&uStack12 + (uint)bVar1);
    param_2[5] = bVar1 + 1;
    uVar3 = uVar3 + bVar2 & 0xffff;
  }
  param_2[4] = (char)uVar4 - ((char)uVar3 - (&cStack13)[(uint)bVar1]);
  return 0;
}



int utils_getopt_init(getopt_env_t *env,int opterr)

{
  if (env != (getopt_env_t *)0x0) {
    env->optarg = (char *)0x0;
    env->optind = 1;
    env->opterr = opterr;
    env->optopt = 0;
    env->__optpos = 0;
    return 0;
  }
  return -1;
}



int utils_getopt(getopt_env_t *env,int argc,char **argv,char *optstring)

{
  byte bVar1;
  byte bVar2;
  int iVar3;
  uint uVar4;
  char **ppcVar5;
  int iVar6;
  byte *pbVar7;
  char *pcVar8;
  byte *pbVar9;
  
  if (env == (getopt_env_t *)0x0) {
    return -1;
  }
  iVar6 = env->optind;
  if (argc <= iVar6) {
    return -1;
  }
  ppcVar5 = argv + iVar6;
  pcVar8 = *ppcVar5;
  if (pcVar8 == (char *)0x0) {
    return -1;
  }
  if (*pcVar8 != '-') {
    if (*optstring == '-') {
      env->optind = iVar6 + 1;
      env->optarg = *ppcVar5;
      return 1;
    }
    return -1;
  }
  if (pcVar8[1] == '\0') {
    return -1;
  }
  if ((pcVar8[1] == '-') && (pcVar8[2] == '\0')) {
    env->optind = iVar6 + 1;
    return -1;
  }
  if (env->__optpos == 0) {
    env->__optpos = 1;
  }
  pbVar9 = (byte *)(*ppcVar5 + env->__optpos);
  bVar1 = *pbVar9;
  uVar4 = (uint)bVar1;
  iVar3 = (uint)(bVar1 != 0) + env->__optpos;
  env->__optpos = iVar3;
  if ((*ppcVar5)[iVar3] == '\0') {
    env->optind = iVar6 + 1;
    env->__optpos = 0;
  }
  if ((*optstring - 0x2bU & 0xfd) == 0) {
    optstring = optstring + 1;
  }
  iVar6 = 0;
  do {
    iVar3 = iVar6 + 1;
    pbVar7 = (byte *)(optstring + iVar6);
    bVar2 = *pbVar7;
    if (bVar2 == 0) {
      if (bVar1 == 0) goto LAB_2304bcb4;
      goto LAB_2304bc96;
    }
    iVar6 = iVar3;
  } while (uVar4 != (uint)bVar2);
  if (bVar1 == 0x3a) {
LAB_2304bc96:
    env->optopt = uVar4;
    if (*optstring == ':') {
      return 0x3f;
    }
    if (env->opterr == 0) {
      return 0x3f;
    }
    bVar1 = *pbVar9;
    pcVar8 = *argv;
    iVar6 = -0x728;
  }
  else {
LAB_2304bcb4:
    if (optstring[iVar3] != ':') {
      return uVar4;
    }
    env->optarg = (char *)0x0;
    iVar6 = env->__optpos;
    if ((pbVar7[2] != 0x3a) || (iVar6 != 0)) {
      iVar3 = env->optind;
      env->optind = iVar3 + 1;
      pcVar8 = argv[iVar3];
      env->__optpos = 0;
      env->optarg = pcVar8 + iVar6;
    }
    if (env->optind <= argc) {
      return uVar4;
    }
    env->optopt = uVar4;
    if (*optstring == ':') {
      return 0x3a;
    }
    if (env->opterr == 0) {
      return 0x3f;
    }
    bVar1 = *pbVar9;
    pcVar8 = *argv;
    iVar6 = -0x708;
  }
  printf("ERROR failed! net_set_(non)block() returned -0x%x\r\n" + iVar6 + 0x14,pcVar8,(uint)bVar1);
  return 0x3f;
}



// WARNING: Variable defined which should be unmapped: pTemp

void Bl_F_fast(uchar *digest,uchar *digest1,char *password,uchar *ssid,int ssidlength,int count,
              uchar *output)

{
  int iVar1;
  size_t key_len;
  byte *pbVar2;
  uchar *puVar3;
  byte *pbVar4;
  int iVar5;
  int iStack40;
  int tmpLen;
  uchar *pTemp;
  
  key_len = strlen(password);
  iStack40 = ssidlength + 4;
  tmpLen = (int)digest;
  memcpy(digest,ssid,ssidlength);
  puVar3 = digest + ssidlength;
  *puVar3 = '\0';
  puVar3[3] = (uchar)count;
  puVar3[1] = '\0';
  puVar3[2] = '\0';
  bl_sha_mutex_take();
  utils_hmac_sha1_fast((uchar **)&tmpLen,&iStack40,1,(uchar *)password,key_len,digest1,0x14);
  memcpy(output,digest1,0x14);
  iVar1 = 0xfff;
  tmpLen = (int)digest1;
  do {
    iStack40 = 0x14;
    utils_hmac_sha1_fast((uchar **)&tmpLen,&iStack40,1,(uchar *)password,key_len,digest,0x14);
    memcpy(digest1,digest,0x14);
    iVar5 = 0;
    do {
      pbVar2 = output + iVar5;
      pbVar4 = digest + iVar5;
      iVar5 = iVar5 + 1;
      *pbVar2 = *pbVar4 ^ *pbVar2;
    } while (iVar5 != 0x14);
    iVar1 = iVar1 + -1;
  } while (iVar1 != 0);
  bl_sha_mutex_give();
  return;
}



int utils_wifi_psk_cal_fast_bin(char *password,uchar *ssid,int ssidlength,uchar *output)

{
  size_t sVar1;
  int iVar2;
  uchar auStack88 [4];
  uchar digest1 [20];
  uchar digest [36];
  
  sVar1 = strlen(password);
  if (sVar1 < 0x40) {
    iVar2 = -1;
    if (ssidlength < 0x21) {
      Bl_F_fast(digest1 + 0x10,auStack88,password,ssid,ssidlength,2,output);
      memcpy(output + 0x14,output,0xc);
      Bl_F_fast(digest1 + 0x10,auStack88,password,ssid,ssidlength,1,output);
      iVar2 = 0;
    }
  }
  else {
    iVar2 = -1;
  }
  return iVar2;
}



// WARNING: Type propagation algorithm not settling

int utils_memp_init(utils_memp_pool_t **pool,uint16_t node_size,uint16_t pool_cap,uint8_t align_req)

{
  uint uVar1;
  uint uVar2;
  utils_memp_pool_t *puVar3;
  int iVar4;
  undefined2 in_register_0000202e;
  undefined2 in_register_00002032;
  uint32_t uVar5;
  utils_memp_node uVar6;
  uint32_t uVar7;
  utils_memp_node uVar8;
  uint uVar9;
  
  uVar5 = CONCAT22(in_register_00002032,pool_cap);
  uVar9 = (uint)align_req + 3 & 0xfc;
  uVar2 = CONCAT22(in_register_0000202e,node_size) + 3 + uVar9 & -uVar9 & 0xffff;
  uVar1 = -uVar9 & uVar9 + 0x1f;
  puVar3 = (utils_memp_pool_t *)pvPortMalloc(uVar2 * uVar5 + uVar1);
  if (puVar3 == (utils_memp_pool_t *)0x0) {
    iVar4 = -1;
  }
  else {
    uVar8 = (utils_memp_node)((int)&puVar3->node_size + uVar1);
    *(utils_memp_node *)&((utils_memp_node *)&puVar3->first_node)->next = uVar8;
    puVar3->node_size = CONCAT22(in_register_0000202e,node_size);
    puVar3->pool_cap = uVar5;
    puVar3->pool_size = 0;
    puVar3->align_req = (uint8_t)uVar9;
    puVar3->padded_node_size = uVar2;
    puVar3->mem = (utils_memp_node *)0x0;
    uVar7 = 0;
    uVar6 = (utils_memp_node)0x0;
    while (uVar7 != uVar5) {
      *(utils_memp_node *)uVar8 = uVar6;
      uVar7 = uVar7 + 1 & 0xffff;
      uVar6 = uVar8;
      uVar8 = (utils_memp_node)((int)uVar8 + uVar2);
    }
    *(utils_memp_node *)&((utils_memp_node *)&puVar3->mem)->next = uVar6;
    *(utils_memp_node *)&((utils_memp_node *)&puVar3->last_node)->next = uVar6;
    *pool = puVar3;
    iVar4 = 0;
  }
  return iVar4;
}



int utils_memp_deinit(utils_memp_pool_t *pool)

{
  if (pool != (utils_memp_pool_t *)0x0) {
    vPortFree(pool);
    return 0;
  }
  return -1;
}



void * utils_memp_malloc(utils_memp_pool_t *pool)

{
  utils_memp_node *puVar1;
  utils_memp_node *puVar2;
  
  puVar2 = (utils_memp_node *)0x0;
  if (pool != (utils_memp_pool_t *)0x0) {
    puVar2 = (utils_memp_node *)0x0;
    if ((pool->pool_size != pool->pool_cap) &&
       (puVar2 = pool->mem, puVar2 != (utils_memp_node *)0x0)) {
      puVar1 = puVar2->next;
      pool->pool_size = pool->pool_size + 1;
      pool->mem = puVar1;
      puVar2->next = (utils_memp_node *)0xa5;
      puVar2 = puVar2 + 1;
    }
  }
  return puVar2;
}



int utils_memp_free(utils_memp_pool_t *pool,void *node)

{
  utils_memp_node *puVar1;
  
  puVar1 = (utils_memp_node *)((int)node + -4);
  if ((((pool != (utils_memp_pool_t *)0x0) && (puVar1 != (utils_memp_node *)0x0)) &&
      (pool->pool_size != 0)) &&
     ((((utils_memp_node *)pool->first_node <= puVar1 &&
       (puVar1 <= (utils_memp_node *)pool->last_node)) &&
      (((uint)((int)puVar1 - (int)(utils_memp_node *)pool->first_node) % pool->padded_node_size == 0
       && (*(int *)((int)node + -4) == 0xa5)))))) {
    *(utils_memp_node **)((int)node + -4) = pool->mem;
    pool->mem = puVar1;
    pool->pool_size = pool->pool_size - 1;
    return 0;
  }
  return -1;
}



int utils_tlv_bl_pack_auto(uint32_t *buf,int buf_sz,uint16_t type,void *arg1)

{
  undefined2 in_register_00002032;
  uint32_t uVar1;
  int iVar2;
  
  if (CONCAT22(in_register_00002032,type) == 1) {
    uVar1 = (uint32_t)*(byte *)arg1;
  }
  else {
    if (CONCAT22(in_register_00002032,type) != 7) {
      return -2;
    }
    uVar1 = *(uint32_t *)arg1;
  }
  iVar2 = -1;
  if (3 < buf_sz) {
    *buf = uVar1;
    iVar2 = 4;
  }
  return iVar2;
}



int utils_tlv_bl_unpack_auto(uint32_t *buf,int buf_sz,uint16_t type,void *arg1)

{
  int iVar1;
  undefined2 in_register_00002032;
  bool bVar2;
  uint32_t uVar3;
  
  if (CONCAT22(in_register_00002032,type) == 1) {
    if (buf_sz < 4) {
      bVar2 = true;
      iVar1 = -1;
    }
    else {
      iVar1 = 4;
      bVar2 = *buf != 0;
    }
    *(bool *)arg1 = bVar2;
    return iVar1;
  }
  if (CONCAT22(in_register_00002032,type) != 7) {
    return -2;
  }
  if (buf_sz < 4) {
    uVar3 = 0;
    iVar1 = -1;
  }
  else {
    uVar3 = *buf;
    iVar1 = 4;
  }
  *(uint32_t *)arg1 = uVar3;
  return iVar1;
}



void utils_hmac_sha1_fast
               (uchar **ppText,int *pTextLen,int textNum,uchar *key,int key_len,uchar *output,
               int outputLen)

{
  uint *puVar1;
  uint32_t *puVar2;
  uint *__src;
  uchar **ppuVar3;
  int iVar4;
  uint *hash;
  uint local_120;
  uint64_t pBuf [11];
  undefined auStack196 [4];
  bl_sha_ctx_t sha_ctx;
  
  if (0x40 < key_len) {
    bl_sha_init((bl_sha_ctx_t *)auStack196,BL_SHA1);
    bl_sha_update((bl_sha_ctx_t *)auStack196,key,key_len);
    bl_sha_finish((bl_sha_ctx_t *)auStack196,key);
    key_len = 0x14;
  }
  memset(&local_120,0,0x40);
  memcpy(&local_120,key,key_len);
  hash = (uint *)((int)pBuf + 0x3c);
  puVar1 = &local_120;
  do {
    __src = puVar1 + 2;
    *puVar1 = *puVar1 ^ 0x36363636;
    puVar1[1] = puVar1[1] ^ 0x36363636;
    puVar1 = __src;
  } while (__src != hash);
  bl_sha_init((bl_sha_ctx_t *)auStack196,BL_SHA1);
  bl_sha_update((bl_sha_ctx_t *)auStack196,(uint8_t *)&local_120,0x40);
  iVar4 = 0;
  while (iVar4 < textNum) {
    puVar2 = (uint32_t *)(pTextLen + iVar4);
    ppuVar3 = ppText + iVar4;
    iVar4 = iVar4 + 1;
    bl_sha_update((bl_sha_ctx_t *)auStack196,*ppuVar3,*puVar2);
  }
  bl_sha_finish((bl_sha_ctx_t *)auStack196,(uint8_t *)hash);
  memset(&local_120,0,0x40);
  memcpy(&local_120,key,key_len);
  puVar1 = &local_120;
  do {
    __src = puVar1 + 2;
    *puVar1 = *puVar1 ^ 0x5c5c5c5c;
    puVar1[1] = puVar1[1] ^ 0x5c5c5c5c;
    puVar1 = __src;
  } while (__src != hash);
  bl_sha_init((bl_sha_ctx_t *)auStack196,BL_SHA1);
  bl_sha_update((bl_sha_ctx_t *)auStack196,(uint8_t *)&local_120,0x40);
  bl_sha_update((bl_sha_ctx_t *)auStack196,(uint8_t *)__src,0x14);
  bl_sha_finish((bl_sha_ctx_t *)auStack196,(uint8_t *)__src);
  memcpy(output,__src,outputLen);
  return;
}



int vfs_init(void)

{
  int iVar1;
  
  iVar1 = 0;
  if (g_vfs_init != '\x01') {
    g_vfs_mutex = (SemaphoreHandle_t)xQueueCreateMutexStatic('\x01',(StaticQueue_t *)&xMutexBuffer);
    iVar1 = -1;
    if (g_vfs_mutex != (SemaphoreHandle_t)0x0) {
      inode_init();
      iVar1 = 0;
      g_vfs_init = '\x01';
    }
  }
  return iVar1;
}



int aos_open(char *path,int flags)

{
  size_t sVar1;
  BaseType_t BVar2;
  inode_t *node;
  file_t *file;
  int iVar3;
  code *pcVar4;
  
  if (path == (char *)0x0) {
    iVar3 = -0x16;
  }
  else {
    sVar1 = strlen(path);
    if (0x400 < sVar1) {
      return -0x5b;
    }
    BVar2 = xQueueSemaphoreTake((QueueHandle_t)g_vfs_mutex,0xffffffff);
    if (BVar2 != 1) {
      return -1;
    }
    node = inode_open(path);
    if (node == (inode_t *)0x0) {
      xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
      return -2;
    }
    node->i_flags = flags;
    file = new_file(node);
    xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
    if (file == (file_t *)0x0) {
      return -0x17;
    }
    pcVar4 = *(code **)node->ops;
    if (node->type == '\x03') {
      if (pcVar4 == (code *)0x0) goto LAB_2304c23a;
      iVar3 = (*pcVar4)(file,path,flags);
    }
    else {
      if (pcVar4 == (code *)0x0) goto LAB_2304c23a;
      iVar3 = (*pcVar4)(node,file);
    }
    if (iVar3 == 0) {
LAB_2304c23a:
      iVar3 = get_fd(file);
      return iVar3;
    }
    del_file(file);
  }
  return iVar3;
}



int aos_close(int fd)

{
  int iVar1;
  file_t *file;
  BaseType_t BVar2;
  code *pcVar3;
  
  file = get_file(fd);
  iVar1 = -2;
  if (file != (file_t *)0x0) {
    iVar1 = 0;
    pcVar3 = *(code **)(file->node->ops + 4);
    if (pcVar3 != (code *)0x0) {
      iVar1 = (*pcVar3)();
    }
    BVar2 = xQueueSemaphoreTake((QueueHandle_t)g_vfs_mutex,0xffffffff);
    if (BVar2 == 1) {
      del_file(file);
      xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
    }
    else {
      iVar1 = -1;
    }
  }
  return iVar1;
}



ssize_t aos_read(int fd,void *buf,size_t nbytes)

{
  code *UNRECOVERED_JUMPTABLE;
  file_t *pfVar1;
  ssize_t sVar2;
  
  pfVar1 = get_file(fd);
  if (pfVar1 == (file_t *)0x0) {
    sVar2 = -2;
  }
  else {
    UNRECOVERED_JUMPTABLE = *(code **)(pfVar1->node->ops + 8);
    if (UNRECOVERED_JUMPTABLE != (code *)0x0) {
                    // WARNING: Could not recover jumptable at 0x2304c2d6. Too many branches
                    // WARNING: Treating indirect jump as call
      sVar2 = (*UNRECOVERED_JUMPTABLE)(buf,nbytes);
      return sVar2;
    }
    sVar2 = -1;
  }
  return sVar2;
}



ssize_t aos_write(int fd,void *buf,size_t nbytes)

{
  code *UNRECOVERED_JUMPTABLE;
  file_t *pfVar1;
  ssize_t sVar2;
  
  pfVar1 = get_file(fd);
  if (pfVar1 == (file_t *)0x0) {
    sVar2 = -2;
  }
  else {
    UNRECOVERED_JUMPTABLE = *(code **)(pfVar1->node->ops + 0xc);
    if (UNRECOVERED_JUMPTABLE != (code *)0x0) {
                    // WARNING: Could not recover jumptable at 0x2304c304. Too many branches
                    // WARNING: Treating indirect jump as call
      sVar2 = (*UNRECOVERED_JUMPTABLE)(buf,nbytes);
      return sVar2;
    }
    sVar2 = -1;
  }
  return sVar2;
}



int aos_ioctl(int fd,int cmd,ulong arg)

{
  code *UNRECOVERED_JUMPTABLE;
  file_t *pfVar1;
  int iVar2;
  
  if (fd < 0) {
    return -0x16;
  }
  pfVar1 = get_file(fd);
  if (pfVar1 == (file_t *)0x0) {
    iVar2 = -2;
  }
  else {
    iVar2 = pfVar1->node->ops;
    if (pfVar1->node->type == '\x03') {
      UNRECOVERED_JUMPTABLE = *(code **)(iVar2 + 0x44);
    }
    else {
      UNRECOVERED_JUMPTABLE = *(code **)(iVar2 + 0x10);
    }
    if (UNRECOVERED_JUMPTABLE != (code *)0x0) {
                    // WARNING: Could not recover jumptable at 0x2304c340. Too many branches
                    // WARNING: Treating indirect jump as call
      iVar2 = (*UNRECOVERED_JUMPTABLE)(cmd,arg);
      return iVar2;
    }
    iVar2 = -0x58;
  }
  return iVar2;
}



off_t aos_lseek(int fd,off_t offset,int whence)

{
  code *UNRECOVERED_JUMPTABLE;
  file_t *pfVar1;
  off_t oVar2;
  
  pfVar1 = get_file(fd);
  if (pfVar1 == (file_t *)0x0) {
    oVar2 = -2;
  }
  else {
    if (pfVar1->node->type == '\x03') {
      UNRECOVERED_JUMPTABLE = *(code **)(pfVar1->node->ops + 0x10);
      if (UNRECOVERED_JUMPTABLE != (code *)0x0) {
                    // WARNING: Could not recover jumptable at 0x2304c384. Too many branches
                    // WARNING: Treating indirect jump as call
        oVar2 = (*UNRECOVERED_JUMPTABLE)(offset,whence);
        return oVar2;
      }
    }
    oVar2 = -0x58;
  }
  return oVar2;
}



int aos_stat(char *path,stat *st)

{
  int iVar1;
  BaseType_t BVar2;
  inode_t *node;
  file_t *file;
  code *pcVar3;
  
  if (path == (char *)0x0) {
    return -0x16;
  }
  BVar2 = xQueueSemaphoreTake((QueueHandle_t)g_vfs_mutex,0xffffffff);
  if (BVar2 == 1) {
    node = inode_open(path);
    if (node == (inode_t *)0x0) {
      xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
      return -0x13;
    }
    file = new_file(node);
    xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
    if (file == (file_t *)0x0) {
      return -2;
    }
    iVar1 = -0x58;
    if ((node->type == '\x03') && (pcVar3 = *(code **)(node->ops + 0x18), pcVar3 != (code *)0x0)) {
      iVar1 = (*pcVar3)(file,path,st);
    }
    BVar2 = xQueueSemaphoreTake((QueueHandle_t)g_vfs_mutex,0xffffffff);
    if (BVar2 == 1) {
      del_file(file);
      xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
      return iVar1;
    }
  }
  return -1;
}



aos_dir_t * aos_opendir(char *path)

{
  BaseType_t BVar1;
  inode_t *node;
  file_t *file;
  aos_dir_t *paVar2;
  int iVar3;
  code *pcVar4;
  
  if ((path != (char *)0x0) &&
     (BVar1 = xQueueSemaphoreTake((QueueHandle_t)g_vfs_mutex,0xffffffff), BVar1 == 1)) {
    node = inode_open(path);
    if (node == (inode_t *)0x0) {
      xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
      return (aos_dir_t *)0x0;
    }
    file = new_file(node);
    xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
    if (file != (file_t *)0x0) {
      if (((node->type == '\x03') && (pcVar4 = *(code **)(node->ops + 0x24), pcVar4 != (code *)0x0))
         && (paVar2 = (aos_dir_t *)(*pcVar4)(file,path), paVar2 != (aos_dir_t *)0x0)) {
        iVar3 = get_fd(file);
        paVar2->dd_vfs_fd = iVar3;
        return paVar2;
      }
      BVar1 = xQueueSemaphoreTake((QueueHandle_t)g_vfs_mutex,0xffffffff);
      if (BVar1 == 1) {
        del_file(file);
        xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
      }
    }
  }
  return (aos_dir_t *)0x0;
}



int aos_closedir(aos_dir_t *dir)

{
  int iVar1;
  file_t *file;
  BaseType_t BVar2;
  code *pcVar3;
  
  iVar1 = -0x16;
  if (dir != (aos_dir_t *)0x0) {
    iVar1 = -2;
    file = get_file(dir->dd_vfs_fd);
    if (file != (file_t *)0x0) {
      iVar1 = -0x58;
      if ((file->node->type == '\x03') &&
         (pcVar3 = *(code **)(file->node->ops + 0x2c), pcVar3 != (code *)0x0)) {
        iVar1 = (*pcVar3)(dir);
      }
      BVar2 = xQueueSemaphoreTake((QueueHandle_t)g_vfs_mutex,0xffffffff);
      if (BVar2 == 1) {
        del_file(file);
        xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
      }
      else {
        iVar1 = -1;
      }
    }
  }
  return iVar1;
}



aos_dirent_t * aos_readdir(aos_dir_t *dir)

{
  code *UNRECOVERED_JUMPTABLE;
  file_t *pfVar1;
  aos_dirent_t *paVar2;
  
  if (dir == (aos_dir_t *)0x0) {
    return (aos_dirent_t *)0x0;
  }
  pfVar1 = get_file(dir->dd_vfs_fd);
  if (pfVar1 != (file_t *)0x0) {
    if (pfVar1->node->type == '\x03') {
      UNRECOVERED_JUMPTABLE = *(code **)(pfVar1->node->ops + 0x28);
      if (UNRECOVERED_JUMPTABLE != (code *)0x0) {
                    // WARNING: Could not recover jumptable at 0x2304c59a. Too many branches
                    // WARNING: Treating indirect jump as call
        paVar2 = (aos_dirent_t *)(*UNRECOVERED_JUMPTABLE)(dir);
        return paVar2;
      }
    }
  }
  return (aos_dirent_t *)0x0;
}



file_t * new_file(inode_t *node)

{
  file_t *pfVar1;
  int iVar2;
  
  pfVar1 = files;
  iVar2 = 0;
  do {
    if (pfVar1->node == (inode_t *)0x0) {
      files[iVar2].node = node;
      files[iVar2].f_arg = (void *)0x0;
      files[iVar2].offset = 0;
      inode_ref(node);
      return files + iVar2;
    }
    iVar2 = iVar2 + 1;
    pfVar1 = pfVar1 + 1;
  } while (iVar2 != 0x3c);
  return (file_t *)0x0;
}



void del_file(file_t *file)

{
  inode_unref(file->node);
  file->node = (inode_t *)0x0;
  return;
}



int get_fd(file_t *file)

{
  return ((int)(file + -0x5801c68) >> 2) * -0x55555555 + 2;
}



file_t * get_file(int fd)

{
  inode_t *piVar1;
  
  if (fd - 2U < 0x3c) {
    piVar1 = files[fd - 2U].node;
    if (piVar1 != (inode_t *)0x0) {
      return files + (fd - 2U);
    }
  }
  else {
    piVar1 = (inode_t *)0x0;
  }
  return (file_t *)piVar1;
}



int inode_init(void)

{
  memset(g_vfs_dev_nodes,0,600);
  return 0;
}



int inode_alloc(void)

{
  int iVar1;
  inode_t *piVar2;
  
  piVar2 = g_vfs_dev_nodes;
  iVar1 = 0;
  do {
    if (piVar2->type == '\0') {
      return iVar1;
    }
    iVar1 = iVar1 + 1;
    piVar2 = piVar2 + 1;
  } while (iVar1 != 0x1e);
  return -0xc;
}



inode_t * inode_open(char *path)

{
  inode_t *piVar1;
  int iVar2;
  size_t __n;
  char *__s;
  
  piVar1 = g_vfs_dev_nodes;
  do {
    __s = piVar1->i_name;
    if (__s != (char *)0x0) {
      if (piVar1->type == '\x03') {
        __n = strlen(__s);
        iVar2 = strncmp(__s,path,__n);
        if ((iVar2 == 0) && (__n = strlen(piVar1->i_name), path[__n] == '/')) {
          return piVar1;
        }
      }
      iVar2 = strcmp(piVar1->i_name,path);
      if (iVar2 == 0) {
        return piVar1;
      }
    }
    piVar1 = piVar1 + 1;
    if (piVar1 == (inode_t *)deleteAcceptedTopic) {
      return (inode_t *)0x0;
    }
  } while( true );
}



int inode_forearch_name(anon_subr_int_void_ptr_inode_t_ptr *cb,void *arg)

{
  inode_t *piVar1;
  int iVar2;
  int iVar3;
  
  piVar1 = g_vfs_dev_nodes;
  iVar2 = 0;
  do {
    if (piVar1->i_name != (char *)0x0) {
      iVar2 = iVar2 + 1;
      iVar3 = (*cb)(arg,piVar1);
      if (iVar3 != 0) {
        return iVar2;
      }
    }
    piVar1 = piVar1 + 1;
  } while (piVar1 != (inode_t *)deleteAcceptedTopic);
  return iVar2;
}



void inode_ref(inode_t *node)

{
  node->refs = node->refs + '\x01';
  return;
}



void inode_unref(inode_t *node)

{
  if (node->refs != '\0') {
    node->refs = node->refs + -1;
  }
  return;
}



int inode_reserve(char *path,inode_t **inode)

{
  inode_t *piVar1;
  int iVar2;
  size_t __n;
  char *__dest;
  
  if (((path != (char *)0x0) && (inode != (inode_t **)0x0)) &&
     (*inode = (inode_t *)0x0, *path == '/')) {
    iVar2 = inode_alloc();
    if (-1 < iVar2) {
      piVar1 = (inode_t *)0x0;
      if (iVar2 < 0x1e) {
        piVar1 = g_vfs_dev_nodes + iVar2;
      }
      __n = strlen(path);
      __dest = (char *)pvPortMalloc(__n + 1);
      iVar2 = -0xc;
      if (__dest != (char *)0x0) {
        memcpy(__dest,path,__n);
        piVar1->i_name = __dest;
        __dest[__n] = '\0';
        *inode = piVar1;
        iVar2 = 0;
      }
    }
    return iVar2;
  }
  return -0x16;
}



int aos_register_driver(char *path,file_ops_t *ops,void *arg)

{
  BaseType_t BVar1;
  int iVar2;
  inode_t *piStack36;
  inode_t *node;
  
  piStack36 = (inode_t *)0x0;
  BVar1 = xQueueSemaphoreTake((QueueHandle_t)g_vfs_mutex,0xffffffff);
  if (BVar1 == 1) {
    iVar2 = inode_reserve(path,&piStack36);
    if (iVar2 == 0) {
      *(file_ops_t **)&piStack36->ops = ops;
      piStack36->type = '\x01';
      piStack36->i_arg = arg;
    }
    BVar1 = xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
    if (BVar1 == 1) {
      return iVar2;
    }
    if (piStack36->i_name != (char *)0x0) {
      vPortFree(piStack36->i_name);
    }
    memset(piStack36,0,0x14);
  }
  return -1;
}



int aos_register_fs(char *path,fs_ops_t *ops,void *arg)

{
  BaseType_t BVar1;
  int iVar2;
  inode_t *piStack36;
  inode_t *node;
  
  piStack36 = (inode_t *)0x0;
  BVar1 = xQueueSemaphoreTake((QueueHandle_t)g_vfs_mutex,0xffffffff);
  if (BVar1 == 1) {
    iVar2 = inode_reserve(path,&piStack36);
    if (iVar2 == 0) {
      *(fs_ops_t **)&piStack36->ops = ops;
      piStack36->type = '\x03';
      piStack36->i_arg = arg;
    }
    BVar1 = xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
    if (BVar1 == 1) {
      return iVar2;
    }
    if (piStack36->i_name != (char *)0x0) {
      vPortFree(piStack36->i_name);
    }
    memset(piStack36,0,0x14);
  }
  return -1;
}



int vfs_uart_open(inode_t *inode,file_t *fp)

{
  uart_dev_t *uart;
  int iVar1;
  StreamBufferHandle_t pSVar2;
  int32_t iVar3;
  inode_t *piVar4;
  
  if ((fp == (file_t *)0x0) || (piVar4 = fp->node, piVar4 == (inode_t *)0x0)) {
    iVar1 = -0x16;
  }
  else {
    iVar1 = 0;
    if (piVar4->refs == '\x01') {
      uart = (uart_dev_t *)piVar4->i_arg;
      aos_mutex_new((aos_mutex_t *)&uart->mutex);
      pSVar2 = xStreamBufferGenericCreate(uart->rx_buf_size,1,0);
      *(StreamBufferHandle_t *)&uart->rx_ringbuf_handle = pSVar2;
      pSVar2 = xStreamBufferGenericCreate(uart->tx_buf_size,1,0);
      *(StreamBufferHandle_t *)&uart->tx_ringbuf_handle = pSVar2;
      if ((uart->rx_ringbuf_handle != (void *)0x0) && (pSVar2 != (StreamBufferHandle_t)0x0)) {
        hal_uart_notify_register(uart,UART_TX_INT,__uart_tx_irq);
        hal_uart_notify_register(uart,UART_RX_INT,__uart_rx_irq);
        iVar3 = hal_uart_init(uart);
        return iVar3;
      }
      return -0x16;
    }
  }
  return iVar1;
}



void __uart_rx_irq(void *p_arg)

{
  uint32_t uStack88;
  uint32_t length;
  BaseType_t xHigherPriorityTaskWoken;
  uint8_t tmp_buf [64];
  
  uStack88 = 0;
  length = 0;
  hal_uart_recv_II((uart_dev_t *)p_arg,&xHigherPriorityTaskWoken,0x40,&uStack88,0);
  if (uStack88 != 0) {
    xStreamBufferSendFromISR
              (*(StreamBufferHandle_t *)((int)p_arg + 0x10),&xHigherPriorityTaskWoken,uStack88,
               (BaseType_t *)&length);
    if (length != 0) {
      vTaskSwitchContext();
    }
  }
  if (*(int *)((int)p_arg + 0x24) != 0) {
    *(ushort *)(*(int *)((int)p_arg + 0x28) + 6) = *(ushort *)(*(int *)((int)p_arg + 0x28) + 6) | 1;
    (**(code **)((int)p_arg + 0x24))
              (*(undefined4 *)((int)p_arg + 0x28),*(undefined4 *)((int)p_arg + 0x2c),
               *(code **)((int)p_arg + 0x24));
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

void __uart_tx_irq(void *p_arg)

{
  size_t sVar1;
  undefined uStack21;
  uint8_t ch;
  int iStack20;
  BaseType_t xHigherPriorityTaskWoken;
  
  iStack20 = 0;
  sVar1 = xStreamBufferReceiveFromISR
                    (*(StreamBufferHandle_t *)((int)p_arg + 0x14),&uStack21,1,
                     (BaseType_t *)&stack0xffffffec);
  if (iStack20 != 0) {
    vTaskSwitchContext();
  }
  if (sVar1 == 1) {
    hal_uart_send((uart_dev_t *)p_arg,&uStack21,1,0);
  }
  else {
    hal_uart_send_trigger_off((uart_dev_t *)p_arg);
  }
  return;
}



int vfs_uart_close(file_t *fp)

{
  uart_dev_t *uart;
  int32_t iVar1;
  inode_t *piVar2;
  
  if ((fp == (file_t *)0x0) || (piVar2 = fp->node, piVar2 == (inode_t *)0x0)) {
    return -0x16;
  }
  if (piVar2->refs != '\x01') {
    return 0;
  }
  uart = (uart_dev_t *)piVar2->i_arg;
  if (uart != (uart_dev_t *)0x0) {
    aos_mutex_free((aos_mutex_t *)&uart->mutex);
    vStreamBufferDelete((StreamBufferHandle_t)uart->rx_ringbuf_handle);
    vStreamBufferDelete((StreamBufferHandle_t)uart->tx_ringbuf_handle);
    iVar1 = hal_uart_finalize(uart);
    return iVar1;
  }
  return -0x16;
}



ssize_t vfs_uart_read(file_t *fp,void *buf,size_t nbytes)

{
  size_t sVar1;
  TickType_t xTicksToWait;
  size_t sVar2;
  void *pvVar3;
  
  sVar1 = 0xffffffea;
  if (fp != (file_t *)0x0) {
    sVar1 = 0xffffffea;
    if (((fp->node != (inode_t *)0x0) && (pvVar3 = fp->node->i_arg, nbytes != 0)) &&
       (pvVar3 != (void *)0x0)) {
      aos_mutex_lock((aos_mutex_t *)((int)pvVar3 + 0x20),0xffffffff);
      sVar1 = 0;
      xTicksToWait = -(uint)(*(char *)((int)pvVar3 + 0x34) == '\x01');
      do {
        sVar2 = xStreamBufferReceive
                          (*(StreamBufferHandle_t *)((int)pvVar3 + 0x10),(void *)((int)buf + sVar1),
                           nbytes - sVar1,xTicksToWait);
        sVar1 = sVar1 + sVar2;
        if (sVar1 == nbytes) break;
      } while (xTicksToWait != 0);
      aos_mutex_unlock((aos_mutex_t *)((int)pvVar3 + 0x20));
    }
  }
  return sVar1;
}



ssize_t vfs_uart_write(file_t *fp,void *buf,size_t nbytes)

{
  size_t sVar1;
  uart_dev_t *uart;
  
  sVar1 = 0xffffffea;
  if (fp != (file_t *)0x0) {
    sVar1 = 0xffffffea;
    if (((fp->node != (inode_t *)0x0) &&
        (uart = (uart_dev_t *)fp->node->i_arg, uart != (uart_dev_t *)0x0)) &&
       (sVar1 = xStreamBufferSend((StreamBufferHandle_t)uart->tx_ringbuf_handle,buf,nbytes,0),
       0 < (int)sVar1)) {
      hal_uart_send_trigger(uart);
    }
  }
  return sVar1;
}



int vfs_uart_poll(file_t *fp,_Bool setup,poll_notify_t *notify,pollfd *fd,void *opa)

{
  void *pvVar1;
  BaseType_t BVar2;
  undefined3 in_register_0000202d;
  
  pvVar1 = fp->node->i_arg;
  aos_mutex_lock((aos_mutex_t *)((int)pvVar1 + 0x20),0xffffffff);
  if (CONCAT31(in_register_0000202d,setup) == 0) {
    vTaskEnterCritical();
    *(undefined4 *)((int)pvVar1 + 0x24) = 0;
    *(undefined4 *)((int)pvVar1 + 0x2c) = 0;
    vTaskExitCritical();
  }
  else {
    vTaskEnterCritical();
    *(poll_notify_t **)((int)pvVar1 + 0x24) = notify;
    *(pollfd **)((int)pvVar1 + 0x28) = fd;
    *(void **)((int)pvVar1 + 0x2c) = opa;
    vTaskExitCritical();
    BVar2 = xStreamBufferIsEmpty(*(StreamBufferHandle_t *)((int)pvVar1 + 0x10));
    if (BVar2 != 1) {
      *(ushort *)(*(int *)((int)pvVar1 + 0x28) + 6) =
           *(ushort *)(*(int *)((int)pvVar1 + 0x28) + 6) | 1;
      (*notify)(fd,opa);
    }
  }
  aos_mutex_unlock((aos_mutex_t *)((int)pvVar1 + 0x20));
  return 0;
}



int vfs_uart_sync(file_t *fp)

{
  uart_dev_t *uart;
  int iVar1;
  
  if (fp == (file_t *)0x0) {
    return -0x16;
  }
  iVar1 = -0x16;
  if (fp->node != (inode_t *)0x0) {
    uart = (uart_dev_t *)fp->node->i_arg;
    if (uart != (uart_dev_t *)0x0) {
      aos_mutex_lock((aos_mutex_t *)&uart->mutex,0xffffffff);
      hal_uart_send_flush(uart,0);
      aos_mutex_unlock((aos_mutex_t *)&uart->mutex);
      iVar1 = 0;
    }
    return iVar1;
  }
  return iVar1;
}



int uart_ioctl_cmd_waimode(uart_dev_t *uart_dev,int cmd,ulong arg)

{
  int iVar1;
  size_t sVar2;
  uint uVar3;
  int iVar4;
  
  iVar1 = -0x16;
  if (arg != 0) {
    iVar4 = *(int *)(arg + 4);
    uVar3 = *(int *)(arg + 8) * 1000;
    iVar1 = 0;
    do {
      sVar2 = xStreamBufferReceive
                        ((StreamBufferHandle_t)uart_dev->rx_ringbuf_handle,
                         (void *)(*(int *)arg + iVar1),iVar4 - iVar1,uVar3 / 1000);
      iVar1 = iVar1 + sVar2;
      if (iVar4 == iVar1) {
        return iVar1;
      }
      if (uVar3 < 1000) {
        return iVar1;
      }
    } while ((cmd != 4) || (iVar1 < 1));
  }
  return iVar1;
}



int uart_ioctl_cmd_setconfig(uart_dev_t *uart_dev,ulong arg)

{
  hal_uart_parity_t parity;
  
  if (arg != 0) {
    parity = *(hal_uart_parity_t *)(arg + 4);
    if ((parity != ODD_PARITY) && (parity != EVEN_PARITY)) {
      parity = NO_PARITY;
    }
    hal_uart_setconfig(uart_dev,*(uint32_t *)arg,parity);
    return 0;
  }
  return -0x16;
}



int vfs_uart_ioctl(file_t *fp,int cmd,ulong arg)

{
  int iVar1;
  uart_dev_t *uart_dev;
  uint8_t uVar2;
  
  if (fp == (file_t *)0x0) {
    return -0x16;
  }
  iVar1 = -0x16;
  if (fp->node == (inode_t *)0x0) {
    return -0x16;
  }
  uart_dev = (uart_dev_t *)fp->node->i_arg;
  if (uart_dev == (uart_dev_t *)0x0) {
    return -0x16;
  }
  aos_mutex_lock((aos_mutex_t *)&uart_dev->mutex,0xffffffff);
  switch(cmd) {
  case 2:
    hal_uart_send_flush(uart_dev,0);
    break;
  case 3:
    hal_uart_setbaud(uart_dev,arg);
    break;
  case 4:
  case 5:
    iVar1 = uart_ioctl_cmd_waimode(uart_dev,cmd,arg);
    goto switchD_2304ccc2_caseD_7;
  case 6:
    uVar2 = '\x01';
    goto LAB_2304cd04;
  case 7:
    uVar2 = '\x02';
LAB_2304cd04:
    uart_dev->read_block_flag = uVar2;
    break;
  case 8:
    iVar1 = uart_ioctl_cmd_setconfig(uart_dev,arg);
  default:
    goto switchD_2304ccc2_caseD_7;
  }
  iVar1 = -1;
switchD_2304ccc2_caseD_7:
  aos_mutex_unlock((aos_mutex_t *)&uart_dev->mutex);
  return iVar1;
}



yloop_ctx_t * get_context(void)

{
  yloop_ctx_t *pyVar1;
  
  pyVar1 = (yloop_ctx_t *)aos_task_getspecific(g_loop_key);
  if (pyVar1 == (yloop_ctx_t *)0x0) {
    aos_task_setspecific(g_loop_key,g_main_ctx);
    pyVar1 = g_main_ctx;
  }
  return pyVar1;
}



void aos_loop_set_eventfd(int fd)

{
  yloop_ctx_t *pyVar1;
  
  pyVar1 = get_context();
  pyVar1->eventfd = fd;
  return;
}



aos_loop_t aos_loop_init(void)

{
  aos_task_key_t key;
  void *pvVar1;
  yloop_ctx_t *__s;
  
  pvVar1 = aos_task_getspecific(g_loop_key);
  if (g_main_ctx == (yloop_ctx_t *)0x0) {
    aos_task_key_create(&g_loop_key);
  }
  else {
    if (pvVar1 != (void *)0x0) {
      printf("yloopyloop already inited");
      return pvVar1;
    }
  }
  __s = (yloop_ctx_t *)pvPortMalloc(0x1c);
  if (__s != (yloop_ctx_t *)0x0) {
    memset(__s,0,0x1c);
  }
  if (g_main_ctx == (yloop_ctx_t *)0x0) {
    g_main_ctx = __s;
  }
  *(yloop_ctx_t **)&(__s->timeouts).prev = __s;
  key = g_loop_key;
  __s->eventfd = -1;
  *(yloop_ctx_t **)&(__s->timeouts).next = __s;
  aos_task_setspecific(key,__s);
  aos_event_service_init();
  return __s;
}



int aos_poll_read_fd(int sock,aos_poll_call_t *cb,void *private_data)

{
  yloop_sock_t *__dest;
  yloop_ctx_t *pyVar1;
  pollfd *__dest_00;
  uint uVar2;
  int iVar3;
  uint uVar4;
  
  pyVar1 = get_context();
  if (sock < 0) {
    iVar3 = -0x16;
  }
  else {
    uVar4 = (uint)pyVar1->reader_count;
    __dest = (yloop_sock_t *)pvPortMalloc((uVar4 + 1) * 0xc);
    __dest_00 = (pollfd *)pvPortMalloc((uVar4 + 1) * 8);
    if ((__dest == (yloop_sock_t *)0x0) || (__dest_00 == (pollfd *)0x0)) {
      printf("yloopout of memory");
      vPortFree(__dest);
      vPortFree(__dest_00);
      iVar3 = -0xc;
    }
    else {
      uVar2 = aos_fcntl(sock,3,0);
      aos_fcntl(sock,4,uVar2 | 0x4000);
      pyVar1->reader_count = pyVar1->reader_count + '\x01';
      memcpy(__dest,pyVar1->readers,uVar4 * 0xc);
      vPortFree(pyVar1->readers);
      pyVar1->readers = __dest;
      memcpy(__dest_00,pyVar1->pollfds,uVar4 << 3);
      __dest = __dest + uVar4;
      vPortFree(pyVar1->pollfds);
      pyVar1->pollfds = __dest_00;
      __dest->sock = sock;
      __dest->private_data = private_data;
      __dest->cb = cb;
      iVar3 = 0;
      if ((int)(uint)pyVar1->max_sock < sock) {
        pyVar1->max_sock = (uint16_t)sock;
        iVar3 = 0;
      }
    }
  }
  return iVar3;
}



int aos_post_delayed_action(int ms,aos_call_t *action,void *param)

{
  yloop_ctx_t *pyVar1;
  dlist_s *pdVar2;
  int iVar3;
  pollfd *ppVar4;
  aos_call_t *paVar5;
  yloop_sock_t *pyVar6;
  dlist_s *pdVar7;
  yloop_ctx_t *pyVar8;
  
  if (action != (aos_call_t *)0x0) {
    paVar5 = action;
    pyVar1 = get_context();
    pdVar2 = (dlist_s *)pvPortMalloc(0x20);
    iVar3 = -0xc;
    if (pdVar2 != (dlist_s *)0x0) {
      aos_now_ms();
      ppVar4 = (pollfd *)(iVar3 + ms);
      pyVar6 = (yloop_sock_t *)(paVar5 + (uint)(ppVar4 < (uint)ms) + (ms >> 0x1f));
      *(pollfd **)&pdVar2[1].prev = ppVar4;
      *(yloop_sock_t **)&pdVar2[1].next = pyVar6;
      pdVar2[2].prev = param;
      *(aos_call_t **)&pdVar2[2].next = action;
      *(int *)&pdVar2[3].prev = ms;
      pyVar8 = (yloop_ctx_t *)(pyVar1->timeouts).next;
      while (((pyVar8 != pyVar1 && ((int)pyVar8->readers <= (int)pyVar6)) &&
             ((pyVar8->readers != pyVar6 || (pyVar8->pollfds <= ppVar4))))) {
        pyVar8 = (yloop_ctx_t *)(pyVar8->timeouts).next;
      }
      pdVar7 = (pyVar8->timeouts).prev;
      *(yloop_ctx_t **)&pdVar2->next = pyVar8;
      iVar3 = 0;
      pdVar2->prev = pdVar7;
      pdVar7->next = pdVar2;
      (pyVar8->timeouts).prev = pdVar2;
    }
    return iVar3;
  }
  return -0x16;
}



void aos_loop_run(yloop_sock_t *param_1)

{
  yloop_ctx_t *pyVar1;
  yloop_sock_t *pyVar2;
  yloop_ctx_t *pyVar3;
  yloop_ctx_t *pyVar4;
  yloop_sock_t *extraout_a1;
  yloop_sock_t *extraout_a1_00;
  yloop_ctx_t *pv;
  dlist_s *pdVar5;
  int iVar6;
  dlist_s *pdVar7;
  yloop_sock_t *pyVar8;
  yloop_sock_t *nfds;
  undefined4 extraout_fa0;
  longlong lVar9;
  
  pyVar3 = get_context();
  pyVar4 = pyVar3;
  while (pyVar3->terminate == false) {
    pyVar1 = (yloop_ctx_t *)(pyVar3->timeouts).next;
    nfds = (yloop_sock_t *)(uint)pyVar3->reader_count;
    if ((pyVar3 == pyVar1) && (pyVar3->reader_count == 0)) break;
    pv = (yloop_ctx_t *)0xffffffff;
    if (pyVar3 != pyVar1) {
      aos_now_ms();
      if (((int)param_1 < (int)pyVar1->readers) ||
         ((pyVar1->readers == param_1 && (pyVar4 < (yloop_ctx_t *)pyVar1->pollfds)))) {
        pv = (yloop_ctx_t *)((int)(yloop_ctx_t *)pyVar1->pollfds - (int)pyVar4);
      }
      else {
        pv = (yloop_ctx_t *)0x0;
      }
    }
    iVar6 = 0;
    while (iVar6 < (int)nfds) {
      pyVar3->pollfds[iVar6].fd = pyVar3->readers[iVar6].sock;
      pyVar3->pollfds[iVar6].events = 1;
      iVar6 = iVar6 + 1;
    }
    param_1 = nfds;
    pyVar1 = (yloop_ctx_t *)aos_poll(pyVar3->pollfds,(int)nfds,(int)pv);
    pyVar4 = pyVar1;
    if ((int)pyVar1 < 0) {
      pyVar4 = (yloop_ctx_t *)__errno();
      param_1 = extraout_a1;
      if ((pyVar4->timeouts).prev != (dlist_s *)0x4) {
        printf("yloopaos_poll",extraout_fa0);
        return;
      }
    }
    pv = (yloop_ctx_t *)(pyVar3->timeouts).next;
    if (pyVar3 != pv) {
      lVar9 = aos_now_ms();
      if (((int)pv->readers <= (int)param_1) &&
         ((pv->readers != param_1 || ((yloop_ctx_t *)pv->pollfds <= pyVar4)))) {
        pdVar7 = (pv->timeouts).next;
        pdVar5 = (pv->timeouts).prev;
        pdVar5->next = pdVar7;
        pdVar7->prev = pdVar5;
        param_1 = (yloop_sock_t *)
                  (**(code **)&pv->max_sock)(pv->eventfd,*(code **)&pv->max_sock,(int)lVar9);
        vPortFree(pv);
        pyVar4 = pv;
      }
    }
    pyVar2 = (yloop_sock_t *)0x0;
    if (0 < (int)pyVar1) {
      while (pyVar2 != nfds) {
        if ((pyVar3->pollfds[(int)pyVar2].revents & 1U) != 0) {
          pyVar8 = pyVar3->readers + (int)pyVar2;
          pyVar4 = (yloop_ctx_t *)(*pyVar8->cb)(pyVar8->sock,pyVar8->private_data);
          param_1 = extraout_a1_00;
        }
        pyVar2 = (yloop_sock_t *)((int)&pyVar2->sock + 1);
      }
    }
  }
  pyVar3->terminate = false;
  return;
}



void vfs_poll_notify(pollfd *fd,void *arg)

{
  aos_sem_signal((aos_sem_t *)arg);
  return;
}



int aos_poll(pollfd *fds,int nfds,int timeout)

{
  ushort *puVar1;
  int iVar2;
  uint fd;
  file_t *pfVar3;
  ushort *puVar4;
  int iVar5;
  code *pcVar6;
  int iVar7;
  pollfd *ppVar8;
  aos_sem_t aStack60;
  poll_arg parg;
  _types_fd_set rfds;
  
  aos_sem_new(&aStack60,0);
  iVar5 = 0;
  do {
    *(undefined *)((int)&parg.sem.hdl + iVar5) = 0;
    iVar5 = iVar5 + 1;
  } while (iVar5 != 8);
  puVar1 = (ushort *)&fds->revents;
  iVar5 = 0;
  puVar4 = puVar1;
  while (iVar5 < nfds) {
    *puVar4 = 0;
    iVar5 = iVar5 + 1;
    puVar4 = puVar4 + 4;
  }
  iVar5 = 0;
  ppVar8 = fds;
  do {
    if (nfds <= iVar5) {
      if (timeout < 0) {
        timeout = 0xffffffff;
      }
      aos_sem_wait(&aStack60,timeout);
      iVar5 = 0;
      while (iVar5 < nfds) {
        if ((1 << (*(uint *)(puVar1 + -3) & 0x1f) &
            (uint)(&parg)[*(uint *)(puVar1 + -3) >> 5].sem.hdl) != 0) {
          *puVar1 = *puVar1 | 1;
        }
        iVar5 = iVar5 + 1;
        puVar1 = puVar1 + 4;
      }
      iVar5 = 0;
check_poll:
      iVar2 = 0;
      iVar7 = 0;
      while (iVar7 < nfds) {
        if (((1 < fds->fd) && (pfVar3 = get_file(fds->fd), pfVar3 != (file_t *)0x0)) &&
           (pcVar6 = *(code **)(pfVar3->node->ops + 0x14), (*pcVar6)(0,0,0,0,pcVar6),
           fds->revents != 0)) {
          iVar2 = iVar2 + 1;
        }
        iVar7 = iVar7 + 1;
        fds = fds + 1;
      }
      aos_sem_free(&aStack60);
      if (iVar5 != 0) {
        iVar2 = 0;
      }
      return iVar2;
    }
    fd = ppVar8->fd;
    if ((int)fd < 2) {
      (&parg)[fd >> 5].sem.hdl = (void *)(1 << (fd & 0x1f) | (uint)(&parg)[fd >> 5].sem.hdl);
    }
    else {
      pfVar3 = get_file(fd);
      if (pfVar3 == (file_t *)0x0) {
        iVar5 = -1;
        goto check_poll;
      }
      pcVar6 = *(code **)(pfVar3->node->ops + 0x14);
      (*pcVar6)(1,vfs_poll_notify,ppVar8,&aStack60,pcVar6);
    }
    iVar5 = iVar5 + 1;
    ppVar8 = ppVar8 + 1;
  } while( true );
}



int aos_fcntl(int fd,int cmd,int val)

{
  int iVar1;
  
  iVar1 = -0x16;
  if ((-1 < fd) && (iVar1 = 0, fd < 2)) {
    iVar1 = -2;
  }
  return iVar1;
}



void dfl_entry(void *arg)

{
  code *pcVar1;
  undefined4 uVar2;
  
  uVar2 = *(undefined4 *)((int)arg + 8);
  pcVar1 = *(code **)((int)arg + 4);
  vPortFree(arg);
  (*pcVar1)(uVar2);
  vTaskDelete((TaskHandle_t)0x0);
  return;
}



int aos_task_new(char *name,anon_subr_void_void_ptr *fn,void *arg,int stack_size)

{
  StaticTask_t *pxTaskBuffer;
  StaticTask_t **pvParameters;
  StackType_t *puxStackBuffer;
  TaskHandle_t ptVar1;
  int iVar2;
  
  pxTaskBuffer = (StaticTask_t *)pvPortMalloc(0x9c);
  pvParameters = (StaticTask_t **)pvPortMalloc(0xc);
  puxStackBuffer = (StackType_t *)pvPortMalloc(stack_size);
  memset(puxStackBuffer,0,stack_size);
  memset(pxTaskBuffer,0,0x9c);
  pxTaskBuffer[1].pxDummy1 = (void *)0xfffffff0;
  *(StackType_t **)(pxTaskBuffer[1].xDummy3[0].pvDummy3 + 3) = puxStackBuffer;
  strncpy((char *)(pxTaskBuffer[1].xDummy3 + 1),name,0x1f);
  *(undefined4 *)(pxTaskBuffer[1].ucDummy7 + 4) = 0x20171020;
  *pvParameters = pxTaskBuffer;
  *(anon_subr_void_void_ptr **)(pvParameters + 1) = fn;
  pvParameters[2] = arg;
  ptVar1 = xTaskCreateStatic(dfl_entry,name,(uint)stack_size >> 2,pvParameters,10,puxStackBuffer,
                             pxTaskBuffer);
  if (ptVar1 == (TaskHandle_t)0x0) {
    vPortFree(pxTaskBuffer);
    vPortFree(puxStackBuffer);
    vPortFree(pvParameters);
    iVar2 = -1;
  }
  else {
    iVar2 = 0;
  }
  return iVar2;
}



void aos_task_exit(int code)

{
  vTaskDelete((TaskHandle_t)0x0);
  return;
}



int aos_task_key_create(aos_task_key_t *key)

{
  TaskHandle_t ptVar1;
  uint uVar2;
  aos_task_key_t aVar3;
  int iVar4;
  StackType_t *pSVar5;
  
  ptVar1 = xTaskGetCurrentTaskHandle();
  if (*(int *)(ptVar1[1].pcTaskName + 4) == 0x20171020) {
    pSVar5 = ptVar1[1].pxTopOfStack;
    if (((uint)pSVar5 & 1) == 0) {
      aVar3 = 0;
      uVar2 = 1;
    }
    else {
      if (((uint)pSVar5 & 2) == 0) {
        aVar3 = 1;
        uVar2 = 2;
      }
      else {
        if (((uint)pSVar5 & 4) == 0) {
          aVar3 = 2;
          uVar2 = 4;
        }
        else {
          if (((uint)pSVar5 & 8) != 0) {
            return -1;
          }
          aVar3 = 3;
          uVar2 = 8;
        }
      }
    }
    ptVar1[1].pxTopOfStack = (StackType_t *)((uint)pSVar5 | uVar2);
    *key = aVar3;
    iVar4 = 0;
  }
  else {
    iVar4 = -1;
  }
  return iVar4;
}



int aos_task_setspecific(aos_task_key_t key,void *vp)

{
  TaskHandle_t ptVar1;
  int iVar2;
  
  ptVar1 = xTaskGetCurrentTaskHandle();
  if (key < 4) {
    iVar2 = -1;
    if (*(int *)(ptVar1[1].pcTaskName + 4) == 0x20171020) {
      *(void **)(&(ptVar1->xStateListItem).xItemValue + key + 0x18) = vp;
      iVar2 = 0;
    }
  }
  else {
    iVar2 = -1;
  }
  return iVar2;
}



void * aos_task_getspecific(aos_task_key_t key)

{
  TaskHandle_t ptVar1;
  void *pvVar2;
  
  ptVar1 = xTaskGetCurrentTaskHandle();
  if (key < 4) {
    pvVar2 = (void *)0x0;
    if (*(int *)(ptVar1[1].pcTaskName + 4) == 0x20171020) {
      pvVar2 = (void *)(&(ptVar1->xStateListItem).xItemValue)[key + 0x18];
    }
  }
  else {
    pvVar2 = (void *)0x0;
  }
  return pvVar2;
}



int aos_mutex_new(aos_mutex_t *mutex)

{
  QueueHandle_t pQVar1;
  
  pQVar1 = xQueueCreateMutex('\x01');
  *(QueueHandle_t *)&mutex->hdl = pQVar1;
  return -(uint)(pQVar1 == (QueueHandle_t)0x0);
}



void aos_mutex_free(aos_mutex_t *mutex)

{
  vQueueDelete((QueueHandle_t)mutex->hdl);
  return;
}



int aos_mutex_lock(aos_mutex_t *mutex,uint ms)

{
  if (mutex != (aos_mutex_t *)0x0) {
    xQueueSemaphoreTake((QueueHandle_t)mutex->hdl,ms);
    return 0;
  }
  return 0;
}



int aos_mutex_unlock(aos_mutex_t *mutex)

{
  if (mutex != (aos_mutex_t *)0x0) {
    xQueueGenericSend((QueueHandle_t)mutex->hdl,(void *)0x0,0,0);
    return 0;
  }
  return 0;
}



int aos_sem_new(aos_sem_t *sem,int count)

{
  QueueHandle_t pQVar1;
  
  pQVar1 = xQueueCreateCountingSemaphore(0x80,count);
  *(QueueHandle_t *)&sem->hdl = pQVar1;
  return 0;
}



void aos_sem_free(aos_sem_t *sem)

{
  if (sem != (aos_sem_t *)0x0) {
    vQueueDelete((QueueHandle_t)sem->hdl);
    return;
  }
  return;
}



int aos_sem_wait(aos_sem_t *sem,uint ms)

{
  BaseType_t BVar1;
  
  if (sem != (aos_sem_t *)0x0) {
    BVar1 = xQueueSemaphoreTake((QueueHandle_t)sem->hdl,ms);
    return -(uint)(BVar1 != 1);
  }
  return -1;
}



void aos_sem_signal(aos_sem_t *sem)

{
  BaseType_t BStack20;
  BaseType_t xHigherPriorityTaskWoken;
  
  BStack20 = 0;
  if (sem != (aos_sem_t *)0x0) {
    if (TrapNetCounter == 0) {
      xQueueGenericSend((QueueHandle_t)sem->hdl,(void *)0x0,0,0);
    }
    else {
      xQueueGiveFromISR((QueueHandle_t)sem->hdl,&BStack20);
      if (BStack20 != 0) {
        vTaskSwitchContext();
      }
    }
  }
  return;
}



void * aos_malloc(size_t xWantedSize)

{
  size_t sVar1;
  size_t sVar2;
  BlockLink_t *pBVar3;
  A_BLOCK_LINK *pAVar4;
  BlockLink_t *pxBlockToInsert;
  uint uVar5;
  uint uVar6;
  
  if (pxEnd == (BlockLink_t *)0x0) {
    vAssertCalled();
  }
  vTaskSuspendAll();
  sVar2 = xFreeBytesRemaining;
  sVar1 = xBlockAllocatedBit;
  if (((xBlockAllocatedBit & xWantedSize) == 0) && (xWantedSize != 0)) {
    uVar6 = xWantedSize + 8;
    if ((uVar6 & 7) != 0) {
      uVar6 = (uVar6 & 0xfffffff8) + 8;
    }
    if ((uVar6 != 0) && (uVar6 <= xFreeBytesRemaining)) {
      pAVar4 = xStart.pxNextFreeBlock;
      pBVar3 = &xStart;
      do {
        pxBlockToInsert = pBVar3;
        pBVar3 = (BlockLink_t *)pAVar4;
        if (uVar6 <= pBVar3->xBlockSize) break;
        pAVar4 = pBVar3->pxNextFreeBlock;
      } while (pBVar3->pxNextFreeBlock != (A_BLOCK_LINK *)0x0);
      if (pxEnd != pBVar3) {
        pAVar4 = pxBlockToInsert->pxNextFreeBlock;
        pxBlockToInsert->pxNextFreeBlock = pBVar3->pxNextFreeBlock;
        uVar5 = pBVar3->xBlockSize;
        pAVar4 = pAVar4 + 1;
        if (0x10 < uVar5 - uVar6) {
          pxBlockToInsert = (BlockLink_t *)((int)&pBVar3->pxNextFreeBlock + uVar6);
          pxBlockToInsert->xBlockSize = uVar5 - uVar6;
          pBVar3->xBlockSize = uVar6;
          prvInsertBlockIntoFreeList(pxBlockToInsert);
          uVar5 = pBVar3->xBlockSize;
        }
        xFreeBytesRemaining = sVar2 - uVar5;
        if (xFreeBytesRemaining < xMinimumEverFreeBytesRemaining) {
          xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
        }
        pBVar3->xBlockSize = sVar1 | uVar5;
        pBVar3->pxNextFreeBlock = (A_BLOCK_LINK *)0x0;
        xTaskResumeAll();
        if (pAVar4 != (A_BLOCK_LINK *)0x0) {
          return pAVar4;
        }
        goto LAB_230321be;
      }
    }
  }
  xTaskResumeAll();
LAB_230321be:
  vApplicationMallocFailedHook();
  return (void *)0x0;
}



void aos_free(void *pv)

{
  uint uVar1;
  
  if (pv == (void *)0x0) {
    return;
  }
  uVar1 = *(uint *)((int)pv + -4);
  if ((uVar1 & xBlockAllocatedBit) == 0) {
    vAssertCalled();
    if (*(int *)((int)pv + -8) == 0) {
      uVar1 = *(uint *)((int)pv + -4);
      if ((uVar1 & xBlockAllocatedBit) == 0) {
        return;
      }
      goto LAB_230322ce;
    }
  }
  else {
    if (*(int *)((int)pv + -8) == 0) goto LAB_230322ce;
  }
  vAssertCalled();
  uVar1 = *(uint *)((int)pv + -4);
  if (((uVar1 & xBlockAllocatedBit) == 0) || (*(int *)((int)pv + -8) != 0)) {
    return;
  }
LAB_230322ce:
  *(uint *)((int)pv + -4) = ~xBlockAllocatedBit & uVar1;
  vTaskSuspendAll();
  xFreeBytesRemaining = *(int *)((int)pv + -4) + xFreeBytesRemaining;
  prvInsertBlockIntoFreeList((BlockLink_t *)((int)pv + -8));
  xTaskResumeAll();
  return;
}



longlong aos_now_ms(void)

{
  BaseType_t BVar1;
  longlong in_fa0;
  TickType_t TStack24;
  TickType_t ticks;
  BaseType_t overflow_count;
  
  TStack24 = 0;
  ticks = 0;
  BVar1 = xTaskGetTickCount2(&TStack24,(BaseType_t *)&ticks);
  if (BVar1 != 1) {
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  return in_fa0;
}



int event_poll(file_t *f,_Bool setup,poll_notify_t *notify,pollfd *fd,void *opa)

{
  aos_mutex_t *mutex;
  undefined3 in_register_0000202d;
  
  mutex = (aos_mutex_t *)f->f_arg;
  aos_mutex_lock(mutex,0xffffffff);
  if (CONCAT31(in_register_0000202d,setup) == 0) {
    mutex[1].hdl = (void *)0x0;
    mutex[3].hdl = (void *)0x0;
  }
  else {
    *(poll_notify_t **)&mutex[1].hdl = notify;
    *(pollfd **)&mutex[2].hdl = fd;
    mutex[3].hdl = opa;
    if (mutex[4].hdl != (void *)0x0) {
      fd->revents = fd->revents | 1;
      (*notify)(fd,opa);
    }
  }
  aos_mutex_unlock(mutex);
  return 0;
}



int event_open(inode_t *node,file_t *file)

{
  aos_mutex_t *mutex;
  
  mutex = (aos_mutex_t *)aos_malloc(0x28);
  memset(mutex,0,0x28);
  aos_mutex_new(mutex);
  *(aos_mutex_t **)&mutex[5].hdl = mutex + 5;
  *(aos_mutex_t **)&mutex[6].hdl = mutex + 5;
  *(aos_mutex_t **)&mutex[8].hdl = mutex + 8;
  *(aos_mutex_t **)&mutex[9].hdl = mutex + 8;
  *(aos_mutex_t **)&file->f_arg = mutex;
  return 0;
}



ssize_t _event_write(void *buf,size_t len,_Bool urgent)

{
  int *piVar1;
  undefined3 in_register_00002031;
  int in_a3;
  int iVar2;
  int *piVar3;
  int **ppiVar4;
  size_t __n;
  
  __n = CONCAT31(in_register_00002031,urgent);
  aos_mutex_lock((aos_mutex_t *)buf,0xffffffff);
  if ((*(int *)((int)buf + 0x1c) < 1) || (piVar1 = *(int **)((int)buf + 0x24), __n != piVar1[2])) {
    piVar1 = (int *)aos_malloc(__n + 0xc);
    if (piVar1 == (int *)0x0) {
      __n = 0xffffffff;
      goto out;
    }
  }
  else {
    piVar3 = (int *)piVar1[1];
    iVar2 = *piVar1;
    *(int **)(iVar2 + 4) = piVar3;
    *piVar3 = iVar2;
    *(int *)((int)buf + 0x1c) = *(int *)((int)buf + 0x1c) + -1;
  }
  *(int *)((int)buf + 0x10) = *(int *)((int)buf + 0x10) + 1;
  piVar1[2] = __n;
  memcpy(piVar1 + 3,(void *)len,__n);
  if (in_a3 == 0) {
    iVar2 = *(int *)((int)buf + 0x14);
    piVar1[1] = (int)buf + 0x14;
    *piVar1 = iVar2;
    *(int **)(iVar2 + 4) = piVar1;
    *(int **)((int)buf + 0x14) = piVar1;
  }
  else {
    ppiVar4 = *(int ***)((int)buf + 0x18);
    *piVar1 = (int)buf + 0x14;
    *(int ***)(piVar1 + 1) = ppiVar4;
    *(int **)((int)buf + 0x18) = piVar1;
    *ppiVar4 = piVar1;
  }
  if (*(int *)((int)buf + 4) != 0) {
    *(ushort *)(*(int *)((int)buf + 8) + 6) = *(ushort *)(*(int *)((int)buf + 8) + 6) | 1;
    (**(code **)((int)buf + 4))
              (*(undefined4 *)((int)buf + 8),*(undefined4 *)((int)buf + 0xc),
               *(code **)((int)buf + 4));
  }
out:
  aos_mutex_unlock((aos_mutex_t *)buf);
  return __n;
}



int event_ioctl(file_t *f,int cmd,ulong arg)

{
  ssize_t sVar1;
  
  if (((cmd & 0xfU) != 1) && ((cmd & 0xfU) != 2)) {
    return -1;
  }
  sVar1 = _event_write(f->f_arg,arg,SUB41(cmd >> 4,0));
  return sVar1;
}



ssize_t event_write(file_t *f,void *buf,size_t len)

{
  ssize_t sVar1;
  
  sVar1 = _event_write(f->f_arg,(size_t)buf,SUB41(len,0));
  return sVar1;
}



int event_close(file_t *file)

{
  aos_mutex_t *mutex;
  aos_mutex_t *pv;
  void *pvVar1;
  void **ppvVar2;
  
  mutex = (aos_mutex_t *)file->f_arg;
  aos_mutex_free(mutex);
  while (pv = (aos_mutex_t *)mutex[6].hdl, pv != mutex + 5) {
    pvVar1 = pv->hdl;
    ppvVar2 = (void **)pv[1].hdl;
    *(void ***)((int)pvVar1 + 4) = ppvVar2;
    *ppvVar2 = pvVar1;
    aos_free(pv);
  }
  while (pv = (aos_mutex_t *)mutex[9].hdl, pv != mutex + 8) {
    pvVar1 = pv->hdl;
    ppvVar2 = (void **)pv[1].hdl;
    *(void ***)((int)pvVar1 + 4) = ppvVar2;
    *ppvVar2 = pvVar1;
    aos_free(pv);
  }
  aos_free(mutex);
  return 0;
}



// WARNING: Type propagation algorithm not settling

ssize_t event_read(file_t *f,void *buf,size_t len)

{
  aos_mutex_t *mutex;
  void *pv;
  int iVar1;
  int *piVar2;
  void **ppvVar3;
  uint __n;
  
  mutex = (aos_mutex_t *)f->f_arg;
  __n = (uint)mutex[4].hdl;
  if (__n != 0) {
    aos_mutex_lock(mutex,0xffffffff);
    pv = mutex[6].hdl;
    iVar1 = *(int *)pv;
    piVar2 = *(int **)((int)pv + 4);
    *(int **)(iVar1 + 4) = piVar2;
    *piVar2 = iVar1;
    __n = *(uint *)((int)pv + 8);
    if (len < *(uint *)((int)pv + 8)) {
      __n = len;
    }
    memcpy(buf,(void *)((int)pv + 0xc),__n);
    if ((int)mutex[7].hdl < 4) {
      ppvVar3 = (void **)mutex[9].hdl;
      *(aos_mutex_t **)pv = mutex + 8;
      *(void ***)((int)pv + 4) = ppvVar3;
      mutex[9].hdl = pv;
      *ppvVar3 = pv;
      mutex[7].hdl = (void *)((int)mutex[7].hdl + 1);
    }
    else {
      aos_free(pv);
    }
    mutex[4].hdl = (void *)((int)mutex[4].hdl + -1);
    aos_mutex_unlock(mutex);
  }
  return __n;
}



int vfs_device_init(void)

{
  int iVar1;
  
  iVar1 = 0;
  if ((inited != 1) &&
     (iVar1 = aos_register_driver("/dev/event",(file_ops_t *)&event_fops,(void *)0x0), iVar1 == 0))
  {
    inited = 1;
  }
  return iVar1;
}



// WARNING: Could not reconcile some variable overlaps

void event_read_cb(int fd,void *param)

{
  dlist_s *pdVar1;
  ssize_t sVar2;
  undefined auStack32 [4];
  input_event_t event;
  
  sVar2 = aos_read(fd,auStack32,0x10);
  if (sVar2 == 0x10) {
    pdVar1 = g_local_event_list.next;
    if ((short)event.time == 0x100) {
      (*event._4_4_)(event.value,event._4_4_);
    }
    else {
      while (pdVar1 != (dlist_s *)&g_local_event_list) {
        if ((*(short *)&((dlist_t *)pdVar1)[2].prev == 0) ||
           ((short)event.time == *(short *)&((dlist_t *)pdVar1)[2].prev)) {
          (*(code *)((dlist_t *)pdVar1)[1].prev)
                    (auStack32,((dlist_t *)pdVar1)[1].next,((dlist_t *)pdVar1)[1].prev);
        }
        pdVar1 = ((dlist_t *)pdVar1)->next;
      }
    }
  }
  return;
}



int aos_event_service_init(void)

{
  int sock;
  
  sock = aos_open("/dev/event",0);
  if (local_event.fd < 0) {
    local_event.fd = sock;
  }
  aos_poll_read_fd(sock,event_read_cb,(void *)0x0);
  aos_loop_set_eventfd(sock);
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

int aos_post_event(uint16_t type,uint16_t code,ulong value)

{
  undefined2 in_register_0000202a;
  int iVar1;
  undefined4 local_20;
  input_event_t event;
  
  event.time._0_2_ = (ushort)((CONCAT22(in_register_0000202a,type) << 0x11) >> 0x11);
  local_20 = 0;
  event.value = 0;
  event.time._2_2_ = code;
  event._4_4_ = value;
  iVar1 = aos_ioctl(local_event.fd,(CONCAT22(in_register_0000202a,type) >> 0xf) + 0x101,
                    (ulong)&local_20);
  return iVar1;
}



int aos_register_event_filter(uint16_t type,aos_event_cb *cb,void *priv)

{
  dlist_s *pdVar1;
  int iVar2;
  
  if (cb != (aos_event_cb *)0x0) {
    pdVar1 = (dlist_s *)aos_malloc(0x14);
    iVar2 = -0xc;
    if (pdVar1 != (dlist_s *)0x0) {
      *(aos_event_cb **)&pdVar1[1].prev = cb;
      *(uint16_t *)&pdVar1[2].prev = type;
      pdVar1->prev = g_local_event_list.prev;
      pdVar1[1].next = priv;
      *(dlist_t **)&pdVar1->next = &g_local_event_list;
      (g_local_event_list.prev)->next = pdVar1;
      iVar2 = 0;
      g_local_event_list.prev = pdVar1;
    }
    return iVar2;
  }
  return -0x16;
}



// WARNING: Could not reconcile some variable overlaps

IoT_Error_t aws_iot_shadow_init(AWS_IoT_Client *pClient,ShadowInitParameters_t *pParams)

{
  IoT_Error_t IVar1;
  undefined3 extraout_var;
  _Bool a_Stack68 [4];
  IoT_Client_Init_Params mqttInitParams;
  
  memcpy(a_Stack68,&DAT_230879c0,0x34);
  IVar1 = NULL_VALUE_ERROR;
  if ((pClient != (AWS_IoT_Client *)0x0) && (pParams != (ShadowInitParameters_t *)0x0)) {
    a_Stack68[0] = pParams->enableAutoReconnect;
    mqttInitParams._0_4_ = pParams->pHost;
    mqttInitParams.pHostURL._0_2_ = pParams->port;
    mqttInitParams._8_4_ = pParams->pRootCA;
    mqttInitParams.pRootCALocation = pParams->pClientCRT;
    mqttInitParams.pDeviceCertLocation = pParams->pClientKey;
    mqttInitParams.pDevicePrivateKeyLocation = (char *)0x1388;
    mqttInitParams.tlsHandshakeTimeout_ms._0_1_ = true;
    mqttInitParams._36_4_ = pParams->disconnectHandler;
    IVar1 = aws_iot_mqtt_init(pClient,(IoT_Client_Init_Params *)a_Stack68);
    if (CONCAT31(extraout_var,IVar1) == 0) {
      resetClientTokenSequenceNum();
      shadowJsonVersionNum = 0;
      initDeltaTokens();
    }
  }
  return IVar1;
}



// WARNING: Could not reconcile some variable overlaps

IoT_Error_t
aws_iot_shadow_connect(AWS_IoT_Client *pClient,ShadowConnectParameters_t_conflict6 *pParams)

{
  IoT_Error_t IVar1;
  undefined3 extraout_var;
  size_t sVar2;
  undefined auStack88 [4];
  IoT_Client_Connect_Params ConnectParams;
  
  IVar1 = NULL_VALUE_ERROR;
  memcpy(auStack88,&iotClientConnectParamsDefault,0x38);
  if (((pClient != (AWS_IoT_Client *)0x0) && (pParams != (ShadowConnectParameters_t_conflict6 *)0x0)
      ) && (pParams->pMqttClientId != (char *)0x0)) {
    snprintf(myThingName,0x14,"%s",pParams->pMyThingName);
    snprintf(mqttClientID,0x50,"%s",pParams->pMqttClientId);
    ConnectParams.struct_id[0] = MQTT_3_1_1;
    ConnectParams.pClientID._2_2_ = 600;
    ConnectParams.clientIDLen = 1;
    ConnectParams._4_4_ = pParams->pMqttClientId;
    ConnectParams.pClientID._0_2_ = pParams->mqttClientIdLen;
    ConnectParams._44_4_ = (char *)0x0;
    ConnectParams.will._16_4_ = (char *)0x0;
    IVar1 = aws_iot_mqtt_connect(pClient,(IoT_Client_Connect_Params *)auStack88);
    if (CONCAT31(extraout_var,IVar1) == 0) {
      initializeRecords(pClient);
      if (pParams->deleteActionHandler != (pApplicationHandler_t *)0x0) {
        snprintf(deleteAcceptedTopic,0x50,"$aws/things/%s/shadow/delete/accepted",myThingName);
        sVar2 = strlen(deleteAcceptedTopic);
        IVar1 = aws_iot_mqtt_subscribe
                          (pClient,deleteAcceptedTopic,(uint16_t)sVar2,QOS1,
                           pParams->deleteActionHandler,myThingName);
      }
    }
  }
  return IVar1;
}



IoT_Error_t aws_iot_shadow_register_delta(AWS_IoT_Client *pMqttClient,jsonStruct_t *pStruct)

{
  _Bool _Var1;
  IoT_Error_t IVar2;
  undefined3 extraout_var;
  
  if ((pMqttClient != (AWS_IoT_Client *)0x0) && (pStruct != (jsonStruct_t *)0x0)) {
    _Var1 = aws_iot_mqtt_is_client_connected(pMqttClient);
    if (CONCAT31(extraout_var,_Var1) != 0) {
      IVar2 = registerJsonTokenOnDelta(pStruct);
      return IVar2;
    }
    return MQTT_CONNECTION_ERROR;
  }
  return NULL_VALUE_ERROR;
}



IoT_Error_t aws_iot_shadow_yield(AWS_IoT_Client *pClient,uint32_t timeout)

{
  IoT_Error_t IVar1;
  
  if (pClient != (AWS_IoT_Client *)0x0) {
    HandleExpiredResponseCallbacks();
    IVar1 = aws_iot_mqtt_yield(pClient,timeout);
    return IVar1;
  }
  return NULL_VALUE_ERROR;
}



IoT_Error_t aws_iot_shadow_disconnect(AWS_IoT_Client *pClient)

{
  ClientState CVar1;
  _Bool _Var2;
  IoT_Error_t IVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  int iVar4;
  undefined3 extraout_var_01;
  
  if (pClient != (AWS_IoT_Client *)0x0) {
    CVar1 = aws_iot_mqtt_get_client_state(pClient);
    _Var2 = aws_iot_mqtt_is_client_connected(pClient);
    IVar3 = NETWORK_DISCONNECTED_ERROR;
    if (CONCAT31(extraout_var_00,_Var2) != 0) {
      iVar4 = aws_iot_mqtt_set_client_state(pClient,CONCAT31(extraout_var,CVar1),10);
      IVar3 = (IoT_Error_t)iVar4;
      if (iVar4 == 0) {
        IVar3 = _aws_iot_mqtt_internal_disconnect(pClient);
        if (CONCAT31(extraout_var_01,IVar3) == 0) {
          (pClient->clientStatus).clientState = CLIENT_STATE_DISCONNECTED_MANUALLY;
        }
        else {
          (pClient->clientStatus).clientState = CVar1;
        }
      }
    }
    return IVar3;
  }
  return NULL_VALUE_ERROR;
}



IoT_Error_t
aws_iot_shadow_update
          (AWS_IoT_Client *pClient,char *pThingName,char *pJsonString,fpActionCallback_t *callback,
          void *pContextData,uint8_t timeout_seconds,_Bool isPersistentSubscribe)

{
  _Bool _Var1;
  IoT_Error_t IVar2;
  undefined3 extraout_var;
  size_t jsonSize;
  undefined3 in_register_0000203d;
  
  if (pClient == (AWS_IoT_Client *)0x0) {
    return NULL_VALUE_ERROR;
  }
  _Var1 = aws_iot_mqtt_is_client_connected(pClient);
  if (CONCAT31(extraout_var,_Var1) != 0) {
    jsonSize = strlen(pJsonString);
    IVar2 = aws_iot_shadow_internal_action
                      (pThingName,SHADOW_UPDATE,pJsonString,jsonSize,callback,pContextData,
                       CONCAT31(in_register_0000203d,timeout_seconds),isPersistentSubscribe);
    return IVar2;
  }
  return MQTT_CONNECTION_ERROR;
}



IoT_Error_t aws_iot_shadow_set_autoreconnect_status(AWS_IoT_Client *pClient,_Bool newStatus)

{
  if (pClient != (AWS_IoT_Client *)0x0) {
    (pClient->clientStatus).isAutoReconnectEnabled = newStatus;
    return SUCCESS;
  }
  return NULL_VALUE_ERROR;
}



IoT_Error_t
aws_iot_shadow_internal_action
          (char *pThingName,ShadowActions_t action,char *pJsonDocumentToBeSent,size_t jsonSize,
          fpActionCallback_t *callback,void *pCallbackContext,uint32_t timeout_seconds,
          _Bool isSticky)

{
  _Bool _Var1;
  _Bool _Var2;
  _Bool _Var3;
  IoT_Error_t IVar4;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  int iVar5;
  uint8_t uStack141;
  char acStack140 [3];
  uint8_t indexAckWaitList;
  char extractedClientToken [90];
  
  IVar4 = NULL_VALUE_ERROR;
  if ((pThingName != (char *)0x0) && (pJsonDocumentToBeSent != (char *)0x0)) {
    _Var1 = extractClientToken(pJsonDocumentToBeSent,jsonSize,acStack140,0x5a);
    if ((CONCAT31(extraout_var,_Var1) == 0) || (callback == (fpActionCallback_t *)0x0)) {
      iVar5 = 0;
    }
    else {
      _Var2 = getNextFreeIndexOfAckWaitList(&uStack141);
      if (CONCAT31(extraout_var_00,_Var2) == 0) {
        return FAILURE;
      }
      _Var3 = isSubscriptionPresent(pThingName,action);
      iVar5 = CONCAT31(extraout_var_01,_Var3);
      if (iVar5 == 0) {
        IVar4 = subscribeToShadowActionAcks(pThingName,action,isSticky);
        iVar5 = CONCAT31(extraout_var_00,_Var2);
        if (CONCAT31(extraout_var_02,IVar4) != 0) {
          return IVar4;
        }
      }
      else {
        incrementSubscriptionCnt(pThingName,action,isSticky);
      }
    }
    IVar4 = publishToShadowAction(pThingName,action,pJsonDocumentToBeSent);
    if ((((CONCAT31(extraout_var,_Var1) != 0) && (callback != (fpActionCallback_t *)0x0)) &&
        (CONCAT31(extraout_var_03,IVar4) == 0)) && (iVar5 != 0)) {
      addToAckWaitList(uStack141,pThingName,action,acStack140,callback,pCallbackContext,
                       timeout_seconds);
    }
  }
  return IVar4;
}



IoT_Error_t
convertDataToString(char *pStringBuffer,size_t maxSizoStringBuffer,JsonPrimitiveType type,
                   void *pData)

{
  uint uVar1;
  undefined3 in_register_00002031;
  int iVar2;
  char *__format;
  char *pcVar3;
  IoT_Error_t IVar4;
  size_t sVar5;
  
  iVar2 = CONCAT31(in_register_00002031,type);
  if (maxSizoStringBuffer == 0) {
    return SHADOW_JSON_ERROR;
  }
  if (iVar2 == 0) {
    pcVar3 = *(char **)pData;
    __format = "%li,";
LAB_2304db20:
    uVar1 = snprintf(pStringBuffer,maxSizoStringBuffer,__format,pcVar3);
  }
  else {
    if (iVar2 == 1) {
      pcVar3 = (char *)(int)*(short *)pData;
      __format = "%hi,";
      goto LAB_2304db20;
    }
    if (iVar2 == 2) {
      pcVar3 = (char *)(int)*(char *)pData;
      __format = "%hhi,";
      goto LAB_2304db20;
    }
    if (iVar2 == 3) {
      pcVar3 = *(char **)pData;
      __format = "%lu,";
      goto LAB_2304db20;
    }
    if (iVar2 == 4) {
      pcVar3 = (char *)(uint)*(ushort *)pData;
      __format = "%hu,";
      goto LAB_2304db20;
    }
    if (iVar2 == 5) {
      pcVar3 = (char *)(uint)*(byte *)pData;
      __format = "%hhu,";
      goto LAB_2304db20;
    }
    if (iVar2 == 7) {
      pcVar3 = *(char **)pData;
      sVar5 = *(size_t *)((int)pData + 4);
    }
    else {
      if (iVar2 != 6) {
        if (iVar2 == 8) {
          if (*(char *)pData == '\0') {
            pcVar3 = "false";
          }
          else {
            pcVar3 = "true";
          }
LAB_2304dbe6:
          iVar2 = -0x538;
        }
        else {
          pcVar3 = (char *)pData;
          if (iVar2 != 9) {
            uVar1 = 0;
            if (iVar2 != 10) goto LAB_2304dc16;
            goto LAB_2304dbe6;
          }
          iVar2 = -0x534;
        }
        __format = "ERROR failed! net_set_(non)block() returned -0x%x\r\n" + iVar2 + 0x14;
        goto LAB_2304db20;
      }
      pcVar3 = pStringBuffer;
      sVar5 = maxSizoStringBuffer;
      __extendsfdf2((SFtype)pStringBuffer);
    }
    uVar1 = snprintf(pStringBuffer,maxSizoStringBuffer,"%f,",pcVar3,sVar5);
  }
  if ((int)uVar1 < 0) {
    return SHADOW_JSON_ERROR;
  }
LAB_2304dc16:
  IVar4 = SUCCESS;
  if (maxSizoStringBuffer <= uVar1) {
    IVar4 = SHADOW_JSON_BUFFER_TRUNCATED;
  }
  return IVar4;
}



void resetClientTokenSequenceNum(void)

{
  clientTokenNum = 0;
  return;
}



IoT_Error_t aws_iot_shadow_init_json_document(char *pJsonDocument,size_t maxSizeOfJsonDocument)

{
  uint uVar1;
  IoT_Error_t IVar2;
  
  if (pJsonDocument != (char *)0x0) {
    uVar1 = snprintf(pJsonDocument,maxSizeOfJsonDocument,"{\"state\":{");
    IVar2 = SHADOW_JSON_ERROR;
    if ((-1 < (int)uVar1) && (IVar2 = SUCCESS, maxSizeOfJsonDocument <= uVar1)) {
      IVar2 = SHADOW_JSON_BUFFER_TRUNCATED;
    }
    return IVar2;
  }
  return NULL_VALUE_ERROR;
}



IoT_Error_t
aws_iot_shadow_add_reported(char *pJsonDocument,size_t maxSizeOfJsonDocument,uint8_t count,...)

{
  int *piVar1;
  IoT_Error_t IVar2;
  size_t sVar3;
  uint uVar4;
  undefined3 extraout_var;
  int *in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  int iVar5;
  uint __maxlen;
  int **ppiStack84;
  va_list pArgs;
  int *piStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  undefined4 uStack8;
  undefined4 uStack4;
  
  ppiStack84 = &piStack20;
  if (pJsonDocument == (char *)0x0) {
LAB_2304dc88:
    IVar2 = NULL_VALUE_ERROR;
  }
  else {
    piStack20 = in_a3;
    uStack16 = in_a4;
    uStack12 = in_a5;
    uStack8 = in_a6;
    uStack4 = in_a7;
    sVar3 = strlen(pJsonDocument);
    __maxlen = maxSizeOfJsonDocument - sVar3;
    if (__maxlen < 2) {
LAB_2304dcb6:
      IVar2 = SHADOW_JSON_ERROR;
    }
    else {
      sVar3 = strlen(pJsonDocument);
      uVar4 = snprintf(pJsonDocument + sVar3,__maxlen,"\"reported\":{");
      IVar2 = SHADOW_JSON_ERROR;
      if (-1 < (int)uVar4) {
        iVar5 = 0;
        if (uVar4 < __maxlen) {
          while (iVar5 < _count) {
            sVar3 = strlen(pJsonDocument);
            __maxlen = maxSizeOfJsonDocument - sVar3;
            if (__maxlen < 2) goto LAB_2304dcb6;
            piVar1 = *ppiStack84;
            ppiStack84 = ppiStack84 + 1;
            if (piVar1 == (int *)0x0) goto LAB_2304dc88;
            sVar3 = strlen(pJsonDocument);
            uVar4 = snprintf(pJsonDocument + sVar3,__maxlen,"\"%s\":",*piVar1);
            if ((int)uVar4 < 0) goto LAB_2304dcb6;
            if (__maxlen <= uVar4) goto LAB_2304dd10;
            if ((*piVar1 == 0) || (piVar1[1] == 0)) goto LAB_2304dc88;
            sVar3 = strlen(pJsonDocument);
            IVar2 = convertDataToString(pJsonDocument + sVar3,__maxlen,
                                        *(JsonPrimitiveType *)(piVar1 + 3),(void *)piVar1[1]);
            if (CONCAT31(extraout_var,IVar2) != 0) {
              return IVar2;
            }
            iVar5 = (iVar5 + 1) * 0x1000000 >> 0x18;
          }
          sVar3 = strlen(pJsonDocument);
          uVar4 = snprintf(pJsonDocument + (sVar3 - 1),__maxlen,"},");
          if ((int)uVar4 < 0) {
            return SHADOW_JSON_ERROR;
          }
          if (uVar4 < __maxlen) {
            return SUCCESS;
          }
        }
LAB_2304dd10:
        IVar2 = SHADOW_JSON_BUFFER_TRUNCATED;
      }
    }
  }
  return IVar2;
}



int32_t FillWithClientTokenSize
                  (char *pBufferToBeUpdatedWithClientToken,size_t maxSizeOfJsonDocument)

{
  int iVar1;
  
  clientTokenNum = clientTokenNum + 1;
  iVar1 = snprintf(pBufferToBeUpdatedWithClientToken,maxSizeOfJsonDocument,"%s-%d",mqttClientID);
  return iVar1;
}



IoT_Error_t aws_iot_finalize_json_document(char *pJsonDocument,size_t maxSizeOfJsonDocument)

{
  size_t sVar1;
  uint uVar2;
  uint __maxlen;
  
  if (pJsonDocument == (char *)0x0) {
    return NULL_VALUE_ERROR;
  }
  sVar1 = strlen(pJsonDocument);
  __maxlen = maxSizeOfJsonDocument - sVar1;
  if (1 < __maxlen) {
    sVar1 = strlen(pJsonDocument);
    uVar2 = snprintf(pJsonDocument + (sVar1 - 1),__maxlen,"}, \"%s\":\"","clientToken");
    if (-1 < (int)uVar2) {
      if (__maxlen <= uVar2) {
        return SHADOW_JSON_BUFFER_TRUNCATED;
      }
      sVar1 = strlen(pJsonDocument);
      __maxlen = maxSizeOfJsonDocument - sVar1;
      if (1 < __maxlen) {
        sVar1 = strlen(pJsonDocument);
        uVar2 = FillWithClientTokenSize(pJsonDocument + sVar1,__maxlen);
        if (-1 < (int)uVar2) {
          if (__maxlen <= uVar2) {
            return SHADOW_JSON_BUFFER_TRUNCATED;
          }
          sVar1 = strlen(pJsonDocument);
          __maxlen = maxSizeOfJsonDocument - sVar1;
          if (1 < __maxlen) {
            sVar1 = strlen(pJsonDocument);
            uVar2 = snprintf(pJsonDocument + sVar1,__maxlen,"\"}");
            if (-1 < (int)uVar2) {
              if (__maxlen <= uVar2) {
                return SHADOW_JSON_BUFFER_TRUNCATED;
              }
              return SUCCESS;
            }
          }
        }
      }
    }
  }
  return SHADOW_JSON_ERROR;
}



_Bool isJsonValidAndParse(char *pJsonDocument,size_t jsonSize,void *pJsonHandler,
                         int32_t *pTokenCount)

{
  int iVar1;
  undefined uVar2;
  
  jsmn_init(&shadowJsonParser);
  iVar1 = jsmn_parse(&shadowJsonParser,pJsonDocument,jsonSize,jsonTokenStruct,0x78);
  uVar2 = 0;
  if ((0 < iVar1) && (uVar2 = 0, jsonTokenStruct[0].type == JSMN_OBJECT)) {
    *pTokenCount = iVar1;
    uVar2 = 1;
  }
  return (_Bool)uVar2;
}



_Bool isJsonKeyMatchingAndUpdateValue
                (char *pJsonDocument,void *pJsonHandler,int32_t tokenCount,jsonStruct_t *pDataStruct
                ,uint32_t *pDataLength,int32_t *pDataPosition)

{
  JsonPrimitiveType JVar1;
  int8_t iVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  uint uVar3;
  int iVar4;
  uint32_t uVar5;
  undefined auStack80 [4];
  int iStack76;
  int iStack72;
  jsmntok_t jStack64;
  
  iVar4 = 1;
  while( true ) {
    if (tokenCount <= iVar4) {
      return false;
    }
    iVar2 = jsoneq(pJsonDocument,jsonTokenStruct + iVar4,pDataStruct->pKey);
    if (CONCAT31(extraout_var,iVar2) == 0) break;
    iVar2 = jsoneq(pJsonDocument,jsonTokenStruct + iVar4,"metadata");
    if (CONCAT31(extraout_var_00,iVar2) == 0) {
      return false;
    }
    iVar4 = iVar4 + 1;
  }
  iVar4 = iVar4 + 1;
  memcpy(auStack80,jsonTokenStruct + iVar4,0x10);
  iStack72 = jsonTokenStruct[iVar4].end;
  iVar4 = jsonTokenStruct[iVar4].start;
  uVar5 = iStack72 - iVar4;
  iStack76 = iVar4;
  memcpy(&jStack64,auStack80,0x10);
  JVar1 = pDataStruct->type;
  uVar3 = (uint)JVar1;
  if (JVar1 == SHADOW_JSON_BOOL) {
    if (pDataStruct->dataLength != 0) {
      parseBooleanValue((_Bool *)pDataStruct->pData,pJsonDocument,&jStack64);
    }
  }
  else {
    if (JVar1 == SHADOW_JSON_INT32) {
      if (3 < pDataStruct->dataLength) {
        parseInteger32Value((int32_t *)pDataStruct->pData,pJsonDocument,&jStack64);
      }
    }
    else {
      if (JVar1 == SHADOW_JSON_INT16) {
        if (uVar3 < pDataStruct->dataLength) {
          parseInteger16Value((int16_t *)pDataStruct->pData,pJsonDocument,&jStack64);
        }
      }
      else {
        if (JVar1 == SHADOW_JSON_INT8) {
          if (pDataStruct->dataLength != 0) {
            parseInteger8Value((int8_t *)pDataStruct->pData,pJsonDocument,&jStack64);
          }
        }
        else {
          if (JVar1 == SHADOW_JSON_UINT32) {
            if (uVar3 < pDataStruct->dataLength) {
              parseUnsignedInteger32Value((uint32_t *)pDataStruct->pData,pJsonDocument,&jStack64);
            }
          }
          else {
            if (JVar1 == SHADOW_JSON_UINT16) {
              if (1 < pDataStruct->dataLength) {
                parseUnsignedInteger16Value((uint16_t *)pDataStruct->pData,pJsonDocument,&jStack64);
              }
            }
            else {
              if (JVar1 == SHADOW_JSON_UINT8) {
                if (pDataStruct->dataLength != 0) {
                  parseUnsignedInteger8Value((uint8_t *)pDataStruct->pData,pJsonDocument,&jStack64);
                }
              }
              else {
                if (JVar1 == SHADOW_JSON_FLOAT) {
                  if (3 < pDataStruct->dataLength) {
                    parseFloatValue((float *)pDataStruct->pData,pJsonDocument,&jStack64);
                  }
                }
                else {
                  if (JVar1 == SHADOW_JSON_DOUBLE) {
                    if (uVar3 < pDataStruct->dataLength) {
                      parseDoubleValue((double *)pDataStruct->pData,pJsonDocument,&jStack64);
                    }
                  }
                  else {
                    if (JVar1 == SHADOW_JSON_STRING) {
                      parseStringValue((char *)pDataStruct->pData,pDataStruct->dataLength,
                                       pJsonDocument,&jStack64);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  *pDataPosition = iVar4;
  *pDataLength = uVar5;
  return true;
}



_Bool extractClientToken(char *pJsonDocument,size_t jsonSize,char *pExtractedClientToken,
                        size_t clientTokenSize)

{
  uint __n;
  int iVar1;
  int8_t iVar2;
  int iVar3;
  undefined3 extraout_var;
  
  jsmn_init(&shadowJsonParser);
  iVar3 = jsmn_parse(&shadowJsonParser,pJsonDocument,jsonSize,jsonTokenStruct,0x78);
  if ((0 < iVar3) && (jsonTokenStruct[0].type == JSMN_OBJECT)) {
    iVar1 = 1;
    do {
      if (iVar1 == iVar3) {
        return false;
      }
      iVar2 = jsoneq(pJsonDocument,jsonTokenStruct + iVar1,"clientToken");
      iVar1 = iVar1 + 1;
    } while (CONCAT31(extraout_var,iVar2) != 0);
    __n = jsonTokenStruct[iVar1].end - jsonTokenStruct[iVar1].start & 0xff;
    if (__n + 1 <= clientTokenSize) {
      strncpy(pExtractedClientToken,pJsonDocument + jsonTokenStruct[iVar1].start,__n);
      pExtractedClientToken[__n] = '\0';
      return true;
    }
  }
  return false;
}



_Bool extractVersionNumber
                (char *pJsonDocument,void *pJsonHandler,int32_t tokenCount,uint32_t *pVersionNumber)

{
  int iVar1;
  int iVar2;
  int8_t iVar3;
  IoT_Error_t IVar4;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  
  iVar1 = 1;
  do {
    iVar2 = iVar1;
    if (tokenCount <= iVar2) {
      return false;
    }
    iVar3 = jsoneq(pJsonDocument,jsonTokenStruct + iVar2,"version");
    iVar1 = iVar2 + 1;
  } while ((CONCAT31(extraout_var,iVar3) != 0) ||
          (IVar4 = parseUnsignedInteger32Value
                             (pVersionNumber,pJsonDocument,jsonTokenStruct + iVar2 + 1),
          CONCAT31(extraout_var_00,IVar4) != 0));
  return true;
}



void shadow_delta_callback
               (AWS_IoT_Client *pClient,char *topicName,uint16_t topicNameLen,
               IoT_Publish_Message_Params *params,void *pData)

{
  JsonTokenTable_t *pJVar1;
  _Bool _Var2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  uint uVar3;
  int32_t local_30;
  int32_t tokenCount;
  int32_t DataPosition;
  uint32_t dataLength;
  uint32_t tempVersionNumber;
  
  dataLength = 0;
  if (params->payloadLen < 0x201) {
    memcpy(shadowRxBuf,params->payload,params->payloadLen);
    shadowRxBuf[params->payloadLen] = '\0';
    _Var2 = isJsonValidAndParse(shadowRxBuf,0x201,(void *)0x0,&local_30);
    if (CONCAT31(extraout_var,_Var2) != 0) {
      if ((shadowDiscardOldDeltaFlag != false) &&
         (_Var2 = extractVersionNumber(shadowRxBuf,(void *)0x0,local_30,&dataLength),
         CONCAT31(extraout_var_00,_Var2) != 0)) {
        if (dataLength <= shadowJsonVersionNum) {
          return;
        }
        shadowJsonVersionNum = dataLength;
      }
      pJVar1 = tokenTable;
      uVar3 = 0;
      while (uVar3 < tokenTableIndex) {
        if (((pJVar1->isFree == false) &&
            (_Var2 = isJsonKeyMatchingAndUpdateValue
                               (shadowRxBuf,(void *)0x0,local_30,(jsonStruct_t *)pJVar1->pStruct,
                                (uint32_t *)&DataPosition,&tokenCount),
            CONCAT31(extraout_var_01,_Var2) != 0)) &&
           (pJVar1->callback != (jsonStructCallback_t *)0x0)) {
          (*pJVar1->callback)(shadowRxBuf + tokenCount,DataPosition,(jsonStruct_t *)pJVar1->pStruct)
          ;
        }
        uVar3 = uVar3 + 1;
        pJVar1 = pJVar1 + 1;
      }
    }
  }
  return;
}



int16_t findIndexOfSubscriptionList(char *pTopic)

{
  ushort uVar1;
  SubscriptionRecord_t *__s2;
  int iVar2;
  
  __s2 = SubscriptionList;
  uVar1 = 0;
  while ((__s2->isFree != false || (iVar2 = strcmp(pTopic,(char *)__s2), iVar2 != 0))) {
    uVar1 = uVar1 + 1 & 0xff;
    __s2 = __s2 + 1;
    if (uVar1 == 0x14) {
      return -1;
    }
  }
  return uVar1;
}



// WARNING: Variable defined which should be unmapped: ackTypeBuf

void topicNameFromThingAndAction
               (char *pTopic,char *pThingName,ShadowActions_t action,ShadowAckTopicTypes_t ackType)

{
  char *__src;
  undefined3 in_register_00002031;
  int iVar1;
  undefined3 in_register_00002035;
  char acStack40 [4];
  char actionBuf [10];
  char ackTypeBuf [10];
  
  iVar1 = CONCAT31(in_register_00002031,action);
  if (iVar1 == 0) {
    __src = "get";
  }
  else {
    if (iVar1 == 1) {
      __src = "update";
    }
    else {
      if (iVar1 != 2) goto LAB_2304e29c;
      __src = "delete";
    }
  }
  strncpy(acStack40,__src,10);
LAB_2304e29c:
  if (CONCAT31(in_register_00002035,ackType) == 0) {
    __src = "accepted";
  }
  else {
    if (CONCAT31(in_register_00002035,ackType) != 1) {
      snprintf(pTopic,0x50,"$aws/things/%s/shadow/%s",pThingName,acStack40);
      return;
    }
    __src = "rejected";
  }
  strncpy(actionBuf + 8,__src,10);
  snprintf(pTopic,0x50,"$aws/things/%s/shadow/%s/%s",pThingName,acStack40,actionBuf + 8);
  return;
}



// WARNING: Variable defined which should be unmapped: TemporaryTopicNameRejected

void unsubscribeFromAcceptedAndRejected(uint8_t index)

{
  byte bVar1;
  AWS_IoT_Client *pClient;
  IoT_Error_t IVar2;
  int16_t iVar3;
  undefined3 in_register_00002029;
  int iVar4;
  short extraout_var_01;
  size_t sVar5;
  undefined3 extraout_var;
  short extraout_var_02;
  undefined3 extraout_var_00;
  char acStack176 [4];
  char TemporaryTopicNameAccepted [80];
  char TemporaryTopicNameRejected [80];
  
  iVar4 = CONCAT31(in_register_00002029,index);
  topicNameFromThingAndAction
            (acStack176,AckWaitList[iVar4].thingName,AckWaitList[iVar4].action,SHADOW_ACCEPTED);
  topicNameFromThingAndAction
            (TemporaryTopicNameAccepted + 0x4c,AckWaitList[iVar4].thingName,
             AckWaitList[iVar4].action,SHADOW_REJECTED);
  iVar3 = findIndexOfSubscriptionList(acStack176);
  pClient = pMqttClient;
  iVar4 = CONCAT22(extraout_var_01,iVar3);
  if (-1 < extraout_var_01) {
    bVar1 = SubscriptionList[iVar4].count;
    if ((SubscriptionList[iVar4].isSticky == false) && (bVar1 == 1)) {
      sVar5 = strlen(acStack176);
      IVar2 = aws_iot_mqtt_unsubscribe(pClient,acStack176,(uint16_t)sVar5);
      if (CONCAT31(extraout_var,IVar2) == 0) {
        SubscriptionList[iVar4].isFree = true;
      }
    }
    else {
      if (1 < bVar1) {
        SubscriptionList[iVar4].count = bVar1 - 1;
      }
    }
  }
  iVar3 = findIndexOfSubscriptionList(TemporaryTopicNameAccepted + 0x4c);
  pClient = pMqttClient;
  iVar4 = CONCAT22(extraout_var_02,iVar3);
  if (-1 < extraout_var_02) {
    bVar1 = SubscriptionList[iVar4].count;
    if ((SubscriptionList[iVar4].isSticky == false) && (bVar1 == 1)) {
      sVar5 = strlen(TemporaryTopicNameAccepted + 0x4c);
      IVar2 = aws_iot_mqtt_unsubscribe(pClient,TemporaryTopicNameAccepted + 0x4c,(uint16_t)sVar5);
      if (CONCAT31(extraout_var_00,IVar2) == 0) {
        SubscriptionList[iVar4].isFree = true;
      }
    }
    else {
      if (1 < bVar1) {
        SubscriptionList[iVar4].count = bVar1 - 1;
      }
    }
  }
  return;
}



void AckStatusCallback(AWS_IoT_Client *pClient,char *topicName,uint16_t topicNameLen,
                      IoT_Publish_Message_Params *params,void *pData)

{
  int iVar1;
  _Bool _Var2;
  undefined3 extraout_var;
  char *pcVar3;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  int iVar4;
  Shadow_Ack_Status_t SVar5;
  ToBeReceivedAckRecord_t *__s1;
  int32_t iStack164;
  int32_t tokenCount;
  char temporaryClientToken [110];
  
  if (0x200 < params->payloadLen) {
    return;
  }
  memcpy(shadowRxBuf,params->payload,params->payloadLen);
  shadowRxBuf[params->payloadLen] = '\0';
  _Var2 = isJsonValidAndParse(shadowRxBuf,0x201,(void *)0x0,&iStack164);
  if (CONCAT31(extraout_var,_Var2) != 0) {
    pcVar3 = strstr(topicName,myThingName);
    if ((pcVar3 != (char *)0x0) &&
       ((pcVar3 = strstr(topicName,"get/accepted"), pcVar3 != (char *)0x0 ||
        (pcVar3 = strstr(topicName,"delta"), pcVar3 != (char *)0x0)))) {
      tokenCount = 0;
      _Var2 = extractVersionNumber(shadowRxBuf,(void *)0x0,iStack164,(uint32_t *)&tokenCount);
      if ((CONCAT31(extraout_var_00,_Var2) != 0) && (shadowJsonVersionNum < (uint)tokenCount)) {
        shadowJsonVersionNum = tokenCount;
      }
    }
    _Var2 = extractClientToken(shadowRxBuf,0x201,(char *)&tokenCount,0x6e);
    if (CONCAT31(extraout_var_01,_Var2) != 0) {
      __s1 = AckWaitList;
      iVar1 = 0;
      do {
        if (__s1->isFree == false) {
          iVar4 = strcmp((char *)__s1,(char *)&tokenCount);
          if (iVar4 == 0) {
            pcVar3 = strstr(topicName,"accepted");
            SVar5 = SHADOW_ACK_ACCEPTED;
            if (pcVar3 == (char *)0x0) {
              strstr(topicName,"rejected");
              SVar5 = SHADOW_ACK_REJECTED;
            }
            if (AckWaitList[iVar1].callback != (fpActionCallback_t *)0x0) {
              (*AckWaitList[iVar1].callback)
                        ((char *)(iVar1 * 0x88 + 0x4202086e),AckWaitList[iVar1].action,SVar5,
                         shadowRxBuf,AckWaitList[iVar1].pCallbackContext);
            }
            unsubscribeFromAcceptedAndRejected((uint8_t)iVar1);
            AckWaitList[iVar1].isFree = true;
            return;
          }
        }
        iVar1 = iVar1 + 1;
        __s1 = __s1 + 1;
      } while (iVar1 != 10);
    }
  }
  return;
}



void initDeltaTokens(void)

{
  JsonTokenTable_t *pJVar1;
  
  pJVar1 = tokenTable;
  do {
    pJVar1->isFree = true;
    pJVar1 = pJVar1 + 1;
  } while (pJVar1 != (JsonTokenTable_t *)pUsernameTemp);
  deltaTopicSubscribedFlag = false;
  tokenTableIndex = 0;
  return;
}



IoT_Error_t registerJsonTokenOnDelta(jsonStruct_t *pStruct)

{
  AWS_IoT_Client *pClient;
  IoT_Error_t IVar1;
  size_t sVar2;
  jsonStructCallback_t *pjVar3;
  
  IVar1 = SUCCESS;
  if (deltaTopicSubscribedFlag == false) {
    snprintf(shadowDeltaTopic,0x50,"$aws/things/%s/shadow/update/delta",myThingName);
    pClient = pMqttClient;
    sVar2 = strlen(shadowDeltaTopic);
    IVar1 = aws_iot_mqtt_subscribe
                      (pClient,shadowDeltaTopic,(uint16_t)sVar2,QOS0,shadow_delta_callback,
                       (void *)0x0);
    deltaTopicSubscribedFlag = true;
  }
  if (tokenTableIndex < 0x78) {
    tokenTable[tokenTableIndex].pKey = pStruct->pKey;
    pjVar3 = pStruct->cb;
    *(jsonStruct_t **)&tokenTable[tokenTableIndex].pStruct = pStruct;
    tokenTable[tokenTableIndex].callback = pjVar3;
    tokenTable[tokenTableIndex].isFree = false;
    tokenTableIndex = tokenTableIndex + 1;
  }
  else {
    IVar1 = FAILURE;
  }
  return IVar1;
}



void initializeRecords(AWS_IoT_Client *pClient)

{
  ToBeReceivedAckRecord_t *pTVar1;
  SubscriptionRecord_t *pSVar2;
  
  pTVar1 = AckWaitList;
  do {
    pTVar1->isFree = true;
    pTVar1 = pTVar1 + 1;
  } while (pTVar1 != (ToBeReceivedAckRecord_t *)&_fsymc_level_bloop);
  pSVar2 = SubscriptionList;
  do {
    pSVar2->isFree = true;
    pSVar2->count = '\0';
    pSVar2->isSticky = false;
    pSVar2 = pSVar2 + 1;
  } while (pSVar2 != (SubscriptionRecord_t *)&pMqttClient);
  pMqttClient = pClient;
  return;
}



_Bool isSubscriptionPresent(char *pThingName,ShadowActions_t action)

{
  bool bVar1;
  bool bVar2;
  SubscriptionRecord_t *__s2;
  int iVar3;
  char acStack192 [4];
  char TemporaryTopicNameAccepted [80];
  char TemporaryTopicNameRejected [80];
  
  topicNameFromThingAndAction(acStack192,pThingName,action,SHADOW_ACCEPTED);
  __s2 = SubscriptionList;
  topicNameFromThingAndAction(TemporaryTopicNameAccepted + 0x4c,pThingName,action,SHADOW_REJECTED);
  bVar1 = false;
  bVar2 = false;
  do {
    if (__s2->isFree == false) {
      iVar3 = strcmp(acStack192,(char *)__s2);
      if (iVar3 == 0) {
        bVar2 = true;
      }
      else {
        iVar3 = strcmp(TemporaryTopicNameAccepted + 0x4c,(char *)__s2);
        if (iVar3 == 0) {
          bVar1 = true;
        }
      }
    }
    __s2 = __s2 + 1;
  } while (__s2 != (SubscriptionRecord_t *)&pMqttClient);
  if (bVar1) {
    bVar1 = bVar2;
  }
  return (_Bool)bVar1;
}



IoT_Error_t subscribeToShadowActionAcks(char *pThingName,ShadowActions_t action,_Bool isSticky)

{
  uint8_t uVar1;
  AWS_IoT_Client *pClient;
  IoT_Error_t IVar2;
  _Bool _Var3;
  size_t sVar4;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  SubscriptionRecord_t *pTopic;
  SubscriptionRecord_t *pTopic_00;
  int iVar5;
  int iVar6;
  int iVar7;
  undefined auStack76 [4];
  Timer subSettlingtimer;
  
  pTopic_00 = SubscriptionList;
  pTopic = SubscriptionList;
  iVar5 = 0;
  do {
    if (pTopic->isFree != false) {
      iVar6 = (int)(short)((ushort)iVar5 & 0xff);
      SubscriptionList[iVar5].isFree = false;
      goto LAB_2304e79a;
    }
    iVar5 = iVar5 + 1;
    pTopic = pTopic + 1;
  } while (iVar5 != 0x14);
  iVar6 = -1;
LAB_2304e79a:
  iVar5 = 0;
LAB_2304e79e:
  if (pTopic_00->isFree == false) goto LAB_2304e886;
  iVar7 = (int)(short)((ushort)iVar5 & 0xff);
  IVar2 = SUCCESS;
  pTopic = SubscriptionList + iVar5;
  SubscriptionList[iVar5].isFree = false;
  if (iVar6 == -1) goto LAB_2304e8d6;
  pTopic_00 = SubscriptionList + iVar6;
  topicNameFromThingAndAction((char *)pTopic_00,pThingName,action,SHADOW_ACCEPTED);
  pClient = pMqttClient;
  sVar4 = strlen((char *)pTopic_00);
  IVar2 = aws_iot_mqtt_subscribe
                    (pClient,(char *)pTopic_00,(uint16_t)sVar4,QOS0,AckStatusCallback,(void *)0x0);
  if (CONCAT31(extraout_var,IVar2) == 0) {
    SubscriptionList[iVar6].count = '\x01';
    *(_Bool *)(iVar6 * 0x53 + 0x420201d2) = isSticky;
    topicNameFromThingAndAction((char *)pTopic,pThingName,action,SHADOW_REJECTED);
    pClient = pMqttClient;
    sVar4 = strlen((char *)pTopic);
    IVar2 = aws_iot_mqtt_subscribe
                      (pClient,(char *)pTopic,(uint16_t)sVar4,QOS0,AckStatusCallback,(void *)0x0);
    if (CONCAT31(extraout_var_00,IVar2) == 0) {
      SubscriptionList[iVar5].count = '\x01';
      *(_Bool *)(iVar5 * 0x53 + 0x420201d2) = isSticky;
      init_timer((Timer *)auStack76);
      countdown_sec((Timer *)auStack76,2);
      do {
        _Var3 = has_timer_expired((Timer *)auStack76);
      } while (CONCAT31(extraout_var_01,_Var3) == 0);
      goto LAB_2304e856;
    }
  }
  goto LAB_2304e89a;
LAB_2304e886:
  iVar5 = iVar5 + 1;
  pTopic_00 = pTopic_00 + 1;
  if (iVar5 == 0x14) {
    if (iVar6 == -1) {
LAB_2304e856:
      IVar2 = SUCCESS;
    }
    else {
      iVar7 = -1;
      IVar2 = SUCCESS;
LAB_2304e89a:
      uVar1 = SubscriptionList[iVar6].count;
      SubscriptionList[iVar6].isFree = true;
      pClient = pMqttClient;
      if (uVar1 == '\x01') {
        sVar4 = strlen((char *)(SubscriptionList + iVar6));
        aws_iot_mqtt_unsubscribe(pClient,(char *)(SubscriptionList + iVar6),(uint16_t)sVar4);
      }
      if (iVar7 != -1) {
LAB_2304e8d6:
        SubscriptionList[iVar7].isFree = true;
      }
    }
    return IVar2;
  }
  goto LAB_2304e79e;
}



// WARNING: Variable defined which should be unmapped: TemporaryTopicNameRejected

void incrementSubscriptionCnt(char *pThingName,ShadowActions_t action,_Bool isSticky)

{
  SubscriptionRecord_t *__s2;
  int iVar1;
  char acStack176 [4];
  char TemporaryTopicNameAccepted [80];
  char TemporaryTopicNameRejected [80];
  
  topicNameFromThingAndAction(acStack176,pThingName,action,SHADOW_ACCEPTED);
  __s2 = SubscriptionList;
  topicNameFromThingAndAction(TemporaryTopicNameAccepted + 0x4c,pThingName,action,SHADOW_REJECTED);
  do {
    if ((__s2->isFree == false) &&
       ((iVar1 = strcmp(acStack176,(char *)__s2), iVar1 == 0 ||
        (iVar1 = strcmp(TemporaryTopicNameAccepted + 0x4c,(char *)__s2), iVar1 == 0)))) {
      __s2->isSticky = isSticky;
      __s2->count = __s2->count + '\x01';
    }
    __s2 = __s2 + 1;
  } while (__s2 != (SubscriptionRecord_t *)&pMqttClient);
  return;
}



// WARNING: Could not reconcile some variable overlaps

IoT_Error_t
publishToShadowAction(char *pThingName,ShadowActions_t action,char *pJsonDocumentToBeSent)

{
  AWS_IoT_Client *pClient;
  IoT_Error_t IVar1;
  size_t sVar2;
  undefined2 local_70 [2];
  IoT_Publish_Message_Params msgParams;
  char TemporaryTopicName [80];
  
  if (pThingName == (char *)0x0) {
    return NULL_VALUE_ERROR;
  }
  if (pJsonDocumentToBeSent != (char *)0x0) {
    topicNameFromThingAndAction((char *)&msgParams.payloadLen,pThingName,action,SHADOW_ACTION);
    local_70[0] = 0;
    msgParams.payload = (void *)strlen(pJsonDocumentToBeSent);
    pClient = pMqttClient;
    msgParams._4_4_ = pJsonDocumentToBeSent;
    sVar2 = strlen((char *)&msgParams.payloadLen);
    IVar1 = aws_iot_mqtt_publish
                      (pClient,(char *)&msgParams.payloadLen,(uint16_t)sVar2,
                       (IoT_Publish_Message_Params *)local_70);
    return IVar1;
  }
  return NULL_VALUE_ERROR;
}



_Bool getNextFreeIndexOfAckWaitList(uint8_t *pIndex)

{
  _Bool _Var1;
  ToBeReceivedAckRecord_t *pTVar2;
  uint8_t uVar3;
  
  _Var1 = false;
  if (pIndex != (uint8_t *)0x0) {
    pTVar2 = AckWaitList;
    uVar3 = '\0';
    do {
      _Var1 = pTVar2->isFree;
      if (_Var1 != false) {
        *pIndex = uVar3;
        return _Var1;
      }
      uVar3 = uVar3 + '\x01';
      pTVar2 = pTVar2 + 1;
    } while (uVar3 != '\n');
  }
  return _Var1;
}



void addToAckWaitList(uint8_t indexAckWaitList,char *pThingName,ShadowActions_t action,
                     char *pExtractedClientToken,fpActionCallback_t *callback,void *pCallbackContext
                     ,uint32_t timeout_seconds)

{
  undefined3 in_register_00002029;
  int iVar1;
  
  iVar1 = CONCAT31(in_register_00002029,indexAckWaitList);
  AckWaitList[iVar1].callback = callback;
  memcpy(AckWaitList + iVar1,pExtractedClientToken,0x5a);
  memcpy(AckWaitList[iVar1].thingName,pThingName,0x14);
  AckWaitList[iVar1].pCallbackContext = pCallbackContext;
  AckWaitList[iVar1].action = action;
  init_timer(&AckWaitList[iVar1].timer);
  countdown_sec(&AckWaitList[iVar1].timer,timeout_seconds);
  AckWaitList[iVar1].isFree = false;
  return;
}



void HandleExpiredResponseCallbacks(void)

{
  ToBeReceivedAckRecord_t *pTVar1;
  uint8_t index;
  _Bool _Var2;
  undefined3 extraout_var;
  
  pTVar1 = AckWaitList;
  index = '\0';
  do {
    if ((pTVar1->isFree == false) &&
       (_Var2 = has_timer_expired(&pTVar1->timer), CONCAT31(extraout_var,_Var2) != 0)) {
      if (pTVar1->callback != (fpActionCallback_t *)0x0) {
        (*pTVar1->callback)(pTVar1->thingName,pTVar1->action,SHADOW_ACK_TIMEOUT,shadowRxBuf,
                            pTVar1->pCallbackContext);
      }
      pTVar1->isFree = true;
      unsubscribeFromAcceptedAndRejected(index);
    }
    index = index + '\x01';
    pTVar1 = pTVar1 + 1;
  } while (index != '\n');
  return;
}



_Bool has_timer_expired(Timer *timer)

{
  TickType_t TVar1;
  uint uVar2;
  uint uVar3;
  
  TVar1 = xTaskGetTickCount();
  uVar2 = timer->timeout_ticks;
  uVar3 = TVar1 - timer->start_ticks;
  if ((uVar3 < uVar2) && (timer->last_polled_ticks == TVar1)) {
    vTaskDelay(1);
  }
  timer->last_polled_ticks = TVar1;
  return (_Bool)(uVar2 <= uVar3);
}



void countdown_ms(Timer *timer,uint32_t timeout)

{
  TickType_t TVar1;
  
  TVar1 = xTaskGetTickCount();
  timer->start_ticks = TVar1;
  timer->last_polled_ticks = 0;
  timer->timeout_ticks = timeout;
  return;
}



uint32_t left_ms(Timer *timer)

{
  TickType_t TVar1;
  uint32_t uVar2;
  
  TVar1 = xTaskGetTickCount();
  if (TVar1 - timer->start_ticks < timer->timeout_ticks) {
    uVar2 = (timer->start_ticks + timer->timeout_ticks) - TVar1;
  }
  else {
    uVar2 = 0;
  }
  return uVar2;
}



void countdown_sec(Timer *timer,uint32_t timeout)

{
  if (0x418937 < timeout) {
    puts("aws_timer");
    printf("ERRORtimeout is out of range: %lus\r\n",timeout);
  }
  countdown_ms(timer,timeout * 1000);
  return;
}



void init_timer(Timer *timer)

{
  timer->start_ticks = 0;
  timer->timeout_ticks = 0;
  timer->last_polled_ticks = 0;
  return;
}



int jsmn_parse(jsmn_parser *parser,char *js,size_t len,jsmntok_t *tokens,uint num_tokens)

{
  byte bVar1;
  char cVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  jsmntok_t *pjVar7;
  jsmntype_t jVar8;
  jsmntok_t *pjVar9;
  uint uVar10;
  
  uVar5 = parser->toknext;
LAB_2304ebda:
  uVar6 = parser->pos;
  if ((len <= uVar6) || (bVar1 = js[uVar6], bVar1 == 0)) {
    if (tokens != (jsmntok_t *)0x0) {
      uVar6 = parser->toknext;
      tokens = tokens + uVar6;
      while (uVar6 = uVar6 - 1, -1 < (int)uVar6) {
        if ((tokens[-1].start != -1) && (tokens[-1].end == -1)) {
          return -3;
        }
        tokens = tokens + -1;
      }
    }
    return uVar5;
  }
  if (bVar1 != 0x2c) {
    if (0x2c < bVar1) {
      if (bVar1 == 0x5d) {
LAB_2304ed06:
        if (tokens != (jsmntok_t *)0x0) {
          jVar8 = JSMN_OBJECT;
          if (bVar1 != 0x7d) {
            jVar8 = JSMN_ARRAY;
          }
          uVar10 = parser->toknext;
          pjVar7 = tokens + uVar10;
          do {
            pjVar9 = pjVar7;
            uVar10 = uVar10 - 1;
            if ((int)uVar10 < 0) {
              if (uVar10 == 0xffffffff) {
                return -2;
              }
              goto LAB_2304ed68;
            }
            pjVar7 = pjVar9 + -1;
          } while ((pjVar9[-1].start == -1) || (pjVar9[-1].end != -1));
          if (pjVar7->type != jVar8) {
            return -2;
          }
          parser->toksuper = -1;
          pjVar9[-1].end = uVar6 + 1;
          pjVar7 = tokens + uVar10;
          do {
            if ((pjVar7->start != -1) && (pjVar7->end == -1)) {
              parser->toksuper = uVar10;
              break;
            }
            uVar10 = uVar10 - 1;
            pjVar7 = pjVar7 + -1;
          } while (uVar10 != 0xffffffff);
        }
      }
      else {
        if (bVar1 < 0x5e) {
          if (bVar1 != 0x3a) {
            if (bVar1 != 0x5b) goto LAB_2304ef0c;
            goto LAB_2304ec9c;
          }
        }
        else {
          if (bVar1 != 0x7b) {
            if (bVar1 != 0x7d) goto LAB_2304ef0c;
            goto LAB_2304ed06;
          }
LAB_2304ec9c:
          uVar5 = uVar5 + 1;
          if (tokens == (jsmntok_t *)0x0) goto LAB_2304ed68;
          uVar6 = parser->toknext;
          if (num_tokens <= uVar6) {
            return -1;
          }
          parser->toknext = uVar6 + 1;
          pjVar7 = tokens + uVar6;
          pjVar7->end = -1;
          pjVar7->start = -1;
          pjVar7->size = 0;
          if (parser->toksuper != -1) {
            tokens[parser->toksuper].size = tokens[parser->toksuper].size + 1;
          }
          jVar8 = JSMN_OBJECT;
          if (bVar1 != 0x7b) {
            jVar8 = JSMN_ARRAY;
          }
          pjVar7->type = jVar8;
          pjVar7->start = parser->pos;
        }
        parser->toksuper = parser->toknext - 1;
      }
      goto LAB_2304ed68;
    }
    if (bVar1 == 0xd) goto LAB_2304ed68;
    if (bVar1 < 0xe) {
      if (1 < (byte)(bVar1 - 9)) {
LAB_2304ef0c:
        do {
          uVar10 = parser->pos;
          if (((len <= uVar10) || (bVar1 = js[uVar10], bVar1 == 0)) || (bVar1 == 0x20)) goto found;
          if (bVar1 < 0x21) {
            if ((8 < bVar1) && ((bVar1 < 0xb || (bVar1 == 0xd)))) goto found;
          }
          else {
            if (bVar1 == 0x3a) goto found;
            if (bVar1 < 0x3b) {
              if (bVar1 == 0x2c) goto found;
            }
            else {
              if ((bVar1 == 0x5d) || (bVar1 == 0x7d)) goto found;
            }
          }
          if (0x5e < (byte)(bVar1 - 0x20)) goto LAB_2304ee20;
          parser->pos = uVar10 + 1;
        } while( true );
      }
      goto LAB_2304ed68;
    }
    if (bVar1 == 0x20) goto LAB_2304ed68;
    if (bVar1 != 0x22) goto LAB_2304ef0c;
    parser->pos = uVar6 + 1;
    while( true ) {
      uVar10 = parser->pos;
      if ((len <= uVar10) || (cVar2 = js[uVar10], cVar2 == '\0')) {
        parser->pos = uVar6;
        return -3;
      }
      if (cVar2 == '\"') break;
      if ((cVar2 == '\\') && (uVar3 = uVar10 + 1, uVar3 < len)) {
        parser->pos = uVar3;
        bVar1 = js[uVar3];
        if (bVar1 != 0x66) {
          if (bVar1 < 0x67) {
            if (bVar1 != 0x2f) {
              if (bVar1 < 0x30) {
                if (bVar1 != 0x22) goto LAB_2304ee20;
              }
              else {
                if ((bVar1 != 0x5c) && (bVar1 != 0x62)) goto LAB_2304ee20;
              }
            }
          }
          else {
            if (bVar1 != 0x72) {
              if (bVar1 < 0x73) {
                if (bVar1 != 0x6e) goto LAB_2304ee20;
              }
              else {
                if (bVar1 != 0x74) {
                  if (bVar1 != 0x75) {
LAB_2304ee20:
                    parser->pos = uVar6;
                    return -2;
                  }
                  parser->pos = uVar10 + 2;
                  iVar4 = 4;
                  do {
                    uVar10 = parser->pos;
                    if ((len <= uVar10) || (bVar1 = js[uVar10], bVar1 == 0)) break;
                    if ((9 < (byte)(bVar1 - 0x30)) && (5 < (byte)((bVar1 & 0xdf) + 0xbf)))
                    goto LAB_2304ee20;
                    parser->pos = uVar10 + 1;
                    iVar4 = iVar4 + -1;
                  } while (iVar4 != 0);
                  parser->pos = parser->pos - 1;
                }
              }
            }
          }
        }
      }
      parser->pos = parser->pos + 1;
    }
    if (tokens != (jsmntok_t *)0x0) {
      uVar10 = parser->toknext;
      if (num_tokens <= uVar10) goto LAB_2304ed92;
      parser->toknext = uVar10 + 1;
      pjVar7 = tokens + uVar10;
      pjVar7->end = -1;
      pjVar7->start = -1;
      pjVar7->size = 0;
      uVar10 = parser->pos;
      pjVar7->type = JSMN_STRING;
      pjVar7->start = uVar6 + 1;
      pjVar7->end = uVar10;
    }
    goto LAB_2304edc6;
  }
  if (((tokens != (jsmntok_t *)0x0) && (parser->toksuper != -1)) &&
     (1 < (byte)(tokens[parser->toksuper].type + ~JSMN_UNDEFINED))) {
    uVar6 = parser->toknext;
    pjVar7 = tokens + uVar6;
    while (uVar6 = uVar6 - 1, -1 < (int)uVar6) {
      if ((((byte)(pjVar7[-1].type + ~JSMN_UNDEFINED) < 2) && (pjVar7[-1].start != -1)) &&
         (pjVar7[-1].end == -1)) {
        parser->toksuper = uVar6;
        break;
      }
      pjVar7 = pjVar7 + -1;
    }
  }
  goto LAB_2304ed68;
found:
  if (tokens == (jsmntok_t *)0x0) {
    parser->pos = uVar10 - 1;
  }
  else {
    uVar10 = parser->toknext;
    if (num_tokens <= uVar10) {
LAB_2304ed92:
      parser->pos = uVar6;
      return -1;
    }
    parser->toknext = uVar10 + 1;
    pjVar7 = tokens + uVar10;
    pjVar7->end = -1;
    pjVar7->start = -1;
    pjVar7->size = 0;
    uVar10 = parser->pos;
    pjVar7->type = JSMN_PRIMITIVE;
    pjVar7->start = uVar6;
    pjVar7->end = uVar10;
    parser->pos = parser->pos - 1;
  }
LAB_2304edc6:
  uVar5 = uVar5 + 1;
  if ((parser->toksuper != -1) && (tokens != (jsmntok_t *)0x0)) {
    tokens[parser->toksuper].size = tokens[parser->toksuper].size + 1;
  }
LAB_2304ed68:
  parser->pos = parser->pos + 1;
  goto LAB_2304ebda;
}



void jsmn_init(jsmn_parser *parser)

{
  parser->pos = 0;
  parser->toknext = 0;
  parser->toksuper = -1;
  return;
}



int8_t jsoneq(char *json,jsmntok_t *tok,char *s)

{
  int8_t iVar1;
  size_t __n;
  int iVar2;
  
  if (tok->type != JSMN_STRING) {
    return -1;
  }
  __n = strlen(s);
  if (__n == tok->end - tok->start) {
    iVar2 = strncmp(json + tok->start,s,__n);
    iVar1 = -(iVar2 != 0);
  }
  else {
    iVar1 = -1;
  }
  return iVar1;
}



IoT_Error_t parseUnsignedInteger32Value(uint32_t *i,char *jsonString,jsmntok_t *token)

{
  int iVar1;
  IoT_Error_t IVar2;
  
  if (token->type == JSMN_PRIMITIVE) {
    if (jsonString[token->start] != '-') {
      iVar1 = sscanf(jsonString + token->start,"%lu",i);
      IVar2 = SUCCESS;
      if (iVar1 != 1) {
        IVar2 = JSON_PARSE_ERROR;
      }
      return IVar2;
    }
  }
  return JSON_PARSE_ERROR;
}



IoT_Error_t parseUnsignedInteger16Value(uint16_t *i,char *jsonString,jsmntok_t *token)

{
  int iVar1;
  IoT_Error_t IVar2;
  
  if (token->type == JSMN_PRIMITIVE) {
    if (jsonString[token->start] != '-') {
      iVar1 = sscanf(jsonString + token->start,"%hu",i);
      IVar2 = SUCCESS;
      if (iVar1 != 1) {
        IVar2 = JSON_PARSE_ERROR;
      }
      return IVar2;
    }
  }
  return JSON_PARSE_ERROR;
}



IoT_Error_t parseUnsignedInteger8Value(uint8_t *i,char *jsonString,jsmntok_t *token)

{
  IoT_Error_t IVar1;
  int iVar2;
  uint uStack20;
  uint32_t i_word;
  
  if (token->type == JSMN_PRIMITIVE) {
    if (jsonString[token->start] != '-') {
      iVar2 = sscanf(jsonString + token->start,"%lu",&uStack20);
      if ((iVar2 == 1) && (uStack20 < 0x100)) {
        *i = (uint8_t)uStack20;
        IVar1 = SUCCESS;
      }
      else {
        IVar1 = JSON_PARSE_ERROR;
      }
      return IVar1;
    }
  }
  return JSON_PARSE_ERROR;
}



IoT_Error_t parseInteger32Value(int32_t *i,char *jsonString,jsmntok_t *token)

{
  int iVar1;
  IoT_Error_t IVar2;
  
  if (token->type == JSMN_PRIMITIVE) {
    iVar1 = sscanf(jsonString + token->start,"%ld",i);
    IVar2 = SUCCESS;
    if (iVar1 != 1) {
      IVar2 = JSON_PARSE_ERROR;
    }
    return IVar2;
  }
  return JSON_PARSE_ERROR;
}



IoT_Error_t parseInteger16Value(int16_t *i,char *jsonString,jsmntok_t *token)

{
  IoT_Error_t IVar1;
  int iVar2;
  int iStack20;
  int32_t i_word;
  
  if (token->type != JSMN_PRIMITIVE) {
    return JSON_PARSE_ERROR;
  }
  iVar2 = sscanf(jsonString + token->start,"%li",&iStack20);
  if ((iVar2 == 1) && (iStack20 + 0x8000U < 0x10000)) {
    *i = (int16_t)iStack20;
    IVar1 = SUCCESS;
  }
  else {
    IVar1 = JSON_PARSE_ERROR;
  }
  return IVar1;
}



IoT_Error_t parseInteger8Value(int8_t *i,char *jsonString,jsmntok_t *token)

{
  IoT_Error_t IVar1;
  int iVar2;
  int iStack20;
  int32_t i_word;
  
  if (token->type != JSMN_PRIMITIVE) {
    return JSON_PARSE_ERROR;
  }
  iVar2 = sscanf(jsonString + token->start,"%li",&iStack20);
  if ((iVar2 == 1) && (iStack20 + 0x80U < 0x100)) {
    *i = (int8_t)iStack20;
    IVar1 = SUCCESS;
  }
  else {
    IVar1 = JSON_PARSE_ERROR;
  }
  return IVar1;
}



IoT_Error_t parseFloatValue(float *f,char *jsonString,jsmntok_t *token)

{
  int iVar1;
  IoT_Error_t IVar2;
  
  if (token->type == JSMN_PRIMITIVE) {
    iVar1 = sscanf(jsonString + token->start,"%f",f);
    IVar2 = SUCCESS;
    if (iVar1 != 1) {
      IVar2 = JSON_PARSE_ERROR;
    }
    return IVar2;
  }
  return JSON_PARSE_ERROR;
}



IoT_Error_t parseDoubleValue(double *d,char *jsonString,jsmntok_t *token)

{
  int iVar1;
  IoT_Error_t IVar2;
  
  if (token->type == JSMN_PRIMITIVE) {
    iVar1 = sscanf(jsonString + token->start,"%lf",d);
    IVar2 = SUCCESS;
    if (iVar1 != 1) {
      IVar2 = JSON_PARSE_ERROR;
    }
    return IVar2;
  }
  return JSON_PARSE_ERROR;
}



IoT_Error_t parseBooleanValue(_Bool *b,char *jsonString,jsmntok_t *token)

{
  IoT_Error_t IVar1;
  
  if (token->type != JSMN_PRIMITIVE) {
    return JSON_PARSE_ERROR;
  }
  _IVar1 = strncmp(jsonString + token->start,"true",4);
  IVar1 = (IoT_Error_t)_IVar1;
  if (_IVar1 == 0) {
    *b = true;
  }
  else {
    _IVar1 = strncmp(jsonString + token->start,"false",5);
    IVar1 = (IoT_Error_t)_IVar1;
    if (_IVar1 == 0) {
      *b = false;
    }
    else {
      IVar1 = JSON_PARSE_ERROR;
    }
  }
  return IVar1;
}



IoT_Error_t parseStringValue(char *buf,size_t bufLen,char *jsonString,jsmntok_t *token)

{
  size_t __n;
  IoT_Error_t IVar1;
  
  __n = token->end - token->start;
  if (token->type == JSMN_STRING) {
    IVar1 = SHADOW_JSON_ERROR;
    if (__n + 1 <= bufLen) {
      strncpy(buf,jsonString + token->start,__n);
      buf[__n] = '\0';
      IVar1 = SUCCESS;
    }
  }
  else {
    IVar1 = JSON_PARSE_ERROR;
  }
  return IVar1;
}



ClientState aws_iot_mqtt_get_client_state(AWS_IoT_Client *pClient)

{
  if (pClient != (AWS_IoT_Client *)0x0) {
    return (pClient->clientStatus).clientState;
  }
  return CLIENT_STATE_INVALID;
}



IoT_Error_t aws_iot_mqtt_client_lock_mutex(AWS_IoT_Client *pClient,IoT_Mutex_t *pMutex)

{
  IoT_Error_t IVar1;
  
  if ((pClient != (AWS_IoT_Client *)0x0) && (pMutex != (IoT_Mutex_t *)0x0)) {
    if ((pClient->clientData).isBlockOnThreadLockEnabled == false) {
      IVar1 = aws_iot_thread_mutex_trylock(pMutex);
      return IVar1;
    }
    IVar1 = aws_iot_thread_mutex_lock(pMutex);
    return IVar1;
  }
  return NULL_VALUE_ERROR;
}



IoT_Error_t aws_iot_mqtt_client_unlock_mutex(AWS_IoT_Client *pClient,IoT_Mutex_t *pMutex)

{
  IoT_Error_t IVar1;
  
  if ((pClient != (AWS_IoT_Client *)0x0) && (pMutex != (IoT_Mutex_t *)0x0)) {
    IVar1 = aws_iot_thread_mutex_unlock(pMutex);
    return IVar1;
  }
  return NULL_VALUE_ERROR;
}



int aws_iot_mqtt_set_client_state(AWS_IoT_Client *param_1,uint param_2,ClientState param_3)

{
  int iVar1;
  IoT_Error_t IVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  int iVar3;
  IoT_Mutex_t *pMutex;
  
  if (param_1 != (AWS_IoT_Client *)0x0) {
    pMutex = &(param_1->clientData).state_change_mutex;
    IVar2 = aws_iot_mqtt_client_lock_mutex(param_1,pMutex);
    iVar3 = CONCAT31(extraout_var,IVar2);
    if (CONCAT31(extraout_var,IVar2) == 0) {
      iVar1 = -0x1d;
      if ((uint)(param_1->clientStatus).clientState == param_2) {
        (param_1->clientStatus).clientState = param_3;
        iVar1 = 0;
      }
      IVar2 = aws_iot_mqtt_client_unlock_mutex(param_1,pMutex);
      iVar3 = CONCAT31(extraout_var_00,IVar2);
      if (iVar1 != 0) {
        iVar3 = iVar1;
      }
    }
    return iVar3;
  }
  return 0xfffffffe;
}



IoT_Error_t
aws_iot_mqtt_set_connect_params
          (AWS_IoT_Client *pClient,IoT_Client_Connect_Params *pNewConnectParams)

{
  IoT_Error_t IVar1;
  size_t sVar2;
  
  if (pClient != (AWS_IoT_Client *)0x0) {
    IVar1 = NULL_VALUE_ERROR;
    if (pNewConnectParams != (IoT_Client_Connect_Params *)0x0) {
      (pClient->clientData).options.isWillMsgPresent = pNewConnectParams->isWillMsgPresent;
      (pClient->clientData).options.MQTTVersion = pNewConnectParams->MQTTVersion;
      (pClient->clientData).options.pClientID = pNewConnectParams->pClientID;
      (pClient->clientData).options.clientIDLen = pNewConnectParams->clientIDLen;
      sVar2 = strlen(pUsernameTemp);
      if (sVar2 == 0) {
        snprintf(pUsernameTemp,0x19,"?SDK=C&Version=%d.%d.%d",3,0,1);
      }
      (pClient->clientData).options.pUsername = pUsernameTemp;
      sVar2 = strlen(pUsernameTemp);
      (pClient->clientData).options.usernameLen = (uint16_t)sVar2;
      IVar1 = SUCCESS;
      (pClient->clientData).options.pPassword = pNewConnectParams->pPassword;
      (pClient->clientData).options.passwordLen = pNewConnectParams->passwordLen;
      (pClient->clientData).options.will.pTopicName = (pNewConnectParams->will).pTopicName;
      (pClient->clientData).options.will.topicNameLen = (pNewConnectParams->will).topicNameLen;
      (pClient->clientData).options.will.pMessage = (pNewConnectParams->will).pMessage;
      (pClient->clientData).options.will.msgLen = (pNewConnectParams->will).msgLen;
      (pClient->clientData).options.will.qos = (pNewConnectParams->will).qos;
      (pClient->clientData).options.will.isRetained = (pNewConnectParams->will).isRetained;
      (pClient->clientData).options.keepAliveIntervalInSec =
           pNewConnectParams->keepAliveIntervalInSec;
      (pClient->clientData).options.isCleanSession = pNewConnectParams->isCleanSession;
    }
    return IVar1;
  }
  return NULL_VALUE_ERROR;
}



// WARNING: Variable defined which should be unmapped: default_options

IoT_Error_t aws_iot_mqtt_init(AWS_IoT_Client *pClient,IoT_Client_Init_Params *pInitParams)

{
  IoT_Error_t IVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  MessageHandlers_conflict40 *pMVar2;
  uint32_t uVar3;
  void *pvVar4;
  IoT_Mutex_t *pMutex;
  IoT_Mutex_t *pMutex_00;
  IoT_Mutex_t *pMutex_01;
  undefined auStack88 [4];
  IoT_Client_Connect_Params default_options;
  
  IVar1 = NULL_VALUE_ERROR;
  memcpy(auStack88,&DAT_23087bdc,0x38);
  if ((((pClient != (AWS_IoT_Client *)0x0) && (pInitParams != (IoT_Client_Init_Params *)0x0)) &&
      (pInitParams->pHostURL != (char *)0x0)) &&
     (((pInitParams->port != 0 && (pInitParams->pRootCALocation != (char *)0x0)) &&
      ((pInitParams->pDevicePrivateKeyLocation != (char *)0x0 &&
       (pInitParams->pDeviceCertLocation != (char *)0x0)))))) {
    pMVar2 = (pClient->clientData).messageHandlers;
    do {
      pMVar2->topicName = (char *)0x0;
      pMVar2->pApplicationHandler = (pApplicationHandler_t *)0x0;
      pMVar2->pApplicationHandlerData = (void *)0x0;
      pMVar2->qos = QOS0;
      pMVar2 = pMVar2 + 1;
    } while (pMVar2 != (MessageHandlers_conflict40 *)&(pClient->clientData).disconnectHandler);
    (pClient->clientData).packetTimeoutMs = pInitParams->mqttPacketTimeout_ms;
    uVar3 = pInitParams->mqttCommandTimeout_ms;
    (pClient->clientData).counterNetworkDisconnected = 0;
    (pClient->clientData).commandTimeoutMs = uVar3;
    (pClient->clientData).writeBufSize = 0x200;
    (pClient->clientData).readBufSize = 0x200;
    (pClient->clientData).disconnectHandler = pInitParams->disconnectHandler;
    pvVar4 = pInitParams->disconnectHandlerData;
    (pClient->clientData).nextPacketId = 1;
    (pClient->clientData).disconnectHandlerData = pvVar4;
    IVar1 = aws_iot_mqtt_set_connect_params(pClient,(IoT_Client_Connect_Params *)auStack88);
    if (CONCAT31(extraout_var,IVar1) == 0) {
      pMutex = &(pClient->clientData).state_change_mutex;
      (pClient->clientData).isBlockOnThreadLockEnabled = pInitParams->isBlockOnThreadLockEnabled;
      IVar1 = aws_iot_thread_mutex_init(pMutex);
      if (CONCAT31(extraout_var_00,IVar1) == 0) {
        pMutex_00 = &(pClient->clientData).tls_read_mutex;
        IVar1 = aws_iot_thread_mutex_init(pMutex_00);
        if (CONCAT31(extraout_var_01,IVar1) == 0) {
          pMutex_01 = &(pClient->clientData).tls_write_mutex;
          IVar1 = aws_iot_thread_mutex_init(pMutex_01);
          if (CONCAT31(extraout_var_02,IVar1) == 0) {
            (pClient->clientStatus).isPingOutstanding = false;
            (pClient->clientStatus).isAutoReconnectEnabled = pInitParams->enableAutoReconnect;
            IVar1 = iot_tls_init((Network *)&pClient->networkStack,pInitParams->pRootCALocation,
                                 pInitParams->pDeviceCertLocation,
                                 pInitParams->pDevicePrivateKeyLocation,pInitParams->pHostURL,
                                 pInitParams->port,pInitParams->tlsHandshakeTimeout_ms,
                                 pInitParams->isSSLHostnameVerify);
            if (CONCAT31(extraout_var_03,IVar1) != 0) {
              aws_iot_thread_mutex_destroy(pMutex_00);
              aws_iot_thread_mutex_destroy(pMutex);
              aws_iot_thread_mutex_destroy(pMutex_01);
              (pClient->clientStatus).clientState = CLIENT_STATE_INVALID;
              return IVar1;
            }
            init_timer((Timer *)pClient);
            init_timer(&pClient->reconnectDelayTimer);
            (pClient->clientStatus).clientState = CLIENT_STATE_INITIALIZED;
            return IVar1;
          }
          aws_iot_thread_mutex_destroy(pMutex_00);
        }
        aws_iot_thread_mutex_destroy(pMutex);
      }
    }
  }
  return IVar1;
}



uint16_t aws_iot_mqtt_get_next_packet_id(AWS_IoT_Client *pClient)

{
  uint16_t uVar1;
  
  uVar1 = (pClient->clientData).nextPacketId;
  if (uVar1 == 0xffff) {
    uVar1 = 1;
  }
  else {
    uVar1 = uVar1 + 1;
  }
  (pClient->clientData).nextPacketId = uVar1;
  return uVar1;
}



_Bool aws_iot_mqtt_is_client_connected(AWS_IoT_Client *pClient)

{
  if (pClient != (AWS_IoT_Client *)0x0) {
    return (_Bool)((uint)(pClient->clientStatus).clientState - 3 < 7);
  }
  return false;
}



IoT_Error_t aws_iot_mqtt_autoreconnect_set_status(AWS_IoT_Client *pClient,_Bool newStatus)

{
  if (pClient != (AWS_IoT_Client *)0x0) {
    (pClient->clientStatus).isAutoReconnectEnabled = newStatus;
    return SUCCESS;
  }
  return NULL_VALUE_ERROR;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Could not reconcile some variable overlaps

IoT_Error_t aws_iot_mqtt_connect(AWS_IoT_Client *pClient,IoT_Client_Connect_Params *pConnectParams)

{
  ushort uVar1;
  uint uVar2;
  ClientState CVar3;
  IoT_Error_t IVar4;
  IoT_Error_t IVar5;
  uchar uVar6;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  uint32_t uVar7;
  undefined3 extraout_var_02;
  size_t sVar8;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  undefined3 extraout_var_05;
  undefined3 extraout_var_06;
  undefined3 extraout_var_07;
  undefined3 extraout_var_08;
  byte c;
  char *string;
  undefined4 uVar9;
  uint32_t rem_len;
  Network *pNVar10;
  uchar *puVar11;
  uchar *puStack56;
  uchar *curdata;
  MQTTHeader header;
  uchar *ptr;
  Timer connect_timer;
  
  if (pClient == (AWS_IoT_Client *)0x0) {
    return NULL_VALUE_ERROR;
  }
  aws_iot_mqtt_internal_flushBuffers(pClient);
  CVar3 = aws_iot_mqtt_get_client_state(pClient);
  _CVar3 = CONCAT31(extraout_var,CVar3);
  if (_CVar3 != 1) {
    if (CVar3 == CLIENT_STATE_INVALID) {
      return NETWORK_ALREADY_CONNECTED_ERROR;
    }
    if (2 < (_CVar3 - 0xbU & 0xff)) {
      return NETWORK_ALREADY_CONNECTED_ERROR;
    }
  }
  aws_iot_mqtt_set_client_state(pClient,_CVar3,2);
  pNVar10 = (Network *)&pClient->networkStack;
  if ((pConnectParams == (IoT_Client_Connect_Params *)0x0) ||
     (IVar4 = aws_iot_mqtt_set_connect_params(pClient,pConnectParams),
     CONCAT31(extraout_var_01,IVar4) == 0)) {
    IVar4 = (*(pClient->networkStack).connect)(pNVar10,(TLSConnectParams *)0x0);
    if (CONCAT31(extraout_var_00,IVar4) == 0) {
      init_timer((Timer *)&ptr);
      puVar11 = (pClient->clientData).writeBuf;
      countdown_ms((Timer *)&ptr,(pClient->clientData).commandTimeoutMs);
      curdata = (uchar *)((uint)curdata & 0xffffff00);
      uVar2 = (pClient->clientData).writeBufSize;
      (pClient->clientData).keepAliveInterval = (pClient->clientData).options.keepAliveIntervalInSec
      ;
      uVar1 = (pClient->clientData).options.clientIDLen;
      if (uVar1 == 0) {
        IVar4 = NULL_VALUE_ERROR;
      }
      else {
        IVar4 = MQTT_CONNACK_UNACCEPTABLE_PROTOCOL_VERSION_ERROR;
        if ((pClient->clientData).options.MQTTVersion == MQTT_3_1_1) {
          rem_len = (uint)uVar1 + 0xc;
          if ((pClient->clientData).options.isWillMsgPresent != false) {
            rem_len = rem_len + (uint)(pClient->clientData).options.will.topicNameLen +
                                (uint)(pClient->clientData).options.will.msgLen + 4;
          }
          if ((pClient->clientData).options.pUsername != (char *)0x0) {
            rem_len = rem_len + (uint)(pClient->clientData).options.usernameLen + 2;
          }
          if ((pClient->clientData).options.pPassword != (char *)0x0) {
            rem_len = rem_len + (uint)(pClient->clientData).options.passwordLen + 2;
          }
          _header = puVar11;
          uVar7 = aws_iot_mqtt_internal_get_final_packet_length_from_remaining_length(rem_len);
          if (uVar2 < uVar7) {
            IVar4 = MQTT_TX_BUFFER_TOO_SHORT_ERROR;
          }
          else {
            IVar5 = aws_iot_mqtt_internal_init_header((MQTTHeader *)&curdata,CONNECT,QOS0,'\0','\0')
            ;
            IVar4 = IVar5;
            if (CONCAT31(extraout_var_02,IVar5) == 0) {
              aws_iot_mqtt_internal_write_char((uchar **)&header,(uchar)curdata);
              sVar8 = aws_iot_mqtt_internal_write_len_to_buffer(_header,rem_len);
              _header = _header + sVar8;
              aws_iot_mqtt_internal_write_utf8_string((uchar **)&header,"MQTT",4);
              aws_iot_mqtt_internal_write_char
                        ((uchar **)&header,(pClient->clientData).options.MQTTVersion);
              c = ((pClient->clientData).options.isCleanSession != false) << 1;
              if ((pClient->clientData).options.isWillMsgPresent != false) {
                c = c | 4 | (pClient->clientData).options.will.qos << 3 |
                            (pClient->clientData).options.will.isRetained << 5;
              }
              if ((pClient->clientData).options.pPassword != (char *)0x0) {
                c = c | 0x40;
              }
              if ((pClient->clientData).options.pUsername != (char *)0x0) {
                c = c | 0x80;
              }
              aws_iot_mqtt_internal_write_char((uchar **)&header,c);
              aws_iot_mqtt_internal_write_uint_16
                        ((uchar **)&header,(pClient->clientData).options.keepAliveIntervalInSec);
              string = (pClient->clientData).options.pClientID;
              if (string == (char *)0x0) {
                aws_iot_mqtt_internal_write_uint_16((uchar **)&header,0);
              }
              else {
                aws_iot_mqtt_internal_write_utf8_string
                          ((uchar **)&header,string,(pClient->clientData).options.clientIDLen);
              }
              if ((pClient->clientData).options.isWillMsgPresent != false) {
                aws_iot_mqtt_internal_write_utf8_string
                          ((uchar **)&header,(pClient->clientData).options.will.pTopicName,
                           (pClient->clientData).options.will.topicNameLen);
                aws_iot_mqtt_internal_write_utf8_string
                          ((uchar **)&header,(pClient->clientData).options.will.pMessage,
                           (pClient->clientData).options.will.msgLen);
              }
              string = (pClient->clientData).options.pUsername;
              if (string != (char *)0x0) {
                aws_iot_mqtt_internal_write_utf8_string
                          ((uchar **)&header,string,(pClient->clientData).options.usernameLen);
              }
              string = (pClient->clientData).options.pPassword;
              if (string != (char *)0x0) {
                aws_iot_mqtt_internal_write_utf8_string
                          ((uchar **)&header,string,(pClient->clientData).options.passwordLen);
              }
              if (_header + -(int)puVar11 == (uchar *)0x0) {
LAB_2304f84e:
                uVar9 = 3;
                goto LAB_2304f850;
              }
              IVar4 = aws_iot_mqtt_internal_send_packet
                                (pClient,(size_t)(_header + -(int)puVar11),(Timer *)&ptr);
              if ((CONCAT31(extraout_var_03,IVar4) == 0) &&
                 (IVar4 = aws_iot_mqtt_internal_wait_for_read(pClient,'\x02',(Timer *)&ptr),
                 CONCAT31(extraout_var_04,IVar4) == 0)) {
                IVar4 = MQTT_RX_BUFFER_TOO_SHORT_ERROR;
                if (3 < (pClient->clientData).readBufSize) {
                  curdata = (uchar *)0x0;
                  _header = (uchar *)0x0;
                  puStack56 = (pClient->clientData).readBuf;
                  uVar6 = aws_iot_mqtt_internal_read_char(&puStack56);
                  IVar4 = FAILURE;
                  if (((CONCAT31(extraout_var_05,uVar6) >> 4 & 0xff) == 2) &&
                     (IVar4 = aws_iot_mqtt_internal_decode_remaining_length_from_buffer
                                        (puStack56,(uint32_t *)&curdata,(uint32_t *)&header),
                     CONCAT31(extraout_var_06,IVar4) == 0)) {
                    puStack56 = puStack56 + (int)_header;
                    IVar4 = MQTT_DECODE_REMAINING_LENGTH_ERROR;
                    if (curdata == (uchar *)0x2) {
                      aws_iot_mqtt_internal_read_char(&puStack56);
                      uVar6 = aws_iot_mqtt_internal_read_char(&puStack56);
                      switch(CONCAT31(extraout_var_07,uVar6)) {
                      case 0:
                        uVar1 = (pClient->clientData).keepAliveInterval;
                        (pClient->clientStatus).isPingOutstanding = false;
                        countdown_sec((Timer *)pClient,(uint)uVar1);
                        goto LAB_2304f84e;
                      case 1:
                        IVar4 = MQTT_CONNACK_UNACCEPTABLE_PROTOCOL_VERSION_ERROR;
                        break;
                      case 2:
                        IVar4 = MQTT_CONNACK_IDENTIFIER_REJECTED_ERROR;
                        break;
                      case 3:
                        IVar4 = MQTT_CONNACK_SERVER_UNAVAILABLE_ERROR;
                        break;
                      case 4:
                        IVar4 = MQTT_CONNACK_BAD_USERDATA_ERROR;
                        break;
                      case 5:
                        IVar4 = MQTT_CONNACK_NOT_AUTHORIZED_ERROR;
                        break;
                      default:
                        IVar4 = MQTT_CONNACK_UNKNOWN_ERROR;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  else {
    IVar4 = MQTT_CONNECTION_ERROR;
  }
  IVar5 = IVar4;
  (*(pClient->networkStack).disconnect)(pNVar10);
  IVar4 = (*(pClient->networkStack).destroy)(pNVar10);
  uVar9 = 0xb;
  if (CONCAT31(extraout_var_08,IVar4) != 0) {
    return NETWORK_DISCONNECTED_ERROR;
  }
LAB_2304f850:
  aws_iot_mqtt_set_client_state(pClient,2,uVar9);
  return IVar5;
}



IoT_Error_t _aws_iot_mqtt_internal_disconnect(AWS_IoT_Client *pClient)

{
  IoT_Error_t IVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  size_t local_20;
  size_t serialized_len;
  Timer timer;
  
  local_20 = 0;
  IVar1 = aws_iot_mqtt_internal_serialize_zero
                    ((pClient->clientData).writeBuf,(pClient->clientData).writeBufSize,DISCONNECT,
                     &local_20);
  if (CONCAT31(extraout_var,IVar1) == 0) {
    init_timer((Timer *)&serialized_len);
    countdown_ms((Timer *)&serialized_len,(pClient->clientData).commandTimeoutMs);
    if (local_20 != 0) {
      aws_iot_mqtt_internal_send_packet(pClient,local_20,(Timer *)&serialized_len);
    }
    (*(pClient->networkStack).disconnect)((Network *)&pClient->networkStack);
    IVar1 = (*(pClient->networkStack).destroy)((Network *)&pClient->networkStack);
    IVar1 = -(CONCAT31(extraout_var_00,IVar1) != 0);
  }
  return IVar1;
}



IoT_Error_t aws_iot_mqtt_disconnect(AWS_IoT_Client *pClient)

{
  ClientState CVar1;
  _Bool _Var2;
  IoT_Error_t IVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  int iVar4;
  undefined3 extraout_var_01;
  
  if (pClient != (AWS_IoT_Client *)0x0) {
    CVar1 = aws_iot_mqtt_get_client_state(pClient);
    _Var2 = aws_iot_mqtt_is_client_connected(pClient);
    IVar3 = NETWORK_DISCONNECTED_ERROR;
    if (CONCAT31(extraout_var_00,_Var2) != 0) {
      iVar4 = aws_iot_mqtt_set_client_state(pClient,CONCAT31(extraout_var,CVar1),10);
      IVar3 = (IoT_Error_t)iVar4;
      if (iVar4 == 0) {
        IVar3 = _aws_iot_mqtt_internal_disconnect(pClient);
        if (CONCAT31(extraout_var_01,IVar3) == 0) {
          (pClient->clientStatus).clientState = CLIENT_STATE_DISCONNECTED_MANUALLY;
        }
        else {
          (pClient->clientStatus).clientState = CVar1;
        }
      }
    }
    return IVar3;
  }
  return NULL_VALUE_ERROR;
}



IoT_Error_t aws_iot_mqtt_attempt_reconnect(AWS_IoT_Client *pClient)

{
  _Bool _Var1;
  ClientState CVar2;
  IoT_Error_t IVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  
  if (pClient != (AWS_IoT_Client *)0x0) {
    _Var1 = aws_iot_mqtt_is_client_connected(pClient);
    IVar3 = NETWORK_ALREADY_CONNECTED_ERROR;
    if (CONCAT31(extraout_var,_Var1) == 0) {
      aws_iot_mqtt_connect(pClient,(IoT_Client_Connect_Params *)0x0);
      CVar2 = aws_iot_mqtt_get_client_state(pClient);
      if (CONCAT31(extraout_var_00,CVar2) == 3) {
        IVar3 = aws_iot_mqtt_resubscribe(pClient);
        if (CONCAT31(extraout_var_01,IVar3) == 0) {
          IVar3 = NETWORK_RECONNECTED;
        }
      }
      else {
        aws_iot_mqtt_set_client_state(pClient,0xb,0xd);
        IVar3 = NETWORK_ATTEMPTING_RECONNECT;
      }
    }
    return IVar3;
  }
  return NULL_VALUE_ERROR;
}



IoT_Error_t
aws_iot_mqtt_internal_serialize_ack
          (uchar *pTxBuf,size_t txBufLen,MessageTypes msgType,uint8_t dup,uint16_t packetId,
          uint32_t *pSerializedLen)

{
  IoT_Error_t IVar1;
  undefined3 extraout_var;
  size_t sVar2;
  undefined3 in_register_00002031;
  uchar auStack40 [4];
  MQTTHeader header;
  uchar *ptr;
  
  auStack40[0] = '\0';
  IVar1 = NULL_VALUE_ERROR;
  if ((pTxBuf != (uchar *)0x0) && (pSerializedLen != (uint32_t *)0x0)) {
    IVar1 = MQTT_TX_BUFFER_TOO_SHORT_ERROR;
    if ((3 < txBufLen) &&
       (_header = pTxBuf,
       IVar1 = aws_iot_mqtt_internal_init_header
                         (auStack40,msgType,CONCAT31(in_register_00002031,msgType) == 6,dup,'\0'),
       CONCAT31(extraout_var,IVar1) == 0)) {
      aws_iot_mqtt_internal_write_char((uchar **)&header,auStack40[0]);
      sVar2 = aws_iot_mqtt_internal_write_len_to_buffer(_header,2);
      _header = _header + sVar2;
      aws_iot_mqtt_internal_write_uint_16((uchar **)&header,packetId);
      *(uchar **)pSerializedLen = _header + -(int)pTxBuf;
    }
  }
  return IVar1;
}



IoT_Error_t
aws_iot_mqtt_internal_deserialize_publish
          (uint8_t *dup,QoS *qos,uint8_t *retained,uint16_t *pPacketId,char **pTopicName,
          uint16_t *topicNameLen,uchar **payload,size_t *payloadLen,uchar *pRxBuf,size_t rxBufLen)

{
  uchar *puVar1;
  byte bVar2;
  IoT_Error_t IVar3;
  uint16_t uVar4;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined2 extraout_var_01;
  uchar *in_stack_00000000;
  uint in_stack_00000004;
  uchar *puStack60;
  uchar *curData;
  uint32_t decodedLen;
  uint32_t readBytesLen;
  
  puStack60 = in_stack_00000000;
  curData = (uchar *)0x0;
  decodedLen = 0;
  if ((((dup != (uint8_t *)0x0) && (qos != (QoS *)0x0)) && (retained != (uint8_t *)0x0)) &&
     (pPacketId != (uint16_t *)0x0)) {
    if (in_stack_00000004 < 4) {
      return MQTT_RX_BUFFER_TOO_SHORT_ERROR;
    }
    bVar2 = aws_iot_mqtt_internal_read_char(&puStack60);
    _bVar2 = CONCAT31(extraout_var,bVar2);
    if ((_bVar2 >> 4 & 0xff) == 3) {
      *dup = (byte)((int)_bVar2 >> 3) & 1;
      *qos = (byte)((int)_bVar2 >> 1) & 3;
      *retained = bVar2 & 1;
      IVar3 = aws_iot_mqtt_internal_decode_remaining_length_from_buffer
                        (puStack60,(uint32_t *)&curData,&decodedLen);
      if (CONCAT31(extraout_var_00,IVar3) != 0) {
        return IVar3;
      }
      puStack60 = puStack60 + decodedLen;
      puVar1 = puStack60 + (int)curData;
      if (1 < (int)curData) {
        uVar4 = aws_iot_mqtt_internal_read_uint16_t(&puStack60);
        *topicNameLen = uVar4;
        if (puStack60 + CONCAT22(extraout_var_01,uVar4) <= puVar1) {
          *(uchar **)pTopicName = puStack60;
          puStack60 = puStack60 + *topicNameLen;
          if (-1 < (int)(puVar1 + -(int)puStack60)) {
            if (*qos != QOS0) {
              uVar4 = aws_iot_mqtt_internal_read_uint16_t(&puStack60);
              *pPacketId = uVar4;
            }
            *(uchar **)payloadLen = puVar1 + -(int)puStack60;
            *payload = puStack60;
            return IVar3;
          }
        }
      }
    }
  }
  return FAILURE;
}



// WARNING: Variable defined which should be unmapped: readBytesLen

IoT_Error_t
aws_iot_mqtt_internal_deserialize_ack
          (uchar *pPacketType,uchar *dup,uint16_t *pPacketId,uchar *pRxBuf,size_t rxBuflen)

{
  uchar uVar1;
  IoT_Error_t IVar2;
  uint16_t uVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  uchar *puStack28;
  uchar *curdata;
  uint32_t decodedLen;
  uint32_t readBytesLen;
  
  curdata = (uchar *)0x0;
  decodedLen = 0;
  IVar2 = NULL_VALUE_ERROR;
  if ((((pPacketType != (uchar *)0x0) && (dup != (uchar *)0x0)) && (pPacketId != (uint16_t *)0x0))
     && ((pRxBuf != (uchar *)0x0 && (IVar2 = MQTT_RX_BUFFER_TOO_SHORT_ERROR, 3 < rxBuflen)))) {
    puStack28 = pRxBuf;
    uVar1 = aws_iot_mqtt_internal_read_char(&puStack28);
    *dup = (byte)((int)CONCAT31(extraout_var,uVar1) >> 3) & 1;
    *pPacketType = (uchar)(CONCAT31(extraout_var,uVar1) >> 4);
    IVar2 = aws_iot_mqtt_internal_decode_remaining_length_from_buffer
                      (puStack28,(uint32_t *)&curdata,&decodedLen);
    if (CONCAT31(extraout_var_00,IVar2) == 0) {
      puStack28 = puStack28 + decodedLen;
      if ((int)curdata < 2) {
        IVar2 = FAILURE;
      }
      else {
        uVar3 = aws_iot_mqtt_internal_read_uint16_t(&puStack28);
        *pPacketId = uVar3;
      }
    }
  }
  return IVar2;
}



IoT_Error_t
aws_iot_mqtt_publish
          (AWS_IoT_Client *pClient,char *pTopicName,uint16_t topicNameLen,
          IoT_Publish_Message_Params *pParams)

{
  QoS qos;
  uint8_t retained;
  _Bool _Var1;
  ClientState CVar2;
  IoT_Error_t IVar3;
  uint16_t anInt;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  int iVar4;
  uint32_t uVar5;
  undefined3 extraout_var_01;
  size_t sVar6;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  undefined2 in_register_00002032;
  uint uVar7;
  size_t __n;
  uchar *puVar8;
  void *__src;
  uint32_t rem_len;
  uchar uStack85;
  uchar auStack84 [3];
  uchar dup;
  uchar type;
  uint16_t packet_id;
  Timer timer;
  
  if ((((pClient != (AWS_IoT_Client *)0x0) && (pTopicName != (char *)0x0)) &&
      (CONCAT22(in_register_00002032,topicNameLen) != 0)) &&
     (pParams != (IoT_Publish_Message_Params *)0x0)) {
    _Var1 = aws_iot_mqtt_is_client_connected(pClient);
    IVar3 = NETWORK_DISCONNECTED_ERROR;
    if (CONCAT31(extraout_var,_Var1) != 0) {
      CVar2 = aws_iot_mqtt_get_client_state(pClient);
      _CVar2 = CONCAT31(extraout_var_00,CVar2);
      if ((_CVar2 != 3) && (_CVar2 != 9)) {
        return MQTT_CLIENT_NOT_IDLE_ERROR;
      }
      iVar4 = aws_iot_mqtt_set_client_state(pClient,_CVar2,5);
      IVar3 = (IoT_Error_t)iVar4;
      if (iVar4 == 0) {
        init_timer((Timer *)&packet_id);
        countdown_ms((Timer *)&packet_id,(pClient->clientData).commandTimeoutMs);
        if (pParams->qos == QOS1) {
          anInt = aws_iot_mqtt_get_next_packet_id(pClient);
          pParams->id = anInt;
        }
        __src = pParams->payload;
        auStack84[0] = '\0';
        puVar8 = (pClient->clientData).writeBuf;
        uVar7 = (pClient->clientData).writeBufSize;
        qos = pParams->qos;
        retained = pParams->isRetained;
        anInt = pParams->id;
        __n = pParams->payloadLen;
        iVar4 = -2;
        if (__src != (void *)0x0) {
          iVar4 = CONCAT22(in_register_00002032,topicNameLen) + __n;
          rem_len = iVar4 + 4;
          if (qos == QOS0) {
            rem_len = iVar4 + 2;
          }
          _type = puVar8;
          uVar5 = aws_iot_mqtt_internal_get_final_packet_length_from_remaining_length(rem_len);
          iVar4 = -0x21;
          if (uVar5 <= uVar7) {
            IVar3 = aws_iot_mqtt_internal_init_header(auStack84,PUBLISH,qos,'\0',retained);
            iVar4 = CONCAT31(extraout_var_01,IVar3);
            if (iVar4 == 0) {
              aws_iot_mqtt_internal_write_char((uchar **)&type,auStack84[0]);
              sVar6 = aws_iot_mqtt_internal_write_len_to_buffer(_type,rem_len);
              _type = _type + sVar6;
              aws_iot_mqtt_internal_write_utf8_string((uchar **)&type,pTopicName,topicNameLen);
              if (qos != QOS0) {
                aws_iot_mqtt_internal_write_uint_16((uchar **)&type,anInt);
              }
              memcpy(_type,__src,__n);
              IVar3 = aws_iot_mqtt_internal_send_packet
                                (pClient,(size_t)(_type + (__n - (int)puVar8)),(Timer *)&packet_id);
              iVar4 = CONCAT31(extraout_var_02,IVar3);
              if ((iVar4 == 0) && (pParams->qos == QOS1)) {
                IVar3 = aws_iot_mqtt_internal_wait_for_read(pClient,'\x04',(Timer *)&packet_id);
                iVar4 = CONCAT31(extraout_var_03,IVar3);
                if (iVar4 == 0) {
                  IVar3 = aws_iot_mqtt_internal_deserialize_ack
                                    (auStack84,&uStack85,(uint16_t *)&type,
                                     (pClient->clientData).readBuf,(pClient->clientData).readBufSize
                                    );
                  iVar4 = CONCAT31(extraout_var_04,IVar3);
                }
              }
            }
          }
        }
        IVar3 = aws_iot_mqtt_set_client_state(pClient,5,_CVar2);
        if (iVar4 != 0) {
          IVar3 = (IoT_Error_t)iVar4;
        }
      }
    }
    return IVar3;
  }
  return NULL_VALUE_ERROR;
}



IoT_Error_t
_aws_iot_mqtt_deserialize_suback
          (uint16_t *pPacketId,uint32_t *pGrantedQoSCount,QoS *pGrantedQoSs,uchar *pRxBuf,
          size_t rxBufLen)

{
  uchar *puVar1;
  uchar uVar2;
  IoT_Error_t IVar3;
  QoS QVar4;
  uint16_t uVar5;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  uint uVar6;
  uchar *puStack44;
  uchar *curData;
  uint32_t decodedLen;
  uint32_t readBytesLen;
  
  curData = (uchar *)0x0;
  decodedLen = 0;
  if (rxBufLen < 5) {
    return MQTT_RX_BUFFER_TOO_SHORT_ERROR;
  }
  puStack44 = pRxBuf;
  uVar2 = aws_iot_mqtt_internal_read_char(&puStack44);
  if ((CONCAT31(extraout_var,uVar2) >> 4 & 0xff) == 9) {
    IVar3 = aws_iot_mqtt_internal_decode_remaining_length_from_buffer
                      (puStack44,(uint32_t *)&curData,&decodedLen);
    if (CONCAT31(extraout_var_00,IVar3) != 0) {
      return IVar3;
    }
    puStack44 = puStack44 + decodedLen;
    puVar1 = puStack44 + (int)curData;
    if (1 < (int)curData) {
      uVar5 = aws_iot_mqtt_internal_read_uint16_t(&puStack44);
      *pPacketId = uVar5;
      *pGrantedQoSCount = 0;
      while( true ) {
        if (puVar1 <= puStack44) {
          return IVar3;
        }
        uVar6 = *pGrantedQoSCount;
        if (1 < uVar6) break;
        *pGrantedQoSCount = uVar6 + 1;
        QVar4 = aws_iot_mqtt_internal_read_char(&puStack44);
        pGrantedQoSs[uVar6] = QVar4;
      }
    }
  }
  return FAILURE;
}



IoT_Error_t
_aws_iot_mqtt_serialize_subscribe
          (uchar *pTxBuf,size_t txBufLen,uint16_t packetId,char **pTopicNameList,
          uint16_t *pTopicNameLenList,QoS *pRequestedQoSs,uint32_t *pSerializedLen)

{
  ushort uVar1;
  IoT_Error_t IVar2;
  uint32_t uVar3;
  undefined3 extraout_var;
  size_t sVar4;
  uchar auStack56 [4];
  MQTTHeader header;
  uchar *ptr;
  
  uVar1 = *pTopicNameLenList;
  auStack56[0] = '\0';
  _header = pTxBuf;
  uVar3 = aws_iot_mqtt_internal_get_final_packet_length_from_remaining_length((uint)uVar1 + 5);
  IVar2 = MQTT_TX_BUFFER_TOO_SHORT_ERROR;
  if ((uVar3 <= txBufLen) &&
     (IVar2 = aws_iot_mqtt_internal_init_header(auStack56,SUBSCRIBE,QOS1,'\0','\0'),
     CONCAT31(extraout_var,IVar2) == 0)) {
    aws_iot_mqtt_internal_write_char((uchar **)&header,auStack56[0]);
    sVar4 = aws_iot_mqtt_internal_write_len_to_buffer(_header,(uint)uVar1 + 5);
    _header = _header + sVar4;
    aws_iot_mqtt_internal_write_uint_16((uchar **)&header,packetId);
    aws_iot_mqtt_internal_write_utf8_string((uchar **)&header,*pTopicNameList,*pTopicNameLenList);
    aws_iot_mqtt_internal_write_char((uchar **)&header,*pRequestedQoSs);
    *(uchar **)pSerializedLen = _header + -(int)pTxBuf;
  }
  return IVar2;
}



// WARNING: Variable defined which should be unmapped: timer
// WARNING: Could not reconcile some variable overlaps

IoT_Error_t
aws_iot_mqtt_subscribe
          (AWS_IoT_Client *pClient,char *pTopicName,uint16_t topicNameLen,QoS qos,
          pApplicationHandler_t *pApplicationHandler,void *pApplicationHandlerData)

{
  int iVar1;
  _Bool _Var2;
  ClientState CVar3;
  IoT_Error_t IVar4;
  uint16_t packetId;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  int iVar5;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  Timer *pTVar6;
  MessageHandlers_conflict40 *pMVar7;
  QoS QStack65;
  uint16_t uStack64;
  uint16_t uStack62;
  undefined2 uStack60;
  uint16_t rxPacketId;
  QoS grantedQoS [3];
  uint32_t uStack52;
  uint32_t serializedLen;
  uint32_t count;
  Timer timer;
  
  if (((pClient == (AWS_IoT_Client *)0x0) || (pTopicName == (char *)0x0)) ||
     (pApplicationHandler == (pApplicationHandler_t *)0x0)) {
    return NULL_VALUE_ERROR;
  }
  _Var2 = aws_iot_mqtt_is_client_connected(pClient);
  IVar4 = NETWORK_DISCONNECTED_ERROR;
  if (CONCAT31(extraout_var,_Var2) != 0) {
    CVar3 = aws_iot_mqtt_get_client_state(pClient);
    _CVar3 = CONCAT31(extraout_var_00,CVar3);
    if ((_CVar3 != 3) && (_CVar3 != 9)) {
      return MQTT_CLIENT_NOT_IDLE_ERROR;
    }
    iVar5 = aws_iot_mqtt_set_client_state(pClient,_CVar3,6);
    IVar4 = (IoT_Error_t)iVar5;
    if (iVar5 == 0) {
      uStack60 = 0;
      rxPacketId._0_1_ = 0;
      QStack65 = qos;
      uStack64 = topicNameLen;
      _grantedQoS = pTopicName;
      init_timer((Timer *)&count);
      countdown_ms((Timer *)&count,(pClient->clientData).commandTimeoutMs);
      uStack52 = 0;
      serializedLen = 0;
      packetId = aws_iot_mqtt_get_next_packet_id(pClient);
      uStack62 = 0;
      IVar4 = _aws_iot_mqtt_serialize_subscribe
                        ((pClient->clientData).writeBuf,(pClient->clientData).writeBufSize,packetId,
                         (char **)grantedQoS,&uStack64,&QStack65,&uStack52);
      iVar5 = CONCAT31(extraout_var_01,IVar4);
      if (iVar5 == 0) {
        pMVar7 = (pClient->clientData).messageHandlers;
        iVar1 = 0;
        do {
          if (pMVar7->topicName == (char *)0x0) {
            IVar4 = aws_iot_mqtt_internal_send_packet(pClient,uStack52,(Timer *)&count);
            iVar5 = CONCAT31(extraout_var_02,IVar4);
            if (iVar5 == 0) {
              IVar4 = aws_iot_mqtt_internal_wait_for_read(pClient,'\t',(Timer *)&count);
              iVar5 = CONCAT31(extraout_var_03,IVar4);
              if (iVar5 == 0) {
                IVar4 = _aws_iot_mqtt_deserialize_suback
                                  (&uStack62,&serializedLen,(QoS *)&uStack60,
                                   (pClient->clientData).readBuf,(pClient->clientData).readBufSize);
                iVar5 = CONCAT31(extraout_var_04,IVar4);
                if (iVar5 == 0) {
                  pTVar6 = (Timer *)((int)&pClient->pingTimer + iVar1 * 0x10);
                  *(char **)&pTVar6[0x60].last_polled_ticks = _grantedQoS;
                  *(pApplicationHandler_t **)&pTVar6[0x61].timeout_ticks = pApplicationHandler;
                  *(void **)&pTVar6[0x61].last_polled_ticks = pApplicationHandlerData;
                  *(uint16_t *)&pTVar6[0x61].start_ticks = uStack64;
                  *(QoS *)((int)&pTVar6[0x61].start_ticks + 2) = QStack65;
                }
              }
            }
            goto LAB_2304ff0e;
          }
          iVar1 = iVar1 + 1;
          pMVar7 = pMVar7 + 1;
        } while (iVar1 != 5);
        iVar5 = -0x22;
      }
LAB_2304ff0e:
      IVar4 = aws_iot_mqtt_set_client_state(pClient,6,_CVar3);
      if (iVar5 != 0) {
        IVar4 = (IoT_Error_t)iVar5;
      }
    }
  }
  return IVar4;
}



// WARNING: Variable defined which should be unmapped: timer
// WARNING: Could not reconcile some variable overlaps

IoT_Error_t aws_iot_mqtt_resubscribe(AWS_IoT_Client *pClient)

{
  int iVar1;
  _Bool _Var2;
  ClientState CVar3;
  IoT_Error_t IVar4;
  uint16_t packetId_00;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  int iVar5;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  size_t txBufLen;
  MessageHandlers_conflict40 *pMVar6;
  MessageHandlers_conflict40 *pTopicNameList;
  int iVar7;
  uint16_t uStack58;
  undefined2 uStack56;
  uint16_t packetId;
  QoS grantedQoS [3];
  uint32_t len;
  uint32_t count;
  Timer timer;
  
  if (pClient == (AWS_IoT_Client *)0x0) {
    return NULL_VALUE_ERROR;
  }
  _Var2 = aws_iot_mqtt_is_client_connected(pClient);
  IVar4 = NETWORK_DISCONNECTED_ERROR;
  if (CONCAT31(extraout_var,_Var2) != 0) {
    CVar3 = aws_iot_mqtt_get_client_state(pClient);
    IVar4 = MQTT_CLIENT_NOT_IDLE_ERROR;
    if (CONCAT31(extraout_var_00,CVar3) == 3) {
      iVar5 = aws_iot_mqtt_set_client_state(pClient,3,8);
      IVar4 = (IoT_Error_t)iVar5;
      if (iVar5 == 0) {
        pTopicNameList = (pClient->clientData).messageHandlers;
        uStack56 = 0;
        packetId._0_1_ = 0;
        uStack58 = 0;
        _grantedQoS = 0;
        len = 0;
        iVar5 = 0;
        pMVar6 = pTopicNameList;
        do {
          if (pMVar6->topicName == (char *)0x0) break;
          iVar5 = iVar5 + 1;
          pMVar6 = pMVar6 + 1;
        } while (iVar5 != 5);
        iVar7 = 0;
        while (iVar5 != iVar7) {
          if (pTopicNameList->topicName != (char *)0x0) {
            init_timer((Timer *)&count);
            countdown_ms((Timer *)&count,(pClient->clientData).commandTimeoutMs);
            txBufLen = (pClient->clientData).writeBufSize;
            packetId_00 = aws_iot_mqtt_get_next_packet_id(pClient);
            IVar4 = _aws_iot_mqtt_serialize_subscribe
                              ((pClient->clientData).writeBuf,txBufLen,packetId_00,
                               (char **)pTopicNameList,&pTopicNameList->topicNameLen,
                               &pTopicNameList->qos,(uint32_t *)grantedQoS);
            iVar1 = CONCAT31(extraout_var_01,IVar4);
            if (iVar1 != 0) goto LAB_23050076;
            IVar4 = aws_iot_mqtt_internal_send_packet(pClient,_grantedQoS,(Timer *)&count);
            iVar1 = CONCAT31(extraout_var_02,IVar4);
            if (iVar1 != 0) goto LAB_23050076;
            IVar4 = aws_iot_mqtt_internal_wait_for_read(pClient,'\t',(Timer *)&count);
            iVar1 = CONCAT31(extraout_var_03,IVar4);
            if (iVar1 != 0) goto LAB_23050076;
            IVar4 = _aws_iot_mqtt_deserialize_suback
                              (&uStack58,&len,(QoS *)&uStack56,(pClient->clientData).readBuf,
                               (pClient->clientData).readBufSize);
            iVar1 = CONCAT31(extraout_var_04,IVar4);
            if (iVar1 != 0) goto LAB_23050076;
          }
          iVar7 = iVar7 + 1;
          pTopicNameList = pTopicNameList + 1;
        }
        iVar1 = 0;
LAB_23050076:
        IVar4 = aws_iot_mqtt_set_client_state(pClient,8,3);
        if (iVar1 != 0) {
          IVar4 = (IoT_Error_t)iVar1;
        }
      }
    }
  }
  return IVar4;
}



// WARNING: Variable defined which should be unmapped: timer

IoT_Error_t
aws_iot_mqtt_unsubscribe(AWS_IoT_Client *pClient,char *pTopicFilter,uint16_t topicFilterLen)

{
  MessageHandlers_conflict40 *pMVar1;
  _Bool _Var2;
  ClientState CVar3;
  IoT_Error_t IVar4;
  uint16_t anInt;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  int iVar5;
  uint32_t uVar6;
  undefined3 extraout_var_01;
  size_t sVar7;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  int iVar8;
  undefined2 in_register_00002032;
  MessageHandlers_conflict40 *pMVar9;
  uint32_t rem_len;
  uchar *puVar10;
  MessageHandlers_conflict40 *pMVar11;
  uint uVar12;
  uchar uStack69;
  uchar auStack68 [3];
  uchar type;
  uchar dup;
  uint16_t packet_id;
  Timer timer;
  
  if ((pClient == (AWS_IoT_Client *)0x0) || (pTopicFilter == (char *)0x0)) {
    return NULL_VALUE_ERROR;
  }
  _Var2 = aws_iot_mqtt_is_client_connected(pClient);
  if (CONCAT31(extraout_var,_Var2) == 0) {
    return NETWORK_DISCONNECTED_ERROR;
  }
  CVar3 = aws_iot_mqtt_get_client_state(pClient);
  _CVar3 = CONCAT31(extraout_var_00,CVar3);
  if ((_CVar3 != 3) && (_CVar3 != 9)) {
    return MQTT_CLIENT_NOT_IDLE_ERROR;
  }
  iVar5 = aws_iot_mqtt_set_client_state(pClient,_CVar3,7);
  if (iVar5 != 0) {
    IVar4 = aws_iot_mqtt_set_client_state(pClient,7,_CVar3);
    return IVar4;
  }
  pMVar9 = (pClient->clientData).messageHandlers;
  pMVar11 = (MessageHandlers_conflict40 *)&(pClient->clientData).disconnectHandler;
  pMVar1 = pMVar9;
  do {
    if ((pMVar1->topicName != (char *)0x0) &&
       (iVar5 = strcmp(pMVar1->topicName,pTopicFilter), iVar5 == 0)) {
      init_timer((Timer *)&packet_id);
      rem_len = CONCAT22(in_register_00002032,topicFilterLen) + 4;
      countdown_ms((Timer *)&packet_id,(pClient->clientData).commandTimeoutMs);
      uVar12 = (pClient->clientData).writeBufSize;
      anInt = aws_iot_mqtt_get_next_packet_id(pClient);
      puVar10 = (pClient->clientData).writeBuf;
      auStack68[0] = '\0';
      _dup = puVar10;
      uVar6 = aws_iot_mqtt_internal_get_final_packet_length_from_remaining_length(rem_len);
      iVar5 = -0x21;
      if (uVar12 < uVar6) goto LAB_23050136;
      IVar4 = aws_iot_mqtt_internal_init_header(auStack68,UNSUBSCRIBE,QOS1,'\0','\0');
      iVar5 = CONCAT31(extraout_var_01,IVar4);
      if (iVar5 != 0) goto LAB_23050136;
      aws_iot_mqtt_internal_write_char((uchar **)&dup,auStack68[0]);
      sVar7 = aws_iot_mqtt_internal_write_len_to_buffer(_dup,rem_len);
      _dup = _dup + sVar7;
      aws_iot_mqtt_internal_write_uint_16((uchar **)&dup,anInt);
      aws_iot_mqtt_internal_write_utf8_string((uchar **)&dup,pTopicFilter,topicFilterLen);
      IVar4 = aws_iot_mqtt_internal_send_packet
                        (pClient,(size_t)(_dup + -(int)puVar10),(Timer *)&packet_id);
      iVar5 = CONCAT31(extraout_var_02,IVar4);
      if (iVar5 != 0) goto LAB_23050136;
      IVar4 = aws_iot_mqtt_internal_wait_for_read(pClient,'\v',(Timer *)&packet_id);
      iVar5 = CONCAT31(extraout_var_03,IVar4);
      if (iVar5 != 0) goto LAB_23050136;
      uStack69 = '\0';
      auStack68[0] = '\0';
      IVar4 = aws_iot_mqtt_internal_deserialize_ack
                        (&uStack69,auStack68,(uint16_t *)&dup,(pClient->clientData).readBuf,
                         (pClient->clientData).readBufSize);
      iVar5 = CONCAT31(extraout_var_04,IVar4);
      if (iVar5 != 0) goto LAB_23050136;
      if (uStack69 == '\v') goto LAB_2305020a;
      break;
    }
    pMVar1 = pMVar1 + 1;
  } while (pMVar1 != pMVar11);
  iVar5 = -1;
LAB_23050136:
  IVar4 = aws_iot_mqtt_set_client_state(pClient,7,_CVar3);
  if (iVar5 != 0) {
    IVar4 = (IoT_Error_t)iVar5;
  }
  return IVar4;
LAB_2305020a:
  do {
    if ((pMVar9->topicName != (char *)0x0) &&
       (iVar8 = strcmp(pMVar9->topicName,pTopicFilter), iVar8 == 0)) {
      pMVar9->topicName = (char *)0x0;
    }
    pMVar9 = pMVar9 + 1;
  } while (pMVar9 != pMVar11);
  goto LAB_23050136;
}



IoT_Error_t _aws_iot_mqtt_handle_disconnect(AWS_IoT_Client *pClient)

{
  IoT_Error_t IVar1;
  undefined3 extraout_var;
  iot_disconnect_handler *piVar2;
  
  IVar1 = aws_iot_mqtt_disconnect(pClient);
  if (CONCAT31(extraout_var,IVar1) != 0) {
    (pClient->clientStatus).clientState = CLIENT_STATE_DISCONNECTED_ERROR;
    (*(pClient->networkStack).disconnect)((Network *)&pClient->networkStack);
    (*(pClient->networkStack).destroy)((Network *)&pClient->networkStack);
  }
  piVar2 = (pClient->clientData).disconnectHandler;
  if (piVar2 != (iot_disconnect_handler *)0x0) {
    (*piVar2)(pClient,(pClient->clientData).disconnectHandlerData);
  }
  (pClient->clientStatus).clientState = CLIENT_STATE_DISCONNECTED_ERROR;
  return NETWORK_DISCONNECTED_ERROR;
}



// WARNING: Variable defined which should be unmapped: timer_1
// WARNING: Could not reconcile some variable overlaps

IoT_Error_t aws_iot_mqtt_yield(AWS_IoT_Client *pClient,uint32_t timeout_ms)

{
  ushort uVar1;
  ClientState CVar2;
  _Bool _Var3;
  IoT_Error_t IVar4;
  byte bVar5;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  int iVar6;
  undefined3 extraout_var_04;
  undefined3 extraout_var_05;
  undefined3 extraout_var_06;
  undefined3 extraout_var_07;
  undefined3 extraout_var_08;
  undefined3 extraout_var_09;
  undefined3 extraout_var_10;
  uint timeout;
  anon_subr_IoT_Error_t_Network_ptr_for_isConnected *paVar7;
  int iVar8;
  Timer *timer_00;
  uint8_t uStack61;
  uint8_t packet_type;
  size_t sStack60;
  size_t serialized_len;
  Timer timer;
  Timer timer_1;
  
  if (pClient == (AWS_IoT_Client *)0x0) {
    return NULL_VALUE_ERROR;
  }
  if (timeout_ms == 0) {
    return NULL_VALUE_ERROR;
  }
  CVar2 = aws_iot_mqtt_get_client_state(pClient);
  iVar6 = CONCAT31(extraout_var,CVar2);
  if (iVar6 == 0xc) {
    return NETWORK_MANUALLY_DISCONNECTED;
  }
  if (iVar6 != 0xd) {
    _Var3 = aws_iot_mqtt_is_client_connected(pClient);
    if (CONCAT31(extraout_var_05,_Var3) == 0) {
      return NETWORK_DISCONNECTED_ERROR;
    }
    if (iVar6 != 3) {
      return MQTT_CLIENT_NOT_IDLE_ERROR;
    }
    iVar6 = aws_iot_mqtt_set_client_state(pClient,3,4);
    if (iVar6 != 0) {
      return (IoT_Error_t)iVar6;
    }
  }
  init_timer((Timer *)&serialized_len);
  countdown_ms((Timer *)&serialized_len,timeout_ms);
  timer_00 = &pClient->reconnectDelayTimer;
  do {
    CVar2 = aws_iot_mqtt_get_client_state(pClient);
    if (CONCAT31(extraout_var_00,CVar2) == 0xd) {
      if (0x1f400 < (pClient->clientData).currentReconnectWaitInterval) {
        iVar6 = -0xe;
        goto LAB_2305042e;
      }
      _Var3 = has_timer_expired(timer_00);
      iVar6 = 4;
      if (CONCAT31(extraout_var_01,_Var3) != 0) {
        paVar7 = (pClient->networkStack).isConnected;
        if (paVar7 == (anon_subr_IoT_Error_t_Network_ptr_for_isConnected *)0x0) {
          iVar8 = -0x12;
        }
        else {
          IVar4 = (*paVar7)((Network *)&pClient->networkStack);
          iVar8 = CONCAT31(extraout_var_02,IVar4);
          if (iVar8 == 6) {
            IVar4 = aws_iot_mqtt_attempt_reconnect(pClient);
            iVar8 = CONCAT31(extraout_var_03,IVar4);
            if (iVar8 == 3) {
              iVar6 = aws_iot_mqtt_set_client_state(pClient,3,4);
              if (iVar6 == 0) {
                iVar6 = 3;
              }
              goto LAB_2305030e;
            }
          }
        }
        timeout = (pClient->clientData).currentReconnectWaitInterval << 1;
        (pClient->clientData).currentReconnectWaitInterval = timeout;
        iVar6 = -0xe;
        if (timeout < 0x1f401) {
          countdown_ms(timer_00,timeout);
          iVar6 = iVar8;
        }
      }
    }
    else {
      bVar5 = aws_iot_mqtt_internal_cycle_read(pClient,(Timer *)&serialized_len,&uStack61);
      iVar6 = CONCAT31(extraout_var_06,bVar5);
      if (iVar6 == 0) {
        if (((pClient->clientData).keepAliveInterval == 0) ||
           (_Var3 = has_timer_expired((Timer *)pClient), CONCAT31(extraout_var_07,_Var3) == 0))
        goto LAB_2305030e;
        if ((pClient->clientStatus).isPingOutstanding == false) {
          init_timer((Timer *)&timer.last_polled_ticks);
          countdown_ms((Timer *)&timer.last_polled_ticks,(pClient->clientData).commandTimeoutMs);
          sStack60 = 0;
          IVar4 = aws_iot_mqtt_internal_serialize_zero
                            ((pClient->clientData).writeBuf,(pClient->clientData).writeBufSize,
                             PINGREQ,(size_t *)&stack0xffffffc4);
          iVar6 = CONCAT31(extraout_var_09,IVar4);
          if (iVar6 == 0) {
            IVar4 = aws_iot_mqtt_internal_send_packet
                              (pClient,sStack60,(Timer *)&timer.last_polled_ticks);
            iVar6 = CONCAT31(extraout_var_10,IVar4);
            if (iVar6 == 0) {
              uVar1 = (pClient->clientData).keepAliveInterval;
              (pClient->clientStatus).isPingOutstanding = true;
              countdown_sec((Timer *)pClient,(uint)uVar1);
              goto LAB_2305030e;
            }
            goto LAB_23050392;
          }
        }
        else {
LAB_23050392:
          IVar4 = _aws_iot_mqtt_handle_disconnect(pClient);
          iVar6 = CONCAT31(extraout_var_08,IVar4);
        }
        if (iVar6 != -0xd) {
          if (iVar6 == 0) goto LAB_2305030e;
          goto LAB_2305042e;
        }
      }
      else {
        if (((bVar5 & 0xfd) == 0xf4) || (iVar6 == -7)) goto LAB_23050392;
        if (iVar6 != -0xd) goto LAB_2305042e;
      }
      (pClient->clientData).counterNetworkDisconnected =
           (pClient->clientData).counterNetworkDisconnected + 1;
      if ((pClient->clientStatus).isAutoReconnectEnabled == false) {
        return NETWORK_DISCONNECTED_ERROR;
      }
      iVar6 = aws_iot_mqtt_set_client_state(pClient,0xb,0xd);
      if (iVar6 != 0) break;
      (pClient->clientData).currentReconnectWaitInterval = 1000;
      countdown_ms(timer_00,1000);
      iVar6 = 4;
    }
LAB_2305030e:
    _Var3 = has_timer_expired((Timer *)&serialized_len);
  } while (CONCAT31(extraout_var_04,_Var3) == 0);
  if (iVar6 == -0xd) {
    return NETWORK_DISCONNECTED_ERROR;
  }
LAB_2305042e:
  if (iVar6 == 4) {
    return (IoT_Error_t)iVar6;
  }
  IVar4 = aws_iot_mqtt_set_client_state(pClient,4,3);
  if (iVar6 == 0) {
    return IVar4;
  }
  return (IoT_Error_t)iVar6;
}



IoT_Error_t iot_tls_is_connected(Network *pNetwork)

{
  return NETWORK_PHYSICAL_LAYER_CONNECTED;
}



// WARNING: Variable defined which should be unmapped: info_buf

IoT_Error_t iot_tls_connect(Network *pNetwork,TLSConnectParams *params)

{
  _Bool _Var1;
  mbedtls_ssl_context *ssl;
  size_t len;
  int authmode;
  uint uVar2;
  mbedtls_x509_crt *crt;
  uchar *buf;
  char *__format;
  char *pcVar3;
  uint32_t uVar4;
  char *pcVar5;
  char *pcVar6;
  IoT_Error_t IVar7;
  mbedtls_ssl_config *conf;
  mbedtls_net_context *ctx;
  mbedtls_pk_context *ctx_00;
  mbedtls_x509_crt *crt_00;
  mbedtls_ctr_drbg_context_conflict *ctx_01;
  char acStack312 [4];
  char portBuffer [6];
  char info_buf [256];
  
  if (pNetwork == (Network *)0x0) {
    return NULL_VALUE_ERROR;
  }
  if (params != (TLSConnectParams *)0x0) {
    pcVar3 = params->pRootCALocation;
    pcVar5 = params->pDeviceCertLocation;
    __format = params->pDevicePrivateKeyLocation;
    pcVar6 = params->pDestinationURL;
    uVar4 = params->timeout_ms;
    _Var1 = params->ServerVerificationFlag;
    (pNetwork->tlsConnectParams).DestinationPort = params->DestinationPort;
    (pNetwork->tlsConnectParams).pDestinationURL = pcVar6;
    (pNetwork->tlsConnectParams).pDeviceCertLocation = pcVar5;
    (pNetwork->tlsConnectParams).pDevicePrivateKeyLocation = __format;
    (pNetwork->tlsConnectParams).pRootCALocation = pcVar3;
    (pNetwork->tlsConnectParams).timeout_ms = uVar4;
    (pNetwork->tlsConnectParams).ServerVerificationFlag = _Var1;
  }
  ctx = &(pNetwork->tlsDataParams).server_fd;
  mbedtls_net_init(ctx);
  ssl = (mbedtls_ssl_context *)&(pNetwork->tlsDataParams).ssl;
  mbedtls_ssl_init(ssl);
  conf = (mbedtls_ssl_config *)&(pNetwork->tlsDataParams).conf;
  mbedtls_ssl_config_init(conf);
  ctx_01 = (mbedtls_ctr_drbg_context_conflict *)&(pNetwork->tlsDataParams).ctr_drbg;
  mbedtls_ctr_drbg_init(ctx_01);
  crt_00 = &(pNetwork->tlsDataParams).cacert;
  mbedtls_x509_crt_init(crt_00);
  crt = &(pNetwork->tlsDataParams).clicert;
  mbedtls_x509_crt_init(crt);
  ctx_00 = &(pNetwork->tlsDataParams).pkey;
  mbedtls_pk_init(ctx_00);
  printf("DEBUG Seeding the random number generator...\r\n");
  mbedtls_entropy_init((mbedtls_entropy_context *)&pNetwork->tlsDataParams);
  __format = TAG;
  len = strlen(TAG);
  authmode = mbedtls_ctr_drbg_seed
                       (ctx_01,mbedtls_entropy_func,&pNetwork->tlsDataParams,(uchar *)__format,len);
  if (authmode != 0) {
    printf("ERROR failed! mbedtls_ctr_drbg_seed returned -0x%x\r\n",-authmode);
    return NETWORK_MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED;
  }
  if (*(pNetwork->tlsConnectParams).pRootCALocation == '/') {
    printf("DEBUG Loading CA root certificate from file ...\r\n");
    authmode = mbedtls_x509_crt_parse_file(crt_00,(pNetwork->tlsConnectParams).pRootCALocation);
  }
  else {
    printf("DEBUG Loading embedded CA root certificate ...\r\n");
    buf = (uchar *)(pNetwork->tlsConnectParams).pRootCALocation;
    len = strlen((char *)buf);
    authmode = mbedtls_x509_crt_parse(crt_00,buf,len + 1);
  }
  if (authmode < 0) {
    printf("ERROR failed!  mbedtls_x509_crt_parse returned -0x%x while parsing root cert\r\n",
           -authmode);
    return NETWORK_X509_ROOT_CRT_PARSE_ERROR;
  }
  printf("DEBUG ok (%d skipped)\r\n",authmode);
  if (*(pNetwork->tlsConnectParams).pDeviceCertLocation == '/') {
    printf("DEBUG Loading client cert from file...\r\n");
    authmode = mbedtls_x509_crt_parse_file(crt,(pNetwork->tlsConnectParams).pDeviceCertLocation);
  }
  else {
    printf("DEBUG Loading embedded client certificate...\r\n");
    buf = (uchar *)(pNetwork->tlsConnectParams).pDeviceCertLocation;
    len = strlen((char *)buf);
    authmode = mbedtls_x509_crt_parse(crt,buf,len + 1);
  }
  if (authmode != 0) {
    printf("ERROR failed!  mbedtls_x509_crt_parse returned -0x%x while parsing device cert\r\n",
           -authmode);
    return NETWORK_X509_DEVICE_CRT_PARSE_ERROR;
  }
  if (*(pNetwork->tlsConnectParams).pDevicePrivateKeyLocation == '/') {
    printf("DEBUG Loading client private key from file...\r\n");
    authmode = mbedtls_pk_parse_keyfile
                         (ctx_00,(pNetwork->tlsConnectParams).pDevicePrivateKeyLocation,"");
  }
  else {
    printf("DEBUG Loading embedded client private key...\r\n");
    buf = (uchar *)(pNetwork->tlsConnectParams).pDevicePrivateKeyLocation;
    len = strlen((char *)buf);
    authmode = mbedtls_pk_parse_key(ctx_00,buf,len + 1,"",0);
  }
  if (authmode != 0) {
    printf("ERROR failed!  mbedtls_pk_parse_key returned -0x%x while parsing private key\r\n",
           -authmode);
    return NETWORK_PK_PRIVATE_KEY_PARSE_ERROR;
  }
  printf("DEBUG ok\r\n");
  snprintf(acStack312,6,"%d",(uint)(pNetwork->tlsConnectParams).DestinationPort);
  printf("DEBUG Connecting to %s/%s...\r\n",(pNetwork->tlsConnectParams).pDestinationURL,acStack312)
  ;
  authmode = mbedtls_net_connect(ctx,(pNetwork->tlsConnectParams).pDestinationURL,acStack312,0);
  if (authmode != 0) {
    printf("ERROR failed! mbedtls_net_connect returned -0x%x\r\n",-authmode);
    if (authmode == -0x52) {
      return NETWORK_ERR_NET_UNKNOWN_HOST;
    }
    if (authmode == -0x42) {
      return NETWORK_ERR_NET_SOCKET_FAILED;
    }
    return NETWORK_ERR_NET_CONNECT_FAILED;
  }
  authmode = mbedtls_net_set_block(ctx);
  if (authmode != 0) {
    authmode = -authmode;
    __format = "ERROR failed! net_set_(non)block() returned -0x%x\r\n";
LAB_2305072e:
    printf(__format,authmode);
    return SSL_CONNECTION_ERROR;
  }
  printf("DEBUG ok\r\n");
  printf("DEBUG Setting up the SSL/TLS structure...\r\n");
  authmode = mbedtls_ssl_config_defaults(conf,0,0,0);
  if (authmode != 0) {
    authmode = -authmode;
    __format = "ERROR failed! mbedtls_ssl_config_defaults returned -0x%x\r\n";
    goto LAB_2305072e;
  }
  mbedtls_ssl_conf_verify(conf,_iot_tls_verify_cert,(void *)0x0);
  authmode = 2;
  if ((pNetwork->tlsConnectParams).ServerVerificationFlag == false) {
    authmode = 1;
  }
  mbedtls_ssl_conf_authmode(conf,authmode);
  mbedtls_ssl_conf_rng(conf,mbedtls_ctr_drbg_random,ctx_01);
  mbedtls_ssl_conf_ca_chain(conf,crt_00,(mbedtls_x509_crl *)0x0);
  authmode = mbedtls_ssl_conf_own_cert(conf,crt,ctx_00);
  if (authmode != 0) {
    __format = "ERROR failed! mbedtls_ssl_conf_own_cert returned %d\r\n";
    goto LAB_2305072e;
  }
  mbedtls_ssl_conf_read_timeout(conf,(pNetwork->tlsConnectParams).timeout_ms);
  if ((pNetwork->tlsConnectParams).DestinationPort == 0x1bb) {
    stack0xfffffed0 = "x-amzn-mqtt-ca";
    authmode = mbedtls_ssl_conf_alpn_protocols(conf,(char **)(portBuffer + 4));
    if (authmode != 0) {
      authmode = -authmode;
      __format = "ERROR failed! mbedtls_ssl_conf_alpn_protocols returned -0x%x\r\n";
      goto LAB_2305072e;
    }
  }
  authmode = mbedtls_ssl_setup(ssl,conf);
  if (authmode != 0) {
    authmode = -authmode;
    __format = "ERROR failed! mbedtls_ssl_setup returned -0x%x\r\n";
    goto LAB_2305072e;
  }
  authmode = mbedtls_ssl_set_hostname(ssl,(pNetwork->tlsConnectParams).pDestinationURL);
  if (authmode != 0) {
    __format = "ERROR failed! mbedtls_ssl_set_hostname returned %d\r\n";
    goto LAB_2305072e;
  }
  printf("DEBUG SSL state connect : %d \r\n",(pNetwork->tlsDataParams).ssl.state);
  mbedtls_ssl_set_bio(ssl,ctx,mbedtls_net_send,(mbedtls_ssl_recv_t *)0x0,mbedtls_net_recv_timeout);
  printf("DEBUG ok\r\n");
  printf("DEBUG SSL state connect : %d \r\n",(pNetwork->tlsDataParams).ssl.state);
  printf("DEBUG Performing the SSL/TLS handshake...\r\n");
  while( true ) {
    uVar2 = mbedtls_ssl_handshake(ssl);
    IVar7 = (IoT_Error_t)uVar2;
    if (uVar2 == 0) break;
    if ((uVar2 & 0xffffff7f) != 0xffff9700) {
      printf("ERROR failed! mbedtls_ssl_handshake returned -0x%x\r\n",-uVar2);
      if (uVar2 != 0xffffd900) {
        return SSL_CONNECTION_ERROR;
      }
      printf("ERROR     Unable to verify the server\'s certificate. \r\n");
      return SSL_CONNECTION_ERROR;
    }
  }
  __format = mbedtls_ssl_get_version(ssl);
  pcVar3 = mbedtls_ssl_get_ciphersuite(ssl);
  printf("DEBUG ok [ Protocol is %s ]    [ Ciphersuite is %s ]\r\n",__format,pcVar3);
  authmode = mbedtls_ssl_get_record_expansion(ssl);
  if (authmode < 0) {
    printf("DEBUG  [ Record expansion is unknown (compression) ]\r\n",authmode);
  }
  else {
    printf("DEBUG  [ Record expansion is %d ]\r\n",authmode);
  }
  printf("DEBUG Verifying peer X.509 certificate...\r\n");
  if ((pNetwork->tlsConnectParams).ServerVerificationFlag == false) {
    __format = "WARNN  Server Verification skipped\r\n";
  }
  else {
    uVar4 = mbedtls_ssl_get_verify_result(ssl);
    (pNetwork->tlsDataParams).flags = uVar4;
    if (uVar4 != 0) {
      printf("ERROR failed\r\n");
      mbedtls_x509_crt_verify_info(portBuffer + 4,0x100,"  ! ",(pNetwork->tlsDataParams).flags);
      printf("ERROR %s\r\n",portBuffer + 4);
      IVar7 = SSL_CONNECTION_ERROR;
      goto LAB_23050902;
    }
    __format = "DEBUG ok\r\n";
  }
  printf(__format);
LAB_23050902:
  crt = mbedtls_ssl_get_peer_cert(ssl);
  if (crt == (mbedtls_x509_crt *)0x0) {
    return IVar7;
  }
  printf("DEBUG Peer certificate information:\r\n");
  crt = mbedtls_ssl_get_peer_cert(ssl);
  mbedtls_x509_crt_info(portBuffer + 4,0xff,"      ",crt);
  printf("DEBUG %s\r\n",portBuffer + 4);
  return IVar7;
}



int _iot_tls_verify_cert(void *data,mbedtls_x509_crt *crt,int depth,uint32_t *flags)

{
  char acStack272 [4];
  char buf [256];
  
  printf("DEBUG Verify requested for (Depth %d):\r\n",depth);
  mbedtls_x509_crt_info(acStack272,0xff,"",crt);
  printf("DEBUG %s\r\n",acStack272);
  if (*flags == 0) {
    printf("DEBUG   This certificate has no flags\r\n");
  }
  else {
    printf("DEBUG Verify result:%s\r\n",acStack272);
  }
  return 0;
}



IoT_Error_t iot_tls_write(Network *pNetwork,uchar *pMsg,size_t len,Timer *timer,size_t *written_len)

{
  uint uVar1;
  int iVar2;
  _Bool _Var3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  IoT_Error_t IVar4;
  
  iVar2 = 0;
  uVar1 = 0;
  do {
    if ((len <= uVar1) || (_Var3 = has_timer_expired(timer), CONCAT31(extraout_var,_Var3) != 0)) {
      *written_len = uVar1;
      _Var3 = has_timer_expired(timer);
      IVar4 = SUCCESS;
      if ((CONCAT31(extraout_var_01,_Var3) != 0) && (IVar4 = SUCCESS, uVar1 != len)) {
        IVar4 = NETWORK_SSL_WRITE_TIMEOUT_ERROR;
      }
      return IVar4;
    }
    while ((_Var3 = has_timer_expired(timer), CONCAT31(extraout_var_00,_Var3) == 0 &&
           (iVar2 = mbedtls_ssl_write((mbedtls_ssl_context *)&(pNetwork->tlsDataParams).ssl,
                                      pMsg + uVar1,len - uVar1), iVar2 < 1))) {
      if ((iVar2 != -0x6900) && (iVar2 != -0x6880)) {
        printf("ERROR failed! mbedtls_ssl_write returned -0x%x\r\n",-iVar2);
        *written_len = uVar1;
        return NETWORK_SSL_WRITE_ERROR;
      }
    }
    uVar1 = uVar1 + iVar2;
  } while( true );
}



IoT_Error_t iot_tls_read(Network *pNetwork,uchar *pMsg,size_t len,Timer *timer,size_t *read_len)

{
  IoT_Error_t IVar1;
  _Bool _Var2;
  uint32_t timeout;
  uint32_t uVar3;
  uint uVar4;
  undefined3 extraout_var;
  uint timeout_00;
  size_t sVar5;
  mbedtls_ssl_config *conf;
  
  timeout_00 = (pNetwork->tlsDataParams).conf.read_timeout;
  conf = (mbedtls_ssl_config *)&(pNetwork->tlsDataParams).conf;
  sVar5 = 0;
  do {
    if (len == 0) goto LAB_23050b08;
    timeout = left_ms(timer);
    uVar3 = timeout_00;
    if (timeout <= timeout_00) {
      uVar3 = left_ms(timer);
    }
    timeout = 1;
    if ((uVar3 != 0) && (uVar3 = left_ms(timer), timeout = timeout_00, uVar3 <= timeout_00)) {
      timeout = left_ms(timer);
    }
    mbedtls_ssl_conf_read_timeout(conf,timeout);
    uVar4 = mbedtls_ssl_read((mbedtls_ssl_context *)&(pNetwork->tlsDataParams).ssl,pMsg,len);
    mbedtls_ssl_conf_read_timeout(conf,timeout_00);
    if ((int)uVar4 < 1) {
      if ((uVar4 == 0) || (((uVar4 & 0xffffff7f) != 0xffff9700 && (uVar4 != 0xffff9800)))) {
        return NETWORK_SSL_READ_ERROR;
      }
    }
    else {
      sVar5 = sVar5 + uVar4;
      pMsg = pMsg + uVar4;
      len = len - uVar4;
    }
    _Var2 = has_timer_expired(timer);
  } while (CONCAT31(extraout_var,_Var2) == 0);
  if (len == 0) {
LAB_23050b08:
    *read_len = sVar5;
    IVar1 = SUCCESS;
  }
  else {
    IVar1 = NETWORK_SSL_NOTHING_TO_READ;
    if (sVar5 != 0) {
      IVar1 = NETWORK_SSL_READ_TIMEOUT_ERROR;
    }
  }
  return IVar1;
}



IoT_Error_t iot_tls_disconnect(Network *pNetwork)

{
  int iVar1;
  
  do {
    iVar1 = mbedtls_ssl_close_notify((mbedtls_ssl_context *)&(pNetwork->tlsDataParams).ssl);
  } while (iVar1 == -0x6880);
  return SUCCESS;
}



IoT_Error_t iot_tls_destroy(Network *pNetwork)

{
  mbedtls_net_free(&(pNetwork->tlsDataParams).server_fd);
  mbedtls_x509_crt_free(&(pNetwork->tlsDataParams).clicert);
  mbedtls_x509_crt_free(&(pNetwork->tlsDataParams).cacert);
  mbedtls_pk_free(&(pNetwork->tlsDataParams).pkey);
  mbedtls_ssl_free((mbedtls_ssl_context *)&(pNetwork->tlsDataParams).ssl);
  mbedtls_ssl_config_free((mbedtls_ssl_config *)&(pNetwork->tlsDataParams).conf);
  mbedtls_ctr_drbg_free((mbedtls_ctr_drbg_context_conflict *)&(pNetwork->tlsDataParams).ctr_drbg);
  mbedtls_entropy_free((mbedtls_entropy_context *)&pNetwork->tlsDataParams);
  return SUCCESS;
}



IoT_Error_t
iot_tls_init(Network *pNetwork,char *pRootCALocation,char *pDeviceCertLocation,
            char *pDevicePrivateKeyLocation,char *pDestinationURL,uint16_t destinationPort,
            uint32_t timeout_ms,_Bool ServerVerificationFlag)

{
  (pNetwork->tlsConnectParams).DestinationPort = destinationPort;
  pNetwork->connect = iot_tls_connect;
  pNetwork->read = iot_tls_read;
  pNetwork->write = iot_tls_write;
  pNetwork->disconnect = iot_tls_disconnect;
  pNetwork->isConnected = iot_tls_is_connected;
  (pNetwork->tlsConnectParams).pDestinationURL = pDestinationURL;
  (pNetwork->tlsConnectParams).pDeviceCertLocation = pDeviceCertLocation;
  (pNetwork->tlsConnectParams).pDevicePrivateKeyLocation = pDevicePrivateKeyLocation;
  (pNetwork->tlsConnectParams).pRootCALocation = pRootCALocation;
  (pNetwork->tlsConnectParams).timeout_ms = timeout_ms;
  (pNetwork->tlsConnectParams).ServerVerificationFlag = ServerVerificationFlag;
  pNetwork->destroy = iot_tls_destroy;
  (pNetwork->tlsDataParams).flags = 0;
  return SUCCESS;
}



IoT_Error_t aws_iot_thread_mutex_init(IoT_Mutex_t *pMutex)

{
  IoT_Error_t IVar1;
  QueueHandle_t pQVar2;
  
  pQVar2 = xQueueCreateMutex('\x04');
  *(QueueHandle_t *)&pMutex->mutex = pQVar2;
  if (pQVar2 == (QueueHandle_t)0x0) {
    IVar1 = MUTEX_INIT_ERROR;
  }
  else {
    IVar1 = SUCCESS;
  }
  return IVar1;
}



IoT_Error_t aws_iot_thread_mutex_lock(IoT_Mutex_t *pMutex)

{
  xQueueTakeMutexRecursive((QueueHandle_t)pMutex->mutex,0xffffffff);
  return SUCCESS;
}



IoT_Error_t aws_iot_thread_mutex_trylock(IoT_Mutex_t *pMutex)

{
  IoT_Error_t IVar1;
  BaseType_t BVar2;
  
  BVar2 = xQueueTakeMutexRecursive((QueueHandle_t)pMutex->mutex,0);
  if (BVar2 == 0) {
    IVar1 = MUTEX_LOCK_ERROR;
  }
  else {
    IVar1 = SUCCESS;
  }
  return IVar1;
}



IoT_Error_t aws_iot_thread_mutex_unlock(IoT_Mutex_t *pMutex)

{
  IoT_Error_t IVar1;
  BaseType_t BVar2;
  
  BVar2 = xQueueGiveMutexRecursive((QueueHandle_t)pMutex->mutex);
  if (BVar2 == 0) {
    IVar1 = MUTEX_UNLOCK_ERROR;
  }
  else {
    IVar1 = SUCCESS;
  }
  return IVar1;
}



IoT_Error_t aws_iot_thread_mutex_destroy(IoT_Mutex_t *pMutex)

{
  vQueueDelete((QueueHandle_t)pMutex->mutex);
  return SUCCESS;
}



// WARNING: Variable defined which should be unmapped: byteRead

IoT_Error_t
_aws_iot_mqtt_internal_readWrapper
          (AWS_IoT_Client *pClient,size_t offset,size_t size,Timer *pTimer,size_t *read_len)

{
  IoT_Error_t IVar1;
  size_t sVar2;
  size_t sVar3;
  size_t sStack20;
  size_t byteRead;
  
  sVar3 = (pClient->clientData).readBufIndex;
  sStack20 = 0;
  sVar2 = (offset - sVar3) + size;
  if ((int)sVar2 < 1) {
    *read_len = size;
    IVar1 = SUCCESS;
  }
  else {
    IVar1 = (*(pClient->networkStack).read)
                      ((Network *)&pClient->networkStack,(pClient->clientData).readBuf + sVar3,sVar2
                       ,pTimer,&sStack20);
    sStack20 = sStack20 + (pClient->clientData).readBufIndex;
    (pClient->clientData).readBufIndex = sStack20;
    *read_len = sStack20 - offset;
  }
  return IVar1;
}



size_t aws_iot_mqtt_internal_write_len_to_buffer(uchar *buf,uint32_t length)

{
  bool bVar1;
  byte bVar2;
  size_t sVar3;
  size_t sVar4;
  
  sVar3 = 0;
  do {
    bVar2 = (byte)length & 0x7f;
    if (0x7f < length) {
      bVar2 = bVar2 | 0x80;
    }
    sVar4 = sVar3 + 1;
    buf[sVar3] = bVar2;
    bVar1 = 0x7f < length;
    length = length >> 7;
    sVar3 = sVar4;
  } while (bVar1);
  return sVar4;
}



IoT_Error_t
aws_iot_mqtt_internal_decode_remaining_length_from_buffer
          (uchar *buf,uint32_t *decodedLen,uint32_t *readBytesLen)

{
  byte bVar1;
  int iVar2;
  uint32_t uVar3;
  int iVar4;
  
  *decodedLen = 0;
  iVar2 = 1;
  uVar3 = 0;
  do {
    uVar3 = uVar3 + 1;
    if (uVar3 == 5) {
      return MQTT_DECODE_REMAINING_LENGTH_ERROR;
    }
    bVar1 = buf[uVar3];
    iVar4 = ((uint)bVar1 & 0x7f) * iVar2;
    iVar2 = iVar2 << 7;
    *decodedLen = *decodedLen + iVar4;
    uVar3 = uVar3;
  } while ((char)bVar1 < '\0');
  *readBytesLen = uVar3;
  return SUCCESS;
}



uint32_t aws_iot_mqtt_internal_get_final_packet_length_from_remaining_length(uint32_t rem_len)

{
  uint32_t uVar1;
  uint uVar2;
  
  uVar2 = rem_len + 1;
  if (uVar2 < 0x80) {
    return rem_len + 2;
  }
  if (uVar2 < 0x4000) {
    return rem_len + 3;
  }
  uVar1 = rem_len + 5;
  if (uVar2 < 0x200000) {
    uVar1 = rem_len + 4;
  }
  return uVar1;
}



uint16_t aws_iot_mqtt_internal_read_uint16_t(uchar **pptr)

{
  uchar uVar1;
  uchar uVar2;
  uchar *puVar3;
  
  puVar3 = *pptr;
  uVar1 = *puVar3;
  uVar2 = puVar3[1];
  *pptr = puVar3 + 2;
  return CONCAT11(uVar1,uVar2);
}



void aws_iot_mqtt_internal_write_uint_16(uchar **pptr,uint16_t anInt)

{
  uchar *puVar1;
  
  **pptr = (uchar)(anInt >> 8);
  puVar1 = *pptr;
  *pptr = puVar1 + 1;
  puVar1[1] = (uchar)anInt;
  *pptr = *pptr + 1;
  return;
}



uchar aws_iot_mqtt_internal_read_char(uchar **pptr)

{
  uchar uVar1;
  
  uVar1 = **pptr;
  *pptr = *pptr + 1;
  return uVar1;
}



void aws_iot_mqtt_internal_write_char(uchar **pptr,uchar c)

{
  **pptr = c;
  *pptr = *pptr + 1;
  return;
}



void aws_iot_mqtt_internal_write_utf8_string(uchar **pptr,char *string,uint16_t stringLen)

{
  undefined2 in_register_00002032;
  size_t __n;
  
  __n = CONCAT22(in_register_00002032,stringLen);
  aws_iot_mqtt_internal_write_uint_16(pptr,stringLen);
  if (__n != 0) {
    memcpy(*pptr,string,__n);
    *pptr = *pptr + __n;
  }
  return;
}



IoT_Error_t
aws_iot_mqtt_internal_init_header
          (MQTTHeader *pHeader,MessageTypes message_type,QoS qos,uint8_t dup,uint8_t retained)

{
  uint uVar1;
  undefined3 in_register_00002031;
  byte bVar2;
  undefined3 in_register_00002039;
  IoT_Error_t IVar3;
  
  IVar3 = NULL_VALUE_ERROR;
  if (pHeader != (MQTTHeader *)0x0) {
    *pHeader = 0;
    uVar1 = (uint)(byte)message_type - 1 & 0xff;
    IVar3 = FAILURE;
    if (uVar1 < 0xe) {
      bVar2 = dup << 3 | CSWTCH_27[uVar1] << 4;
      if (CONCAT31(in_register_00002031,qos) == 1) {
        bVar2 = bVar2 | 2;
      }
      *pHeader = bVar2;
      *pHeader = CONCAT31(in_register_00002039,retained) == 1 | *pHeader;
      IVar3 = SUCCESS;
    }
  }
  return IVar3;
}



IoT_Error_t aws_iot_mqtt_internal_send_packet(AWS_IoT_Client *pClient,size_t length,Timer *pTimer)

{
  IoT_Error_t IVar1;
  _Bool _Var2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  uint uVar3;
  IoT_Mutex_t *pMutex;
  size_t sStack36;
  size_t sentLen;
  
  if ((pClient != (AWS_IoT_Client *)0x0) && (pTimer != (Timer *)0x0)) {
    IVar1 = MQTT_TX_BUFFER_TOO_SHORT_ERROR;
    if (length < (pClient->clientData).writeBufSize) {
      pMutex = &(pClient->clientData).tls_write_mutex;
      IVar1 = aws_iot_mqtt_client_lock_mutex(pClient,pMutex);
      if (CONCAT31(extraout_var,IVar1) == 0) {
        sStack36 = 0;
        uVar3 = 0;
        while (((uVar3 < length &&
                (_Var2 = has_timer_expired(pTimer), CONCAT31(extraout_var_00,_Var2) == 0)) &&
               (IVar1 = (*(pClient->networkStack).write)
                                  ((Network *)&pClient->networkStack,
                                   (pClient->clientData).writeBuf + uVar3,length - uVar3,pTimer,
                                   &sStack36), CONCAT31(extraout_var_01,IVar1) == 0))) {
          uVar3 = uVar3 + sStack36;
        }
        IVar1 = aws_iot_mqtt_client_unlock_mutex(pClient,pMutex);
      }
    }
    return IVar1;
  }
  return NULL_VALUE_ERROR;
}



// WARNING: Could not reconcile some variable overlaps

IoT_Error_t
aws_iot_mqtt_internal_cycle_read(AWS_IoT_Client *pClient,Timer *pTimer,uint8_t *pPacketType)

{
  byte bVar1;
  char cVar2;
  ushort uVar3;
  char *pcVar4;
  IoT_Error_t IVar5;
  uint __n;
  MessageHandlers_conflict40 *pMVar6;
  IoT_Error_t IVar7;
  ClientState CVar8;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  undefined3 extraout_var_05;
  undefined3 extraout_var_06;
  undefined3 extraout_var_07;
  char *pcVar9;
  int iVar10;
  char *__s1;
  size_t sVar11;
  char *pcVar12;
  char *pcVar13;
  IoT_Mutex_t *pMutex;
  size_t offset;
  int iVar14;
  uchar *in_fa0;
  uchar *extraout_fa0;
  size_t in_fa1;
  size_t extraout_fa1;
  uint16_t uStack74;
  uint16_t topicNameLen;
  char *pcStack72;
  size_t read_len;
  size_t read_len_1;
  Timer packetTimer;
  
  IVar7 = NULL_VALUE_ERROR;
  if ((pClient != (AWS_IoT_Client *)0x0) && (pTimer != (Timer *)0x0)) {
    pMutex = &(pClient->clientData).tls_read_mutex;
    IVar7 = aws_iot_mqtt_client_lock_mutex(pClient,pMutex);
    if (CONCAT31(extraout_var,IVar7) == 0) {
      init_timer((Timer *)&read_len_1);
      countdown_ms((Timer *)&read_len_1,(pClient->clientData).packetTimeoutMs);
      pcStack72 = (char *)0x0;
      IVar7 = _aws_iot_mqtt_internal_readWrapper(pClient,0,1,pTimer,(size_t *)&stack0xffffffb8);
      __n = CONCAT31(extraout_var_00,IVar7);
      if (__n == 0xffffffe7) {
        __n = 2;
      }
      else {
        if (__n == 0) {
          __s1 = (char *)0x0;
          iVar14 = 1;
          offset = 0;
          do {
            sVar11 = offset;
            offset = sVar11 + 1;
            if (offset == 5) {
              __n = 0xffffffdd;
              goto LAB_2305102e;
            }
            IVar7 = _aws_iot_mqtt_internal_readWrapper(pClient,offset,1,pTimer,&read_len);
            __n = CONCAT31(extraout_var_01,IVar7);
            if (__n != 0) goto LAB_2305102e;
            bVar1 = (pClient->clientData).readBuf[sVar11 + 1];
            iVar10 = ((uint)bVar1 & 0x7f) * iVar14;
            iVar14 = iVar14 << 7;
            __s1 = __s1 + iVar10;
          } while ((char)bVar1 < '\0');
          pcVar13 = (char *)(pClient->clientData).readBufSize;
          if (__s1 + sVar11 + 2 < pcVar13) {
            if ((__s1 == (char *)0x0) ||
               ((IVar7 = _aws_iot_mqtt_internal_readWrapper
                                   (pClient,sVar11 + 2,(size_t)__s1,pTimer,
                                    (size_t *)&stack0xffffffb8),
                CONCAT31(extraout_var_04,IVar7) == 0 && (pcStack72 == __s1)))) {
              (pClient->clientData).readBufIndex = 0;
              *pPacketType = (pClient->clientData).readBuf[0] >> 4;
            }
            else {
              __n = 0xffffffff;
            }
          }
          else {
            pcVar12 = (char *)0x0;
            do {
              IVar7 = (*(pClient->networkStack).read)
                                ((Network *)&pClient->networkStack,(pClient->clientData).readBuf,
                                 (size_t)pcVar13,pTimer,(size_t *)&stack0xffffffb8);
              __n = CONCAT31(extraout_var_02,IVar7);
              in_fa0 = extraout_fa0;
              in_fa1 = extraout_fa1;
              if (__n != 0) {
                if (pcVar12 < __s1) goto LAB_2305102e;
                break;
              }
              pcVar12 = pcVar12 + (int)pcStack72;
              pcVar9 = (char *)(pClient->clientData).readBufSize;
              pcVar13 = __s1 + -(int)pcVar12;
              if (pcVar9 < __s1 + -(int)pcVar12) {
                pcVar13 = pcVar9;
              }
            } while (pcVar12 < __s1);
            if (__s1 == pcVar12) {
              (pClient->clientData).readBufIndex = 0;
              __n = 0xffffffe0;
            }
          }
        }
      }
LAB_2305102e:
      IVar5 = (IoT_Error_t)__n;
      IVar7 = aws_iot_mqtt_client_unlock_mutex(pClient,pMutex);
      if (CONCAT31(extraout_var_03,IVar7) == 0) {
        if (__n == 2) {
          return SUCCESS;
        }
        if (__n != 0) {
          return IVar5;
        }
        if (0xb < ((uint)*pPacketType - 2 & 0xff)) {
          return MQTT_RX_MESSAGE_PACKET_TYPE_INVALID_ERROR;
        }
        __n = 1 << ((uint)*pPacketType - 2 & 0x1f);
        if ((__n & 0x2ad) != 0) {
          return IVar5;
        }
        if ((int)(__n << 0x14) < 0) {
          uVar3 = (pClient->clientData).keepAliveInterval;
          (pClient->clientStatus).isPingOutstanding = false;
          countdown_sec((Timer *)pClient,(uint)uVar3);
          return IVar5;
        }
        if ((__n & 2) == 0) {
          return MQTT_RX_MESSAGE_PACKET_TYPE_INVALID_ERROR;
        }
        pcStack72 = (char *)0x0;
        uStack74 = 0;
        read_len = 0;
        IVar7 = aws_iot_mqtt_internal_deserialize_publish
                          ((uint8_t *)((int)&read_len_1 + 2),(QoS *)&read_len_1,
                           (uint8_t *)((int)&read_len_1 + 1),(uint16_t *)&packetTimer,
                           (char **)&stack0xffffffb8,&uStack74,(uchar **)&packetTimer.timeout_ticks,
                           &packetTimer.last_polled_ticks,in_fa0,in_fa1);
        __s1 = pcStack72;
        uVar3 = uStack74;
        if (CONCAT31(extraout_var_05,IVar7) != 0) {
          return IVar7;
        }
        __n = (uint)uStack74;
        if (pcStack72 == (char *)0x0) {
          return NULL_VALUE_ERROR;
        }
        CVar8 = aws_iot_mqtt_get_client_state(pClient);
        aws_iot_mqtt_set_client_state(pClient,CONCAT31(extraout_var_06,CVar8),9);
        pMVar6 = (pClient->clientData).messageHandlers;
        pcVar13 = __s1 + __n;
        do {
          if (pMVar6->topicName != (char *)0x0) {
            if (((uint)pMVar6->topicNameLen == __n) &&
               (iVar14 = strncmp(__s1,pMVar6->topicName,__n), iVar14 == 0)) {
LAB_2305118e:
              if (pMVar6->pApplicationHandler != (pApplicationHandler_t *)0x0) {
                (*pMVar6->pApplicationHandler)
                          (pClient,__s1,uVar3,(IoT_Publish_Message_Params *)&read_len_1,
                           pMVar6->pApplicationHandlerData);
              }
            }
            else {
              pcVar9 = pMVar6->topicName;
              pcVar12 = __s1;
              if (pcVar9 != (char *)0x0) {
                while (cVar2 = *pcVar9, cVar2 != '\0') {
                  if (pcVar13 <= pcVar12) goto LAB_23051140;
                  if (*pcVar12 == '/') {
                    if (cVar2 != '/') goto LAB_23051140;
                  }
                  else {
                    pcVar4 = pcVar12;
                    if (cVar2 == '+') {
                      do {
                        pcVar12 = pcVar4;
                        if (pcVar13 == pcVar12 + 1) break;
                        pcVar4 = pcVar12 + 1;
                      } while (pcVar12[1] != '/');
                    }
                    else {
                      if (cVar2 == '#') {
                        pcVar12 = pcVar13 + -1;
                      }
                      else {
                        if (*pcVar12 != cVar2) goto LAB_23051140;
                      }
                    }
                  }
                  pcVar9 = pcVar9 + 1;
                  pcVar12 = pcVar12 + 1;
                }
                if (pcVar13 == pcVar12) goto LAB_2305118e;
              }
            }
          }
LAB_23051140:
          pMVar6 = pMVar6 + 1;
        } while ((MessageHandlers_conflict40 *)&(pClient->clientData).disconnectHandler != pMVar6);
        iVar14 = aws_iot_mqtt_set_client_state(pClient,9,CONCAT31(extraout_var_06,CVar8));
        if (iVar14 != 0) {
          return (IoT_Error_t)iVar14;
        }
        if ((QoS)read_len_1 == QOS0) {
          return (IoT_Error_t)iVar14;
        }
        IVar7 = aws_iot_mqtt_internal_serialize_ack
                          ((pClient->clientData).writeBuf,(pClient->clientData).writeBufSize,PUBACK,
                           '\0',(uint16_t)packetTimer.start_ticks,&read_len);
        if (CONCAT31(extraout_var_07,IVar7) != 0) {
          return IVar7;
        }
        IVar7 = aws_iot_mqtt_internal_send_packet(pClient,read_len,pTimer);
      }
      else {
        if ((__n & 0xfd) != 0) {
          return IVar5;
        }
      }
    }
  }
  return IVar7;
}



IoT_Error_t aws_iot_mqtt_internal_flushBuffers(AWS_IoT_Client *pClient)

{
  (pClient->clientData).readBufIndex = 0;
  return SUCCESS;
}



// WARNING: Variable defined which should be unmapped: read_packet_type

IoT_Error_t
aws_iot_mqtt_internal_wait_for_read(AWS_IoT_Client *pClient,uint8_t packetType,Timer *pTimer)

{
  IoT_Error_t IVar1;
  _Bool _Var2;
  byte bVar3;
  undefined3 extraout_var;
  undefined3 in_register_0000202d;
  byte abStack17 [4];
  uint8_t read_packet_type;
  
  if (pClient == (AWS_IoT_Client *)0x0) {
    return NULL_VALUE_ERROR;
  }
  IVar1 = NULL_VALUE_ERROR;
  if (pTimer != (Timer *)0x0) {
    abStack17[0] = 0;
    while (_Var2 = has_timer_expired(pTimer), CONCAT31(extraout_var,_Var2) == 0) {
      bVar3 = aws_iot_mqtt_internal_cycle_read(pClient,pTimer,abStack17);
      if ((bVar3 & 0xfd) != 0) {
        return bVar3;
      }
      if ((uint)abStack17[0] == CONCAT31(in_register_0000202d,packetType)) {
        return bVar3;
      }
    }
    IVar1 = MQTT_REQUEST_TIMEOUT_ERROR;
  }
  return IVar1;
}



// WARNING: Variable defined which should be unmapped: ptr

IoT_Error_t
aws_iot_mqtt_internal_serialize_zero
          (uchar *pTxBuf,size_t txBufLen,MessageTypes packetType,size_t *pSerializedLength)

{
  IoT_Error_t IVar1;
  undefined3 extraout_var;
  size_t sVar2;
  uchar auStack24 [4];
  MQTTHeader header;
  uchar *ptr;
  
  auStack24[0] = '\0';
  IVar1 = NULL_VALUE_ERROR;
  if (((pTxBuf != (uchar *)0x0) && (pSerializedLength != (size_t *)0x0)) &&
     (IVar1 = MQTT_TX_BUFFER_TOO_SHORT_ERROR, 3 < txBufLen)) {
    _header = pTxBuf;
    IVar1 = aws_iot_mqtt_internal_init_header(auStack24,packetType,QOS0,'\0','\0');
    if (CONCAT31(extraout_var,IVar1) == 0) {
      aws_iot_mqtt_internal_write_char((uchar **)&header,auStack24[0]);
      sVar2 = aws_iot_mqtt_internal_write_len_to_buffer(_header,0);
      *(uchar **)pSerializedLength = _header + (sVar2 - (int)pTxBuf);
    }
  }
  return IVar1;
}



size_t format_int(char *q,size_t n,uint flags,int base,int width,int prec)

{
  char "0123456789abcdef" [17];
  char "0123456789ABCDEF" [17];
  int iVar1;
  uint uVar2;
  uint uVar3;
  char cVar4;
  uint uVar5;
  uint uVar6;
  int in_a6;
  int in_a7;
  int iVar7;
  int iVar8;
  uint uVar9;
  char *pcVar10;
  int iVar11;
  char *pcStack84;
  
  if ((width & 0x80U) == 0) {
    pcStack84 = "0123456789abcdef";
  }
  else {
    pcStack84 = "0123456789ABCDEF";
  }
  uVar9 = 0;
  if (((width & 0x40U) != 0) && (base < 0)) {
    flags = -flags;
    base = -(uint)(flags != 0) - base;
    uVar9 = 1;
  }
  iVar7 = 0;
  uVar2 = flags;
  uVar6 = base;
  while ((uVar2 | uVar6) != 0) {
    __udivdi3();
    iVar7 = iVar7 + 1;
  }
  uVar2 = width & 0x20;
  if ((uVar2 == 0) || (prec != 8)) {
LAB_23051346:
    if ((in_a7 <= iVar7) && (in_a7 = iVar7, (flags | base) == 0)) {
      in_a7 = 1;
    }
  }
  else {
    if (in_a7 <= iVar7) {
      in_a7 = iVar7 + 1;
      goto LAB_23051346;
    }
  }
  iVar7 = in_a7;
  if (((width & 8U) != 0) && (iVar7 = 4, prec != 0x10)) {
    iVar7 = 3;
  }
  iVar8 = (in_a7 + -1) / iVar7 + in_a7;
  iVar1 = (uint)((width & 0x14U | uVar9) != 0) + iVar8;
  if ((uVar2 != 0) && (prec == 0x10)) {
    iVar1 = iVar1 + 2;
  }
  uVar3 = width & 3;
  uVar6 = 0;
  if ((uVar3 == 0) && (uVar6 = uVar3, iVar1 < in_a6)) {
    uVar6 = in_a6 - iVar1;
    uVar5 = 0;
    do {
      if (uVar5 < n) {
        *q = ' ';
        q = q + 1;
      }
      uVar5 = uVar5 + 1;
      in_a6 = iVar1;
    } while (uVar5 != uVar6);
  }
  if (uVar9 == 0) {
    if ((width & 4U) == 0) {
      if ((width & 0x10U) == 0) goto LAB_230513c8;
      if (uVar6 < n) {
        *q = ' ';
        q = q + 1;
      }
    }
    else {
      if (uVar6 < n) {
        *q = '+';
        q = q + 1;
      }
    }
  }
  else {
    if (uVar6 < n) {
      *q = '-';
      q = q + 1;
    }
  }
  uVar6 = uVar6 + 1;
LAB_230513c8:
  if ((uVar2 != 0) && (prec == 0x10)) {
    if (uVar6 < n) {
      *q = '0';
      q = q + 1;
    }
    if (uVar6 + 1 < n) {
      cVar4 = 'X';
      if ((width & 0x80U) == 0) {
        cVar4 = 'x';
      }
      *q = cVar4;
      q = q + 1;
    }
    uVar6 = uVar6 + 2;
  }
  if ((uVar3 == 1) && (iVar8 < in_a6)) {
    while (iVar1 < in_a6) {
      if (uVar6 < n) {
        *q = '0';
        q = q + 1;
      }
      uVar6 = uVar6 + 1;
      in_a6 = in_a6 + -1;
    }
  }
  uVar6 = iVar8 + uVar6;
  q = q + iVar8;
  pcVar10 = q;
  uVar9 = uVar6;
  iVar11 = iVar7;
  while (0 < iVar8) {
    if (iVar11 == 0) {
      uVar9 = uVar9 - 1;
      if (uVar9 < n) {
        pcVar10[-1] = '_';
      }
      pcVar10 = pcVar10 + -1;
      iVar8 = iVar8 + -1;
      iVar11 = iVar7;
    }
    iVar11 = iVar11 + -1;
    uVar9 = uVar9 - 1;
    iVar8 = iVar8 + -1;
    if (uVar9 < n) {
      uVar2 = flags;
      __umoddi3();
      pcVar10[-1] = pcStack84[uVar2];
    }
    __udivdi3();
    pcVar10 = pcVar10 + -1;
  }
  iVar7 = in_a6 + uVar6;
  while (((width & 2U) != 0 && (iVar1 < (int)(iVar7 - uVar6)))) {
    if (uVar6 < n) {
      *q = ' ';
      q = q + 1;
    }
    uVar6 = uVar6 + 1;
  }
  return uVar6;
}



char * cvt(int ndigits,int *decpt,int *sign,char *buf,int eflag)

{
  int *piVar1;
  byte *pbVar2;
  __gcc_CMPtype _Var3;
  double *__iptr;
  SItype SVar4;
  byte *in_a5;
  byte *pbVar5;
  int in_a6;
  byte *pbVar6;
  byte *pbVar7;
  double in_fa1;
  double *pdStack80;
  double fi;
  double fj;
  
  piVar1 = (int *)0x4e;
  if (((int)sign < 0x4f) && (piVar1 = sign, (int)sign < 0)) {
    piVar1 = (int *)0x0;
  }
  _Var3 = __ledf2();
  if (_Var3 < 0) {
    *(undefined4 *)eflag = 1;
  }
  else {
    *(undefined4 *)eflag = 0;
  }
  modf(in_fa1,(double *)ndigits);
  pbVar6 = in_a5 + 0x50;
  _Var3 = __eqdf2();
  pbVar2 = pbVar6;
  pbVar5 = in_a5;
  if (_Var3 == 0) {
    _Var3 = __gedf2();
    pbVar7 = (byte *)0x0;
    if (0 < _Var3) {
      while( true ) {
        __iptr = (double *)ndigits;
        __muldf3();
        _Var3 = __ledf2();
        if (-1 < _Var3) break;
        pbVar7 = pbVar7 + -1;
        ndigits = (int)__iptr;
      }
    }
  }
  else {
    while( true ) {
      _Var3 = __eqdf2();
      pbVar7 = pbVar6 + -(int)pbVar2;
      if (_Var3 == 0) break;
      __iptr = pdStack80;
      __divdf3();
      modf(in_fa1,__iptr);
      __adddf3();
      __muldf3();
      SVar4 = __fixdfsi();
      pbVar2[-1] = (char)SVar4 + 0x30;
      pbVar2 = pbVar2 + -1;
    }
    while (pbVar2 < pbVar6) {
      *pbVar5 = *pbVar2;
      pbVar5 = pbVar5 + 1;
      pbVar2 = pbVar2 + 1;
    }
  }
  pbVar2 = (byte *)((int)piVar1 + (int)in_a5);
  if (in_a6 == 0) {
    pbVar2 = pbVar2 + (int)pbVar7;
  }
  *(byte **)buf = pbVar7;
  if (pbVar2 < in_a5) {
    *in_a5 = 0;
  }
  else {
    while ((pbVar5 <= pbVar2 && (pbVar5 < pbVar6))) {
      __muldf3();
      modf(in_fa1,(double *)ndigits);
      SVar4 = __fixdfsi();
      *pbVar5 = (char)SVar4 + 0x30;
      pbVar5 = pbVar5 + 1;
    }
    if (pbVar2 < pbVar6) {
      *pbVar2 = *pbVar2 + 5;
      pbVar5 = pbVar2;
      while (0x39 < *pbVar5) {
        *pbVar5 = 0x30;
        if (in_a5 < pbVar5) {
          pbVar6 = pbVar5 + -1;
          pbVar5 = pbVar5 + -1;
          *pbVar5 = *pbVar6 + 1;
        }
        else {
          *pbVar5 = 0x31;
          *(int *)buf = *(int *)buf + 1;
          if (in_a6 == 0) {
            if (in_a5 < pbVar2) {
              *pbVar2 = 0x30;
            }
            pbVar2 = pbVar2 + 1;
          }
        }
      }
      *pbVar2 = 0;
    }
    else {
      in_a5[0x4f] = 0;
    }
  }
  return (char *)in_a5;
}



char * ecvtbuf(int ndigits,int *decpt,int *sign,char *buf)

{
  char *pcVar1;
  int in_a4;
  
  pcVar1 = cvt(ndigits,decpt,sign,buf,in_a4);
  return pcVar1;
}



char * fcvtbuf(int ndigits,int *decpt,int *sign,char *buf)

{
  char *pcVar1;
  int in_a4;
  
  pcVar1 = cvt(ndigits,decpt,sign,buf,in_a4);
  return pcVar1;
}



char * flt(char *str,int size,int precision,char fmt,int flags)

{
  bool bVar1;
  byte bVar2;
  int iVar3;
  __gcc_CMPtype _Var4;
  char *pcVar5;
  undefined *puVar6;
  size_t sVar7;
  int *sign_00;
  undefined3 in_register_00002035;
  char *pcVar8;
  int *piVar9;
  uint uVar10;
  int *__string;
  char cVar11;
  uint in_a5;
  uint uVar12;
  char *pcVar13;
  int iVar14;
  uint in_a6;
  char cVar15;
  char cVar16;
  char *pcVar17;
  char *pcStack232;
  int decpt;
  int sign;
  char tmp [80];
  char cvtbuf [80];
  
  iVar3 = CONCAT31(in_register_00002035,fmt);
  uVar12 = in_a6 & 0x10;
  if (uVar12 == 0) {
    cVar16 = '0';
    if ((in_a6 & 1) == 0) {
      cVar16 = ' ';
    }
  }
  else {
    in_a6 = in_a6 & 0xfffffffe;
    cVar16 = ' ';
  }
  cVar15 = '\0';
  if ((in_a6 & 2) != 0) {
    _Var4 = __ledf2();
    if (_Var4 < 0) {
      precision = precision ^ 0x80000000;
      iVar3 = iVar3 + -1;
      cVar15 = '-';
    }
    else {
      if ((in_a6 & 4) == 0) {
        if ((in_a6 & 8) != 0) {
          iVar3 = iVar3 + -1;
          cVar15 = ' ';
        }
      }
      else {
        iVar3 = iVar3 + -1;
        cVar15 = '+';
      }
    }
  }
  if (flags < 0) {
    flags = 6;
  }
  bVar1 = (in_a5 & 0xfd) != 0x45;
  uVar10 = in_a5;
  if (!bVar1) {
    uVar10 = in_a5 + 0x20 & 0xff;
  }
  if (uVar10 == 0x67) {
    ecvtbuf(size,(int *)precision,(int *)flags,(char *)&pcStack232);
    if ((-5 < (int)(pcStack232 + -1)) && ((int)(pcStack232 + -1) < flags)) {
      sign_00 = (int *)(flags - (int)pcStack232);
LAB_23051924:
      pcVar5 = fcvtbuf(size,(int *)precision,sign_00,(char *)&pcStack232);
      __string = &sign;
      if (decpt != 0) {
        sign._0_1_ = 0x2d;
        __string = (int *)((int)&sign + 1);
      }
      if (*pcVar5 == '\0') {
        *(char *)__string = '0';
        if ((int)sign_00 < 1) {
          __string = (int *)((int)__string + 1);
        }
        else {
          *(char *)((int)__string + 1) = '.';
          pcVar5 = (char *)((int)__string + 2);
          piVar9 = (int *)((int)__string + (int)sign_00);
          do {
            *(char *)((int)__string + 2) = '0';
            __string = (int *)((int)__string + 1);
          } while (piVar9 != __string);
          __string = (int *)(pcVar5 + (int)sign_00);
        }
      }
      else {
        pcVar17 = pcVar5;
        if ((int)pcStack232 < 1) {
          *(char *)__string = '0';
          *(char *)((int)__string + 1) = '.';
          sign_00 = __string;
          while ((int *)((int)__string - (int)pcStack232) != sign_00) {
            *(char *)((int)sign_00 + 2) = '0';
            sign_00 = (int *)((int)sign_00 + 1);
          }
          __string = (int *)((int)__string + (2 - (int)pcStack232));
          while (cVar11 = *pcVar5, cVar11 != '\0') {
            pcVar5 = pcVar5 + 1;
            *(char *)__string = cVar11;
            __string = (int *)((int)__string + 1);
          }
        }
        else {
          do {
            sign_00 = __string;
            if (pcStack232 == pcVar17 + -(int)pcVar5) {
              sign_00 = (int *)((int)__string + 1);
              *(char *)__string = '.';
            }
            pcVar8 = pcVar17 + 1;
            __string = (int *)((int)sign_00 + 1);
            *(char *)sign_00 = *pcVar17;
            pcVar17 = pcVar8;
          } while (*pcVar8 != '\0');
        }
      }
      goto LAB_230518cc;
    }
    __string = (int *)(flags + -1);
  }
  else {
    __string = (int *)flags;
    if (uVar10 != 0x65) {
      __string = &sign;
      sign_00 = (int *)flags;
      if (uVar10 != 0x66) goto LAB_230518cc;
      goto LAB_23051924;
    }
  }
  pcVar5 = ecvtbuf(size,(int *)precision,(int *)((int)__string + 1),(char *)&pcStack232);
  sign_00 = &sign;
  if (decpt != 0) {
    sign._0_1_ = 0x2d;
    sign_00 = (int *)((int)&sign + 1);
  }
  pcVar17 = (char *)((int)sign_00 + 1);
  *(char *)sign_00 = *pcVar5;
  if (0 < (int)__string) {
    pcVar17 = (char *)((int)sign_00 + 2);
    *(undefined *)((int)sign_00 + 1) = 0x2e;
  }
  pcVar8 = pcVar5 + 1;
  pcVar13 = pcVar17;
  while (pcVar5 + 1 + (int)__string != pcVar8) {
    *pcVar13 = *pcVar8;
    pcVar8 = pcVar8 + 1;
    pcVar13 = pcVar13 + 1;
  }
  pcVar17 = pcVar17 + (int)__string;
  cVar11 = 'E';
  if (bVar1) {
    cVar11 = 'e';
  }
  *pcVar17 = cVar11;
  if (pcStack232 == (char *)0x0) {
    _Var4 = __eqdf2();
    if (_Var4 != 0) {
      pcStack232 = (char *)0xffffffff;
      goto LAB_2305188a;
    }
LAB_230519b0:
    cVar11 = '+';
  }
  else {
    pcStack232 = pcStack232 + -1;
    if (-1 < (int)pcStack232) goto LAB_230519b0;
LAB_2305188a:
    pcStack232 = (char *)-(int)pcStack232;
    cVar11 = '-';
  }
  pcVar17[1] = cVar11;
  pcVar17[4] = (char)((int)pcStack232 % 10) + '0';
  pcVar17[2] = (char)(((int)pcStack232 / 100) % 10) + '0';
  pcVar17[3] = (char)(((int)pcStack232 / 10) % 10) + '0';
  __string = (int *)(pcVar17 + 5);
LAB_230518cc:
  *(char *)__string = '\0';
  if ((in_a6 & 0x20) == 0) {
    if (in_a5 == 0x67) {
      __string = &sign;
      do {
        bVar2 = *(byte *)__string;
        __string = (int *)((int)__string + 1);
        if (bVar2 == 0) goto LAB_23051a64;
      } while (bVar2 != 0x2e);
      while ((sign_00 = __string, *(byte *)__string != 0 && ((*(byte *)__string & 0xdf) != 0x45))) {
        __string = (int *)((int)__string + 1);
      }
      do {
        piVar9 = sign_00;
        sign_00 = (int *)((int)piVar9 + -1);
      } while (*(byte *)sign_00 == 0x30);
      if (*(byte *)sign_00 == 0x2e) {
        sign_00 = (int *)((int)piVar9 + -2);
      }
      while (__string != sign_00) {
        sign_00 = (int *)((int)sign_00 + 1);
        *(byte *)sign_00 = 0;
      }
    }
  }
  else {
    if ((int *)flags == (int *)0x0) {
      __string = &sign;
      while (bVar2 = *(byte *)__string, bVar2 != 0) {
        if (bVar2 == 0x2e) goto LAB_23051a64;
        if ((bVar2 & 0xdf) == 0x45) {
          sVar7 = strnlen((char *)__string,0x100);
          puVar6 = (undefined *)(sVar7 + (int)__string);
          while (0 < (int)(puVar6 + -(int)__string)) {
            puVar6[1] = *puVar6;
            puVar6 = puVar6 + -1;
          }
          *(byte *)__string = 0x2e;
          goto LAB_23051a64;
        }
        __string = (int *)((int)__string + 1);
      }
      *(byte *)__string = 0x2e;
      *(byte *)((int)__string + 1) = 0;
    }
  }
LAB_23051a64:
  sVar7 = strnlen((char *)&sign,0x100);
  iVar3 = iVar3 - sVar7;
  pcVar5 = str;
  if ((in_a6 & 0x11) == 0) {
    while (0 < (int)(str + (iVar3 - (int)pcVar5))) {
      *pcVar5 = ' ';
      pcVar5 = pcVar5 + 1;
    }
    iVar14 = iVar3;
    if (iVar3 < 0) {
      iVar14 = 0;
    }
    str = str + iVar14;
    iVar3 = (iVar3 + -1) - iVar14;
  }
  if (cVar15 != '\0') {
    *str = cVar15;
    str = str + 1;
  }
  pcVar5 = str;
  if (uVar12 == 0) {
    while (0 < (int)(str + (iVar3 - (int)pcVar5))) {
      *pcVar5 = cVar16;
      pcVar5 = pcVar5 + 1;
    }
    iVar14 = iVar3;
    if (iVar3 < 0) {
      iVar14 = 0;
    }
    str = str + iVar14;
    iVar3 = (iVar3 + -1) - iVar14;
  }
  iVar14 = 0;
  while (iVar14 < (int)sVar7) {
    pcVar5 = (char *)((int)&sign + iVar14);
    pcVar17 = str + iVar14;
    iVar14 = iVar14 + 1;
    *pcVar17 = *pcVar5;
  }
  if ((int)sVar7 < 0) {
    sVar7 = 0;
  }
  str = str + sVar7;
  pcVar5 = str;
  while (0 < (int)(str + (iVar3 - (int)pcVar5))) {
    *pcVar5 = ' ';
    pcVar5 = pcVar5 + 1;
  }
  if (iVar3 < 0) {
    iVar3 = 0;
  }
  return str + iVar3;
}



int vsnprintf(char *__s,size_t __maxlen,char *__format,__gnuc_va_list __arg)

{
  char *pcVar1;
  size_t n;
  byte *pbVar2;
  int *piVar3;
  undefined4 uVar4;
  char *pcVar5;
  byte bVar6;
  uint uVar7;
  char **ppcVar8;
  int prec;
  char *pcVar9;
  char *pcVar10;
  int iVar11;
  uint width;
  char *flags;
  byte *str;
  char *pcVar12;
  char *pcStack104;
  char *pcStack100;
  char *pcStack88;
  char acStack65 [4];
  char carg;
  
  uVar4 = 0;
  width = 0;
  flags = (char *)0xffffffff;
  iVar11 = 0;
  pcStack104 = (char *)0x0;
  pcStack100 = (char *)0x0;
  pcVar5 = (char *)0x0;
  str = (byte *)__s;
  pcVar12 = (char *)0x0;
switchD_23051c14_caseD_5:
  do {
    pbVar2 = (byte *)__format;
    __format = (char *)(pbVar2 + 1);
    bVar6 = *pbVar2;
    uVar7 = (uint)bVar6;
    if (bVar6 == 0) {
      if (pcVar5 < __maxlen) {
        *str = 0;
      }
      else {
        if (__maxlen != 0) {
          __s[__maxlen - 1] = '\0';
        }
      }
      return (int)pcVar5;
    }
    switch(uVar4) {
    case 0:
      if (bVar6 == 0x25) {
        uVar4 = 1;
        width = 0;
        flags = (char *)0xffffffff;
        iVar11 = 0;
        pcVar12 = (char *)0x0;
      }
      else {
        if (pcVar5 < __maxlen) {
          *str = bVar6;
          str = str + 1;
        }
        pcVar5 = pcVar5 + 1;
      }
      break;
    case 1:
      switch(uVar7 - 0x20 & 0xff) {
      case 0:
        width = width | 0x10;
        break;
      default:
        uVar4 = 2;
        __format = (char *)pbVar2;
        break;
      case 3:
        width = width | 0x20;
        break;
      case 7:
        width = width | 8;
        break;
      case 0xb:
        width = width | 4;
        break;
      case 0xd:
        width = width | 2;
        break;
      case 0x10:
        width = width | 1;
      }
      break;
    case 2:
      if ((uVar7 - 0x30 & 0xff) < 10) {
        pcVar12 = (char *)((int)pcVar12 * 10 + (uVar7 - 0x30));
      }
      else {
        if (bVar6 == 0x2a) {
          ppcVar8 = (char **)__arg + 1;
          pcVar12 = *(char **)__arg;
          __arg = ppcVar8;
          if ((int)pcVar12 < 0) {
            width = width | 2;
            pcVar12 = (char *)-(int)pcVar12;
          }
        }
        else {
          if (bVar6 == 0x2e) {
            uVar4 = 3;
            flags = (char *)0x0;
          }
          else {
            uVar4 = 4;
            __format = (char *)pbVar2;
          }
        }
      }
      break;
    case 3:
      if ((uVar7 - 0x30 & 0xff) < 10) {
        flags = (char *)((int)flags * 10 + (uVar7 - 0x30));
      }
      else {
        if (bVar6 == 0x2a) {
          ppcVar8 = (char **)__arg + 1;
          flags = *(char **)__arg;
          __arg = ppcVar8;
          if ((int)flags < 0) {
            flags = (char *)0xffffffff;
          }
        }
        else {
          uVar4 = 4;
          __format = (char *)pbVar2;
        }
      }
      break;
    case 4:
      switch(uVar7 - 0x4c & 0xff) {
      case 0:
      case 0x25:
        iVar11 = iVar11 + 2;
        break;
      default:
        if (2 < iVar11) {
          iVar11 = 2;
        }
        if (iVar11 < -2) {
          iVar11 = -2;
        }
        switch(uVar7 - 0x50 & 0xff) {
        case 0:
          width = width | 0x80;
          goto switchD_23051d70_caseD_20;
        default:
          if (pcVar5 < __maxlen) {
            *str = bVar6;
            str = str + 1;
          }
          uVar4 = 0;
          pcVar5 = pcVar5 + 1;
          goto switchD_23051c14_caseD_5;
        case 8:
          width = width | 0x80;
          prec = 0x10;
          break;
        case 0x13:
          acStack65[0] = (char)*(char **)__arg;
          pcVar1 = (char *)0x1;
          pcStack88 = acStack65;
          goto is_string;
        case 0x14:
        case 0x19:
          width = width | 0x40;
                    // WARNING: Could not find normalized switch variable to match jumptable
          switch(iVar11) {
          case -2:
            pcStack104 = (char *)(int)*(char *)__arg;
            pcStack100 = (char *)((int)pcStack104 >> 0x1f);
            __arg = (char **)__arg + 1;
            prec = 10;
            break;
          case 0:
            pcStack104 = *(char **)__arg;
            pcStack100 = (char *)((int)pcStack104 >> 0x1f);
            __arg = (char **)__arg + 1;
            prec = 10;
            break;
          case 2:
            ppcVar8 = (char **)((int)__arg + 7U & 0xfffffff8);
            __arg = ppcVar8 + 2;
            pcStack104 = *ppcVar8;
            pcStack100 = ppcVar8[1];
            prec = 10;
            break;
          default:
            prec = 10;
          }
          goto is_integer;
        case 0x16:
          piVar3 = (int *)((int)__arg + 7U & 0xfffffff8);
          str = (byte *)flt((char *)str,*piVar3,piVar3[1],(char)pcVar12,(int)flags);
          uVar4 = 0;
          __arg = piVar3 + 2;
          goto switchD_23051c14_caseD_5;
        case 0x1e:
          if (iVar11 + 2U < 5) {
                    // WARNING: Could not recover jumptable at 0x23051f80. Too many branches
                    // WARNING: Treating indirect jump as call
            iVar11 = (*(code *)(&PTR_LAB_230885a4)[iVar11 + 2U])((&PTR_LAB_230885a4)[iVar11 + 2U]);
            return iVar11;
          }
          uVar4 = 0;
          goto switchD_23051c14_caseD_5;
        case 0x1f:
          prec = 8;
          break;
        case 0x20:
switchD_23051d70_caseD_20:
          width = width | 0x20;
          pcStack104 = *(char **)__arg;
          pcStack100 = (char *)0x0;
          __arg = (char **)__arg + 1;
          prec = 0x10;
          flags = &DAT_00000008;
          goto is_integer;
        case 0x23:
          pcStack88 = *(char **)__arg;
          if (pcStack88 == (char *)0x0) {
            pcStack88 = "(null)";
          }
          pcVar1 = (char *)strlen(pcStack88);
is_string:
          __arg = (char **)__arg + 1;
          if ((flags != (char *)0xffffffff) && ((int)flags < (int)pcVar1)) {
            pcVar1 = flags;
          }
          pcVar9 = pcVar5;
          if (((int)pcVar1 < (int)pcVar12) && ((width & 2) == 0)) {
            if ((width & 1) == 0) {
              bVar6 = 0x20;
            }
            else {
              bVar6 = 0x30;
            }
            pcVar9 = pcVar12 + (int)(pcVar5 + -(int)pcVar1);
            do {
              if (pcVar5 < __maxlen) {
                *str = bVar6;
                str = str + 1;
              }
              pcVar5 = pcVar5 + 1;
              pcVar12 = pcVar1;
            } while (pcVar5 != pcVar9);
          }
          pcVar5 = pcVar9;
          if (pcVar1 != (char *)0x0) {
            pcVar10 = pcVar9;
            do {
              if (pcVar10 < __maxlen) {
                *str = pcStack88[(int)(pcVar10 + -(int)pcVar9)];
                str = str + 1;
              }
              pcVar10 = pcVar10 + 1;
              pcVar5 = pcVar1 + (int)pcVar9;
            } while (pcVar10 != pcVar1 + (int)pcVar9);
          }
          if ((int)pcVar1 < (int)pcVar12) {
            if ((width & 2) == 0) {
              uVar4 = 0;
            }
            else {
              pcVar9 = pcVar5 + -(int)pcVar1;
              do {
                if (pcVar5 < __maxlen) {
                  *str = 0x20;
                  str = str + 1;
                }
                pcVar5 = pcVar5 + 1;
              } while (pcVar5 != pcVar12 + (int)pcVar9);
              uVar4 = 0;
              pcVar5 = pcVar12 + (int)pcVar9;
              pcVar12 = pcVar1;
            }
          }
          else {
            uVar4 = 0;
          }
          goto switchD_23051c14_caseD_5;
        case 0x25:
          prec = 10;
          break;
        case 0x28:
          prec = 0x10;
        }
                    // WARNING: Could not find normalized switch variable to match jumptable
        switch(iVar11) {
        case -2:
          pcStack104 = (char *)(uint)*(byte *)__arg;
          pcStack100 = (char *)0x0;
          __arg = (char **)__arg + 1;
          break;
        case 0:
          pcStack104 = *(char **)__arg;
          pcStack100 = (char *)0x0;
          __arg = (char **)__arg + 1;
          break;
        case 2:
          ppcVar8 = (char **)((int)__arg + 7U & 0xfffffff8);
          __arg = ppcVar8 + 2;
          pcStack104 = *ppcVar8;
          pcStack100 = ppcVar8[1];
        }
is_integer:
        if (pcVar5 < __maxlen) {
          n = __maxlen - (int)pcVar5;
        }
        else {
          n = 0;
        }
        n = format_int((char *)str,n,(uint)pcStack104,(int)pcStack100,width,prec);
        str = str + n;
        uVar4 = 0;
        pcVar5 = pcVar5 + n;
        break;
      case 0x1c:
        iVar11 = iVar11 + -1;
        break;
      case 0x1e:
        iVar11 = 2;
        break;
      case 0x20:
        iVar11 = iVar11 + 1;
        break;
      case 0x28:
      case 0x2e:
        iVar11 = 1;
      }
    }
  } while( true );
}



int vsprintf(char *__s,char *__format,__gnuc_va_list __arg)

{
  int iVar1;
  
  iVar1 = vsnprintf(__s,0x1e0,__format,__arg);
  return iVar1;
}



void vprint(char *fmt,va_list argp)

{
  uint8_t *puVar1;
  int iVar2;
  
  if (sys_log_all_enable == false) {
    return;
  }
  iVar2 = vsprintf(string,fmt,argp);
  puVar1 = (uint8_t *)string;
  if (0 < iVar2) {
    while( true ) {
      if (*puVar1 == '\0') break;
      bl_uart_data_send('\0',*puVar1);
      puVar1 = puVar1 + 1;
    }
  }
  return;
}



int bl_putchar(int c)

{
  bl_uart_data_send('\0',(uint8_t)c);
  return 0;
}



int puts(char *__s)

{
  int iVar1;
  
  iVar1 = 0;
  if (sys_log_all_enable != false) {
    iVar1 = 0;
    while (__s[iVar1] != '\0') {
      bl_uart_data_send('\0',__s[iVar1]);
      iVar1 = iVar1 + 1;
    }
  }
  return iVar1;
}



int printf(char *__format,...)

{
  undefined4 in_a1;
  undefined4 in_a2;
  undefined4 in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list argp;
  undefined4 uStack28;
  undefined4 uStack24;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  undefined4 uStack8;
  undefined4 uStack4;
  
  if (sys_log_all_enable != false) {
    uStack28 = in_a1;
    uStack24 = in_a2;
    uStack20 = in_a3;
    uStack16 = in_a4;
    uStack12 = in_a5;
    uStack8 = in_a6;
    uStack4 = in_a7;
    vprint(__format,&uStack28);
  }
  return 0;
}



int sprintf(char *__s,char *__format,...)

{
  int iVar1;
  undefined4 in_a2;
  undefined4 in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list ap;
  undefined4 uStack24;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  undefined4 uStack8;
  undefined4 uStack4;
  
  uStack24 = in_a2;
  uStack20 = in_a3;
  uStack16 = in_a4;
  uStack12 = in_a5;
  uStack8 = in_a6;
  uStack4 = in_a7;
  iVar1 = vsnprintf(__s,0xffffffff,__format,&uStack24);
  return iVar1;
}



int snprintf(char *__s,size_t __maxlen,char *__format,...)

{
  int iVar1;
  undefined4 in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list ap;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  undefined4 uStack8;
  undefined4 uStack4;
  
  uStack20 = in_a3;
  uStack16 = in_a4;
  uStack12 = in_a5;
  uStack8 = in_a6;
  uStack4 = in_a7;
  iVar1 = vsnprintf(__s,__maxlen,__format,&uStack20);
  return iVar1;
}



int sscanf(char *__s,char *__format,...)

{
  int iVar1;
  undefined4 in_a2;
  undefined4 in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list ap;
  undefined4 uStack24;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  undefined4 uStack8;
  undefined4 uStack4;
  
  uStack24 = in_a2;
  uStack20 = in_a3;
  uStack16 = in_a4;
  uStack12 = in_a5;
  uStack8 = in_a6;
  uStack4 = in_a7;
  iVar1 = vsscanf(__s,__format,&uStack24);
  return iVar1;
}



void set_bit(ulong *bitmap,uint bit)

{
  bitmap[bit >> 5] = bitmap[bit >> 5] | 1 << (bit & 0x1f);
  return;
}



int vsscanf(char *__s,char *__format,__gnuc_va_list __arg)

{
  byte bVar1;
  bool bVar2;
  bool bVar3;
  size_t sVar4;
  uint uVar5;
  uint bit;
  byte *pbVar6;
  int base;
  uint uVar7;
  byte **endptr;
  byte **ppbVar8;
  uint bit_00;
  int iVar9;
  byte *nptr;
  byte *pbVar10;
  size_t n;
  byte *pbVar11;
  int iVar12;
  uint uVar13;
  uint uStack132;
  uint uStack128;
  byte *pbStack100;
  char *qq;
  ulong matchmap [8];
  
  uStack128 = 0;
  uStack132 = 0;
  iVar12 = 0;
  pbVar11 = (byte *)0x0;
  bVar2 = false;
  bVar3 = false;
  iVar9 = 0;
  uVar5 = 0;
  pbVar10 = (byte *)__s;
  n = 0xffffffff;
  uVar13 = 0;
switchD_23052248_caseD_7:
  nptr = pbVar10;
  pbVar6 = (byte *)__format;
  uVar7 = uVar5;
  bVar1 = *pbVar6;
  bit = (uint)bVar1;
  __format = (char *)(pbVar6 + 1);
  if ((bVar1 == 0) || (uVar13 != 0)) {
    if ((uVar13 == 1) && (iVar12 == 0)) {
      iVar12 = -1;
    }
    return iVar12;
  }
  uVar5 = uVar7;
  pbVar10 = nptr;
  switch(uVar7) {
  case 0:
    if (bVar1 == 0x25) {
      bVar2 = false;
      bVar3 = false;
      iVar9 = 0;
      uVar5 = 1;
      n = 0xffffffff;
      uVar13 = uVar7;
      goto switchD_23052248_caseD_7;
    }
    uVar5 = (uint)(byte)_ctype_[bit + 1] & 8;
    if ((_ctype_[bit + 1] & 8) == 0) {
      uVar13 = 2;
      if ((uint)*nptr != bit) goto switchD_23052248_caseD_7;
      nptr = nptr + 1;
    }
    else {
      while (uVar5 = (uint)(byte)_ctype_[(uint)*nptr + 1] & 8, (_ctype_[(uint)*nptr + 1] & 8) != 0)
      {
        nptr = nptr + 1;
      }
    }
    pbVar10 = nptr;
    uVar13 = 0;
    goto switchD_23052248_caseD_7;
  case 1:
    if (bVar1 == 0x2a) {
      bVar3 = true;
      goto switchD_23052248_caseD_7;
    }
    if ((0x29 < bVar1) && ((bit - 0x30 & 0xff) < 10)) {
      bVar2 = true;
      uVar5 = 2;
      n = bit - 0x30;
      goto switchD_23052248_caseD_7;
    }
    break;
  case 2:
    if ((bit - 0x30 & 0xff) < 10) {
      n = n * 10 + -0x30 + bit;
      goto switchD_23052248_caseD_7;
    }
    break;
  case 3:
    if (bVar1 == 0x6c) {
      iVar9 = iVar9 + 1;
    }
    else {
      if (0x6c < bVar1) {
        if ((bVar1 == 0x74) || (bVar1 == 0x7a)) {
          iVar9 = 1;
          goto switchD_23052248_caseD_7;
        }
        uVar7 = 0x71;
LAB_230522f0:
        if (bit == uVar7) goto LAB_230522f4;
        if (2 < iVar9) {
          iVar9 = 2;
        }
        if (iVar9 < -2) {
          iVar9 = -2;
        }
        if (bVar1 == 0x69) {
          base = 0;
LAB_230523aa:
          while( true ) {
            uVar7 = (uint)*nptr;
            if ((_ctype_[uVar7 + 1] & 8) == 0) break;
            nptr = nptr + 1;
          }
          pbVar10 = nptr;
          if (*nptr == 0) goto LAB_230525ca;
          endptr = &pbStack100;
          pbVar6 = nptr;
          strntoumax((char *)nptr,(char **)endptr,base,n);
          if (pbStack100 == nptr) goto LAB_2305234e;
          nptr = pbStack100;
          if (!bVar3) {
            iVar12 = iVar12 + 1;
          }
set_integer:
          uVar5 = 0;
          pbVar10 = nptr;
          if (!bVar3) {
            if (iVar9 == 0) {
              endptr = *(byte ***)__arg;
              __arg = (byte **)__arg + 1;
              *endptr = pbVar6;
LAB_230524ba:
              uVar5 = 0;
              pbVar10 = nptr;
              goto switchD_23052248_caseD_7;
            }
            if (iVar9 < 1) {
              if (iVar9 == -2) {
                **(byte **)__arg = (byte)pbVar6;
              }
              else {
                if (iVar9 != -1) goto switchD_23052248_caseD_7;
                **(undefined2 **)__arg = (short)pbVar6;
              }
            }
            else {
              if (iVar9 == 2) {
                ppbVar8 = *(byte ***)__arg;
                *ppbVar8 = pbVar6;
                *(byte ***)(ppbVar8 + 1) = endptr;
              }
              else {
                if ((1 < iVar9) && (iVar9 != 0x7fffffff)) goto switchD_23052248_caseD_7;
                **(byte ***)__arg = pbVar6;
              }
            }
            __arg = (byte **)__arg + 1;
          }
          goto switchD_23052248_caseD_7;
        }
        if (bVar1 < 0x6a) {
          if (bVar1 == 0x58) {
scan_int:
            base = 0x10;
            goto LAB_230523aa;
          }
          if (0x58 < bVar1) {
            if (bVar1 == 99) {
              if (!bVar2) {
                n = 1;
              }
              sVar4 = n - 1;
              if (!bVar3) {
                pbVar11 = *(byte **)__arg;
                __arg = (byte **)__arg + 1;
                n = n - 1;
                while (n != 0xffffffff) {
                  bVar1 = *nptr;
                  uVar7 = (uint)bVar1;
                  pbVar10 = nptr;
                  if (bVar1 == 0) goto LAB_230525ca;
                  nptr = nptr + 1;
                  *pbVar11 = bVar1;
                  n = n - 1;
                  pbVar11 = pbVar11 + 1;
                }
                iVar12 = iVar12 + 1;
                goto LAB_230524ba;
              }
              do {
                n = sVar4;
                if (n == 0xffffffff) goto LAB_230524ba;
                uVar7 = (uint)*nptr;
                sVar4 = n - 1;
              } while (*nptr != 0);
              goto LAB_230525ca;
            }
            if (bVar1 == 100) goto LAB_2305247c;
            if (bVar1 != 0x5b) goto LAB_2305234e;
            pbVar11 = (byte *)0x0;
            if (!bVar3) {
              pbVar11 = *(byte **)__arg;
              __arg = (byte **)__arg + 1;
            }
            memset(&qq,0,0x20);
            uStack132 = 0;
            uVar5 = 4;
            goto switchD_23052248_caseD_7;
          }
          if (bVar1 == 0x25) {
            if ((uint)*nptr == bit) {
              nptr = nptr + 1;
              goto LAB_230524ba;
            }
          }
          else {
            if (bVar1 == 0x50) goto LAB_23052470;
          }
        }
        else {
          if (bVar1 == 0x70) {
LAB_23052470:
            base = 0;
            iVar9 = 0x7fffffff;
            goto LAB_230523aa;
          }
          if (bVar1 < 0x71) {
            if (bVar1 == 0x6e) {
              pbVar6 = nptr + -(int)__s;
              endptr = (byte **)((int)pbVar6 >> 0x1f);
              goto set_integer;
            }
            base = 8;
            if (bVar1 == 0x6f) goto LAB_230523aa;
          }
          else {
            if (bVar1 == 0x75) {
LAB_2305247c:
              base = 10;
              goto LAB_230523aa;
            }
            if (bVar1 == 0x78) goto scan_int;
            if (bVar1 == 0x73) {
              n = n - 1;
              if (bVar3) {
                while (n != 0xffffffff) {
                  uVar7 = (uint)*nptr;
                  pbVar10 = nptr;
                  if (*nptr == 0) goto LAB_230525ca;
                  if ((_ctype_[uVar7 + 1] & 8) != 0) break;
                  nptr = nptr + 1;
                  n = n - 1;
                }
                goto LAB_230524ba;
              }
              pbVar11 = *(byte **)__arg;
              __arg = (byte **)__arg + 1;
              uVar13 = 1;
              pbVar10 = pbVar11;
              while (n != 0xffffffff) {
                bVar1 = *nptr;
                uVar13 = (uint)bVar1;
                if ((bVar1 == 0) || ((_ctype_[uVar13 + 1] & 8) != 0)) break;
                *pbVar10 = bVar1;
                nptr = nptr + 1;
                pbVar10 = pbVar10 + 1;
                n = n - 1;
              }
              if (pbVar10 != pbVar11) {
                *pbVar10 = 0;
                iVar12 = iVar12 + 1;
              }
              uVar13 = (uint)(uVar13 == 0);
              uVar5 = 0;
              pbVar10 = nptr;
              goto switchD_23052248_caseD_7;
            }
          }
        }
LAB_2305234e:
        uVar13 = 2;
        uVar5 = 0;
        pbVar10 = nptr;
        goto switchD_23052248_caseD_7;
      }
      if (bVar1 == 0x68) {
        iVar9 = iVar9 + -1;
      }
      else {
        if (bVar1 != 0x6a) {
          uVar7 = 0x4c;
          goto LAB_230522f0;
        }
LAB_230522f4:
        iVar9 = 2;
      }
    }
    goto switchD_23052248_caseD_7;
  case 4:
    if (bVar1 != 0x5e) {
      set_bit((ulong *)&qq,bit);
      goto LAB_2305255e;
    }
    uStack132 = 1;
    goto switchD_23052248_caseD_7;
  case 5:
    if (bVar1 == 0x5d) {
match_run:
      bit = 1;
      while (n != 0) {
        bVar1 = *pbVar10;
        bit = (uint)bVar1;
        if ((bVar1 == 0) || (uStack132 == ((uint)(&qq)[bVar1 >> 5] >> (bit & 0x1f) & 1))) break;
        if (pbVar11 != (byte *)0x0) {
          *pbVar11 = bVar1;
          pbVar11 = pbVar11 + 1;
        }
        pbVar10 = pbVar10 + 1;
      }
      if ((nptr == pbVar10) || (pbVar11 == (byte *)0x0)) {
        uVar13 = 2;
      }
      else {
        *pbVar11 = 0;
        iVar12 = iVar12 + 1;
      }
      pbStack100 = nptr;
      if (bit == 0) {
LAB_230525ca:
        uVar13 = 1;
        uVar5 = uVar7;
      }
    }
    else {
      if (bVar1 == 0x2d) {
        uStack128 = 0x2d;
        uVar5 = 6;
      }
      else {
        set_bit((ulong *)&qq,bit);
      }
    }
    goto switchD_23052248_caseD_7;
  case 6:
    bit_00 = uStack128;
    if (bVar1 == 0x5d) goto match_run;
    while ((int)bit_00 < (int)bit) {
      set_bit((ulong *)&qq,bit_00);
      bit_00 = bit_00 + 1;
    }
LAB_2305255e:
    uVar5 = 5;
  default:
    goto switchD_23052248_caseD_7;
  }
  uVar5 = 3;
  __format = (char *)pbVar6;
  goto switchD_23052248_caseD_7;
}



uintmax_t strntoumax(char *nptr,char **endptr,int base,size_t n)

{
  byte *pbVar1;
  uint uVar2;
  uint uVar3;
  uintmax_t in_fa0;
  
  while (n != 0) {
    if ((_ctype_[(uint)(byte)*nptr + 1] & 8) == 0) {
      if (((uint)(byte)*nptr - 0x2b & 0xfd) == 0) {
        nptr = (char *)((byte *)nptr + 1);
        n = n - 1;
      }
      if (base != 0) {
        if ((((base == 0x10) && (1 < n)) && (*nptr == 0x30)) && ((((byte *)nptr)[1] & 0xdf) == 0x58)
           ) {
          n = n - 2;
          nptr = (char *)((byte *)nptr + 2);
        }
        goto LAB_2305267a;
      }
      if (n < 2) {
        if (n == 0) goto joined_r0x23052722;
        if (*nptr != 0x30) {
          n = 1;
          base = 10;
          goto LAB_2305267a;
        }
      }
      else {
        base = 10;
        if (*nptr != 0x30) goto LAB_2305267a;
        if ((((byte *)nptr)[1] & 0xdf) == 0x58) {
          n = n - 2;
          nptr = (char *)((byte *)nptr + 2);
          base = 0x10;
          goto LAB_2305267a;
        }
      }
      n = n - 1;
      nptr = (char *)((byte *)nptr + 1);
      base = 8;
      goto LAB_2305267a;
    }
    nptr = (char *)((byte *)nptr + 1);
    n = n - 1;
  }
  if (base != 0) {
LAB_2305267a:
    pbVar1 = (byte *)nptr + n;
    while ((byte *)nptr != pbVar1) {
      uVar3 = (uint)(byte)*nptr;
      uVar2 = uVar3 - 0x30;
      if (9 < uVar2) {
        if (uVar3 - 0x41 < 0x1a) {
          uVar2 = uVar3 - 0x37;
        }
        else {
          if (0x19 < uVar3 - 0x61) break;
          uVar2 = uVar3 - 0x57;
        }
      }
      if (((int)uVar2 < 0) || (base <= (int)uVar2)) break;
      nptr = (char *)((byte *)nptr + 1);
    }
  }
joined_r0x23052722:
  if (endptr != (char **)0x0) {
    *endptr = nptr;
  }
  return in_fa0;
}



BL_Err_Type UART_Init(UART_ID_Type uartId,UART_CFG_Type *uartCfg)

{
  UART_Parity_Type UVar1;
  undefined3 in_register_00002029;
  uint *puVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  
  puVar2 = (uint *)uartAddr[CONCAT31(in_register_00002029,uartId)];
  uVar5 = uartCfg->uartClk / uartCfg->baudRate;
  if (4 < ((uartCfg->uartClk * 10) / uartCfg->baudRate) % 10) {
    uVar5 = uVar5 + 1;
  }
  puVar2[2] = uVar5 - 1 & 0xffff | (uVar5 - 1) * 0x10000;
  UVar1 = uartCfg->parity;
  uVar5 = *puVar2;
  uVar6 = puVar2[1];
  if (UVar1 == UART_PARITY_ODD) {
    uVar5 = uVar5 | 0x30;
    uVar6 = uVar6 | 0x30;
  }
  else {
    if (UVar1 == UART_PARITY_NONE) {
      uVar5 = uVar5 & 0xffffffef;
      uVar6 = uVar6 & 0xffffffef;
    }
    else {
      if (UVar1 == UART_PARITY_EVEN) {
        uVar5 = uVar5 & 0xffffffdf | 0x10;
        uVar6 = uVar6 & 0xffffffdf | 0x10;
      }
    }
  }
  uVar3 = ((uint)uartCfg->dataBits + 4) * 0x100;
  uVar4 = uVar5 & 0xfffff8ff | uVar3;
  uVar3 = uVar6 & 0xfffff8ff | uVar3;
  uVar5 = ((uint)uartCfg->stopBits + 1) * 0x1000;
  uVar6 = uVar4 & 0xffffcffd | uVar5;
  if (uartCfg->ctsFlowControl == ENABLE) {
    uVar6 = uVar4 & 0xffffcfff | uVar5 | 2;
  }
  if (uartCfg->rxDeglitch == ENABLE) {
    uVar3 = uVar3 | 0x800;
  }
  else {
    uVar3 = uVar3 & 0xfffff7ff;
  }
  uVar5 = uVar3 & 0xfffffffd;
  if (uartCfg->rtsSoftwareControl == ENABLE) {
    uVar5 = uVar3 | 2;
  }
  *puVar2 = uVar6;
  puVar2[1] = uVar5;
  uVar5 = puVar2[3] & 0xfffffffe;
  if (uartCfg->byteBitInverse == UART_MSB_FIRST) {
    uVar5 = puVar2[3] | 1;
  }
  puVar2[3] = uVar5;
  return SUCCESS;
}



BL_Err_Type UART_FifoConfig(UART_ID_Type uartId,UART_FifoCfg_Type *fifoCfg)

{
  undefined3 in_register_00002029;
  uint32_t uVar1;
  uint uVar2;
  uint uVar3;
  
  uVar1 = uartAddr[CONCAT31(in_register_00002029,uartId)];
  *(uint *)(uVar1 + 0x84) =
       (((uint)fifoCfg->txFifoDmaThreshold - 1) * 0x10000 | *(uint *)(uVar1 + 0x84) & 0xffe0ffff) &
       0xe0ffffff | ((uint)fifoCfg->rxFifoDmaThreshold - 1) * 0x1000000;
  uVar3 = *(uint *)(uVar1 + 0x80) & 0xfffffffe;
  if (fifoCfg->txFifoDmaEnable == ENABLE) {
    uVar3 = *(uint *)(uVar1 + 0x80) | 1;
  }
  uVar2 = uVar3 & 0xfffffffd;
  if (fifoCfg->rxFifoDmaEnable == ENABLE) {
    uVar2 = uVar3 | 2;
  }
  *(uint *)(uVar1 + 0x80) = uVar2;
  return SUCCESS;
}



BL_Err_Type UART_Enable(UART_ID_Type uartId,UART_Direction_Type direct)

{
  undefined3 in_register_00002029;
  uint *puVar1;
  
  puVar1 = (uint *)uartAddr[CONCAT31(in_register_00002029,uartId)];
  if ((direct & ~UART_TXRX) == UART_TX) {
    *puVar1 = *puVar1 | 1;
  }
  if ((byte)(direct + ~UART_TX) < 2) {
    puVar1[1] = puVar1[1] | 1;
  }
  return SUCCESS;
}



BL_Err_Type UART_Disable(UART_ID_Type uartId,UART_Direction_Type direct)

{
  undefined3 in_register_00002029;
  uint *puVar1;
  
  puVar1 = (uint *)uartAddr[CONCAT31(in_register_00002029,uartId)];
  if ((direct & ~UART_TXRX) == UART_TX) {
    *puVar1 = *puVar1 & 0xfffffffe;
  }
  if ((byte)(direct + ~UART_TX) < 2) {
    puVar1[1] = puVar1[1] & 0xfffffffe;
  }
  return SUCCESS;
}



BL_Err_Type UART_SetRxTimeoutValue(UART_ID_Type uartId,uint8_t time)

{
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  
  *(uint *)(uartAddr[CONCAT31(in_register_00002029,uartId)] + 0x18) =
       CONCAT31(in_register_0000202d,time) - 1U |
       *(uint *)(uartAddr[CONCAT31(in_register_00002029,uartId)] + 0x18) & 0xffffff00;
  return SUCCESS;
}



BL_Err_Type UART_TxFreeRun(UART_ID_Type uartId,BL_Fun_Type txFreeRun)

{
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  uint uVar1;
  
  uVar1 = *(uint *)uartAddr[CONCAT31(in_register_00002029,uartId)];
  if (CONCAT31(in_register_0000202d,txFreeRun) == 1) {
    uVar1 = uVar1 | 4;
  }
  else {
    uVar1 = uVar1 & 0xfffffffb;
  }
  *(uint *)uartAddr[CONCAT31(in_register_00002029,uartId)] = uVar1;
  return SUCCESS;
}



BL_Err_Type UART_IntMask(UART_ID_Type uartId,UART_INT_Type intType,BL_Mask_Type intMask)

{
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  uint uVar1;
  undefined3 in_register_00002031;
  uint uVar2;
  
  uVar2 = *(uint *)(uartAddr[CONCAT31(in_register_00002029,uartId)] + 0x24);
  if (CONCAT31(in_register_0000202d,intType) == 8) {
    uVar1 = 0;
    if (CONCAT31(in_register_00002031,intMask) == 1) {
      uVar1 = uVar2 | 0xff;
    }
  }
  else {
    uVar1 = 1 << ((uint)intType & 0x1f);
    if (CONCAT31(in_register_00002031,intMask) == 1) {
      uVar1 = uVar1 | uVar2;
    }
    else {
      uVar1 = ~uVar1 & uVar2;
    }
  }
  *(uint *)(uartAddr[CONCAT31(in_register_00002029,uartId)] + 0x24) = uVar1;
  return SUCCESS;
}



uint8_t UART_GetTxFifoCount(UART_ID_Type uartId)

{
  undefined3 in_register_00002029;
  
  return (uint8_t)((byte)*(undefined4 *)(uartAddr[CONCAT31(in_register_00002029,uartId)] + 0x84) &
                  0x3f);
}



BL_Err_Type UART_SendData(UART_ID_Type uartId,uint8_t *data,uint32_t len)

{
  int iVar1;
  uint uVar2;
  uint8_t uVar3;
  undefined3 in_register_00002029;
  undefined3 extraout_var;
  uint8_t *puVar4;
  uint32_t uVar5;
  
  uVar5 = uartAddr[CONCAT31(in_register_00002029,uartId)];
  iVar1 = 160000;
  uVar2 = 0;
  do {
    while( true ) {
      if (len <= uVar2) {
        return SUCCESS;
      }
      uVar3 = UART_GetTxFifoCount(uartId);
      if (CONCAT31(extraout_var,uVar3) == 0) break;
      puVar4 = data + uVar2;
      uVar2 = uVar2 + 1;
      iVar1 = 160000;
      *(uint8_t *)(uVar5 + 0x88) = *puVar4;
    }
    iVar1 = iVar1 + -1;
  } while (iVar1 != 0);
  return TIMEOUT;
}



uint8_t UART_GetRxFifoCount(UART_ID_Type uartId)

{
  undefined3 in_register_00002029;
  
  return (uint8_t)((byte)((uint)*(undefined4 *)
                                 (uartAddr[CONCAT31(in_register_00002029,uartId)] + 0x84) >> 8) &
                  0x3f);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ADC_Reset(void)

{
  _DAT_4000f90c = _DAT_4000f90c & 0xfffffffb;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ADC_Enable(void)

{
  _DAT_4000f90c = _DAT_4000f90c | 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ADC_Disable(void)

{
  _DAT_4000f90c = _DAT_4000f90c & 0xfffffffe;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ADC_Channel_Config(ADC_Chan_Type posCh,ADC_Chan_Type negCh,BL_Fun_Type contEn)

{
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  undefined3 in_register_00002031;
  
  _DAT_4000f90c =
       CONCAT31(in_register_00002029,posCh) << 8 | _DAT_4000f90c & 0xffffe007 |
       CONCAT31(in_register_0000202d,negCh) << 3;
  _DAT_4000f910 =
       (CONCAT31(in_register_00002031,contEn) << 1 | _DAT_4000f910 & 0xfffffffd) & 0xfdffffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ADC_Start(void)

{
  _DAT_4000f90c = _DAT_4000f90c & 0xfffffffd;
  BL602_Delay_US(100);
  _DAT_4000f90c = _DAT_4000f90c | 2;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ADC_FIFO_Cfg(ADC_FIFO_Cfg_Type *fifoCfg)

{
  _DAT_40002000 =
       (uint)fifoCfg->fifoThreshold << 0x16 | _DAT_40002000 & 0xff3ffffe | (uint)fifoCfg->dmaEn | 2;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t ADC_Get_FIFO_Count(void)

{
  return (uint8_t)((byte)((uint)_DAT_40002000 >> 0x10) & 0x3f);
}



// WARNING: Control flow encountered bad instruction data

void ADC_Parse_Result(uint32_t *orgVal,uint32_t len,ADC_Result_Type *result)

{
                    // WARNING: Bad instruction - Truncating control flow here
  halt_baddata();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ADC_Tsen_Init(ADC_TSEN_MOD_Type tsenMod)

{
  undefined3 in_register_00002029;
  
  _DAT_4000f90c = _DAT_4000f90c & 0x87ffffff | 0xc0000;
  _DAT_4000f910 = _DAT_4000f910 | 0x4000000;
  _DAT_4000f914 =
       (_DAT_4000f914 & 0xfc3ffdf | CONCAT31(in_register_00002029,tsenMod) << 5) & 0xffffa07f |
       0x20000140;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ADC_SET_TSVBE_LOW(void)

{
  _DAT_4000f914 = _DAT_4000f914 & 0x7fffffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ADC_SET_TSVBE_HIGH(void)

{
  _DAT_4000f914 = _DAT_4000f914 | 0x80000000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t TSEN_Get_V_Error(void)

{
  BL_Fun_Type BVar1;
  uint8_t uVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  uint uVar3;
  uint32_t uStack44;
  uint32_t regVal;
  ADC_Result_Type result;
  
  uStack44 = 0;
  _DAT_40002000 = _DAT_40002000 | 2;
  ADC_SET_TSVBE_LOW();
  ADC_Start();
  do {
    uVar2 = ADC_Get_FIFO_Count();
    BVar1 = adcGainCoeffCal.adcGainCoeffEnable;
  } while (CONCAT31(extraout_var,uVar2) == 0);
  uStack44 = _DAT_40002004;
  adcGainCoeffCal.adcGainCoeffEnable = DISABLE;
  ADC_Parse_Result(&uStack44,1,(ADC_Result_Type *)&regVal);
  uVar3 = (uint)regVal._2_2_;
  _DAT_40002000 = _DAT_40002000 | 2;
  adcGainCoeffCal.adcGainCoeffEnable = BVar1;
  ADC_SET_TSVBE_HIGH();
  ADC_Start();
  do {
    uVar2 = ADC_Get_FIFO_Count();
    BVar1 = adcGainCoeffCal.adcGainCoeffEnable;
  } while (CONCAT31(extraout_var_00,uVar2) == 0);
  uStack44 = _DAT_40002004;
  adcGainCoeffCal.adcGainCoeffEnable = DISABLE;
  ADC_Parse_Result(&uStack44,1,(ADC_Result_Type *)&regVal);
  adcGainCoeffCal.adcGainCoeffEnable = BVar1;
  return uVar3 - regVal._2_2_;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

float TSEN_Get_Temp(uint32_t tsen_offset)

{
  BL_Fun_Type BVar1;
  uint8_t uVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  uint32_t *orgVal;
  SFtype SVar3;
  undefined4 uVar4;
  uint32_t uStack44;
  uint32_t regVal;
  ADC_Result_Type result;
  
  uStack44 = 0;
  _DAT_40002000 = _DAT_40002000 | 2;
  uVar4 = ADC_SET_TSVBE_LOW();
  ADC_Start(uVar4);
  do {
    uVar2 = ADC_Get_FIFO_Count();
    BVar1 = adcGainCoeffCal.adcGainCoeffEnable;
  } while (CONCAT31(extraout_var,uVar2) == 0);
  uStack44 = _DAT_40002004;
  adcGainCoeffCal.adcGainCoeffEnable = DISABLE;
  ADC_Parse_Result(&uStack44,1,(ADC_Result_Type *)&regVal);
  _DAT_40002000 = _DAT_40002000 | 2;
  adcGainCoeffCal.adcGainCoeffEnable = BVar1;
  uVar4 = ADC_SET_TSVBE_HIGH();
  ADC_Start(uVar4);
  do {
    uVar2 = ADC_Get_FIFO_Count();
    BVar1 = adcGainCoeffCal.adcGainCoeffEnable;
  } while (CONCAT31(extraout_var_00,uVar2) == 0);
  orgVal = &uStack44;
  uStack44 = _DAT_40002004;
  adcGainCoeffCal.adcGainCoeffEnable = DISABLE;
  ADC_Parse_Result(orgVal,1,(ADC_Result_Type *)&regVal);
  adcGainCoeffCal.adcGainCoeffEnable = BVar1;
  __extendsfdf2((SFtype)orgVal);
  __divdf3();
  SVar3 = __truncdfsf2();
  return (float)SVar3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ADC_Init(ADC_CFG_Type *cfg)

{
  uint uVar1;
  uint uVar2;
  
  _DAT_4000f910 =
       (uint)cfg->resWidth << 2 |
       ((uint)cfg->clkDiv << 0x12 |
        (uint)cfg->v11Sel << 0x1b | (uint)cfg->v18Sel << 0x1d | _DAT_4000f910 & 0x8001fffe |
       (uint)cfg->offsetCalibEn) & 0xffffffe3;
  if ((cfg->gain1 | cfg->gain2) == 0) {
    uVar1 = 0xfffe1fff;
    uVar2 = 0x8000;
  }
  else {
    uVar1 = 0xfffe3fff;
    uVar2 = 0x12000;
  }
  _DAT_4000f914 =
       ((uint)cfg->biasSel << 0x11 |
       (uint)cfg->gain2 << 0x16 | (uint)cfg->gain1 << 0x19 | _DAT_4000f914 & 0x803dffff) & uVar1 &
       0xffffe073 | uVar2 | (uint)cfg->vcm << 7 | (uint)cfg->vref << 3 | 0x1000 |
       (uint)cfg->inputMode << 2;
  _DAT_4000f938 = (int)cfg->offsetCalibVal | _DAT_4000f938 & 0xffff0000;
                    // WARNING: Treating indirect jump as call
  ADC_Gain_Trim();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_PKA_Write_Common_OP_First_Cfg
               (uint8_t s0RegIndex,uint8_t s0RegType,uint8_t dRegIndex,uint8_t dRegType,uint8_t op,
               uint8_t lastOp)

{
  undefined3 in_register_00002029;
  uint uVar1;
  undefined3 in_register_00002031;
  undefined3 in_register_00002039;
  
  uVar1 = CONCAT31(in_register_00002029,s0RegIndex) | ((uint)s0RegType & 0xf) << 8;
  if (CONCAT31(in_register_00002039,op) != 0x19) {
    uVar1 = uVar1 | CONCAT31(in_register_00002031,dRegIndex) << 0xc | ((uint)dRegType & 0xf) << 0x14
    ;
  }
  _DAT_40004340 = uVar1 & 0xffffff | ((uint)op & 0x7f) << 0x18 | (uint)lastOp << 0x1f;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type Sec_Eng_PKA_Wait_ISR(void)

{
  int iVar1;
  
  iVar1 = 16000000;
  do {
    iVar1 = iVar1 + -1;
    if (iVar1 == 0) {
      return TIMEOUT;
    }
  } while ((_DAT_40004300 & 0x100) == 0);
  return SUCCESS;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type Sec_Eng_SHA256_Update(SEC_Eng_SHA256_Ctx *shaCtx,uint8_t *input,uint32_t len)

{
  byte bVar1;
  uint uVar2;
  int iVar3;
  uint n;
  uint32_t *psrc;
  uint uVar4;
  
  uVar2 = _DAT_40004000;
  iVar3 = 16000000;
  do {
    iVar3 = iVar3 + -1;
    if (iVar3 == 0) {
      return TIMEOUT;
    }
  } while ((_DAT_40004000 & 1) != 0);
  bVar1 = shaCtx->shaFeed;
  uVar4 = shaCtx->total[0] & 0x3f;
  n = shaCtx->total[0] + len;
  shaCtx->total[0] = n;
  if (n < len) {
    shaCtx->total[1] = shaCtx->total[1] + 1;
  }
  if ((uVar4 != 0) && (n = 0x40 - uVar4, n <= len)) {
    BL602_MemCpy_Fast((void *)((int)shaCtx->shaBuf + uVar4),input,n);
    _DAT_40004004 = shaCtx->shaBuf;
    _DAT_40004000 = (uint)bVar1 << 6 | uVar2 & 0xffbf | 0x10002;
    len = (len - 0x40) + uVar4;
    shaCtx->shaFeed = '\x01';
    input = input + n;
    uVar4 = 0;
  }
  psrc = (uint32_t *)input;
  if (0x3f < len) {
    iVar3 = 16000000;
    do {
      iVar3 = iVar3 + -1;
      if (iVar3 == 0) {
        return TIMEOUT;
      }
    } while ((_DAT_40004000 & 1) != 0);
    _DAT_40004000 = (len >> 6) << 0x10 | (uint)shaCtx->shaFeed << 6 | _DAT_40004000 & 0xffbf | 2;
    psrc = (uint32_t *)((int)input + (len & 0xffffffc0));
    _DAT_40004004 = (uint32_t *)input;
    shaCtx->shaFeed = '\x01';
  }
  if ((len & 0x3f) != 0) {
    iVar3 = 16000000;
    do {
      iVar3 = iVar3 + -1;
      if (iVar3 == 0) {
        return TIMEOUT;
      }
    } while ((_DAT_40004000 & 1) != 0);
    BL602_MemCpy_Fast((void *)((int)shaCtx->shaBuf + uVar4),psrc,len & 0x3f);
  }
  iVar3 = 16000000;
  do {
    iVar3 = iVar3 + -1;
    if (iVar3 == 0) {
      return TIMEOUT;
    }
  } while ((_DAT_40004000 & 1) != 0);
  return SUCCESS;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_SHA256_Init(SEC_Eng_SHA256_Ctx *shaCtx,SEC_ENG_SHA_ID_Type shaNo,
                        SEC_ENG_SHA_Type shaType,uint32_t *shaTmpBuf,uint32_t *padding)

{
  undefined3 in_register_00002031;
  
  _DAT_40004000 = CONCAT31(in_register_00002031,shaType) << 2 | _DAT_40004000 & 0xffffffe3;
  memset(shaCtx,0,0x14);
  shaCtx->shaPadding = padding;
  shaCtx->shaBuf = shaTmpBuf;
  BL602_MemSet(padding,'\0',0x40);
                    // WARNING: Treating indirect jump as call
  BL602_MemSet(shaCtx->shaPadding,-0x80,1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_SHA_Start(SEC_ENG_SHA_ID_Type shaNo)

{
  _DAT_40004000 = _DAT_40004000 & 0xffffffbf | 0x20;
  return;
}



BL_Err_Type
Sec_Eng_SHA256_Update
          (SEC_Eng_SHA256_Ctx *shaCtx,SEC_ENG_SHA_ID_Type shaNo,uint8_t *input,uint32_t len)

{
  BL_Err_Type BVar1;
  
  if (len != 0) {
    BVar1 = Sec_Eng_SHA256_Update(shaCtx,input,len);
    return BVar1;
  }
  return SUCCESS;
}



// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
Sec_Eng_SHA256_Finish(SEC_Eng_SHA256_Ctx *shaCtx,SEC_ENG_SHA_ID_Type shaNo,uint8_t *hash)

{
  undefined4 uVar1;
  uint uVar2;
  int iVar3;
  uint uVar4;
  undefined uStack24;
  undefined uStack23;
  ushort uStack22;
  uint8_t msgLen [8];
  
  iVar3 = 16000000;
  do {
    iVar3 = iVar3 + -1;
    if (iVar3 == 0) {
      return TIMEOUT;
    }
  } while ((_DAT_40004000 & 1) != 0);
  uVar2 = shaCtx->total[0];
  uVar4 = shaCtx->total[1] << 3;
  uStack24 = (undefined)(uVar4 >> 0x18);
  uStack23 = (undefined)(uVar4 >> 0x10);
  uStack22 = (ushort)((uVar4 | uVar2 >> 0x1d) << 8) | (ushort)(uVar4 >> 8) & 0xff;
  msgLen[0] = (uint8_t)((uVar2 << 3) >> 0x18);
  msgLen[1] = (uint8_t)((uVar2 << 3) >> 0x10);
  msgLen._2_2_ = (ushort)((uVar2 << 0x13) >> 0x18) | (ushort)(uVar2 << 0xb);
  if ((uVar2 & 0x3f) < 0x38) {
    iVar3 = 0x38;
  }
  else {
    iVar3 = 0x78;
  }
  Sec_Eng_SHA256_Update(shaCtx,shaNo,(uint8_t *)shaCtx->shaPadding,iVar3 - (uVar2 & 0x3f));
  iVar3 = 16000000;
  do {
    iVar3 = iVar3 + -1;
    if (iVar3 == 0) {
      return TIMEOUT;
    }
  } while ((_DAT_40004000 & 1) != 0);
  BL602_MemCpy_Fast(shaCtx->shaPadding,&uStack24,8);
  Sec_Eng_SHA256_Update(shaCtx,(uint8_t *)shaCtx->shaPadding,8);
  uVar1 = _DAT_40004010;
  iVar3 = 16000000;
  do {
    iVar3 = iVar3 + -1;
    if (iVar3 == 0) {
      return TIMEOUT;
    }
  } while ((_DAT_40004000 & 1) != 0);
  uVar2 = _DAT_40004000 >> 2;
  *hash = (uint8_t)_DAT_40004010;
  hash[1] = (uint8_t)((uint)uVar1 >> 8);
  hash[2] = (uint8_t)((uint)uVar1 >> 0x10);
  hash[3] = (uint8_t)((uint)uVar1 >> 0x18);
  uVar1 = _DAT_40004014;
  hash[4] = (uint8_t)_DAT_40004014;
  hash[5] = (uint8_t)((uint)uVar1 >> 8);
  hash[6] = (uint8_t)((uint)uVar1 >> 0x10);
  hash[7] = (uint8_t)((uint)uVar1 >> 0x18);
  uVar1 = _DAT_40004018;
  hash[8] = (uint8_t)_DAT_40004018;
  hash[9] = (uint8_t)((uint)uVar1 >> 8);
  hash[10] = (uint8_t)((uint)uVar1 >> 0x10);
  hash[0xb] = (uint8_t)((uint)uVar1 >> 0x18);
  uVar1 = _DAT_4000401c;
  hash[0xc] = (uint8_t)_DAT_4000401c;
  hash[0xd] = (uint8_t)((uint)uVar1 >> 8);
  hash[0xe] = (uint8_t)((uint)uVar1 >> 0x10);
  hash[0xf] = (uint8_t)((uint)uVar1 >> 0x18);
  uVar1 = _DAT_40004020;
  hash[0x10] = (uint8_t)_DAT_40004020;
  hash[0x11] = (uint8_t)((uint)uVar1 >> 8);
  hash[0x13] = (uint8_t)((uint)uVar1 >> 0x18);
  hash[0x12] = (uint8_t)((uint)uVar1 >> 0x10);
  uVar1 = _DAT_40004024;
  if ((uVar2 & 6) == 0) {
    hash[0x14] = (uint8_t)_DAT_40004024;
    hash[0x15] = (uint8_t)((uint)uVar1 >> 8);
    hash[0x16] = (uint8_t)((uint)uVar1 >> 0x10);
    hash[0x17] = (uint8_t)((uint)uVar1 >> 0x18);
    uVar1 = _DAT_40004028;
    hash[0x18] = (uint8_t)_DAT_40004028;
    hash[0x19] = (uint8_t)((uint)uVar1 >> 8);
    hash[0x1a] = (uint8_t)((uint)uVar1 >> 0x10);
    hash[0x1b] = (uint8_t)((uint)uVar1 >> 0x18);
    uVar1 = _DAT_4000402c;
    if ((uVar2 & 7) == 0) {
      hash[0x1c] = (uint8_t)_DAT_4000402c;
      hash[0x1d] = (uint8_t)((uint)uVar1 >> 8);
      hash[0x1e] = (uint8_t)((uint)uVar1 >> 0x10);
      hash[0x1f] = (uint8_t)((uint)uVar1 >> 0x18);
    }
  }
  _DAT_40004000 = _DAT_40004000 & 0xffffff9f;
  return SUCCESS;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_SHA_Enable_Link(SEC_ENG_SHA_ID_Type shaNo)

{
  _DAT_40004000 = _DAT_40004000 | 0x8020;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_SHA_Disable_Link(SEC_ENG_SHA_ID_Type shaNo)

{
  _DAT_40004000 = _DAT_40004000 & 0xffff7fdf;
  return;
}



void Sec_Eng_SHA256_Link_Init
               (SEC_Eng_SHA256_Link_Ctx *shaCtx,SEC_ENG_SHA_ID_Type shaNo,uint32_t linkAddr,
               uint32_t *shaTmpBuf,uint32_t *padding)

{
  memset(shaCtx,0,0x14);
  shaCtx->shaPadding = padding;
  shaCtx->shaBuf = shaTmpBuf;
  BL602_MemSet(padding,'\0',0x40);
  BL602_MemSet(shaCtx->shaPadding,-0x80,1);
  shaCtx->linkAddr = linkAddr;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
Sec_Eng_SHA256_Link_Update
          (SEC_Eng_SHA256_Link_Ctx *shaCtx,SEC_ENG_SHA_ID_Type shaNo,uint8_t *input,uint32_t len)

{
  int iVar1;
  uint n;
  uint uVar2;
  
  if (len == 0) {
    return SUCCESS;
  }
  iVar1 = 16000000;
  do {
    iVar1 = iVar1 + -1;
    if (iVar1 == 0) {
      return TIMEOUT;
    }
  } while ((_DAT_40004000 & 1) != 0);
  _DAT_40004050 = shaCtx->linkAddr;
  uVar2 = shaCtx->total[0] & 0x3f;
  n = shaCtx->total[0] + len;
  shaCtx->total[0] = n;
  if (n < len) {
    shaCtx->total[1] = shaCtx->total[1] + 1;
  }
  if ((uVar2 != 0) && (n = 0x40 - uVar2, n <= len)) {
    BL602_MemCpy_Fast((void *)((int)shaCtx->shaBuf + uVar2),input,n);
    input = input + n;
    *(uint32_t **)(shaCtx->linkAddr + 4) = shaCtx->shaBuf;
    *(undefined2 *)(shaCtx->linkAddr + 2) = 1;
    _DAT_40004000 = _DAT_40004000 | 2;
    len = (len + uVar2) - 0x40;
    *(uint *)shaCtx->linkAddr = *(uint *)shaCtx->linkAddr | 0x40;
    uVar2 = 0;
  }
  if (0x3f < len) {
    iVar1 = 16000000;
    do {
      iVar1 = iVar1 + -1;
      if (iVar1 == 0) {
        return TIMEOUT;
      }
    } while ((_DAT_40004000 & 1) != 0);
    *(uint8_t **)(shaCtx->linkAddr + 4) = input;
    input = input + (len & 0xffffffc0);
    *(undefined2 *)(shaCtx->linkAddr + 2) = (short)(len >> 6);
    _DAT_40004000 = _DAT_40004000 | 2;
    *(uint *)shaCtx->linkAddr = *(uint *)shaCtx->linkAddr | 0x40;
  }
  if ((len & 0x3f) != 0) {
    iVar1 = 16000000;
    do {
      iVar1 = iVar1 + -1;
      if (iVar1 == 0) {
        return TIMEOUT;
      }
    } while ((_DAT_40004000 & 1) != 0);
    BL602_MemCpy_Fast((void *)((int)shaCtx->shaBuf + uVar2),input,len & 0x3f);
  }
  iVar1 = 16000000;
  do {
    iVar1 = iVar1 + -1;
    if (iVar1 == 0) {
      return TIMEOUT;
    }
  } while ((_DAT_40004000 & 1) != 0);
  return SUCCESS;
}



// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
Sec_Eng_SHA256_Link_Finish(SEC_Eng_SHA256_Link_Ctx *shaCtx,SEC_ENG_SHA_ID_Type shaNo,uint8_t *hash)

{
  uint uVar1;
  uint32_t n;
  uint uVar2;
  int iVar3;
  uint uVar4;
  uint8_t uStack40;
  undefined uStack39;
  ushort uStack38;
  uint8_t msgLen [8];
  
  iVar3 = 16000000;
  uVar1 = *(uint *)shaCtx->linkAddr;
  do {
    iVar3 = iVar3 + -1;
    if (iVar3 == 0) {
      return TIMEOUT;
    }
  } while ((_DAT_40004000 & 1) != 0);
  uVar2 = shaCtx->total[0];
  uVar4 = shaCtx->total[1] << 3;
  uStack40 = (uint8_t)(uVar4 >> 0x18);
  uStack39 = (undefined)(uVar4 >> 0x10);
  uStack38 = (ushort)((uVar4 | uVar2 >> 0x1d) << 8) | (ushort)(uVar4 >> 8) & 0xff;
  msgLen[0] = (uint8_t)((uVar2 << 3) >> 0x18);
  msgLen[1] = (uint8_t)((uVar2 << 3) >> 0x10);
  msgLen._2_2_ = (ushort)((uVar2 << 0x13) >> 0x18) | (ushort)(uVar2 << 0xb);
  if ((uVar2 & 0x3f) < 0x38) {
    iVar3 = 0x38;
  }
  else {
    iVar3 = 0x78;
  }
  _DAT_40004050 = (uint *)shaCtx->linkAddr;
  Sec_Eng_SHA256_Link_Update(shaCtx,shaNo,(uint8_t *)shaCtx->shaPadding,iVar3 - (uVar2 & 0x3f));
  iVar3 = 16000000;
  do {
    iVar3 = iVar3 + -1;
    if (iVar3 == 0) {
      return TIMEOUT;
    }
  } while ((_DAT_40004000 & 1) != 0);
  Sec_Eng_SHA256_Link_Update(shaCtx,shaNo,&uStack40,8);
  iVar3 = 16000000;
  do {
    iVar3 = iVar3 + -1;
    if (iVar3 == 0) {
      return TIMEOUT;
    }
  } while ((_DAT_40004000 & 1) != 0);
  uVar1 = uVar1 >> 2 & 7;
  if (uVar1 == 1) {
    n = 0x1c;
  }
  else {
    if (uVar1 == 0) {
      n = 0x20;
    }
    else {
      n = 0x14;
      if (3 < uVar1) goto LAB_230537a0;
    }
  }
  BL602_MemCpy_Fast(hash,(void *)(shaCtx->linkAddr + 8),n);
LAB_230537a0:
  *(uint *)shaCtx->linkAddr = *(uint *)shaCtx->linkAddr & 0xffffffbf;
  return SUCCESS;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_AES_Enable_Link(SEC_ENG_AES_ID_Type aesNo)

{
  _DAT_40004100 = _DAT_40004100 | 0x8000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_AES_Disable_Link(SEC_ENG_AES_ID_Type aesNo)

{
  _DAT_40004100 = _DAT_40004100 & 0xffff7fff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
Sec_Eng_AES_Link_Work
          (SEC_ENG_AES_ID_Type aesNo,uint32_t linkAddr,uint8_t *in,uint32_t len,uint8_t *out)

{
  BL_Err_Type BVar1;
  int iVar2;
  
  BVar1 = ERROR;
  if ((linkAddr & 3 | len & 0xf) == 0) {
    iVar2 = 16000000;
    do {
      iVar2 = iVar2 + -1;
      if (iVar2 == 0) {
        return TIMEOUT;
      }
    } while ((_DAT_40004100 & 1) != 0);
    _DAT_40004150 = linkAddr;
    *(uint8_t **)(linkAddr + 4) = in;
    *(uint8_t **)(linkAddr + 8) = out;
    *(undefined2 *)(linkAddr + 2) = (short)(len >> 4);
    iVar2 = 16000000;
    do {
      iVar2 = iVar2 + -1;
      if (iVar2 == 0) {
        _DAT_40004100 = _DAT_40004100 | 6;
        return TIMEOUT;
      }
    } while ((_DAT_40004100 & 1) != 0);
    _DAT_40004100 = (_DAT_40004100 | 6) & 0xfffffffb;
    BVar1 = SUCCESS;
  }
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_PKA_Reset(void)

{
  _DAT_40004300 = 8;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_PKA_BigEndian_Enable(void)

{
  _DAT_40004300 = _DAT_40004300 | 0x1000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_PKA_Clear_Int(void)

{
  _DAT_40004300 = _DAT_40004300 & 0xfffffdff;
  return;
}



void Sec_Eng_PKA_Read_Block(uint32_t *dest,uint32_t *src,uint32_t len)

{
  uint uVar1;
  
  uVar1 = 0;
  while (uVar1 != (len & 0xfffffffc)) {
    dest[uVar1] = *src;
    uVar1 = uVar1 + 1;
  }
  return;
}



void Sec_Eng_PKA_Write_Block(uint32_t *dest,uint32_t *src,uint32_t len)

{
  uint32_t *puVar1;
  uint uVar2;
  
  uVar2 = 0;
  while (uVar2 != (len & 0xfffffffc)) {
    puVar1 = src + uVar2;
    uVar2 = uVar2 + 1;
    *dest = *puVar1;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_PKA_Write_Data
               (SEC_ENG_PKA_REG_SIZE_Type regType,uint8_t regIndex,uint32_t *data,uint16_t size,
               uint8_t lastOp)

{
  undefined3 in_register_0000202d;
  uint uVar1;
  undefined2 in_register_00002036;
  uint uVar2;
  
  uVar1 = (uint)regType - 1 & 0xff;
  uVar2 = 0;
  if (uVar1 < 10) {
    uVar2 = (uint)*(ushort *)(CSWTCH_116 + uVar1 * 2);
  }
  _DAT_40004340 =
       (uint)size & 0xfff | CONCAT31(in_register_0000202d,regIndex) << 0xc |
       ((uint)regType & 0xf) << 0x14 | 0x39000000 | (uint)lastOp << 0x1f;
  uVar1 = uVar2 >> 2;
  if (CONCAT22(in_register_00002036,size) < uVar2 >> 2) {
    uVar1 = CONCAT22(in_register_00002036,size);
  }
  Sec_Eng_PKA_Write_Block((uint32_t *)&DAT_40004340,data,uVar1 & 0xffff);
  uVar2 = uVar1 & 0xfffc;
  while ((int)uVar2 < (int)(uVar1 & 0xffff)) {
    _DAT_40004340 = data[uVar2];
    uVar2 = uVar2 + 1;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_PKA_Read_Data
               (SEC_ENG_PKA_REG_SIZE_Type regType,uint8_t regIdx,uint32_t *result,uint8_t retSize)

{
  undefined3 in_register_00002035;
  uint len;
  uint uVar1;
  uint uVar2;
  
  len = CONCAT31(in_register_00002035,retSize);
  uVar2 = (uint)regType - 1 & 0xff;
  uVar1 = 0;
  if (uVar2 < 10) {
    uVar1 = (uint)*(ushort *)(CSWTCH_116 + uVar2 * 2);
  }
  if (len <= uVar1 >> 2) {
    _DAT_40004340 = 0;
    Sec_Eng_PKA_Wait_ISR();
    Sec_Eng_PKA_Clear_Int();
    Sec_Eng_PKA_Read_Block(result,(uint32_t *)&DAT_40004340,len);
    uVar1 = len & 0xfffffffc;
    while ((int)uVar1 < (int)len) {
      result[uVar1] = _DAT_40004340;
      uVar1 = uVar1 + 1;
    }
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_PKA_CREG(SEC_ENG_PKA_REG_SIZE_Type dRegType,uint8_t dRegIdx,uint8_t size,uint8_t lastOp
                     )

{
  undefined3 in_register_00002035;
  
  _DAT_40004340 = 0;
  if (CONCAT31(in_register_00002035,lastOp) != 0) {
    Sec_Eng_PKA_Wait_ISR();
    Sec_Eng_PKA_Clear_Int();
    return;
  }
  _DAT_40004340 = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_PKA_Move_Data
               (uint8_t dRegType,uint8_t dRegIdx,uint8_t s0RegType,uint8_t s0RegIdx,uint8_t lastOp)

{
  undefined3 in_register_00002039;
  
  Sec_Eng_PKA_Write_Common_OP_First_Cfg(s0RegIdx,s0RegType,dRegIdx,dRegType,'2',lastOp);
  _DAT_40004340 = 0;
  if (CONCAT31(in_register_00002039,lastOp) != 0) {
    Sec_Eng_PKA_Wait_ISR();
    Sec_Eng_PKA_Clear_Int();
    return;
  }
  _DAT_40004340 = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_PKA_MREM(uint8_t dRegType,uint8_t dRegIdx,uint8_t s0RegType,uint8_t s0RegIdx,
                     uint8_t s2RegType,uint8_t s2RegIdx,uint8_t lastOp)

{
  undefined3 in_register_0000203d;
  undefined3 in_register_00002041;
  
  Sec_Eng_PKA_Write_Common_OP_First_Cfg(s0RegIdx,s0RegType,dRegIdx,dRegType,'&',lastOp);
  _DAT_40004340 = ((uint)s2RegType & 0xf) << 8 | CONCAT31(in_register_0000203d,s2RegIdx);
  if (CONCAT31(in_register_00002041,lastOp) != 0) {
    Sec_Eng_PKA_Wait_ISR();
    Sec_Eng_PKA_Clear_Int();
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_PKA_MEXP(uint8_t dRegType,uint8_t dRegIdx,uint8_t s0RegType,uint8_t s0RegIdx,
                     uint8_t s1RegType,uint8_t s1RegIdx,uint8_t s2RegType,uint8_t s2RegIdx,
                     uint8_t lastOp)

{
  undefined3 in_register_0000203d;
  undefined3 in_register_00002045;
  uint8_t in_stack_00000000;
  
  Sec_Eng_PKA_Write_Common_OP_First_Cfg(s0RegIdx,s0RegType,dRegIdx,dRegType,'#',in_stack_00000000);
  _DAT_40004340 =
       CONCAT31(in_register_0000203d,s1RegIdx) << 0xc | ((uint)s1RegType & 0xf) << 0x14 |
       CONCAT31(in_register_00002045,s2RegIdx) | ((uint)s2RegType & 0xf) << 8;
  if (in_stack_00000000 != '\0') {
    Sec_Eng_PKA_Wait_ISR();
    Sec_Eng_PKA_Clear_Int();
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_PKA_LCMP(uint8_t *cout,uint8_t s0RegType,uint8_t s0RegIdx,uint8_t s1RegType,
                     uint8_t s1RegIdx)

{
  undefined3 in_register_00002039;
  
  _DAT_40004340 = CONCAT31(in_register_00002039,s1RegIdx) << 0xc | ((uint)s1RegType & 0xf) << 0x14;
  Sec_Eng_PKA_Wait_ISR();
  Sec_Eng_PKA_Clear_Int();
  *cout = (byte)((uint)_DAT_40004300 >> 0x18) & 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_PKA_LSUB(uint8_t dRegType,uint8_t dRegIdx,uint8_t s0RegType,uint8_t s0RegIdx,
                     uint8_t s1RegType,uint8_t s1RegIdx,uint8_t lastOp)

{
  undefined3 in_register_0000203d;
  undefined3 in_register_00002041;
  
  Sec_Eng_PKA_Write_Common_OP_First_Cfg(s0RegIdx,s0RegType,dRegIdx,dRegType,'\x17',lastOp);
  _DAT_40004340 = CONCAT31(in_register_0000203d,s1RegIdx) << 0xc | ((uint)s1RegType & 0xf) << 0x14;
  if (CONCAT31(in_register_00002041,lastOp) != 0) {
    Sec_Eng_PKA_Wait_ISR();
    Sec_Eng_PKA_Clear_Int();
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_PKA_LMUL(uint8_t dRegType,uint8_t dRegIdx,uint8_t s0RegType,uint8_t s0RegIdx,
                     uint8_t s1RegType,uint8_t s1RegIdx,uint8_t lastOp)

{
  undefined3 in_register_0000203d;
  undefined3 in_register_00002041;
  
  Sec_Eng_PKA_Write_Common_OP_First_Cfg(s0RegIdx,s0RegType,dRegIdx,dRegType,'\x16',lastOp);
  _DAT_40004340 = CONCAT31(in_register_0000203d,s1RegIdx) << 0xc | ((uint)s1RegType & 0xf) << 0x14;
  if (CONCAT31(in_register_00002041,lastOp) != 0) {
    Sec_Eng_PKA_Wait_ISR();
    Sec_Eng_PKA_Clear_Int();
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_PKA_LDIV(uint8_t dRegType,uint8_t dRegIdx,uint8_t s0RegType,uint8_t s0RegIdx,
                     uint8_t s2RegType,uint8_t s2RegIdx,uint8_t lastOp)

{
  undefined3 in_register_0000203d;
  undefined3 in_register_00002041;
  
  Sec_Eng_PKA_Write_Common_OP_First_Cfg(s0RegIdx,s0RegType,dRegIdx,dRegType,'\x14',lastOp);
  _DAT_40004340 = ((uint)s2RegType & 0xf) << 8 | CONCAT31(in_register_0000203d,s2RegIdx);
  if (CONCAT31(in_register_00002041,lastOp) != 0) {
    Sec_Eng_PKA_Wait_ISR();
    Sec_Eng_PKA_Clear_Int();
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_PKA_LMUL2N(uint8_t dRegType,uint8_t dRegIdx,uint8_t s0RegType,uint8_t s0RegIdx,
                       uint16_t bit_shift,uint8_t lastOp)

{
  undefined3 in_register_0000203d;
  
  Sec_Eng_PKA_Write_Common_OP_First_Cfg(s0RegIdx,s0RegType,dRegIdx,dRegType,'\x13','\0');
  _DAT_40004340 = (uint)bit_shift & 0x7fff;
  if (CONCAT31(in_register_0000203d,lastOp) != 0) {
    Sec_Eng_PKA_Wait_ISR();
    Sec_Eng_PKA_Clear_Int();
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SEC_Eng_IntMask(SEC_ENG_INT_Type intType,BL_Mask_Type intMask)

{
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  int iVar1;
  
  iVar1 = CONCAT31(in_register_0000202d,intMask);
  switch(CONCAT31(in_register_00002029,intType)) {
  case 0:
    if (iVar1 == 0) {
      _DAT_40004200 = _DAT_40004200 & 0xfffff7ff;
    }
    else {
      _DAT_40004200 = _DAT_40004200 | 0x800;
    }
    return;
  case 1:
    if (iVar1 == 0) {
      _DAT_40004100 = _DAT_40004100 & 0xfffff7ff;
    }
    else {
      _DAT_40004100 = _DAT_40004100 | 0x800;
    }
    return;
  case 2:
    if (iVar1 == 0) {
      _DAT_40004000 = _DAT_40004000 & 0xfffff7ff;
    }
    else {
      _DAT_40004000 = _DAT_40004000 | 0x800;
    }
    return;
  case 3:
    if (iVar1 == 0) {
      _DAT_40004300 = _DAT_40004300 & 0xfffff7ff;
    }
    else {
      _DAT_40004300 = _DAT_40004300 | 0x800;
    }
    return;
  case 5:
    if (iVar1 == 0) {
      _DAT_40004500 = _DAT_40004500 & 0xfffff7ff;
    }
    else {
      _DAT_40004500 = _DAT_40004500 | 0x800;
    }
    return;
  case 6:
    if (iVar1 == 0) {
      _DAT_40004200 = _DAT_40004200 & 0xfffff7ff;
      _DAT_40004100 = _DAT_40004100 & 0xfffff7ff;
      _DAT_40004000 = _DAT_40004000 & 0xfffff7ff;
      _DAT_40004300 = _DAT_40004300 & 0xfffff7ff;
      _DAT_40004500 = _DAT_40004500 & 0xfffff7ff;
    }
    else {
      _DAT_40004200 = _DAT_40004200 | 0x800;
      _DAT_40004100 = _DAT_40004100 | 0x800;
      _DAT_40004000 = _DAT_40004000 | 0x800;
      _DAT_40004300 = _DAT_40004300 | 0x800;
      _DAT_40004500 = _DAT_40004500 | 0x800;
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void DMA_Enable(void)

{
  _DAT_4000c030 = _DAT_4000c030 | 1;
  return;
}



void DMA_Channel_Enable(uint8_t ch)

{
  undefined3 in_register_00002029;
  uint *puVar1;
  
  puVar1 = (uint *)(CONCAT31(in_register_00002029,ch) * 0x100 + 0x4000c110);
  *puVar1 = *puVar1 | 1;
  return;
}



void DMA_LLI_Init(uint8_t ch,DMA_LLI_Cfg_Type *lliCfg)

{
  undefined3 in_register_00002029;
  uint *puVar1;
  
  puVar1 = (uint *)(CONCAT31(in_register_00002029,ch) * 0x100 + 0x4000c110);
  *puVar1 = (uint)lliCfg->dir << 0xb | *puVar1 & 0xffffc001 | (uint)lliCfg->dstPeriph << 6 |
            (uint)lliCfg->srcPeriph << 1;
  return;
}



void DMA_LLI_Update(uint8_t ch,uint32_t LLI)

{
  undefined3 in_register_00002029;
  
                    // WARNING: Treating indirect jump as call
  BL602_MemCpy4((uint32_t *)(CONCAT31(in_register_00002029,ch) * 0x100 + 0x4000c100),(uint32_t *)LLI
                ,4);
  return;
}



void DMA_IntMask(uint8_t ch,DMA_INT_Type intType,BL_Mask_Type intMask)

{
  undefined3 in_register_00002029;
  int iVar1;
  uint *puVar2;
  undefined3 in_register_0000202d;
  int iVar3;
  undefined3 in_register_00002031;
  int iVar4;
  uint uVar5;
  uint uVar6;
  
  iVar4 = CONCAT31(in_register_00002031,intMask);
  iVar3 = CONCAT31(in_register_0000202d,intType);
  iVar1 = CONCAT31(in_register_00002029,ch) * 0x100;
  if (iVar3 == 1) {
    puVar2 = (uint *)(iVar1 + 0x4000c110);
    uVar6 = *puVar2;
    if (iVar4 == 0) {
      uVar6 = uVar6 & 0xffffbfff;
      goto LAB_23053e98;
    }
    uVar5 = 0x4000;
  }
  else {
    if (iVar3 == 0) {
      uVar6 = *(uint *)(iVar1 + 0x4000c110);
      iVar3 = -0x8000;
      if (iVar4 != 0) {
        uVar5 = 0x8000;
        goto LAB_23053e78;
      }
    }
    else {
      if (iVar3 != 2) {
        return;
      }
      uVar6 = *(uint *)(iVar1 + 0x4000c110);
      if (iVar4 != 0) {
        uVar5 = 0xc000;
LAB_23053e78:
        puVar2 = (uint *)(iVar1 + 0x4000c10c);
        *(uint *)(iVar1 + 0x4000c110) = uVar6 | uVar5;
        uVar6 = *puVar2 & 0x7fffffff;
        goto LAB_23053e98;
      }
      iVar3 = -0xc000;
    }
    puVar2 = (uint *)(iVar1 + 0x4000c10c);
    *(uint *)(iVar1 + 0x4000c110) = uVar6 & iVar3 - 1U;
    uVar6 = *puVar2;
    uVar5 = 0x80000000;
  }
  uVar6 = uVar6 | uVar5;
LAB_23053e98:
  *puVar2 = uVar6;
  return;
}



void Default_Handler(void)

{
  bflb_platform_printf("Default_Handler\r\n");
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_Set_UART_CLK(uint8_t enable,HBN_UART_CLK_Type clkSel,uint8_t div)

{
  undefined3 in_register_00002029;
  undefined3 in_register_00002031;
  uint uVar1;
  
  _DAT_40000008 = CONCAT31(in_register_00002031,div) | _DAT_40000008 & 0xffffffe8;
  HBN_Set_UART_CLK_Sel(clkSel);
  uVar1 = _DAT_40000008 | 0x10;
  if (CONCAT31(in_register_00002029,enable) == 0) {
    uVar1 = _DAT_40000008 & 0xffffffef;
  }
  _DAT_40000008 = uVar1;
  return SUCCESS;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_Set_ADC_CLK(uint8_t enable,GLB_ADC_CLK_Type clkSel,uint8_t div)

{
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  undefined3 in_register_00002031;
  uint uVar1;
  
  uVar1 = (CONCAT31(in_register_00002031,div) | _DAT_400000a4 & 0xfffffec0) & 0xffffff7f |
          CONCAT31(in_register_0000202d,clkSel) << 7;
  _DAT_400000a4 = uVar1 & 0xfffffeff;
  if (CONCAT31(in_register_00002029,enable) != 0) {
    _DAT_400000a4 = uVar1 | 0x100;
  }
  return SUCCESS;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_UART_Fun_Sel(GLB_UART_SIG_Type sig,GLB_UART_SIG_FUN_Type fun)

{
  undefined3 in_register_0000202d;
  
  _DAT_400000c0 =
       ~(0xf << (((uint)sig & 7) << 2)) & _DAT_400000c0 |
       CONCAT31(in_register_0000202d,fun) << (((uint)sig & 7) << 2);
  return SUCCESS;
}



BL_Err_Type GLB_GPIO_Write(GLB_GPIO_Type gpioPin,uint32_t val)

{
  undefined3 in_register_00002029;
  uint uVar1;
  uint uVar2;
  uint *puVar3;
  
  puVar3 = (uint *)((CONCAT31(in_register_00002029,gpioPin) >> 5) * 4 + 0x40000188);
  uVar2 = *puVar3;
  uVar1 = 1 << ((uint)gpioPin & 0x1f);
  if (val == 0) {
    uVar1 = ~uVar1 & uVar2;
  }
  else {
    uVar1 = uVar1 | uVar2;
  }
  *puVar3 = uVar1;
  return SUCCESS;
}



uint32_t GLB_GPIO_Read(GLB_GPIO_Type gpioPin)

{
  undefined3 in_register_00002029;
  
  return (uint)((1 << ((uint)gpioPin & 0x1f) &
                *(uint *)((CONCAT31(in_register_00002029,gpioPin) >> 5) * 4 + 0x40000180)) != 0);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Set_UART_CLK_Sel(HBN_UART_CLK_Type clkSel)

{
  undefined3 in_register_00002029;
  
  _DAT_4000f030 = CONCAT31(in_register_00002029,clkSel) << 2 | _DAT_4000f030 & 0xfffffffb;
  return SUCCESS;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Get_RTC_Timer_Val(uint32_t *valLow,uint32_t *valHigh)

{
  _DAT_4000f010 = _DAT_4000f010 & 0x7fffffff;
  *valLow = _DAT_4000f00c;
  *valHigh = _DAT_4000f010 & 0xff;
  return SUCCESS;
}



void TIMER_SetCompValue(TIMER_Chan_Type timerCh,TIMER_Comp_ID_Type cmpNo,uint32_t val)

{
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  
  *(uint32_t *)
   ((CONCAT31(in_register_00002029,timerCh) * 3 + CONCAT31(in_register_0000202d,cmpNo)) * 4 +
   0x4000a510) = val;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void TIMER_SetCountMode(TIMER_Chan_Type timerCh,TIMER_CountMode_Type countMode)

{
  undefined3 in_register_0000202d;
  
  _DAT_4000a588 =
       ~(1 << ((uint)timerCh + 1 & 0x1f)) & _DAT_4000a588 |
       CONCAT31(in_register_0000202d,countMode) << ((uint)timerCh + 1 & 0x1f);
  return;
}



void TIMER_ClearIntStatus(TIMER_Chan_Type timerCh,TIMER_Comp_ID_Type cmpNo)

{
  undefined3 in_register_00002029;
  uint *puVar1;
  
  puVar1 = (uint *)(CONCAT31(in_register_00002029,timerCh) * 4 + 0x4000a578);
  *puVar1 = 1 << ((uint)cmpNo & 0x1f) | *puVar1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type TIMER_Init(TIMER_CFG_Type *timerCfg)

{
  TIMER_Chan_Type timerCh;
  uint uVar1;
  uint uVar2;
  
  timerCh = timerCfg->timerCh;
  if (timerCh == TIMER_CH0) {
    _DAT_4000a500 = _DAT_4000a500 & 0xfffffff3;
    uVar1 = (uint)timerCfg->clkSrc << 2;
  }
  else {
    _DAT_4000a500 = _DAT_4000a500 & 0xffffff9f;
    uVar1 = (uint)timerCfg->clkSrc << 5;
  }
  _DAT_4000a500 = uVar1 | _DAT_4000a500;
  if (timerCh == TIMER_CH0) {
    uVar1 = 0xffff00ff;
    uVar2 = (uint)timerCfg->clockDivision << 8;
  }
  else {
    uVar1 = 0xff00ffff;
    uVar2 = (uint)timerCfg->clockDivision << 0x10;
  }
  _DAT_4000a5bc = uVar2 | uVar1 & _DAT_4000a5bc;
  TIMER_SetCountMode(timerCh,timerCfg->countMode);
  *(uint *)((uint)timerCh * 4 + 0x4000a55c) = (uint)timerCfg->plTrigSrc;
  if (timerCfg->countMode == TIMER_COUNT_PRELOAD) {
    *(uint32_t *)((uint)timerCh * 4 + 0x4000a550) = timerCfg->preLoadVal;
  }
  TIMER_SetCompValue(timerCh,TIMER_COMP_ID_0,timerCfg->matchVal0);
  TIMER_SetCompValue(timerCh,TIMER_COMP_ID_1,timerCfg->matchVal1);
  TIMER_SetCompValue(timerCh,TIMER_COMP_ID_2,timerCfg->matchVal2);
  return SUCCESS;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void TIMER_Enable(TIMER_Chan_Type timerCh)

{
  _DAT_4000a584 = 1 << ((uint)timerCh + 1 & 0x1f) | _DAT_4000a584;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void TIMER_Disable(TIMER_Chan_Type timerCh)

{
  _DAT_4000a584 = ~(1 << ((uint)timerCh + 1 & 0x1f)) & _DAT_4000a584;
  return;
}



void TIMER_IntMask(TIMER_Chan_Type timerCh,TIMER_INT_Type intType,BL_Mask_Type intMask)

{
  undefined3 in_register_00002029;
  uint *puVar1;
  undefined3 in_register_0000202d;
  int iVar2;
  undefined3 in_register_00002031;
  int iVar3;
  uint uVar4;
  
  iVar3 = CONCAT31(in_register_00002031,intMask);
  iVar2 = CONCAT31(in_register_0000202d,intType);
  puVar1 = (uint *)(CONCAT31(in_register_00002029,timerCh) * 4 + 0x4000a544);
  uVar4 = *puVar1;
  if (iVar2 == 1) {
    if (iVar3 == 0) {
      uVar4 = uVar4 | 2;
    }
    else {
      uVar4 = uVar4 & 0xfffffffd;
    }
    goto LAB_2305416e;
  }
  if (iVar2 == 0) {
    if (iVar3 == 0) {
      uVar4 = uVar4 | 1;
    }
    else {
      uVar4 = uVar4 & 0xfffffffe;
    }
    goto LAB_2305416e;
  }
  if (iVar2 == 2) {
    if (iVar3 != 0) goto LAB_230541a6;
  }
  else {
    if (iVar2 != 3) {
      return;
    }
    if (iVar3 != 0) {
      *puVar1 = uVar4 & 0xfffffffe;
      *puVar1 = uVar4 & 0xfffffffd;
LAB_230541a6:
      uVar4 = uVar4 & 0xfffffffb;
      goto LAB_2305416e;
    }
    *puVar1 = uVar4 | 1;
    *puVar1 = uVar4 | 2;
  }
  uVar4 = uVar4 | 4;
LAB_2305416e:
  *puVar1 = uVar4;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void WDT_Set_Clock(TIMER_ClkSrc_Type clkSrc,uint8_t div)

{
  undefined3 in_register_00002029;
  
  _DAT_4000a500 = CONCAT31(in_register_00002029,clkSrc) << 8 | _DAT_4000a500 & 0xfffffcff;
  _DAT_4000a5bc = _DAT_4000a5bc & 0xffffff | (uint)div << 0x18;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void WDT_SetCompValue(uint16_t val)

{
  undefined2 in_register_0000202a;
  
  _DAT_4000a568 = CONCAT22(in_register_0000202a,val);
  _DAT_4000a59c = _DAT_4000a59c & 0xffff0000 | 0xbaba;
  _DAT_4000a5a0 = _DAT_4000a5a0 & 0xffff0000 | 0xeb10;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void WDT_ResetCounterValue(void)

{
  _DAT_4000a598 = _DAT_4000a598 | 1;
  _DAT_4000a59c = _DAT_4000a59c & 0xffff0000 | 0xbaba;
  _DAT_4000a5a0 = _DAT_4000a5a0 & 0xffff0000 | 0xeb10;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void WDT_Enable(void)

{
  _DAT_4000a564 = _DAT_4000a564 | 1;
  _DAT_4000a59c = _DAT_4000a59c & 0xffff0000 | 0xbaba;
  _DAT_4000a5a0 = _DAT_4000a5a0 & 0xffff0000 | 0xeb10;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void WDT_Disable(void)

{
  _DAT_4000a564 = _DAT_4000a564 & 0xfffffffe;
  _DAT_4000a59c = _DAT_4000a59c & 0xffff0000 | 0xbaba;
  _DAT_4000a5a0 = _DAT_4000a5a0 & 0xffff0000 | 0xeb10;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void WDT_IntMask(WDT_INT_Type intType,BL_Mask_Type intMask)

{
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  
  if (CONCAT31(in_register_00002029,intType) == 0) {
    if (CONCAT31(in_register_0000202d,intMask) == 0) {
      _DAT_4000a564 = _DAT_4000a564 & 0xfffffffd;
    }
    else {
      _DAT_4000a564 = _DAT_4000a564 | 2;
    }
  }
  _DAT_4000a59c = _DAT_4000a59c & 0xffff0000 | 0xbaba;
  _DAT_4000a5a0 = _DAT_4000a5a0 & 0xffff0000 | 0xeb10;
  return;
}



uint32_t EF_Ctrl_Get_Byte_Zero_Cnt(uint8_t val)

{
  undefined3 in_register_00002029;
  uint32_t uVar1;
  uint uVar2;
  
  uVar2 = 0;
  uVar1 = 0;
  do {
    if ((CONCAT31(in_register_00002029,val) >> (uVar2 & 0x1f) & 1U) == 0) {
      uVar1 = uVar1 + 1;
    }
    uVar2 = uVar2 + 1;
  } while (uVar2 != 8);
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type EF_Ctrl_Read_MAC_Address(uint8_t *mac)

{
  uint8_t uVar1;
  undefined4 uVar2;
  uint uVar3;
  BL_Err_Type BVar4;
  uint32_t uVar5;
  uint8_t *puVar6;
  uint8_t *puVar7;
  uint8_t *puVar8;
  int iVar9;
  uint uVar10;
  
  EF_Ctrl_Load_Efuse_R0();
  uVar2 = _DAT_40007014;
  uVar10 = 0;
  iVar9 = 0;
  *mac = (uint8_t)_DAT_40007014;
  mac[1] = (uint8_t)((uint)uVar2 >> 8);
  mac[3] = (uint8_t)((uint)uVar2 >> 0x18);
  mac[2] = (uint8_t)((uint)uVar2 >> 0x10);
  uVar3 = _DAT_40007018;
  mac[4] = (uint8_t)_DAT_40007018;
  mac[5] = (uint8_t)(uVar3 >> 8);
  do {
    puVar7 = mac + iVar9;
    iVar9 = iVar9 + 1;
    uVar5 = EF_Ctrl_Get_Byte_Zero_Cnt(*puVar7);
    uVar10 = uVar10 + uVar5;
  } while (iVar9 != 6);
  BVar4 = ERROR;
  if (((uVar3 >> 0x10 ^ uVar10) & 0x3f) == 0) {
    puVar6 = mac + 2;
    puVar7 = mac + 5;
    do {
      uVar1 = *mac;
      puVar8 = puVar7 + -1;
      *mac = *puVar7;
      *puVar7 = uVar1;
      mac = mac + 1;
      puVar7 = puVar8;
    } while (puVar8 != puVar6);
    BVar4 = SUCCESS;
  }
  return BVar4;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t EF_Ctrl_Is_MAC_Address_Slot_Empty(uint8_t slot,uint8_t reload)

{
  undefined3 in_register_00002029;
  int iVar1;
  undefined3 in_register_0000202d;
  int iVar2;
  uint uVar3;
  uint uVar4;
  
  iVar2 = CONCAT31(in_register_0000202d,reload);
  iVar1 = CONCAT31(in_register_00002029,slot);
  if (iVar1 == 0) {
    EF_Ctrl_Sw_AHB_Clk_0();
    uVar3 = _DAT_40007014;
    uVar4 = _DAT_40007018;
    if (iVar2 != 0) {
      EF_Ctrl_Load_Efuse_R0();
      uVar3 = _DAT_40007014;
      uVar4 = _DAT_40007018;
    }
  }
  else {
    if (iVar1 == 1) {
      EF_Ctrl_Sw_AHB_Clk_0();
      uVar3 = _DAT_4000706c;
      uVar4 = _DAT_40007070;
      if (iVar2 != 0) {
        EF_Ctrl_Load_Efuse_R0();
        uVar3 = _DAT_4000706c;
        uVar4 = _DAT_40007070;
      }
    }
    else {
      if (iVar1 != 2) {
        return '\0';
      }
      EF_Ctrl_Sw_AHB_Clk_0();
      uVar3 = _DAT_40007004;
      uVar4 = _DAT_40007008;
      if (iVar2 != 0) {
        EF_Ctrl_Load_Efuse_R0();
        uVar3 = _DAT_40007004;
        uVar4 = _DAT_40007008;
      }
    }
  }
  if ((uVar4 & 0x3fffff | uVar3) != 0) {
    return '\0';
  }
  return '\x01';
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type EF_Ctrl_Read_MAC_Address_Opt(uint8_t slot,uint8_t *mac,uint8_t reload)

{
  uint8_t uVar1;
  uint uVar2;
  BL_Err_Type BVar3;
  undefined3 in_register_00002029;
  uint32_t uVar4;
  undefined3 in_register_00002031;
  uint8_t *puVar5;
  undefined4 uVar6;
  uint8_t *puVar7;
  uint8_t *puVar8;
  int iVar9;
  uint uVar10;
  
  uVar10 = CONCAT31(in_register_00002029,slot);
  if (2 < uVar10) {
    return ERROR;
  }
  if (CONCAT31(in_register_00002031,reload) == 0) {
LAB_23054456:
    uVar6 = _DAT_40007014;
    if ((uVar10 == 0) || (uVar6 = _DAT_4000706c, uVar10 == 1)) goto LAB_2305445e;
  }
  else {
    if (uVar10 != 2) {
      EF_Ctrl_Load_Efuse_R0();
      goto LAB_23054456;
    }
    EF_Ctrl_Load_Efuse_R0();
  }
  uVar6 = _DAT_40007004;
LAB_2305445e:
  *mac = (uint8_t)uVar6;
  mac[1] = (uint8_t)((uint)uVar6 >> 8);
  mac[2] = (uint8_t)((uint)uVar6 >> 0x10);
  mac[3] = (uint8_t)((uint)uVar6 >> 0x18);
  uVar2 = _DAT_40007018;
  if ((uVar10 != 0) && (uVar2 = _DAT_40007008, uVar10 == 1)) {
    uVar2 = _DAT_40007070;
  }
  mac[4] = (uint8_t)uVar2;
  mac[5] = (uint8_t)(uVar2 >> 8);
  uVar10 = 0;
  iVar9 = 0;
  do {
    puVar7 = mac + iVar9;
    iVar9 = iVar9 + 1;
    uVar4 = EF_Ctrl_Get_Byte_Zero_Cnt(*puVar7);
    uVar10 = uVar10 + uVar4;
  } while (iVar9 != 6);
  BVar3 = ERROR;
  if (((uVar2 >> 0x10 ^ uVar10) & 0x3f) == 0) {
    puVar5 = mac + 2;
    puVar7 = mac + 5;
    do {
      uVar1 = *mac;
      puVar8 = puVar7 + -1;
      *mac = *puVar7;
      *puVar7 = uVar1;
      mac = mac + 1;
      puVar7 = puVar8;
    } while (puVar5 != puVar8);
    BVar3 = SUCCESS;
  }
  return BVar3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint EF_Ctrl_Is_CapCode_Slot_Empty(int param_1,int param_2)

{
  uint uVar1;
  
  EF_Ctrl_Sw_AHB_Clk_0();
  if (param_2 != 0) {
    EF_Ctrl_Load_Efuse_R0();
  }
  if (param_1 == 0) {
    uVar1 = _DAT_4000700c >> 2;
  }
  else {
    uVar1 = _DAT_40007070;
    if ((param_1 != 1) && (uVar1 = _DAT_40007008, param_1 != 2)) {
      return 0;
    }
    uVar1 = uVar1 >> 0x16;
  }
  return (uint)((uVar1 & 0xff) == 0);
}



// WARNING: Variable defined which should be unmapped: tmp
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type EF_Ctrl_Read_CapCode_Opt(uint8_t slot,uint8_t *code,uint8_t reload)

{
  uint8_t uVar1;
  undefined3 in_register_00002029;
  uint uVar2;
  undefined3 extraout_var;
  undefined3 in_register_00002031;
  uint uVar3;
  uint32_t tmp;
  
  uVar2 = CONCAT31(in_register_00002029,slot);
  if (2 < uVar2) {
    return ERROR;
  }
  EF_Ctrl_Sw_AHB_Clk_0();
  if (CONCAT31(in_register_00002031,reload) != 0) {
    EF_Ctrl_Load_Efuse_R0();
  }
  if (uVar2 == 0) {
    uVar3 = _DAT_4000700c >> 2;
  }
  else {
    uVar3 = _DAT_40007008;
    if (uVar2 == 1) {
      uVar3 = _DAT_40007070;
    }
    uVar3 = uVar3 >> 0x16;
  }
  if ((uVar3 & 0x80) != 0) {
    uVar1 = EF_Ctrl_Get_Trim_Parity(uVar3 & 0x3f,'\x06');
    if ((uVar3 >> 6 & 1) == CONCAT31(extraout_var,uVar1)) {
      *code = (uint8_t)(uVar3 & 0x3f);
      return SUCCESS;
    }
  }
  return ERROR;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t EF_Ctrl_Is_PowerOffset_Slot_Empty(uint8_t slot,uint8_t reload)

{
  byte bVar1;
  undefined3 in_register_00002029;
  int iVar2;
  undefined3 in_register_0000202d;
  byte bVar3;
  uint uVar4;
  
  iVar2 = CONCAT31(in_register_00002029,slot);
  EF_Ctrl_Sw_AHB_Clk_0();
  if (CONCAT31(in_register_0000202d,reload) != 0) {
    EF_Ctrl_Load_Efuse_R0();
  }
  if (iVar2 == 0) {
    bVar3 = 1;
    uVar4 = _DAT_40007078 >> 0xf;
  }
  else {
    if (iVar2 == 1) {
      bVar3 = (byte)_DAT_4000700c;
      uVar4 = _DAT_40007074 & 0xffff;
    }
    else {
      if (iVar2 != 2) {
        return '\0';
      }
      uVar4 = _DAT_40007074 >> 0x10;
      bVar3 = (byte)(_DAT_4000700c >> 1);
    }
    bVar3 = ~bVar3 & 1;
  }
  bVar1 = 0;
  if (uVar4 == 0) {
    bVar1 = bVar3;
  }
  return (uint8_t)bVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type EF_Ctrl_Read_PowerOffset_Opt(uint8_t slot,int8_t *pwrOffset,uint8_t reload)

{
  uint uVar1;
  int iVar2;
  uint32_t val;
  uint8_t uVar3;
  undefined3 in_register_00002029;
  undefined3 extraout_var;
  uint32_t uVar4;
  undefined3 in_register_00002031;
  byte bVar5;
  uint uVar6;
  undefined4 uVar7;
  
  iVar2 = CONCAT31(in_register_00002029,slot);
  uVar7 = EF_Ctrl_Sw_AHB_Clk_0();
  if (CONCAT31(in_register_00002031,reload) != 0) {
    EF_Ctrl_Load_Efuse_R0(uVar7);
  }
  if (iVar2 == 0) {
    val = (_DAT_40007078 << 1) >> 0x11;
    uVar1 = _DAT_40007078 >> 0x1f;
    uVar6 = _DAT_40007078 >> 0xf;
  }
  else {
    if (iVar2 == 1) {
      val = _DAT_40007074 & 0x7fff;
      uVar1 = _DAT_40007074 >> 0xf & 1;
      uVar6 = _DAT_4000700c;
    }
    else {
      if (iVar2 != 2) {
        return ERROR;
      }
      val = (_DAT_40007074 << 1) >> 0x11;
      uVar1 = _DAT_40007074 >> 0x1f;
      uVar6 = _DAT_4000700c >> 1;
    }
  }
  if (((uVar6 & 1) != 0) &&
     (uVar3 = EF_Ctrl_Get_Trim_Parity(val,'\x0f'), CONCAT31(extraout_var,uVar3) == uVar1)) {
    iVar2 = 0;
    do {
      uVar4 = val;
      __lshrdi3(val);
      bVar5 = (byte)uVar4 & 0x1f;
      if ((uVar4 & 0x10) != 0) {
        bVar5 = bVar5 - 0x20;
      }
      pwrOffset[iVar2] = bVar5;
      iVar2 = iVar2 + 1;
    } while (iVar2 != 3);
    return SUCCESS;
  }
  return ERROR;
}



int8_t mfg_media_read_xtal_capcode(uint8_t *capcode,uint8_t reload)

{
  int8_t iVar1;
  
  if (rf_para_on_flash != '\0') {
    iVar1 = mfg_flash_read_xtal_capcode(capcode,reload);
    return iVar1;
  }
  iVar1 = mfg_efuse_read_xtal_capcode(capcode,reload);
  return iVar1;
}



int8_t mfg_media_read_poweroffset(int8_t *pwrOffset,uint8_t reload)

{
  int8_t iVar1;
  
  if (rf_para_on_flash != '\0') {
    iVar1 = mfg_flash_read_poweroffset(pwrOffset,reload);
    return iVar1;
  }
  iVar1 = mfg_efuse_read_poweroffset(pwrOffset,reload);
  return iVar1;
}



int8_t mfg_media_read_macaddr(uint8_t *mac,uint8_t reload)

{
  int8_t iVar1;
  
  if (rf_para_on_flash != '\0') {
    iVar1 = mfg_flash_read_macaddr(mac,reload);
    return iVar1;
  }
  iVar1 = mfg_efuse_read_macaddr(mac,reload);
  return iVar1;
}



void bflb_platform_usart_dbg_send(uint8_t *data,uint32_t len)

{
  UART_SendData(UART0_ID,data,len);
  return;
}



void bflb_platform_printf(char *fmt,...)

{
  char print_buf [128];
  size_t len;
  undefined4 in_a1;
  undefined4 in_a2;
  undefined4 in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list ap;
  undefined4 uStack28;
  undefined4 uStack24;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  undefined4 uStack8;
  undefined4 uStack4;
  
  if (uart_dbg_disable == '\0') {
    uStack28 = in_a1;
    uStack24 = in_a2;
    uStack20 = in_a3;
    uStack16 = in_a4;
    uStack12 = in_a5;
    uStack8 = in_a6;
    uStack4 = in_a7;
    vsnprintf((char *)&ram0x42016b80,0x7f,fmt,&uStack28);
    len = strlen((char *)0x42016b80);
    bflb_platform_usart_dbg_send((uint8_t *)0x42016b80,len);
  }
  return;
}



// WARNING: Control flow encountered bad instruction data

void Default_Handler_Stub(void)

{
                    // WARNING: Bad instruction - Truncating control flow here
  halt_baddata();
}



int8_t mfg_efuse_read_xtal_capcode(uint8_t *capcode,uint8_t reload)

{
  uint8_t bclkDiv;
  uint8_t hclkDiv;
  BL_Err_Type BVar1;
  int iVar2;
  undefined3 extraout_var;
  undefined3 in_register_0000202d;
  undefined4 uVar3;
  
  uVar3 = CONCAT31(in_register_0000202d,reload);
  bclkDiv = GLB_Get_BCLK_Div();
  hclkDiv = GLB_Get_HCLK_Div();
  HBN_Set_ROOT_CLK_Sel(HBN_ROOT_CLK_XTAL);
  if ((rf_cal_slots < 3) || (iVar2 = EF_Ctrl_Is_CapCode_Slot_Empty(2,uVar3), iVar2 != 0)) {
    if ((rf_cal_slots < 2) || (iVar2 = EF_Ctrl_Is_CapCode_Slot_Empty(1,uVar3), iVar2 != 0)) {
      if ((rf_cal_slots == '\0') || (iVar2 = EF_Ctrl_Is_CapCode_Slot_Empty(0,uVar3), iVar2 != 0)) {
        printf("No written slot found\r\n");
        iVar2 = 1;
        goto LAB_230548ee;
      }
    }
    else {
      iVar2 = 1;
    }
  }
  else {
    iVar2 = 2;
  }
  printf("Read slot:%d\r\n",iVar2);
  BVar1 = EF_Ctrl_Read_CapCode_Opt((uint8_t)iVar2,capcode,reload);
  iVar2 = CONCAT31(extraout_var,BVar1);
LAB_230548ee:
  GLB_Set_System_CLK_Div(hclkDiv,bclkDiv);
  HBN_Set_ROOT_CLK_Sel(HBN_ROOT_CLK_PLL);
  return (int8_t)-(iVar2 != 0);
}



int8_t mfg_efuse_read_poweroffset(int8_t *pwrOffset,uint8_t reload)

{
  int iVar1;
  uint8_t bclkDiv;
  uint8_t hclkDiv;
  uint8_t uVar2;
  BL_Err_Type BVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  int iVar4;
  int iVar5;
  int8_t iStack36;
  char cStack35;
  char cStack34;
  int8_t pwrOffsetTmp [3];
  
  bclkDiv = GLB_Get_BCLK_Div();
  hclkDiv = GLB_Get_HCLK_Div();
  HBN_Set_ROOT_CLK_Sel(HBN_ROOT_CLK_XTAL);
  if ((rf_cal_slots < 3) ||
     (uVar2 = EF_Ctrl_Is_PowerOffset_Slot_Empty('\x02',reload), CONCAT31(extraout_var_00,uVar2) != 0
     )) {
    if ((rf_cal_slots < 2) ||
       (uVar2 = EF_Ctrl_Is_PowerOffset_Slot_Empty('\x01',reload), CONCAT31(extraout_var,uVar2) != 0)
       ) {
      if (rf_cal_slots != '\0') {
        uVar2 = EF_Ctrl_Is_PowerOffset_Slot_Empty('\0',reload);
        iVar1 = CONCAT31(extraout_var_01,uVar2);
        if (iVar1 == 0) goto LAB_230549a8;
      }
      printf("No written slot found\r\n");
      iVar1 = 1;
      goto LAB_23054aca;
    }
    iVar1 = 1;
  }
  else {
    iVar1 = 2;
  }
LAB_230549a8:
  printf("Read slot:%d\r\n",iVar1);
  BVar3 = EF_Ctrl_Read_PowerOffset_Opt((uint8_t)iVar1,&iStack36,reload);
  iVar1 = CONCAT31(extraout_var_02,BVar3);
  memset(pwrOffset,0,0xe);
  *pwrOffset = iStack36;
  pwrOffset[6] = cStack35;
  pwrOffset[0xc] = cStack34;
  iVar4 = (((int)cStack35 - (int)iStack36) * 100) / 6;
  pwrOffset[2] = (char)((iVar4 + 0x19) / 0x32) + iStack36;
  pwrOffset[3] = (char)((iVar4 * 3 + 0x32) / 100) + iStack36;
  pwrOffset[4] = (char)((iVar4 * 4 + 0x32) / 100) + iStack36;
  pwrOffset[1] = (char)((iVar4 + 0x32) / 100) + iStack36;
  iVar5 = (((int)cStack34 - (int)cStack35) * 100) / 6;
  pwrOffset[5] = (char)((iVar4 * 5 + 0x32) / 100) + iStack36;
  pwrOffset[8] = (char)((iVar5 + 0x19) / 0x32) + cStack35;
  pwrOffset[0xb] = (char)((iVar5 * 5 + 0x32) / 100) + cStack35;
  pwrOffset[9] = (char)((iVar5 * 3 + 0x32) / 100) + cStack35;
  pwrOffset[7] = (char)((iVar5 + 0x32) / 100) + cStack35;
  pwrOffset[10] = (char)((iVar5 * 4 + 0x32) / 100) + cStack35;
  pwrOffset[0xd] = (char)((iVar5 * 7 + 0x32) / 100) + cStack35;
LAB_23054aca:
  GLB_Set_System_CLK_Div(hclkDiv,bclkDiv);
  HBN_Set_ROOT_CLK_Sel(HBN_ROOT_CLK_PLL);
  return (int8_t)-(iVar1 != 0);
}



int8_t mfg_efuse_read_macaddr(uint8_t *mac,uint8_t reload)

{
  int iVar1;
  uint8_t bclkDiv;
  uint8_t hclkDiv;
  uint8_t uVar2;
  BL_Err_Type BVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  
  bclkDiv = GLB_Get_BCLK_Div();
  hclkDiv = GLB_Get_HCLK_Div();
  HBN_Set_ROOT_CLK_Sel(HBN_ROOT_CLK_XTAL);
  if ((rf_cal_slots < 3) ||
     (uVar2 = EF_Ctrl_Is_MAC_Address_Slot_Empty('\x02',reload), CONCAT31(extraout_var_00,uVar2) != 0
     )) {
    if ((rf_cal_slots < 2) ||
       (uVar2 = EF_Ctrl_Is_MAC_Address_Slot_Empty('\x01',reload), CONCAT31(extraout_var,uVar2) != 0)
       ) {
      if (rf_cal_slots != '\0') {
        uVar2 = EF_Ctrl_Is_MAC_Address_Slot_Empty('\0',reload);
        iVar1 = CONCAT31(extraout_var_01,uVar2);
        if (iVar1 == 0) goto LAB_23054b82;
      }
      printf("No written slot found\r\n");
      iVar1 = 1;
      goto LAB_23054b9c;
    }
    iVar1 = 1;
  }
  else {
    iVar1 = 2;
  }
LAB_23054b82:
  printf("Read slot:%d\r\n",iVar1);
  BVar3 = EF_Ctrl_Read_MAC_Address_Opt((uint8_t)iVar1,mac,reload);
  iVar1 = CONCAT31(extraout_var_02,BVar3);
LAB_23054b9c:
  GLB_Set_System_CLK_Div(hclkDiv,bclkDiv);
  HBN_Set_ROOT_CLK_Sel(HBN_ROOT_CLK_PLL);
  return (int8_t)-(iVar1 != 0);
}


/*
Unable to decompile 'mfg_flash_read'
Cause: Exception while decompiling 23054bce: Decompiler process died

*/


int8_t mfg_flash_read_xtal_capcode(uint8_t *capcode,uint8_t reload)

{
  uint32_t uVar1;
  int8_t iVar2;
  undefined3 extraout_var;
  uint32_t uVar3;
  undefined3 in_register_0000202d;
  
  if ((((CONCAT31(in_register_0000202d,reload) == 0) ||
       (iVar2 = mfg_flash_read(), CONCAT31(extraout_var,iVar2) == 0)) &&
      (uVar1 = rf_para.crc32, rf_para.magic == 0x41)) &&
     ((uVar3 = BFLB_Soft_CRC32(&rf_para.capcode_valid,0x10), uVar1 == uVar3 &&
      (rf_para.capcode_valid == 'Z')))) {
    iVar2 = '\0';
    *capcode = rf_para.capcode;
  }
  else {
    iVar2 = -1;
  }
  return iVar2;
}



int8_t mfg_flash_read_poweroffset(int8_t *pwrOffset,uint8_t reload)

{
  int8_t iVar1;
  int8_t iVar2;
  uint32_t uVar3;
  int8_t iVar4;
  undefined3 extraout_var;
  uint32_t uVar5;
  undefined3 in_register_0000202d;
  int iVar6;
  int iVar7;
  int iVar8;
  
  if ((((CONCAT31(in_register_0000202d,reload) == 0) ||
       (iVar4 = mfg_flash_read(), CONCAT31(extraout_var,iVar4) == 0)) &&
      (uVar3 = rf_para.crc32, rf_para.magic == 0x41)) &&
     ((uVar5 = BFLB_Soft_CRC32(&rf_para.capcode_valid,0x10), uVar3 == uVar5 &&
      (rf_para.poweroffset_valid == 'Z')))) {
    memset(pwrOffset,0,0xe);
    iVar2 = rf_para.poweroffset[2];
    iVar1 = rf_para.poweroffset[1];
    iVar4 = rf_para.poweroffset[0];
    iVar8 = (int)rf_para.poweroffset[1];
    iVar6 = (int)rf_para.poweroffset[0];
    iVar7 = (int)rf_para.poweroffset[2];
    *pwrOffset = rf_para.poweroffset[0];
    pwrOffset[6] = iVar1;
    pwrOffset[0xc] = iVar2;
    iVar6 = ((iVar8 - iVar6) * 100) / 6;
    pwrOffset[2] = (char)((iVar6 + 0x19) / 0x32) + iVar4;
    pwrOffset[3] = (char)((iVar6 * 3 + 0x32) / 100) + iVar4;
    pwrOffset[4] = (char)((iVar6 * 4 + 0x32) / 100) + iVar4;
    pwrOffset[1] = (char)((iVar6 + 0x32) / 100) + iVar4;
    iVar7 = ((iVar7 - iVar8) * 100) / 6;
    pwrOffset[5] = iVar4 + (char)((iVar6 * 5 + 0x32) / 100);
    pwrOffset[8] = (char)((iVar7 + 0x19) / 0x32) + iVar1;
    pwrOffset[10] = (char)((iVar7 * 4 + 0x32) / 100) + iVar1;
    pwrOffset[7] = (char)((iVar7 + 0x32) / 100) + iVar1;
    pwrOffset[9] = (char)((iVar7 * 3 + 0x32) / 100) + iVar1;
    pwrOffset[0xb] = (char)((iVar7 * 5 + 0x32) / 100) + iVar1;
    iVar4 = '\0';
    pwrOffset[0xd] = (char)((iVar7 * 7 + 0x32) / 100) + iVar1;
  }
  else {
    iVar4 = -1;
  }
  return iVar4;
}



int8_t mfg_flash_read_macaddr(uint8_t *mac,uint8_t reload)

{
  uint32_t uVar1;
  int8_t iVar2;
  undefined3 extraout_var;
  uint32_t uVar3;
  undefined3 in_register_0000202d;
  
  if ((CONCAT31(in_register_0000202d,reload) == 0) ||
     (iVar2 = mfg_flash_read(), CONCAT31(extraout_var,iVar2) == 0)) {
    uVar1 = rf_para.crc32;
    if ((rf_para.magic == 0x41) &&
       ((uVar3 = BFLB_Soft_CRC32(&rf_para.capcode_valid,0x10), uVar1 == uVar3 &&
        (rf_para.mac_valid == 'Z')))) {
      memcpy(mac,rf_para.mac,6);
      return '\0';
    }
  }
  else {
    printf("mfg_flash_read fail\r\n");
  }
  return -1;
}



void Bl_F(uchar *digest,uchar *digest1,char *password,uchar *ssid,int ssidlength,int iterations,
         int count,uchar *output)

{
  int iVar1;
  size_t key_len;
  byte *pbVar2;
  uchar *puVar3;
  byte *pbVar4;
  int iVar5;
  int iStack56;
  int tmpLen;
  uchar *pTemp;
  
  key_len = strlen(password);
  iStack56 = ssidlength + 4;
  tmpLen = (int)digest;
  memcpy(digest,ssid,ssidlength);
  puVar3 = digest + ssidlength;
  *puVar3 = (uchar)((uint)count >> 0x18);
  puVar3[1] = (uchar)((uint)count >> 0x10);
  puVar3[2] = (uchar)((uint)count >> 8);
  puVar3[3] = (uchar)count;
  Bl_hmac_sha1((uchar **)&tmpLen,&iStack56,1,(uchar *)password,key_len,digest1,0x14);
  memcpy(output,digest1,0x14);
  iVar1 = 1;
  tmpLen = (int)digest1;
  while (iVar1 < iterations) {
    iStack56 = 0x14;
    Bl_hmac_sha1((uchar **)&tmpLen,&iStack56,1,(uchar *)password,key_len,digest,0x14);
    memcpy(digest1,digest,0x14);
    iVar5 = 0;
    do {
      pbVar2 = output + iVar5;
      pbVar4 = digest + iVar5;
      iVar5 = iVar5 + 1;
      *pbVar2 = *pbVar4 ^ *pbVar2;
    } while (iVar5 != 0x14);
    iVar1 = iVar1 + 1;
  }
  return;
}



int Bl_PasswordHash(char *password,uchar *ssid,int ssidlength,uchar *output)

{
  size_t sVar1;
  int iVar2;
  uchar auStack88 [4];
  uchar digest1 [20];
  uchar digest [36];
  
  sVar1 = strlen(password);
  if (sVar1 < 0x40) {
    iVar2 = -1;
    if (ssidlength < 0x21) {
      Bl_F(digest1 + 0x10,auStack88,password,ssid,ssidlength,0x1000,2,output);
      memcpy(output + 0x14,output,0xc);
      Bl_F(digest1 + 0x10,auStack88,password,ssid,ssidlength,0x1000,1,output);
      iVar2 = 0;
    }
  }
  else {
    iVar2 = -1;
  }
  return iVar2;
}



int bl60x_fw_password_hash(char *password,uchar *ssid,int ssidlength,uchar *output)

{
  size_t sVar1;
  int iVar2;
  uchar auStack88 [20];
  uchar auStack68 [48];
  
  sVar1 = strlen(password);
  if (sVar1 < 0x40) {
    iVar2 = -1;
    if (ssidlength < 0x21) {
      Bl_F(auStack68,auStack88,password,ssid,ssidlength,0x1000,2,output);
      memcpy(output + 0x14,output,0xc);
      Bl_F(auStack68,auStack88,password,ssid,ssidlength,0x1000,1,output);
      iVar2 = 0;
    }
  }
  else {
    iVar2 = -1;
  }
  return iVar2;
}



int bl_mtd_open(char *name,bl_mtd_handle_t *handle,uint flags)

{
  char *__dest;
  int iVar1;
  uint32_t uStack40;
  uint32_t addr;
  uint32_t size;
  
  uStack40 = 0;
  addr = 0;
  __dest = (char *)pvPortMalloc(0x20);
  if (__dest == (char *)0x0) {
    iVar1 = -1;
  }
  else {
    memset(__dest,0,0x20);
    strncpy(__dest,name,0x10);
    if ((flags & 1) == 0) {
      if ((flags & 2) == 0) {
        *(undefined4 *)(__dest + 0x1c) = 0;
      }
      else {
        iVar1 = hal_boot2_partition_bus_addr_active(name,&uStack40,&addr);
        if ((iVar1 != 0) || (uStack40 == 0)) {
          printf("[MTD] [PART] [XIP] error when get %s partition %d\r\n",name,iVar1);
          printf("[MTD] [PART] [XIP] Dead Loop. Reason: no Valid %s partition found\r\n",name);
          do {
                    // WARNING: Do nothing block with infinite loop
          } while( true );
        }
        *(uint32_t *)(__dest + 0x1c) = uStack40;
      }
      iVar1 = hal_boot2_partition_addr_active(name,&uStack40,&addr);
      if ((iVar1 != 0) || (uStack40 == 0)) {
        printf("[MTD] [PART] [XIP] error when get %s partition %d\r\n",name,iVar1);
        printf("[MTD] [PART] [XIP] Dead Loop. Reason: no Valid %s partition found\r\n",name);
        do {
                    // WARNING: Do nothing block with infinite loop
        } while( true );
      }
    }
    else {
      if ((flags & 2) == 0) {
        *(undefined4 *)(__dest + 0x1c) = 0;
      }
      else {
        iVar1 = hal_boot2_partition_bus_addr_inactive(name,&uStack40,&addr);
        if ((iVar1 != 0) || (uStack40 == 0)) {
          printf("[MTD] [PART] [XIP] error when get %s partition %d\r\n",name,iVar1);
          printf("[MTD] [PART] [XIP] Dead Loop. Reason: no Valid %s partition found\r\n",name);
          do {
                    // WARNING: Do nothing block with infinite loop
          } while( true );
        }
        *(uint32_t *)(__dest + 0x1c) = uStack40;
      }
      iVar1 = hal_boot2_partition_addr_inactive(name,&uStack40,&addr);
      if ((iVar1 != 0) || (uStack40 == 0)) {
        printf("[MTD] [PART] [XIP] error when get %s partition %d\r\n",name,iVar1);
        printf("[MTD] [PART] [XIP] Dead Loop. Reason: no Valid %s partition found\r\n",name);
        do {
                    // WARNING: Do nothing block with infinite loop
        } while( true );
      }
    }
    *(uint32_t *)(__dest + 0x14) = uStack40;
    *(uint32_t *)(__dest + 0x18) = addr;
    puts("[MTD] >>>>>> Hanlde info Dump >>>>>>\r\n");
    printf("      name %s\r\n",__dest);
    printf("      id %d\r\n",*(undefined4 *)(__dest + 0x10));
    printf("      offset %p(%u)\r\n",*(undefined4 *)(__dest + 0x14));
    printf("      size %p(%uKbytes)\r\n",*(uint *)(__dest + 0x18),*(uint *)(__dest + 0x18) >> 10);
    printf("      xip_addr %p\r\n",*(undefined4 *)(__dest + 0x1c));
    puts("[MTD] <<<<<< Hanlde info End <<<<<<\r\n");
    iVar1 = 0;
    *(char **)handle = __dest;
  }
  return iVar1;
}



int bl_mtd_close(bl_mtd_handle_t handle)

{
  vPortFree(handle);
  return 0;
}



int bl_mtd_info(bl_mtd_handle_t handle,bl_mtd_info_t *info)

{
  strcpy((char *)info,(char *)handle);
  info->offset = *(uint *)((int)handle + 0x14);
  info->size = *(uint *)((int)handle + 0x18);
  info->xip_addr = *(void **)((int)handle + 0x1c);
  return 0;
}



int bl_mtd_erase(bl_mtd_handle_t handle,uint addr,uint size)

{
  bl_flash_erase(*(int *)((int)handle + 0x14) + addr,size);
  return 0;
}



int bl_mtd_erase_all(bl_mtd_handle_t handle)

{
  bl_flash_erase(*(uint32_t *)((int)handle + 0x14),*(int *)((int)handle + 0x18));
  return 0;
}



int bl_mtd_write(bl_mtd_handle_t handle,uint addr,uint size,uint8_t *data)

{
  uint32_t addr_00;
  int iVar1;
  TickType_t TVar2;
  uint __n;
  uint8_t auStack96 [4];
  uint8_t buf_tmp [64];
  
  addr_00 = *(int *)((int)handle + 0x14) + addr;
  iVar1 = bl_sys_isxipaddr((uint32_t)data);
  if (iVar1 == 0) {
    bl_flash_write(addr_00,data,size);
  }
  else {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] addr@%p is xip flash, size %d\r\n",TVar2,&DAT_23081ce8,"bl_mtd.c",
              0xc9,data,size);
    while (size != 0) {
      __n = size;
      if (0x40 < size) {
        __n = 0x40;
      }
      memcpy(auStack96,data,__n);
      bl_flash_write(addr_00,auStack96,__n);
      addr_00 = addr_00 + __n;
      data = data + __n;
      size = size - __n;
    }
  }
  return 0;
}



int bl_mtd_read(bl_mtd_handle_t handle,uint addr,uint size,uint8_t *data)

{
  bl_flash_read(*(int *)((int)handle + 0x14) + addr,data,size);
  return 0;
}



int bloop_init(loop_ctx *loop)

{
  loop_evt_handler_statistic *list;
  loop_evt_handler_statistic *plVar1;
  
  memset(loop,0,0x4a0);
  list = (loop_evt_handler_statistic *)loop->list;
  do {
    plVar1 = (loop_evt_handler_statistic *)&list->time_accumulated;
    utils_list_init((utils_list *)list);
    list = plVar1;
  } while (plVar1 != loop->statistic);
  *(utils_dlist_t **)&(loop->timer_dlist).next = &loop->timer_dlist;
  *(utils_dlist_t **)&(loop->timer_dlist).prev = &loop->timer_dlist;
  *(utils_dlist_t **)&(loop->timer_dued).next = &loop->timer_dued;
  *(utils_dlist_t **)&(loop->timer_dued).prev = &loop->timer_dued;
  printf("=== %d task inited\r\n",0x20);
  return 0;
}



int bloop_handler_register(loop_ctx *loop,loop_evt_handler *handler,int priority)

{
  if (((uint)priority < 0x20) && ((&loop->looper + priority)[0x104] == (TaskHandle_t)0x0)) {
    *(loop_evt_handler **)(&loop->looper + priority + 0x104) = handler;
    return 0;
  }
  return -1;
}



void bloop_timer_init(loop_timer *timer,int use_auto_free)

{
  memset(timer,0,0x24);
  *(loop_timer **)&(timer->dlist_item).prev = timer;
  *(loop_timer **)&(timer->dlist_item).next = timer;
  timer->flags = (use_auto_free != 0) << 1;
  return;
}



void bloop_timer_configure
               (loop_timer *timer,uint delay_ms,
               anon_subr_void_loop_ctx_ptr_loop_timer_ptr_void_ptr *cb,void *arg,int idx_task,
               uint32_t evt_type_map)

{
  TickType_t TVar1;
  
  TVar1 = xTaskGetTickCount();
  timer->time_added = TVar1;
  timer->time_target = TVar1 + delay_ms;
  *(anon_subr_void_loop_ctx_ptr_loop_timer_ptr_void_ptr **)&timer->cb = cb;
  timer->arg = arg;
  timer->idx_task = idx_task;
  timer->evt_type_map = evt_type_map;
  return;
}



void bloop_timer_repeat_enable(loop_timer *timer)

{
  timer->flags = timer->flags | 1;
  return;
}



void bloop_timer_repeat_reconfigure(loop_timer *timer)

{
  uint uVar1;
  uint uVar2;
  TickType_t TVar3;
  
  uVar1 = timer->time_target;
  uVar2 = timer->time_added;
  TVar3 = xTaskGetTickCount();
  timer->time_target = (uVar1 - uVar2) + TVar3;
  timer->time_added = TVar3;
  return;
}



void bloop_timer_register(loop_ctx *loop,loop_timer *timer)

{
  utils_dlist_s *puVar1;
  utils_dlist_s *puVar2;
  utils_dlist_s *puVar3;
  utils_dlist_s *puVar4;
  utils_dlist_s *puVar5;
  
  puVar2 = (loop->timer_dlist).next;
  puVar3 = (utils_dlist_s *)&loop->timer_dlist;
  if (puVar3 == puVar2) {
    (timer->dlist_item).next = puVar3;
    (timer->dlist_item).prev = puVar3;
    *(loop_timer **)&(loop->timer_dlist).next = timer;
    *(loop_timer **)&(loop->timer_dlist).prev = timer;
    return;
  }
  puVar1 = puVar2;
  puVar5 = (utils_dlist_s *)0x0;
  do {
    puVar4 = puVar1;
    if (puVar3 == puVar4) {
LAB_230553be:
      puVar2 = puVar5->next;
      (timer->dlist_item).prev = puVar5;
      (timer->dlist_item).next = puVar2;
      *(loop_timer **)&puVar5->next = timer;
      *(loop_timer **)&puVar2->prev = timer;
      return;
    }
    if ((int)(timer->time_target - (int)puVar4[2].prev) < 1) {
      if (puVar5 == (utils_dlist_s *)0x0) {
        (timer->dlist_item).next = puVar2;
        (timer->dlist_item).prev = puVar3;
        *(loop_timer **)&(loop->timer_dlist).next = timer;
        *(loop_timer **)&puVar2->prev = timer;
        return;
      }
      goto LAB_230553be;
    }
    puVar1 = puVar4->next;
    puVar5 = puVar4;
  } while( true );
}



void bloop_wait_startup(loop_ctx *loop)

{
  while (loop->looper == (TaskHandle_t)0x0) {
    vTaskDelay(1);
  }
  return;
}



void bloop_evt_set_async(loop_ctx *loop,uint evt,uint32_t evt_map)

{
  if (0x1f < evt) {
    printf("[ASSERT] [ERR] %s:%d\r\n","bloop_base.c",0x15a);
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  vTaskEnterCritical();
  loop->bitmap_evt_async = loop->bitmap_evt_async | 1 << (evt & 0x1f);
  (&loop->looper + evt)[4] = (TaskHandle_t)((uint)(&loop->looper + evt)[4] | evt_map);
  vTaskExitCritical();
  xTaskGenericNotify(loop->looper,0,eIncrement,(uint32_t *)0x0);
  return;
}



void bloop_evt_set_sync(loop_ctx *loop,uint evt,uint32_t evt_map)

{
  if (0x1f < evt) {
    printf("[ASSERT] [ERR] %s:%d\r\n","bloop_base.c",0x177);
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  loop->bitmap_evt_sync = loop->bitmap_evt_sync | 1 << (evt & 0x1f);
  (&loop->looper + evt)[4] = (TaskHandle_t)((uint)(&loop->looper + evt)[4] | evt_map);
  return;
}



void bloop_evt_unset_sync(loop_ctx *loop,uint evt)

{
  if (0x1f < evt) {
    printf("[ASSERT] [ERR] %s:%d\r\n","bloop_base.c",0x17f);
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  loop->bitmap_evt_sync = ~(1 << (evt & 0x1f)) & loop->bitmap_evt_sync;
  return;
}



void bloop_run(loop_ctx *param_1)

{
  loop_timer *plVar1;
  utils_dlist_t *puVar2;
  loop_timer *timer;
  TaskHandle_t ptVar3;
  TickType_t TVar4;
  uint32_t uVar5;
  uint32_t uVar6;
  int iVar7;
  int iVar8;
  utils_list_hdr *puVar9;
  utils_dlist_s *xTicksToWait;
  uint evt;
  TaskHandle_t ptVar10;
  utils_dlist_s *puVar11;
  utils_dlist_s *puVar12;
  TaskHandle_t *pptVar13;
  loop_timer *plVar14;
  utils_dlist_t *puVar15;
  
  ptVar3 = xTaskGetCurrentTaskHandle();
  param_1->looper = ptVar3;
LAB_230554f2:
  do {
    puVar15 = &param_1->timer_dlist;
    while( true ) {
      vTaskEnterCritical();
      evt = param_1->bitmap_evt_async;
      param_1->bitmap_evt_async = 0;
      param_1->bitmap_evt_sync = param_1->bitmap_evt_sync | evt;
      vTaskExitCritical();
      if (param_1->bitmap_evt_sync != 0) break;
      puVar2 = (utils_dlist_t *)(param_1->timer_dlist).next;
      xTicksToWait = (utils_dlist_s *)0xffffffff;
      if (puVar2 != puVar15) {
        xTicksToWait = puVar2[2].prev;
        TVar4 = xTaskGetTickCount();
        xTicksToWait = (utils_dlist_s *)((int)xTicksToWait - TVar4);
        if ((int)xTicksToWait < 1) break;
      }
      ulTaskNotifyTake(1,(TickType_t)xTicksToWait);
    }
    if ((utils_dlist_t *)(param_1->timer_dlist).next != puVar15) {
      TVar4 = xTaskGetTickCount();
      puVar2 = (utils_dlist_t *)(param_1->timer_dlist).next;
      xTicksToWait = (utils_dlist_s *)0x0;
      if (puVar2 != (utils_dlist_t *)0x0) {
        xTicksToWait = (&puVar2->prev)[1];
      }
      while ((puVar11 = xTicksToWait, puVar2 != puVar15 && (-1 < (int)(TVar4 - (int)puVar2[2].prev))
             )) {
        bloop_evt_set_sync(param_1,(uint)puVar2[2].next,(uint32_t)puVar2[3].prev);
        if (puVar2[3].next != (utils_dlist_s *)0x0) {
          (*(code *)puVar2[3].next)(param_1,puVar2,puVar2[4].prev);
        }
        puVar12 = (&puVar2->prev)[1];
        xTicksToWait = puVar2->prev;
        xTicksToWait->next = puVar12;
        puVar12->prev = xTicksToWait;
        xTicksToWait = (param_1->timer_dued).next;
        *(loop_timer **)&puVar2->prev = (loop_timer *)&param_1->timer_dued;
        (&puVar2->prev)[1] = xTicksToWait;
        *(utils_dlist_t **)&(param_1->timer_dued).next = puVar2;
        *(utils_dlist_t **)&xTicksToWait->prev = puVar2;
        puVar2 = (utils_dlist_t *)puVar11;
        xTicksToWait = (utils_dlist_s *)0x0;
        if (puVar11 != (utils_dlist_s *)0x0) {
          xTicksToWait = (&puVar11->prev)[1];
        }
      }
      timer = (loop_timer *)(param_1->timer_dued).next;
      plVar1 = (loop_timer *)0x0;
      if (timer != (loop_timer *)0x0) {
        plVar1 = (loop_timer *)(timer->dlist_item).next;
      }
      while (plVar14 = plVar1, timer != (loop_timer *)&param_1->timer_dued) {
        xTicksToWait = (timer->dlist_item).prev;
        puVar11 = (timer->dlist_item).next;
        xTicksToWait->next = puVar11;
        puVar11->prev = xTicksToWait;
        if ((timer->flags & 2) == 0) {
          if ((timer->flags & 1) != 0) {
            if ((_fsymc_level_bloop < BLOG_LEVEL_INFO) &&
               (_fsymf_level_bloopbloop_base < BLOG_LEVEL_INFO)) {
              if (TrapNetCounter == 0) {
                TVar4 = xTaskGetTickCount();
              }
              else {
                TVar4 = xTaskGetTickCountFromISR();
              }
              bl_printk("[%10u][%s: %s:%4d] Repeat timer\r\n",TVar4,"DEBUG ","bloop_base.c",0xbb);
            }
            bloop_timer_repeat_reconfigure(timer);
            bloop_timer_register(param_1,timer);
          }
        }
        else {
          if ((_fsymc_level_bloop < BLOG_LEVEL_INFO) &&
             (_fsymf_level_bloopbloop_base < BLOG_LEVEL_INFO)) {
            if (TrapNetCounter == 0) {
              TVar4 = xTaskGetTickCount();
            }
            else {
              TVar4 = xTaskGetTickCountFromISR();
            }
            bl_printk("[%10u][%s: %s:%4d] Free now\r\n",TVar4,"DEBUG ","bloop_base.c",0xb8);
          }
          vPortFree(timer);
        }
        timer = plVar14;
        plVar1 = (loop_timer *)0x0;
        if (plVar14 != (loop_timer *)0x0) {
          plVar1 = (loop_timer *)(plVar14->dlist_item).next;
        }
      }
    }
    iVar7 = __clzsi2(param_1->bitmap_evt_sync);
    iVar8 = __clzsi2(param_1->bitmap_msg);
    if (iVar7 <= iVar8) {
      evt = -iVar7 + 0x1f;
      if (evt != 0xffffffff) {
        pptVar13 = &param_1->looper + evt;
        ptVar3 = pptVar13[0x104];
        if (ptVar3 == (TaskHandle_t)0x0) {
          printf("[ASSERT] [ERR] %s:%d\r\n","bloop_base.c",0x105);
          do {
                    // WARNING: Do nothing block with infinite loop
          } while( true );
        }
        vTaskEnterCritical();
        ptVar10 = pptVar13[4];
        pptVar13[4] = (TaskHandle_t)0x0;
        pptVar13[0x24] = (TaskHandle_t)((uint)pptVar13[0x24] | (uint)ptVar10);
        vTaskExitCritical();
        uVar5 = bl_timer_now_us();
        (*(code *)(ptVar3->xStateListItem).xItemValue)
                  (param_1,(loop_evt_handler *)ptVar3,&param_1->bitmap_evt_sync,
                   (uint32_t *)(&param_1->looper + -iVar7 + 0x43));
        uVar6 = bl_timer_now_us();
        pptVar13 = &param_1->looper + evt * 4;
        ptVar3 = (TaskHandle_t)(uVar6 - uVar5);
        pptVar13[0x85] = ptVar3;
        pptVar13[0x86] = (TaskHandle_t)((int)pptVar13[0x86] + (int)ptVar3);
        if (pptVar13[0x84] < ptVar3) {
          pptVar13[0x84] = ptVar3;
        }
        pptVar13[0x87] = (TaskHandle_t)((int)&pptVar13[0x87]->pxTopOfStack + 1);
        bloop_evt_unset_sync(param_1,evt);
        goto LAB_230554f2;
      }
    }
    if ((-iVar8 != -0x20) &&
       (puVar9 = utils_list_pop_front((utils_list *)(&param_1->looper + (-iVar8 + 0x41) * 2)),
       puVar9 == (utils_list_hdr *)0x0)) {
      printf("[ASSERT] [ERR] %s:%d\r\n","bloop_base.c",0x124);
      do {
                    // WARNING: Do nothing block with infinite loop
      } while( true );
    }
  } while( true );
}



int bloop_status_dump(loop_ctx *loop)

{
  loop_evt_handler_statistic *plVar1;
  utils_dlist_s *puVar2;
  uint32_t *puVar3;
  TickType_t TVar4;
  char *pcVar5;
  uint32_t uVar6;
  int iVar7;
  uint32_t uVar8;
  uint32_t uVar9;
  
  puts("====== bloop dump ======\r\n");
  printf("  bitmap_evt %lx\r\n",loop->bitmap_evt_sync);
  printf("  bitmap_msg %lx\r\n",loop->bitmap_msg);
  TVar4 = xTaskGetTickCount();
  puts("--->>> timer list:\r\n");
  puVar2 = (loop->timer_dlist).next;
  iVar7 = 0;
  while ((utils_dlist_s *)&loop->timer_dlist != puVar2) {
    printf("    timer[%02d]: %u(diff %d)ms, \t\t task idx %02d, evt map %08lx, ptr %p\r\n",iVar7,
           puVar2[2].prev,TVar4 - (int)puVar2[2].prev,puVar2[2].next,puVar2[3].prev,puVar2[3].next);
    iVar7 = iVar7 + 1;
    puVar2 = puVar2->next;
  }
  puVar3 = loop->evt_type_map_async + 0x1f;
  printf("  %d task:\r\n",0x20);
  plVar1 = loop->statistic + 0x1f;
  iVar7 = 0x1f;
  do {
    pcVar5 = "empty";
    if ((char **)puVar3[0x100] != (char **)0x0) {
      pcVar5 = *(char **)puVar3[0x100];
    }
    printf("    task[%02d] : %s\r\n",iVar7,pcVar5);
    uVar8 = puVar3[0x100];
    if (uVar8 != 0) {
      uVar6 = puVar3[0x20];
      uVar9 = *puVar3;
      printf("      evt handler %p,",*(undefined4 *)(uVar8 + 4));
      printf(" msg handler %p,",*(undefined4 *)(uVar8 + 8));
      printf(" trigged cnt %u,",plVar1->count_triggered);
      printf(" bitmap async %lx sync %lx,",uVar9,uVar6);
      printf(" time consumed %dus acc %dms, max %uus\r\n",plVar1->time_consumed,
             plVar1->time_accumulated / 1000,plVar1->time_max);
    }
    iVar7 = iVar7 + -1;
    puVar3 = puVar3 + -1;
    plVar1 = plVar1 + -1;
  } while (iVar7 != -1);
  return 0;
}



int loop_evt_entity_sys_handler(loop_ctx *loop,loop_evt_handler *handler,loop_msg *msg)

{
  printf(
         "[SYS] [MSG] called with msg info\r\n    priority %u\r\n    dst %u\r\n    msgid %u\r\n    src %u\r\n    arg1 %p\r\n    arg2 %p\r\n"
         ,(uint)*(byte *)&msg->u,(uint)*(byte *)((int)&msg->u + 1),(uint)*(byte *)((int)&msg->u + 2)
         ,(uint)*(byte *)((int)&msg->u + 3),msg->arg1,msg->arg2);
  return 0;
}



int loop_evt_entity_sys_evt
              (loop_ctx *loop,loop_evt_handler *handler,uint32_t *bitmap_evt,uint32_t *evt_type_map)

{
  uint uVar1;
  
  uVar1 = *evt_type_map;
  printf("[SYS] [EVT] called with bitmap_evt %08lx, bitmap_task %08lx\r\n",*bitmap_evt,uVar1);
  do {
    if ((uVar1 & 1) == 0) {
      if (uVar1 != 0) {
        printf("[ASSERT] [ERR] %s:%d\r\n","bloop_handler_sys.c",0x2e);
        do {
                    // WARNING: Do nothing block with infinite loop
        } while( true );
      }
      break;
    }
    uVar1 = uVar1 & 0xfffffffe;
    bloop_status_dump(loop);
  } while (uVar1 != 0);
  *evt_type_map = 0;
  return 0;
}


/*
Unable to decompile 'misaligned_load_trap'
Cause: Exception while decompiling 23055930: Decompiler process died

*/

/*
Unable to decompile 'misaligned_store_trap'
Cause: Exception while decompiling 23055a82: Decompiler process died

*/


void get_f32_reg(void)

{
  uint in_t0;
  
                    // WARNING: Could not recover jumptable at 0x23055bd2. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)(in_t0 & 0xfffffffe))();
  return;
}



void put_f32_reg(void)

{
  uint in_t0;
  
                    // WARNING: Could not recover jumptable at 0x23055cd2. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)(in_t0 & 0xfffffffe))();
  return;
}



int backtrace_riscv(anon_subr_int_char_ptr *print_func,uintptr_t *regs)

{
  return -1;
}



// WARNING: Variable defined which should be unmapped: addr

void set_if(netif *netif,char *ip_addr,char *gw_addr,char *nm_addr)

{
  int iVar1;
  ip4_addr_t iStack20;
  ip4_addr_t addr;
  
  if ((ip_addr != (char *)0x0) && (iVar1 = ip4addr_aton(ip_addr,&iStack20), iVar1 != 0)) {
    netif_set_ipaddr(netif,&iStack20);
  }
  if ((gw_addr != (char *)0x0) && (iVar1 = ip4addr_aton(gw_addr,&iStack20), iVar1 != 0)) {
    netif_set_gw(netif,&iStack20);
  }
  if ((nm_addr != (char *)0x0) && (iVar1 = ip4addr_aton(nm_addr,&iStack20), iVar1 != 0)) {
    netif_set_netmask(netif,&iStack20);
  }
  return;
}



// WARNING: Variable defined which should be unmapped: buf
// WARNING: Could not reconcile some variable overlaps

int block_cipher_df(uchar *output,uchar *data,size_t data_len)

{
  uchar *__dest;
  uchar *puVar1;
  byte *pbVar2;
  byte *pbVar3;
  int iVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  uint32_t *puVar8;
  byte local_338 [4];
  uchar chain [16];
  uchar key [32];
  uchar tmp [48];
  mbedtls_aes_context aes_ctx;
  uchar buf [416];
  
  if (data_len < 0x181) {
    memset(aes_ctx.buf + 0x43,0,0x1a0);
    mbedtls_aes_init((mbedtls_aes_context *)(tmp + 0x2c));
    buf._14_2_ = (ushort)(data_len << 8) | (ushort)(data_len >> 8) & 0xff;
    buf[19] = '0';
    buf._12_2_ = 0;
    memcpy(buf + 0x14,data,data_len);
    buf[data_len + 0x14] = -0x80;
    iVar4 = 0;
    do {
      chain[iVar4 + 0xc] = (uchar)iVar4;
      iVar4 = iVar4 + 1;
    } while (iVar4 != 0x20);
    mbedtls_aes_setkey_enc((mbedtls_aes_context *)(tmp + 0x2c),chain + 0xc,0x100);
    iVar4 = 0;
    do {
      memset(local_338,0,0x10);
      puVar8 = aes_ctx.buf + 0x43;
      uVar7 = data_len + 0x19;
      do {
        iVar5 = 0;
        pbVar3 = local_338;
        do {
          pbVar2 = (byte *)((int)puVar8 + iVar5);
          iVar5 = iVar5 + 1;
          *pbVar3 = *pbVar2 ^ *pbVar3;
          pbVar3 = pbVar3 + 1;
        } while (iVar5 != 0x10);
        puVar8 = puVar8 + 4;
        uVar6 = uVar7;
        if (0x10 < uVar7) {
          uVar6 = 0x10;
        }
        uVar7 = uVar7 - uVar6;
        mbedtls_aes_crypt_ecb((mbedtls_aes_context *)(tmp + 0x2c),1,local_338,local_338);
      } while (uVar7 != 0);
      memcpy(key + iVar4 + 0x1c,local_338,0x10);
      iVar4 = iVar4 + 0x10;
      aes_ctx.buf[67]._3_1_ = aes_ctx.buf[67]._3_1_ + '\x01';
    } while (iVar4 != 0x30);
    mbedtls_aes_setkey_enc((mbedtls_aes_context *)(tmp + 0x2c),key + 0x1c,0x100);
    __dest = output;
    do {
      mbedtls_aes_crypt_ecb((mbedtls_aes_context *)(tmp + 0x2c),1,tmp + 0x1c,tmp + 0x1c);
      puVar1 = __dest + 0x10;
      memcpy(__dest,tmp + 0x1c,0x10);
      __dest = puVar1;
    } while (output + 0x30 != puVar1);
    mbedtls_aes_free((mbedtls_aes_context *)(tmp + 0x2c));
    return 0;
  }
  return -0x38;
}



// WARNING: Variable defined which should be unmapped: tmp

int ctr_drbg_update_internal(mbedtls_ctr_drbg_context_conflict *ctx,uchar *data)

{
  bool bVar1;
  byte *output;
  mbedtls_ctr_drbg_context_conflict *pmVar2;
  byte *pbVar3;
  uchar uVar4;
  int iVar5;
  byte local_50 [4];
  uchar tmp [48];
  
  iVar5 = 0;
  memset(local_50,0,0x30);
  do {
    output = local_50 + iVar5;
    pmVar2 = (mbedtls_ctr_drbg_context_conflict *)(ctx->counter + 0xf);
    do {
      uVar4 = pmVar2->counter[0] + '\x01';
      pmVar2->counter[0] = uVar4;
      if (uVar4 != '\0') break;
      bVar1 = ctx != pmVar2;
      pmVar2 = (mbedtls_ctr_drbg_context_conflict *)((int)&pmVar2[-1].p_entropy + 3);
    } while (bVar1);
    iVar5 = iVar5 + 0x10;
    mbedtls_aes_crypt_ecb(&ctx->aes_ctx,1,(uchar *)ctx,output);
    if (iVar5 == 0x30) {
      iVar5 = 0;
      output = local_50;
      do {
        pbVar3 = data + iVar5;
        iVar5 = iVar5 + 1;
        *output = *pbVar3 ^ *output;
        output = output + 1;
      } while (iVar5 != 0x30);
      mbedtls_aes_setkey_enc(&ctx->aes_ctx,local_50,0x100);
      memcpy(ctx,tmp + 0x1c,0x10);
      return 0;
    }
  } while( true );
}



void mbedtls_ctr_drbg_init(mbedtls_ctr_drbg_context_conflict *ctx)

{
  memset(ctx,0,0x140);
  return;
}



void mbedtls_ctr_drbg_free(mbedtls_ctr_drbg_context_conflict *ctx)

{
  mbedtls_ctr_drbg_context_conflict *pmVar1;
  
  if (ctx != (mbedtls_ctr_drbg_context_conflict *)0x0) {
    mbedtls_aes_free(&ctx->aes_ctx);
    pmVar1 = ctx + 1;
    while (ctx != pmVar1) {
      ctx->counter[0] = '\0';
      ctx = (mbedtls_ctr_drbg_context_conflict *)(ctx->counter + 1);
    }
    return;
  }
  return;
}



int mbedtls_ctr_drbg_reseed(mbedtls_ctr_drbg_context_conflict *ctx,uchar *additional,size_t len)

{
  int iVar1;
  size_t data_len;
  uchar auStack416 [4];
  uchar seed [384];
  
  iVar1 = -0x38;
  if ((ctx->entropy_len < 0x181) && (iVar1 = -0x38, len <= 0x180 - ctx->entropy_len)) {
    memset(auStack416,0,0x180);
    iVar1 = (*ctx->f_entropy)(ctx->p_entropy,auStack416,ctx->entropy_len);
    if (iVar1 == 0) {
      data_len = ctx->entropy_len;
      if ((additional != (uchar *)0x0) && (len != 0)) {
        memcpy(auStack416 + data_len,additional,len);
        data_len = data_len + len;
      }
      block_cipher_df(auStack416,auStack416,data_len);
      ctr_drbg_update_internal(ctx,auStack416);
      ctx->reseed_counter = 1;
    }
    else {
      iVar1 = -0x34;
    }
  }
  return iVar1;
}



int mbedtls_ctr_drbg_seed_entropy_len
              (mbedtls_ctr_drbg_context_conflict *ctx,
              anon_subr_int_void_ptr_uchar_ptr_size_t *f_entropy,void *p_entropy,uchar *custom,
              size_t len,size_t entropy_len)

{
  int iVar1;
  uchar auStack64 [4];
  uchar key [32];
  
  memset(auStack64,0,0x20);
  mbedtls_aes_init(&ctx->aes_ctx);
  *(anon_subr_int_void_ptr_uchar_ptr_size_t **)&ctx->f_entropy = f_entropy;
  ctx->p_entropy = p_entropy;
  ctx->entropy_len = entropy_len;
  ctx->reseed_interval = 10000;
  mbedtls_aes_setkey_enc(&ctx->aes_ctx,auStack64,0x100);
  iVar1 = mbedtls_ctr_drbg_reseed(ctx,custom,len);
  return iVar1;
}



int mbedtls_ctr_drbg_seed
              (mbedtls_ctr_drbg_context_conflict *ctx,
              anon_subr_int_void_ptr_uchar_ptr_size_t *f_entropy,void *p_entropy,uchar *custom,
              size_t len)

{
  int iVar1;
  
  iVar1 = mbedtls_ctr_drbg_seed_entropy_len(ctx,f_entropy,p_entropy,custom,len,0x20);
  return iVar1;
}



// WARNING: Variable defined which should be unmapped: add_input

int mbedtls_ctr_drbg_random_with_add
              (void *p_rng,uchar *output,size_t output_len,uchar *additional,size_t add_len)

{
  bool bVar1;
  char cVar2;
  int iVar3;
  char *pcVar4;
  uint __n;
  uchar auStack96 [4];
  uchar tmp [16];
  uchar add_input [48];
  
  if (output_len < 0x401) {
    iVar3 = -0x38;
    if (add_len < 0x101) {
      memset(tmp + 0xc,0,0x30);
      if ((*(int *)((int)p_rng + 0x1c) < *(int *)((int)p_rng + 0x10)) ||
         (*(int *)((int)p_rng + 0x14) != 0)) {
        iVar3 = mbedtls_ctr_drbg_reseed
                          ((mbedtls_ctr_drbg_context_conflict *)p_rng,additional,add_len);
        if (iVar3 != 0) {
          return iVar3;
        }
      }
      else {
        if (add_len != 0) {
          block_cipher_df(tmp + 0xc,additional,add_len);
          ctr_drbg_update_internal((mbedtls_ctr_drbg_context_conflict *)p_rng,tmp + 0xc);
        }
      }
      while (pcVar4 = (char *)((int)p_rng + 0xf), output_len != 0) {
        do {
          cVar2 = *pcVar4;
          *pcVar4 = cVar2 + '\x01';
          if ((char)(cVar2 + '\x01') != '\0') break;
          bVar1 = (char *)p_rng != pcVar4;
          pcVar4 = pcVar4 + -1;
        } while (bVar1);
        mbedtls_aes_crypt_ecb((mbedtls_aes_context *)((int)p_rng + 0x20),1,(uchar *)p_rng,auStack96)
        ;
        __n = output_len;
        if (0x10 < output_len) {
          __n = 0x10;
        }
        memcpy(output,auStack96,__n);
        output = output + __n;
        output_len = output_len - __n;
      }
      ctr_drbg_update_internal((mbedtls_ctr_drbg_context_conflict *)p_rng,tmp + 0xc);
      iVar3 = 0;
      *(int *)((int)p_rng + 0x10) = *(int *)((int)p_rng + 0x10) + 1;
    }
  }
  else {
    iVar3 = -0x36;
  }
  return iVar3;
}



int mbedtls_ctr_drbg_random(void *p_rng,uchar *output,size_t output_len)

{
  int iVar1;
  
  iVar1 = mbedtls_ctr_drbg_random_with_add(p_rng,output,output_len,(uchar *)0x0,0);
  return iVar1;
}



int entropy_update(mbedtls_entropy_context *ctx,uchar source_id,uchar *data,size_t len)

{
  uchar uStack68;
  undefined uStack67;
  uchar header [2];
  uchar tmp [32];
  
  if (0x20 < len) {
    mbedtls_sha256(data,len,header,0);
    data = header;
    len = 0x20;
  }
  uStack67 = (undefined)len;
  uStack68 = source_id;
  mbedtls_sha256_update((mbedtls_sha256_context *)ctx,&uStack68,2);
  mbedtls_sha256_update((mbedtls_sha256_context *)ctx,data,len);
  return 0;
}



int entropy_gather_internal(mbedtls_entropy_context *ctx)

{
  bool bVar1;
  mbedtls_entropy_source_state *pmVar2;
  int iVar3;
  int iVar4;
  size_t local_a4;
  size_t olen;
  uchar buf [128];
  
  pmVar2 = ctx->source;
  bVar1 = false;
  iVar3 = 0;
  while( true ) {
    if (ctx->source_count <= iVar3) {
      iVar3 = 0;
      if (!bVar1) {
        iVar3 = -0x3d;
      }
      return iVar3;
    }
    if (pmVar2->strong == 1) {
      bVar1 = true;
    }
    local_a4 = 0;
    iVar4 = (*pmVar2->f_source)(pmVar2->p_source,(uchar *)&olen,0x80,&local_a4);
    if (iVar4 != 0) break;
    if (local_a4 != 0) {
      entropy_update(ctx,(uchar)iVar3,(uchar *)&olen,local_a4);
      pmVar2->size = pmVar2->size + local_a4;
    }
    iVar3 = iVar3 + 1;
    pmVar2 = pmVar2 + 1;
  }
  return iVar4;
}



void mbedtls_entropy_init(mbedtls_entropy_context *ctx)

{
  int iVar1;
  uint32_t *puVar2;
  
  memset(ctx,0,0x208);
  mbedtls_sha256_starts((mbedtls_sha256_context *)ctx,0);
  iVar1 = ctx->source_count;
  if (iVar1 < 0x14) {
    puVar2 = (ctx->accumulator).total + iVar1 * 5;
    puVar2[0x1e] = 0x23056490;
    puVar2[0x21] = 0x20;
    puVar2[0x1f] = 0;
    puVar2[0x22] = 1;
    ctx->source_count = iVar1 + 1;
  }
  return;
}



void mbedtls_entropy_free(mbedtls_entropy_context *ctx)

{
  mbedtls_entropy_context *pmVar1;
  
  pmVar1 = ctx + 1;
  while (ctx != pmVar1) {
    *(undefined *)(ctx->accumulator).total = 0;
    ctx = (mbedtls_entropy_context *)((int)(ctx->accumulator).total + 1);
  }
  return;
}



int mbedtls_entropy_func(void *data,uchar *output,size_t len)

{
  bool bVar1;
  int iVar2;
  int iVar3;
  uint *puVar4;
  uint *puVar5;
  int iVar6;
  uchar auStack64 [4];
  uchar buf [32];
  
  if (len < 0x21) {
    iVar6 = 0x102;
    do {
      iVar6 = iVar6 + -1;
      if (iVar6 == 0) goto LAB_230563d2;
      if (*(int *)((int)data + 0x74) == 0) {
        return -0x40;
      }
      iVar2 = entropy_gather_internal((mbedtls_entropy_context *)data);
      if (iVar2 != 0) {
        return iVar2;
      }
      puVar5 = (uint *)((int)data + 0x80);
      iVar3 = 0;
      bVar1 = true;
      puVar4 = puVar5;
      while (iVar3 < *(int *)((int)data + 0x74)) {
        if (*puVar4 < puVar4[1]) {
          bVar1 = false;
        }
        iVar3 = iVar3 + 1;
        puVar4 = puVar4 + 5;
      }
    } while (!bVar1);
    memset(auStack64,0,0x20);
    mbedtls_sha256_finish((mbedtls_sha256_context *)data,auStack64);
    memset(data,0,0x74);
    mbedtls_sha256_starts((mbedtls_sha256_context *)data,0);
    mbedtls_sha256_update((mbedtls_sha256_context *)data,auStack64,0x20);
    mbedtls_sha256(auStack64,0x20,auStack64,0);
    iVar6 = *(int *)((int)data + 0x74);
    iVar3 = 0;
    while (iVar3 < iVar6) {
      *puVar5 = 0;
      iVar3 = iVar3 + 1;
      puVar5 = puVar5 + 5;
    }
    memcpy(output,auStack64,len);
  }
  else {
LAB_230563d2:
    iVar2 = -0x3c;
  }
  return iVar2;
}



int mbedtls_platform_entropy_poll(void *data,uchar *output,size_t len,size_t *olen)

{
  uint uVar1;
  uint uVar2;
  
  *olen = 0;
  uVar2 = 0;
  uVar1 = 0;
  while (uVar1 != len) {
    if ((uVar1 & 3) == 0) {
      uVar2 = bl_rand();
    }
    output[uVar1] = (uchar)uVar2;
    uVar1 = uVar1 + 1;
    uVar2 = uVar2 >> 8;
  }
  *olen = uVar1;
  return 0;
}



void mbedtls_pk_init(mbedtls_pk_context *ctx)

{
  if (ctx != (mbedtls_pk_context *)0x0) {
    ctx->pk_info = (mbedtls_pk_info_t *)0x0;
    ctx->pk_ctx = (void *)0x0;
  }
  return;
}



void mbedtls_pk_free(mbedtls_pk_context *ctx)

{
  mbedtls_pk_context *pmVar1;
  
  if (ctx != (mbedtls_pk_context *)0x0) {
    if (ctx->pk_info != (mbedtls_pk_info_t *)0x0) {
      (*ctx->pk_info->ctx_free_func)(ctx->pk_ctx);
      pmVar1 = ctx + 1;
      while (ctx != pmVar1) {
        *(undefined *)&ctx->pk_info = 0;
        ctx = (mbedtls_pk_context *)((int)&ctx->pk_info + 1);
      }
    }
    return;
  }
  return;
}



mbedtls_pk_info_t * mbedtls_pk_info_from_type(mbedtls_pk_type_t pk_type)

{
  uint uVar1;
  
  uVar1 = (uint)pk_type - 1 & 0xff;
  if (uVar1 < 3) {
    return *(mbedtls_pk_info_t **)(&CSWTCH_5 + uVar1 * 4);
  }
  return (mbedtls_pk_info_t *)0x0;
}



int mbedtls_pk_setup(mbedtls_pk_context *ctx,mbedtls_pk_info_t *info)

{
  void *pvVar1;
  int iVar2;
  
  if (((ctx != (mbedtls_pk_context *)0x0) && (info != (mbedtls_pk_info_t *)0x0)) &&
     (ctx->pk_info == (mbedtls_pk_info_t *)0x0)) {
    pvVar1 = (*info->ctx_alloc_func)(info->ctx_alloc_func);
    ctx->pk_ctx = pvVar1;
    if (pvVar1 == (void *)0x0) {
      iVar2 = -0x3f80;
    }
    else {
      ctx->pk_info = info;
      iVar2 = 0;
    }
    return iVar2;
  }
  return -16000;
}



int mbedtls_pk_can_do(mbedtls_pk_context *ctx,mbedtls_pk_type_t type)

{
  int iVar1;
  
  if ((ctx != (mbedtls_pk_context *)0x0) && (ctx->pk_info != (mbedtls_pk_info_t *)0x0)) {
                    // WARNING: Could not recover jumptable at 0x23056572. Too many branches
                    // WARNING: Treating indirect jump as call
    iVar1 = (*ctx->pk_info->can_do)(type);
    return iVar1;
  }
  return 0;
}



int mbedtls_pk_verify(mbedtls_pk_context *ctx,mbedtls_md_type_t md_alg,uchar *hash,size_t hash_len,
                     uchar *sig,size_t sig_len)

{
  anon_subr_int_void_ptr_mbedtls_md_type_t_uchar_ptr_size_t_uchar_ptr_size_t_for_verify_func
  *UNRECOVERED_JUMPTABLE;
  uchar uVar1;
  mbedtls_md_info_t *md_info;
  undefined3 extraout_var;
  int iVar2;
  
  if (ctx == (mbedtls_pk_context *)0x0) {
    return -16000;
  }
  if (ctx->pk_info == (mbedtls_pk_info_t *)0x0) {
LAB_23056582:
    iVar2 = -16000;
  }
  else {
    if (hash_len == 0) {
      md_info = mbedtls_md_info_from_type(md_alg);
      if (md_info == (mbedtls_md_info_t *)0x0) goto LAB_23056582;
      uVar1 = mbedtls_md_get_size(md_info);
      hash_len = CONCAT31(extraout_var,uVar1);
    }
    UNRECOVERED_JUMPTABLE = ctx->pk_info->verify_func;
    if (UNRECOVERED_JUMPTABLE !=
        (anon_subr_int_void_ptr_mbedtls_md_type_t_uchar_ptr_size_t_uchar_ptr_size_t_for_verify_func
         *)0x0) {
                    // WARNING: Could not recover jumptable at 0x230565ce. Too many branches
                    // WARNING: Treating indirect jump as call
      iVar2 = (*UNRECOVERED_JUMPTABLE)(ctx->pk_ctx,md_alg,hash,hash_len,sig,sig_len);
      return iVar2;
    }
    iVar2 = -0x3f00;
  }
  return iVar2;
}



int mbedtls_pk_sign(mbedtls_pk_context *ctx,mbedtls_md_type_t md_alg,uchar *hash,size_t hash_len,
                   uchar *sig,size_t *sig_len,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,
                   void *p_rng)

{
    
  anon_subr_int_void_ptr_mbedtls_md_type_t_uchar_ptr_size_t_uchar_ptr_size_t_ptr_anon_subr_int_void_ptr_uchar_ptr_size_t_ptr_void_ptr_for_sign_func
  *UNRECOVERED_JUMPTABLE;
  uchar uVar1;
  mbedtls_md_info_t *md_info;
  undefined3 extraout_var;
  int iVar2;
  
  if (ctx == (mbedtls_pk_context *)0x0) {
    return -16000;
  }
  if (ctx->pk_info == (mbedtls_pk_info_t *)0x0) {
LAB_230565e2:
    iVar2 = -16000;
  }
  else {
    if (hash_len == 0) {
      md_info = mbedtls_md_info_from_type(md_alg);
      if (md_info == (mbedtls_md_info_t *)0x0) goto LAB_230565e2;
      uVar1 = mbedtls_md_get_size(md_info);
      hash_len = CONCAT31(extraout_var,uVar1);
    }
    UNRECOVERED_JUMPTABLE = ctx->pk_info->sign_func;
    if (UNRECOVERED_JUMPTABLE !=
        (
         anon_subr_int_void_ptr_mbedtls_md_type_t_uchar_ptr_size_t_uchar_ptr_size_t_ptr_anon_subr_int_void_ptr_uchar_ptr_size_t_ptr_void_ptr_for_sign_func
         *)0x0) {
                    // WARNING: Could not recover jumptable at 0x23056636. Too many branches
                    // WARNING: Treating indirect jump as call
      iVar2 = (*UNRECOVERED_JUMPTABLE)(ctx->pk_ctx,md_alg,hash,hash_len,sig,sig_len,f_rng,p_rng);
      return iVar2;
    }
    iVar2 = -0x3f00;
  }
  return iVar2;
}



// WARNING: Exceeded maximum restarts with more pending

int mbedtls_pk_decrypt(mbedtls_pk_context *ctx,uchar *input,size_t ilen,uchar *output,size_t *olen,
                      size_t osize,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng)

{
    
  anon_subr_int_void_ptr_uchar_ptr_size_t_uchar_ptr_size_t_ptr_size_t_anon_subr_int_void_ptr_uchar_ptr_size_t_ptr_void_ptr_for_decrypt_func
  *UNRECOVERED_JUMPTABLE;
  int iVar1;
  
  if ((ctx != (mbedtls_pk_context *)0x0) && (ctx->pk_info != (mbedtls_pk_info_t *)0x0)) {
    UNRECOVERED_JUMPTABLE = ctx->pk_info->decrypt_func;
    if (UNRECOVERED_JUMPTABLE !=
        (
         anon_subr_int_void_ptr_uchar_ptr_size_t_uchar_ptr_size_t_ptr_size_t_anon_subr_int_void_ptr_uchar_ptr_size_t_ptr_void_ptr_for_decrypt_func
         *)0x0) {
                    // WARNING: Could not recover jumptable at 0x23056654. Too many branches
                    // WARNING: Treating indirect jump as call
      iVar1 = (*UNRECOVERED_JUMPTABLE)(ctx->pk_ctx);
      return iVar1;
    }
    return -0x3f00;
  }
  return -16000;
}



// WARNING: Exceeded maximum restarts with more pending

int mbedtls_pk_encrypt(mbedtls_pk_context *ctx,uchar *input,size_t ilen,uchar *output,size_t *olen,
                      size_t osize,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng)

{
    
  anon_subr_int_void_ptr_uchar_ptr_size_t_uchar_ptr_size_t_ptr_size_t_anon_subr_int_void_ptr_uchar_ptr_size_t_ptr_void_ptr_for_encrypt_func
  *UNRECOVERED_JUMPTABLE;
  int iVar1;
  
  if ((ctx != (mbedtls_pk_context *)0x0) && (ctx->pk_info != (mbedtls_pk_info_t *)0x0)) {
    UNRECOVERED_JUMPTABLE = ctx->pk_info->encrypt_func;
    if (UNRECOVERED_JUMPTABLE !=
        (
         anon_subr_int_void_ptr_uchar_ptr_size_t_uchar_ptr_size_t_ptr_size_t_anon_subr_int_void_ptr_uchar_ptr_size_t_ptr_void_ptr_for_encrypt_func
         *)0x0) {
                    // WARNING: Could not recover jumptable at 0x2305667a. Too many branches
                    // WARNING: Treating indirect jump as call
      iVar1 = (*UNRECOVERED_JUMPTABLE)(ctx->pk_ctx);
      return iVar1;
    }
    return -0x3f00;
  }
  return -16000;
}



size_t mbedtls_pk_get_bitlen(mbedtls_pk_context *ctx)

{
  size_t sVar1;
  
  if ((ctx != (mbedtls_pk_context *)0x0) && (ctx->pk_info != (mbedtls_pk_info_t *)0x0)) {
                    // WARNING: Could not recover jumptable at 0x23056698. Too many branches
                    // WARNING: Treating indirect jump as call
    sVar1 = (*ctx->pk_info->get_bitlen)(ctx->pk_ctx);
    return sVar1;
  }
  return 0;
}



int mbedtls_pk_verify_ext
              (mbedtls_pk_type_t type,void *options,mbedtls_pk_context *ctx,mbedtls_md_type_t md_alg
              ,uchar *hash,size_t hash_len,uchar *sig,size_t sig_len)

{
  undefined3 in_register_00002029;
  int iVar1;
  size_t sVar2;
  int in_fa0;
  uchar *in_fa1;
  
  if ((ctx != (mbedtls_pk_context *)0x0) && (ctx->pk_info != (mbedtls_pk_info_t *)0x0)) {
    iVar1 = mbedtls_pk_can_do(ctx,type);
    if (iVar1 == 0) {
      return -0x3f00;
    }
    if (CONCAT31(in_register_00002029,type) == 6) {
      if (options != (void *)0x0) {
        sVar2 = mbedtls_pk_get_bitlen(ctx);
        if (sig_len < sVar2 + 7 >> 3) {
          return -0x4380;
        }
        iVar1 = mbedtls_rsa_rsassa_pss_verify_ext
                          ((mbedtls_rsa_context *)ctx->pk_ctx,
                           (anon_subr_int_void_ptr_uchar_ptr_size_t *)0x0,(void *)0x0,0,md_alg,
                           hash_len,hash,*(mbedtls_md_type_t *)options,in_fa0,in_fa1);
        if (iVar1 != 0) {
          return iVar1;
        }
        sVar2 = mbedtls_pk_get_bitlen(ctx);
        if (sig_len <= sVar2 + 7 >> 3) {
          return 0;
        }
        return -0x3900;
      }
    }
    else {
      if (options == (void *)0x0) {
        iVar1 = mbedtls_pk_verify(ctx,md_alg,hash,hash_len,sig,sig_len);
        return iVar1;
      }
    }
  }
  return -16000;
}



int mbedtls_pk_debug(mbedtls_pk_context *ctx,mbedtls_pk_debug_item *items)

{
  anon_subr_void_void_ptr_mbedtls_pk_debug_item_ptr_for_debug_func *paVar1;
  
  if ((ctx != (mbedtls_pk_context *)0x0) && (ctx->pk_info != (mbedtls_pk_info_t *)0x0)) {
    paVar1 = ctx->pk_info->debug_func;
    if (paVar1 != (anon_subr_void_void_ptr_mbedtls_pk_debug_item_ptr_for_debug_func *)0x0) {
      (*paVar1)(ctx->pk_ctx,items);
      return 0;
    }
    return -0x3f00;
  }
  return -16000;
}



char * mbedtls_pk_get_name(mbedtls_pk_context *ctx)

{
  if ((ctx != (mbedtls_pk_context *)0x0) && (ctx->pk_info != (mbedtls_pk_info_t *)0x0)) {
    return ctx->pk_info->name;
  }
  return "invalid PK";
}



mbedtls_pk_type_t mbedtls_pk_get_type(mbedtls_pk_context *ctx)

{
  if ((ctx != (mbedtls_pk_context *)0x0) && (ctx->pk_info != (mbedtls_pk_info_t *)0x0)) {
    return ctx->pk_info->type;
  }
  return MBEDTLS_PK_NONE;
}



int pk_use_ecparams(mbedtls_asn1_buf *params,mbedtls_ecp_group *grp)

{
  int iVar1;
  mbedtls_ecp_group_id local_11 [4];
  mbedtls_ecp_group_id grp_id;
  
  if (params->tag != 6) {
    return -0x3d00;
  }
  iVar1 = mbedtls_oid_get_ec_grp(params,local_11);
  if (iVar1 == 0) {
    if ((grp->id == MBEDTLS_ECP_DP_NONE) || (grp->id == local_11[0])) {
      iVar1 = mbedtls_ecp_group_load(grp,local_11[0]);
    }
    else {
      iVar1 = -0x3d00;
    }
  }
  else {
    iVar1 = -0x3a00;
  }
  return iVar1;
}



int pk_parse_key_pkcs1_der(mbedtls_rsa_context *rsa,uchar *key,size_t keylen)

{
  int iVar1;
  int iVar2;
  size_t sVar3;
  uchar *end;
  size_t sStack40;
  size_t len;
  uchar *p;
  
  len = (size_t)key;
  iVar2 = mbedtls_asn1_get_tag((uchar **)&len,key + keylen,&sStack40,0x30);
  if (iVar2 == 0) {
    end = (uchar *)(len + sStack40);
    iVar2 = mbedtls_asn1_get_int((uchar **)&len,end,(int *)rsa);
    if (iVar2 == 0) {
      if (rsa->ver != 0) {
        return -0x3d80;
      }
      iVar1 = mbedtls_asn1_get_mpi((uchar **)&len,end,&rsa->N);
      if (((((iVar1 == 0) && (iVar1 = mbedtls_asn1_get_mpi((uchar **)&len,end,&rsa->E), iVar1 == 0))
           && (iVar1 = mbedtls_asn1_get_mpi((uchar **)&len,end,&rsa->D), iVar1 == 0)) &&
          ((iVar1 = mbedtls_asn1_get_mpi((uchar **)&len,end,&rsa->P), iVar1 == 0 &&
           (iVar1 = mbedtls_asn1_get_mpi((uchar **)&len,end,&rsa->Q), iVar1 == 0)))) &&
         ((iVar1 = mbedtls_asn1_get_mpi((uchar **)&len,end,&rsa->DP), iVar1 == 0 &&
          ((iVar1 = mbedtls_asn1_get_mpi((uchar **)&len,end,&rsa->DQ), iVar1 == 0 &&
           (iVar1 = mbedtls_asn1_get_mpi((uchar **)&len,end,&rsa->QP), iVar1 == 0)))))) {
        sVar3 = mbedtls_mpi_size(&rsa->N);
        rsa->len = sVar3;
        if ((uchar *)len != end) {
          mbedtls_rsa_free(rsa);
          return -0x3d66;
        }
        iVar2 = mbedtls_rsa_check_privkey(rsa);
        if (iVar2 == 0) {
          return 0;
        }
        mbedtls_rsa_free(rsa);
        return iVar2;
      }
      mbedtls_rsa_free(rsa);
      iVar2 = -0x3d00;
      goto LAB_2305683a;
    }
  }
  iVar1 = -0x3d00;
LAB_2305683a:
  return iVar1 + iVar2;
}



int pk_parse_key_sec1_der(mbedtls_ecp_keypair *eck,uchar *key,size_t keylen)

{
  int iVar1;
  uchar *end;
  int iVar2;
  uchar *end_00;
  mbedtls_mpi *X;
  int iStack56;
  int version;
  size_t len;
  uchar *p;
  mbedtls_asn1_buf params;
  
  len = (size_t)key;
  iVar2 = mbedtls_asn1_get_tag((uchar **)&len,key + keylen,(size_t *)&version,0x30);
  if (iVar2 == 0) {
    end_00 = (uchar *)(len + version);
    iVar2 = mbedtls_asn1_get_int((uchar **)&len,end_00,&iStack56);
    if (iVar2 == 0) {
      if (iStack56 != 1) {
        return -0x3d80;
      }
      iVar2 = mbedtls_asn1_get_tag((uchar **)&len,end_00,(size_t *)&version,4);
      if (iVar2 == 0) {
        X = &eck->d;
        iVar1 = mbedtls_mpi_read_binary(X,(uchar *)len,version);
        if (iVar1 == 0) {
          len = len + version;
          if ((uchar *)len == end_00) {
LAB_23056a92:
            iVar1 = mbedtls_ecp_mul((mbedtls_ecp_group *)eck,&eck->Q,X,&(eck->grp).G,
                                    (anon_subr_int_void_ptr_uchar_ptr_size_t *)0x0,(void *)0x0);
            if (iVar1 != 0) goto LAB_2305698a;
          }
          else {
            iVar1 = mbedtls_asn1_get_tag((uchar **)&len,end_00,(size_t *)&version,0xa0);
            if (iVar1 == 0) {
              end = (uchar *)(version + len);
              p = (uchar *)(uint)*(byte *)len;
              if (*(byte *)len != 6) {
                iVar2 = -0x3d62;
                goto LAB_230569fc;
              }
              iVar2 = mbedtls_asn1_get_tag((uchar **)&len,end,(size_t *)&params,6);
              if (iVar2 == 0) {
                params.len = len;
                len = len + params.tag;
                if (end != (uchar *)len) {
                  iVar2 = -0x3d66;
                  goto LAB_230569fc;
                }
              }
              else {
                iVar2 = iVar2 + -0x3d00;
                if (iVar2 != 0) goto LAB_230569fc;
              }
              iVar2 = pk_use_ecparams((mbedtls_asn1_buf *)&p,(mbedtls_ecp_group *)eck);
              if (iVar2 != 0) goto LAB_230569fc;
            }
            else {
              if (iVar1 != -0x62) goto LAB_2305698a;
            }
            iVar1 = mbedtls_asn1_get_tag((uchar **)&len,end_00,(size_t *)&version,0xa1);
            if (iVar1 != 0) {
              if (iVar1 != -0x62) goto LAB_2305698a;
              goto LAB_23056a92;
            }
            end_00 = (uchar *)(len + version);
            iVar2 = mbedtls_asn1_get_bitstring_null((uchar **)&len,end_00,(size_t *)&version);
            if (iVar2 != 0) goto LAB_23056948;
            if (end_00 != (uchar *)(version + len)) {
              return -0x3d66;
            }
            iVar2 = mbedtls_ecp_point_read_binary
                              ((mbedtls_ecp_group *)eck,&eck->Q,(uchar *)len,(size_t)(end_00 + -len)
                              );
            if (iVar2 == 0) {
              iVar2 = mbedtls_ecp_check_pubkey((mbedtls_ecp_group *)eck,&eck->Q);
            }
            len = (size_t)end_00;
            if (iVar2 != 0) {
              if (iVar2 != -0x4e80) {
                return -0x3d00;
              }
              goto LAB_23056a92;
            }
          }
          iVar2 = mbedtls_ecp_check_privkey((mbedtls_ecp_group *)eck,X);
          if (iVar2 == 0) {
            return 0;
          }
LAB_230569fc:
          mbedtls_ecp_keypair_free(eck);
          return iVar2;
        }
LAB_2305698a:
        mbedtls_ecp_keypair_free(eck);
        iVar2 = -0x3d00;
        goto LAB_23056996;
      }
    }
  }
LAB_23056948:
  iVar1 = -0x3d00;
LAB_23056996:
  return iVar1 + iVar2;
}



int pk_get_pk_alg(uchar **p,uchar *end,mbedtls_pk_type_t *pk_alg,mbedtls_asn1_buf *params)

{
  int iVar1;
  undefined auStack44 [4];
  mbedtls_asn1_buf alg_oid;
  
  memset(params,0,0xc);
  iVar1 = mbedtls_asn1_get_alg(p,end,(mbedtls_asn1_buf *)auStack44,params);
  if (iVar1 == 0) {
    iVar1 = mbedtls_oid_get_pk_alg((mbedtls_asn1_buf *)auStack44,pk_alg);
    if (iVar1 == 0) {
      if ((*pk_alg == MBEDTLS_PK_RSA) &&
         (((params->tag != 5 && (params->tag != 0)) || (params->len != 0)))) {
        iVar1 = -0x3a80;
      }
    }
    else {
      iVar1 = -0x3c80;
    }
  }
  else {
    iVar1 = iVar1 + -0x3a80;
  }
  return iVar1;
}



// WARNING: Could not reconcile some variable overlaps

int pk_parse_key_pkcs8_unencrypted_der(mbedtls_pk_context *pk,uchar *key,size_t keylen)

{
  uchar *end;
  int iVar1;
  mbedtls_pk_info_t *info;
  mbedtls_pk_type_t mStack41;
  mbedtls_pk_type_t pk_alg;
  int iStack40;
  int version;
  size_t len;
  uchar *p;
  mbedtls_asn1_buf params;
  
  mStack41 = MBEDTLS_PK_NONE;
  len = (size_t)key;
  iVar1 = mbedtls_asn1_get_tag((uchar **)&len,key + keylen,(size_t *)&version,0x30);
  if (iVar1 != 0) {
LAB_23056b60:
    return iVar1 + -0x3d00;
  }
  end = (uchar *)(len + version);
  iVar1 = mbedtls_asn1_get_int((uchar **)&len,end,(int *)&stack0xffffffd8);
  if (iVar1 != 0) goto LAB_23056b60;
  if (iStack40 != 0) {
    return -0x3d80;
  }
  iVar1 = pk_get_pk_alg((uchar **)&len,end,&mStack41,(mbedtls_asn1_buf *)&p);
  if ((iVar1 != 0) ||
     (iVar1 = mbedtls_asn1_get_tag((uchar **)&len,end,(size_t *)&version,4), iVar1 != 0))
  goto LAB_23056b60;
  if (version == 0) {
    return -0x3d60;
  }
  info = mbedtls_pk_info_from_type(mStack41);
  if (info == (mbedtls_pk_info_t *)0x0) {
    return -0x3c80;
  }
  iVar1 = mbedtls_pk_setup(pk,info);
  if (iVar1 != 0) {
    return iVar1;
  }
  if (mStack41 == MBEDTLS_PK_RSA) {
    iVar1 = pk_parse_key_pkcs1_der((mbedtls_rsa_context *)pk->pk_ctx,(uchar *)len,version);
  }
  else {
    if (1 < (byte)(mStack41 + ~MBEDTLS_PK_RSA)) {
      return -0x3c80;
    }
    iVar1 = pk_use_ecparams((mbedtls_asn1_buf *)&p,(mbedtls_ecp_group *)pk->pk_ctx);
    if (iVar1 != 0) goto LAB_23056be2;
    iVar1 = pk_parse_key_sec1_der((mbedtls_ecp_keypair *)pk->pk_ctx,(uchar *)len,version);
  }
  if (iVar1 == 0) {
    return 0;
  }
LAB_23056be2:
  mbedtls_pk_free(pk);
  return iVar1;
}



int mbedtls_pk_load_file(char *path,uchar **buf,size_t *n)

{
  char "mbedtls_pk_load_file" [21];
  int fd;
  size_t sVar1;
  uchar *buf_00;
  char *pcVar2;
  undefined4 uVar3;
  
  printf("Open path %s\r\n",path);
  fd = aos_open(path,0);
  uVar3 = 0x7f;
  if (-1 < fd) {
    sVar1 = aos_lseek(fd,0,2);
    if (sVar1 != 0xffffffff) {
      aos_lseek(fd,0,0);
      *n = sVar1;
      printf("Cert size is %d\r\n",sVar1);
      if (*n != 0xffffffff) {
        buf_00 = (uchar *)mycalloc(1,*n + 1);
        *buf = buf_00;
        if (buf_00 != (uchar *)0x0) {
          sVar1 = aos_read(fd,buf_00,*n);
          if (sVar1 == *n) {
            aos_close(fd);
            (*buf)[*n] = '\0';
            pcVar2 = strstr((char *)*buf,"-----BEGIN ");
            if (pcVar2 == (char *)0x0) {
              return 0;
            }
            *n = *n + 1;
            return 0;
          }
          aos_close(fd);
          vPortFree(*buf);
          uVar3 = 0x96;
          goto LAB_23056c6a;
        }
      }
      aos_close(fd);
      printf("%s:%d\r\n",0x23088b4c,0x90);
      return -0x3f80;
    }
    aos_close(fd);
    uVar3 = 0x86;
  }
LAB_23056c6a:
  printf("%s:%d\r\n","mbedtls_pk_load_file",uVar3);
  return -0x3e00;
}



// WARNING: Variable defined which should be unmapped: alg_params
// WARNING: Could not reconcile some variable overlaps

int mbedtls_pk_parse_subpubkey(uchar **p,uchar *end,mbedtls_pk_context *pk)

{
  mbedtls_rsa_context *ctx;
  int iVar1;
  mbedtls_pk_info_t *info;
  size_t sVar2;
  int iVar3;
  uchar *end_00;
  mbedtls_ecp_group *grp;
  mbedtls_ecp_point *pt;
  mbedtls_pk_type_t mStack53;
  mbedtls_pk_type_t pk_alg;
  size_t sStack52;
  size_t len;
  size_t len_1;
  mbedtls_asn1_buf alg_params;
  
  mStack53 = MBEDTLS_PK_NONE;
  iVar1 = mbedtls_asn1_get_tag(p,end,(size_t *)&stack0xffffffcc,0x30);
  if (iVar1 != 0) {
    iVar3 = -0x3d00;
LAB_23056d6c:
    return iVar1 + iVar3;
  }
  end_00 = *p + sStack52;
  iVar1 = pk_get_pk_alg(p,end_00,&mStack53,(mbedtls_asn1_buf *)&len_1);
  if (iVar1 != 0) {
    return iVar1;
  }
  iVar1 = mbedtls_asn1_get_bitstring_null(p,end_00,(size_t *)&stack0xffffffcc);
  if (iVar1 != 0) {
    iVar3 = -0x3b00;
    goto LAB_23056d6c;
  }
  if (end_00 != *p + sStack52) {
    return -0x3b66;
  }
  info = mbedtls_pk_info_from_type(mStack53);
  if (info == (mbedtls_pk_info_t *)0x0) {
    return -0x3c80;
  }
  iVar1 = mbedtls_pk_setup(pk,info);
  if (iVar1 != 0) {
    return iVar1;
  }
  if (mStack53 != MBEDTLS_PK_RSA) {
    if ((byte)(mStack53 + ~MBEDTLS_PK_RSA) < 2) {
      iVar1 = pk_use_ecparams((mbedtls_asn1_buf *)&len_1,(mbedtls_ecp_group *)pk->pk_ctx);
      if (iVar1 == 0) {
        grp = (mbedtls_ecp_group *)pk->pk_ctx;
        pt = (mbedtls_ecp_point *)&grp[1].P.p;
        iVar1 = mbedtls_ecp_point_read_binary(grp,pt,*p,(size_t)(end_00 + -(int)*p));
        if (iVar1 == 0) {
          iVar1 = mbedtls_ecp_check_pubkey(grp,pt);
        }
        *p = end_00;
        if (iVar1 == 0) {
          return 0;
        }
      }
    }
    else {
      iVar1 = -0x3c80;
    }
    goto LAB_23056e00;
  }
  ctx = (mbedtls_rsa_context *)pk->pk_ctx;
  iVar1 = mbedtls_asn1_get_tag(p,end_00,&len,0x30);
  if (iVar1 == 0) {
    if (end_00 == *p + len) {
      iVar1 = mbedtls_asn1_get_mpi(p,end_00,&ctx->N);
      if ((iVar1 != 0) || (iVar1 = mbedtls_asn1_get_mpi(p,end_00,&ctx->E), iVar1 != 0))
      goto LAB_23056df6;
      if (end_00 != *p) goto LAB_23056e16;
      iVar1 = mbedtls_rsa_check_pubkey(ctx);
      if (iVar1 != 0) {
        iVar1 = -0x3b00;
        goto LAB_23056e00;
      }
      sVar2 = mbedtls_mpi_size(&ctx->N);
      ctx->len = sVar2;
      goto LAB_23056e52;
    }
  }
  else {
LAB_23056df6:
    iVar1 = iVar1 + -0x3b00;
    if (iVar1 != 0) goto LAB_23056e00;
LAB_23056e52:
    if (*p == end_00) {
      return 0;
    }
  }
LAB_23056e16:
  iVar1 = -0x3b66;
LAB_23056e00:
  mbedtls_pk_free(pk);
  return iVar1;
}



int mbedtls_pk_parse_key(mbedtls_pk_context *pk,uchar *key,size_t keylen,uchar *pwd,size_t pwdlen)

{
  int iVar1;
  mbedtls_pk_info_t *info;
  uchar *puVar2;
  size_t sStack64;
  size_t len;
  mbedtls_pem_context pem;
  
  mbedtls_pem_init((mbedtls_pem_context *)&len);
  if ((keylen == 0) || (puVar2 = key + (keylen - 1), *puVar2 != '\0')) {
LAB_23056eee:
    iVar1 = pk_parse_key_pkcs8_unencrypted_der(pk,key,keylen);
    if (iVar1 != 0) {
      mbedtls_pk_free(pk);
      info = mbedtls_pk_info_from_type(MBEDTLS_PK_RSA);
      if (info == (mbedtls_pk_info_t *)0x0) goto LAB_23056f92;
      iVar1 = mbedtls_pk_setup(pk,info);
      if ((iVar1 == 0) &&
         (iVar1 = pk_parse_key_pkcs1_der((mbedtls_rsa_context *)pk->pk_ctx,key,keylen), iVar1 != 0))
      {
        mbedtls_pk_free(pk);
        info = mbedtls_pk_info_from_type(MBEDTLS_PK_ECKEY);
        if (info == (mbedtls_pk_info_t *)0x0) goto LAB_23056f92;
        iVar1 = mbedtls_pk_setup(pk,info);
        if ((iVar1 == 0) &&
           (iVar1 = pk_parse_key_sec1_der((mbedtls_ecp_keypair *)pk->pk_ctx,key,keylen), iVar1 != 0)
           ) {
          mbedtls_pk_free(pk);
          return -0x3d00;
        }
      }
    }
    iVar1 = 0;
  }
  else {
    iVar1 = mbedtls_pem_read_buffer
                      ((mbedtls_pem_context *)&len,"-----BEGIN RSA PRIVATE KEY-----",
                       "-----END RSA PRIVATE KEY-----",key,pwd,pwdlen,&sStack64);
    if (iVar1 != 0) {
      if (iVar1 == -0x1380) {
        return -0x3b80;
      }
      if (iVar1 == -0x1300) {
        return -0x3c00;
      }
      if (iVar1 != -0x1080) {
        return iVar1;
      }
      if (*puVar2 == '\0') {
        iVar1 = mbedtls_pem_read_buffer
                          ((mbedtls_pem_context *)&len,"-----BEGIN EC PRIVATE KEY-----",
                           "-----END EC PRIVATE KEY-----",key,pwd,pwdlen,&sStack64);
        if (iVar1 == 0) {
          info = mbedtls_pk_info_from_type(MBEDTLS_PK_ECKEY);
          if (info == (mbedtls_pk_info_t *)0x0) goto LAB_23056f92;
          iVar1 = mbedtls_pk_setup(pk,info);
          if (iVar1 != 0) goto LAB_23056fca;
          iVar1 = pk_parse_key_sec1_der
                            ((mbedtls_ecp_keypair *)pk->pk_ctx,(uchar *)len,(size_t)pem.buf);
LAB_23056fc6:
          if (iVar1 == 0) goto LAB_23056fd0;
          goto LAB_23056fca;
        }
        if (iVar1 == -0x1380) {
          return -0x3b80;
        }
        if (iVar1 == -0x1300) {
          return -0x3c00;
        }
        if (iVar1 != -0x1080) {
          return iVar1;
        }
        if (*puVar2 == '\0') {
          iVar1 = mbedtls_pem_read_buffer
                            ((mbedtls_pem_context *)&len,"-----BEGIN PRIVATE KEY-----",
                             "-----END PRIVATE KEY-----",key,(uchar *)0x0,0,&sStack64);
          if (iVar1 == 0) {
            iVar1 = pk_parse_key_pkcs8_unencrypted_der(pk,(uchar *)len,(size_t)pem.buf);
            goto LAB_23056fc6;
          }
          if (iVar1 != -0x1080) {
            return iVar1;
          }
        }
      }
      goto LAB_23056eee;
    }
    info = mbedtls_pk_info_from_type(MBEDTLS_PK_RSA);
    if (info != (mbedtls_pk_info_t *)0x0) {
      iVar1 = mbedtls_pk_setup(pk,info);
      if (iVar1 == 0) {
        iVar1 = pk_parse_key_pkcs1_der
                          ((mbedtls_rsa_context *)pk->pk_ctx,(uchar *)len,(size_t)pem.buf);
        goto LAB_23056fc6;
      }
LAB_23056fca:
      mbedtls_pk_free(pk);
LAB_23056fd0:
      mbedtls_pem_free((mbedtls_pem_context *)&len);
      return iVar1;
    }
LAB_23056f92:
    iVar1 = -0x3c80;
  }
  return iVar1;
}



// WARNING: Variable defined which should be unmapped: buf

int mbedtls_pk_parse_keyfile(mbedtls_pk_context *ctx,char *path,char *pwd)

{
  size_t keylen;
  size_t key;
  int iVar1;
  size_t pwdlen;
  uchar *puVar2;
  size_t local_18;
  size_t n;
  uchar *buf;
  
  iVar1 = mbedtls_pk_load_file(path,(uchar **)&n,&local_18);
  key = n;
  keylen = local_18;
  if (iVar1 == 0) {
    if (pwd == (char *)0x0) {
      pwdlen = 0;
      pwd = (char *)0x0;
    }
    else {
      pwdlen = strlen(pwd);
    }
    iVar1 = mbedtls_pk_parse_key(ctx,(uchar *)key,keylen,(uchar *)pwd,pwdlen);
    puVar2 = (uchar *)n;
    while (puVar2 != (uchar *)(local_18 + n)) {
      *puVar2 = '\0';
      puVar2 = puVar2 + 1;
    }
    vPortFree((void *)n);
  }
  return iVar1;
}



int rsa_can_do(mbedtls_pk_type_t type)

{
  undefined3 in_register_00002029;
  
  if (CONCAT31(in_register_00002029,type) != 1) {
    return (uint)(CONCAT31(in_register_00002029,type) == 6);
  }
  return 1;
}



size_t rsa_get_bitlen(void *ctx)

{
  return *(int *)((int)ctx + 4) << 3;
}



void rsa_debug(void *ctx,mbedtls_pk_debug_item *items)

{
  items->name = "rsa.N";
  items->value = (void *)((int)ctx + 8);
  items->type = MBEDTLS_PK_DEBUG_MPI;
  items[1].type = MBEDTLS_PK_DEBUG_MPI;
  items[1].name = "rsa.E";
  items[1].value = (void *)((int)ctx + 0x14);
  return;
}



int eckey_can_do(mbedtls_pk_type_t type)

{
  undefined3 in_register_00002029;
  
  return (uint)(CONCAT31(in_register_00002029,type) - 2U < 3);
}



size_t eckey_get_bitlen(void *ctx)

{
  return *(size_t *)((int)ctx + 0x58);
}



void eckey_debug(void *ctx,mbedtls_pk_debug_item *items)

{
  items->type = MBEDTLS_PK_DEBUG_ECP;
  items->name = "eckey.Q";
  items->value = (void *)((int)ctx + 0x88);
  return;
}



int eckeydh_can_do(mbedtls_pk_type_t type)

{
  undefined3 in_register_00002029;
  
  return (uint)(CONCAT31(in_register_00002029,type) - 2U < 2);
}



void rsa_free_wrap(void *ctx)

{
  mbedtls_rsa_free((mbedtls_rsa_context *)ctx);
  vPortFree(ctx);
  return;
}



void * rsa_alloc_wrap(void)

{
  mbedtls_rsa_context *ctx;
  
  ctx = (mbedtls_rsa_context *)mycalloc(1,0xac);
  if (ctx != (mbedtls_rsa_context *)0x0) {
    mbedtls_rsa_init(ctx,0,0);
  }
  return ctx;
}



int rsa_check_pair_wrap(mbedtls_rsa_context *pub,mbedtls_rsa_context *prv)

{
  int iVar1;
  
  iVar1 = mbedtls_rsa_check_pubkey(pub);
  if ((((iVar1 != 0) || (iVar1 = mbedtls_rsa_check_privkey(prv), iVar1 != 0)) ||
      (iVar1 = mbedtls_mpi_cmp_mpi(&pub->N,&prv->N), iVar1 != 0)) ||
     (iVar1 = mbedtls_mpi_cmp_mpi(&pub->E,&prv->E), iVar1 != 0)) {
    iVar1 = -0x4200;
  }
  return iVar1;
}



int rsa_encrypt_wrap(void *ctx,uchar *input,size_t ilen,uchar *output,size_t *olen,size_t osize,
                    anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng)

{
  int iVar1;
  uint uVar2;
  
  uVar2 = *(uint *)((int)ctx + 4);
  *olen = uVar2;
  if (uVar2 <= osize) {
    iVar1 = mbedtls_rsa_pkcs1_encrypt((mbedtls_rsa_context *)ctx,f_rng,p_rng,0,ilen,input,output);
    return iVar1;
  }
  return -0x4400;
}



int rsa_decrypt_wrap(void *ctx,uchar *input,size_t ilen,uchar *output,size_t *olen,size_t osize,
                    anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng)

{
  int iVar1;
  
  if (*(size_t *)((int)ctx + 4) == ilen) {
    iVar1 = mbedtls_rsa_pkcs1_decrypt
                      ((mbedtls_rsa_context *)ctx,f_rng,p_rng,1,olen,input,output,osize);
    return iVar1;
  }
  return -0x4080;
}



int rsa_sign_wrap(void *ctx,mbedtls_md_type_t md_alg,uchar *hash,size_t hash_len,uchar *sig,
                 size_t *sig_len,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng)

{
  int iVar1;
  
  *sig_len = *(size_t *)((int)ctx + 4);
  iVar1 = mbedtls_rsa_pkcs1_sign((mbedtls_rsa_context *)ctx,f_rng,p_rng,1,md_alg,hash_len,hash,sig);
  return iVar1;
}



int rsa_verify_wrap(void *ctx,mbedtls_md_type_t md_alg,uchar *hash,size_t hash_len,uchar *sig,
                   size_t sig_len)

{
  int iVar1;
  
  if (*(uint *)((int)ctx + 4) <= sig_len) {
    iVar1 = mbedtls_rsa_pkcs1_verify
                      ((mbedtls_rsa_context *)ctx,(anon_subr_int_void_ptr_uchar_ptr_size_t *)0x0,
                       (void *)0x0,0,md_alg,hash_len,hash,sig);
    if ((iVar1 == 0) && (*(uint *)((int)ctx + 4) < sig_len)) {
      iVar1 = -0x3900;
    }
    return iVar1;
  }
  return -0x4380;
}



void eckey_free_wrap(void *ctx)

{
  mbedtls_ecp_keypair_free((mbedtls_ecp_keypair *)ctx);
  vPortFree(ctx);
  return;
}



void * eckey_alloc_wrap(void)

{
  mbedtls_ecp_keypair *key;
  
  key = (mbedtls_ecp_keypair *)mycalloc(1,0xac);
  if (key != (mbedtls_ecp_keypair *)0x0) {
    mbedtls_ecp_keypair_init(key);
  }
  return key;
}



int eckey_check_pair(mbedtls_ecp_keypair *pub,mbedtls_ecp_keypair *prv)

{
  mbedtls_ecp_group_id mVar1;
  int iVar2;
  mbedtls_mpi *Y;
  mbedtls_mpi *Y_00;
  mbedtls_ecp_point mStack192;
  mbedtls_ecp_group mStack156;
  
  mVar1 = (pub->grp).id;
  if ((mVar1 != MBEDTLS_ECP_DP_NONE) && ((prv->grp).id == mVar1)) {
    iVar2 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&pub->Q,(mbedtls_mpi *)&prv->Q);
    if (iVar2 == 0) {
      Y_00 = &(prv->Q).Y;
      iVar2 = mbedtls_mpi_cmp_mpi(&(pub->Q).Y,Y_00);
      if (iVar2 == 0) {
        Y = &(prv->Q).Z;
        iVar2 = mbedtls_mpi_cmp_mpi(&(pub->Q).Z,Y);
        if (iVar2 == 0) {
          mbedtls_ecp_point_init(&mStack192);
          memset(&mStack156,0,0x7c);
          mbedtls_ecp_group_copy(&mStack156,(mbedtls_ecp_group *)prv);
          iVar2 = mbedtls_ecp_mul(&mStack156,&mStack192,&prv->d,&(prv->grp).G,
                                  (anon_subr_int_void_ptr_uchar_ptr_size_t *)0x0,(void *)0x0);
          if ((iVar2 == 0) &&
             (((iVar2 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&mStack192,(mbedtls_mpi *)&prv->Q),
               iVar2 != 0 || (iVar2 = mbedtls_mpi_cmp_mpi(&mStack192.Y,Y_00), iVar2 != 0)) ||
              (iVar2 = mbedtls_mpi_cmp_mpi(&mStack192.Z,Y), iVar2 != 0)))) {
            iVar2 = -0x4f80;
          }
          mbedtls_ecp_point_free(&mStack192);
          mbedtls_ecp_group_free(&mStack156);
          return iVar2;
        }
      }
    }
  }
  return -0x4f80;
}



// WARNING: Variable defined which should be unmapped: mask

void mgf_mask(uchar *dst,size_t dlen,uchar *src,size_t slen,mbedtls_md_context_t *md_ctx)

{
  uchar uVar1;
  undefined3 extraout_var;
  byte *pbVar2;
  byte *pbVar3;
  uint uVar4;
  uint uVar5;
  uchar auStack68 [3];
  char cStack65;
  uchar counter [4];
  uchar mask [32];
  
  memset(counter,0,0x20);
  memset(auStack68,0,4);
  uVar1 = mbedtls_md_get_size(md_ctx->md_info);
  while (dlen != 0) {
    uVar5 = dlen;
    if (CONCAT31(extraout_var,uVar1) < dlen) {
      uVar5 = CONCAT31(extraout_var,uVar1);
    }
    mbedtls_md_starts(md_ctx);
    mbedtls_md_update(md_ctx,src,slen);
    mbedtls_md_update(md_ctx,auStack68,4);
    mbedtls_md_finish(md_ctx,counter);
    uVar4 = 0;
    while (pbVar3 = dst + uVar4, uVar4 != uVar5) {
      pbVar2 = counter + uVar4;
      uVar4 = uVar4 + 1;
      *pbVar3 = *pbVar2 ^ *pbVar3;
    }
    dlen = dlen - uVar4;
    cStack65 = cStack65 + '\x01';
    dst = pbVar3;
  }
  return;
}



void mbedtls_rsa_init(mbedtls_rsa_context *ctx,int padding,int hash_id)

{
  memset(ctx,0,0xac);
  ctx->padding = padding;
  ctx->hash_id = hash_id;
  return;
}



int mbedtls_rsa_check_pubkey(mbedtls_rsa_context *ctx)

{
  mbedtls_mpi *X;
  size_t sVar1;
  int iVar2;
  mbedtls_mpi_uint *pmVar3;
  mbedtls_mpi_uint *pmVar4;
  
  pmVar4 = (ctx->N).p;
  if ((((pmVar4 != (mbedtls_mpi_uint *)0x0) &&
       (pmVar3 = (ctx->E).p, pmVar3 != (mbedtls_mpi_uint *)0x0)) && ((*pmVar4 & 1) != 0)) &&
     ((*pmVar3 & 1) != 0)) {
    X = &ctx->N;
    sVar1 = mbedtls_mpi_bitlen(X);
    if ((0x7f < sVar1) && (sVar1 = mbedtls_mpi_bitlen(X), sVar1 < 0x2001)) {
      sVar1 = mbedtls_mpi_bitlen(&ctx->E);
      if ((1 < sVar1) && (iVar2 = mbedtls_mpi_cmp_mpi(&ctx->E,X), iVar2 < 0)) {
        return 0;
      }
    }
    return -0x4200;
  }
  return -0x4200;
}



int mbedtls_rsa_check_privkey(mbedtls_rsa_context *ctx)

{
  int iVar1;
  mbedtls_mpi *B;
  mbedtls_mpi *A;
  mbedtls_mpi *A_00;
  undefined auStack188 [4];
  mbedtls_mpi PQ;
  mbedtls_mpi DE;
  mbedtls_mpi P1;
  mbedtls_mpi Q1;
  mbedtls_mpi H;
  mbedtls_mpi I;
  mbedtls_mpi G;
  mbedtls_mpi G2;
  mbedtls_mpi L1;
  mbedtls_mpi L2;
  mbedtls_mpi DP;
  mbedtls_mpi DQ;
  mbedtls_mpi QP;
  
  iVar1 = mbedtls_rsa_check_pubkey(ctx);
  if (iVar1 == 0) {
    iVar1 = -0x4200;
    if ((((ctx->P).p != (mbedtls_mpi_uint *)0x0) && ((ctx->Q).p != (mbedtls_mpi_uint *)0x0)) &&
       (iVar1 = -0x4200, (ctx->D).p != (mbedtls_mpi_uint *)0x0)) {
      mbedtls_mpi_init((mbedtls_mpi *)auStack188);
      mbedtls_mpi_init((mbedtls_mpi *)&PQ.p);
      mbedtls_mpi_init((mbedtls_mpi *)&DE.p);
      mbedtls_mpi_init((mbedtls_mpi *)&P1.p);
      mbedtls_mpi_init((mbedtls_mpi *)&Q1.p);
      mbedtls_mpi_init((mbedtls_mpi *)&H.p);
      mbedtls_mpi_init((mbedtls_mpi *)&I.p);
      mbedtls_mpi_init((mbedtls_mpi *)&G.p);
      mbedtls_mpi_init((mbedtls_mpi *)&G2.p);
      mbedtls_mpi_init((mbedtls_mpi *)&L1.p);
      mbedtls_mpi_init((mbedtls_mpi *)&L2.p);
      mbedtls_mpi_init((mbedtls_mpi *)&DP.p);
      mbedtls_mpi_init((mbedtls_mpi *)&DQ.p);
      A = &ctx->P;
      B = &ctx->Q;
      iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)auStack188,A,B);
      if (iVar1 == 0) {
        A_00 = &ctx->D;
        iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&PQ.p,A_00,&ctx->E);
        if (((((iVar1 == 0) && (iVar1 = mbedtls_mpi_sub_int((mbedtls_mpi *)&DE.p,A,1), iVar1 == 0))
             && ((iVar1 = mbedtls_mpi_sub_int((mbedtls_mpi *)&P1.p,B,1), iVar1 == 0 &&
                 ((iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&Q1.p,(mbedtls_mpi *)&DE.p,
                                               (mbedtls_mpi *)&P1.p), iVar1 == 0 &&
                  (iVar1 = mbedtls_mpi_gcd((mbedtls_mpi *)&I.p,&ctx->E,(mbedtls_mpi *)&Q1.p),
                  iVar1 == 0)))))) &&
            ((iVar1 = mbedtls_mpi_gcd((mbedtls_mpi *)&G.p,(mbedtls_mpi *)&DE.p,(mbedtls_mpi *)&P1.p)
             , iVar1 == 0 &&
             ((((iVar1 = mbedtls_mpi_div_mpi((mbedtls_mpi *)&G2.p,(mbedtls_mpi *)&L1.p,
                                             (mbedtls_mpi *)&Q1.p,(mbedtls_mpi *)&G.p), iVar1 == 0
                && (iVar1 = mbedtls_mpi_mod_mpi((mbedtls_mpi *)&H.p,(mbedtls_mpi *)&PQ.p,
                                                (mbedtls_mpi *)&G2.p), iVar1 == 0)) &&
               (iVar1 = mbedtls_mpi_mod_mpi((mbedtls_mpi *)&L2.p,A_00,(mbedtls_mpi *)&DE.p),
               iVar1 == 0)) &&
              ((iVar1 = mbedtls_mpi_mod_mpi((mbedtls_mpi *)&DP.p,A_00,(mbedtls_mpi *)&P1.p),
               iVar1 == 0 && (iVar1 = mbedtls_mpi_inv_mod((mbedtls_mpi *)&DQ.p,B,A), iVar1 == 0)))))
             ))) && ((((iVar1 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)auStack188,&ctx->N), iVar1 != 0
                       || ((iVar1 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&L2.p,&ctx->DP), iVar1 != 0
                           || (iVar1 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&DP.p,&ctx->DQ),
                              iVar1 != 0)))) ||
                      (iVar1 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&DQ.p,&ctx->QP), iVar1 != 0)) ||
                     (((iVar1 = mbedtls_mpi_cmp_int((mbedtls_mpi *)&L1.p,0), iVar1 != 0 ||
                       (iVar1 = mbedtls_mpi_cmp_int((mbedtls_mpi *)&H.p,1), iVar1 != 0)) ||
                      (iVar1 = mbedtls_mpi_cmp_int((mbedtls_mpi *)&I.p,1), iVar1 != 0)))))) {
          iVar1 = -0x4200;
        }
      }
      mbedtls_mpi_free((mbedtls_mpi *)auStack188);
      mbedtls_mpi_free((mbedtls_mpi *)&PQ.p);
      mbedtls_mpi_free((mbedtls_mpi *)&DE.p);
      mbedtls_mpi_free((mbedtls_mpi *)&P1.p);
      mbedtls_mpi_free((mbedtls_mpi *)&Q1.p);
      mbedtls_mpi_free((mbedtls_mpi *)&H.p);
      mbedtls_mpi_free((mbedtls_mpi *)&I.p);
      mbedtls_mpi_free((mbedtls_mpi *)&G.p);
      mbedtls_mpi_free((mbedtls_mpi *)&G2.p);
      mbedtls_mpi_free((mbedtls_mpi *)&L1.p);
      mbedtls_mpi_free((mbedtls_mpi *)&L2.p);
      mbedtls_mpi_free((mbedtls_mpi *)&DP.p);
      mbedtls_mpi_free((mbedtls_mpi *)&DQ.p);
      if ((iVar1 != -0x4200) && (iVar1 != 0)) {
        iVar1 = iVar1 + -0x4200;
      }
    }
  }
  return iVar1;
}



int mbedtls_rsa_check_pub_priv(mbedtls_rsa_context *pub,mbedtls_rsa_context *prv)

{
  int iVar1;
  
  iVar1 = mbedtls_rsa_check_pubkey(pub);
  if ((((iVar1 != 0) || (iVar1 = mbedtls_rsa_check_privkey(prv), iVar1 != 0)) ||
      (iVar1 = mbedtls_mpi_cmp_mpi(&pub->N,&prv->N), iVar1 != 0)) ||
     (iVar1 = mbedtls_mpi_cmp_mpi(&pub->E,&prv->E), iVar1 != 0)) {
    iVar1 = -0x4200;
  }
  return iVar1;
}



int mbedtls_rsa_public(mbedtls_rsa_context *ctx,uchar *input,uchar *output)

{
  int iVar1;
  int iVar2;
  size_t buflen;
  undefined auStack44 [4];
  mbedtls_mpi T;
  
  mbedtls_mpi_init((mbedtls_mpi *)auStack44);
  iVar1 = mbedtls_mpi_read_binary((mbedtls_mpi *)auStack44,input,ctx->len);
  if (iVar1 == 0) {
    iVar2 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)auStack44,&ctx->N);
    iVar1 = -4;
    if (iVar2 < 0) {
      buflen = ctx->len;
      iVar1 = mbedtls_mpi_exp_mod((mbedtls_mpi *)auStack44,(mbedtls_mpi *)auStack44,&ctx->E,&ctx->N,
                                  &ctx->RN);
      if (iVar1 == 0) {
        iVar1 = mbedtls_mpi_write_binary((mbedtls_mpi *)auStack44,output,buflen);
      }
    }
  }
  mbedtls_mpi_free((mbedtls_mpi *)auStack44);
  if (iVar1 != 0) {
    iVar1 = iVar1 + -0x4280;
  }
  return iVar1;
}



int mbedtls_rsa_private(mbedtls_rsa_context *ctx,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,
                       void *p_rng,uchar *input,uchar *output)

{
  int iVar1;
  int iVar2;
  mbedtls_mpi *Y;
  mbedtls_mpi *G;
  mbedtls_mpi *X;
  undefined auStack84 [4];
  mbedtls_mpi T;
  mbedtls_mpi T1;
  mbedtls_mpi T2;
  
  if ((((ctx->P).p == (mbedtls_mpi_uint *)0x0) || ((ctx->Q).p == (mbedtls_mpi_uint *)0x0)) ||
     ((ctx->D).p == (mbedtls_mpi_uint *)0x0)) {
    return -0x4080;
  }
  mbedtls_mpi_init((mbedtls_mpi *)auStack84);
  mbedtls_mpi_init((mbedtls_mpi *)&T.p);
  mbedtls_mpi_init((mbedtls_mpi *)&T1.p);
  iVar1 = mbedtls_mpi_read_binary((mbedtls_mpi *)auStack84,input,ctx->len);
  if (iVar1 == 0) {
    Y = &ctx->N;
    iVar2 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)auStack84,Y);
    iVar1 = -4;
    if (iVar2 < 0) {
      if (f_rng != (anon_subr_int_void_ptr_uchar_ptr_size_t *)0x0) {
        if ((ctx->Vf).p == (mbedtls_mpi_uint *)0x0) {
          iVar2 = 0xc;
          X = &ctx->Vf;
          G = &ctx->Vi;
          do {
            iVar2 = iVar2 + -1;
            if (iVar2 == 0) {
              iVar1 = -0x4480;
              goto cleanup;
            }
            iVar1 = mbedtls_mpi_fill_random(X,ctx->len - 1,f_rng,p_rng);
            if ((iVar1 != 0) || (iVar1 = mbedtls_mpi_gcd(G,X,Y), iVar1 != 0)) goto cleanup;
            iVar1 = mbedtls_mpi_cmp_int(G,1);
          } while (iVar1 != 0);
          iVar1 = mbedtls_mpi_inv_mod(G,X,Y);
          if (iVar1 != 0) goto cleanup;
          iVar1 = mbedtls_mpi_exp_mod(G,G,&ctx->E,Y,&ctx->RN);
        }
        else {
          G = &ctx->Vi;
          iVar1 = mbedtls_mpi_mul_mpi(G,G,G);
          if ((iVar1 != 0) || (iVar1 = mbedtls_mpi_mod_mpi(G,G,Y), iVar1 != 0)) goto cleanup;
          G = &ctx->Vf;
          iVar1 = mbedtls_mpi_mul_mpi(G,G,G);
          if (iVar1 != 0) goto cleanup;
          iVar1 = mbedtls_mpi_mod_mpi(G,G,Y);
        }
        if (((iVar1 != 0) ||
            (iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)auStack84,(mbedtls_mpi *)auStack84,&ctx->Vi)
            , iVar1 != 0)) ||
           (iVar1 = mbedtls_mpi_mod_mpi((mbedtls_mpi *)auStack84,(mbedtls_mpi *)auStack84,Y),
           iVar1 != 0)) goto cleanup;
      }
      iVar1 = mbedtls_mpi_exp_mod((mbedtls_mpi *)&T.p,(mbedtls_mpi *)auStack84,&ctx->DP,&ctx->P,
                                  &ctx->RP);
      if (iVar1 == 0) {
        iVar1 = mbedtls_mpi_exp_mod((mbedtls_mpi *)&T1.p,(mbedtls_mpi *)auStack84,&ctx->DQ,&ctx->Q,
                                    &ctx->RQ);
        if (((((iVar1 == 0) &&
              (iVar1 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)auStack84,(mbedtls_mpi *)&T.p,
                                           (mbedtls_mpi *)&T1.p), iVar1 == 0)) &&
             ((iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&T.p,(mbedtls_mpi *)auStack84,&ctx->QP),
              iVar1 == 0 &&
              ((iVar1 = mbedtls_mpi_mod_mpi((mbedtls_mpi *)auStack84,(mbedtls_mpi *)&T.p,&ctx->P),
               iVar1 == 0 &&
               (iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&T.p,(mbedtls_mpi *)auStack84,&ctx->Q),
               iVar1 == 0)))))) &&
            (iVar1 = mbedtls_mpi_add_mpi((mbedtls_mpi *)auStack84,(mbedtls_mpi *)&T1.p,
                                         (mbedtls_mpi *)&T.p), iVar1 == 0)) &&
           ((f_rng == (anon_subr_int_void_ptr_uchar_ptr_size_t *)0x0 ||
            ((iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)auStack84,(mbedtls_mpi *)auStack84,&ctx->Vf
                                         ), iVar1 == 0 &&
             (iVar1 = mbedtls_mpi_mod_mpi((mbedtls_mpi *)auStack84,(mbedtls_mpi *)auStack84,Y),
             iVar1 == 0)))))) {
          iVar1 = mbedtls_mpi_write_binary((mbedtls_mpi *)auStack84,output,ctx->len);
        }
      }
    }
  }
cleanup:
  mbedtls_mpi_free((mbedtls_mpi *)auStack84);
  mbedtls_mpi_free((mbedtls_mpi *)&T.p);
  mbedtls_mpi_free((mbedtls_mpi *)&T1.p);
  if (iVar1 != 0) {
    iVar1 = iVar1 + -0x4300;
  }
  return iVar1;
}



int mbedtls_rsa_rsaes_oaep_encrypt
              (mbedtls_rsa_context *ctx,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng,
              int mode,uchar *label,size_t label_len,size_t ilen,uchar *input,uchar *output)

{
  uint __n;
  size_t dlen;
  uchar slen;
  mbedtls_md_info_t *md_info;
  undefined3 extraout_var;
  int iVar1;
  uint uVar2;
  uchar *output_00;
  uchar *src;
  uchar *in_stack_00000000;
  undefined auStack76 [4];
  mbedtls_md_context_t md_ctx;
  
  if ((((mode != 1) || (ctx->padding == 1)) &&
      (f_rng != (anon_subr_int_void_ptr_uchar_ptr_size_t *)0x0)) &&
     (md_info = mbedtls_md_info_from_type(*(mbedtls_md_type_t *)&ctx->hash_id),
     md_info != (mbedtls_md_info_t *)0x0)) {
    __n = ctx->len;
    slen = mbedtls_md_get_size(md_info);
    _slen = CONCAT31(extraout_var,slen);
    uVar2 = ilen + 2 + _slen * 2;
    if ((ilen <= uVar2) && (uVar2 <= __n)) {
      memset(in_stack_00000000,0,__n);
      src = in_stack_00000000 + 1;
      *in_stack_00000000 = '\0';
      iVar1 = (*f_rng)(p_rng,src,_slen);
      if (iVar1 != 0) {
        return iVar1 + -0x4480;
      }
      output_00 = src + _slen;
      mbedtls_md(md_info,label,label_len,output_00);
      output_00[((__n - ilen) + -2) - _slen] = '\x01';
      memcpy(output_00 + (((__n - ilen) + -2) - _slen) + 1,input,ilen);
      mbedtls_md_init((mbedtls_md_context_t *)auStack76);
      iVar1 = mbedtls_md_setup((mbedtls_md_context_t *)auStack76,md_info,0);
      if (iVar1 != 0) {
        mbedtls_md_free((mbedtls_md_context_t *)auStack76);
        return iVar1;
      }
      dlen = (__n - 1) - _slen;
      mgf_mask(in_stack_00000000 + _slen + 1,dlen,src,_slen,(mbedtls_md_context_t *)auStack76);
      mgf_mask(src,_slen,in_stack_00000000 + _slen + 1,dlen,(mbedtls_md_context_t *)auStack76);
      mbedtls_md_free((mbedtls_md_context_t *)auStack76);
      if (mode == 0) {
        iVar1 = mbedtls_rsa_public(ctx,in_stack_00000000,in_stack_00000000);
        return iVar1;
      }
      iVar1 = mbedtls_rsa_private(ctx,f_rng,p_rng,in_stack_00000000,in_stack_00000000);
      return iVar1;
    }
  }
  return -0x4080;
}



int mbedtls_rsa_rsaes_pkcs1_v15_encrypt
              (mbedtls_rsa_context *ctx,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng,
              int mode,size_t ilen,uchar *input,uchar *output)

{
  int iVar1;
  int iVar2;
  uchar *puVar3;
  uchar *puVar4;
  
  if ((((mode == 1) && (ctx->padding != 0)) ||
      (f_rng == (anon_subr_int_void_ptr_uchar_ptr_size_t *)0x0)) ||
     ((input == (uchar *)0x0 || (output == (uchar *)0x0)))) {
    return -0x4080;
  }
  if ((0xfffffff4 < ilen) || (ctx->len < ilen + 0xb)) {
    return -0x4080;
  }
  iVar1 = ctx->len - ilen;
  *output = '\0';
  iVar2 = iVar1 + -3;
  puVar4 = output + 2;
  if (mode == 0) {
    output[1] = '\x02';
    puVar3 = output + iVar1 + -1;
    while (puVar4 != puVar3) {
      iVar1 = 100;
      while (iVar2 = (*f_rng)(p_rng,puVar4,1), *puVar4 == '\0') {
        iVar1 = iVar1 + -1;
        if ((iVar1 == 0) || (iVar2 != 0)) goto LAB_23057aec;
      }
      if (iVar2 != 0) {
LAB_23057aec:
        return iVar2 + -0x4480;
      }
      puVar4 = puVar4 + 1;
    }
  }
  else {
    output[1] = '\x01';
    puVar3 = output;
    while (output + iVar2 != puVar3) {
      puVar3[2] = -1;
      puVar3 = puVar3 + 1;
    }
    puVar3 = puVar4 + iVar2;
  }
  *puVar3 = '\0';
  memcpy(puVar3 + 1,input,ilen);
  if (mode != 0) {
    iVar1 = mbedtls_rsa_private(ctx,f_rng,p_rng,output,output);
    return iVar1;
  }
  iVar1 = mbedtls_rsa_public(ctx,output,output);
  return iVar1;
}



int mbedtls_rsa_pkcs1_encrypt
              (mbedtls_rsa_context *ctx,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng,
              int mode,size_t ilen,uchar *input,uchar *output)

{
  int iVar1;
  uchar *in_fa0;
  
  if (ctx->padding == 0) {
    iVar1 = mbedtls_rsa_rsaes_pkcs1_v15_encrypt(ctx,f_rng,p_rng,mode,ilen,input,output);
    return iVar1;
  }
  if (ctx->padding != 1) {
    return -0x4100;
  }
  iVar1 = mbedtls_rsa_rsaes_oaep_encrypt(ctx,f_rng,p_rng,mode,(uchar *)0x0,0,ilen,input,in_fa0);
  return iVar1;
}



int mbedtls_rsa_rsaes_oaep_decrypt
              (mbedtls_rsa_context *ctx,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng,
              int mode,uchar *label,size_t label_len,size_t *olen,uchar *input,uchar *output,
              size_t output_max_len)

{
  uint __n;
  uchar dlen;
  mbedtls_md_info_t *md_info;
  undefined3 extraout_var;
  int iVar1;
  uchar *puVar2;
  uint uVar3;
  int iVar4;
  byte *pbVar5;
  byte *pbVar6;
  uchar *output_00;
  int iVar7;
  size_t slen;
  void *in_stack_00000000;
  uint in_stack_00000004;
  undefined auStack1132 [4];
  mbedtls_md_context_t md_ctx;
  uchar lhash [32];
  uchar buf [1024];
  
  if ((((mode != 1) || (ctx->padding == 1)) && (__n = ctx->len, __n - 0x10 < 0x3f1)) &&
     (md_info = mbedtls_md_info_from_type(*(mbedtls_md_type_t *)&ctx->hash_id),
     md_info != (mbedtls_md_info_t *)0x0)) {
    dlen = mbedtls_md_get_size(md_info);
    _dlen = CONCAT31(extraout_var,dlen);
    iVar7 = _dlen + 1;
    if ((uint)(iVar7 * 2) <= __n) {
      output_00 = lhash + 0x1c;
      if (mode == 0) {
        iVar1 = mbedtls_rsa_public(ctx,input,output_00);
      }
      else {
        iVar1 = mbedtls_rsa_private(ctx,f_rng,p_rng,input,output_00);
      }
      if (iVar1 != 0) {
        return iVar1;
      }
      mbedtls_md_init((mbedtls_md_context_t *)auStack1132);
      iVar1 = mbedtls_md_setup((mbedtls_md_context_t *)auStack1132,md_info,0);
      if (iVar1 != 0) {
        mbedtls_md_free((mbedtls_md_context_t *)auStack1132);
        return iVar1;
      }
      mbedtls_md(md_info,label,label_len,(uchar *)&md_ctx.hmac_ctx);
      slen = (__n - 1) - _dlen;
      mgf_mask(lhash + 0x1d,_dlen,output_00 + iVar7,slen,(mbedtls_md_context_t *)auStack1132);
      mgf_mask(output_00 + iVar7,slen,lhash + 0x1d,_dlen,(mbedtls_md_context_t *)auStack1132);
      mbedtls_md_free((mbedtls_md_context_t *)auStack1132);
      uVar3 = 0;
      while (uVar3 < _dlen) {
        pbVar5 = (byte *)((int)&md_ctx.hmac_ctx + uVar3);
        pbVar6 = lhash + _dlen + 0x1d + uVar3;
        uVar3 = uVar3 + 1;
        lhash[28] = *pbVar5 ^ *pbVar6 | lhash[28];
      }
      puVar2 = lhash + _dlen + 0x1d + _dlen;
      uVar3 = 0;
      iVar4 = 0;
      iVar1 = 0;
      while (__n + iVar7 * -2 != iVar1) {
        pbVar6 = puVar2 + iVar1;
        iVar1 = iVar1 + 1;
        uVar3 = uVar3 | *pbVar6;
        iVar4 = iVar4 + ((-uVar3 & 0xff | uVar3) >> 7 ^ 1);
      }
      if ((byte)(puVar2[iVar4] ^ 1 | lhash[28]) == 0) {
        __n = __n - (int)(puVar2 + iVar4 + 1 + -(int)output_00);
        if (__n <= in_stack_00000004) {
          *olen = __n;
          memcpy(in_stack_00000000,puVar2 + iVar4 + 1,__n);
          return 0;
        }
        return -0x4400;
      }
      return -0x4100;
    }
  }
  return -0x4080;
}



// WARNING: Variable defined which should be unmapped: buf

int mbedtls_rsa_rsaes_pkcs1_v15_decrypt
              (mbedtls_rsa_context *ctx,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng,
              int mode,size_t *olen,uchar *input,uchar *output,size_t output_max_len)

{
  char *pcVar1;
  int iVar2;
  uint __n;
  byte *pbVar3;
  uint uVar4;
  uint uVar5;
  byte *pbVar6;
  size_t sVar7;
  byte local_420;
  byte bStack1055;
  byte abStack1054 [2];
  uchar buf [1024];
  
  pbVar6 = &local_420;
  pbVar3 = &local_420;
  if (((mode == 1) && (ctx->padding != 0)) || (sVar7 = ctx->len, 0x3f0 < sVar7 - 0x10)) {
    iVar2 = -0x4080;
  }
  else {
    if (mode == 0) {
      iVar2 = mbedtls_rsa_public(ctx,input,&local_420);
    }
    else {
      iVar2 = mbedtls_rsa_private(ctx,f_rng,p_rng,input,&local_420);
    }
    if (iVar2 == 0) {
      if (mode == 1) {
        bStack1055 = bStack1055 ^ 2;
        uVar4 = 0;
        __n = 0;
        uVar5 = 0;
        do {
          pbVar3 = pbVar6 + 2;
          __n = __n + 1;
          pbVar6 = pbVar6 + 1;
          uVar4 = uVar4 | ((uint)*pbVar3 | -(uint)*pbVar3 & 0xff) >> 7 ^ 1;
          uVar5 = uVar5 + ((-uVar4 & 0xff) >> 7 ^ 1);
        } while (__n < sVar7 - 3);
      }
      else {
        bStack1055 = bStack1055 ^ 1;
        uVar4 = 0;
        __n = 0;
        uVar5 = 0;
        do {
          pcVar1 = (char *)(pbVar3 + 2);
          __n = __n + 1;
          pbVar3 = pbVar3 + 1;
          uVar4 = *pcVar1 != -1 | uVar4;
          uVar5 = uVar5 + (uVar4 ^ 1);
        } while (__n < sVar7 - 3);
      }
      if ((byte)(uVar5 < 8 | bStack1055 | local_420 | abStack1054[uVar5]) == 0) {
        __n = sVar7 - (int)(abStack1054 + uVar5 + 1 + -(int)&local_420);
        if (output_max_len < __n) {
          iVar2 = -0x4400;
        }
        else {
          *olen = __n;
          memcpy(output,abStack1054 + uVar5 + 1,__n);
        }
      }
      else {
        iVar2 = -0x4100;
      }
    }
  }
  return iVar2;
}



int mbedtls_rsa_pkcs1_decrypt
              (mbedtls_rsa_context *ctx,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng,
              int mode,size_t *olen,uchar *input,uchar *output,size_t output_max_len)

{
  int iVar1;
  uchar *in_fa0;
  size_t in_fa1;
  
  if (ctx->padding == 0) {
    iVar1 = mbedtls_rsa_rsaes_pkcs1_v15_decrypt
                      (ctx,f_rng,p_rng,mode,olen,input,output,output_max_len);
    return iVar1;
  }
  if (ctx->padding != 1) {
    return -0x4100;
  }
  iVar1 = mbedtls_rsa_rsaes_oaep_decrypt
                    (ctx,f_rng,p_rng,mode,(uchar *)0x0,0,olen,input,in_fa0,in_fa1);
  return iVar1;
}



int mbedtls_rsa_rsassa_pss_sign
              (mbedtls_rsa_context *ctx,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng,
              int mode,mbedtls_md_type_t md_alg,uint hashlen,uchar *hash,uchar *sig)

{
  uint __n;
  uchar uVar1;
  mbedtls_md_info_t *md_info;
  undefined3 extraout_var;
  size_t __n_00;
  int iVar2;
  size_t sVar3;
  uint uVar4;
  undefined3 in_register_00002039;
  uchar *input;
  undefined auStack108 [4];
  mbedtls_md_context_t md_ctx;
  uchar salt [32];
  
  if (((mode != 1) || (ctx->padding == 1)) &&
     (f_rng != (anon_subr_int_void_ptr_uchar_ptr_size_t *)0x0)) {
    __n = ctx->len;
    if (CONCAT31(in_register_00002039,md_alg) != 0) {
      md_info = mbedtls_md_info_from_type(md_alg);
      if (md_info == (mbedtls_md_info_t *)0x0) {
        return -0x4080;
      }
      uVar1 = mbedtls_md_get_size(md_info);
      hashlen = CONCAT31(extraout_var,uVar1);
    }
    md_info = mbedtls_md_info_from_type(*(mbedtls_md_type_t *)&ctx->hash_id);
    if (md_info != (mbedtls_md_info_t *)0x0) {
      uVar1 = mbedtls_md_get_size(md_info);
      __n_00 = CONCAT31(__n_00._1_3_,uVar1);
      if ((__n_00 + 1) * 2 <= __n) {
        memset(sig,0,__n);
        iVar2 = (*f_rng)(p_rng,(uchar *)&md_ctx.hmac_ctx,__n_00);
        if (iVar2 != 0) {
          return iVar2 + -0x4480;
        }
        sVar3 = mbedtls_mpi_bitlen(&ctx->N);
        input = sig + __n + (__n_00 + 1) * -2;
        *input = '\x01';
        memcpy(input + 1,&md_ctx.hmac_ctx,__n_00);
        mbedtls_md_init((mbedtls_md_context_t *)auStack108);
        iVar2 = mbedtls_md_setup((mbedtls_md_context_t *)auStack108,md_info,0);
        if (iVar2 == 0) {
          input = input + 1 + __n_00;
          mbedtls_md_starts((mbedtls_md_context_t *)auStack108);
          mbedtls_md_update((mbedtls_md_context_t *)auStack108,input,8);
          mbedtls_md_update((mbedtls_md_context_t *)auStack108,hash,hashlen);
          mbedtls_md_update((mbedtls_md_context_t *)auStack108,(uchar *)&md_ctx.hmac_ctx,__n_00);
          mbedtls_md_finish((mbedtls_md_context_t *)auStack108,input);
          uVar4 = (uint)((sVar3 - 1 & 7) == 0);
          mgf_mask(sig + uVar4,((__n - 1) - __n_00) - uVar4,input,__n_00,
                   (mbedtls_md_context_t *)auStack108);
          mbedtls_md_free((mbedtls_md_context_t *)auStack108);
          sVar3 = mbedtls_mpi_bitlen(&ctx->N);
          *sig = (byte)(0xff >> ((__n * 8 + 1) - sVar3 & 0x1f)) & *sig;
          input[__n_00] = -0x44;
          if (mode != 0) {
            iVar2 = mbedtls_rsa_private(ctx,f_rng,p_rng,sig,sig);
            return iVar2;
          }
          iVar2 = mbedtls_rsa_public(ctx,sig,sig);
          return iVar2;
        }
        mbedtls_md_free((mbedtls_md_context_t *)auStack108);
        return iVar2;
      }
    }
  }
  return -0x4080;
}



// WARNING: Could not reconcile some variable overlaps

int mbedtls_rsa_rsassa_pkcs1_v15_sign
              (mbedtls_rsa_context *ctx,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng,
              int mode,mbedtls_md_type_t md_alg,uint hashlen,uchar *hash,uchar *sig)

{
  uint uVar1;
  int iVar2;
  uint __n;
  uchar uVar3;
  mbedtls_md_info_t *md_info;
  int iVar4;
  undefined3 extraout_var;
  uchar *output;
  uchar *output_00;
  byte *pbVar5;
  byte *pbVar6;
  byte bVar7;
  undefined3 in_register_00002039;
  size_t sVar8;
  uchar diff_no_optimize;
  size_t __n_00;
  size_t oid_size;
  char *oid;
  
  __n_00 = 0;
  oid_size = 0;
  if ((mode != 1) || (ctx->padding == 0)) {
    uVar1 = ctx->len;
    iVar2 = uVar1 - 3;
    if (CONCAT31(in_register_00002039,md_alg) != 0) {
      md_info = mbedtls_md_info_from_type(md_alg);
      if (md_info == (mbedtls_md_info_t *)0x0) {
        return -0x4080;
      }
      iVar4 = mbedtls_oid_get_oid_by_md(md_alg,(char **)&oid_size,(size_t *)&stack0xffffffc8);
      if (iVar4 != 0) {
        return -0x4080;
      }
      iVar2 = iVar2 - __n_00;
      uVar3 = mbedtls_md_get_size(md_info);
      hashlen = CONCAT31(extraout_var,uVar3);
      iVar2 = iVar2 + -10;
    }
    __n = iVar2 - hashlen;
    if ((7 < __n) && (__n <= uVar1)) {
      *sig = '\0';
      sig[1] = '\x01';
      memset(sig + 2,0xff,__n);
      output = sig + 2 + __n;
      *output = '\0';
      if (CONCAT31(in_register_00002039,md_alg) == 0) {
        output = output + 1;
      }
      else {
        uVar3 = (uchar)__n_00;
        output[2] = uVar3 + '\b' + (uchar)hashlen;
        output[4] = uVar3 + '\x04';
        output[6] = uVar3;
        output[1] = '0';
        output[3] = '0';
        output[5] = '\x06';
        memcpy(output + 7,(void *)oid_size,__n_00);
        output = output + 7 + __n_00;
        *output = '\x05';
        output[1] = '\0';
        output[2] = '\x04';
        output[3] = (uchar)hashlen;
        output = output + 4;
      }
      memcpy(output,hash,hashlen);
      if (mode != 0) {
        iVar2 = -0x10;
        output = (uchar *)mycalloc(1,ctx->len);
        if (output != (uchar *)0x0) {
          output_00 = (uchar *)mycalloc(1,ctx->len);
          if (output_00 != (uchar *)0x0) {
            iVar2 = mbedtls_rsa_private(ctx,f_rng,p_rng,sig,output);
            if ((iVar2 == 0) && (iVar2 = mbedtls_rsa_public(ctx,output,output_00), iVar2 == 0)) {
              bVar7 = 0;
              sVar8 = 0;
              while (ctx->len != sVar8) {
                pbVar6 = output_00 + sVar8;
                pbVar5 = sig + sVar8;
                sVar8 = sVar8 + 1;
                bVar7 = bVar7 | *pbVar6 ^ *pbVar5;
              }
              if (bVar7 == 0) {
                memcpy(sig,output,ctx->len);
              }
              else {
                iVar2 = -0x4300;
              }
            }
            vPortFree(output);
            output = output_00;
          }
          vPortFree(output);
          return iVar2;
        }
        return -0x10;
      }
      iVar2 = mbedtls_rsa_public(ctx,sig,sig);
      return iVar2;
    }
  }
  return -0x4080;
}



int mbedtls_rsa_pkcs1_sign
              (mbedtls_rsa_context *ctx,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng,
              int mode,mbedtls_md_type_t md_alg,uint hashlen,uchar *hash,uchar *sig)

{
  int iVar1;
  
  if (ctx->padding == 0) {
    iVar1 = mbedtls_rsa_rsassa_pkcs1_v15_sign(ctx,f_rng,p_rng,mode,md_alg,hashlen,hash,sig);
    return iVar1;
  }
  if (ctx->padding != 1) {
    return -0x4100;
  }
  iVar1 = mbedtls_rsa_rsassa_pss_sign(ctx,f_rng,p_rng,mode,md_alg,hashlen,hash,sig);
  return iVar1;
}



// WARNING: Type propagation algorithm not settling

int mbedtls_rsa_rsassa_pss_verify_ext
              (mbedtls_rsa_context *ctx,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng,
              int mode,mbedtls_md_type_t md_alg,uint hashlen,uchar *hash,
              mbedtls_md_type_t mgf1_hash_id,int expected_salt_len,uchar *sig)

{
  uchar *dst;
  uchar *puVar1;
  uchar uVar2;
  int iVar3;
  mbedtls_md_info_t *md_info;
  undefined3 extraout_var;
  uint slen;
  size_t sVar4;
  undefined3 in_register_00002039;
  size_t ilen;
  size_t sVar5;
  uchar *output;
  size_t in_stack_00000000;
  uchar *in_stack_00000004;
  uchar auStack1124 [4];
  uchar zeros [8];
  mbedtls_md_context_t md_ctx;
  uchar result [32];
  uchar buf [1024];
  
  if (((mode != 1) || (ctx->padding == 1)) && (ilen = ctx->len, ilen - 0x10 < 0x3f1)) {
    output = result + 0x1c;
    if (mode == 0) {
      iVar3 = mbedtls_rsa_public(ctx,in_stack_00000004,output);
    }
    else {
      iVar3 = mbedtls_rsa_private(ctx,f_rng,p_rng,in_stack_00000004,output);
    }
    if (iVar3 != 0) {
      return iVar3;
    }
    if (result[ilen + 0x1b] != -0x44) {
      return -0x4100;
    }
    if (CONCAT31(in_register_00002039,md_alg) != 0) {
      md_info = mbedtls_md_info_from_type(md_alg);
      if (md_info == (mbedtls_md_info_t *)0x0) {
        return -0x4080;
      }
      uVar2 = mbedtls_md_get_size(md_info);
      hashlen = CONCAT31(extraout_var,uVar2);
    }
    md_info = mbedtls_md_info_from_type(mgf1_hash_id);
    if (md_info != (mbedtls_md_info_t *)0x0) {
      uVar2 = mbedtls_md_get_size(md_info);
      slen = CONCAT31(slen._1_3_,uVar2);
      memset(auStack1124,0,8);
      sVar4 = mbedtls_mpi_bitlen(&ctx->N);
      dst = output;
      sVar5 = ilen;
      if ((sVar4 - 1 & 7) == 0) {
        dst = result + 0x1d;
        sVar5 = ilen - 1;
      }
      if ((int)(uint)result[28] >> (sVar5 * -8 + sVar4 + 7 & 0x1f) == 0) {
        mbedtls_md_init((mbedtls_md_context_t *)(zeros + 4));
        iVar3 = mbedtls_md_setup((mbedtls_md_context_t *)(zeros + 4),md_info,0);
        if (iVar3 != 0) {
          mbedtls_md_free((mbedtls_md_context_t *)(zeros + 4));
          return iVar3;
        }
        mgf_mask(dst,~slen + sVar5,dst + ~slen + sVar5,slen,(mbedtls_md_context_t *)(zeros + 4));
        result[28] = (byte)(0xff >> (sVar5 * 8 - (sVar4 - 1) & 0x1f)) & result[28];
        do {
          puVar1 = dst;
          if (output + sVar5 <= puVar1) {
            if (output + sVar5 == puVar1) goto LAB_230584a6;
            break;
          }
          dst = puVar1 + 1;
        } while (*puVar1 == '\0');
        dst = puVar1 + 1;
        if ((*puVar1 == '\x01') &&
           ((ilen = ((ilen - 1) - slen) - (int)(dst + -(int)output), in_stack_00000000 == 0xffffffff
            || (in_stack_00000000 == ilen)))) {
          mbedtls_md_starts((mbedtls_md_context_t *)(zeros + 4));
          mbedtls_md_update((mbedtls_md_context_t *)(zeros + 4),auStack1124,8);
          mbedtls_md_update((mbedtls_md_context_t *)(zeros + 4),hash,hashlen);
          mbedtls_md_update((mbedtls_md_context_t *)(zeros + 4),dst,ilen);
          mbedtls_md_finish((mbedtls_md_context_t *)(zeros + 4),(uchar *)&md_ctx.hmac_ctx);
          mbedtls_md_free((mbedtls_md_context_t *)(zeros + 4));
          iVar3 = memcmp(dst + ilen,&md_ctx.hmac_ctx,slen);
          if (iVar3 == 0) {
            return 0;
          }
          return -0x4380;
        }
LAB_230584a6:
        mbedtls_md_free((mbedtls_md_context_t *)(zeros + 4));
        return -0x4100;
      }
    }
  }
  return -0x4080;
}



int mbedtls_rsa_rsassa_pss_verify
              (mbedtls_rsa_context *ctx,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng,
              int mode,mbedtls_md_type_t md_alg,uint hashlen,uchar *hash,uchar *sig)

{
  int iVar1;
  mbedtls_md_type_t mgf1_hash_id;
  int in_fa0;
  uchar *in_fa1;
  
  mgf1_hash_id = (mbedtls_md_type_t)ctx->hash_id;
  if (ctx->hash_id == 0) {
    mgf1_hash_id = md_alg;
  }
  iVar1 = mbedtls_rsa_rsassa_pss_verify_ext
                    (ctx,f_rng,p_rng,mode,md_alg,hashlen,hash,mgf1_hash_id,in_fa0,in_fa1);
  return iVar1;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Could not reconcile some variable overlaps

int mbedtls_rsa_rsassa_pkcs1_v15_verify
              (mbedtls_rsa_context *ctx,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng,
              int mode,mbedtls_md_type_t md_alg,uint hashlen,uchar *hash,uchar *sig)

{
  uchar **output;
  uint uVar1;
  uchar *end;
  uchar __n;
  int iVar2;
  mbedtls_md_info_t *md_info;
  undefined3 extraout_var;
  undefined3 in_register_00002039;
  size_t sVar3;
  mbedtls_md_type_t mStack1077;
  mbedtls_md_type_t msg_md_alg;
  size_t sStack1076;
  size_t asn1_len;
  uchar *p;
  mbedtls_asn1_buf oid;
  uchar buf [1024];
  
  if ((mode == 1) && (ctx->padding != 0)) {
    return -0x4080;
  }
  sVar3 = ctx->len;
  if (sVar3 - 0x10 < 0x3f1) {
    output = &oid.p;
    if (mode == 0) {
      iVar2 = mbedtls_rsa_public(ctx,sig,(uchar *)output);
    }
    else {
      iVar2 = mbedtls_rsa_private(ctx,f_rng,p_rng,sig,(uchar *)output);
    }
    if (iVar2 != 0) {
      return iVar2;
    }
    if (((char)oid.p != '\0') || (asn1_len = (int)&oid.p + 2, oid.p._1_1_ != '\x01')) {
      return -0x4100;
    }
    while (*(uchar *)asn1_len != '\0') {
      if ((uchar *)((int)output + (sVar3 - 1)) <= asn1_len) {
        return -0x4100;
      }
      if (*(uchar *)asn1_len != -1) {
        return -0x4100;
      }
      asn1_len = asn1_len + 1;
    }
    asn1_len = asn1_len + 1;
    uVar1 = sVar3 - (int)((uchar *)asn1_len + -(int)output);
    if ((uVar1 == hashlen) && (CONCAT31(in_register_00002039,md_alg) == 0)) {
      iVar2 = memcmp((void *)asn1_len,hash,hashlen);
      if (iVar2 == 0) {
        return 0;
      }
    }
    else {
      md_info = mbedtls_md_info_from_type(md_alg);
      if (md_info == (mbedtls_md_info_t *)0x0) goto LAB_230584ee;
      __n = mbedtls_md_get_size(md_info);
      ___n = CONCAT31(extraout_var,__n);
      end = (uchar *)(asn1_len + uVar1);
      iVar2 = mbedtls_asn1_get_tag((uchar **)&asn1_len,end,(size_t *)&stack0xfffffbcc,0x30);
      if ((((iVar2 == 0) && (sStack1076 + 2 == uVar1)) &&
          (iVar2 = mbedtls_asn1_get_tag((uchar **)&asn1_len,end,(size_t *)&stack0xfffffbcc,0x30),
          iVar2 == 0)) &&
         ((sStack1076 + 6 + ___n == uVar1 &&
          (iVar2 = mbedtls_asn1_get_tag((uchar **)&asn1_len,end,(size_t *)&oid,6), iVar2 == 0)))) {
        oid.len = asn1_len;
        asn1_len = asn1_len + oid.tag;
        iVar2 = mbedtls_oid_get_md_alg((mbedtls_asn1_buf *)&p,&mStack1077);
        if (((iVar2 == 0) &&
            (((uint)mStack1077 == CONCAT31(in_register_00002039,md_alg) &&
             (iVar2 = mbedtls_asn1_get_tag((uchar **)&asn1_len,end,(size_t *)&stack0xfffffbcc,5),
             iVar2 == 0)))) &&
           ((iVar2 = mbedtls_asn1_get_tag((uchar **)&asn1_len,end,(size_t *)&stack0xfffffbcc,4),
            iVar2 == 0 &&
            (((sStack1076 == ___n && (iVar2 = memcmp((void *)asn1_len,hash,___n), iVar2 == 0)) &&
             (end == (uchar *)(___n + asn1_len))))))) {
          return 0;
        }
      }
    }
    iVar2 = -0x4380;
  }
  else {
LAB_230584ee:
    iVar2 = -0x4080;
  }
  return iVar2;
}



int mbedtls_rsa_pkcs1_verify
              (mbedtls_rsa_context *ctx,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng,
              int mode,mbedtls_md_type_t md_alg,uint hashlen,uchar *hash,uchar *sig)

{
  int iVar1;
  
  if (ctx->padding == 0) {
    iVar1 = mbedtls_rsa_rsassa_pkcs1_v15_verify(ctx,f_rng,p_rng,mode,md_alg,hashlen,hash,sig);
    return iVar1;
  }
  if (ctx->padding != 1) {
    return -0x4100;
  }
  iVar1 = mbedtls_rsa_rsassa_pss_verify(ctx,f_rng,p_rng,mode,md_alg,hashlen,hash,sig);
  return iVar1;
}



void mbedtls_rsa_free(mbedtls_rsa_context *ctx)

{
  mbedtls_mpi_free(&ctx->Vi);
  mbedtls_mpi_free(&ctx->Vf);
  mbedtls_mpi_free(&ctx->RQ);
  mbedtls_mpi_free(&ctx->RP);
  mbedtls_mpi_free(&ctx->RN);
  mbedtls_mpi_free(&ctx->QP);
  mbedtls_mpi_free(&ctx->DQ);
  mbedtls_mpi_free(&ctx->DP);
  mbedtls_mpi_free(&ctx->Q);
  mbedtls_mpi_free(&ctx->P);
  mbedtls_mpi_free(&ctx->D);
  mbedtls_mpi_free(&ctx->E);
  mbedtls_mpi_free(&ctx->N);
  return;
}



void mbedtls_sha256_init(mbedtls_sha256_context *ctx)

{
  memset(ctx,0,0x74);
  return;
}



void mbedtls_sha256_free(mbedtls_sha256_context *ctx)

{
  mbedtls_sha256_context *pmVar1;
  
  pmVar1 = ctx + 1;
  if (ctx != (mbedtls_sha256_context *)0x0) {
    while (ctx != pmVar1) {
      *(undefined *)ctx->total = 0;
      ctx = (mbedtls_sha256_context *)((int)ctx->total + 1);
    }
  }
  return;
}



void mbedtls_sha256_clone(mbedtls_sha256_context *dst,mbedtls_sha256_context *src)

{
  memcpy(dst,src,0x74);
  return;
}



void mbedtls_sha256_starts(mbedtls_sha256_context *ctx,int is224)

{
  uint32_t uVar1;
  
  ctx->total[0] = 0;
  ctx->total[1] = 0;
  if (is224 == 0) {
    ctx->state[0] = 0x6a09e667;
    ctx->state[1] = 0xbb67ae85;
    ctx->state[2] = 0x3c6ef372;
    ctx->state[3] = 0xa54ff53a;
    ctx->state[4] = 0x510e527f;
    ctx->state[5] = 0x9b05688c;
    ctx->state[6] = 0x1f83d9ab;
    uVar1 = 0x5be0cd19;
  }
  else {
    ctx->state[0] = 0xc1059ed8;
    ctx->state[1] = 0x367cd507;
    ctx->state[2] = 0x3070dd17;
    ctx->state[3] = 0xf70e5939;
    ctx->state[4] = 0xffc00b31;
    ctx->state[5] = 0x68581511;
    ctx->state[6] = 0x64f98fa7;
    uVar1 = 0xbefa4fa4;
  }
  ctx->state[7] = uVar1;
  ctx->is224 = is224;
  return;
}



void mbedtls_sha256_process(mbedtls_sha256_context *ctx,uchar *data)

{
  uint uVar1;
  uint32_t *puVar2;
  byte *pbVar3;
  byte *pbVar4;
  uint uVar5;
  uint uVar6;
  uint32_t uVar7;
  uint uVar8;
  uint32_t *puVar9;
  uint uVar10;
  uint32_t *puVar11;
  uint uVar12;
  int iVar13;
  uint uVar14;
  uint uVar15;
  uint uVar16;
  uint uVar17;
  uint32_t *puVar18;
  uint uVar19;
  uint uVar20;
  uint uVar21;
  uint32_t *puVar22;
  uint uVar23;
  uint32_t uVar24;
  uint uVar25;
  uint32_t *puVar26;
  uint32_t uVar27;
  uint32_t local_150;
  uint32_t A [8];
  uint32_t W [64];
  
  puVar18 = &local_150;
  puVar9 = &local_150;
  puVar11 = ctx->state;
  do {
    uVar7 = *puVar11;
    puVar11 = puVar11 + 1;
    *puVar9 = uVar7;
    puVar9 = puVar9 + 1;
  } while ((uint32_t *)ctx->buffer != puVar11);
  puVar11 = A + 7;
  pbVar3 = data;
  puVar9 = puVar11;
  do {
    pbVar4 = pbVar3 + 4;
    *puVar9 = (uint)*pbVar3 << 0x18 | (uint)pbVar3[1] << 0x10 | (uint)pbVar3[3] |
              (uint)pbVar3[2] << 8;
    pbVar3 = pbVar4;
    puVar9 = puVar9 + 1;
  } while (data + 0x40 != pbVar4);
  puVar2 = K;
  puVar9 = K;
  puVar26 = puVar11;
  do {
    puVar22 = puVar9 + 8;
    iVar13 = A[6] + ((A[3] >> 6 | A[3] << 0x1a) ^ (A[3] >> 0xb | A[3] << 0x15) ^
                    (A[3] << 7 | A[3] >> 0x19)) + *puVar9 + *puVar26 + ((A[5] ^ A[4]) & A[3] ^ A[5])
    ;
    uVar12 = A[2] + iVar13;
    uVar14 = iVar13 + ((local_150 >> 2 | local_150 << 0x1e) ^ (local_150 >> 0xd | local_150 << 0x13)
                      ^ (local_150 << 10 | local_150 >> 0x16)) +
                      ((local_150 | A[0]) & A[1] | local_150 & A[0]);
    iVar13 = ((uVar12 >> 6 | uVar12 * 0x4000000) ^ (uVar12 >> 0xb | uVar12 * 0x200000) ^
             (uVar12 * 0x80 | uVar12 >> 0x19)) +
             A[5] + puVar9[1] + puVar26[1] + ((A[3] ^ A[4]) & uVar12 ^ A[4]);
    uVar1 = ((uVar14 >> 2 | uVar14 * 0x40000000) ^ (uVar14 >> 0xd | uVar14 * 0x80000) ^
            (uVar14 * 0x400 | uVar14 >> 0x16)) + ((uVar14 | local_150) & A[0] | uVar14 & local_150)
            + iVar13;
    uVar10 = A[1] + iVar13;
    iVar13 = ((uVar10 >> 6 | uVar10 * 0x4000000) ^ (uVar10 >> 0xb | uVar10 * 0x200000) ^
             (uVar10 * 0x80 | uVar10 >> 0x19)) +
             A[4] + puVar9[2] + puVar26[2] + ((uVar12 ^ A[3]) & uVar10 ^ A[3]);
    uVar5 = ((uVar1 >> 2 | uVar1 * 0x40000000) ^ (uVar1 >> 0xd | uVar1 * 0x80000) ^
            (uVar1 * 0x400 | uVar1 >> 0x16)) + ((uVar14 | uVar1) & local_150 | uVar14 & uVar1) +
            iVar13;
    uVar8 = A[0] + iVar13;
    iVar13 = ((uVar8 >> 6 | uVar8 * 0x4000000) ^ (uVar8 >> 0xb | uVar8 * 0x200000) ^
             (uVar8 * 0x80 | uVar8 >> 0x19)) +
             A[3] + puVar9[3] + puVar26[3] + ((uVar12 ^ uVar10) & uVar8 ^ uVar12);
    uVar16 = ((uVar5 >> 2 | uVar5 * 0x40000000) ^ (uVar5 >> 0xd | uVar5 * 0x80000) ^
             (uVar5 * 0x400 | uVar5 >> 0x16)) + ((uVar1 | uVar5) & uVar14 | uVar1 & uVar5) + iVar13;
    uVar6 = local_150 + iVar13;
    iVar13 = ((uVar6 >> 6 | uVar6 * 0x4000000) ^ (uVar6 >> 0xb | uVar6 * 0x200000) ^
             (uVar6 * 0x80 | uVar6 >> 0x19)) +
             uVar12 + puVar9[4] + puVar26[4] + ((uVar10 ^ uVar8) & uVar6 ^ uVar10);
    A[2] = ((uVar16 >> 2 | uVar16 * 0x40000000) ^ (uVar16 >> 0xd | uVar16 * 0x80000) ^
           (uVar16 * 0x400 | uVar16 >> 0x16)) + ((uVar5 | uVar16) & uVar1 | uVar5 & uVar16) + iVar13
    ;
    A[6] = uVar14 + iVar13;
    iVar13 = ((A[6] >> 6 | A[6] * 0x4000000) ^ (A[6] >> 0xb | A[6] * 0x200000) ^
             (A[6] * 0x80 | A[6] >> 0x19)) +
             uVar10 + puVar9[5] + puVar26[5] + ((uVar8 ^ uVar6) & A[6] ^ uVar8);
    A[1] = ((A[2] >> 2 | A[2] * 0x40000000) ^ (A[2] >> 0xd | A[2] * 0x80000) ^
           (A[2] * 0x400 | A[2] >> 0x16)) + ((uVar16 | A[2]) & uVar5 | uVar16 & A[2]) + iVar13;
    A[5] = uVar1 + iVar13;
    iVar13 = ((A[5] >> 6 | A[5] * 0x4000000) ^ (A[5] >> 0xb | A[5] * 0x200000) ^
             (A[5] * 0x80 | A[5] >> 0x19)) +
             uVar8 + puVar9[6] + puVar26[6] + ((uVar6 ^ A[6]) & A[5] ^ uVar6);
    A[0] = ((A[1] >> 2 | A[1] * 0x40000000) ^ (A[1] >> 0xd | A[1] * 0x80000) ^
           (A[1] * 0x400 | A[1] >> 0x16)) + ((A[2] | A[1]) & uVar16 | A[2] & A[1]) + iVar13;
    A[4] = uVar5 + iVar13;
    iVar13 = ((A[4] >> 6 | A[4] * 0x4000000) ^ (A[4] >> 0xb | A[4] * 0x200000) ^
             (A[4] * 0x80 | A[4] >> 0x19)) +
             uVar6 + puVar9[7] + puVar26[7] + ((A[6] ^ A[5]) & A[4] ^ A[6]);
    A[3] = uVar16 + iVar13;
    local_150 = ((A[0] >> 2 | A[0] * 0x40000000) ^ (A[0] >> 0xd | A[0] * 0x80000) ^
                (A[0] * 0x400 | A[0] >> 0x16)) + ((A[1] | A[0]) & A[2] | A[1] & A[0]) + iVar13;
    puVar9 = puVar22;
    puVar26 = puVar26 + 8;
  } while (puVar22 != K + 0x10);
  do {
    uVar19 = puVar11[0xe];
    uVar1 = puVar11[1];
    uVar20 = puVar11[0xf];
    uVar23 = ((uVar19 << 0xf | uVar19 >> 0x11) ^ (uVar19 << 0xd | uVar19 >> 0x13) ^ uVar19 >> 10) +
             puVar11[9] + *puVar11 +
             ((uVar1 >> 7 | uVar1 << 0x19) ^ (uVar1 << 0xe | uVar1 >> 0x12) ^ uVar1 >> 3);
    uVar10 = puVar11[3];
    iVar13 = A[6] + ((A[3] >> 6 | A[3] << 0x1a) ^ (A[3] >> 0xb | A[3] << 0x15) ^
                    (A[3] << 7 | A[3] >> 0x19)) + ((A[5] ^ A[4]) & A[3] ^ A[5]) + puVar2[0x10] +
                    uVar23;
    uVar16 = A[2] + iVar13;
    uVar15 = iVar13 + ((local_150 >> 2 | local_150 << 0x1e) ^ (local_150 >> 0xd | local_150 << 0x13)
                      ^ (local_150 << 10 | local_150 >> 0x16)) +
                      ((local_150 | A[0]) & A[1] | local_150 & A[0]);
    uVar6 = puVar11[2];
    uVar1 = ((uVar20 << 0xf | uVar20 >> 0x11) ^ (uVar20 << 0xd | uVar20 >> 0x13) ^ uVar20 >> 10) +
            uVar1 + puVar11[10] +
            ((uVar6 >> 7 | uVar6 << 0x19) ^ (uVar6 << 0xe | uVar6 >> 0x12) ^ uVar6 >> 3);
    iVar13 = ((A[3] ^ A[4]) & uVar16 ^ A[4]) + A[5] + puVar2[0x11] + uVar1 +
             ((uVar16 >> 6 | uVar16 * 0x4000000) ^ (uVar16 >> 0xb | uVar16 * 0x200000) ^
             (uVar16 * 0x80 | uVar16 >> 0x19));
    uVar5 = ((uVar15 >> 2 | uVar15 * 0x40000000) ^ (uVar15 >> 0xd | uVar15 * 0x80000) ^
            (uVar15 * 0x400 | uVar15 >> 0x16)) + ((local_150 | uVar15) & A[0] | local_150 & uVar15)
            + iVar13;
    uVar14 = A[1] + iVar13;
    uVar6 = ((uVar23 * 0x8000 | uVar23 >> 0x11) ^ (uVar23 * 0x2000 | uVar23 >> 0x13) ^ uVar23 >> 10)
            + uVar6 + puVar11[0xb] +
            ((uVar10 >> 7 | uVar10 << 0x19) ^ (uVar10 << 0xe | uVar10 >> 0x12) ^ uVar10 >> 3);
    iVar13 = ((A[3] ^ uVar16) & uVar14 ^ A[3]) + A[4] + puVar2[0x12] + uVar6 +
             ((uVar14 >> 6 | uVar14 * 0x4000000) ^ (uVar14 >> 0xb | uVar14 * 0x200000) ^
             (uVar14 * 0x80 | uVar14 >> 0x19));
    puVar11[0x11] = uVar1;
    uVar8 = ((uVar5 >> 2 | uVar5 * 0x40000000) ^ (uVar5 >> 0xd | uVar5 * 0x80000) ^
            (uVar5 * 0x400 | uVar5 >> 0x16)) + ((uVar15 | uVar5) & local_150 | uVar15 & uVar5) +
            iVar13;
    uVar12 = A[0] + iVar13;
    uVar25 = puVar11[4];
    uVar1 = ((uVar1 * 0x8000 | uVar1 >> 0x11) ^ (uVar1 * 0x2000 | uVar1 >> 0x13) ^ uVar1 >> 10) +
            uVar10 + puVar11[0xc] +
            ((uVar25 >> 7 | uVar25 << 0x19) ^ (uVar25 << 0xe | uVar25 >> 0x12) ^ uVar25 >> 3);
    iVar13 = ((uVar16 ^ uVar14) & uVar12 ^ uVar16) + A[3] + puVar2[0x13] + uVar1 +
             ((uVar12 >> 6 | uVar12 * 0x4000000) ^ (uVar12 >> 0xb | uVar12 * 0x200000) ^
             (uVar12 * 0x80 | uVar12 >> 0x19));
    uVar17 = ((uVar8 >> 2 | uVar8 * 0x40000000) ^ (uVar8 >> 0xd | uVar8 * 0x80000) ^
             (uVar8 * 0x400 | uVar8 >> 0x16)) + ((uVar5 | uVar8) & uVar15 | uVar5 & uVar8) + iVar13;
    uVar10 = local_150 + iVar13;
    puVar11[0x12] = uVar6;
    uVar21 = puVar11[5];
    uVar25 = ((uVar6 * 0x8000 | uVar6 >> 0x11) ^ (uVar6 * 0x2000 | uVar6 >> 0x13) ^ uVar6 >> 10) +
             uVar25 + puVar11[0xd] +
             ((uVar21 >> 7 | uVar21 << 0x19) ^ (uVar21 << 0xe | uVar21 >> 0x12) ^ uVar21 >> 3);
    iVar13 = ((uVar10 >> 6 | uVar10 * 0x4000000) ^ (uVar10 >> 0xb | uVar10 * 0x200000) ^
             (uVar10 * 0x80 | uVar10 >> 0x19)) +
             ((uVar14 ^ uVar12) & uVar10 ^ uVar14) + uVar16 + puVar2[0x14] + uVar25;
    A[2] = ((uVar17 >> 2 | uVar17 * 0x40000000) ^ (uVar17 >> 0xd | uVar17 * 0x80000) ^
           (uVar17 * 0x400 | uVar17 >> 0x16)) + ((uVar8 | uVar17) & uVar5 | uVar8 & uVar17) + iVar13
    ;
    A[6] = uVar15 + iVar13;
    uVar6 = puVar11[6];
    puVar11[0x13] = uVar1;
    uVar16 = ((uVar1 * 0x8000 | uVar1 >> 0x11) ^ (uVar1 * 0x2000 | uVar1 >> 0x13) ^ uVar1 >> 10) +
             uVar19 + uVar21 +
             ((uVar6 >> 7 | uVar6 << 0x19) ^ (uVar6 << 0xe | uVar6 >> 0x12) ^ uVar6 >> 3);
    iVar13 = ((A[6] >> 6 | A[6] * 0x4000000) ^ (A[6] >> 0xb | A[6] * 0x200000) ^
             (A[6] * 0x80 | A[6] >> 0x19)) +
             ((uVar12 ^ uVar10) & A[6] ^ uVar12) + uVar14 + puVar2[0x15] + uVar16;
    A[1] = ((A[2] >> 2 | A[2] * 0x40000000) ^ (A[2] >> 0xd | A[2] * 0x80000) ^
           (A[2] * 0x400 | A[2] >> 0x16)) + ((uVar17 | A[2]) & uVar8 | uVar17 & A[2]) + iVar13;
    A[5] = uVar5 + iVar13;
    uVar1 = puVar11[7];
    puVar11[0x14] = uVar25;
    uVar7 = uVar20 + uVar6 +
            ((uVar25 * 0x8000 | uVar25 >> 0x11) ^ (uVar25 * 0x2000 | uVar25 >> 0x13) ^ uVar25 >> 10)
            + ((uVar1 >> 7 | uVar1 << 0x19) ^ (uVar1 << 0xe | uVar1 >> 0x12) ^ uVar1 >> 3);
    iVar13 = ((A[5] >> 6 | A[5] * 0x4000000) ^ (A[5] >> 0xb | A[5] * 0x200000) ^
             (A[5] * 0x80 | A[5] >> 0x19)) +
             ((uVar10 ^ A[6]) & A[5] ^ uVar10) + uVar12 + puVar2[0x16] + uVar7;
    A[0] = ((A[1] >> 2 | A[1] * 0x40000000) ^ (A[1] >> 0xd | A[1] * 0x80000) ^
           (A[1] * 0x400 | A[1] >> 0x16)) + ((A[2] | A[1]) & uVar17 | A[2] & A[1]) + iVar13;
    A[4] = uVar8 + iVar13;
    uVar5 = puVar11[8];
    puVar11[0x15] = uVar16;
    puVar11[0x10] = uVar23;
    uVar27 = puVar2[0x17];
    uVar24 = uVar23 + uVar1 +
             ((uVar16 * 0x8000 | uVar16 >> 0x11) ^ (uVar16 * 0x2000 | uVar16 >> 0x13) ^ uVar16 >> 10
             ) + ((uVar5 >> 7 | uVar5 << 0x19) ^ (uVar5 << 0xe | uVar5 >> 0x12) ^ uVar5 >> 3);
    puVar11[0x17] = uVar24;
    iVar13 = ((A[4] >> 6 | A[4] * 0x4000000) ^ (A[4] >> 0xb | A[4] * 0x200000) ^
             (A[4] * 0x80 | A[4] >> 0x19)) +
             uVar10 + uVar27 + uVar24 + ((A[6] ^ A[5]) & A[4] ^ A[6]);
    puVar11[0x16] = uVar7;
    puVar11 = puVar11 + 8;
    A[3] = uVar17 + iVar13;
    local_150 = ((A[0] >> 2 | A[0] * 0x40000000) ^ (A[0] >> 0xd | A[0] * 0x80000) ^
                (A[0] * 0x400 | A[0] >> 0x16)) + ((A[1] | A[0]) & A[2] | A[1] & A[0]) + iVar13;
    puVar2 = puVar2 + 8;
  } while (W + 0x2f != puVar11);
  puVar9 = ctx->state;
  do {
    iVar13 = *puVar18;
    puVar11 = puVar9 + 1;
    puVar18 = (uint32_t *)((int *)puVar18 + 1);
    *puVar9 = *puVar9 + iVar13;
    puVar9 = puVar11;
  } while ((uint32_t *)ctx->buffer != puVar11);
  return;
}



void mbedtls_sha256_update(mbedtls_sha256_context *ctx,uchar *input,size_t ilen)

{
  size_t __n;
  uint uVar1;
  uint uVar2;
  uint __n_00;
  
  uVar2 = ctx->total[0] & 0x3f;
  uVar1 = ctx->total[0] + ilen;
  ctx->total[0] = uVar1;
  if (uVar1 < ilen) {
    ctx->total[1] = ctx->total[1] + 1;
  }
  uVar1 = ilen;
  if ((uVar2 != 0) && (__n_00 = 0x40 - uVar2, __n_00 <= ilen)) {
    memcpy(ctx->buffer + uVar2,input,__n_00);
    ilen = (ilen - 0x40) + uVar2;
    mbedtls_sha256_process(ctx,ctx->buffer);
    input = input + __n_00;
    uVar2 = 0;
    uVar1 = ilen;
  }
  while (0x3f < ilen) {
    mbedtls_sha256_process(ctx,input + (uVar1 - ilen));
    ilen = ilen - 0x40;
  }
  __n = (uVar1 >> 6) * -0x40 + uVar1;
  if (__n == 0) {
    return;
  }
  memcpy(ctx->buffer + uVar2,input + (uVar1 & 0xffffffc0),__n);
  return;
}



void mbedtls_sha256_update(mbedtls_sha256_context *ctx,uchar *input,size_t ilen)

{
  if (ilen != 0) {
    mbedtls_sha256_update(ctx,input,ilen);
    return;
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

void mbedtls_sha256_finish(mbedtls_sha256_context *ctx,uchar *output)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  uchar uStack24;
  undefined uStack23;
  ushort uStack22;
  uchar msglen [8];
  
  uVar1 = ctx->total[0];
  uVar2 = ctx->total[1] << 3;
  uStack24 = (uchar)(uVar2 >> 0x18);
  uStack23 = (undefined)(uVar2 >> 0x10);
  uStack22 = (ushort)(uVar2 >> 8) & 0xff | (ushort)((uVar2 | uVar1 >> 0x1d) << 8);
  msglen[0] = (uchar)((uVar1 << 3) >> 0x18);
  msglen[1] = (uchar)((uVar1 << 3) >> 0x10);
  msglen._2_2_ = (ushort)((uVar1 << 0x13) >> 0x18) | (ushort)(uVar1 << 0xb);
  if ((uVar1 & 0x3f) < 0x38) {
    iVar3 = 0x38;
  }
  else {
    iVar3 = 0x78;
  }
  mbedtls_sha256_update(ctx,sha256_padding,iVar3 - (uVar1 & 0x3f));
  mbedtls_sha256_update(ctx,&uStack24,8);
  *output = *(uchar *)((int)ctx->state + 3);
  output[1] = (uchar)*(undefined2 *)((int)ctx->state + 2);
  output[2] = (uchar)(ctx->state[0] >> 8);
  output[3] = (uchar)ctx->state[0];
  output[4] = *(uchar *)((int)ctx->state + 7);
  output[5] = (uchar)*(undefined2 *)((int)ctx->state + 6);
  output[6] = (uchar)(ctx->state[1] >> 8);
  output[7] = (uchar)ctx->state[1];
  output[8] = *(uchar *)((int)ctx->state + 0xb);
  output[9] = (uchar)*(undefined2 *)((int)ctx->state + 10);
  output[10] = (uchar)(ctx->state[2] >> 8);
  output[0xb] = (uchar)ctx->state[2];
  output[0xc] = *(uchar *)((int)ctx->state + 0xf);
  output[0xd] = (uchar)*(undefined2 *)((int)ctx->state + 0xe);
  output[0xe] = (uchar)(ctx->state[3] >> 8);
  output[0xf] = (uchar)ctx->state[3];
  output[0x10] = *(uchar *)((int)ctx->state + 0x13);
  output[0x11] = (uchar)*(undefined2 *)((int)ctx->state + 0x12);
  output[0x12] = (uchar)(ctx->state[4] >> 8);
  output[0x13] = (uchar)ctx->state[4];
  output[0x14] = *(uchar *)((int)ctx->state + 0x17);
  output[0x15] = (uchar)*(undefined2 *)((int)ctx->state + 0x16);
  output[0x16] = (uchar)(ctx->state[5] >> 8);
  output[0x17] = (uchar)ctx->state[5];
  output[0x18] = *(uchar *)((int)ctx->state + 0x1b);
  output[0x19] = (uchar)*(undefined2 *)((int)ctx->state + 0x1a);
  output[0x1a] = (uchar)(ctx->state[6] >> 8);
  output[0x1b] = (uchar)ctx->state[6];
  if (ctx->is224 == 0) {
    output[0x1c] = *(uchar *)((int)ctx->state + 0x1f);
    output[0x1d] = (uchar)*(undefined2 *)((int)ctx->state + 0x1e);
    output[0x1e] = (uchar)(ctx->state[7] >> 8);
    output[0x1f] = (uchar)ctx->state[7];
  }
  return;
}



// WARNING: Variable defined which should be unmapped: ctx

void mbedtls_sha256(uchar *input,size_t ilen,uchar *output,int is224)

{
  undefined auStack132 [4];
  mbedtls_sha256_context ctx;
  
  mbedtls_sha256_init((mbedtls_sha256_context *)auStack132);
  mbedtls_sha256_starts((mbedtls_sha256_context *)auStack132,is224);
  mbedtls_sha256_update((mbedtls_sha256_context *)auStack132,input,ilen);
  mbedtls_sha256_finish((mbedtls_sha256_context *)auStack132,output);
  mbedtls_sha256_free((mbedtls_sha256_context *)auStack132);
  return;
}



mbedtls_x509_crt * mbedtls_ssl_own_cert(mbedtls_ssl_context *ssl)

{
  mbedtls_x509_crt *pmVar1;
  
  if (((ssl->handshake != (mbedtls_ssl_handshake_params *)0x0) &&
      (pmVar1 = (mbedtls_x509_crt *)ssl->handshake->key_cert, pmVar1 != (mbedtls_x509_crt *)0x0)) ||
     (pmVar1 = (mbedtls_x509_crt *)ssl->conf->key_cert, pmVar1 != (mbedtls_x509_crt *)0x0)) {
    pmVar1 = (mbedtls_x509_crt *)(pmVar1->raw).tag;
  }
  return pmVar1;
}



void mbedtls_zeroize(void *v,size_t n)

{
  undefined *puVar1;
  
  puVar1 = (undefined *)(n + (int)v);
  while ((undefined *)v != puVar1) {
    *(undefined *)v = 0;
    v = (undefined *)v + 1;
  }
  return;
}



void ssl_swap_epochs(mbedtls_ssl_context *ssl)

{
  mbedtls_ssl_transform *pmVar1;
  uchar *puVar2;
  undefined auStack24 [4];
  uchar tmp_out_ctr [8];
  
  if (ssl->transform_out == ssl->handshake->alt_transform_out) {
    mbedtls_debug_print_msg(ssl,3,"file1",0xa0a,"skip swap epochs");
  }
  else {
    mbedtls_debug_print_msg(ssl,3,"file1",0xa0e,"swap epochs");
    pmVar1 = ssl->transform_out;
    ssl->transform_out = ssl->handshake->alt_transform_out;
    ssl->handshake->alt_transform_out = pmVar1;
    memcpy(auStack24,ssl->out_ctr,8);
    memcpy(ssl->out_ctr,ssl->handshake->alt_out_ctr,8);
    memcpy(ssl->handshake->alt_out_ctr,auStack24,8);
    pmVar1 = ssl->transform_out;
    puVar2 = ssl->out_iv;
    if ((pmVar1 != (mbedtls_ssl_transform *)0x0) && (1 < ssl->minor_ver)) {
      puVar2 = puVar2 + (pmVar1->ivlen - pmVar1->fixed_ivlen);
    }
    ssl->out_msg = puVar2;
  }
  return;
}



void ssl_calc_finished_tls_sha256(mbedtls_ssl_context *ssl,uchar *buf,int from)

{
  mbedtls_ssl_session *pmVar1;
  char *pcVar2;
  uchar auStack180 [4];
  uchar padbuf [32];
  mbedtls_sha256_context sha256;
  
  pmVar1 = ssl->session_negotiate;
  if (pmVar1 == (mbedtls_ssl_session *)0x0) {
    pmVar1 = ssl->session;
  }
  mbedtls_sha256_init((mbedtls_sha256_context *)(padbuf + 0x1c));
  mbedtls_debug_print_msg(ssl,2,"file1",0x1356,"=> calc  finished tls sha256");
  mbedtls_sha256_clone((mbedtls_sha256_context *)(padbuf + 0x1c),&ssl->handshake->fin_sha256);
  mbedtls_debug_print_buf
            (ssl,4,"file1",0x1362,"finished sha2 state",(uchar *)(sha256.total + 1),0x20);
  if (from == 0) {
    pcVar2 = "client finished";
  }
  else {
    pcVar2 = "server finished";
  }
  mbedtls_sha256_finish((mbedtls_sha256_context *)(padbuf + 0x1c),auStack180);
  (*ssl->handshake->tls_prf)(pmVar1->master,0x30,pcVar2,auStack180,0x20,buf,0xc);
  mbedtls_debug_print_buf(ssl,3,"file1",0x136e,"calc finished result",buf,0xc);
  mbedtls_sha256_free((mbedtls_sha256_context *)(padbuf + 0x1c));
  mbedtls_zeroize(auStack180,0x20);
  mbedtls_debug_print_msg(ssl,2,"file1",0x1374,"<= calc  finished");
  return;
}



// WARNING: Variable defined which should be unmapped: sha256

void ssl_calc_verify_tls_sha256(mbedtls_ssl_context *ssl,uchar *hash)

{
  undefined auStack132 [4];
  mbedtls_sha256_context sha256;
  
  mbedtls_sha256_init((mbedtls_sha256_context *)auStack132);
  mbedtls_debug_print_msg(ssl,2,"file1",0x42d,"=> calc verify sha256");
  mbedtls_sha256_clone((mbedtls_sha256_context *)auStack132,&ssl->handshake->fin_sha256);
  mbedtls_sha256_finish((mbedtls_sha256_context *)auStack132,hash);
  mbedtls_debug_print_buf(ssl,3,"file1",0x432,"calculated verify result",hash,0x20);
  mbedtls_debug_print_msg(ssl,2,"file1",0x433,"<= calc verify");
  mbedtls_sha256_free((mbedtls_sha256_context *)auStack132);
  return;
}



void ssl_flight_free(mbedtls_ssl_flight_item *flight)

{
  mbedtls_ssl_flight_item *pmVar1;
  
  while (flight != (mbedtls_ssl_flight_item *)0x0) {
    pmVar1 = flight->next;
    vPortFree(flight->p);
    vPortFree(flight);
    flight = pmVar1;
  }
  return;
}



int ssl_append_key_cert(mbedtls_ssl_key_cert **head,mbedtls_x509_crt *cert,mbedtls_pk_context *key)

{
  mbedtls_ssl_key_cert *pmVar1;
  int iVar2;
  mbedtls_ssl_key_cert *pmVar3;
  mbedtls_ssl_key_cert *pmVar4;
  
  pmVar1 = (mbedtls_ssl_key_cert *)mycalloc(1,0xc);
  if (pmVar1 == (mbedtls_ssl_key_cert *)0x0) {
    iVar2 = -0x7f00;
  }
  else {
    pmVar1->cert = cert;
    pmVar1->next = (mbedtls_ssl_key_cert *)0x0;
    pmVar1->key = key;
    pmVar3 = *head;
    if (*head == (mbedtls_ssl_key_cert *)0x0) {
      *head = pmVar1;
    }
    else {
      do {
        pmVar4 = pmVar3;
        pmVar3 = pmVar4->next;
      } while (pmVar3 != (mbedtls_ssl_key_cert *)0x0);
      pmVar4->next = pmVar1;
    }
    iVar2 = 0;
  }
  return iVar2;
}



void ssl_update_checksum_start(mbedtls_ssl_context *ssl,uchar *buf,size_t len)

{
  mbedtls_sha256_update(&ssl->handshake->fin_sha256,buf,len);
  return;
}



void ssl_update_checksum_sha256(mbedtls_ssl_context *ssl,uchar *buf,size_t len)

{
  mbedtls_sha256_update(&ssl->handshake->fin_sha256,buf,len);
  return;
}



size_t mbedtls_ssl_hdr_len(void)

{
  int in_a0;
  
  if ((*(ushort *)(in_a0 + 0x74) & 2) != 0) {
    return 0xd;
  }
  return 5;
}



void ssl_set_timer(mbedtls_ssl_context *ssl,uint32_t millisecs)

{
  if (ssl->f_set_timer != (mbedtls_ssl_set_timer_t_conflict1 *)0x0) {
    mbedtls_debug_print_msg(ssl,3,"file1",0x52,"set_timer to %d ms",millisecs);
                    // WARNING: Could not recover jumptable at 0x230599f4. Too many branches
                    // WARNING: Treating indirect jump as call
    (*ssl->f_set_timer)(ssl->p_timer,millisecs >> 2,millisecs);
    return;
  }
  return;
}



int ssl_check_timer(mbedtls_ssl_context *ssl)

{
  int iVar1;
  
  if (ssl->f_get_timer == (mbedtls_ssl_get_timer_t *)0x0) {
    return 0;
  }
  iVar1 = (*ssl->f_get_timer)(ssl->p_timer);
  if (iVar1 == 2) {
    mbedtls_debug_print_msg(ssl,3,"file1",0x60,"timer expired");
    iVar1 = -1;
  }
  else {
    iVar1 = 0;
  }
  return iVar1;
}



// WARNING: Variable defined which should be unmapped: tmp

int tls_prf_sha256(uchar *secret,size_t slen,char *label,uchar *random,size_t rlen,uchar *dstbuf,
                  size_t dlen)

{
  int iVar1;
  uint uVar2;
  uchar ilen;
  mbedtls_md_info_t *md_info;
  undefined3 extraout_var;
  size_t __n;
  int iVar3;
  uchar *puVar4;
  size_t sVar5;
  size_t sVar6;
  uint uVar7;
  undefined auStack220 [4];
  mbedtls_md_context_t md_ctx;
  uchar h_i [32];
  uchar tmp [128];
  
  mbedtls_md_init((mbedtls_md_context_t *)auStack220);
  md_info = mbedtls_md_info_from_type(MBEDTLS_MD_SHA256);
  if (md_info == (mbedtls_md_info_t *)0x0) {
    iVar3 = -0x6c00;
  }
  else {
    ilen = mbedtls_md_get_size(md_info);
    _ilen = CONCAT31(extraout_var,ilen);
    __n = strlen(label);
    if (__n + rlen + _ilen < 0x81) {
      __n = strlen(label);
      memcpy(h_i + _ilen + 0x1c,label,__n);
      memcpy(h_i + _ilen + __n + 0x1c,random,rlen);
      iVar3 = mbedtls_md_setup((mbedtls_md_context_t *)auStack220,md_info,1);
      if (iVar3 == 0) {
        mbedtls_md_hmac_starts((mbedtls_md_context_t *)auStack220,secret,slen);
        mbedtls_md_hmac_update((mbedtls_md_context_t *)auStack220,h_i + _ilen + 0x1c,rlen + __n);
        mbedtls_md_hmac_finish((mbedtls_md_context_t *)auStack220,h_i + 0x1c);
        uVar2 = 0;
        while (uVar7 = uVar2, uVar7 < dlen) {
          mbedtls_md_hmac_reset((mbedtls_md_context_t *)auStack220);
          mbedtls_md_hmac_update((mbedtls_md_context_t *)auStack220,h_i + 0x1c,rlen + __n + _ilen);
          mbedtls_md_hmac_finish((mbedtls_md_context_t *)auStack220,(uchar *)&md_ctx.hmac_ctx);
          mbedtls_md_hmac_reset((mbedtls_md_context_t *)auStack220);
          mbedtls_md_hmac_update((mbedtls_md_context_t *)auStack220,h_i + 0x1c,_ilen);
          mbedtls_md_hmac_finish((mbedtls_md_context_t *)auStack220,h_i + 0x1c);
          sVar5 = _ilen;
          if (dlen < _ilen + uVar7) {
            sVar5 = dlen % _ilen;
          }
          sVar6 = 0;
          while (uVar2 = _ilen + uVar7, sVar6 != sVar5) {
            puVar4 = (uchar *)((int)&md_ctx.hmac_ctx + sVar6);
            iVar1 = sVar6 + uVar7;
            sVar6 = sVar6 + 1;
            dstbuf[iVar1] = *puVar4;
          }
        }
        mbedtls_md_free((mbedtls_md_context_t *)auStack220);
        mbedtls_zeroize(h_i + 0x1c,0x80);
        mbedtls_zeroize(&md_ctx.hmac_ctx,0x20);
      }
    }
    else {
      iVar3 = -0x7100;
    }
  }
  return iVar3;
}



int mbedtls_ssl_derive_keys(mbedtls_ssl_context *ssl)

{
  mbedtls_cipher_type_t mVar1;
  size_t __n;
  mbedtls_ssl_transform *pmVar2;
  mbedtls_cipher_context_t *ctx;
  uchar uVar3;
  mbedtls_cipher_info_t *cipher_info;
  mbedtls_md_info_t *md_info;
  undefined3 extraout_var;
  size_t sVar4;
  uint uVar5;
  int line;
  int line_00;
  char *text;
  size_t sVar6;
  mbedtls_ssl_handshake_params *pmVar7;
  uchar *buf;
  uchar *buf_00;
  mbedtls_cipher_context_t *ctx_00;
  uchar *buf_01;
  uchar *key;
  mbedtls_ssl_session *pmVar8;
  undefined auStack384 [4];
  uchar tmp [64];
  uchar keyblk [256];
  
  pmVar2 = ssl->transform_negotiate;
  pmVar8 = ssl->session_negotiate;
  pmVar7 = ssl->handshake;
  mbedtls_debug_print_msg(ssl,2,"file1",0x1f5,"=> derive keys");
  cipher_info = mbedtls_cipher_info_from_type(pmVar2->ciphersuite_info->cipher);
  if (cipher_info == (mbedtls_cipher_info_t *)0x0) {
    mVar1 = pmVar2->ciphersuite_info->cipher;
    text = "cipher info for %d not found";
    line = 0x1fb;
LAB_23059c08:
    mbedtls_debug_print_msg(ssl,1,"file1",line,text,(uint)mVar1);
    return -0x7100;
  }
  md_info = mbedtls_md_info_from_type(pmVar2->ciphersuite_info->mac);
  if (md_info == (mbedtls_md_info_t *)0x0) {
    text = "mbedtls_md info for %d not found";
    mVar1 = pmVar2->ciphersuite_info->mac;
    line = 0x203;
    goto LAB_23059c08;
  }
  if (ssl->minor_ver != 3) {
    line = 0x232;
    goto LAB_23059cde;
  }
  pmVar7->tls_prf = tls_prf_sha256;
  pmVar7->calc_verify = ssl_calc_verify_tls_sha256;
  pmVar7->calc_finished = ssl_calc_finished_tls_sha256;
  buf_01 = pmVar7->randbytes;
  buf = pmVar8->master;
  if (pmVar7->resume == 0) {
    buf_00 = pmVar7->premaster;
    mbedtls_debug_print_buf(ssl,3,"file1",0x243,"premaster secret",buf_00,pmVar7->pmslen);
    line = (*pmVar7->tls_prf)(buf_00,pmVar7->pmslen,"master secret",buf_01,0x40,buf,0x30);
    if (line != 0) {
      text = "prf";
      line_00 = 0x275;
      goto LAB_23059d46;
    }
    mbedtls_zeroize(buf_00,0x30);
  }
  else {
    mbedtls_debug_print_msg(ssl,3,"file1",0x27c,"no premaster (session resumed)");
  }
  memcpy(auStack384,buf_01,0x40);
  memcpy(buf_01,tmp + 0x1c,0x20);
  memcpy(pmVar7->randbytes + 0x20,auStack384,0x20);
  mbedtls_zeroize(auStack384,0x40);
  line = (*pmVar7->tls_prf)(buf,0x30,"key expansion",buf_01,0x40,tmp + 0x3c,0x100);
  if (line != 0) {
    text = "prf";
    line_00 = 0x296;
    goto LAB_23059d46;
  }
  text = mbedtls_ssl_get_ciphersuite_name(pmVar8->ciphersuite);
  mbedtls_debug_print_msg(ssl,3,"file1",0x29b,"ciphersuite = %s",text);
  mbedtls_debug_print_buf(ssl,3,"file1",0x29c,"master secret",buf,0x30);
  mbedtls_debug_print_buf(ssl,4,"file1",0x29d,"random bytes",buf_01,0x40);
  mbedtls_debug_print_buf(ssl,4,"file1",0x29e,"key block",tmp + 0x3c,0x100);
  mbedtls_zeroize(buf_01,0x40);
  pmVar2->keylen = cipher_info->key_bitlen >> 3;
  if ((cipher_info->mode + ~MBEDTLS_MODE_CTR & 0xfd) == 0) {
    pmVar2->ivlen = 0xc;
    pmVar2->fixed_ivlen = 4;
    pmVar2->maclen = 0;
    line = 8;
    if ((pmVar2->ciphersuite_info->flags & 2) == 0) {
      line = 0x10;
    }
    sVar6 = line + 8;
LAB_23059e78:
    pmVar2->minlen = sVar6;
  }
  else {
    line = mbedtls_md_setup(&pmVar2->md_ctx_enc,md_info,1);
    if ((line != 0) || (line = mbedtls_md_setup(&pmVar2->md_ctx_dec,md_info,1), line != 0)) {
      text = "mbedtls_md_setup";
      line_00 = 699;
      goto LAB_23059d46;
    }
    uVar3 = mbedtls_md_get_size(md_info);
    uVar5 = CONCAT31(extraout_var,uVar3);
    pmVar2->maclen = uVar5;
    sVar6 = cipher_info->iv_size;
    pmVar2->ivlen = sVar6;
    if (cipher_info->mode != MBEDTLS_MODE_STREAM) {
      sVar4 = (uVar5 + cipher_info->block_size) - uVar5 % cipher_info->block_size;
      pmVar2->minlen = sVar4;
      if (1 < ssl->minor_ver - 2U) {
        line = 0x2f7;
        goto LAB_23059cde;
      }
      sVar6 = sVar6 + sVar4;
      goto LAB_23059e78;
    }
    pmVar2->minlen = uVar5;
  }
  mbedtls_debug_print_msg
            (ssl,3,"file1",0x2ff,"keylen: %d, minlen: %d, ivlen: %d, maclen: %d",pmVar2->keylen,
             pmVar2->minlen,pmVar2->ivlen);
  uVar5 = pmVar2->keylen;
  __n = pmVar2->fixed_ivlen;
  sVar6 = pmVar2->maclen;
  line = sVar6 * 2;
  if ((*(ushort *)&ssl->conf->field_0x74 & 1) == 0) {
    key = tmp + 0x3c;
    buf_00 = key + line;
    buf = key + line + uVar5;
    key = key + sVar6;
    if (__n == 0) {
      __n = pmVar2->ivlen;
    }
    memcpy(pmVar2->iv_enc,buf + uVar5,__n);
    memcpy(pmVar2->iv_dec,buf + pmVar2->keylen + __n,__n);
    buf_01 = tmp + 0x3c;
  }
  else {
    buf_01 = tmp + 0x3c;
    buf_00 = buf_01 + line + uVar5;
    buf = buf_01 + line;
    buf_01 = buf_01 + sVar6;
    if (__n == 0) {
      __n = pmVar2->ivlen;
    }
    memcpy(pmVar2->iv_dec,buf_00 + uVar5,__n);
    memcpy(pmVar2->iv_enc,buf_00 + pmVar2->keylen + __n,__n);
    key = tmp + 0x3c;
  }
  if (0 < ssl->minor_ver) {
    mbedtls_md_hmac_starts(&pmVar2->md_ctx_enc,buf_01,pmVar2->maclen);
    mbedtls_md_hmac_starts(&pmVar2->md_ctx_dec,key,pmVar2->maclen);
    ctx_00 = &pmVar2->cipher_ctx_enc;
    line = mbedtls_cipher_setup(ctx_00,cipher_info);
    if (line == 0) {
      ctx = &pmVar2->cipher_ctx_dec;
      line = mbedtls_cipher_setup(ctx,cipher_info);
      if (line == 0) {
        line = mbedtls_cipher_setkey(ctx_00,buf_00,cipher_info->key_bitlen,MBEDTLS_ENCRYPT);
        if (line == 0) {
          line = mbedtls_cipher_setkey(ctx,buf,cipher_info->key_bitlen,MBEDTLS_DECRYPT);
          if (line == 0) {
            if (cipher_info->mode == MBEDTLS_MODE_CBC) {
              line = mbedtls_cipher_set_padding_mode(ctx_00,MBEDTLS_PADDING_NONE);
              if (line != 0) {
                mbedtls_debug_print_ret(ssl,1,"file1",0x38e,"mbedtls_cipher_set_padding_mode",line);
                return line;
              }
              line = mbedtls_cipher_set_padding_mode(ctx,MBEDTLS_PADDING_NONE);
              if (line != 0) {
                mbedtls_debug_print_ret(ssl,1,"file1",0x395,"mbedtls_cipher_set_padding_mode",line);
                return line;
              }
            }
            mbedtls_zeroize(tmp + 0x3c,0x100);
            mbedtls_debug_print_msg(ssl,2,"file1",0x3bd,"<= derive keys");
            return 0;
          }
          text = "mbedtls_cipher_setkey";
          line_00 = 900;
        }
        else {
          text = "mbedtls_cipher_setkey";
          line_00 = 0x37c;
        }
      }
      else {
        text = "mbedtls_cipher_setup";
        line_00 = 0x374;
      }
    }
    else {
      text = "mbedtls_cipher_setup";
      line_00 = 0x36d;
    }
LAB_23059d46:
    mbedtls_debug_print_ret(ssl,1,"file1",line_00,text,line);
    return line;
  }
  line = 0x349;
LAB_23059cde:
  mbedtls_debug_print_msg(ssl,1,"file1",line,"should never happen");
  return -0x6c00;
}



int mbedtls_ssl_flush_output(mbedtls_ssl_context *ssl)

{
  int ret;
  size_t sVar1;
  uint uVar2;
  uchar uVar3;
  size_t sVar4;
  
  mbedtls_debug_print_msg(ssl,2,"file1",0x98a,"=> flush output");
  if (ssl->f_send == (mbedtls_ssl_send_t *)0x0) {
    mbedtls_debug_print_msg
              (ssl,1,"file1",0x98f,"Bad usage of mbedtls_ssl_set_bio() or mbedtls_ssl_set_bio()");
    ret = -0x7100;
  }
  else {
    if (ssl->out_left == 0) {
      ret = 0x996;
    }
    else {
      while (sVar4 = ssl->out_left, sVar4 != 0) {
        sVar1 = mbedtls_ssl_hdr_len();
        mbedtls_debug_print_msg
                  (ssl,2,"file1",0x99d,"message length: %d, out_left: %d",ssl->out_msglen + sVar1,
                   sVar4);
        sVar4 = mbedtls_ssl_hdr_len();
        ret = (*ssl->f_send)(ssl->p_bio,ssl->out_hdr + sVar4 + (ssl->out_msglen - ssl->out_left),
                             ssl->out_left);
        mbedtls_debug_print_ret(ssl,2,"file1",0x9a3,"ssl->f_send",ret);
        if (ret < 1) {
          return ret;
        }
        ssl->out_left = ssl->out_left - ret;
      }
      uVar2 = 8;
      while (((uint)*(ushort *)&ssl->conf->field_0x74 & 2) < uVar2) {
        uVar3 = ssl->out_ctr[uVar2 - 1] + '\x01';
        ssl->out_ctr[uVar2 - 1] = uVar3;
        if (uVar3 != '\0') break;
        uVar2 = uVar2 - 1 & 0xff;
      }
      if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
        sVar4 = 2;
      }
      if (uVar2 == sVar4) {
        mbedtls_debug_print_msg(ssl,1,"file1",0x9b2,"outgoing message counter would wrap");
        return -0x6b80;
      }
      ret = 0x9b6;
    }
    mbedtls_debug_print_msg(ssl,2,"file1",ret,"<= flush output");
    ret = 0;
  }
  return ret;
}



void mbedtls_ssl_recv_flight_completed(mbedtls_ssl_context *ssl)

{
  ssl_flight_free(ssl->handshake->flight);
  ssl->handshake->flight = (mbedtls_ssl_flight_item *)0x0;
  ssl->handshake->cur_msg = (mbedtls_ssl_flight_item *)0x0;
  ssl->handshake->in_flight_start_seq = ssl->handshake->in_msg_seq;
  ssl_set_timer(ssl,0);
  if ((ssl->in_msgtype == 0x16) && (*ssl->in_msg == '\x14')) {
    ssl->handshake->retransmit_state = '\x03';
  }
  else {
    ssl->handshake->retransmit_state = '\0';
  }
  return;
}



void mbedtls_ssl_send_flight_completed(mbedtls_ssl_context *ssl)

{
  uchar uVar1;
  
  ssl->handshake->retransmit_timeout = ssl->conf->hs_timeout_min;
  mbedtls_debug_print_msg
            (ssl,3,"file1",0x87,"update timeout value to %d millisecs",
             ssl->handshake->retransmit_timeout);
  ssl_set_timer(ssl,ssl->handshake->retransmit_timeout);
  if ((ssl->in_msgtype == 0x16) && (*ssl->in_msg == '\x14')) {
    uVar1 = '\x03';
  }
  else {
    uVar1 = '\x02';
  }
  ssl->handshake->retransmit_state = uVar1;
  return;
}



void mbedtls_ssl_update_handshake_status(mbedtls_ssl_context *ssl)

{
  mbedtls_ssl_handshake_params *pmVar1;
  
  if ((ssl->state != 0x10) && (ssl->handshake != (mbedtls_ssl_handshake_params *)0x0)) {
    (*ssl->handshake->update_checksum)(ssl,ssl->in_msg,ssl->in_hslen);
  }
  if (((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) &&
     (pmVar1 = ssl->handshake, pmVar1 != (mbedtls_ssl_handshake_params *)0x0)) {
    pmVar1->in_msg_seq = pmVar1->in_msg_seq + 1;
  }
  return;
}



void mbedtls_ssl_optimize_checksum
               (mbedtls_ssl_context *ssl,mbedtls_ssl_ciphersuite_t *ciphersuite_info)

{
  if (ciphersuite_info->mac != MBEDTLS_MD_SHA384) {
    ssl->handshake->update_checksum = ssl_update_checksum_sha256;
    return;
  }
  mbedtls_debug_print_msg(ssl,1,"file1",0x122e,"should never happen");
  return;
}



void mbedtls_ssl_reset_checksum(mbedtls_ssl_context *ssl)

{
  mbedtls_sha256_starts(&ssl->handshake->fin_sha256,0);
  return;
}



void mbedtls_ssl_session_init(mbedtls_ssl_session *session)

{
  memset(session,0,0x74);
  return;
}



void mbedtls_ssl_init(mbedtls_ssl_context *ssl)

{
  memset(ssl,0,0xc0);
  return;
}



void mbedtls_ssl_conf_authmode(mbedtls_ssl_config *conf,int authmode)

{
  *(ushort *)&conf->field_0x74 =
       *(ushort *)&conf->field_0x74 & 0xfff3 | (ushort)((authmode & 3U) << 2);
  return;
}



void mbedtls_ssl_conf_verify
               (mbedtls_ssl_config *conf,
               anon_subr_int_void_ptr_mbedtls_x509_crt_ptr_int_uint32_t_ptr *f_vrfy,void *p_vrfy)

{
  *(anon_subr_int_void_ptr_mbedtls_x509_crt_ptr_int_uint32_t_ptr **)&conf->f_vrfy = f_vrfy;
  conf->p_vrfy = p_vrfy;
  return;
}



void mbedtls_ssl_conf_rng(mbedtls_ssl_config *conf,mbedtls_ssl_recv_t *f_rng,void *p_rng)

{
  conf->f_rng = f_rng;
  conf->p_rng = p_rng;
  return;
}



void mbedtls_ssl_set_bio(mbedtls_ssl_context *ssl,void *p_bio,mbedtls_ssl_send_t *f_send,
                        mbedtls_ssl_recv_t *f_recv,
                        mbedtls_ssl_recv_timeout_t_conflict1 *f_recv_timeout)

{
  ssl->p_bio = p_bio;
  ssl->f_send = f_send;
  ssl->f_recv = f_recv;
  ssl->f_recv_timeout = f_recv_timeout;
  return;
}



void mbedtls_ssl_conf_read_timeout(mbedtls_ssl_config *conf,uint32_t timeout)

{
  conf->read_timeout = timeout;
  return;
}



int mbedtls_ssl_conf_own_cert
              (mbedtls_ssl_config *conf,mbedtls_x509_crt *own_cert,mbedtls_pk_context *pk_key)

{
  int iVar1;
  
  iVar1 = ssl_append_key_cert(&conf->key_cert,own_cert,pk_key);
  return iVar1;
}



void mbedtls_ssl_conf_ca_chain
               (mbedtls_ssl_config *conf,mbedtls_x509_crt *ca_chain,mbedtls_x509_crl *ca_crl)

{
  conf->ca_chain = ca_chain;
  conf->ca_crl = ca_crl;
  return;
}



int mbedtls_ssl_set_hostname(mbedtls_ssl_context *ssl,char *hostname)

{
  size_t __n;
  char *__dest;
  int iVar1;
  
  if (hostname == (char *)0x0) {
    return -0x7100;
  }
  __n = strlen(hostname);
  if (__n < 0x100) {
    __dest = (char *)mycalloc(1,__n + 1);
    ssl->hostname = __dest;
    if (__dest == (char *)0x0) {
      iVar1 = -0x7f00;
    }
    else {
      memcpy(__dest,hostname,__n);
      iVar1 = 0;
      ssl->hostname[__n] = '\0';
    }
  }
  else {
    iVar1 = -0x7100;
  }
  return iVar1;
}



int mbedtls_ssl_conf_alpn_protocols(mbedtls_ssl_config *conf,char **protos)

{
  char **ppcVar1;
  uint uVar2;
  size_t sVar3;
  
  uVar2 = 0;
  ppcVar1 = protos;
  while( true ) {
    if (*ppcVar1 == (char *)0x0) {
      conf->alpn_list = protos;
      return 0;
    }
    sVar3 = strlen(*ppcVar1);
    uVar2 = uVar2 + sVar3;
    if ((0xfe < sVar3 - 1) || (0xffff < uVar2)) break;
    ppcVar1 = ppcVar1 + 1;
  }
  return -0x7100;
}



uint32_t mbedtls_ssl_get_verify_result(mbedtls_ssl_context *ssl)

{
  mbedtls_ssl_session *pmVar1;
  
  pmVar1 = ssl->session;
  if ((pmVar1 == (mbedtls_ssl_session *)0x0) &&
     (pmVar1 = ssl->session_negotiate, pmVar1 == (mbedtls_ssl_session *)0x0)) {
    return 0xffffffff;
  }
  return pmVar1->verify_result;
}



char * mbedtls_ssl_get_ciphersuite(mbedtls_ssl_context *ssl)

{
  char *pcVar1;
  
  if ((ssl != (mbedtls_ssl_context *)0x0) && (ssl->session != (mbedtls_ssl_session *)0x0)) {
    pcVar1 = mbedtls_ssl_get_ciphersuite_name(ssl->session->ciphersuite);
    return pcVar1;
  }
  return (char *)0x0;
}



char * mbedtls_ssl_get_version(mbedtls_ssl_context *ssl)

{
  uint uVar1;
  
  uVar1 = ssl->minor_ver;
  if ((*(ushort *)&ssl->conf->field_0x74 & 2) == 0) {
    if (uVar1 < 4) {
      return *(char **)(CSWTCH_34 + uVar1 * 4);
    }
    return "unknown";
  }
  if (uVar1 != 2) {
    if (uVar1 != 3) {
      return "unknown (DTLS)";
    }
    return "DTLSv1.2";
  }
  return "DTLSv1.0";
}



size_t mbedtls_ssl_get_record_expansion(mbedtls_ssl_context *param_1)

{
  mbedtls_cipher_mode_t mVar1;
  size_t sVar2;
  size_t sVar3;
  int iVar4;
  mbedtls_cipher_info_t *pmVar5;
  mbedtls_ssl_transform *pmVar6;
  
  pmVar6 = param_1->transform_out;
  if (pmVar6 == (mbedtls_ssl_transform *)0x0) {
    sVar2 = mbedtls_ssl_hdr_len();
    return sVar2;
  }
  pmVar5 = (pmVar6->cipher_ctx_enc).cipher_info;
  if (pmVar5 == (mbedtls_cipher_info_t *)0x0) {
LAB_2305a542:
    mbedtls_debug_print_msg(param_1,1,"file1",0x18cf,"should never happen");
    iVar4 = -0x6c00;
  }
  else {
    mVar1 = pmVar5->mode;
    if (mVar1 == MBEDTLS_MODE_CBC) {
      sVar2 = pmVar6->maclen + pmVar5->block_size;
    }
    else {
      if ((mVar1 < MBEDTLS_MODE_CBC) || (2 < (byte)(mVar1 + ~MBEDTLS_MODE_CTR))) goto LAB_2305a542;
      sVar2 = pmVar6->minlen;
    }
    sVar3 = mbedtls_ssl_hdr_len();
    iVar4 = sVar3 + sVar2;
  }
  return iVar4;
}



size_t mbedtls_ssl_get_max_frag_len(mbedtls_ssl_context *ssl)

{
  uint uVar1;
  
  uVar1 = *(uint *)((int)mfl_code_to_length + (*(uint *)&ssl->conf->field_0x74 >> 4 & 0x1c));
  if ((ssl->session_out != (mbedtls_ssl_session *)0x0) &&
     (mfl_code_to_length[ssl->session_out->mfl_code] < uVar1)) {
    uVar1 = mfl_code_to_length[ssl->session_out->mfl_code];
  }
  return uVar1;
}



mbedtls_x509_crt * mbedtls_ssl_get_peer_cert(mbedtls_ssl_context *ssl)

{
  if ((ssl != (mbedtls_ssl_context *)0x0) &&
     (ssl = (mbedtls_ssl_context *)ssl->session, (mbedtls_x509_crt *)ssl != (mbedtls_x509_crt *)0x0)
     ) {
    ssl = (mbedtls_ssl_context *)(((mbedtls_x509_crt *)ssl)->issuer).val.len;
  }
  return (mbedtls_x509_crt *)ssl;
}



int mbedtls_ssl_handshake_step(mbedtls_ssl_context *ssl)

{
  int iVar1;
  
  if (ssl == (mbedtls_ssl_context *)0x0) {
    return -0x7100;
  }
  if (ssl->conf == (mbedtls_ssl_config *)0x0) {
    iVar1 = -0x7100;
  }
  else {
    if (((*(ushort *)&ssl->conf->field_0x74 & 1) != 0) ||
       (iVar1 = mbedtls_ssl_handshake_client_step(ssl), (*(ushort *)&ssl->conf->field_0x74 & 1) != 0
       )) {
      iVar1 = mbedtls_ssl_handshake_server_step(ssl);
      return iVar1;
    }
  }
  return iVar1;
}



int mbedtls_ssl_handshake(mbedtls_ssl_context *ssl)

{
  int iVar1;
  
  if ((ssl == (mbedtls_ssl_context *)0x0) || (ssl->conf == (mbedtls_ssl_config *)0x0)) {
    iVar1 = -0x7100;
  }
  else {
    mbedtls_debug_print_msg(ssl,2,"file1",0x1926,"=> handshake");
    do {
      if (ssl->state == 0x10) {
        iVar1 = 0;
        break;
      }
      iVar1 = mbedtls_ssl_handshake_step(ssl);
    } while (iVar1 == 0);
    mbedtls_debug_print_msg(ssl,2,"file1",0x1930,"<= handshake");
  }
  return iVar1;
}



void mbedtls_ssl_transform_free(mbedtls_ssl_transform *transform)

{
  if (transform != (mbedtls_ssl_transform *)0x0) {
    mbedtls_cipher_free(&transform->cipher_ctx_enc);
    mbedtls_cipher_free(&transform->cipher_ctx_dec);
    mbedtls_md_free(&transform->md_ctx_enc);
    mbedtls_md_free(&transform->md_ctx_dec);
    mbedtls_zeroize(transform,0xd0);
    return;
  }
  return;
}



void mbedtls_ssl_handshake_free(mbedtls_ssl_handshake_params *handshake)

{
  mbedtls_ssl_key_cert *pmVar1;
  mbedtls_ssl_key_cert *pv;
  
  if (handshake != (mbedtls_ssl_handshake_params *)0x0) {
    mbedtls_sha256_free(&handshake->fin_sha256);
    pv = handshake->sni_key_cert;
    while (pv != (mbedtls_ssl_key_cert *)0x0) {
      pmVar1 = pv->next;
      vPortFree(pv);
      pv = pmVar1;
    }
    vPortFree(handshake->verify_cookie);
    vPortFree(handshake->hs_msg);
    ssl_flight_free(handshake->flight);
    mbedtls_zeroize(handshake,0x15c);
    return;
  }
  return;
}



void ssl_handshake_wrapup_free_hs_transform(mbedtls_ssl_context *ssl)

{
  mbedtls_ssl_transform *pmVar1;
  
  mbedtls_debug_print_msg(ssl,3,"file1",0x13af,"=> handshake wrapup: final free");
  mbedtls_ssl_handshake_free(ssl->handshake);
  vPortFree(ssl->handshake);
  ssl->handshake = (mbedtls_ssl_handshake_params *)0x0;
  if (ssl->transform != (mbedtls_ssl_transform *)0x0) {
    mbedtls_ssl_transform_free(ssl->transform);
    vPortFree(ssl->transform);
  }
  pmVar1 = ssl->transform_negotiate;
  ssl->transform_negotiate = (mbedtls_ssl_transform *)0x0;
  ssl->transform = pmVar1;
  mbedtls_debug_print_msg(ssl,3,"file1",0x13c3,"<= handshake wrapup: final free");
  return;
}



void mbedtls_ssl_session_free(mbedtls_ssl_session *session)

{
  if (session != (mbedtls_ssl_session *)0x0) {
    if (session->peer_cert != (mbedtls_x509_crt *)0x0) {
      mbedtls_x509_crt_free(session->peer_cert);
      vPortFree(session->peer_cert);
    }
    vPortFree(session->ticket);
    mbedtls_zeroize(session,0x74);
    return;
  }
  return;
}



void mbedtls_ssl_handshake_wrapup(mbedtls_ssl_context *ssl)

{
  mbedtls_ssl_session *pmVar1;
  anon_subr_int_void_ptr_mbedtls_ssl_session_ptr_for_f_set_cache *paVar2;
  int iVar3;
  
  iVar3 = ssl->handshake->resume;
  mbedtls_debug_print_msg(ssl,3,"file1",0x13ca,"=> handshake wrapup");
  if (ssl->session != (mbedtls_ssl_session *)0x0) {
    mbedtls_ssl_session_free(ssl->session);
    vPortFree(ssl->session);
  }
  pmVar1 = ssl->session_negotiate;
  ssl->session_negotiate = (mbedtls_ssl_session *)0x0;
  ssl->session = pmVar1;
  paVar2 = ssl->conf->f_set_cache;
  if ((((paVar2 != (anon_subr_int_void_ptr_mbedtls_ssl_session_ptr_for_f_set_cache *)0x0) &&
       (pmVar1->id_len != 0)) && (iVar3 == 0)) &&
     (iVar3 = (*paVar2)(ssl->conf->p_cache,pmVar1), iVar3 != 0)) {
    mbedtls_debug_print_msg(ssl,1,"file1",0x13ed,"cache did not store session");
  }
  if (((*(ushort *)&ssl->conf->field_0x74 & 2) == 0) ||
     (ssl->handshake->flight == (mbedtls_ssl_flight_item *)0x0)) {
    ssl_handshake_wrapup_free_hs_transform(ssl);
  }
  else {
    ssl_set_timer(ssl,0);
    mbedtls_debug_print_msg(ssl,3,"file1",0x13f9,"skip freeing handshake and transform");
  }
  ssl->state = ssl->state + 1;
  mbedtls_debug_print_msg(ssl,3,"file1",0x1401,"<= handshake wrapup");
  return;
}



int ssl_handshake_init(mbedtls_ssl_context *ssl)

{
  mbedtls_ssl_transform *__s;
  mbedtls_ssl_handshake_params *__s_00;
  mbedtls_ssl_session *pmVar1;
  
  if (ssl->transform_negotiate != (mbedtls_ssl_transform *)0x0) {
    mbedtls_ssl_transform_free(ssl->transform_negotiate);
  }
  if (ssl->session_negotiate != (mbedtls_ssl_session *)0x0) {
    mbedtls_ssl_session_free(ssl->session_negotiate);
  }
  if (ssl->handshake != (mbedtls_ssl_handshake_params *)0x0) {
    mbedtls_ssl_handshake_free(ssl->handshake);
  }
  if (ssl->transform_negotiate == (mbedtls_ssl_transform *)0x0) {
    __s = (mbedtls_ssl_transform *)mycalloc(1,0xd0);
    ssl->transform_negotiate = __s;
  }
  if (ssl->session_negotiate == (mbedtls_ssl_session *)0x0) {
    pmVar1 = (mbedtls_ssl_session *)mycalloc(1,0x74);
    ssl->session_negotiate = pmVar1;
  }
  if (ssl->handshake == (mbedtls_ssl_handshake_params *)0x0) {
    __s_00 = (mbedtls_ssl_handshake_params *)mycalloc(1,0x15c);
    ssl->handshake = __s_00;
    if (__s_00 == (mbedtls_ssl_handshake_params *)0x0) goto LAB_2305a8a6;
  }
  if ((ssl->transform_negotiate != (mbedtls_ssl_transform *)0x0) &&
     (ssl->session_negotiate != (mbedtls_ssl_session *)0x0)) {
    mbedtls_ssl_session_init(ssl->session_negotiate);
    __s = ssl->transform_negotiate;
    memset(__s,0,0xd0);
    mbedtls_cipher_init(&__s->cipher_ctx_enc);
    mbedtls_cipher_init(&__s->cipher_ctx_dec);
    mbedtls_md_init(&__s->md_ctx_enc);
    mbedtls_md_init(&__s->md_ctx_dec);
    __s_00 = ssl->handshake;
    memset(__s_00,0,0x15c);
    mbedtls_sha256_init(&__s_00->fin_sha256);
    mbedtls_sha256_starts(&__s_00->fin_sha256,0);
    __s_00->update_checksum = ssl_update_checksum_start;
    __s_00->sig_alg = 2;
    __s_00->sni_authmode = 3;
    if ((*(ushort *)&ssl->conf->field_0x74 & 2) == 0) {
      return 0;
    }
    ssl->handshake->alt_transform_out = ssl->transform_out;
    if ((*(ushort *)&ssl->conf->field_0x74 & 1) == 0) {
      ssl->handshake->retransmit_state = '\0';
    }
    else {
      ssl->handshake->retransmit_state = '\x02';
    }
    ssl_set_timer(ssl,0);
    return 0;
  }
LAB_2305a8a6:
  mbedtls_debug_print_msg(ssl,1,"file1",0x152c,"alloc() of ssl sub-contexts failed");
  vPortFree(ssl->handshake);
  vPortFree(ssl->transform_negotiate);
  vPortFree(ssl->session_negotiate);
  ssl->handshake = (mbedtls_ssl_handshake_params *)0x0;
  ssl->transform_negotiate = (mbedtls_ssl_transform *)0x0;
  ssl->session_negotiate = (mbedtls_ssl_session *)0x0;
  return -0x7f00;
}



int mbedtls_ssl_setup(mbedtls_ssl_context *ssl,mbedtls_ssl_config *conf)

{
  uchar *puVar1;
  int iVar2;
  uchar *puVar3;
  uchar *puVar4;
  
  ssl->conf = conf;
  puVar1 = (uchar *)mycalloc(1,0x413d);
  ssl->in_buf = puVar1;
  if (puVar1 != (uchar *)0x0) {
    puVar1 = (uchar *)mycalloc(1,0x413d);
    ssl->out_buf = puVar1;
    if (puVar1 != (uchar *)0x0) {
      puVar4 = ssl->in_buf;
      puVar3 = puVar1 + 0xd;
      if ((*(ushort *)&conf->field_0x74 & 2) == 0) {
        ssl->out_ctr = puVar1;
        ssl->in_ctr = puVar4;
        ssl->out_hdr = puVar1 + 8;
        ssl->out_len = puVar1 + 0xb;
        ssl->out_iv = puVar3;
        ssl->out_msg = puVar3;
        ssl->in_hdr = puVar4 + 8;
      }
      else {
        ssl->out_hdr = puVar1;
        ssl->in_hdr = puVar4;
        ssl->out_ctr = puVar1 + 3;
        ssl->out_len = puVar1 + 0xb;
        ssl->out_iv = puVar3;
        ssl->out_msg = puVar3;
        ssl->in_ctr = puVar4 + 3;
      }
      ssl->in_len = puVar4 + 0xb;
      ssl->in_iv = puVar4 + 0xd;
      ssl->in_msg = puVar4 + 0xd;
      iVar2 = ssl_handshake_init(ssl);
      return iVar2;
    }
  }
  mbedtls_debug_print_msg(ssl,1,"file1",0x1585,"alloc(%d bytes) failed",0x413d);
  vPortFree(ssl->in_buf);
  ssl->in_buf = (uchar *)0x0;
  return -0x7f00;
}



void mbedtls_ssl_free(mbedtls_ssl_context *ssl)

{
  size_t n;
  char *__s;
  
  if (ssl != (mbedtls_ssl_context *)0x0) {
    mbedtls_debug_print_msg(ssl,2,"file1",0x1c0a,"=> free");
    if (ssl->out_buf != (uchar *)0x0) {
      mbedtls_zeroize(ssl->out_buf,0x413d);
      vPortFree(ssl->out_buf);
    }
    if (ssl->in_buf != (uchar *)0x0) {
      mbedtls_zeroize(ssl->in_buf,0x413d);
      vPortFree(ssl->in_buf);
    }
    if (ssl->transform != (mbedtls_ssl_transform *)0x0) {
      mbedtls_ssl_transform_free(ssl->transform);
      vPortFree(ssl->transform);
    }
    if (ssl->handshake != (mbedtls_ssl_handshake_params *)0x0) {
      mbedtls_ssl_handshake_free(ssl->handshake);
      mbedtls_ssl_transform_free(ssl->transform_negotiate);
      mbedtls_ssl_session_free(ssl->session_negotiate);
      vPortFree(ssl->handshake);
      vPortFree(ssl->transform_negotiate);
      vPortFree(ssl->session_negotiate);
    }
    if (ssl->session != (mbedtls_ssl_session *)0x0) {
      mbedtls_ssl_session_free(ssl->session);
      vPortFree(ssl->session);
    }
    __s = ssl->hostname;
    if (__s != (char *)0x0) {
      n = strlen(__s);
      mbedtls_zeroize(__s,n);
      vPortFree(ssl->hostname);
    }
    mbedtls_debug_print_msg(ssl,2,"file1",0x1c4b,"<= free");
    mbedtls_zeroize(ssl,0xc0);
    return;
  }
  return;
}



void mbedtls_ssl_config_init(mbedtls_ssl_config *conf)

{
  memset(conf,0,0x78);
  return;
}



int mbedtls_ssl_config_defaults(mbedtls_ssl_config *conf,int endpoint,int transport,int preset)

{
  ushort uVar1;
  ushort uVar2;
  ushort uVar3;
  int *piVar4;
  mbedtls_ecp_group_id *pmVar5;
  
  uVar1 = *(ushort *)&conf->field_0x74;
  uVar3 = (ushort)endpoint & 1;
  uVar2 = (ushort)((transport & 1U) << 1);
  *(ushort *)&conf->field_0x74 = uVar1 & 0xfffc | uVar3 | uVar2;
  if (endpoint == 0) {
    *(ushort *)&conf->field_0x74 = uVar1 & 0xfdf0 | uVar3 | uVar2 | 0x208;
  }
  conf->hs_timeout_min = 1000;
  conf->hs_timeout_max = 60000;
  if (preset == 2) {
    *(undefined4 *)&conf->max_major_ver = 0x3030303;
    conf->ciphersuite_list[3] = (int *)0x4200d4a8;
    conf->ciphersuite_list[2] = (int *)0x4200d4a8;
    conf->ciphersuite_list[1] = (int *)0x4200d4a8;
    conf->ciphersuite_list[0] = (int *)0x4200d4a8;
    conf->cert_profile = &mbedtls_x509_crt_profile_suiteb;
    conf->sig_hashes = ssl_preset_suiteb_hashes;
    conf->curve_list = ssl_preset_suiteb_curves;
    return 0;
  }
  *(undefined4 *)&conf->max_major_ver = 0x3030303;
  if (transport == 1) {
    conf->min_minor_ver = '\x02';
  }
  piVar4 = mbedtls_ssl_list_ciphersuites();
  conf->cert_profile = &mbedtls_x509_crt_profile_default;
  conf->ciphersuite_list[3] = piVar4;
  conf->ciphersuite_list[2] = piVar4;
  conf->ciphersuite_list[1] = piVar4;
  conf->ciphersuite_list[0] = piVar4;
  conf->sig_hashes = ssl_preset_default_hashes;
  pmVar5 = mbedtls_ecp_grp_id_list();
  conf->curve_list = pmVar5;
  return 0;
}



void mbedtls_ssl_config_free(mbedtls_ssl_config *conf)

{
  mbedtls_ssl_key_cert *pmVar1;
  mbedtls_ssl_key_cert *pv;
  
  pv = conf->key_cert;
  while (pv != (mbedtls_ssl_key_cert *)0x0) {
    pmVar1 = pv->next;
    vPortFree(pv);
    pv = pmVar1;
  }
  mbedtls_zeroize(conf,0x78);
  return;
}



uchar mbedtls_ssl_sig_from_pk(mbedtls_pk_context *pk)

{
  int iVar1;
  
  iVar1 = mbedtls_pk_can_do(pk,MBEDTLS_PK_RSA);
  return (uchar)(iVar1 != 0);
}



mbedtls_pk_type_t mbedtls_ssl_pk_alg_from_sig(uchar sig)

{
  undefined3 in_register_00002029;
  
  return (mbedtls_pk_type_t)(CONCAT31(in_register_00002029,sig) == 1);
}



mbedtls_md_type_t mbedtls_ssl_md_alg_from_hash(uchar hash)

{
  uint uVar1;
  
  uVar1 = (uint)hash - 1 & 0xff;
  if (uVar1 < 4) {
    return *(mbedtls_md_type_t *)((int)&CSWTCH_35 + uVar1);
  }
  return MBEDTLS_MD_NONE;
}



uchar mbedtls_ssl_hash_from_md_alg(int md)

{
  if (md - 3U < 4) {
    return *(uchar *)((int)&CSWTCH_35 + md + 1);
  }
  return '\0';
}



int mbedtls_ssl_check_curve(mbedtls_ssl_context *ssl,mbedtls_ecp_group_id grp_id)

{
  undefined3 in_register_0000202d;
  mbedtls_ecp_group_id *pmVar1;
  
  pmVar1 = ssl->conf->curve_list;
  if (pmVar1 != (mbedtls_ecp_group_id *)0x0) {
    while (*pmVar1 != MBEDTLS_ECP_DP_NONE) {
      if ((uint)*pmVar1 == CONCAT31(in_register_0000202d,grp_id)) {
        return 0;
      }
      pmVar1 = pmVar1 + 1;
    }
  }
  return -1;
}



int mbedtls_ssl_check_cert_usage
              (mbedtls_x509_crt *cert,mbedtls_ssl_ciphersuite_t *ciphersuite,int cert_endpoint,
              uint32_t *flags)

{
  int iVar1;
  int iVar2;
  uint usage;
  char *usage_oid;
  uint uVar3;
  
  usage = 0x80;
  if (cert_endpoint == 1) {
    usage = 0;
    if (ciphersuite->key_exchange < MBEDTLS_KEY_EXCHANGE_ECJPAKE) {
      uVar3 = 1 << ((uint)ciphersuite->key_exchange & 0x1f);
      usage = 0x20;
      if (((uVar3 & 0x82) == 0) && (usage = 8, (uVar3 & 0x600) == 0)) {
        usage = (uint)((uVar3 & 0x1c) != 0) << 7;
      }
    }
  }
  iVar1 = mbedtls_x509_crt_check_key_usage(cert,usage);
  if (iVar1 != 0) {
    *flags = *flags | 0x800;
    iVar1 = -1;
  }
  if (cert_endpoint == 1) {
    usage_oid = "+\x06\x01\x05\x05\a\x03\x01";
  }
  else {
    usage_oid = "+\x06\x01\x05\x05\a\x03\x02";
  }
  iVar2 = mbedtls_x509_crt_check_extended_key_usage(cert,usage_oid,8);
  if (iVar2 != 0) {
    iVar1 = -1;
    *flags = *flags | 0x1000;
  }
  return iVar1;
}



void mbedtls_ssl_write_version(int major,int minor,int transport,uchar *ver)

{
  uchar uVar1;
  
  uVar1 = (uchar)minor;
  if (transport == 1) {
    if (minor == 2) {
      uVar1 = '\x01';
    }
    *ver = ~((uchar)major - 2);
    uVar1 = -uVar1;
  }
  else {
    *ver = (uchar)major;
  }
  ver[1] = uVar1;
  return;
}



// WARNING: Variable defined which should be unmapped: add_data

int mbedtls_ssl_write_record(mbedtls_ssl_context *ssl)

{
  uchar uVar1;
  mbedtls_cipher_mode_t mVar2;
  int ret;
  mbedtls_ssl_flight_item *pv;
  size_t __n;
  char *text;
  int line;
  mbedtls_ssl_flight_item *pmVar3;
  mbedtls_ssl_flight_item *pmVar4;
  mbedtls_cipher_info_t *pmVar5;
  mbedtls_ssl_transform *pmVar6;
  uint uVar7;
  byte *pbVar8;
  uchar *input;
  undefined2 ilen;
  uint uVar9;
  size_t ilen_00;
  size_t *in_fa0;
  uchar *in_fa1;
  uchar *extraout_fa1;
  size_t in_fa2;
  size_t sStack52;
  size_t olen;
  uchar add_data [13];
  
  _ilen = ssl->out_msglen;
  ilen = (undefined2)_ilen;
  mbedtls_debug_print_msg(ssl,2,"file1",0xaa7,"=> write record");
  if (((((*(ushort *)&ssl->conf->field_0x74 & 2) == 0) ||
       (ssl->handshake == (mbedtls_ssl_handshake_params *)0x0)) ||
      (ssl->handshake->retransmit_state != '\x01')) && (ssl->out_msgtype == 0x16)) {
    uVar1 = *ssl->out_msg;
    if ((uVar1 != '\0') && (ssl->handshake == (mbedtls_ssl_handshake_params *)0x0)) {
      mbedtls_debug_print_msg(ssl,1,"file1",0xab9,"should never happen");
      return -0x6c00;
    }
    __n = _ilen - 4;
    ssl->out_msg[1] = (uchar)(__n >> 0x10);
    ssl->out_msg[2] = (uchar)(__n >> 8);
    ssl->out_msg[3] = (uchar)__n;
    if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
      _ilen = _ilen + 8;
      memmove(ssl->out_msg + 0xc,ssl->out_msg + 4,__n);
      ssl->out_msglen = ssl->out_msglen + 8;
      if (uVar1 == '\0') {
        ssl->out_msg[4] = '\0';
        ssl->out_msg[5] = '\0';
      }
      else {
        ssl->out_msg[4] = (uchar)(ssl->handshake->out_msg_seq >> 8);
        ssl->out_msg[5] = (uchar)ssl->handshake->out_msg_seq;
        ssl->handshake->out_msg_seq = ssl->handshake->out_msg_seq + 1;
      }
      memset(ssl->out_msg + 6,0,3);
      memcpy(ssl->out_msg + 9,ssl->out_msg + 1,3);
    }
    ilen = (undefined2)_ilen;
    if (uVar1 != '\0') {
      in_fa0 = (size_t *)(*ssl->handshake->update_checksum)(ssl,ssl->out_msg,_ilen);
      in_fa1 = extraout_fa1;
    }
  }
  if ((((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) &&
      (ssl->handshake != (mbedtls_ssl_handshake_params *)0x0)) &&
     ((ssl->handshake->retransmit_state != '\x01' && ((ssl->out_msgtype & 0xfffffffdU) == 0x14)))) {
    pv = (mbedtls_ssl_flight_item *)mycalloc(1,0x10);
    if (pv == (mbedtls_ssl_flight_item *)0x0) {
      mbedtls_debug_print_msg(ssl,1,"file1",0x9ca,"alloc %d bytes failed",0x10);
LAB_2305af0c:
      mbedtls_debug_print_ret(ssl,1,"file1",0xaf1,"ssl_flight_append",-0x7f00);
      return -0x7f00;
    }
    input = (uchar *)mycalloc(1,ssl->out_msglen);
    pv->p = input;
    if (input == (uchar *)0x0) {
      mbedtls_debug_print_msg(ssl,1,"file1",0x9d0,"alloc %d bytes failed");
      vPortFree(pv);
      goto LAB_2305af0c;
    }
    memcpy(input,ssl->out_msg,ssl->out_msglen);
    pv->len = ssl->out_msglen;
    line = ssl->out_msgtype;
    pv->next = (mbedtls_ssl_flight_item *)0x0;
    pv->type = (uchar)line;
    pmVar3 = ssl->handshake->flight;
    if (pmVar3 == (mbedtls_ssl_flight_item *)0x0) {
      ssl->handshake->flight = pv;
    }
    else {
      do {
        pmVar4 = pmVar3;
        pmVar3 = pmVar4->next;
      } while (pmVar3 != (mbedtls_ssl_flight_item *)0x0);
      pmVar4->next = pv;
    }
  }
  *ssl->out_hdr = (uchar)ssl->out_msgtype;
  mbedtls_ssl_write_version
            (ssl->major_ver,ssl->minor_ver,*(uint *)&ssl->conf->field_0x74 >> 1 & 1,ssl->out_hdr + 1
            );
  *ssl->out_len = (uchar)((ushort)ilen >> 8);
  ssl->out_len[1] = (uchar)ilen;
  if (ssl->transform_out == (mbedtls_ssl_transform *)0x0) {
LAB_2305b3e0:
    _ilen = mbedtls_ssl_hdr_len();
    ssl->out_left = _ilen + ssl->out_msglen;
    pbVar8 = ssl->out_hdr;
    mbedtls_debug_print_msg
              (ssl,3,"file1",0xb30,"output record: msgtype = %d, version = [%d:%d], msglen = %d",
               (uint)*pbVar8,(uint)pbVar8[1],(uint)pbVar8[2]);
    _ilen = mbedtls_ssl_hdr_len();
    mbedtls_debug_print_buf
              (ssl,4,"file1",0xb33,"output record sent to network",ssl->out_hdr,
               ssl->out_msglen + _ilen);
    ret = mbedtls_ssl_flush_output(ssl);
    if (ret == 0) {
      mbedtls_debug_print_msg(ssl,2,"file1",0xb3c,"<= write record");
      return 0;
    }
    text = "mbedtls_ssl_flush_output";
    line = 0xb38;
    goto LAB_2305b256;
  }
  mbedtls_debug_print_msg(ssl,2,"file1",0x504,"=> encrypt buf");
  if ((ssl->session_out == (mbedtls_ssl_session *)0x0) ||
     (ssl->transform_out == (mbedtls_ssl_transform *)0x0)) {
    line = 0x508;
LAB_2305b000:
    mbedtls_debug_print_msg(ssl,1,"file1",line,"should never happen");
    ret = -0x6c00;
  }
  else {
    pmVar5 = (ssl->transform_out->cipher_ctx_enc).cipher_info;
    mVar2 = MBEDTLS_MODE_NONE;
    if (pmVar5 != (mbedtls_cipher_info_t *)0x0) {
      mVar2 = pmVar5->mode;
    }
    mbedtls_debug_print_buf
              (ssl,4,"file1",0x50f,"before encrypt: output payload",ssl->out_msg,ssl->out_msglen);
    if ((mVar2 == MBEDTLS_MODE_STREAM) || (line = 0, mVar2 == MBEDTLS_MODE_CBC)) {
      if (ssl->minor_ver < 1) {
        line = 0x536;
        goto LAB_2305b000;
      }
      mbedtls_md_hmac_update(&ssl->transform_out->md_ctx_enc,ssl->out_ctr,8);
      mbedtls_md_hmac_update(&ssl->transform_out->md_ctx_enc,ssl->out_hdr,3);
      mbedtls_md_hmac_update(&ssl->transform_out->md_ctx_enc,ssl->out_len,2);
      line = 1;
      mbedtls_md_hmac_update(&ssl->transform_out->md_ctx_enc,ssl->out_msg,ssl->out_msglen);
      mbedtls_md_hmac_finish(&ssl->transform_out->md_ctx_enc,ssl->out_msg + ssl->out_msglen);
      mbedtls_md_hmac_reset(&ssl->transform_out->md_ctx_enc);
      mbedtls_debug_print_buf
                (ssl,4,"file1",0x53c,"computed mac",ssl->out_msg + ssl->out_msglen,
                 ssl->transform_out->maclen);
      ssl->out_msglen = ssl->out_msglen + ssl->transform_out->maclen;
    }
    if ((mVar2 + ~MBEDTLS_MODE_CTR & 0xfd) != 0) {
      if (mVar2 != MBEDTLS_MODE_CBC) {
        line = 0x627;
        goto LAB_2305b000;
      }
      olen = 0;
      uVar7 = ssl->transform_out->ivlen;
      uVar9 = uVar7 - (ssl->out_msglen + 1) % uVar7;
      if (uVar7 == uVar9) {
        uVar9 = 0;
      }
      uVar7 = 0;
      do {
        ssl->out_msg[ssl->out_msglen + uVar7] = (uchar)uVar9;
        uVar7 = uVar7 + 1;
      } while (uVar7 <= uVar9);
      _ilen = ssl->out_msglen + 1 + uVar9;
      ssl->out_msglen = _ilen;
      if (1 < ssl->minor_ver) {
        ret = (*ssl->conf->f_rng)(ssl->conf->p_rng,ssl->transform_out->iv_enc,
                                  ssl->transform_out->ivlen);
        if (ret == 0) {
          memcpy(ssl->out_iv,ssl->transform_out->iv_enc,ssl->transform_out->ivlen);
          _ilen = ssl->out_msglen;
          input = ssl->out_msg;
          ssl->out_msglen = ssl->transform_out->ivlen + _ilen;
          goto LAB_2305b304;
        }
        goto LAB_2305b246;
      }
      input = ssl->out_msg;
LAB_2305b304:
      mbedtls_debug_print_msg
                (ssl,3,"file1",0x5e3,
                 "before encrypt: msglen = %d, including %d bytes of IV and %d bytes of padding",
                 ssl->out_msglen,ssl->transform_out->ivlen,uVar9 + 1);
      pmVar6 = ssl->transform_out;
      ret = mbedtls_cipher_crypt
                      (&pmVar6->cipher_ctx_enc,pmVar6->iv_enc,pmVar6->ivlen,input,_ilen,input,&olen)
      ;
      if (ret != 0) {
        text = "mbedtls_cipher_crypt";
        line = 0x5eb;
        goto LAB_2305b23a;
      }
      if (_ilen == olen) goto LAB_2305b2a0;
      line = 0x5f1;
      goto LAB_2305b000;
    }
    _ilen = 8;
    if ((ssl->transform_out->ciphersuite_info->flags & 2) == 0) {
      _ilen = 0x10;
    }
    memcpy(&olen,ssl->out_ctr,8);
    add_data[4] = (uchar)ssl->out_msgtype;
    mbedtls_ssl_write_version
              (ssl->major_ver,ssl->minor_ver,*(uint *)&ssl->conf->field_0x74 >> 1 & 1,add_data + 5);
    add_data[7] = (uchar)(ssl->out_msglen >> 8);
    add_data[8] = (uchar)ssl->out_msglen;
    mbedtls_debug_print_buf(ssl,4,"file1",0x575,"additional data used for AEAD",(uchar *)&olen,0xd);
    pmVar6 = ssl->transform_out;
    if (pmVar6->ivlen - 8 != pmVar6->fixed_ivlen) {
      line = 0x57d;
      goto LAB_2305b000;
    }
    memcpy(pmVar6->iv_enc + pmVar6->fixed_ivlen,ssl->out_ctr,8);
    memcpy(ssl->out_iv,ssl->out_ctr,8);
    mbedtls_debug_print_buf
              (ssl,4,"file1",0x586,"IV used",ssl->out_iv,
               ssl->transform_out->ivlen - ssl->transform_out->fixed_ivlen);
    ilen_00 = ssl->out_msglen;
    input = ssl->out_msg;
    ssl->out_msglen = (ssl->transform_out->ivlen + ilen_00) - ssl->transform_out->fixed_ivlen;
    mbedtls_debug_print_msg
              (ssl,3,"file1",0x592,"before encrypt: msglen = %d, including %d bytes of padding",0);
    pmVar6 = ssl->transform_out;
    ret = mbedtls_cipher_auth_encrypt
                    (&pmVar6->cipher_ctx_enc,pmVar6->iv_enc,pmVar6->ivlen,(uchar *)&olen,0xd,input,
                     ilen_00,input,in_fa0,in_fa1,in_fa2);
    if (ret == 0) {
      if (ilen_00 != sStack52) {
        line = 0x5a5;
        goto LAB_2305b000;
      }
      ssl->out_msglen = ssl->out_msglen + _ilen;
      line = line + 1;
      mbedtls_debug_print_buf(ssl,4,"file1",0x5ac,"after encrypt: tag",input + ilen_00,_ilen);
LAB_2305b2a0:
      if (line == 1) {
        mbedtls_debug_print_msg(ssl,2,"file1",0x632,"<= encrypt buf");
        _ilen = ssl->out_msglen;
        *ssl->out_len = (uchar)(_ilen >> 8);
        ssl->out_len[1] = (uchar)_ilen;
        goto LAB_2305b3e0;
      }
      line = 0x62e;
      goto LAB_2305b000;
    }
    text = "mbedtls_cipher_auth_encrypt";
    line = 0x59f;
LAB_2305b23a:
    mbedtls_debug_print_ret(ssl,1,"file1",line,text,ret);
  }
LAB_2305b246:
  text = "ssl_encrypt_buf";
  line = 0xb22;
LAB_2305b256:
  mbedtls_debug_print_ret(ssl,1,"file1",line,text,ret);
  return ret;
}



int mbedtls_ssl_resend(mbedtls_ssl_context *ssl)

{
  mbedtls_ssl_flight_item *pmVar1;
  int ret;
  mbedtls_ssl_handshake_params *pmVar2;
  
  mbedtls_debug_print_msg(ssl,2,"file1",0xa39,"=> mbedtls_ssl_resend");
  if (ssl->handshake->retransmit_state != '\x01') {
    mbedtls_debug_print_msg(ssl,2,"file1",0xa3d,"initialise resending");
    ssl->handshake->cur_msg = ssl->handshake->flight;
    ssl_swap_epochs(ssl);
    ssl->handshake->retransmit_state = '\x01';
  }
  do {
    pmVar2 = ssl->handshake;
    pmVar1 = pmVar2->cur_msg;
    if (pmVar1 == (mbedtls_ssl_flight_item *)0x0) {
      if (ssl->state == 0x10) {
        pmVar2->retransmit_state = '\x03';
      }
      else {
        pmVar2->retransmit_state = '\x02';
        ssl_set_timer(ssl,ssl->handshake->retransmit_timeout);
      }
      mbedtls_debug_print_msg(ssl,2,"file1",0xa6a,"<= mbedtls_ssl_resend");
      return 0;
    }
    if ((pmVar1->type == '\x16') && (*pmVar1->p == '\x14')) {
      ssl_swap_epochs(ssl);
    }
    memcpy(ssl->out_msg,pmVar1->p,pmVar1->len);
    ssl->out_msglen = pmVar1->len;
    ssl->out_msgtype = (uint)pmVar1->type;
    ssl->handshake->cur_msg = pmVar1->next;
    mbedtls_debug_print_buf(ssl,3,"file1",0xa59,"resent handshake message header",ssl->out_msg,0xc);
    ret = mbedtls_ssl_write_record(ssl);
  } while (ret == 0);
  mbedtls_debug_print_ret(ssl,1,"file1",0xa5d,"mbedtls_ssl_write_record",ret);
  return ret;
}



// WARNING: Exceeded maximum restarts with more pending

int mbedtls_ssl_fetch_input(mbedtls_ssl_context *ssl,size_t nb_want)

{
  void *pvVar1;
  int iVar2;
  int ret;
  uint uVar3;
  char *format;
  size_t ret_00;
  uint uVar4;
  uint uVar5;
  uint32_t uVar6;
  
  mbedtls_debug_print_msg(ssl,2,"file1",0x8ba,"=> fetch input");
  if ((ssl->f_recv == (mbedtls_ssl_recv_t *)0x0) &&
     (ssl->f_recv_timeout == (mbedtls_ssl_recv_timeout_t_conflict1 *)0x0)) {
    format = "Bad usage of mbedtls_ssl_set_bio() or mbedtls_ssl_set_bio()";
    ret = 0x8bf;
LAB_2305b62c:
    mbedtls_debug_print_msg(ssl,1,"file1",ret,format);
    return -0x7100;
  }
  if (0x413dU - (int)(ssl->in_hdr + -(int)ssl->in_buf) < nb_want) {
    format = "requesting more data than fits";
    ret = 0x8c5;
    goto LAB_2305b62c;
  }
  if ((*(ushort *)&ssl->conf->field_0x74 & 2) == 0) {
    mbedtls_debug_print_msg(ssl,2,"file1",0x958,"in_left: %d, nb_want: %d",ssl->in_left,nb_want);
    while (uVar5 = ssl->in_left, uVar5 < nb_want) {
      iVar2 = ssl_check_timer(ssl);
      ret = -0x6800;
      if (iVar2 == 0) {
        if (ssl->f_recv_timeout == (mbedtls_ssl_recv_timeout_t_conflict1 *)0x0) {
          ret = (*ssl->f_recv)(ssl->f_recv);
        }
        else {
          ret = (*ssl->f_recv_timeout)
                          (ssl->p_bio,ssl->in_hdr + ssl->in_left,nb_want - uVar5,
                           ssl->conf->read_timeout);
        }
      }
      mbedtls_debug_print_msg(ssl,2,"file1",0x970,"in_left: %d, nb_want: %d",ssl->in_left,nb_want);
      mbedtls_debug_print_ret(ssl,2,"file1",0x971,"ssl->f_recv(_timeout)",ret);
      if (ret == 0) {
        return -0x7280;
      }
      if (ret < 0) {
        return ret;
      }
      ssl->in_left = ret + ssl->in_left;
    }
  }
  else {
    if ((ssl->f_set_timer == (mbedtls_ssl_set_timer_t_conflict1 *)0x0) ||
       (ssl->f_get_timer == (mbedtls_ssl_get_timer_t *)0x0)) {
      format = "You must use mbedtls_ssl_set_timer_cb() for DTLS";
      ret = 0x8d2;
      goto LAB_2305b62c;
    }
    uVar5 = ssl->next_record_offset;
    if (uVar5 != 0) {
      if (ssl->in_left < uVar5) {
        ret = 0x8e4;
        goto LAB_2305b6ba;
      }
      ret_00 = ssl->in_left - uVar5;
      ssl->in_left = ret_00;
      if (ret_00 != 0) {
        mbedtls_debug_print_msg(ssl,2,"file1",0x8ed,"next record in same datagram, offset: %d");
        memmove(ssl->in_hdr,ssl->in_hdr + ssl->next_record_offset,ssl->in_left);
      }
      ssl->next_record_offset = 0;
    }
    mbedtls_debug_print_msg(ssl,2,"file1",0x8f7,"in_left: %d, nb_want: %d",ssl->in_left,nb_want);
    if (nb_want <= ssl->in_left) {
      ret = 0x8fe;
      goto LAB_2305b72e;
    }
    if (ssl->in_left != 0) {
      ret = 0x909;
LAB_2305b6ba:
      mbedtls_debug_print_msg(ssl,1,"file1",ret,"should never happen");
      return -0x6c00;
    }
    ret = ssl_check_timer(ssl);
    if (ret != 0) {
LAB_2305b756:
      mbedtls_debug_print_msg(ssl,2,"file1",0x92d,"timeout");
      ssl_set_timer(ssl,0);
      if (ssl->state != 0x10) {
        uVar3 = ssl->handshake->retransmit_timeout;
        uVar5 = ssl->conf->hs_timeout_max;
        if (uVar3 < uVar5) {
          uVar4 = uVar3 << 1;
          if ((uVar3 <= uVar4) && (uVar4 < uVar5)) {
            uVar5 = uVar4;
          }
          ssl->handshake->retransmit_timeout = uVar5;
          mbedtls_debug_print_msg
                    (ssl,3,"file1",0x7e,"update timeout value to %d millisecs",
                     ssl->handshake->retransmit_timeout);
          ret = mbedtls_ssl_resend(ssl);
          if (ret == 0) {
            return -0x6900;
          }
          mbedtls_debug_print_ret(ssl,1,"file1",0x93a,"mbedtls_ssl_resend",ret);
          return ret;
        }
        mbedtls_debug_print_msg(ssl,1,"file1",0x934,"handshake timeout");
      }
      return -0x6800;
    }
    pvVar1 = (void *)(0x413d - (int)(ssl->in_hdr + -(int)ssl->in_buf));
    if (ssl->state == 0x10) {
      uVar6 = ssl->conf->read_timeout;
    }
    else {
      uVar6 = ssl->handshake->retransmit_timeout;
    }
    mbedtls_debug_print_msg(ssl,3,"file1",0x91d,"f_recv_timeout: %u ms",uVar6);
    if (ssl->f_recv_timeout == (mbedtls_ssl_recv_timeout_t_conflict1 *)0x0) {
      ret_00 = (*ssl->f_recv)(pvVar1,(uchar *)ssl->f_recv);
    }
    else {
      ret_00 = (*ssl->f_recv_timeout)(ssl->p_bio,ssl->in_hdr,(size_t)pvVar1,uVar6);
    }
    mbedtls_debug_print_ret(ssl,2,"file1",0x925,"ssl->f_recv(_timeout)",ret_00);
    if (ret_00 == 0) {
      return -0x7280;
    }
    if (ret_00 == 0xffff9800) goto LAB_2305b756;
    if ((int)ret_00 < 0) {
      return ret_00;
    }
    ssl->in_left = ret_00;
  }
  ret = 0x97d;
LAB_2305b72e:
  mbedtls_debug_print_msg(ssl,2,"file1",ret,"<= fetch input");
  return 0;
}



int mbedtls_ssl_prepare_handshake_record(mbedtls_ssl_context *ssl)

{
  byte bVar1;
  uint uVar2;
  uchar *__s1;
  int line;
  size_t __n;
  uint uVar3;
  mbedtls_ssl_handshake_params *pmVar4;
  uint __n_00;
  int line_00;
  uint uVar5;
  byte *pbVar6;
  char *format;
  uint uVar7;
  size_t size;
  uint uVar8;
  uint uVar9;
  size_t sVar10;
  uchar *puVar11;
  uint uVar12;
  uchar *puVar13;
  
  uVar3 = 0xc;
  if ((*(ushort *)&ssl->conf->field_0x74 & 2) == 0) {
    uVar3 = 4;
  }
  if (ssl->in_msglen < uVar3) {
    mbedtls_debug_print_msg(ssl,1,"file1",0xc20,"handshake message too short: %d");
    return -0x7200;
  }
  pbVar6 = ssl->in_msg;
  ssl->in_hslen = ((uint)pbVar6[1] << 0x10 | (uint)pbVar6[2] << 8 | (uint)pbVar6[3]) + uVar3;
  mbedtls_debug_print_msg
            (ssl,3,"file1",0xc2b,"handshake message: msglen = %d, type = %d, hslen = %d",
             (uint)*pbVar6);
  if ((*(ushort *)&ssl->conf->field_0x74 & 2) == 0) {
    if (ssl->in_hslen <= ssl->in_msglen) {
      return 0;
    }
    mbedtls_debug_print_msg(ssl,1,"file1",0xc69,"TLS handshake fragmentation not supported");
    return -0x7080;
  }
  pmVar4 = ssl->handshake;
  __s1 = ssl->in_msg;
  if (pmVar4 != (mbedtls_ssl_handshake_params *)0x0) {
    uVar3 = (uint)(*(ushort *)(__s1 + 4) >> 8) | ((uint)*(ushort *)(__s1 + 4) & 0xff) << 8;
    if (pmVar4->in_msg_seq != uVar3) {
      __n_00 = pmVar4->in_flight_start_seq - 1;
      if ((__n_00 != uVar3) || (*__s1 == '\x03')) {
        mbedtls_debug_print_msg
                  (ssl,2,"file1",0xc4d,
                   "dropping out-of-sequence message: message_seq = %d, expected = %d",
                   pmVar4->in_msg_seq);
        return -0x6900;
      }
      mbedtls_debug_print_msg
                (ssl,2,"file1",0xc40,
                 "received message from last flight, message_seq = %d, start_of_flight = %d",__n_00)
      ;
      line = mbedtls_ssl_resend(ssl);
      if (line == 0) {
        return -0x6900;
      }
      format = "mbedtls_ssl_resend";
      line_00 = 0xc44;
      goto LAB_2305ba60;
    }
  }
  if (((ssl->in_hslen <= ssl->in_msglen) && (line = memcmp(__s1 + 6,&DAT_23088e44,3), line == 0)) &&
     (line = memcmp(ssl->in_msg + 9,ssl->in_msg + 1,3), line == 0)) {
    if (ssl->handshake == (mbedtls_ssl_handshake_params *)0x0) {
      return 0;
    }
    if (ssl->handshake->hs_msg == (uchar *)0x0) {
      return 0;
    }
  }
  mbedtls_debug_print_msg(ssl,2,"file1",0xc5b,"found fragmented DTLS handshake message");
  sVar10 = ssl->in_hslen;
  uVar3 = sVar10 - 0xc;
  if (ssl->handshake == (mbedtls_ssl_handshake_params *)0x0) {
    format = "not supported outside handshake (for now)";
    line = 0xb8f;
LAB_2305bace:
    mbedtls_debug_print_msg(ssl,1,"file1",line,format);
    line = -0x7080;
  }
  else {
    __s1 = ssl->handshake->hs_msg;
    if (__s1 != (uchar *)0x0) {
      line = memcmp(__s1,ssl->in_msg,4);
      if (line == 0) goto LAB_2305bbca;
      mbedtls_debug_print_msg(ssl,1,"file1",0xbb9,"fragment header mismatch");
      goto LAB_2305bc4c;
    }
    mbedtls_debug_print_msg(ssl,2,"file1",0xb9b,"initialize reassembly, total length = %d",uVar3);
    if (0x4000 < ssl->in_hslen) {
      format = "handshake message too large";
      line = 0xb9f;
      goto LAB_2305bace;
    }
    size = (uint)((uVar3 & 7) != 0) + (uVar3 >> 3) + sVar10;
    pmVar4 = ssl->handshake;
    __s1 = (uchar *)mycalloc(1,size);
    pmVar4->hs_msg = __s1;
    __s1 = ssl->handshake->hs_msg;
    if (__s1 == (uchar *)0x0) {
      mbedtls_debug_print_msg(ssl,1,"file1",0xba9,"alloc failed (%d bytes)",size);
      line = -0x7f00;
      goto LAB_2305bae0;
    }
    memcpy(__s1,ssl->in_msg,6);
    memset(ssl->handshake->hs_msg + 6,0,3);
    __s1 = ssl->handshake->hs_msg;
    memcpy(__s1 + 9,__s1 + 1,3);
LAB_2305bbca:
    puVar13 = ssl->handshake->hs_msg;
    __s1 = ssl->in_msg;
    puVar11 = puVar13 + sVar10;
    bVar1 = __s1[8];
    uVar9 = (uint)__s1[6] << 0x10 | (uint)__s1[7] << 8 | (uint)bVar1;
    __n_00 = (uint)__s1[9] << 0x10 | (uint)__s1[10] << 8 | (uint)__s1[0xb];
    if (uVar3 < uVar9 + __n_00) {
      mbedtls_debug_print_msg
                (ssl,1,"file1",0xbce,"invalid fragment offset/len: %d + %d > %d",uVar9,__n_00,uVar3)
      ;
    }
    else {
      uVar12 = __n_00 + 0xc;
      if (uVar12 <= ssl->in_msglen) {
        mbedtls_debug_print_msg
                  (ssl,2,"file1",0xbda,"adding fragment, offset = %d, length = %d",uVar9,__n_00);
        memcpy(puVar13 + uVar9 + 0xc,ssl->in_msg + 0xc,__n_00);
        uVar5 = (uint)bVar1 & 7;
        uVar8 = 8 - uVar5;
        if (uVar8 == 8) {
LAB_2305bd4a:
          uVar5 = __n_00 & 7;
          if (uVar5 != 0) {
            uVar7 = __n_00 + uVar9;
            uVar8 = (uint)puVar11[uVar7 >> 3];
            __n_00 = __n_00 - uVar5;
            uVar5 = 8 - uVar5;
            do {
              uVar2 = uVar5 & 0x1f;
              uVar5 = uVar5 + 1;
              uVar8 = uVar8 | 1 << uVar2 & 0xffU;
            } while (uVar5 != 8);
            puVar11[uVar7 >> 3] = (byte)uVar8;
          }
          memset(puVar11 + (uVar9 >> 3),0xff,__n_00 >> 3);
        }
        else {
          uVar7 = uVar9 >> 3;
          if (uVar8 < __n_00) {
            __n_00 = (__n_00 - 8) + uVar5;
            uVar5 = (uint)puVar11[uVar7];
            uVar9 = uVar9 + uVar8;
            do {
              uVar8 = uVar8 - 1;
              uVar5 = uVar5 | 1 << (uVar8 & 0x1f) & 0xffU;
            } while (uVar8 != 0);
            puVar11[uVar7] = (byte)uVar5;
            goto LAB_2305bd4a;
          }
          __n_00 = uVar8 - __n_00;
          while (__n_00 != uVar8) {
            uVar9 = __n_00 & 0x1f;
            __n_00 = __n_00 + 1;
            puVar11[uVar7] = (byte)(1 << uVar9) | puVar11[uVar7];
          }
        }
        __n_00 = 0;
        while (__n_00 != uVar3 >> 3) {
          if (puVar11[__n_00] != -1) goto LAB_2305be72;
          __n_00 = __n_00 + 1;
        }
        uVar9 = 0;
        while (uVar9 < (uVar3 & 7)) {
          if (((int)(uint)puVar11[__n_00] >> (7 - uVar9 & 0x1f) & 1U) == 0) goto LAB_2305be72;
          uVar9 = uVar9 + 1;
        }
        mbedtls_debug_print_msg(ssl,2,"file1",0xbe9,"handshake message completed");
        if (ssl->in_msglen <= uVar12) {
          uVar3 = ssl->next_record_offset;
          if (ssl->in_left <= uVar3) {
LAB_2305be0a:
            memcpy(ssl->in_msg,ssl->handshake->hs_msg,ssl->in_hslen);
            vPortFree(ssl->handshake->hs_msg);
            ssl->handshake->hs_msg = (uchar *)0x0;
            mbedtls_debug_print_buf
                      (ssl,3,"file1",0xc15,"reassembled handshake message",ssl->in_msg,ssl->in_hslen
                      );
            return 0;
          }
          puVar13 = ssl->in_hdr;
          __n = ssl->in_left - uVar3;
          __s1 = ssl->in_msg + ssl->in_hslen;
          puVar11 = __s1 + -(int)puVar13;
          *(uchar **)&ssl->next_record_offset = puVar11;
          *(uchar **)&ssl->in_left = puVar11 + __n;
          if (puVar11 + __n <= (uchar *)(0x413d - (int)(puVar13 + -(int)ssl->in_buf))) {
            memmove(__s1,puVar13 + uVar3,__n);
            goto LAB_2305be0a;
          }
          mbedtls_debug_print_msg(ssl,1,"file1",0xc08,"reassembled message too large for buffer");
          line = -0x6a00;
          goto LAB_2305bae0;
        }
        format = "last fragment not alone in its record";
        line = 0xbf2;
        goto LAB_2305bace;
      }
      mbedtls_debug_print_msg(ssl,1,"file1",0xbd5,"invalid fragment length: %d + 12 > %d",__n_00);
    }
LAB_2305bc4c:
    line = -0x7200;
  }
LAB_2305bae0:
  format = "ssl_reassemble_dtls_handshake";
  line_00 = 0xc5f;
LAB_2305ba60:
  mbedtls_debug_print_ret(ssl,1,"file1",line_00,format,line);
  return line;
LAB_2305be72:
  mbedtls_debug_print_msg(ssl,2,"file1",0xbe5,"message is not complete yet");
  line = -0x6900;
  goto LAB_2305bae0;
}



int mbedtls_ssl_handle_message_type(mbedtls_ssl_context *ssl)

{
  int iVar1;
  uchar *puVar2;
  
  if ((ssl->in_msgtype == 0x16) && (iVar1 = mbedtls_ssl_prepare_handshake_record(ssl), iVar1 != 0))
  {
    return iVar1;
  }
  if (ssl->in_msgtype == 0x15) {
    mbedtls_debug_print_msg
              (ssl,2,"file1",0xf93,"got an alert message, type: [%d:%d]",(uint)*ssl->in_msg,
               (uint)ssl->in_msg[1]);
    puVar2 = ssl->in_msg;
    if (*puVar2 == '\x02') {
      mbedtls_debug_print_msg
                (ssl,1,"file1",0xf9b,"is a fatal alert message (msg %d)",(uint)puVar2[1]);
      return -0x7780;
    }
    if (*puVar2 == '\x01') {
      if (puVar2[1] == '\0') {
        mbedtls_debug_print_msg(ssl,2,"file1",0xfa2,"is a close notify message");
        return -0x7880;
      }
      if (puVar2[1] == 'd') {
        mbedtls_debug_print_msg(ssl,2,"file1",0xfaa,"is a SSLv3 no_cert");
        goto LAB_2305beb0;
      }
    }
    iVar1 = -0x6680;
  }
  else {
LAB_2305beb0:
    iVar1 = 0;
  }
  return iVar1;
}



int mbedtls_ssl_send_alert_message(mbedtls_ssl_context *ssl,uchar level,uchar message)

{
  int ret;
  
  if ((ssl == (mbedtls_ssl_context *)0x0) || (ssl->conf == (mbedtls_ssl_config *)0x0)) {
    ret = -0x7100;
  }
  else {
    mbedtls_debug_print_msg(ssl,2,"file1",0xfda,"=> send alert message");
    ssl->out_msgtype = 0x15;
    ssl->out_msglen = 2;
    *ssl->out_msg = level;
    ssl->out_msg[1] = message;
    ret = mbedtls_ssl_write_record(ssl);
    if (ret == 0) {
      mbedtls_debug_print_msg(ssl,2,"file1",0xfe7,"<= send alert message");
    }
    else {
      mbedtls_debug_print_ret(ssl,1,"file1",0xfe3,"mbedtls_ssl_write_record",ret);
    }
  }
  return ret;
}



int mbedtls_ssl_send_fatal_handshake_failure(mbedtls_ssl_context *ssl)

{
  int iVar1;
  
  iVar1 = mbedtls_ssl_send_alert_message(ssl,'\x02','(');
  return iVar1;
}



int mbedtls_ssl_close_notify(mbedtls_ssl_context *ssl)

{
  int ret;
  
  if ((ssl == (mbedtls_ssl_context *)0x0) || (ssl->conf == (mbedtls_ssl_config *)0x0)) {
    ret = -0x7100;
  }
  else {
    mbedtls_debug_print_msg(ssl,2,"file1",0x1b68,"=> write close notify");
    if (ssl->out_left != 0) {
      ret = mbedtls_ssl_flush_output(ssl);
      return ret;
    }
    if ((ssl->state == 0x10) && (ret = mbedtls_ssl_send_alert_message(ssl,'\x01','\0'), ret != 0)) {
      mbedtls_debug_print_ret(ssl,1,"file1",0x1b73,"mbedtls_ssl_send_alert_message",ret);
    }
    else {
      mbedtls_debug_print_msg(ssl,2,"file1",0x1b78,"<= write close notify");
      ret = 0;
    }
  }
  return ret;
}



int mbedtls_ssl_write_certificate(mbedtls_ssl_context *ssl)

{
  int ret;
  mbedtls_x509_crt *crt;
  size_t sVar1;
  uint __n;
  mbedtls_ssl_ciphersuite_t *pmVar2;
  
  pmVar2 = ssl->transform_negotiate->ciphersuite_info;
  mbedtls_debug_print_msg(ssl,2,"file1",0x1025,"=> write certificate");
  __n = (uint)pmVar2->key_exchange - 5;
  if (((__n & 0xff) < 7) && ((0x4bU >> (__n & 0x1f) & 1) != 0)) {
    mbedtls_debug_print_msg(ssl,2,"file1",0x102c,"<= skip write certificate");
    ret = 0;
    ssl->state = ssl->state + 1;
  }
  else {
    if ((*(ushort *)&ssl->conf->field_0x74 & 1) == 0) {
      if (ssl->client_auth == 0) {
        mbedtls_debug_print_msg(ssl,2,"file1",0x1036,"<= skip write certificate");
        ssl->state = ssl->state + 1;
        return 0;
      }
    }
    else {
      crt = mbedtls_ssl_own_cert(ssl);
      if (crt == (mbedtls_x509_crt *)0x0) {
        mbedtls_debug_print_msg(ssl,1,"file1",0x1053,"got no certificate to send");
        return -0x7580;
      }
    }
    crt = mbedtls_ssl_own_cert(ssl);
    mbedtls_debug_print_crt(ssl,3,"file1",0x1059,"own certificate",crt);
    crt = mbedtls_ssl_own_cert(ssl);
    sVar1 = 7;
    while (crt != (mbedtls_x509_crt *)0x0) {
      __n = (crt->raw).len;
      if (0x3ffd - sVar1 < __n) {
        mbedtls_debug_print_msg(ssl,1,"file1",0x106d,"certificate too large, %d > %d",0x4000);
        return -0x7500;
      }
      ssl->out_msg[sVar1] = (uchar)(__n >> 0x10);
      ssl->out_msg[sVar1 + 1] = (uchar)(__n >> 8);
      ssl->out_msg[sVar1 + 2] = (uchar)__n;
      memcpy(ssl->out_msg + sVar1 + 3,(crt->raw).p,__n);
      crt = crt->next;
      sVar1 = sVar1 + 3 + __n;
    }
    ret = sVar1 - 7;
    ssl->out_msg[4] = (uchar)((uint)ret >> 0x10);
    ssl->out_msg[5] = (uchar)((uint)ret >> 8);
    ssl->out_msg[6] = (uchar)ret;
    ssl->out_msgtype = 0x16;
    ssl->out_msglen = sVar1;
    *ssl->out_msg = '\v';
    ssl->state = ssl->state + 1;
    ret = mbedtls_ssl_write_record(ssl);
    if (ret == 0) {
      mbedtls_debug_print_msg(ssl,2,"file1",0x108d,"<= write certificate");
    }
    else {
      mbedtls_debug_print_ret(ssl,1,"file1",0x1089,"mbedtls_ssl_write_record",ret);
    }
  }
  return ret;
}



int mbedtls_ssl_write_change_cipher_spec(mbedtls_ssl_context *ssl)

{
  int ret;
  
  mbedtls_debug_print_msg(ssl,2,"file1",0x11b4,"=> write change cipher spec");
  ssl->out_msgtype = 0x14;
  ssl->out_msglen = 1;
  *ssl->out_msg = '\x01';
  ssl->state = ssl->state + 1;
  ret = mbedtls_ssl_write_record(ssl);
  if (ret == 0) {
    mbedtls_debug_print_msg(ssl,2,"file1",0x11c2,"<= write change cipher spec");
  }
  else {
    mbedtls_debug_print_ret(ssl,1,"file1",0x11be,"mbedtls_ssl_write_record",ret);
  }
  return ret;
}



int mbedtls_ssl_write_finished(mbedtls_ssl_context *ssl)

{
  uchar *puVar1;
  uchar uVar2;
  int ret;
  
  mbedtls_debug_print_msg(ssl,2,"file1",0x1408,"=> write finished");
  puVar1 = ssl->out_iv;
  if (1 < ssl->minor_ver) {
    puVar1 = puVar1 + (ssl->transform_negotiate->ivlen - ssl->transform_negotiate->fixed_ivlen);
  }
  ssl->out_msg = puVar1;
  (*ssl->handshake->calc_finished)(ssl,puVar1 + 4,*(uint *)&ssl->conf->field_0x74 & 1);
  ret = 0x24;
  if (ssl->minor_ver != 0) {
    ret = 0xc;
  }
  ssl->out_msglen = ret + 4;
  ssl->out_msgtype = 0x16;
  *ssl->out_msg = '\x14';
  if (ssl->handshake->resume == 0) {
    ret = ssl->state + 1;
  }
  else {
    if (((*(ushort *)&ssl->conf->field_0x74 & 1) == 0) &&
       (ssl->state = 0xf, (*(ushort *)&ssl->conf->field_0x74 & 1) == 0)) goto LAB_2305c40a;
    ret = 10;
  }
  ssl->state = ret;
LAB_2305c40a:
  mbedtls_debug_print_msg(ssl,3,"file1",0x143e,"switching to new transform spec for outbound data");
  if ((*(ushort *)&ssl->conf->field_0x74 & 2) == 0) {
    memset(ssl->out_ctr,0,8);
  }
  else {
    ssl->handshake->alt_transform_out = ssl->transform_out;
    memcpy(ssl->handshake->alt_out_ctr,ssl->out_ctr,8);
    memset(ssl->out_ctr + 2,0,6);
    uVar2 = ssl->out_ctr[1] + '\x01';
    ssl->out_ctr[1] = uVar2;
    if ((uVar2 == '\0') && (uVar2 = *ssl->out_ctr + '\x01', *ssl->out_ctr = uVar2, uVar2 == '\0')) {
      mbedtls_debug_print_msg(ssl,1,"file1",0x1454,"DTLS epoch would wrap");
      return -0x6b80;
    }
  }
  ssl->transform_out = ssl->transform_negotiate;
  ssl->session_out = ssl->session_negotiate;
  if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
    mbedtls_ssl_send_flight_completed(ssl);
  }
  ret = mbedtls_ssl_write_record(ssl);
  if (ret == 0) {
    mbedtls_debug_print_msg(ssl,2,"file1",0x1475,"<= write finished");
  }
  else {
    mbedtls_debug_print_ret(ssl,1,"file1",0x1471,"mbedtls_ssl_write_record",ret);
  }
  return ret;
}



int mbedtls_ssl_write(mbedtls_ssl_context *ssl,uchar *buf,size_t len)

{
  size_t sVar1;
  int line;
  size_t sVar2;
  uint uVar3;
  char *text;
  
  mbedtls_debug_print_msg(ssl,2,"file1",0x1b3d,"=> write");
  if ((ssl == (mbedtls_ssl_context *)0x0) || (ssl->conf == (mbedtls_ssl_config *)0x0)) {
    return -0x7100;
  }
  if ((ssl->state != 0x10) && (line = mbedtls_ssl_handshake(ssl), line != 0)) {
    mbedtls_debug_print_ret(ssl,1,"file1",0x1b4e,"mbedtls_ssl_handshake",line);
    return line;
  }
  sVar2 = mbedtls_ssl_get_max_frag_len(ssl);
  sVar1 = len;
  if ((sVar2 < len) && (sVar1 = sVar2, (*(ushort *)&ssl->conf->field_0x74 & 2) != 0)) {
    text = "fragment larger than the (negotiated) maximum fragment length: %d > %d";
    line = 0x1ae7;
LAB_2305c5bc:
    mbedtls_debug_print_msg(ssl,1,"file1",line,text,len,sVar2);
    len = 0xffff8f00;
  }
  else {
    len = sVar1;
    if (ssl->out_left == 0) {
      sVar2 = 0x4130;
      if (0x4130 < len) {
        text = "input larger than the out msg maximum length: 0x%x > 0x%x";
        line = 0x1afe;
        goto LAB_2305c5bc;
      }
      ssl->out_msgtype = 0x17;
      ssl->out_msglen = len;
      memcpy(ssl->out_msg,buf,len);
      uVar3 = mbedtls_ssl_write_record(ssl);
      if (uVar3 == 0) goto LAB_2305c5ce;
      text = "mbedtls_ssl_write_record";
      line = 0x1b08;
      len = uVar3;
    }
    else {
      uVar3 = mbedtls_ssl_flush_output(ssl);
      if (uVar3 == 0) goto LAB_2305c5ce;
      text = "mbedtls_ssl_flush_output";
      line = 0x1af4;
      len = uVar3;
    }
    mbedtls_debug_print_ret(ssl,1,"file1",line,text,len);
  }
LAB_2305c5ce:
  mbedtls_debug_print_msg(ssl,2,"file1",0x1b59,"<= write");
  return len;
}



void mbedtls_ssl_read_version(int *major,int *minor,int transport,uchar *ver)

{
  uint uVar1;
  
  if (transport == 1) {
    *major = 0x101 - (uint)*ver;
    uVar1 = 0x100 - (uint)ver[1];
    if (uVar1 == 1) {
      uVar1 = 2;
    }
  }
  else {
    *major = (uint)*ver;
    uVar1 = (uint)ver[1];
  }
  *minor = uVar1;
  return;
}



int mbedtls_ssl_read_record_layer(mbedtls_ssl_context *ssl)

{
  bool bVar1;
  size_t nb_want;
  size_t len;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  size_t __n;
  uint uVar5;
  int line;
  mbedtls_cipher_info_t *pmVar6;
  mbedtls_cipher_mode_t mVar7;
  byte bVar8;
  char *format;
  uchar uVar9;
  mbedtls_ssl_transform *pmVar10;
  byte *pbVar11;
  uint uVar12;
  uint uVar13;
  int line_00;
  uint ret;
  uchar *input;
  uint uVar14;
  size_t *in_fa0;
  uchar *in_fa1;
  size_t in_fa2;
  size_t sStack116;
  int major_ver;
  int minor_ver;
  uchar auStack103 [2];
  undefined uStack101;
  undefined uStack100;
  
  uVar4 = ssl->in_hslen;
  if ((uVar4 == 0) || (ssl->in_msglen <= uVar4)) {
    ssl->in_hslen = 0;
    while( true ) {
      nb_want = mbedtls_ssl_hdr_len();
      line_00 = mbedtls_ssl_fetch_input(ssl,nb_want);
      if (line_00 != 0) break;
      nb_want = mbedtls_ssl_hdr_len();
      mbedtls_debug_print_buf(ssl,4,"file1",0xdb1,"input record header",ssl->in_hdr,nb_want);
      ssl->in_msgtype = (uint)*ssl->in_hdr;
      ssl->in_msglen =
           (uint)(*(ushort *)ssl->in_len >> 8) | ((uint)*(ushort *)ssl->in_len & 0xff) << 8;
      mbedtls_ssl_read_version
                ((int *)&sStack116,&major_ver,*(uint *)&ssl->conf->field_0x74 >> 1 & 1,
                 ssl->in_hdr + 1);
      mbedtls_debug_print_msg
                (ssl,3,"file1",0xdba,"input record: msgtype = %d, version = [%d:%d], msglen = %d",
                 ssl->in_msgtype,sStack116,major_ver);
      line_00 = ssl->in_msgtype;
      if (line_00 - 0x14U < 4) {
        if (ssl->major_ver != sStack116) {
          format = "major version mismatch";
          line_00 = 0xdd1;
LAB_2305c86e:
          mbedtls_debug_print_msg(ssl,1,"file1",line_00,format);
          goto LAB_2305c81a;
        }
        if ((int)(uint)ssl->conf->max_minor_ver < major_ver) {
          format = "minor version mismatch";
          line_00 = 0xdd7;
          goto LAB_2305c86e;
        }
        uVar4 = ssl->in_msglen;
        if (0x413dU - (int)(ssl->in_msg + -(int)ssl->in_buf) < uVar4) {
          format = "bad message length";
          line_00 = 0xddf;
          goto LAB_2305c86e;
        }
        if (ssl->transform_in != (mbedtls_ssl_transform *)0x0) {
          ret = ssl->transform_in->minlen;
          if (uVar4 < ret) {
            format = "bad message length";
            line_00 = 0xdf1;
          }
          else {
            if ((ssl->minor_ver < 1) || (uVar4 <= ret + 0x4100)) goto LAB_2305c902;
            format = "bad message length";
            line_00 = 0xe06;
          }
          goto LAB_2305c86e;
        }
        if (0x3fff < uVar4 - 1) {
          format = "bad message length";
          line_00 = 0xde9;
          goto LAB_2305c86e;
        }
LAB_2305c902:
        if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
          if (line_00 == 0x14) {
            if ((ssl->state - 10U & 0xfffffffd) != 0) {
              format = "dropping unexpected ChangeCipherSpec";
              line_00 = 0xe1c;
              goto LAB_2305c948;
            }
LAB_2305c978:
            if ((((uint)*(ushort *)ssl->in_ctr & 0xff) << 8 | (uint)(*(ushort *)ssl->in_ctr >> 8))
                == (uint)ssl->in_epoch) goto LAB_2305c99c;
            mbedtls_debug_print_msg
                      (ssl,1,"file1",0xe33,"record from another epoch: expected %d, received %d");
          }
          else {
            if ((line_00 != 0x17) || (ssl->state == 0x10)) goto LAB_2305c978;
            format = "dropping unexpected ApplicationData";
            line_00 = 0xe2a;
LAB_2305c948:
            mbedtls_debug_print_msg(ssl,1,"file1",line_00,format);
          }
          line_00 = -0x6700;
          goto LAB_2305c820;
        }
LAB_2305c99c:
        nb_want = mbedtls_ssl_hdr_len();
        line_00 = mbedtls_ssl_fetch_input(ssl,nb_want + uVar4);
        if (line_00 != 0) {
          format = "mbedtls_ssl_fetch_input";
          line = 0xf11;
          goto LAB_2305c75a;
        }
        nb_want = ssl->in_msglen;
        if ((*(ushort *)&ssl->conf->field_0x74 & 2) == 0) {
          ssl->in_left = 0;
        }
        else {
          len = mbedtls_ssl_hdr_len();
          ssl->next_record_offset = len + nb_want;
        }
        len = mbedtls_ssl_hdr_len();
        mbedtls_debug_print_buf
                  (ssl,4,"file1",0xe63,"input record from network",ssl->in_hdr,len + nb_want);
        if (ssl->transform_in == (mbedtls_ssl_transform *)0x0) {
LAB_2305d038:
          if ((*(ushort *)&ssl->conf->field_0x74 & 2) == 0) {
            return 0;
          }
          if (ssl->handshake == (mbedtls_ssl_handshake_params *)0x0) {
            return 0;
          }
          if (ssl->state != 0x10) {
            return 0;
          }
          if ((ssl->in_msgtype != 0x16) || (*ssl->in_msg != '\x14')) {
            ssl_handshake_wrapup_free_hs_transform(ssl);
            return 0;
          }
          mbedtls_debug_print_msg(ssl,2,"file1",0xf6d,"received retransmit of last flight");
          line_00 = mbedtls_ssl_resend(ssl);
          if (line_00 == 0) {
            return -0x6900;
          }
          format = "mbedtls_ssl_resend";
          line = 0xf71;
          goto LAB_2305c75a;
        }
        mbedtls_debug_print_msg(ssl,2,"file1",0x642,"=> decrypt buf");
        if ((ssl->session_in == (mbedtls_ssl_session *)0x0) ||
           (pmVar10 = ssl->transform_in, pmVar10 == (mbedtls_ssl_transform *)0x0)) {
          line_00 = 0x646;
LAB_2305ca46:
          mbedtls_debug_print_msg(ssl,1,"file1",line_00,"should never happen");
          ret = 0xffff9400;
LAB_2305ce16:
          mbedtls_debug_print_ret(ssl,1,"file1",0xe79,"ssl_decrypt_buf",ret);
        }
        else {
          pmVar6 = (pmVar10->cipher_ctx_dec).cipher_info;
          mVar7 = MBEDTLS_MODE_NONE;
          if (pmVar6 != (mbedtls_cipher_info_t *)0x0) {
            mVar7 = pmVar6->mode;
          }
          nb_want = ssl->in_msglen;
          if (nb_want < pmVar10->minlen) {
            format = "in_msglen (%d) < minlen (%d)";
            line_00 = 0x64f;
LAB_2305ca86:
            mbedtls_debug_print_msg(ssl,1,"file1",line_00,format,nb_want);
LAB_2305cbe4:
            ret = 0xffff8e80;
            goto LAB_2305ce16;
          }
          if ((mVar7 + ~MBEDTLS_MODE_CTR & 0xfd) != 0) {
            if (mVar7 == MBEDTLS_MODE_CBC) {
              major_ver = 0;
              ret = pmVar10->ivlen;
              uVar4 = ret;
              if (ssl->minor_ver < 2) {
                uVar4 = 0;
              }
              if ((nb_want < uVar4 + ret) || (nb_want < pmVar10->maclen + 1 + uVar4)) {
                format = "msglen (%d) < max( ivlen(%d), maclen (%d) + 1 ) ( + expl IV )";
                line_00 = 0x6d2;
                goto LAB_2305cacc;
              }
              uVar4 = nb_want % ret;
              if (uVar4 != 0) {
                format = "msglen (%d) %% ivlen (%d) != 0";
                line_00 = 0x70b;
                goto LAB_2305ca86;
              }
              input = ssl->in_msg;
              if (1 < ssl->minor_ver) {
                nb_want = nb_want - ret;
                ssl->in_msglen = nb_want;
                ret = 0;
                while (ret < ssl->transform_in->ivlen) {
                  ssl->transform_in->iv_dec[ret] = ssl->in_iv[ret];
                  ret = ret + 1;
                }
              }
              pmVar10 = ssl->transform_in;
              ret = mbedtls_cipher_crypt
                              (&pmVar10->cipher_ctx_dec,pmVar10->iv_dec,pmVar10->ivlen,input,nb_want
                               ,input,(size_t *)&major_ver);
              if (ret != 0) {
                mbedtls_debug_print_ret(ssl,1,"file1",0x723,"mbedtls_cipher_crypt",ret);
                goto LAB_2305ce16;
              }
              if (nb_want == major_ver) {
                uVar5 = ssl->in_msglen;
                nb_want = ssl->transform_in->maclen;
                uVar13 = (uint)ssl->in_msg[uVar5 - 1] + 1;
                bVar1 = uVar13 + nb_want <= uVar5;
                if (!bVar1) {
                  uVar13 = 0;
                }
                if (0 < ssl->minor_ver) {
                  uVar2 = (uVar5 - 1) - uVar13;
                  uVar12 = ((uint)(uVar5 < uVar13 + 1) ^ 1) & (uint)(uVar2 < nb_want + 0x4000) &
                           (uint)bVar1;
                  uVar14 = 1;
                  uVar3 = 1;
                  do {
                    uVar14 = uVar14 & ((uint)(uVar13 < uVar3) ^ 1);
                    line_00 = uVar2 * uVar12 + uVar3;
                    uVar3 = uVar3 + 1;
                    uVar4 = uVar4 + ((uint)ssl->in_msg[line_00] == uVar13 - 1) * uVar14;
                  } while (uVar3 != 0x101);
                  uVar12 = uVar13 == uVar4 & uVar12;
                  uVar13 = uVar12 * 0x1ff & uVar13;
                  ssl->in_msglen = uVar5 - uVar13;
                  goto LAB_2305cc06;
                }
                line_00 = 0x783;
              }
              else {
                line_00 = 0x729;
              }
            }
            else {
              line_00 = 0x78d;
            }
            goto LAB_2305ca46;
          }
          len = 8;
          if ((pmVar10->ciphersuite_info->flags & 2) == 0) {
            len = 0x10;
          }
          if (nb_want < (pmVar10->ivlen - pmVar10->fixed_ivlen) + len) {
            format = "msglen (%d) < explicit_iv_len (%d) + taglen (%d)";
            line_00 = 0x67f;
LAB_2305cacc:
            mbedtls_debug_print_msg(ssl,1,"file1",line_00,format,nb_want);
            goto LAB_2305cbe4;
          }
          nb_want = ((nb_want + pmVar10->fixed_ivlen) - pmVar10->ivlen) - len;
          ssl->in_msglen = nb_want;
          input = ssl->in_msg;
          memcpy(&major_ver,ssl->in_ctr,8);
          mbedtls_ssl_write_version
                    (ssl->major_ver,ssl->minor_ver,*(uint *)&ssl->conf->field_0x74 >> 1 & 1,
                     auStack103);
          uStack101 = (undefined)(ssl->in_msglen >> 8);
          uStack100 = (undefined)ssl->in_msglen;
          mbedtls_debug_print_buf
                    (ssl,4,"file1",0x690,"additional data used for AEAD",(uchar *)&major_ver,0xd);
          pmVar10 = ssl->transform_in;
          memcpy(pmVar10->iv_dec + pmVar10->fixed_ivlen,ssl->in_iv,
                 pmVar10->ivlen - pmVar10->fixed_ivlen);
          mbedtls_debug_print_buf
                    (ssl,4,"file1",0x697,"IV used",ssl->transform_in->iv_dec,
                     ssl->transform_in->ivlen);
          mbedtls_debug_print_buf(ssl,4,"file1",0x698,"TAG used",input + nb_want,len);
          pmVar10 = ssl->transform_in;
          ret = mbedtls_cipher_auth_decrypt
                          (&pmVar10->cipher_ctx_dec,pmVar10->iv_dec,pmVar10->ivlen,
                           (uchar *)&major_ver,0xd,input,nb_want,input,in_fa0,in_fa1,in_fa2);
          if (ret != 0) {
            mbedtls_debug_print_ret(ssl,1,"file1",0x6a5,"mbedtls_cipher_auth_decrypt",ret);
            if (ret == 0xffff9d00) goto LAB_2305cbe4;
            goto LAB_2305ce16;
          }
          if (nb_want != sStack116) {
            line_00 = 0x6b0;
            goto LAB_2305ca46;
          }
          uVar12 = 1;
          uVar13 = 0;
          ret = 1;
LAB_2305cc06:
          mbedtls_debug_print_buf
                    (ssl,4,"file1",0x792,"raw buffer after decryption",ssl->in_msg,ssl->in_msglen);
          if (ret == 0) {
            nb_want = ssl->in_msglen - ssl->transform_in->maclen;
            ssl->in_msglen = nb_want;
            *ssl->in_len = (uchar)(nb_want >> 8);
            ssl->in_len[1] = (uchar)ssl->in_msglen;
            memcpy(&major_ver,ssl->in_msg + ssl->in_msglen,ssl->transform_in->maclen);
            if (ssl->minor_ver < 1) {
              line_00 = 0x7d6;
              goto LAB_2305ca46;
            }
            uVar4 = ssl->in_msglen + 0x15;
            mbedtls_md_hmac_update(&ssl->transform_in->md_ctx_dec,ssl->in_ctr,8);
            mbedtls_md_hmac_update(&ssl->transform_in->md_ctx_dec,ssl->in_hdr,3);
            mbedtls_md_hmac_update(&ssl->transform_in->md_ctx_dec,ssl->in_len,2);
            mbedtls_md_hmac_update(&ssl->transform_in->md_ctx_dec,ssl->in_msg,ssl->in_msglen);
            mbedtls_md_hmac_finish(&ssl->transform_in->md_ctx_dec,ssl->in_msg + ssl->in_msglen);
            ret = 0;
            do {
              mbedtls_md_process(&ssl->transform_in->md_ctx_dec,ssl->in_msg);
              ret = ret + 1;
            } while (ret < (uVar12 * 0xff & (uVar13 + uVar4 >> 6) - (uVar4 >> 6)) + 1);
            mbedtls_md_hmac_reset(&ssl->transform_in->md_ctx_dec);
            mbedtls_debug_print_buf
                      (ssl,4,"file1",0x7da,"message  mac",(uchar *)&major_ver,
                       ssl->transform_in->maclen);
            mbedtls_debug_print_buf
                      (ssl,4,"file1",0x7dc,"computed mac",ssl->in_msg + ssl->in_msglen,
                       ssl->transform_in->maclen);
            bVar8 = 0;
            nb_want = 0;
            while (ssl->transform_in->maclen != nb_want) {
              line_00 = ssl->in_msglen + nb_want;
              pbVar11 = (byte *)((int)&major_ver + nb_want);
              nb_want = nb_want + 1;
              bVar8 = bVar8 | ssl->in_msg[line_00] ^ *pbVar11;
            }
            if ((bVar8 != 0) || (uVar12 == 0)) goto LAB_2305cbe4;
          }
          if (ssl->in_msglen == 0) {
            line_00 = ssl->nb_zero + 1;
            ssl->nb_zero = line_00;
            if (3 < line_00) {
              mbedtls_debug_print_msg
                        (ssl,1,"file1",0x802,
                         "received four consecutive empty messages, possible DoS attack");
              goto LAB_2305cbe4;
            }
          }
          else {
            ssl->nb_zero = 0;
          }
          uVar4 = 8;
          if ((*(ushort *)&ssl->conf->field_0x74 & 2) == 0) {
            do {
              ret = uVar4;
              if (ret <= ((uint)*(ushort *)&ssl->conf->field_0x74 & 2)) break;
              uVar9 = ssl->in_ctr[ret - 1] + '\x01';
              ssl->in_ctr[ret - 1] = uVar9;
              uVar4 = ret - 1;
            } while (uVar9 == '\0');
            if (ret == ((uint)*(ushort *)&ssl->conf->field_0x74 & 2)) {
              mbedtls_debug_print_msg(ssl,1,"file1",0x818,"incoming message counter would wrap");
              ret = 0xffff9480;
              goto LAB_2305ce16;
            }
          }
          mbedtls_debug_print_msg(ssl,2,"file1",0x81d,"<= decrypt buf");
          mbedtls_debug_print_buf
                    (ssl,4,"file1",0xe7e,"input payload after decrypt",ssl->in_msg,ssl->in_msglen);
          if (ssl->in_msglen < 0x4001) goto LAB_2305d038;
          mbedtls_debug_print_msg(ssl,1,"file1",0xe82,"bad message length");
          ret = 0xffff8e00;
        }
        if ((*(ushort *)&ssl->conf->field_0x74 & 2) == 0) {
          return ret;
        }
        if ((ret & 0xffffff7f) != 0xffff8e00) {
          return ret;
        }
        if ((ssl->state - 0xbU & 0xfffffffd) == 0) {
          return ret;
        }
        format = "discarding invalid record (mac)";
        line_00 = 0xf40;
      }
      else {
        mbedtls_debug_print_msg(ssl,1,"file1",0xdc2,"unknown record type");
        line_00 = mbedtls_ssl_send_alert_message(ssl,'\x02','\n');
        if (line_00 == 0) {
LAB_2305c81a:
          line_00 = -0x7200;
        }
LAB_2305c820:
        if ((*(ushort *)&ssl->conf->field_0x74 & 2) == 0) {
          return line_00;
        }
        if (line_00 == -0x6780) {
          return -0x6780;
        }
        if (line_00 == -0x6700) {
          nb_want = mbedtls_ssl_hdr_len();
          format = "discarding unexpected record (header)";
          ssl->next_record_offset = nb_want + ssl->in_msglen;
          line_00 = 0xef8;
        }
        else {
          ssl->next_record_offset = 0;
          ssl->in_left = 0;
          format = "discarding invalid record (header)";
          line_00 = 0xf01;
        }
      }
      mbedtls_debug_print_msg(ssl,1,"file1",line_00,format);
    }
    format = "mbedtls_ssl_fetch_input";
    line = 0xee7;
LAB_2305c75a:
    mbedtls_debug_print_ret(ssl,1,"file1",line,format,line_00);
  }
  else {
    __n = ssl->in_msglen - uVar4;
    ssl->in_msglen = __n;
    line_00 = 0;
    memmove(ssl->in_msg,ssl->in_msg + uVar4,__n);
    mbedtls_debug_print_buf
              (ssl,4,"file1",0xed7,"remaining content in record",ssl->in_msg,ssl->in_msglen);
  }
  return line_00;
}



int mbedtls_ssl_read_record(mbedtls_ssl_context *ssl)

{
  int ret;
  int line;
  char *text;
  
  mbedtls_debug_print_msg(ssl,2,"file1",0xeaa,"=> read record");
  do {
    ret = mbedtls_ssl_read_record_layer(ssl);
    if (ret != 0) {
      text = "mbedtls_ssl_read_record_layer";
      line = 0xeb0;
      goto LAB_2305d0fa;
    }
    ret = mbedtls_ssl_handle_message_type(ssl);
  } while (ret == -0x6680);
  if (ret == 0) {
    if (ssl->in_msgtype == 0x16) {
      mbedtls_ssl_update_handshake_status(ssl);
    }
    mbedtls_debug_print_msg(ssl,2,"file1",0xec3,"<= read record");
  }
  else {
    text = "mbedtls_ssl_handle_message_type";
    line = 0xeba;
LAB_2305d0fa:
    mbedtls_debug_print_ret(ssl,1,"file1",line,text,ret);
  }
  return ret;
}



int mbedtls_ssl_parse_certificate(mbedtls_ssl_context *ssl)

{
  mbedtls_key_exchange_type_t mVar1;
  ushort uVar2;
  uint uVar3;
  mbedtls_ssl_session *pmVar4;
  mbedtls_x509_crt *crt;
  mbedtls_x509_crl *ca_crl;
  int ret;
  int line;
  mbedtls_ssl_config *pmVar5;
  char *text;
  uchar *puVar6;
  uint uVar7;
  mbedtls_ssl_ciphersuite_t *ciphersuite;
  
  ciphersuite = ssl->transform_negotiate->ciphersuite_info;
  uVar3 = *(uint *)&ssl->conf->field_0x74;
  mbedtls_debug_print_msg(ssl,2,"file1",0x1099,"=> parse certificate");
  mVar1 = ciphersuite->key_exchange;
  uVar7 = (uint)mVar1 - 5;
  if (((uVar7 & 0xff) < 7) && ((0x4bU >> (uVar7 & 0x1f) & 1) != 0)) {
    ret = 0x10a0;
LAB_2305d1d0:
    mbedtls_debug_print_msg(ssl,2,"file1",ret,"<= skip parse certificate");
    ssl->state = ssl->state + 1;
    return 0;
  }
  uVar2 = *(ushort *)&ssl->conf->field_0x74;
  if (((uVar2 & 1) != 0) && (mVar1 == MBEDTLS_KEY_EXCHANGE_RSA_PSK)) {
    ret = 0x10a9;
    goto LAB_2305d1d0;
  }
  uVar7 = ssl->handshake->sni_authmode;
  if (uVar7 == 3) {
    uVar7 = uVar3 >> 2 & 3;
  }
  if (((uVar2 & 1) != 0) && (uVar7 == 0)) {
    ssl->session_negotiate->verify_result = 0x80;
    ret = 0x10b7;
    goto LAB_2305d1d0;
  }
  ret = mbedtls_ssl_read_record(ssl);
  if (ret != 0) {
    text = "mbedtls_ssl_read_record";
    line = 0x10bf;
    goto LAB_2305d262;
  }
  ssl->state = ssl->state + 1;
  uVar2 = *(ushort *)&ssl->conf->field_0x74;
  if (((uVar2 & 1) == 0) || (ssl->minor_ver == 0)) {
LAB_2305d314:
    if (ssl->in_msgtype != 0x16) {
LAB_2305d2a2:
      mbedtls_debug_print_msg(ssl,1,"file1",0x10f6,"bad certificate message");
      return -0x7700;
    }
  }
  else {
    ret = 4;
    if ((uVar2 & 2) != 0) {
      ret = 0xc;
    }
    if (ssl->in_hslen != ret + 3U) goto LAB_2305d314;
    if (ssl->in_msgtype != 0x16) goto LAB_2305d2a2;
    if (*ssl->in_msg == '\v') {
      ret = memcmp(ssl->in_msg + ret,&DAT_23088e44,3);
      if (ret == 0) {
        mbedtls_debug_print_msg(ssl,1,"file1",0x10e7,"TLSv1 client has no certificate");
        ssl->session_negotiate->verify_result = 0x40;
        if (uVar7 == 1) {
          return 0;
        }
        return -0x7480;
      }
      goto LAB_2305d314;
    }
  }
  if (*ssl->in_msg == '\v') {
    ret = 4;
    if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
      ret = 0xc;
    }
    if (ret + 6U <= ssl->in_hslen) {
      puVar6 = ssl->in_msg + ret;
      if ((*puVar6 == '\0') &&
         (uVar3 = ret + 3, ssl->in_hslen == CONCAT11(puVar6[1],puVar6[2]) + uVar3)) {
        crt = ssl->session_negotiate->peer_cert;
        if (crt != (mbedtls_x509_crt *)0x0) {
          mbedtls_x509_crt_free(crt);
          vPortFree(ssl->session_negotiate->peer_cert);
        }
        pmVar4 = ssl->session_negotiate;
        crt = (mbedtls_x509_crt *)mycalloc(1,0x134);
        pmVar4->peer_cert = crt;
        if (crt == (mbedtls_x509_crt *)0x0) {
          mbedtls_debug_print_msg(ssl,1,"file1",0x111a,"alloc(%d bytes) failed",0x134);
          return -0x7f00;
        }
        ret = 0;
        mbedtls_x509_crt_init(ssl->session_negotiate->peer_cert);
        do {
          if (ssl->in_hslen <= uVar3) {
            mbedtls_debug_print_crt
                      (ssl,3,"file1",0x113f,"peer certificate",ssl->session_negotiate->peer_cert);
            if (uVar7 != 0) {
              pmVar5 = ssl->conf;
              crt = ssl->handshake->sni_ca_chain;
              if (crt == (mbedtls_x509_crt *)0x0) {
                crt = pmVar5->ca_chain;
                ca_crl = pmVar5->ca_crl;
                if (crt == (mbedtls_x509_crt *)0x0) {
                  mbedtls_debug_print_msg(ssl,1,"file1",0x116f,"got no CA chain");
                  return -0x7680;
                }
              }
              else {
                ca_crl = ssl->handshake->sni_ca_crl;
              }
              ret = mbedtls_x509_crt_verify_with_profile
                              (ssl->session_negotiate->peer_cert,crt,ca_crl,pmVar5->cert_profile,
                               ssl->hostname,&ssl->session_negotiate->verify_result,
                               (anon_subr_int_void_ptr_mbedtls_x509_crt_ptr_int_uint32_t_ptr *)
                               pmVar5->f_vrfy,pmVar5->p_vrfy);
              if (ret != 0) {
                mbedtls_debug_print_ret(ssl,1,"file1",0x1180,"x509_verify_cert",ret);
              }
              crt = ssl->session_negotiate->peer_cert;
              line = mbedtls_pk_can_do(&crt->pk,MBEDTLS_PK_ECKEY);
              if (((line != 0) &&
                  (line = mbedtls_ssl_check_curve(ssl,*(mbedtls_ecp_group_id *)(crt->pk).pk_ctx),
                  line != 0)) &&
                 (mbedtls_debug_print_msg(ssl,1,"file1",0x118f,"bad certificate (EC key curve)"),
                 ret == 0)) {
                ret = -0x7a00;
              }
              line = mbedtls_ssl_check_cert_usage
                               (ssl->session_negotiate->peer_cert,ciphersuite,
                                ~(uint)*(ushort *)&ssl->conf->field_0x74 & 1,
                                &ssl->session_negotiate->verify_result);
              if ((line != 0) &&
                 (mbedtls_debug_print_msg(ssl,1,"file1",0x119b,"bad certificate (usage extensions)")
                 , ret == 0)) {
                ret = -0x7a00;
              }
              if (uVar7 == 1) {
                ret = 0;
              }
            }
            mbedtls_debug_print_msg(ssl,2,"file1",0x11a4,"<= parse certificate");
            return ret;
          }
          puVar6 = ssl->in_msg + uVar3;
          if (*puVar6 != '\0') {
            ret = 0x1126;
            goto LAB_2305d350;
          }
          uVar2 = CONCAT11(puVar6[1],puVar6[2]);
          ret = uVar3 + 3;
          if ((uVar2 < 0x80) || (uVar3 = (uint)uVar2 + ret, ssl->in_hslen < uVar3)) {
            ret = 0x1130;
            goto LAB_2305d350;
          }
          ret = mbedtls_x509_crt_parse_der
                          (ssl->session_negotiate->peer_cert,ssl->in_msg + ret,(uint)uVar2);
        } while ((ret == 0) || (ret == -0x262e));
        text = " mbedtls_x509_crt_parse_der";
        line = 0x1138;
LAB_2305d262:
        mbedtls_debug_print_ret(ssl,1,"file1",line,text,ret);
        return ret;
      }
      ret = 0x110b;
      goto LAB_2305d350;
    }
  }
  ret = 0x10fd;
LAB_2305d350:
  mbedtls_debug_print_msg(ssl,1,"file1",ret,"bad certificate message");
  return -0x7a00;
}



int mbedtls_ssl_parse_change_cipher_spec(mbedtls_ssl_context *ssl)

{
  int ret;
  uint uVar1;
  uchar *puVar2;
  
  mbedtls_debug_print_msg(ssl,2,"file1",0x11cb,"=> parse change cipher spec");
  ret = mbedtls_ssl_read_record(ssl);
  if (ret == 0) {
    if (ssl->in_msgtype == 0x14) {
      if ((ssl->in_msglen == 1) && (*ssl->in_msg == '\x01')) {
        mbedtls_debug_print_msg
                  (ssl,3,"file1",0x11e3,"switching to new transform spec for inbound data");
        ssl->transform_in = ssl->transform_negotiate;
        ssl->session_in = ssl->session_negotiate;
        if ((*(ushort *)&ssl->conf->field_0x74 & 2) == 0) {
          memset(ssl->in_ctr,0,8);
        }
        else {
          uVar1 = (uint)ssl->in_epoch + 1;
          ssl->in_epoch = (uint16_t)(uVar1 * 0x10000 >> 0x10);
          if ((uVar1 & 0xffff) == 0) {
            mbedtls_debug_print_msg(ssl,1,"file1",0x11f1,"DTLS epoch would wrap");
            return -0x6b80;
          }
        }
        puVar2 = ssl->in_iv;
        if (1 < ssl->minor_ver) {
          puVar2 = puVar2 + (ssl->transform_negotiate->ivlen - ssl->transform_negotiate->fixed_ivlen
                            );
        }
        ssl->in_msg = puVar2;
        ssl->state = ssl->state + 1;
        mbedtls_debug_print_msg(ssl,2,"file1",0x1211,"<= parse change cipher spec");
      }
      else {
        mbedtls_debug_print_msg(ssl,1,"file1",0x11db,"bad change cipher spec message");
        ret = -0x7e00;
      }
    }
    else {
      mbedtls_debug_print_msg(ssl,1,"file1",0x11d5,"bad change cipher spec message");
      ret = -0x7700;
    }
  }
  else {
    mbedtls_debug_print_ret(ssl,1,"file1",0x11cf,"mbedtls_ssl_read_record",ret);
  }
  return ret;
}



int mbedtls_ssl_parse_finished(mbedtls_ssl_context *ssl)

{
  byte *pbVar1;
  int line;
  int iVar2;
  byte bVar3;
  mbedtls_ssl_config *pmVar4;
  int iVar5;
  byte local_2c [4];
  uchar buf [12];
  
  mbedtls_debug_print_msg(ssl,2,"file1",0x1486,"=> parse finished");
  (*ssl->handshake->calc_finished)(ssl,local_2c,*(uint *)&ssl->conf->field_0x74 & 1 ^ 1);
  line = mbedtls_ssl_read_record(ssl);
  if (line != 0) {
    mbedtls_debug_print_ret(ssl,1,"file1",0x148c,"mbedtls_ssl_read_record",line);
    return line;
  }
  if (ssl->in_msgtype != 0x16) {
    mbedtls_debug_print_msg(ssl,1,"file1",0x1492,"bad finished message");
    return -0x7700;
  }
  if (*ssl->in_msg == '\x14') {
    pmVar4 = ssl->conf;
    line = 4;
    if ((*(ushort *)&pmVar4->field_0x74 & 2) != 0) {
      line = 0xc;
    }
    bVar3 = 0;
    iVar5 = 0;
    if (ssl->in_hslen == line + 0xcU) {
      do {
        iVar2 = line + iVar5;
        pbVar1 = local_2c + iVar5;
        iVar5 = iVar5 + 1;
        bVar3 = bVar3 | ssl->in_msg[iVar2] ^ *pbVar1;
      } while (iVar5 != 0xc);
      if (bVar3 == 0) {
        if (ssl->handshake->resume == 0) {
          line = ssl->state + 1;
        }
        else {
          if (((*(ushort *)&pmVar4->field_0x74 & 1) == 0) &&
             (ssl->state = 10, (*(ushort *)&pmVar4->field_0x74 & 1) == 0)) goto LAB_2305d838;
          line = 0xf;
        }
        ssl->state = line;
LAB_2305d838:
        if ((*(ushort *)&pmVar4->field_0x74 & 2) != 0) {
          mbedtls_ssl_recv_flight_completed(ssl);
        }
        mbedtls_debug_print_msg(ssl,2,"file1",0x14c4,"<= parse finished");
        return 0;
      }
      line = 0x14a8;
      goto LAB_2305d7d4;
    }
  }
  line = 0x14a1;
LAB_2305d7d4:
  mbedtls_debug_print_msg(ssl,1,"file1",line,"bad finished message");
  return -0x7e80;
}



int mbedtls_ssl_read(mbedtls_ssl_context *ssl,uchar *buf,size_t len)

{
  bool bVar1;
  uint __n;
  int ret;
  int line;
  char *text;
  size_t sVar2;
  uchar *puVar3;
  
  if ((ssl == (mbedtls_ssl_context *)0x0) || (ssl->conf == (mbedtls_ssl_config *)0x0)) {
    return -0x7100;
  }
  mbedtls_debug_print_msg(ssl,2,"file1",0x19e0,"=> read");
  if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
    ret = mbedtls_ssl_flush_output(ssl);
    if (ret != 0) {
      return ret;
    }
    if (((ssl->handshake != (mbedtls_ssl_handshake_params *)0x0) &&
        (ssl->handshake->retransmit_state == '\x01')) && (ret = mbedtls_ssl_resend(ssl), ret != 0))
    {
      return ret;
    }
  }
  if (ssl->state == 0x10) {
LAB_2305d91a:
    bVar1 = false;
  }
  else {
    ret = mbedtls_ssl_handshake(ssl);
    if (ret != -0x6b00) {
      if (ret != 0) {
        text = "mbedtls_ssl_handshake";
        line = 0x1a02;
        goto LAB_2305d8d8;
      }
      goto LAB_2305d91a;
    }
    bVar1 = true;
  }
  if (ssl->in_offt != (uchar *)0x0) {
LAB_2305da00:
    __n = ssl->in_msglen;
    if (len < ssl->in_msglen) {
      __n = len;
    }
    memcpy(buf,ssl->in_offt,__n);
    puVar3 = (uchar *)0x0;
    sVar2 = ssl->in_msglen - __n;
    ssl->in_msglen = sVar2;
    if (sVar2 != 0) {
      puVar3 = ssl->in_offt + __n;
    }
    ssl->in_offt = puVar3;
    mbedtls_debug_print_msg(ssl,2,"file1",0x1ad0,"<= read");
    return __n;
  }
  if ((ssl->f_get_timer != (mbedtls_ssl_get_timer_t *)0x0) &&
     (ret = (*ssl->f_get_timer)(ssl->p_timer), ret == -1)) {
    ssl_set_timer(ssl,ssl->conf->read_timeout);
  }
  if ((bVar1) || (ret = mbedtls_ssl_read_record(ssl), ret == 0)) {
    if ((ssl->in_msglen != 0) ||
       ((ssl->in_msgtype != 0x17 || (ret = mbedtls_ssl_read_record(ssl), ret == 0)))) {
      if (ssl->in_msgtype == 0x15) {
        mbedtls_debug_print_msg(ssl,2,"file1",0x1aa0,"ignoring non-fatal non-closure alert");
        return -0x6900;
      }
      if (ssl->in_msgtype != 0x17) {
        mbedtls_debug_print_msg(ssl,1,"file1",0x1aa6,"bad application data message");
        return -0x7700;
      }
      ssl->in_offt = ssl->in_msg;
      if (ssl->state == 0x10) {
        ssl_set_timer(ssl,0);
      }
      goto LAB_2305da00;
    }
    if (ret == -0x7280) {
      return 0;
    }
    text = "mbedtls_ssl_read_record";
    line = 0x1a27;
  }
  else {
    if (ret == -0x7280) {
      return 0;
    }
    text = "mbedtls_ssl_read_record";
    line = 0x1a17;
  }
LAB_2305d8d8:
  mbedtls_debug_print_ret(ssl,1,"file1",line,text,ret);
  return ret;
}



int mbedtls_ssl_set_calc_verify_md(mbedtls_ssl_context *ssl,int md)

{
  if ((ssl->minor_ver == 3) && (md == 4)) {
    ssl->handshake->calc_verify = ssl_calc_verify_tls_sha256;
    return 0;
  }
  return -0x6600;
}



void mbedtls_zeroize(void *v,size_t n)

{
  undefined *puVar1;
  
  puVar1 = (undefined *)(n + (int)v);
  while ((undefined *)v != puVar1) {
    *(undefined *)v = 0;
    v = (undefined *)v + 1;
  }
  return;
}



int x509_memcasecmp(void *s1,void *s2,size_t len)

{
  byte bVar1;
  size_t sVar2;
  
  sVar2 = 0;
  while( true ) {
    if (sVar2 == len) {
      return 0;
    }
    bVar1 = *(byte *)((int)s1 + sVar2);
    if ((bVar1 != *(byte *)((int)s2 + sVar2)) &&
       (((bVar1 ^ *(byte *)((int)s2 + sVar2)) != 0x20 || (0x19 < (byte)((bVar1 & 0xdf) + 0xbf)))))
    break;
    sVar2 = sVar2 + 1;
  }
  return -1;
}



int x509_name_cmp(mbedtls_x509_name *a,mbedtls_x509_name *b)

{
  int iVar1;
  size_t __n;
  size_t len;
  
  while( true ) {
    if (a == (mbedtls_x509_name *)0x0) {
      return -(uint)(b != (mbedtls_x509_name *)0x0);
    }
    if ((((((b == (mbedtls_x509_name *)0x0) || ((a->oid).tag != (b->oid).tag)) ||
          (__n = (a->oid).len, __n != (b->oid).len)) ||
         (iVar1 = memcmp((a->oid).p,(b->oid).p,__n), iVar1 != 0)) ||
        (((((a->val).tag != (b->val).tag || (__n = (a->val).len, __n != (b->val).len)) ||
          (iVar1 = memcmp((a->val).p,(b->val).p,__n), iVar1 != 0)) &&
         (((iVar1 = (a->val).tag, iVar1 != 0xc && (iVar1 != 0x13)) ||
          (((iVar1 = (b->val).tag, iVar1 != 0xc && (iVar1 != 0x13)) ||
           ((len = (a->val).len, len != (b->val).len ||
            (iVar1 = x509_memcasecmp((a->val).p,(b->val).p,len), iVar1 != 0)))))))))) ||
       (a->next_merged != b->next_merged)) break;
    a = (mbedtls_x509_name *)a->next;
    b = (mbedtls_x509_name *)b->next;
  }
  return -1;
}



int x509_check_wildcard(char *cn,mbedtls_x509_buf *name)

{
  size_t sVar1;
  size_t sVar2;
  uchar *puVar3;
  int iVar4;
  
  sVar1 = strlen(cn);
  if (name->len < 3) {
    iVar4 = 0;
  }
  else {
    puVar3 = name->p;
    iVar4 = 0;
    if ((*puVar3 == '*') && (puVar3[1] == '.')) {
      sVar2 = 0;
      while (sVar2 != sVar1) {
        if (cn[sVar2] == '.') {
          if (sVar2 == 0) {
            return -1;
          }
          if (sVar1 - sVar2 != name->len - 1) {
            return -1;
          }
          iVar4 = x509_memcasecmp(puVar3 + 1,cn + sVar2,sVar1 - sVar2);
          return -(uint)(iVar4 != 0);
        }
        sVar2 = sVar2 + 1;
      }
      iVar4 = -1;
    }
  }
  return iVar4;
}



int x509_profile_check_key
              (mbedtls_x509_crt_profile *profile,mbedtls_pk_type_t pk_alg,mbedtls_pk_context *pk)

{
  bool bVar1;
  size_t sVar2;
  undefined3 in_register_0000202d;
  int iVar3;
  
  iVar3 = CONCAT31(in_register_0000202d,pk_alg);
  if ((iVar3 == 1) || (iVar3 == 6)) {
    sVar2 = mbedtls_pk_get_bitlen(pk);
    bVar1 = sVar2 < profile->rsa_min_bitlen;
  }
  else {
    if (2 < (iVar3 - 2U & 0xff)) {
      return -1;
    }
    bVar1 = (1 << ((uint)*(byte *)pk->pk_ctx - 1 & 0x1f) & profile->allowed_curves) == 0;
  }
  return -(uint)bVar1;
}



// WARNING: Variable defined which should be unmapped: key_size_str

int mbedtls_x509_crt_info(char *buf,size_t size,char *prefix,mbedtls_x509_crt *crt)

{
  byte bVar1;
  uint __maxlen;
  uchar *__s;
  uint uVar2;
  char *name;
  int iVar3;
  size_t sVar4;
  uint uVar5;
  uchar *puVar6;
  undefined *puVar7;
  uchar *puVar8;
  int iVar9;
  mbedtls_x509_sequence *oid;
  char *pcStack56;
  char *desc;
  char key_size_str [18];
  
  if (crt == (mbedtls_x509_crt *)0x0) {
    uVar2 = snprintf(buf,size,"\nCertificate is uninitialised!\n");
    if ((-1 < (int)uVar2) && (uVar2 < size)) {
      return uVar2;
    }
  }
  else {
    uVar2 = snprintf(buf,size,"%scert. version     : %d\r\n",prefix,crt->version);
    if ((-1 < (int)uVar2) && (uVar2 < size)) {
      __maxlen = size - uVar2;
      buf = buf + uVar2;
      uVar2 = snprintf(buf,__maxlen,"%sserial number     : ",prefix);
      if ((-1 < (int)uVar2) && (uVar2 < __maxlen)) {
        __maxlen = __maxlen - uVar2;
        buf = buf + uVar2;
        uVar2 = mbedtls_x509_serial_gets(buf,__maxlen,&crt->serial);
        if ((-1 < (int)uVar2) && (uVar2 < __maxlen)) {
          __maxlen = __maxlen - uVar2;
          buf = buf + uVar2;
          uVar2 = snprintf(buf,__maxlen,"\r\n%sissuer name       : ",prefix);
          if ((-1 < (int)uVar2) && (uVar2 < __maxlen)) {
            __maxlen = __maxlen - uVar2;
            buf = buf + uVar2;
            uVar2 = mbedtls_x509_dn_gets(buf,__maxlen,&crt->issuer);
            if ((-1 < (int)uVar2) && (uVar2 < __maxlen)) {
              __maxlen = __maxlen - uVar2;
              buf = buf + uVar2;
              uVar2 = snprintf(buf,__maxlen,"\r\n%ssubject name      : ",prefix);
              if ((-1 < (int)uVar2) && (uVar2 < __maxlen)) {
                __maxlen = __maxlen - uVar2;
                buf = buf + uVar2;
                uVar2 = mbedtls_x509_dn_gets(buf,__maxlen,&crt->subject);
                if ((-1 < (int)uVar2) && (uVar2 < __maxlen)) {
                  __maxlen = __maxlen - uVar2;
                  buf = buf + uVar2;
                  uVar2 = snprintf(buf,__maxlen,
                                   "\r\n%sissued  on        : %04d-%02d-%02d %02d:%02d:%02d",prefix,
                                   (crt->valid_from).year,(crt->valid_from).mon,
                                   (crt->valid_from).day,(crt->valid_from).hour);
                  if ((-1 < (int)uVar2) && (uVar2 < __maxlen)) {
                    __maxlen = __maxlen - uVar2;
                    buf = buf + uVar2;
                    uVar2 = snprintf(buf,__maxlen,
                                     "\r\n%sexpires on        : %04d-%02d-%02d %02d:%02d:%02d",
                                     prefix,(crt->valid_to).year,(crt->valid_to).mon,
                                     (crt->valid_to).day,(crt->valid_to).hour);
                    if ((-1 < (int)uVar2) && (uVar2 < __maxlen)) {
                      __maxlen = __maxlen - uVar2;
                      buf = buf + uVar2;
                      uVar2 = snprintf(buf,__maxlen,"\r\n%ssigned using      : ",prefix);
                      if ((-1 < (int)uVar2) && (uVar2 < __maxlen)) {
                        __maxlen = __maxlen - uVar2;
                        buf = buf + uVar2;
                        uVar2 = mbedtls_x509_sig_alg_gets
                                          (buf,__maxlen,&crt->sig_oid,crt->sig_pk,crt->sig_md,
                                           crt->sig_opts);
                        if ((-1 < (int)uVar2) && (uVar2 < __maxlen)) {
                          name = mbedtls_pk_get_name(&crt->pk);
                          iVar3 = mbedtls_x509_key_size_helper((char *)&desc,0x12,name);
                          if (iVar3 != 0) {
                            return iVar3;
                          }
                          sVar4 = mbedtls_pk_get_bitlen(&crt->pk);
                          __maxlen = __maxlen - uVar2;
                          uVar5 = snprintf(buf + uVar2,__maxlen,"\r\n%s%-18s: %d bits",prefix,&desc,
                                           sVar4);
                          if ((-1 < (int)uVar5) && (uVar5 < __maxlen)) {
                            __maxlen = __maxlen - uVar5;
                            __s = (uchar *)(buf + uVar2 + uVar5);
                            if ((crt->ext_types & 0x100U) != 0) {
                              if (crt->ca_istrue == 0) {
                                name = "false";
                              }
                              else {
                                name = "true";
                              }
                              uVar2 = snprintf((char *)__s,__maxlen,
                                               "\r\n%sbasic constraints : CA=%s",prefix,name);
                              if ((int)uVar2 < 0) {
                                return -0x2980;
                              }
                              if (__maxlen <= uVar2) {
                                return -0x2980;
                              }
                              __maxlen = __maxlen - uVar2;
                              __s = __s + uVar2;
                              if (0 < crt->max_pathlen) {
                                uVar2 = snprintf((char *)__s,__maxlen,", max_pathlen=%d",
                                                 crt->max_pathlen + -1);
                                if ((int)uVar2 < 0) {
                                  return -0x2980;
                                }
                                if (__maxlen <= uVar2) {
                                  return -0x2980;
                                }
                                __maxlen = __maxlen - uVar2;
                                __s = __s + uVar2;
                              }
                            }
                            if ((crt->ext_types & 0x20U) != 0) {
                              uVar2 = snprintf((char *)__s,__maxlen,"\r\n%ssubject alt name  : ",
                                               prefix);
                              if ((int)uVar2 < 0) {
                                return -0x2980;
                              }
                              if (__maxlen <= uVar2) {
                                return -0x2980;
                              }
                              __maxlen = __maxlen - uVar2;
                              __s = __s + uVar2;
                              oid = &crt->subject_alt_names;
                              iVar3 = 0;
                              puVar7 = &DAT_23088e60;
                              do {
                                uVar2 = (oid->buf).len + iVar3;
                                if (__maxlen <= uVar2) {
                                  *__s = '\0';
                                  return -0x2980;
                                }
                                __maxlen = __maxlen - uVar2;
                                iVar9 = 0;
                                while (puVar6 = __s + iVar9, iVar9 != iVar3) {
                                  puVar8 = puVar7 + iVar9;
                                  iVar9 = iVar9 + 1;
                                  *puVar6 = *puVar8;
                                }
                                uVar2 = 0;
                                while (__s = puVar6 + uVar2, uVar2 < (oid->buf).len) {
                                  puVar8 = (oid->buf).p + uVar2;
                                  uVar2 = uVar2 + 1;
                                  *__s = *puVar8;
                                }
                                oid = (mbedtls_x509_sequence *)oid->next;
                                iVar3 = 2;
                                puVar7 = &DAT_23080648;
                              } while (oid != (mbedtls_x509_sequence *)0x0);
                              *__s = '\0';
                            }
                            if (crt->ext_types << 0xf < 0) {
                              uVar2 = snprintf((char *)__s,__maxlen,"\r\n%scert. type        : ",
                                               prefix);
                              if ((int)uVar2 < 0) {
                                return -0x2980;
                              }
                              if (__maxlen <= uVar2) {
                                return -0x2980;
                              }
                              bVar1 = crt->ns_cert_type;
                              __maxlen = __maxlen - uVar2;
                              __s = __s + uVar2;
                              puVar7 = &DAT_23088e60;
                              if ((char)bVar1 < '\0') {
                                uVar2 = snprintf((char *)__s,__maxlen,"%sSSL Client",&DAT_23088e60);
                                if ((int)uVar2 < 0) {
                                  return -0x2980;
                                }
                                if (__maxlen <= uVar2) {
                                  return -0x2980;
                                }
                                __maxlen = __maxlen - uVar2;
                                __s = __s + uVar2;
                                puVar7 = &DAT_23080648;
                              }
                              if ((bVar1 & 0x40) != 0) {
                                uVar2 = snprintf((char *)__s,__maxlen,"%sSSL Server",puVar7);
                                if ((int)uVar2 < 0) {
                                  return -0x2980;
                                }
                                if (__maxlen <= uVar2) {
                                  return -0x2980;
                                }
                                __maxlen = __maxlen - uVar2;
                                __s = __s + uVar2;
                                puVar7 = &DAT_23080648;
                              }
                              if ((bVar1 & 0x20) != 0) {
                                uVar2 = snprintf((char *)__s,__maxlen,"%sEmail",puVar7);
                                if ((int)uVar2 < 0) {
                                  return -0x2980;
                                }
                                if (__maxlen <= uVar2) {
                                  return -0x2980;
                                }
                                __maxlen = __maxlen - uVar2;
                                __s = __s + uVar2;
                                puVar7 = &DAT_23080648;
                              }
                              if ((bVar1 & 0x10) != 0) {
                                uVar2 = snprintf((char *)__s,__maxlen,"%sObject Signing",puVar7);
                                if ((int)uVar2 < 0) {
                                  return -0x2980;
                                }
                                if (__maxlen <= uVar2) {
                                  return -0x2980;
                                }
                                __maxlen = __maxlen - uVar2;
                                __s = __s + uVar2;
                                puVar7 = &DAT_23080648;
                              }
                              if ((bVar1 & 8) != 0) {
                                uVar2 = snprintf((char *)__s,__maxlen,"%sReserved",puVar7);
                                if ((int)uVar2 < 0) {
                                  return -0x2980;
                                }
                                if (__maxlen <= uVar2) {
                                  return -0x2980;
                                }
                                __maxlen = __maxlen - uVar2;
                                __s = __s + uVar2;
                                puVar7 = &DAT_23080648;
                              }
                              if ((bVar1 & 4) != 0) {
                                uVar2 = snprintf((char *)__s,__maxlen,"%sSSL CA",puVar7);
                                if ((int)uVar2 < 0) {
                                  return -0x2980;
                                }
                                if (__maxlen <= uVar2) {
                                  return -0x2980;
                                }
                                __maxlen = __maxlen - uVar2;
                                __s = __s + uVar2;
                                puVar7 = &DAT_23080648;
                              }
                              if ((bVar1 & 2) != 0) {
                                uVar2 = snprintf((char *)__s,__maxlen,"%sEmail CA",puVar7);
                                if ((int)uVar2 < 0) {
                                  return -0x2980;
                                }
                                if (__maxlen <= uVar2) {
                                  return -0x2980;
                                }
                                __maxlen = __maxlen - uVar2;
                                __s = __s + uVar2;
                                puVar7 = &DAT_23080648;
                              }
                              if ((bVar1 & 1) != 0) {
                                uVar2 = snprintf((char *)__s,__maxlen,"%sObject Signing CA",puVar7);
                                if ((int)uVar2 < 0) {
                                  return -0x2980;
                                }
                                if (__maxlen <= uVar2) {
                                  return -0x2980;
                                }
                                __maxlen = __maxlen - uVar2;
                                __s = __s + uVar2;
                              }
                            }
                            if ((crt->ext_types & 4U) != 0) {
                              uVar2 = snprintf((char *)__s,__maxlen,"\r\n%skey usage         : ",
                                               prefix);
                              if ((int)uVar2 < 0) {
                                return -0x2980;
                              }
                              if (__maxlen <= uVar2) {
                                return -0x2980;
                              }
                              uVar5 = crt->key_usage;
                              __maxlen = __maxlen - uVar2;
                              __s = __s + uVar2;
                              puVar7 = &DAT_23088e60;
                              if ((uVar5 & 0x80) != 0) {
                                uVar2 = snprintf((char *)__s,__maxlen,"%sDigital Signature",
                                                 &DAT_23088e60);
                                if ((int)uVar2 < 0) {
                                  return -0x2980;
                                }
                                if (__maxlen <= uVar2) {
                                  return -0x2980;
                                }
                                __maxlen = __maxlen - uVar2;
                                __s = __s + uVar2;
                                puVar7 = &DAT_23080648;
                              }
                              if ((uVar5 & 0x40) != 0) {
                                uVar2 = snprintf((char *)__s,__maxlen,"%sNon Repudiation",puVar7);
                                if ((int)uVar2 < 0) {
                                  return -0x2980;
                                }
                                if (__maxlen <= uVar2) {
                                  return -0x2980;
                                }
                                __maxlen = __maxlen - uVar2;
                                __s = __s + uVar2;
                                puVar7 = &DAT_23080648;
                              }
                              if ((uVar5 & 0x20) != 0) {
                                uVar2 = snprintf((char *)__s,__maxlen,"%sKey Encipherment",puVar7);
                                if ((int)uVar2 < 0) {
                                  return -0x2980;
                                }
                                if (__maxlen <= uVar2) {
                                  return -0x2980;
                                }
                                __maxlen = __maxlen - uVar2;
                                __s = __s + uVar2;
                                puVar7 = &DAT_23080648;
                              }
                              if ((uVar5 & 0x10) != 0) {
                                uVar2 = snprintf((char *)__s,__maxlen,"%sData Encipherment",puVar7);
                                if ((int)uVar2 < 0) {
                                  return -0x2980;
                                }
                                if (__maxlen <= uVar2) {
                                  return -0x2980;
                                }
                                __maxlen = __maxlen - uVar2;
                                __s = __s + uVar2;
                                puVar7 = &DAT_23080648;
                              }
                              if ((uVar5 & 8) != 0) {
                                uVar2 = snprintf((char *)__s,__maxlen,"%sKey Agreement",puVar7);
                                if ((int)uVar2 < 0) {
                                  return -0x2980;
                                }
                                if (__maxlen <= uVar2) {
                                  return -0x2980;
                                }
                                __maxlen = __maxlen - uVar2;
                                __s = __s + uVar2;
                                puVar7 = &DAT_23080648;
                              }
                              if ((uVar5 & 4) != 0) {
                                uVar2 = snprintf((char *)__s,__maxlen,"%sKey Cert Sign",puVar7);
                                if ((int)uVar2 < 0) {
                                  return -0x2980;
                                }
                                if (__maxlen <= uVar2) {
                                  return -0x2980;
                                }
                                __maxlen = __maxlen - uVar2;
                                __s = __s + uVar2;
                                puVar7 = &DAT_23080648;
                              }
                              if ((uVar5 & 2) != 0) {
                                uVar2 = snprintf((char *)__s,__maxlen,"%sCRL Sign",puVar7);
                                if ((int)uVar2 < 0) {
                                  return -0x2980;
                                }
                                if (__maxlen <= uVar2) {
                                  return -0x2980;
                                }
                                __maxlen = __maxlen - uVar2;
                                __s = __s + uVar2;
                                puVar7 = &DAT_23080648;
                              }
                              if ((uVar5 & 1) != 0) {
                                uVar2 = snprintf((char *)__s,__maxlen,"%sEncipher Only",puVar7);
                                if ((int)uVar2 < 0) {
                                  return -0x2980;
                                }
                                if (__maxlen <= uVar2) {
                                  return -0x2980;
                                }
                                __maxlen = __maxlen - uVar2;
                                __s = __s + uVar2;
                                puVar7 = &DAT_23080648;
                              }
                              if ((int)(uVar5 << 0x10) < 0) {
                                uVar2 = snprintf((char *)__s,__maxlen,"%sDecipher Only",puVar7);
                                if ((int)uVar2 < 0) {
                                  return -0x2980;
                                }
                                if (__maxlen <= uVar2) {
                                  return -0x2980;
                                }
                                __maxlen = __maxlen - uVar2;
                                __s = __s + uVar2;
                              }
                            }
                            if (crt->ext_types << 0x14 < 0) {
                              uVar2 = snprintf((char *)__s,__maxlen,"\r\n%sext key usage     : ",
                                               prefix);
                              if ((int)uVar2 < 0) {
                                return -0x2980;
                              }
                              if (__maxlen <= uVar2) {
                                return -0x2980;
                              }
                              __maxlen = __maxlen - uVar2;
                              __s = __s + uVar2;
                              oid = &crt->ext_key_usage;
                              puVar7 = &DAT_23088e60;
                              do {
                                iVar3 = mbedtls_oid_get_extended_key_usage
                                                  ((mbedtls_asn1_buf *)oid,&pcStack56);
                                if (iVar3 != 0) {
                                  pcStack56 = "???";
                                }
                                uVar2 = snprintf((char *)__s,__maxlen,"%s%s",puVar7,pcStack56);
                                if ((int)uVar2 < 0) {
                                  return -0x2980;
                                }
                                if (__maxlen <= uVar2) {
                                  return -0x2980;
                                }
                                oid = (mbedtls_x509_sequence *)oid->next;
                                __maxlen = __maxlen - uVar2;
                                __s = __s + uVar2;
                                puVar7 = &DAT_23080648;
                              } while (oid != (mbedtls_x509_sequence *)0x0);
                            }
                            uVar2 = snprintf((char *)__s,__maxlen,"\r\n");
                            if ((-1 < (int)uVar2) && (uVar2 < __maxlen)) {
                              return (uVar2 - __maxlen) + size;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return -0x2980;
}



int mbedtls_x509_crt_verify_info(char *buf,size_t size,char *prefix,uint32_t flags)

{
  size_t __maxlen;
  uint uVar1;
  x509_crt_verify_string *pxVar2;
  
  pxVar2 = x509_crt_verify_strings;
  __maxlen = size;
  do {
    if (pxVar2->string == (char *)0x0) {
      if (flags != 0) {
        uVar1 = snprintf(buf,__maxlen,"%sUnknown reason (this should not happen)\n",prefix);
        if (((int)uVar1 < 0) || (__maxlen <= uVar1)) {
          return -0x2980;
        }
        __maxlen = __maxlen - uVar1;
      }
      return size - __maxlen;
    }
    if ((flags & pxVar2->code) != 0) {
      uVar1 = snprintf(buf,__maxlen,"%s%s\n",prefix);
      if ((int)uVar1 < 0) {
        return -0x2980;
      }
      if (__maxlen <= uVar1) {
        return -0x2980;
      }
      __maxlen = __maxlen - uVar1;
      buf = buf + uVar1;
      flags = flags ^ pxVar2->code;
    }
    pxVar2 = pxVar2 + 1;
  } while( true );
}



int mbedtls_x509_crt_check_key_usage(mbedtls_x509_crt *crt,uint usage)

{
  uint uVar1;
  
  uVar1 = crt->ext_types & 4;
  if ((uVar1 != 0) &&
     (((usage & 0xffff7ffe) != (usage & 0xffff7ffe & crt->key_usage) ||
      (uVar1 = 0, (usage & 0x8001) != ((usage | crt->key_usage) & 0x8001))))) {
    uVar1 = 0xffffd800;
  }
  return uVar1;
}



int x509_crt_check_parent(mbedtls_x509_crt *child,mbedtls_x509_crt *parent,int top,int bottom)

{
  int iVar1;
  int iVar2;
  size_t __n;
  
  iVar1 = x509_name_cmp(&child->issuer,&parent->subject);
  if (iVar1 == 0) {
    if (top != 0) {
      iVar1 = parent->version;
      if (((bottom != 0) && (__n = (child->raw).len, __n == (parent->raw).len)) &&
         (iVar2 = memcmp((child->raw).p,(parent->raw).p,__n), iVar2 == 0)) {
        return 0;
      }
      if (iVar1 < 3) {
        return 0;
      }
    }
    if (parent->ca_istrue != 0) {
      iVar1 = mbedtls_x509_crt_check_key_usage(parent,4);
      return -(uint)(iVar1 != 0);
    }
  }
  return -1;
}



int x509_crt_verify_top(mbedtls_x509_crt *child,mbedtls_x509_crt *trust_ca,
                       mbedtls_x509_crt_profile *profile,int path_cnt,int self_cnt,uint32_t *flags,
                       anon_subr_int_void_ptr_mbedtls_x509_crt_ptr_int_uint32_t_ptr *f_vrfy,
                       void *p_vrfy)

{
  mbedtls_pk_type_t type;
  mbedtls_md_type_t md_alg;
  uchar uVar1;
  int iVar2;
  mbedtls_md_info_t *md_info;
  int iVar3;
  undefined3 extraout_var;
  void *options;
  mbedtls_x509_crt *pmVar4;
  uint32_t uStack100;
  uint32_t ca_flags;
  uchar hash [32];
  
  uStack100 = 0;
  iVar2 = mbedtls_x509_time_is_past(&child->valid_to);
  if (iVar2 != 0) {
    *flags = *flags | 1;
  }
  iVar2 = mbedtls_x509_time_is_future(&child->valid_from);
  if (iVar2 != 0) {
    *flags = *flags | 0x200;
  }
  if ((1 << ((uint)child->sig_md - 1 & 0x1f) & profile->allowed_mds) == 0) {
    *flags = *flags | 0x4000;
  }
  if ((1 << ((uint)child->sig_pk - 1 & 0x1f) & profile->allowed_pks) == 0) {
    *flags = *flags | 0x8000;
  }
  *flags = *flags | 8;
  md_info = mbedtls_md_info_from_type(child->sig_md);
  if (md_info == (mbedtls_md_info_t *)0x0) {
LAB_2305e504:
    if (f_vrfy == (anon_subr_int_void_ptr_mbedtls_x509_crt_ptr_int_uint32_t_ptr *)0x0)
    goto LAB_2305e5fe;
  }
  else {
    pmVar4 = (mbedtls_x509_crt *)0x0;
    mbedtls_md(md_info,(child->tbs).p,(child->tbs).len,(uchar *)&ca_flags);
    while (trust_ca != (mbedtls_x509_crt *)0x0) {
      iVar2 = x509_crt_check_parent(child,trust_ca,1,(uint)(path_cnt == 0));
      if (iVar2 == 0) {
        iVar2 = path_cnt + 1;
        if (((child->subject_raw).len == (trust_ca->subject_raw).len) &&
           (iVar3 = memcmp((child->subject_raw).p,(trust_ca->subject_raw).p,(child->issuer_raw).len)
           , iVar3 == 0)) {
          iVar2 = path_cnt;
        }
        if ((trust_ca->max_pathlen < 1) || (iVar2 - self_cnt <= trust_ca->max_pathlen)) {
          type = child->sig_pk;
          options = child->sig_opts;
          md_alg = child->sig_md;
          uVar1 = mbedtls_md_get_size(md_info);
          iVar2 = mbedtls_pk_verify_ext
                            (type,options,&trust_ca->pk,md_alg,(uchar *)&ca_flags,
                             CONCAT31(extraout_var,uVar1),(child->sig).p,(child->sig).len);
          if (iVar2 == 0) {
            iVar2 = mbedtls_x509_time_is_past(&trust_ca->valid_to);
            if ((iVar2 == 0) &&
               (iVar2 = mbedtls_x509_time_is_future(&trust_ca->valid_from), iVar2 == 0))
            goto LAB_2305e5a0;
            if (pmVar4 == (mbedtls_x509_crt *)0x0) {
              pmVar4 = trust_ca;
            }
          }
        }
      }
      trust_ca = trust_ca->next;
    }
    trust_ca = pmVar4;
    if (pmVar4 == (mbedtls_x509_crt *)0x0) goto LAB_2305e504;
LAB_2305e5a0:
    *flags = *flags & 0xfffffff7;
    iVar2 = x509_profile_check_key(profile,child->sig_pk,&trust_ca->pk);
    if (iVar2 != 0) {
      *flags = *flags | 0x10000;
    }
    if (((child->subject_raw).len == (trust_ca->subject_raw).len) &&
       (iVar2 = memcmp((child->subject_raw).p,(trust_ca->subject_raw).p,(child->issuer_raw).len),
       iVar2 == 0)) goto LAB_2305e504;
    iVar2 = mbedtls_x509_time_is_past(&trust_ca->valid_to);
    if (iVar2 != 0) {
      uStack100 = uStack100 | 1;
    }
    iVar2 = mbedtls_x509_time_is_future(&trust_ca->valid_from);
    if (iVar2 != 0) {
      uStack100 = uStack100 | 0x200;
    }
    if (f_vrfy == (anon_subr_int_void_ptr_mbedtls_x509_crt_ptr_int_uint32_t_ptr *)0x0)
    goto LAB_2305e5fe;
    iVar2 = (*f_vrfy)(p_vrfy,trust_ca,path_cnt + 1,&uStack100);
    if (iVar2 != 0) {
      return iVar2;
    }
  }
  iVar2 = (*f_vrfy)(p_vrfy,child,path_cnt,flags);
  if (iVar2 != 0) {
    return iVar2;
  }
LAB_2305e5fe:
  *flags = *flags | uStack100;
  return 0;
}



int x509_crt_verify_child
              (mbedtls_x509_crt *child,mbedtls_x509_crt *parent,mbedtls_x509_crt *trust_ca,
              mbedtls_x509_crl *ca_crl,mbedtls_x509_crt_profile *profile,int path_cnt,int self_cnt,
              uint32_t *flags,anon_subr_int_void_ptr_mbedtls_x509_crt_ptr_int_uint32_t_ptr *f_vrfy,
              void *p_vrfy)

{
  mbedtls_pk_type_t type;
  mbedtls_md_type_t md_alg;
  uchar uVar1;
  int iVar2;
  mbedtls_md_info_t *md_info;
  undefined3 extraout_var;
  void *options;
  mbedtls_x509_crt *parent_00;
  mbedtls_x509_crt *parent_01;
  anon_subr_int_void_ptr_mbedtls_x509_crt_ptr_int_uint32_t_ptr *extraout_fa0;
  anon_subr_int_void_ptr_mbedtls_x509_crt_ptr_int_uint32_t_ptr *f_vrfy_00;
  void *extraout_fa1;
  void *p_vrfy_00;
  anon_subr_int_void_ptr_mbedtls_x509_crt_ptr_int_uint32_t_ptr *in_stack_00000000;
  void *in_stack_00000004;
  uint32_t uStack100;
  uint32_t parent_flags;
  uchar hash [32];
  
  uStack100 = 0;
  if (path_cnt != 0) {
    iVar2 = x509_name_cmp(&child->issuer,&child->subject);
    if (iVar2 == 0) {
      self_cnt = self_cnt + 1;
    }
    if (path_cnt == 8) {
      *flags = *flags | 8;
      return -0x2700;
    }
  }
  iVar2 = mbedtls_x509_time_is_past(&child->valid_to);
  if (iVar2 != 0) {
    *flags = *flags | 1;
  }
  iVar2 = mbedtls_x509_time_is_future(&child->valid_from);
  if (iVar2 != 0) {
    *flags = *flags | 0x200;
  }
  if ((1 << ((uint)child->sig_md - 1 & 0x1f) & profile->allowed_mds) == 0) {
    *flags = *flags | 0x4000;
  }
  if ((1 << ((uint)child->sig_pk - 1 & 0x1f) & profile->allowed_pks) == 0) {
    *flags = *flags | 0x8000;
  }
  f_vrfy_00 = extraout_fa0;
  p_vrfy_00 = extraout_fa1;
  md_info = mbedtls_md_info_from_type(child->sig_md);
  if (md_info != (mbedtls_md_info_t *)0x0) {
    mbedtls_md(md_info,(child->tbs).p,(child->tbs).len,(uchar *)&parent_flags);
    iVar2 = x509_profile_check_key(profile,child->sig_pk,&parent->pk);
    if (iVar2 != 0) {
      *flags = *flags | 0x10000;
    }
    type = child->sig_pk;
    options = child->sig_opts;
    md_alg = child->sig_md;
    uVar1 = mbedtls_md_get_size(md_info);
    iVar2 = mbedtls_pk_verify_ext
                      (type,options,&parent->pk,md_alg,(uchar *)&parent_flags,
                       CONCAT31(extraout_var,uVar1),(child->sig).p,(child->sig).len);
    if (iVar2 == 0) goto LAB_2305e786;
  }
  *flags = *flags | 8;
LAB_2305e786:
  parent_01 = trust_ca;
  while (parent_01 != (mbedtls_x509_crt *)0x0) {
    iVar2 = x509_crt_check_parent(parent,parent_01,0,(uint)(path_cnt == 0));
    if (iVar2 == 0) goto LAB_2305e7da;
    parent_01 = parent_01->next;
  }
  parent_00 = parent->next;
  do {
    parent_01 = trust_ca;
    if (parent_00 == (mbedtls_x509_crt *)0x0) {
LAB_2305e7da:
      iVar2 = x509_crt_verify_top(parent,parent_01,profile,path_cnt + 1,self_cnt,&uStack100,
                                  in_stack_00000000,in_stack_00000004);
LAB_2305e80e:
      if ((iVar2 == 0) &&
         ((in_stack_00000000 == (anon_subr_int_void_ptr_mbedtls_x509_crt_ptr_int_uint32_t_ptr *)0x0
          || (iVar2 = (*in_stack_00000000)(in_stack_00000004,child,path_cnt,flags), iVar2 == 0)))) {
        iVar2 = 0;
        *flags = *flags | uStack100;
      }
      return iVar2;
    }
    if (((parent_00->max_pathlen < 1) || ((path_cnt + 2) - self_cnt <= parent_00->max_pathlen)) &&
       (iVar2 = x509_crt_check_parent(parent,parent_00,0,(uint)(path_cnt == 0)), iVar2 == 0)) {
      iVar2 = x509_crt_verify_child
                        (parent,parent_00,trust_ca,ca_crl,profile,path_cnt + 1,self_cnt,&uStack100,
                         f_vrfy_00,p_vrfy_00);
      goto LAB_2305e80e;
    }
    parent_00 = parent_00->next;
  } while( true );
}



int mbedtls_x509_crt_check_extended_key_usage
              (mbedtls_x509_crt *crt,char *usage_oid,size_t usage_len)

{
  mbedtls_x509_sequence *pmVar1;
  int iVar2;
  
  if (-1 < crt->ext_types << 0x14) {
    return 0;
  }
  pmVar1 = &crt->ext_key_usage;
  while ((((pmVar1->buf).len != usage_len ||
          (iVar2 = memcmp((pmVar1->buf).p,usage_oid,usage_len), iVar2 != 0)) &&
         (((pmVar1->buf).len != 4 || (iVar2 = memcmp(&DAT_2308a3ac,(pmVar1->buf).p,4), iVar2 != 0)))
         )) {
    pmVar1 = (mbedtls_x509_sequence *)pmVar1->next;
    if (pmVar1 == (mbedtls_x509_sequence *)0x0) {
      return -0x2800;
    }
  }
  return 0;
}



int mbedtls_x509_crt_verify_with_profile
              (mbedtls_x509_crt *crt,mbedtls_x509_crt *trust_ca,mbedtls_x509_crl *ca_crl,
              mbedtls_x509_crt_profile *profile,char *cn,uint32_t *flags,
              anon_subr_int_void_ptr_mbedtls_x509_crt_ptr_int_uint32_t_ptr *f_vrfy,void *p_vrfy)

{
  mbedtls_pk_type_t pk_alg;
  size_t len;
  int iVar1;
  mbedtls_x509_crt *parent;
  uint uVar2;
  mbedtls_x509_crt *parent_00;
  mbedtls_x509_name *pmVar3;
  mbedtls_x509_sequence *name;
  anon_subr_int_void_ptr_mbedtls_x509_crt_ptr_int_uint32_t_ptr *in_fa0;
  void *in_fa1;
  
  if (profile == (mbedtls_x509_crt_profile *)0x0) {
    return -0x2800;
  }
  *flags = 0;
  if (cn != (char *)0x0) {
    len = strlen(cn);
    if ((crt->ext_types & 0x20U) == 0) {
      pmVar3 = &crt->subject;
      do {
        if ((((pmVar3->oid).len == 3) &&
            (iVar1 = memcmp(&DAT_2308a724,(pmVar3->oid).p,3), iVar1 == 0)) &&
           (((uVar2 = (pmVar3->val).len, uVar2 == len &&
             (iVar1 = x509_memcasecmp((pmVar3->val).p,cn,len), iVar1 == 0)) ||
            (((2 < uVar2 && (iVar1 = memcmp((pmVar3->val).p,&DAT_2308a720,2), iVar1 == 0)) &&
             (iVar1 = x509_check_wildcard(cn,(mbedtls_x509_buf *)&pmVar3->val), iVar1 == 0))))))
        goto LAB_2305e96c;
        pmVar3 = (mbedtls_x509_name *)pmVar3->next;
      } while (pmVar3 != (mbedtls_x509_name *)0x0);
    }
    else {
      name = &crt->subject_alt_names;
      do {
        uVar2 = (name->buf).len;
        if (((uVar2 == len) && (iVar1 = x509_memcasecmp(cn,(name->buf).p,len), iVar1 == 0)) ||
           ((2 < uVar2 &&
            ((iVar1 = memcmp((name->buf).p,&DAT_2308a720,2), iVar1 == 0 &&
             (iVar1 = x509_check_wildcard(cn,(mbedtls_x509_buf *)name), iVar1 == 0))))))
        goto LAB_2305e96c;
        name = (mbedtls_x509_sequence *)name->next;
      } while (name != (mbedtls_x509_sequence *)0x0);
    }
    *flags = *flags | 4;
  }
LAB_2305e96c:
  pk_alg = mbedtls_pk_get_type(&crt->pk);
  if ((1 << ((uint)pk_alg - 1 & 0x1f) & profile->allowed_pks) == 0) {
    *flags = *flags | 0x8000;
  }
  iVar1 = x509_profile_check_key(profile,pk_alg,&crt->pk);
  parent = trust_ca;
  if (iVar1 != 0) {
    *flags = *flags | 0x10000;
  }
  while (parent != (mbedtls_x509_crt *)0x0) {
    iVar1 = x509_crt_check_parent(crt,parent,0,1);
    if (iVar1 == 0) goto LAB_2305ea38;
    parent = parent->next;
  }
  parent_00 = crt->next;
  do {
    parent = trust_ca;
    if (parent_00 == (mbedtls_x509_crt *)0x0) {
LAB_2305ea38:
      iVar1 = x509_crt_verify_top(crt,parent,profile,0,0,flags,f_vrfy,p_vrfy);
LAB_2305ea60:
      if ((iVar1 == 0) && (iVar1 = 0, *flags != 0)) {
        iVar1 = -0x2700;
      }
      return iVar1;
    }
    iVar1 = x509_crt_check_parent(crt,parent_00,0,1);
    if (iVar1 == 0) {
      iVar1 = x509_crt_verify_child(crt,parent_00,trust_ca,ca_crl,profile,0,0,flags,in_fa0,in_fa1);
      goto LAB_2305ea60;
    }
    parent_00 = parent_00->next;
  } while( true );
}



void mbedtls_x509_crt_init(mbedtls_x509_crt *crt)

{
  memset(crt,0,0x134);
  return;
}



void mbedtls_x509_crt_free(mbedtls_x509_crt *crt)

{
  mbedtls_x509_crt **ppmVar1;
  mbedtls_x509_crt *v;
  uchar *v_00;
  mbedtls_asn1_named_data *v_01;
  mbedtls_asn1_sequence *v_02;
  mbedtls_x509_crt *pmVar2;
  mbedtls_asn1_named_data *pmVar3;
  mbedtls_asn1_sequence *pmVar4;
  
  pmVar2 = crt;
  if (crt == (mbedtls_x509_crt *)0x0) {
    return;
  }
  do {
    mbedtls_pk_free(&pmVar2->pk);
    v_01 = (pmVar2->issuer).next;
    while (v_01 != (mbedtls_asn1_named_data *)0x0) {
      pmVar3 = v_01->next;
      mbedtls_zeroize(v_01,0x20);
      vPortFree(v_01);
      v_01 = pmVar3;
    }
    v_01 = (pmVar2->subject).next;
    while (v_01 != (mbedtls_asn1_named_data *)0x0) {
      pmVar3 = v_01->next;
      mbedtls_zeroize(v_01,0x20);
      vPortFree(v_01);
      v_01 = pmVar3;
    }
    v_02 = (pmVar2->ext_key_usage).next;
    while (v_02 != (mbedtls_asn1_sequence *)0x0) {
      pmVar4 = v_02->next;
      mbedtls_zeroize(v_02,0x10);
      vPortFree(v_02);
      v_02 = pmVar4;
    }
    v_02 = (pmVar2->subject_alt_names).next;
    while (v_02 != (mbedtls_asn1_sequence *)0x0) {
      pmVar4 = v_02->next;
      mbedtls_zeroize(v_02,0x10);
      vPortFree(v_02);
      v_02 = pmVar4;
    }
    v_00 = (pmVar2->raw).p;
    if (v_00 != (uchar *)0x0) {
      mbedtls_zeroize(v_00,(pmVar2->raw).len);
      vPortFree((pmVar2->raw).p);
    }
    ppmVar1 = &pmVar2->next;
    v = crt;
    pmVar2 = *ppmVar1;
  } while (*ppmVar1 != (mbedtls_x509_crt *)0x0);
  do {
    pmVar2 = v->next;
    mbedtls_zeroize(v,0x134);
    if (crt != v) {
      vPortFree(v);
    }
    v = pmVar2;
  } while (pmVar2 != (mbedtls_x509_crt *)0x0);
  return;
}



int mbedtls_x509_crt_parse_der(mbedtls_x509_crt *chain,uchar *buf,size_t buflen)

{
  uchar uVar1;
  uchar *end;
  mbedtls_x509_crt *crt;
  mbedtls_x509_crt *crt_00;
  int iVar2;
  size_t __n;
  size_t sVar3;
  byte *pbVar4;
  byte *pbVar5;
  uchar *end_00;
  mbedtls_x509_crt *pmVar6;
  uchar *end_01;
  uchar *end_02;
  mbedtls_x509_sequence *pmVar7;
  mbedtls_x509_sequence *pmVar8;
  uchar *puStack132;
  size_t len;
  uchar *p;
  size_t len_2;
  int is_critical;
  int ext_type;
  size_t len_3;
  mbedtls_x509_buf sig_params1;
  mbedtls_x509_buf sig_params2;
  mbedtls_x509_buf sig_oid2;
  mbedtls_x509_buf extn_oid;
  size_t len_1;
  
  if ((chain == (mbedtls_x509_crt *)0x0) || (buf == (uchar *)0x0)) {
    return -0x2800;
  }
  crt_00 = chain;
  pmVar6 = (mbedtls_x509_crt *)0x0;
  do {
    crt = crt_00;
    if (crt->version == 0) goto LAB_2305ebe0;
    crt_00 = crt->next;
    pmVar6 = crt;
  } while (crt->next != (mbedtls_x509_crt *)0x0);
  crt_00 = (mbedtls_x509_crt *)mycalloc(1,0x134);
  crt->next = crt_00;
  if (crt_00 == (mbedtls_x509_crt *)0x0) {
    return -0x2880;
  }
  mbedtls_x509_crt_init(crt_00);
  crt = crt->next;
LAB_2305ebe0:
  memset(&len_3,0,0xc);
  memset(&sig_params1.p,0,0xc);
  memset(&sig_params2.p,0,0xc);
  if (crt == (mbedtls_x509_crt *)0x0) {
    iVar2 = -0x2800;
    if (pmVar6 == (mbedtls_x509_crt *)0x0) goto LAB_2305f1cc;
LAB_2305ec28:
    pmVar6->next = (mbedtls_x509_crt *)0x0;
  }
  else {
    puStack132 = (uchar *)buflen;
    len = (size_t)buf;
    iVar2 = mbedtls_asn1_get_tag((uchar **)&len,buf + buflen,(size_t *)&puStack132,0x30);
    if (iVar2 == 0) {
      if (buf + buflen + -len < puStack132) goto LAB_2305ec3c;
      *(uchar **)&(crt->raw).len = puStack132 + (int)(len - (int)buf);
      len = (size_t)mycalloc(1,(size_t)(puStack132 + (int)(len - (int)buf)));
      *(size_t *)&(crt->raw).p = len;
      if ((uchar *)len == (uchar *)0x0) {
        iVar2 = -0x2880;
      }
      else {
        memcpy((void *)len,buf,(crt->raw).len);
        sVar3 = (crt->raw).len;
        end_01 = (uchar *)((sVar3 - (int)puStack132) + len);
        end_00 = (uchar *)(len + sVar3);
        (crt->tbs).p = end_01;
        len = (size_t)end_01;
        iVar2 = mbedtls_asn1_get_tag((uchar **)&len,end_00,(size_t *)&puStack132,0x30);
        if (iVar2 == 0) {
          end_01 = puStack132 + len;
          *(uchar **)&(crt->tbs).len = end_01 + -(int)(crt->tbs).p;
          iVar2 = mbedtls_asn1_get_tag((uchar **)&len,end_01,(size_t *)&extn_oid.p,0xa0);
          if (iVar2 == 0) {
            end_02 = extn_oid.p + len;
            iVar2 = mbedtls_asn1_get_int((uchar **)&len,end_02,&crt->version);
            if (iVar2 == 0) {
              if (end_02 == (uchar *)len) goto LAB_2305ecea;
              iVar2 = -0x2266;
            }
            else {
              iVar2 = iVar2 + -0x2200;
              if (iVar2 == 0) {
LAB_2305ecea:
                iVar2 = mbedtls_x509_get_serial((uchar **)&len,end_01,&crt->serial);
                if (iVar2 == 0) {
                  iVar2 = mbedtls_x509_get_alg
                                    ((uchar **)&len,end_01,&crt->sig_oid,(mbedtls_x509_buf *)&len_3)
                  ;
                  if (iVar2 == 0) {
                    iVar2 = crt->version + 1;
                    crt->version = iVar2;
                    if (3 < iVar2) {
                      mbedtls_x509_crt_free(crt);
                      iVar2 = -0x2580;
                      goto LAB_2305ec24;
                    }
                    iVar2 = mbedtls_x509_get_sig_alg
                                      (&crt->sig_oid,(mbedtls_x509_buf *)&len_3,&crt->sig_md,
                                       &crt->sig_pk,&crt->sig_opts);
                    if (iVar2 == 0) {
                      *(size_t *)&(crt->issuer_raw).p = len;
                      iVar2 = mbedtls_asn1_get_tag((uchar **)&len,end_01,(size_t *)&puStack132,0x30)
                      ;
                      if (iVar2 != 0) goto LAB_2305ec92;
                      iVar2 = mbedtls_x509_get_name((uchar **)&len,puStack132 + len,&crt->issuer);
                      if (iVar2 == 0) {
                        *(uchar **)&(crt->issuer_raw).len =
                             (uchar *)(len - (int)(crt->issuer_raw).p);
                        iVar2 = mbedtls_asn1_get_tag
                                          ((uchar **)&len,end_01,(size_t *)&extn_oid.p,0x30);
                        if (iVar2 == 0) {
                          len = (size_t)(extn_oid.p + len);
                        }
                        else {
                          if (iVar2 != -0x62) goto LAB_2305ed46;
                        }
                        *(size_t *)&(crt->subject_raw).p = len;
                        iVar2 = mbedtls_asn1_get_tag
                                          ((uchar **)&len,end_01,(size_t *)&puStack132,0x30);
                        if (iVar2 != 0) goto LAB_2305ec92;
                        if ((puStack132 == (uchar *)0x0) ||
                           (iVar2 = mbedtls_x509_get_name
                                              ((uchar **)&len,puStack132 + len,&crt->subject),
                           iVar2 == 0)) {
                          *(uchar **)&(crt->subject_raw).len =
                               (uchar *)(len - (int)(crt->subject_raw).p);
                          iVar2 = mbedtls_pk_parse_subpubkey((uchar **)&len,end_01,&crt->pk);
                          if (iVar2 == 0) {
                            if (crt->version - 2U < 2) {
                              if (end_01 != (uchar *)len) {
                                (crt->issuer_id).tag = (uint)*(byte *)len;
                                iVar2 = mbedtls_asn1_get_tag
                                                  ((uchar **)&len,end_01,&(crt->issuer_id).len,0xa1)
                                ;
                                if (iVar2 == 0) {
                                  *(size_t *)&(crt->issuer_id).p = len;
                                  len = len + (crt->issuer_id).len;
                                }
                                else {
                                  if (iVar2 != -0x62) goto LAB_2305ed46;
                                }
                                if (1 < crt->version - 2U) goto LAB_2305ee1e;
                              }
                              if (end_01 != (uchar *)len) {
                                (crt->subject_id).tag = (uint)*(byte *)len;
                                iVar2 = mbedtls_asn1_get_tag
                                                  ((uchar **)&len,end_01,&(crt->subject_id).len,0xa2
                                                  );
                                if (iVar2 == 0) {
                                  *(size_t *)&(crt->subject_id).p = len;
                                  len = len + (crt->subject_id).len;
                                }
                                else {
                                  if (iVar2 != -0x62) goto LAB_2305ed46;
                                }
                              }
                            }
LAB_2305ee1e:
                            if (crt->version == 3) {
                              iVar2 = mbedtls_x509_get_ext((uchar **)&len,end_01,&crt->v3_ext,3);
                              if (iVar2 == 0) {
LAB_2305ee3e:
                                if (end_01 <= len) {
                                  if (end_01 == (uchar *)len) goto LAB_2305ee48;
LAB_2305f11c:
                                  iVar2 = -0x2566;
                                  goto LAB_2305ed46;
                                }
                                sig_oid2.p = (uchar *)0x0;
                                extn_oid.tag = 0;
                                extn_oid.len = 0;
                                len_2 = 0;
                                is_critical = 0;
                                iVar2 = mbedtls_asn1_get_tag
                                                  ((uchar **)&len,end_01,(size_t *)&p,0x30);
                                if (iVar2 != 0) {
LAB_2305ef1a:
                                  iVar2 = iVar2 + -0x2500;
                                  if (iVar2 == 0) goto LAB_2305eef8;
                                  goto LAB_2305ed46;
                                }
                                end_02 = p + len;
                                sig_oid2.p = (uchar *)(uint)*(byte *)len;
                                iVar2 = mbedtls_asn1_get_tag
                                                  ((uchar **)&len,end_01,(size_t *)&extn_oid,6);
                                if (iVar2 != 0) goto LAB_2305ef1a;
                                extn_oid.len = len;
                                len = len + extn_oid.tag;
                                if ((int)(end_01 + -len) < 1) {
LAB_2305f1e4:
                                  iVar2 = -0x2560;
                                  goto LAB_2305ed46;
                                }
                                iVar2 = mbedtls_asn1_get_bool((uchar **)&len,end_02,(int *)&len_2);
                                if (((iVar2 != 0) && (iVar2 != -0x62)) ||
                                   (iVar2 = mbedtls_asn1_get_tag
                                                      ((uchar **)&len,end_02,(size_t *)&p,4),
                                   iVar2 != 0)) goto LAB_2305ef1a;
                                end = p + len;
                                if (end_02 != end) goto LAB_2305f11c;
                                iVar2 = mbedtls_oid_get_x509_ext_type
                                                  ((mbedtls_asn1_buf *)&sig_oid2.p,&is_critical);
                                if (iVar2 != 0) {
                                  len = (size_t)end_02;
                                  if (len_2 != 0) goto LAB_2305ef90;
                                  goto LAB_2305ee3e;
                                }
                                if ((crt->ext_types & is_critical) != 0) {
LAB_2305f1ec:
                                  iVar2 = -0x2500;
                                  goto LAB_2305ed46;
                                }
                                crt->ext_types = crt->ext_types | is_critical;
                                if (is_critical == 0x100) {
                                  crt->ca_istrue = 0;
                                  crt->max_pathlen = 0;
                                  iVar2 = mbedtls_asn1_get_tag
                                                    ((uchar **)&len,end_02,(size_t *)&extn_oid.p,
                                                     0x30);
                                  if (iVar2 == 0) {
                                    if (end == (uchar *)len) goto LAB_2305ee3e;
                                    iVar2 = mbedtls_asn1_get_bool
                                                      ((uchar **)&len,end,&crt->ca_istrue);
                                    if (iVar2 != 0) {
                                      if ((iVar2 != -0x62) ||
                                         (iVar2 = mbedtls_asn1_get_int
                                                            ((uchar **)&len,end,&crt->ca_istrue),
                                         iVar2 != 0)) goto LAB_2305f01c;
                                      if (crt->ca_istrue != 0) {
                                        crt->ca_istrue = 1;
                                      }
                                    }
                                    if (end == (uchar *)len) goto LAB_2305ee3e;
                                    iVar2 = mbedtls_asn1_get_int
                                                      ((uchar **)&len,end,&crt->max_pathlen);
                                    if (iVar2 == 0) {
                                      if (end != (uchar *)len) goto LAB_2305f11c;
                                      crt->max_pathlen = crt->max_pathlen + 1;
                                      goto LAB_2305ee3e;
                                    }
                                  }
                                }
                                else {
                                  if (is_critical < 0x101) {
                                    if (is_critical == 4) {
                                      extn_oid.p = (uchar *)0x0;
                                      iVar2 = mbedtls_asn1_get_bitstring
                                                        ((uchar **)&len,end_02,
                                                         (mbedtls_asn1_bitstring *)&extn_oid.p);
                                      if (iVar2 == 0) {
                                        if (extn_oid.p == (uchar *)0x0) goto LAB_2305f09a;
                                        crt->key_usage = 0;
                                        pbVar4 = (byte *)0x0;
                                        do {
                                          pbVar5 = pbVar4 + 1;
                                          crt->key_usage =
                                               crt->key_usage |
                                               (uint)*pbVar4 << (((uint)pbVar4 & 3) << 3);
                                          if (extn_oid.p == pbVar5) break;
                                          pbVar4 = pbVar5;
                                        } while (pbVar5 != &DAT_00000004);
                                        goto LAB_2305ee3e;
                                      }
                                    }
                                    else {
                                      if (is_critical != 0x20) {
LAB_2305efc6:
                                        iVar2 = -0x2080;
                                        goto LAB_2305ed46;
                                      }
                                      iVar2 = mbedtls_asn1_get_tag
                                                        ((uchar **)&len,end_02,(size_t *)&ext_type,
                                                         0x30);
                                      if (iVar2 == 0) {
                                        if (end == (uchar *)(len + ext_type)) {
                                          pmVar7 = &crt->subject_alt_names;
                                          while (len < end) {
                                            if ((int)(end + -len) < 1) goto LAB_2305f1e4;
                                            uVar1 = *(uchar *)len;
                                            len = len + 1;
                                            iVar2 = mbedtls_asn1_get_len
                                                              ((uchar **)&len,end,
                                                               (size_t *)&extn_oid.p);
                                            if (iVar2 != 0) goto LAB_2305f01c;
                                            if (-1 < (char)uVar1) goto LAB_2305ef90;
                                            if (uVar1 == -0x7e) {
                                              pmVar8 = pmVar7;
                                              if ((pmVar7->buf).p != (uchar *)0x0) {
                                                if (pmVar7->next != (mbedtls_asn1_sequence *)0x0)
                                                goto LAB_2305f1ec;
                                                pmVar8 = (mbedtls_x509_sequence *)mycalloc(1,0x10);
                                                *(mbedtls_x509_sequence **)&pmVar7->next = pmVar8;
                                                if (pmVar8 == (mbedtls_x509_sequence *)0x0) {
                                                  iVar2 = -0x256a;
                                                  goto LAB_2305ed46;
                                                }
                                              }
                                              (pmVar8->buf).tag = 0x82;
                                              *(size_t *)&(pmVar8->buf).p = len;
                                              *(uchar **)&(pmVar8->buf).len = extn_oid.p;
                                              pmVar7 = pmVar8;
                                            }
                                            len = (size_t)((uchar *)len + (int)extn_oid.p);
                                          }
                                          pmVar7->next = (mbedtls_asn1_sequence *)0x0;
                                          if (end != (uchar *)len) goto LAB_2305f11c;
                                          goto LAB_2305ee3e;
                                        }
                                        goto LAB_2305f11c;
                                      }
                                    }
                                  }
                                  else {
                                    if (is_critical == 0x800) {
                                      iVar2 = mbedtls_asn1_get_sequence_of
                                                        ((uchar **)&len,end_02,
                                                         (mbedtls_asn1_sequence *)
                                                         &crt->ext_key_usage,6);
                                      if (iVar2 == 0) {
                                        if ((crt->ext_key_usage).buf.p == (uchar *)0x0) {
LAB_2305f09a:
                                          iVar2 = -0x2564;
                                          goto LAB_2305ed46;
                                        }
                                        goto LAB_2305ee3e;
                                      }
                                    }
                                    else {
                                      if (is_critical != 0x10000) goto LAB_2305efc6;
                                      extn_oid.p = (uchar *)0x0;
                                      iVar2 = mbedtls_asn1_get_bitstring
                                                        ((uchar **)&len,end_02,
                                                         (mbedtls_asn1_bitstring *)&extn_oid.p);
                                      if (iVar2 == 0) {
                                        if (extn_oid.p != (uchar *)0x1) goto LAB_2305f09a;
                                        crt->ns_cert_type = __EM_SIZE;
                                        goto LAB_2305ee3e;
                                      }
                                    }
                                  }
                                }
LAB_2305f01c:
                                iVar2 = iVar2 + -0x2500;
                                if (iVar2 != 0) goto LAB_2305ed46;
                                goto LAB_2305ee3e;
                              }
                              if (iVar2 != -0x62) goto LAB_2305ed46;
                            }
LAB_2305eef8:
                            if (end_01 != (uchar *)len) {
LAB_2305ec3c:
                              mbedtls_x509_crt_free(crt);
                              iVar2 = -0x21e6;
                              goto LAB_2305ec24;
                            }
LAB_2305ee48:
                            iVar2 = mbedtls_x509_get_alg
                                              ((uchar **)&len,end_00,
                                               (mbedtls_x509_buf *)&sig_params2.p,
                                               (mbedtls_x509_buf *)&sig_params1.p);
                            if (iVar2 == 0) {
                              __n = (crt->sig_oid).len;
                              if (((__n != sig_oid2.tag) ||
                                  (iVar2 = memcmp((crt->sig_oid).p,(void *)sig_oid2.len,__n),
                                  iVar2 != 0)) ||
                                 ((sig_params1.tag != sig_params2.tag ||
                                  ((sig_params1.tag != 0 &&
                                   (iVar2 = memcmp((void *)sig_params1.len,(void *)sig_params2.len,
                                                   sig_params1.tag), iVar2 != 0)))))) {
                                mbedtls_x509_crt_free(crt);
                                iVar2 = -0x2680;
                                goto LAB_2305ec24;
                              }
                              iVar2 = mbedtls_x509_get_sig((uchar **)&len,end_00,&crt->sig);
                              if (iVar2 == 0) {
                                if (end_00 == (uchar *)len) {
                                  return 0;
                                }
                                goto LAB_2305ec3c;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          else {
            if (iVar2 == -0x62) {
              crt->version = 0;
              goto LAB_2305ecea;
            }
          }
LAB_2305ed46:
          mbedtls_x509_crt_free(crt);
        }
        else {
LAB_2305ec92:
          mbedtls_x509_crt_free(crt);
          iVar2 = iVar2 + -0x2180;
          if (iVar2 == 0) {
            return 0;
          }
        }
      }
    }
    else {
      mbedtls_x509_crt_free(crt);
      iVar2 = -0x2180;
    }
LAB_2305ec24:
    if (pmVar6 != (mbedtls_x509_crt *)0x0) goto LAB_2305ec28;
  }
  if (chain == crt) {
    return iVar2;
  }
LAB_2305f1cc:
  vPortFree(crt);
  return iVar2;
LAB_2305ef90:
  iVar2 = -0x2562;
  goto LAB_2305ed46;
}



int mbedtls_x509_crt_parse(mbedtls_x509_crt *chain,uchar *buf,size_t buflen)

{
  bool bVar1;
  int iVar2;
  char *pcVar3;
  int iVar4;
  int iVar5;
  size_t local_50;
  size_t use_len;
  mbedtls_pem_context pem;
  
  if ((chain == (mbedtls_x509_crt *)0x0) || (buf == (uchar *)0x0)) {
    iVar4 = -0x2800;
  }
  else {
    if (((buflen != 0) && (buf[buflen - 1] == '\0')) &&
       (pcVar3 = strstr((char *)buf,"-----BEGIN CERTIFICATE-----"), pcVar3 != (char *)0x0)) {
      iVar4 = 0;
      iVar2 = 0;
      bVar1 = false;
      while (1 < buflen) {
        mbedtls_pem_init((mbedtls_pem_context *)&use_len);
        iVar5 = mbedtls_pem_read_buffer
                          ((mbedtls_pem_context *)&use_len,"-----BEGIN CERTIFICATE-----",
                           "-----END CERTIFICATE-----",buf,(uchar *)0x0,0,&local_50);
        if (iVar5 == 0) {
          buflen = buflen - local_50;
          buf = buf + local_50;
          iVar5 = mbedtls_x509_crt_parse_der(chain,(uchar *)use_len,(size_t)pem.buf);
          mbedtls_pem_free((mbedtls_pem_context *)&use_len);
          if (iVar5 != 0) {
            if (iVar5 == -0x2880) {
              return -0x2880;
            }
            goto LAB_2305f2be;
          }
          bVar1 = true;
        }
        else {
          if (iVar5 == -0x1480) {
            return -0x1480;
          }
          if (iVar5 == -0x1080) break;
          mbedtls_pem_free((mbedtls_pem_context *)&use_len);
          buflen = buflen - local_50;
          buf = buf + local_50;
LAB_2305f2be:
          if (iVar2 == 0) {
            iVar2 = iVar5;
          }
          iVar4 = iVar4 + 1;
        }
      }
      if (bVar1) {
        return iVar4;
      }
      if (iVar2 != 0) {
        return iVar2;
      }
      return -0x2780;
    }
    iVar4 = mbedtls_x509_crt_parse_der(chain,buf,buflen);
  }
  return iVar4;
}



int mbedtls_x509_crt_parse_file(mbedtls_x509_crt *chain,char *path)

{
  int iVar1;
  size_t local_18;
  size_t n;
  uchar *buf;
  
  iVar1 = mbedtls_pk_load_file(path,(uchar **)&n,&local_18);
  if (iVar1 == 0) {
    iVar1 = mbedtls_x509_crt_parse(chain,(uchar *)n,local_18);
    mbedtls_zeroize((void *)n,local_18);
    vPortFree((void *)n);
  }
  return iVar1;
}



int net_would_block(void)

{
  int in_a0;
  uint uVar1;
  
  uVar1 = lwip_fcntl(in_a0,3,0);
  uVar1 = uVar1 & 1;
  if (uVar1 != 0) {
    uVar1 = (uint)(errno == 0xb);
  }
  return uVar1;
}



void mbedtls_net_init(mbedtls_net_context *ctx)

{
  ctx->fd = -1;
  return;
}



int mbedtls_net_connect(mbedtls_net_context *ctx,char *host,char *port,int proto)

{
  char "mbedtls_net_connect" [20];
  addrinfo *paVar1;
  int iVar2;
  addrinfo *paStack68;
  addrinfo *addr_list;
  addrinfo hints;
  
  memset(&addr_list,0,0x20);
  iVar2 = lwip_getaddrinfo(host,port,(addrinfo *)&addr_list,&paStack68);
  if (iVar2 == 0) {
    iVar2 = -0x52;
    paVar1 = paStack68;
    while (paVar1 != (addrinfo *)0x0) {
      iVar2 = lwip_socket(paVar1->ai_family,paVar1->ai_socktype,paVar1->ai_protocol);
      ctx->fd = iVar2;
      if (iVar2 < 0) {
        iVar2 = -0x42;
      }
      else {
        do {
          iVar2 = lwip_connect(ctx->fd,paVar1->ai_addr,paVar1->ai_addrlen);
          if (iVar2 == 0) goto _out;
        } while (errno == 4);
        iVar2 = -0x44;
        lwip_close(ctx->fd);
      }
      paVar1 = paVar1->ai_next;
    }
_out:
    lwip_freeaddrinfo(paStack68);
  }
  else {
    printf("%s %d: getaddrinfo fail- errno: %d\n","mbedtls_net_connect",0xf6,errno);
    iVar2 = -0x52;
  }
  return iVar2;
}



int mbedtls_net_set_block(mbedtls_net_context *ctx)

{
  uint uVar1;
  int iVar2;
  
  uVar1 = lwip_fcntl(ctx->fd,3,0);
  iVar2 = lwip_fcntl(ctx->fd,4,uVar1 & 0xfffffffe);
  return iVar2;
}



int mbedtls_net_recv(void *ctx,uchar *buf,size_t len)

{
  int iVar1;
  
  if (*(int *)ctx < 0) {
    printf("%s %d: invalid socket fd\n","mbedtls_net_recv",0x141);
    iVar1 = -0x45;
  }
  else {
    iVar1 = lwip_read(*(int *)ctx,buf,len);
    if (iVar1 < 0) {
      iVar1 = net_would_block();
      if (iVar1 == 0) {
        if ((errno == 0x20) || (errno == 0x68)) {
          printf("%s %d: net reset - errno: %d\n","mbedtls_net_recv",0x14d);
          return -0x50;
        }
        if (errno != 4) {
          printf("%s %d: net recv failed - errno: %d\n","mbedtls_net_recv",0x155);
          return -0x4c;
        }
      }
      iVar1 = -0x6900;
    }
  }
  return iVar1;
}



int mbedtls_net_send(void *ctx,uchar *buf,size_t len)

{
  char "mbedtls_net_send" [17];
  ssize_t sVar1;
  int iVar2;
  
  if (*(int *)ctx < 0) {
    return -0x45;
  }
  sVar1 = lwip_write(*(int *)ctx,buf,len);
  if (sVar1 < 0) {
    iVar2 = net_would_block();
    if (iVar2 == 0) {
      if ((errno == 0x20) || (errno == 0x68)) {
        printf("%s %d: net reset - errno: %d\n","mbedtls_net_send",0x16d);
        return -0x50;
      }
      if (errno != 4) {
        printf("%s %d: net send failed - errno: %d\n",0x2308ac00,0x175);
        return -0x4e;
      }
    }
    return -0x6880;
  }
  return sVar1;
}



// WARNING: Variable defined which should be unmapped: tv

int mbedtls_net_recv_timeout(void *ctx,uchar *buf,size_t len,uint32_t timeout)

{
  int iVar1;
  timeval *timeout_00;
  uint uVar2;
  undefined local_28 [4];
  _types_fd_set read_fds;
  timeval tv;
  
  uVar2 = *(uint *)ctx;
  if (-1 < (int)uVar2) {
    iVar1 = 0;
    do {
      local_28[iVar1] = 0;
      iVar1 = iVar1 + 1;
    } while (iVar1 != 8);
    iVar1 = (uVar2 >> 5) * 4;
    *(uint *)(local_28 + iVar1) = 1 << (uVar2 & 0x1f) | *(uint *)(local_28 + iVar1);
    read_fds.fds_bits[1] = timeout / 1000;
    timeout_00 = (timeval *)(read_fds.fds_bits + 1);
    if (timeout == 0) {
      timeout_00 = (timeval *)0x0;
    }
    iVar1 = lwip_select(uVar2 + 1,(_types_fd_set *)local_28,(_types_fd_set *)0x0,
                        (_types_fd_set *)0x0,timeout_00);
    if (iVar1 == 0) {
      iVar1 = -0x6800;
    }
    else {
      if (iVar1 < 0) {
        iVar1 = -0x4c;
        if (errno == 4) {
          iVar1 = -0x6900;
        }
      }
      else {
        iVar1 = mbedtls_net_recv(ctx,buf,len);
      }
    }
    return iVar1;
  }
  return -0x45;
}



void mbedtls_net_free(mbedtls_net_context *ctx)

{
  if (ctx->fd != -1) {
    lwip_shutdown(ctx->fd,2);
    lwip_close(ctx->fd);
    ctx->fd = -1;
  }
  return;
}



void * mycalloc(size_t numitems,size_t size)

{
  void *__s;
  
  __s = pvPortMalloc(numitems * size);
  memset(__s,0,numitems * size);
  return __s;
}



void aes_gen_tables(void)

{
  byte bVar1;
  int *piVar2;
  uint uVar3;
  uchar *puVar4;
  uint *puVar5;
  uchar *puVar6;
  int iVar7;
  uint32_t *puVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  uint local_820;
  int pow [256];
  int log [256];
  
  puVar5 = &local_820;
  uVar9 = 1;
  iVar7 = 0;
  do {
    pow[uVar9 + 0xff] = iVar7;
    *puVar5 = uVar9;
    uVar3 = uVar9 & 0x80;
    if (uVar3 != 0) {
      uVar3 = 0x1b;
    }
    iVar7 = iVar7 + 1;
    uVar9 = (uVar9 ^ uVar9 << 1 ^ uVar3) & 0xff;
    puVar5 = puVar5 + 1;
  } while (iVar7 != 0x100);
  puVar8 = RCON;
  uVar9 = 1;
  do {
    *puVar8 = uVar9;
    uVar3 = uVar9 & 0x80;
    if (uVar3 != 0) {
      uVar3 = 0x1b;
    }
    puVar8 = puVar8 + 1;
    uVar9 = (uVar3 ^ uVar9 << 1) & 0xff;
  } while (puVar8 != (uint32_t *)RSb);
  FSb[0] = 'c';
  RSb[99] = '\0';
  piVar2 = pow + 0xff;
  iVar7 = 1;
  puVar4 = FSb;
  puVar6 = RSb;
  do {
    uVar13 = (&local_820)[0xff - piVar2[1]];
    piVar2 = piVar2 + 1;
    uVar9 = uVar13 << 1 | (int)uVar13 >> 7;
    uVar12 = uVar9 & 0xff;
    uVar10 = (int)uVar12 >> 7;
    uVar9 = (uVar9 & 0x7f) << 1;
    uVar11 = (int)(uVar9 | uVar10) >> 7;
    uVar3 = (uVar9 & 0x7f | uVar10) << 1 | uVar11;
    uVar9 = ((int)uVar3 >> 7 | ((uVar9 & 0x3f | uVar10) << 1 | uVar11) << 1) ^ uVar13 ^ uVar12 ^
            (uVar9 | uVar10) ^ uVar3 ^ 99;
    FSb[iVar7] = (uchar)uVar9;
    RSb[uVar9] = (uchar)iVar7;
    iVar7 = iVar7 + 1;
  } while (iVar7 != 0x100);
  iVar7 = 0;
  do {
    uVar9 = (uint)*puVar4;
    uVar11 = (uVar9 << 1 ^ (int)(char)*puVar4 >> 0x1f & 0x1bU) & 0xff;
    uVar3 = uVar9 << 8 ^ uVar9 << 0x10 ^ uVar11;
    uVar10 = uVar3 ^ (uVar9 ^ uVar11) << 0x18;
    *(uint *)((int)FT0 + iVar7) = uVar10;
    *(uint *)((int)FT1 + iVar7) = uVar3 << 8 | uVar9 ^ uVar11;
    *(uint *)((int)FT2 + iVar7) = uVar3 << 0x10 | uVar10 >> 0x10;
    *(uint *)((int)FT3 + iVar7) = uVar11 << 0x18 | uVar10 >> 8;
    bVar1 = *puVar6;
    uVar9 = (uint)bVar1;
    if (bVar1 == 0) {
      uVar3 = 0;
      uVar10 = 0;
    }
    else {
      uVar3 = (&local_820)[(log[13] + pow[uVar9 + 0xff]) % 0xff];
      uVar10 = (&local_820)[(pow[uVar9 + 0xff] + log[8]) % 0xff] << 8;
    }
    uVar11 = 0;
    if (bVar1 != 0) {
      uVar11 = (&local_820)[(pow[uVar9 + 0xff] + log[12]) % 0xff] << 0x10;
    }
    uVar11 = uVar10 ^ uVar3 ^ uVar11;
    uVar12 = 0;
    if (bVar1 != 0) {
      uVar12 = (&local_820)[(pow[uVar9 + 0xff] + log[10]) % 0xff] << 0x18;
    }
    uVar12 = uVar11 ^ uVar12;
    *(uint *)((int)RT0 + iVar7) = uVar12;
    *(uint *)((int)RT1 + iVar7) = uVar11 << 8 | uVar12 >> 0x18;
    *(uint *)((int)RT2 + iVar7) = (uVar10 ^ uVar3) << 0x10 | uVar12 >> 0x10;
    *(uint *)((int)RT3 + iVar7) = uVar3 << 0x18 | uVar12 >> 8;
    iVar7 = iVar7 + 4;
    puVar4 = puVar4 + 1;
    puVar6 = puVar6 + 1;
  } while (iVar7 != 0x400);
  return;
}



void mbedtls_aes_init(mbedtls_aes_context *ctx)

{
  memset(ctx,0,0x118);
  return;
}



void mbedtls_aes_free(mbedtls_aes_context *ctx)

{
  mbedtls_aes_context *pmVar1;
  
  pmVar1 = ctx + 1;
  if (ctx != (mbedtls_aes_context *)0x0) {
    while (ctx != pmVar1) {
      *(undefined *)&ctx->nr = 0;
      ctx = (mbedtls_aes_context *)((int)&ctx->nr + 1);
    }
  }
  return;
}



int mbedtls_aes_setkey_enc(mbedtls_aes_context *ctx,uchar *key,uint keybits)

{
  byte *pbVar1;
  uint32_t *puVar2;
  uint uVar3;
  int iVar4;
  uint32_t *puVar5;
  uint32_t *puVar6;
  uint uVar7;
  
  if (aes_init_done == 0) {
    aes_gen_tables();
    aes_init_done = 1;
  }
  if (keybits == 0xc0) {
    iVar4 = 0xc;
  }
  else {
    if (keybits == 0x100) {
      iVar4 = 0xe;
    }
    else {
      if (keybits != 0x80) {
        return -0x20;
      }
      iVar4 = 10;
    }
  }
  ctx->nr = iVar4;
  puVar5 = ctx->buf;
  ctx->rk = puVar5;
  pbVar1 = key;
  puVar2 = puVar5;
  while (key + (keybits >> 5) * 4 != pbVar1) {
    *puVar2 = (uint)pbVar1[1] << 8 | (uint)pbVar1[2] << 0x10 | (uint)*pbVar1 |
              (uint)pbVar1[3] << 0x18;
    pbVar1 = pbVar1 + 4;
    puVar2 = puVar2 + 1;
  }
  iVar4 = ctx->nr;
  if (iVar4 == 0xc) {
    puVar2 = RCON;
    do {
      uVar3 = puVar5[5];
      uVar7 = *puVar2;
      puVar6 = puVar5 + 6;
      puVar2 = puVar2 + 1;
      uVar7 = (uint)FSb[uVar3 >> 8 & 0xff] ^ *puVar5 ^ uVar7 ^ (uint)FSb[uVar3 >> 0x18] << 0x10 ^
              (uint)FSb[uVar3 & 0xff] << 0x18 ^ (uint)FSb[uVar3 >> 0x10 & 0xff] << 8;
      *puVar6 = uVar7;
      uVar7 = uVar7 ^ puVar5[1];
      puVar5[7] = uVar7;
      uVar7 = uVar7 ^ puVar5[2];
      puVar5[8] = uVar7;
      uVar7 = uVar7 ^ puVar5[3];
      puVar5[9] = uVar7;
      uVar7 = uVar7 ^ puVar5[4];
      puVar5[10] = uVar7;
      puVar5[0xb] = uVar7 ^ uVar3;
      puVar5 = puVar6;
    } while (puVar6 != ctx->buf + 0x30);
  }
  else {
    if (iVar4 == 0xe) {
      puVar2 = RCON;
      do {
        uVar3 = puVar5[7];
        uVar7 = *puVar2;
        puVar6 = puVar5 + 8;
        puVar2 = puVar2 + 1;
        uVar7 = (uint)FSb[uVar3 >> 8 & 0xff] ^ *puVar5 ^ uVar7 ^ (uint)FSb[uVar3 >> 0x18] << 0x10 ^
                (uint)FSb[uVar3 & 0xff] << 0x18 ^ (uint)FSb[uVar3 >> 0x10 & 0xff] << 8;
        *puVar6 = uVar7;
        uVar7 = uVar7 ^ puVar5[1];
        puVar5[9] = uVar7;
        uVar7 = uVar7 ^ puVar5[2];
        puVar5[10] = uVar7;
        uVar7 = uVar7 ^ puVar5[3];
        puVar5[0xb] = uVar7;
        uVar7 = (uint)FSb[uVar7 >> 0x10 & 0xff] << 0x10 ^
                (uint)FSb[uVar7 & 0xff] ^ puVar5[4] ^ (uint)FSb[uVar7 >> 0x18] << 0x18 ^
                (uint)FSb[uVar7 >> 8 & 0xff] << 8;
        puVar5[0xc] = uVar7;
        uVar7 = uVar7 ^ puVar5[5];
        puVar5[0xd] = uVar7;
        uVar7 = uVar7 ^ puVar5[6];
        puVar5[0xe] = uVar7;
        puVar5[0xf] = uVar7 ^ uVar3;
        puVar5 = puVar6;
      } while (puVar6 != ctx->buf + 0x38);
    }
    else {
      if (iVar4 != 10) {
        return 0;
      }
      puVar2 = RCON;
      do {
        uVar3 = puVar5[3];
        uVar7 = *puVar2;
        puVar6 = puVar5 + 4;
        puVar2 = puVar2 + 1;
        uVar7 = (uint)FSb[uVar3 >> 8 & 0xff] ^ *puVar5 ^ uVar7 ^ (uint)FSb[uVar3 >> 0x18] << 0x10 ^
                (uint)FSb[uVar3 & 0xff] << 0x18 ^ (uint)FSb[uVar3 >> 0x10 & 0xff] << 8;
        *puVar6 = uVar7;
        uVar7 = uVar7 ^ puVar5[1];
        puVar5[5] = uVar7;
        uVar7 = uVar7 ^ puVar5[2];
        puVar5[6] = uVar7;
        puVar5[7] = uVar7 ^ uVar3;
        puVar5 = puVar6;
      } while (puVar6 != ctx->buf + 0x28);
    }
  }
  return 0;
}



int mbedtls_aes_setkey_dec(mbedtls_aes_context *ctx,uchar *key,uint keybits)

{
  uint *puVar1;
  int iVar2;
  uint32_t *puVar3;
  uint uVar4;
  uint32_t *puVar5;
  uint32_t *puVar6;
  int iVar7;
  int iStack296;
  mbedtls_aes_context cty;
  
  mbedtls_aes_init((mbedtls_aes_context *)&iStack296);
  ctx->rk = ctx->buf;
  iVar2 = mbedtls_aes_setkey_enc((mbedtls_aes_context *)&iStack296,key,keybits);
  if (iVar2 == 0) {
    ctx->nr = iStack296;
    puVar6 = (uint32_t *)(cty.nr + iStack296 * 0x10);
    ctx->buf[0] = *puVar6;
    ctx->buf[1] = puVar6[1];
    puVar3 = ctx->buf;
    ctx->buf[2] = puVar6[2];
    ctx->buf[3] = puVar6[3];
    while( true ) {
      puVar3 = puVar3 + 4;
      puVar5 = puVar6 + -4;
      iStack296 = iStack296 + -1;
      if (iStack296 < 1) break;
      iVar7 = 0;
      do {
        uVar4 = *(uint *)((int)puVar5 + iVar7);
        puVar1 = (uint *)((int)puVar3 + iVar7);
        iVar7 = iVar7 + 4;
        *puVar1 = RT2[FSb[uVar4 >> 0x10 & 0xff]] ^
                  RT0[FSb[uVar4 & 0xff]] ^ RT3[FSb[uVar4 >> 0x18]] ^ RT1[FSb[uVar4 >> 8 & 0xff]];
        puVar6 = puVar5;
      } while (iVar7 != 0x10);
    }
    *puVar3 = *puVar5;
    puVar3[1] = puVar6[-3];
    puVar3[2] = puVar6[-2];
    puVar3[3] = puVar6[-1];
  }
  mbedtls_aes_free((mbedtls_aes_context *)&iStack296);
  return iVar2;
}



void mbedtls_aes_encrypt(mbedtls_aes_context *ctx,uchar *input,uchar *output)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  byte bVar5;
  byte bVar6;
  byte bVar7;
  byte bVar8;
  byte bVar9;
  byte bVar10;
  byte bVar11;
  byte bVar12;
  byte bVar13;
  byte bVar14;
  byte bVar15;
  uint uVar16;
  uint uVar17;
  uint uVar18;
  uint uVar19;
  uint uVar20;
  uint32_t *puVar21;
  uint uVar22;
  uint uVar23;
  uint uVar24;
  int iVar25;
  uint uVar26;
  uint uVar27;
  uint uVar28;
  uint uVar29;
  uint uVar30;
  uint uVar31;
  uint uVar32;
  uint uVar33;
  uint32_t *puVar34;
  
  puVar21 = ctx->rk;
  puVar34 = puVar21 + 4;
  uVar23 = *(uint *)input ^ *puVar21;
  uVar30 = *(uint *)(input + 4) ^ puVar21[1];
  uVar28 = *(uint *)(input + 8) ^ puVar21[2];
  iVar25 = ctx->nr >> 1;
  uVar26 = *(uint *)(input + 0xc) ^ puVar21[3];
  while( true ) {
    iVar25 = iVar25 + -1;
    uVar17 = FT0[uVar23 & 0xff] ^ FT3[uVar26 >> 0x18] ^ *puVar34 ^
             *(uint *)((int)FT1 + (uVar30 >> 6 & 0x3fc)) ^
             *(uint *)((int)FT2 + (uVar28 >> 0xe & 0x3fc));
    uVar31 = puVar34[4];
    uVar19 = FT0[uVar30 & 0xff] ^ FT3[uVar23 >> 0x18] ^ puVar34[1] ^
             *(uint *)((int)FT1 + (uVar28 >> 6 & 0x3fc)) ^
             *(uint *)((int)FT2 + (uVar26 >> 0xe & 0x3fc));
    uVar16 = FT0[uVar28 & 0xff] ^ FT3[uVar30 >> 0x18] ^ puVar34[2] ^
             *(uint *)((int)FT1 + (uVar26 >> 6 & 0x3fc)) ^
             *(uint *)((int)FT2 + (uVar23 >> 0xe & 0x3fc));
    uVar22 = FT0[uVar26 & 0xff] ^ FT3[uVar28 >> 0x18] ^ puVar34[3] ^
             *(uint *)((int)FT1 + (uVar23 >> 6 & 0x3fc)) ^
             *(uint *)((int)FT2 + (uVar30 >> 0xe & 0x3fc));
    uVar33 = uVar19 >> 8 & 0xff;
    uVar23 = uVar16 >> 0x10 & 0xff;
    uVar30 = puVar34[5];
    uVar32 = uVar16 >> 8 & 0xff;
    uVar26 = uVar22 >> 0x10 & 0xff;
    uVar29 = puVar34[6];
    uVar24 = uVar22 >> 8 & 0xff;
    uVar28 = uVar17 >> 0x10 & 0xff;
    uVar27 = puVar34[7];
    uVar18 = uVar17 >> 8 & 0xff;
    uVar20 = uVar19 >> 0x10 & 0xff;
    if (iVar25 < 1) break;
    uVar23 = FT0[uVar17 & 0xff] ^ FT3[uVar22 >> 0x18] ^ uVar31 ^ FT1[uVar33] ^ FT2[uVar23];
    uVar30 = FT0[uVar19 & 0xff] ^ FT3[uVar17 >> 0x18] ^ uVar30 ^ FT1[uVar32] ^ FT2[uVar26];
    uVar28 = FT0[uVar16 & 0xff] ^ FT3[uVar19 >> 0x18] ^ uVar29 ^ FT1[uVar24] ^ FT2[uVar28];
    puVar34 = puVar34 + 8;
    uVar26 = FT0[uVar22 & 0xff] ^ FT3[uVar16 >> 0x18] ^ uVar27 ^ FT1[uVar18] ^ FT2[uVar20];
  }
  bVar1 = FSb[uVar33];
  bVar2 = FSb[uVar23];
  bVar3 = FSb[uVar22 >> 0x18];
  bVar4 = FSb[uVar32];
  bVar5 = FSb[uVar19 & 0xff];
  bVar6 = FSb[uVar26];
  bVar7 = FSb[uVar17 >> 0x18];
  bVar8 = FSb[uVar24];
  bVar9 = FSb[uVar16 & 0xff];
  bVar10 = FSb[uVar28];
  bVar11 = FSb[uVar19 >> 0x18];
  bVar12 = FSb[uVar22 & 0xff];
  bVar13 = FSb[uVar18];
  bVar14 = FSb[uVar20];
  bVar15 = FSb[uVar16 >> 0x18];
  *output = FSb[uVar17 & 0xff] ^ (byte)uVar31;
  output[4] = bVar5 ^ (byte)uVar30;
  output[1] = bVar1 ^ (byte)(uVar31 >> 8);
  output[2] = (byte)(uVar31 >> 0x10) ^ bVar2;
  output[5] = bVar4 ^ (byte)(uVar30 >> 8);
  output[6] = (byte)(uVar30 >> 0x10) ^ bVar6;
  output[9] = bVar8 ^ (byte)(uVar29 >> 8);
  output[10] = (byte)(uVar29 >> 0x10) ^ bVar10;
  output[8] = bVar9 ^ (byte)uVar29;
  output[0xc] = bVar12 ^ (byte)uVar27;
  output[0xd] = (byte)(uVar27 >> 8) ^ bVar13;
  output[3] = (byte)(uVar31 >> 0x18) ^ bVar3;
  output[7] = (byte)(uVar30 >> 0x18) ^ bVar7;
  output[0xb] = (byte)(uVar29 >> 0x18) ^ bVar11;
  output[0xf] = (byte)(uVar27 >> 0x18) ^ bVar15;
  output[0xe] = (byte)(uVar27 >> 0x10) ^ bVar14;
  return;
}



void mbedtls_aes_decrypt(mbedtls_aes_context *ctx,uchar *input,uchar *output)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  byte bVar5;
  byte bVar6;
  byte bVar7;
  byte bVar8;
  byte bVar9;
  byte bVar10;
  byte bVar11;
  byte bVar12;
  byte bVar13;
  byte bVar14;
  byte bVar15;
  uint uVar16;
  uint uVar17;
  uint uVar18;
  uint uVar19;
  uint uVar20;
  uint32_t *puVar21;
  uint uVar22;
  uint uVar23;
  int iVar24;
  uint uVar25;
  uint uVar26;
  uint uVar27;
  uint uVar28;
  uint uVar29;
  uint uVar30;
  uint uVar31;
  uint uVar32;
  uint uVar33;
  uint32_t *puVar34;
  
  puVar21 = ctx->rk;
  uVar29 = *(uint *)(input + 4) ^ puVar21[1];
  puVar34 = puVar21 + 4;
  uVar27 = *(uint *)(input + 8) ^ puVar21[2];
  iVar24 = ctx->nr >> 1;
  uVar23 = *(uint *)input ^ *puVar21;
  uVar25 = *(uint *)(input + 0xc) ^ puVar21[3];
  while( true ) {
    iVar24 = iVar24 + -1;
    uVar17 = RT0[uVar23 & 0xff] ^ RT3[uVar29 >> 0x18] ^ *puVar34 ^
             *(uint *)((int)RT1 + (uVar25 >> 6 & 0x3fc)) ^
             *(uint *)((int)RT2 + (uVar27 >> 0xe & 0x3fc));
    uVar31 = puVar34[4];
    uVar16 = uVar17 >> 8 & 0xff;
    uVar22 = RT0[uVar25 & 0xff] ^ RT3[uVar23 >> 0x18] ^ puVar34[3] ^
             *(uint *)((int)RT1 + (uVar27 >> 6 & 0x3fc)) ^
             *(uint *)((int)RT2 + (uVar29 >> 0xe & 0x3fc));
    uVar18 = RT0[uVar27 & 0xff] ^ RT3[uVar25 >> 0x18] ^ puVar34[2] ^
             *(uint *)((int)RT1 + (uVar29 >> 6 & 0x3fc)) ^
             *(uint *)((int)RT2 + (uVar23 >> 0xe & 0x3fc));
    uVar23 = RT0[uVar29 & 0xff] ^ RT3[uVar27 >> 0x18] ^ puVar34[1] ^
             *(uint *)((int)RT1 + (uVar23 >> 6 & 0x3fc)) ^
             *(uint *)((int)RT2 + (uVar25 >> 0xe & 0x3fc));
    uVar33 = uVar22 >> 8 & 0xff;
    uVar32 = uVar18 >> 0x10 & 0xff;
    uVar30 = puVar34[5];
    uVar29 = uVar22 >> 0x10 & 0xff;
    uVar28 = puVar34[6];
    uVar27 = uVar23 >> 8 & 0xff;
    uVar25 = uVar17 >> 0x10 & 0xff;
    uVar26 = puVar34[7];
    uVar19 = uVar18 >> 8 & 0xff;
    uVar20 = uVar23 >> 0x10 & 0xff;
    if (iVar24 < 1) break;
    uVar29 = RT0[uVar23 & 0xff] ^ RT3[uVar18 >> 0x18] ^ uVar30 ^ RT1[uVar16] ^ RT2[uVar29];
    uVar23 = RT0[uVar17 & 0xff] ^ RT3[uVar23 >> 0x18] ^ uVar31 ^ RT1[uVar33] ^ RT2[uVar32];
    uVar27 = RT0[uVar18 & 0xff] ^ RT3[uVar22 >> 0x18] ^ uVar28 ^ RT1[uVar27] ^ RT2[uVar25];
    puVar34 = puVar34 + 8;
    uVar25 = RT0[uVar22 & 0xff] ^ RT3[uVar17 >> 0x18] ^ uVar26 ^ RT1[uVar19] ^ RT2[uVar20];
  }
  bVar1 = RSb[uVar17 & 0xff];
  bVar2 = RSb[uVar32];
  bVar3 = RSb[uVar23 >> 0x18];
  bVar4 = RSb[uVar22 & 0xff];
  bVar5 = RSb[uVar16];
  bVar6 = RSb[uVar23 & 0xff];
  bVar7 = RSb[uVar29];
  bVar8 = RSb[uVar19];
  bVar9 = RSb[uVar18 >> 0x18];
  bVar10 = RSb[uVar20];
  bVar11 = RSb[uVar27];
  bVar12 = RSb[uVar18 & 0xff];
  bVar13 = RSb[uVar25];
  bVar14 = RSb[uVar17 >> 0x18];
  bVar15 = RSb[uVar22 >> 0x18];
  output[1] = RSb[uVar33] ^ (byte)(uVar31 >> 8);
  output[2] = (byte)(uVar31 >> 0x10) ^ bVar2;
  output[5] = bVar5 ^ (byte)(uVar30 >> 8);
  output[6] = (byte)(uVar30 >> 0x10) ^ bVar7;
  output[9] = bVar11 ^ (byte)(uVar28 >> 8);
  output[10] = (byte)(uVar28 >> 0x10) ^ bVar13;
  *output = bVar1 ^ (byte)uVar31;
  output[4] = bVar6 ^ (byte)uVar30;
  output[8] = bVar12 ^ (byte)uVar28;
  output[0xc] = bVar4 ^ (byte)uVar26;
  output[0xd] = (byte)(uVar26 >> 8) ^ bVar8;
  output[3] = (byte)(uVar31 >> 0x18) ^ bVar3;
  output[7] = (byte)(uVar30 >> 0x18) ^ bVar9;
  output[0xb] = (byte)(uVar28 >> 0x18) ^ bVar15;
  output[0xf] = (byte)(uVar26 >> 0x18) ^ bVar14;
  output[0xe] = (byte)(uVar26 >> 0x10) ^ bVar10;
  return;
}



int mbedtls_aes_crypt_ecb(mbedtls_aes_context *ctx,int mode,uchar *input,uchar *output)

{
  if (mode == 1) {
    mbedtls_aes_encrypt(ctx,input,output);
  }
  else {
    mbedtls_aes_decrypt(ctx,input,output);
  }
  return 0;
}



int mbedtls_aes_crypt_cbc
              (mbedtls_aes_context *ctx,int mode,size_t length,uchar *iv,uchar *input,uchar *output)

{
  uint uVar1;
  int iVar2;
  byte *pbVar3;
  byte *pbVar4;
  byte *pbVar5;
  uchar *input_00;
  undefined auStack64 [4];
  uchar temp [16];
  
  uVar1 = length & 0xf;
  if (uVar1 == 0) {
    if (mode == 0) {
      while( true ) {
        input_00 = output + -uVar1;
        if (uVar1 + length == 0) break;
        memcpy(auStack64,input + -uVar1,0x10);
        mbedtls_aes_decrypt(ctx,input + -uVar1,input_00);
        iVar2 = 0;
        do {
          pbVar3 = input_00 + iVar2;
          pbVar4 = iv + iVar2;
          iVar2 = iVar2 + 1;
          *pbVar3 = *pbVar4 ^ *pbVar3;
        } while (iVar2 != 0x10);
        memcpy(iv,auStack64,0x10);
        uVar1 = uVar1 - 0x10;
      }
    }
    else {
      while( true ) {
        input_00 = output + -uVar1;
        if (length + uVar1 == 0) break;
        iVar2 = 0;
        do {
          pbVar5 = input + -uVar1 + iVar2;
          pbVar3 = iv + iVar2;
          pbVar4 = input_00 + iVar2;
          iVar2 = iVar2 + 1;
          *pbVar4 = *pbVar5 ^ *pbVar3;
        } while (iVar2 != 0x10);
        mbedtls_aes_crypt_ecb(ctx,mode,input_00,input_00);
        memcpy(iv,input_00,0x10);
        uVar1 = uVar1 - 0x10;
      }
    }
    iVar2 = 0;
  }
  else {
    iVar2 = -0x22;
  }
  return iVar2;
}



int mbedtls_aes_crypt_cfb128
              (mbedtls_aes_context *ctx,int mode,size_t length,size_t *iv_off,uchar *iv,uchar *input
              ,uchar *output)

{
  uint uVar1;
  byte *pbVar2;
  byte bVar3;
  
  uVar1 = *iv_off;
  pbVar2 = output;
  if (mode == 0) {
    while (pbVar2 != output + length) {
      if (uVar1 == 0) {
        mbedtls_aes_encrypt(ctx,iv,iv);
      }
      bVar3 = *input;
      *pbVar2 = iv[uVar1] ^ bVar3;
      iv[uVar1] = bVar3;
      uVar1 = uVar1 + 1 & 0xf;
      pbVar2 = pbVar2 + 1;
      input = input + 1;
    }
  }
  else {
    while (pbVar2 != output + length) {
      if (uVar1 == 0) {
        mbedtls_aes_encrypt(ctx,iv,iv);
      }
      bVar3 = iv[uVar1] ^ *input;
      *pbVar2 = bVar3;
      iv[uVar1] = bVar3;
      uVar1 = uVar1 + 1 & 0xf;
      pbVar2 = pbVar2 + 1;
      input = input + 1;
    }
  }
  *iv_off = uVar1;
  return 0;
}



int mbedtls_aes_crypt_ctr
              (mbedtls_aes_context *ctx,size_t length,size_t *nc_off,uchar *nonce_counter,
              uchar *stream_block,uchar *input,uchar *output)

{
  bool bVar1;
  uchar uVar2;
  uint uVar3;
  uchar *puVar4;
  byte *pbVar5;
  
  uVar3 = *nc_off;
  pbVar5 = output;
  do {
    if (pbVar5 == output + length) {
      *nc_off = uVar3;
      return 0;
    }
    if (uVar3 == 0) {
      mbedtls_aes_encrypt(ctx,nonce_counter,stream_block);
      puVar4 = nonce_counter + 0xf;
      do {
        uVar2 = *puVar4;
        *puVar4 = uVar2 + '\x01';
        if ((uchar)(uVar2 + '\x01') != '\0') break;
        bVar1 = nonce_counter != puVar4;
        puVar4 = puVar4 + -1;
      } while (bVar1);
    }
    *pbVar5 = stream_block[uVar3] ^ *input;
    uVar3 = uVar3 + 1 & 0xf;
    input = input + 1;
    pbVar5 = pbVar5 + 1;
  } while( true );
}



int mbedtls_asn1_get_len(uchar **p,uchar *end,size_t *len)

{
  uchar *puVar1;
  byte bVar2;
  byte *pbVar3;
  
  pbVar3 = *p;
  puVar1 = end + -(int)pbVar3;
  if ((int)puVar1 < 1) {
    return -0x60;
  }
  if ((char)*pbVar3 < '\0') {
    bVar2 = *pbVar3 & 0x7f;
    if (bVar2 == 2) {
      if ((int)puVar1 < 3) {
        return -0x60;
      }
      *len = (uint)(*(ushort *)(pbVar3 + 1) >> 8) | ((uint)*(ushort *)(pbVar3 + 1) & 0xff) << 8;
      puVar1 = *p + 3;
    }
    else {
      if (bVar2 < 3) {
        if (bVar2 != 1) {
          return -100;
        }
        if (puVar1 == (uchar *)0x1) {
          return -0x60;
        }
        *len = (uint)pbVar3[1];
        puVar1 = *p + 2;
      }
      else {
        if (bVar2 == 3) {
          if ((int)puVar1 < 4) {
            return -0x60;
          }
          *len = (uint)pbVar3[3] | (uint)pbVar3[1] << 0x10 | (uint)pbVar3[2] << 8;
          puVar1 = *p + 4;
        }
        else {
          if (bVar2 != 4) {
            return -100;
          }
          if ((int)puVar1 < 5) {
            return -0x60;
          }
          *len = (uint)pbVar3[3] << 8 |
                 (uint)pbVar3[1] << 0x18 | (uint)pbVar3[2] << 0x10 | (uint)pbVar3[4];
          puVar1 = *p + 5;
        }
      }
    }
    *p = puVar1;
  }
  else {
    *p = pbVar3 + 1;
    *len = (uint)*pbVar3;
  }
  if (end + -(int)*p < (uchar *)*len) {
    return -0x60;
  }
  return 0;
}



int mbedtls_asn1_get_tag(uchar **p,uchar *end,size_t *len,int tag)

{
  int iVar1;
  byte *pbVar2;
  
  pbVar2 = *p;
  if ((int)(end + -(int)pbVar2) < 1) {
    return -0x60;
  }
  if ((uint)*pbVar2 == tag) {
    *p = pbVar2 + 1;
    iVar1 = mbedtls_asn1_get_len(p,end,len);
    return iVar1;
  }
  return -0x62;
}



int mbedtls_asn1_get_bool(uchar **p,uchar *end,int *val)

{
  int iVar1;
  size_t sStack20;
  size_t len;
  
  iVar1 = mbedtls_asn1_get_tag(p,end,&sStack20,1);
  if (iVar1 == 0) {
    if (sStack20 == 1) {
      *val = (uint)(**p != '\0');
      *p = *p + 1;
    }
    else {
      iVar1 = -100;
    }
  }
  return iVar1;
}



int mbedtls_asn1_get_int(uchar **p,uchar *end,int *val)

{
  int iVar1;
  size_t sStack20;
  size_t len;
  
  iVar1 = mbedtls_asn1_get_tag(p,end,&sStack20,2);
  if (iVar1 == 0) {
    if ((sStack20 - 1 < 4) && (-1 < (char)**p)) {
      *val = 0;
      while (sStack20 != 0) {
        *val = *val << 8 | (uint)**p;
        *p = *p + 1;
        sStack20 = sStack20 - 1;
      }
    }
    else {
      iVar1 = -100;
    }
  }
  return iVar1;
}



int mbedtls_asn1_get_mpi(uchar **p,uchar *end,mbedtls_mpi *X)

{
  int iVar1;
  size_t local_14;
  size_t len;
  
  iVar1 = mbedtls_asn1_get_tag(p,end,&local_14,2);
  if (iVar1 == 0) {
    iVar1 = mbedtls_mpi_read_binary(X,*p,local_14);
    *p = *p + local_14;
  }
  return iVar1;
}



int mbedtls_asn1_get_bitstring(uchar **p,uchar *end,mbedtls_asn1_bitstring *bs)

{
  byte bVar1;
  int iVar2;
  size_t sVar3;
  uchar *puVar4;
  
  iVar2 = mbedtls_asn1_get_tag(p,end,(size_t *)bs,3);
  if (iVar2 == 0) {
    if (bs->len == 0) {
      iVar2 = -0x60;
    }
    else {
      bs->len = bs->len - 1;
      bVar1 = **p;
      bs->unused_bits = bVar1;
      if (bVar1 < 8) {
        puVar4 = *p + 1;
        *p = puVar4;
        sVar3 = bs->len;
        bs->p = puVar4;
        *p = puVar4 + sVar3;
        if (puVar4 + sVar3 != end) {
          iVar2 = -0x66;
        }
      }
      else {
        iVar2 = -100;
      }
    }
  }
  return iVar2;
}



int mbedtls_asn1_get_bitstring_null(uchar **p,uchar *end,size_t *len)

{
  int iVar1;
  uint uVar2;
  uchar *puVar3;
  
  iVar1 = mbedtls_asn1_get_tag(p,end,len,3);
  if ((iVar1 == 0) &&
     ((uVar2 = *len, *len = uVar2 - 1, uVar2 < 2 || (puVar3 = *p, *p = puVar3 + 1, *puVar3 != '\0'))
     )) {
    iVar1 = -0x68;
  }
  return iVar1;
}



int mbedtls_asn1_get_sequence_of(uchar **p,uchar *end,mbedtls_asn1_sequence *cur,int tag)

{
  int iVar1;
  mbedtls_asn1_sequence *pmVar2;
  uchar *puVar3;
  size_t sStack36;
  size_t len;
  
  iVar1 = mbedtls_asn1_get_tag(p,end,&sStack36,0x30);
  if (iVar1 == 0) {
    if (end == *p + sStack36) {
      do {
        do {
          if (end <= *p) {
            cur->next = (mbedtls_asn1_sequence *)0x0;
            if (*p == end) {
              return 0;
            }
            goto LAB_23060ab6;
          }
          (cur->buf).tag = (uint)**p;
          iVar1 = mbedtls_asn1_get_tag(p,end,&(cur->buf).len,tag);
          if (iVar1 != 0) {
            return iVar1;
          }
          puVar3 = *p;
          (cur->buf).p = puVar3;
          puVar3 = puVar3 + (cur->buf).len;
          *p = puVar3;
        } while (end <= puVar3);
        pmVar2 = (mbedtls_asn1_sequence *)mycalloc(1,0x10);
        cur->next = pmVar2;
        cur = pmVar2;
      } while (pmVar2 != (mbedtls_asn1_sequence *)0x0);
      iVar1 = -0x6a;
    }
    else {
LAB_23060ab6:
      iVar1 = -0x66;
    }
  }
  return iVar1;
}



int mbedtls_asn1_get_alg(uchar **p,uchar *end,mbedtls_asn1_buf *alg,mbedtls_asn1_buf *params)

{
  int iVar1;
  int iVar2;
  uchar *puVar3;
  byte *pbVar4;
  mbedtls_asn1_buf *pmVar5;
  byte *end_00;
  size_t sStack36;
  size_t len;
  
  iVar1 = mbedtls_asn1_get_tag(p,end,&sStack36,0x30);
  if (iVar1 == 0) {
    iVar1 = -0x60;
    if (0 < (int)(end + -(int)*p)) {
      alg->tag = (uint)**p;
      end_00 = *p + sStack36;
      iVar2 = mbedtls_asn1_get_tag(p,end_00,&alg->len,6);
      iVar1 = iVar2;
      if (iVar2 == 0) {
        puVar3 = *p;
        alg->p = puVar3;
        pbVar4 = puVar3 + alg->len;
        *p = pbVar4;
        if (pbVar4 == end_00) {
          pmVar5 = params + 1;
          while (params != pmVar5) {
            *(undefined *)&params->tag = 0;
            params = (mbedtls_asn1_buf *)((int)&params->tag + 1);
          }
        }
        else {
          params->tag = (uint)*pbVar4;
          *p = *p + 1;
          iVar1 = mbedtls_asn1_get_len(p,end_00,&params->len);
          if (iVar1 == 0) {
            puVar3 = *p;
            params->p = puVar3;
            pbVar4 = puVar3 + params->len;
            *p = pbVar4;
            iVar1 = iVar2;
            if (pbVar4 != end_00) {
              iVar1 = -0x66;
            }
          }
        }
      }
    }
  }
  return iVar1;
}



void mpi_sub_hlp(size_t n,mbedtls_mpi_uint *s,mbedtls_mpi_uint *d)

{
  mbedtls_mpi_uint *pmVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  mbedtls_mpi_uint *pmVar5;
  uint uVar6;
  size_t sVar7;
  
  uVar4 = 0;
  sVar7 = 0;
  pmVar1 = d;
  while (sVar7 != n) {
    uVar3 = *pmVar1;
    pmVar5 = s + sVar7;
    sVar7 = sVar7 + 1;
    uVar2 = uVar3 - uVar4;
    *pmVar1 = uVar2;
    uVar6 = *pmVar5;
    *pmVar1 = uVar2 - uVar6;
    uVar4 = (uint)(uVar2 < uVar6) + (uint)(uVar3 < uVar4);
    pmVar1 = pmVar1 + 1;
  }
  pmVar1 = d + sVar7;
  while (uVar4 != 0) {
    uVar3 = *pmVar1;
    *pmVar1 = uVar3 - uVar4;
    uVar4 = (uint)(uVar3 < uVar4);
    pmVar1 = pmVar1 + 1;
  }
  return;
}



void mpi_mul_hlp(size_t i,mbedtls_mpi_uint *s,mbedtls_mpi_uint *d,mbedtls_mpi_uint b)

{
  size_t sVar1;
  uint uVar2;
  uint *puVar3;
  uint *puVar4;
  mbedtls_mpi_uint *pmVar5;
  uint uVar6;
  uint uVar7;
  mbedtls_mpi_uint mVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  mbedtls_mpi_uint *pmVar12;
  uint uVar13;
  
  uVar9 = 0;
  sVar1 = i;
  pmVar5 = d;
  pmVar12 = s;
  while (uVar11 = *pmVar5, 0xf < sVar1) {
    uVar10 = *pmVar12;
    sVar1 = sVar1 - 0x10;
    uVar6 = b * uVar10 + uVar9;
    uVar7 = uVar6 + uVar11;
    *pmVar5 = uVar7;
    uVar2 = pmVar12[1];
    uVar11 = (uint)(uVar7 < uVar11) +
             (int)((ulonglong)b * (ulonglong)uVar10 >> 0x20) + (uint)(uVar6 < uVar9);
    uVar6 = b * uVar2 + uVar11;
    uVar9 = pmVar5[1];
    uVar7 = uVar6 + uVar9;
    pmVar5[1] = uVar7;
    uVar9 = (uint)(uVar7 < uVar9) +
            (uint)(uVar6 < uVar11) + (int)((ulonglong)b * (ulonglong)uVar2 >> 0x20);
    uVar11 = pmVar12[2];
    uVar6 = b * uVar11 + uVar9;
    uVar2 = pmVar5[2];
    uVar7 = uVar6 + uVar2;
    pmVar5[2] = uVar7;
    uVar2 = (uint)(uVar7 < uVar2) +
            (uint)(uVar6 < uVar9) + (int)((ulonglong)b * (ulonglong)uVar11 >> 0x20);
    uVar9 = pmVar12[3];
    uVar6 = b * uVar9 + uVar2;
    uVar11 = pmVar5[3];
    uVar7 = uVar6 + uVar11;
    pmVar5[3] = uVar7;
    uVar9 = (uint)(uVar7 < uVar11) +
            (uint)(uVar6 < uVar2) + (int)((ulonglong)b * (ulonglong)uVar9 >> 0x20);
    uVar11 = pmVar12[4];
    uVar6 = b * uVar11 + uVar9;
    uVar2 = pmVar5[4];
    uVar7 = uVar6 + uVar2;
    pmVar5[4] = uVar7;
    uVar2 = (uint)(uVar7 < uVar2) +
            (uint)(uVar6 < uVar9) + (int)((ulonglong)b * (ulonglong)uVar11 >> 0x20);
    uVar9 = pmVar12[5];
    uVar6 = b * uVar9 + uVar2;
    uVar11 = pmVar5[5];
    uVar7 = uVar6 + uVar11;
    pmVar5[5] = uVar7;
    uVar9 = (uint)(uVar7 < uVar11) +
            (uint)(uVar6 < uVar2) + (int)((ulonglong)b * (ulonglong)uVar9 >> 0x20);
    uVar11 = pmVar12[6];
    uVar6 = b * uVar11 + uVar9;
    uVar2 = pmVar5[6];
    uVar7 = uVar6 + uVar2;
    pmVar5[6] = uVar7;
    uVar2 = (uint)(uVar7 < uVar2) +
            (uint)(uVar6 < uVar9) + (int)((ulonglong)b * (ulonglong)uVar11 >> 0x20);
    uVar9 = pmVar12[7];
    uVar6 = b * uVar9 + uVar2;
    uVar11 = pmVar5[7];
    uVar7 = uVar6 + uVar11;
    pmVar5[7] = uVar7;
    uVar9 = (uint)(uVar7 < uVar11) +
            (uint)(uVar6 < uVar2) + (int)((ulonglong)b * (ulonglong)uVar9 >> 0x20);
    uVar11 = pmVar12[8];
    uVar6 = b * uVar11 + uVar9;
    uVar2 = pmVar5[8];
    uVar7 = uVar6 + uVar2;
    pmVar5[8] = uVar7;
    uVar2 = (uint)(uVar7 < uVar2) +
            (uint)(uVar6 < uVar9) + (int)((ulonglong)b * (ulonglong)uVar11 >> 0x20);
    uVar9 = pmVar12[9];
    uVar6 = b * uVar9 + uVar2;
    uVar11 = pmVar5[9];
    uVar7 = uVar6 + uVar11;
    pmVar5[9] = uVar7;
    uVar9 = (uint)(uVar7 < uVar11) +
            (uint)(uVar6 < uVar2) + (int)((ulonglong)b * (ulonglong)uVar9 >> 0x20);
    uVar11 = pmVar12[10];
    uVar6 = b * uVar11 + uVar9;
    uVar2 = pmVar5[10];
    uVar7 = uVar6 + uVar2;
    pmVar5[10] = uVar7;
    uVar2 = (uint)(uVar7 < uVar2) +
            (uint)(uVar6 < uVar9) + (int)((ulonglong)b * (ulonglong)uVar11 >> 0x20);
    uVar9 = pmVar12[0xb];
    uVar6 = b * uVar9 + uVar2;
    uVar11 = pmVar5[0xb];
    uVar7 = uVar6 + uVar11;
    pmVar5[0xb] = uVar7;
    uVar9 = (uint)(uVar7 < uVar11) +
            (uint)(uVar6 < uVar2) + (int)((ulonglong)b * (ulonglong)uVar9 >> 0x20);
    uVar11 = pmVar12[0xc];
    uVar6 = b * uVar11 + uVar9;
    uVar2 = pmVar5[0xc];
    uVar7 = uVar6 + uVar2;
    pmVar5[0xc] = uVar7;
    uVar2 = (uint)(uVar7 < uVar2) +
            (uint)(uVar6 < uVar9) + (int)((ulonglong)b * (ulonglong)uVar11 >> 0x20);
    uVar9 = pmVar12[0xd];
    uVar6 = b * uVar9 + uVar2;
    uVar11 = pmVar5[0xd];
    uVar7 = uVar6 + uVar11;
    pmVar5[0xd] = uVar7;
    uVar9 = (uint)(uVar7 < uVar11) +
            (uint)(uVar6 < uVar2) + (int)((ulonglong)b * (ulonglong)uVar9 >> 0x20);
    uVar11 = pmVar12[0xe];
    uVar6 = b * uVar11 + uVar9;
    uVar2 = pmVar5[0xe];
    uVar7 = uVar6 + uVar2;
    pmVar5[0xe] = uVar7;
    uVar10 = pmVar12[0xf];
    uVar2 = (uint)(uVar7 < uVar2) +
            (uint)(uVar6 < uVar9) + (int)((ulonglong)b * (ulonglong)uVar11 >> 0x20);
    uVar9 = b * uVar10 + uVar2;
    uVar6 = pmVar5[0xf];
    uVar11 = uVar9 + uVar6;
    pmVar5[0xf] = uVar11;
    uVar9 = (uint)(uVar11 < uVar6) +
            (uint)(uVar9 < uVar2) + (int)((ulonglong)b * (ulonglong)uVar10 >> 0x20);
    pmVar5 = pmVar5 + 0x10;
    pmVar12 = pmVar12 + 0x10;
  }
  puVar4 = s + (i & 0xfffffff0);
  d = d + (i & 0xfffffff0);
  uVar2 = i + (i >> 4) * -0x10;
  puVar3 = puVar4;
  pmVar5 = d;
  if (7 < uVar2) {
    uVar13 = *puVar4;
    uVar2 = uVar2 - 8;
    pmVar5 = d + 8;
    puVar3 = puVar4 + 8;
    uVar6 = b * uVar13 + uVar9;
    uVar7 = uVar6 + uVar11;
    *d = uVar7;
    uVar10 = puVar4[1];
    uVar13 = (uint)(uVar7 < uVar11) +
             (int)((ulonglong)b * (ulonglong)uVar13 >> 0x20) + (uint)(uVar6 < uVar9);
    uVar9 = b * uVar10 + uVar13;
    uVar7 = d[1];
    uVar11 = uVar9 + uVar7;
    d[1] = uVar11;
    uVar6 = puVar4[2];
    uVar7 = (uint)(uVar9 < uVar13) + (int)((ulonglong)b * (ulonglong)uVar10 >> 0x20) +
            (uint)(uVar11 < uVar7);
    uVar9 = b * uVar6 + uVar7;
    uVar10 = d[2];
    uVar11 = uVar9 + uVar10;
    d[2] = uVar11;
    uVar7 = (uint)(uVar11 < uVar10) +
            (int)((ulonglong)b * (ulonglong)uVar6 >> 0x20) + (uint)(uVar9 < uVar7);
    uVar9 = puVar4[3];
    uVar10 = b * uVar9 + uVar7;
    uVar11 = d[3];
    uVar13 = uVar10 + uVar11;
    d[3] = uVar13;
    uVar6 = puVar4[4];
    uVar9 = (uint)(uVar13 < uVar11) +
            (uint)(uVar10 < uVar7) + (int)((ulonglong)b * (ulonglong)uVar9 >> 0x20);
    uVar10 = b * uVar6 + uVar9;
    uVar11 = d[4];
    uVar13 = uVar10 + uVar11;
    d[4] = uVar13;
    uVar7 = puVar4[5];
    uVar11 = (uint)(uVar13 < uVar11) +
             (uint)(uVar10 < uVar9) + (int)((ulonglong)b * (ulonglong)uVar6 >> 0x20);
    uVar10 = b * uVar7 + uVar11;
    uVar6 = d[5];
    uVar13 = uVar10 + uVar6;
    d[5] = uVar13;
    uVar9 = puVar4[6];
    uVar7 = (uint)(uVar13 < uVar6) +
            (uint)(uVar10 < uVar11) + (int)((ulonglong)b * (ulonglong)uVar7 >> 0x20);
    uVar10 = b * uVar9 + uVar7;
    uVar11 = d[6];
    uVar13 = uVar10 + uVar11;
    d[6] = uVar13;
    uVar6 = puVar4[7];
    uVar9 = (uint)(uVar13 < uVar11) +
            (uint)(uVar10 < uVar7) + (int)((ulonglong)b * (ulonglong)uVar9 >> 0x20);
    uVar7 = b * uVar6 + uVar9;
    uVar11 = d[7];
    uVar10 = uVar7 + uVar11;
    d[7] = uVar10;
    uVar9 = (uint)(uVar10 < uVar11) +
            (uint)(uVar7 < uVar9) + (int)((ulonglong)b * (ulonglong)uVar6 >> 0x20);
  }
  puVar4 = puVar3;
  pmVar12 = pmVar5;
  while( true ) {
    uVar11 = *pmVar12;
    if (puVar4 == puVar3 + uVar2) break;
    uVar6 = *puVar4;
    uVar7 = b * uVar6 + uVar9;
    uVar10 = uVar7 + uVar11;
    *pmVar12 = uVar10;
    uVar9 = (uint)(uVar10 < uVar11) +
            (int)((ulonglong)b * (ulonglong)uVar6 >> 0x20) + (uint)(uVar7 < uVar9);
    puVar4 = puVar4 + 1;
    pmVar12 = pmVar12 + 1;
  }
  pmVar5 = pmVar5 + uVar2;
  while( true ) {
    mVar8 = *pmVar5;
    *pmVar5 = mVar8 + uVar9;
    if (uVar9 <= mVar8 + uVar9) break;
    uVar9 = 1;
    pmVar5 = pmVar5 + 1;
  }
  return;
}



void mbedtls_mpi_init(mbedtls_mpi *X)

{
  if (X != (mbedtls_mpi *)0x0) {
    X->s = 1;
    X->n = 0;
    X->p = (mbedtls_mpi_uint *)0x0;
  }
  return;
}



void mbedtls_mpi_free(mbedtls_mpi *X)

{
  size_t sVar1;
  mbedtls_mpi_uint *pmVar2;
  
  if (X != (mbedtls_mpi *)0x0) {
    pmVar2 = X->p;
    if (pmVar2 != (mbedtls_mpi_uint *)0x0) {
      sVar1 = X->n;
      while (sVar1 = sVar1 - 1, sVar1 != 0xffffffff) {
        *pmVar2 = 0;
        pmVar2 = pmVar2 + 1;
      }
      vPortFree(X->p);
    }
    X->s = 1;
    X->n = 0;
    X->p = (mbedtls_mpi_uint *)0x0;
    return;
  }
  return;
}



int mbedtls_mpi_grow(mbedtls_mpi *X,size_t nblimbs)

{
  mbedtls_mpi_uint *__dest;
  int iVar1;
  mbedtls_mpi_uint *pmVar2;
  size_t sVar3;
  
  if (10000 < nblimbs) {
    return -0x10;
  }
  iVar1 = 0;
  if (X->n < nblimbs) {
    __dest = (mbedtls_mpi_uint *)mycalloc(nblimbs,4);
    if (__dest == (mbedtls_mpi_uint *)0x0) {
      iVar1 = -0x10;
    }
    else {
      if (X->p != (mbedtls_mpi_uint *)0x0) {
        memcpy(__dest,X->p,X->n << 2);
        pmVar2 = X->p;
        sVar3 = X->n;
        while (sVar3 = sVar3 - 1, sVar3 != 0xffffffff) {
          *pmVar2 = 0;
          pmVar2 = pmVar2 + 1;
        }
        vPortFree(X->p);
      }
      X->n = nblimbs;
      X->p = __dest;
      iVar1 = 0;
    }
  }
  return iVar1;
}



int mbedtls_mpi_shrink(mbedtls_mpi *X,size_t nblimbs)

{
  uint uVar1;
  int iVar2;
  mbedtls_mpi_uint *__dest;
  mbedtls_mpi_uint *pmVar3;
  size_t sVar4;
  uint uVar5;
  
  uVar5 = X->n;
  if (X->n <= nblimbs) {
    iVar2 = mbedtls_mpi_grow(X,nblimbs);
    return iVar2;
  }
  do {
    uVar1 = uVar5;
    uVar5 = uVar1 - 1;
    if (uVar5 == 0) break;
  } while (X->p[uVar5] == 0);
  if (nblimbs < uVar1) {
    nblimbs = uVar1;
  }
  __dest = (mbedtls_mpi_uint *)mycalloc(nblimbs,4);
  iVar2 = -0x10;
  if (__dest != (mbedtls_mpi_uint *)0x0) {
    if (X->p != (mbedtls_mpi_uint *)0x0) {
      memcpy(__dest,X->p,nblimbs << 2);
      pmVar3 = X->p;
      sVar4 = X->n;
      while (sVar4 = sVar4 - 1, sVar4 != 0xffffffff) {
        *pmVar3 = 0;
        pmVar3 = pmVar3 + 1;
      }
      vPortFree(X->p);
    }
    X->n = nblimbs;
    X->p = __dest;
    iVar2 = 0;
  }
  return iVar2;
}



int mbedtls_mpi_copy(mbedtls_mpi *X,mbedtls_mpi *Y)

{
  int iVar1;
  size_t nblimbs;
  
  if (X != Y) {
    if (Y->p != (mbedtls_mpi_uint *)0x0) {
      nblimbs = Y->n;
      do {
        nblimbs = nblimbs;
        nblimbs = nblimbs - 1;
        if (nblimbs == 0) break;
      } while (Y->p[nblimbs] == 0);
      X->s = Y->s;
      iVar1 = mbedtls_mpi_grow(X,nblimbs);
      if (iVar1 != 0) {
        return iVar1;
      }
      memset(X->p,0,X->n << 2);
      memcpy(X->p,Y->p,nblimbs << 2);
      return 0;
    }
    mbedtls_mpi_free(X);
  }
  return 0;
}



int mbedtls_mpi_safe_cond_assign(mbedtls_mpi *X,mbedtls_mpi *Y,uchar assign)

{
  int iVar1;
  mbedtls_mpi_uint *pmVar2;
  uint uVar3;
  mbedtls_mpi_uint *pmVar4;
  int iVar5;
  uint uVar6;
  
  iVar1 = mbedtls_mpi_grow(X,Y->n);
  if (iVar1 == 0) {
    uVar3 = ((uint)assign | -(uint)assign & 0xff) >> 7;
    iVar5 = 1 - uVar3;
    X->s = iVar5 * X->s + uVar3 * Y->s;
    uVar6 = 0;
    while (uVar6 < Y->n) {
      pmVar2 = X->p + uVar6;
      pmVar4 = Y->p + uVar6;
      uVar6 = uVar6 + 1;
      *pmVar2 = uVar3 * *pmVar4 + iVar5 * *pmVar2;
    }
    while (uVar6 < X->n) {
      X->p[uVar6] = X->p[uVar6] * iVar5;
      uVar6 = uVar6 + 1;
    }
  }
  return iVar1;
}



int mbedtls_mpi_lset(mbedtls_mpi *X,mbedtls_mpi_sint z)

{
  int iVar1;
  int iVar2;
  
  iVar1 = mbedtls_mpi_grow(X,1);
  if (iVar1 == 0) {
    memset(X->p,0,X->n << 2);
    *X->p = (z >> 0x1f ^ z) - (z >> 0x1f);
    iVar2 = -1;
    if (-1 < z) {
      iVar2 = 1;
    }
    X->s = iVar2;
  }
  return iVar1;
}



int mbedtls_mpi_get_bit(mbedtls_mpi *X,size_t pos)

{
  if (pos < X->n << 5) {
    return X->p[pos >> 5] >> (pos & 0x1f) & 1;
  }
  return 0;
}



size_t mbedtls_mpi_lsb(mbedtls_mpi *X)

{
  int iVar1;
  size_t sVar2;
  uint uVar3;
  
  sVar2 = 0;
  iVar1 = 0;
  do {
    if (X->n == sVar2) {
      return 0;
    }
    uVar3 = 0;
    do {
      if ((X->p[sVar2] >> (uVar3 & 0x1f) & 1) != 0) {
        return iVar1 + uVar3;
      }
      uVar3 = uVar3 + 1;
    } while (uVar3 != 0x20);
    sVar2 = sVar2 + 1;
    iVar1 = iVar1 + uVar3;
  } while( true );
}



size_t mbedtls_mpi_bitlen(mbedtls_mpi *X)

{
  int iVar1;
  uint uVar2;
  size_t sVar3;
  size_t sVar4;
  
  sVar3 = X->n;
  if (sVar3 != 0) {
    do {
      sVar4 = sVar3;
      sVar3 = sVar4 - 1;
      if (sVar3 == 0) break;
    } while (X->p[sVar3] == 0);
    iVar1 = 0;
    uVar2 = 0x80000000;
    do {
      if ((X->p[sVar3] & uVar2) != 0) break;
      iVar1 = iVar1 + 1;
      uVar2 = uVar2 >> 1;
    } while (iVar1 != 0x20);
    sVar3 = sVar4 * 0x20 - iVar1;
  }
  return sVar3;
}



size_t mbedtls_mpi_size(mbedtls_mpi *X)

{
  size_t sVar1;
  
  sVar1 = mbedtls_mpi_bitlen(X);
  return sVar1 + 7 >> 3;
}



int mbedtls_mpi_read_binary(mbedtls_mpi *X,uchar *buf,size_t buflen)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  uint *puVar4;
  uint uVar5;
  
  uVar2 = 0;
  while ((uVar2 != buflen && (buf[uVar2] == '\0'))) {
    uVar2 = uVar2 + 1;
  }
  iVar3 = mbedtls_mpi_grow(X,(uint)((buflen - uVar2 & 3) != 0) + (buflen - uVar2 >> 2));
  if (iVar3 == 0) {
    iVar3 = mbedtls_mpi_lset(X,0);
    uVar5 = 0;
    if (iVar3 == 0) {
      while (uVar2 < buflen) {
        buflen = buflen - 1;
        puVar4 = (uint *)((int)X->p + (uVar5 & 0xfffffffc));
        uVar1 = uVar5 & 3;
        uVar5 = uVar5 + 1;
        *puVar4 = *puVar4 | (uint)buf[buflen] << (uVar1 << 3);
      }
    }
  }
  return iVar3;
}



int mbedtls_mpi_write_binary(mbedtls_mpi *X,uchar *buf,size_t buflen)

{
  uint uVar1;
  size_t sVar2;
  int iVar3;
  uint uVar4;
  uint uVar5;
  
  sVar2 = mbedtls_mpi_size(X);
  if (buflen < sVar2) {
    iVar3 = -8;
  }
  else {
    memset(buf,0,buflen);
    buf = buf + buflen;
    uVar5 = 0;
    while (buf = buf + -1, uVar5 != sVar2) {
      uVar4 = uVar5 & 0xfffffffc;
      uVar1 = uVar5 & 3;
      uVar5 = uVar5 + 1;
      *buf = (uchar)(*(uint *)((int)X->p + uVar4) >> (uVar1 << 3));
    }
    iVar3 = 0;
  }
  return iVar3;
}



int mbedtls_mpi_shift_l(mbedtls_mpi *X,size_t count)

{
  uint uVar1;
  size_t sVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  
  uVar1 = count >> 5;
  uVar6 = count & 0x1f;
  sVar2 = mbedtls_mpi_bitlen(X);
  uVar3 = sVar2 + count;
  if ((uVar3 <= X->n << 5) ||
     (iVar4 = mbedtls_mpi_grow(X,(uint)((uVar3 & 0x1f) != 0) + (uVar3 >> 5)), iVar4 == 0)) {
    if (0x1f < count) {
      uVar3 = X->n;
      iVar4 = uVar3 << 2;
      while (iVar4 = iVar4 + -4, uVar1 < uVar3) {
        uVar3 = uVar3 - 1;
        *(undefined4 *)((int)X->p + iVar4) = *(undefined4 *)((int)X->p + iVar4 + uVar1 * -4);
      }
      iVar4 = uVar3 << 2;
      while (iVar4 = iVar4 + -4, iVar4 != -4) {
        *(undefined4 *)((int)X->p + iVar4) = 0;
      }
    }
    if (uVar6 != 0) {
      uVar3 = 0;
      while (uVar1 < X->n) {
        uVar5 = X->p[uVar1];
        X->p[uVar1] = uVar5 << uVar6;
        X->p[uVar1] = X->p[uVar1] | uVar3;
        uVar3 = uVar5 >> (0x20 - uVar6 & 0x1f);
        uVar1 = uVar1 + 1;
      }
    }
    iVar4 = 0;
  }
  return iVar4;
}



int mbedtls_mpi_shift_r(mbedtls_mpi *X,size_t count)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  size_t sVar5;
  mbedtls_mpi_uint *pmVar6;
  
  uVar3 = count >> 5;
  uVar4 = count & 0x1f;
  if (X->n < uVar3) {
LAB_230614f4:
    iVar1 = mbedtls_mpi_lset(X,0);
    return iVar1;
  }
  if (X->n == uVar3) {
    if (uVar4 != 0) goto LAB_230614f4;
    if (count < 0x20) {
      return 0;
    }
    uVar2 = 0;
  }
  else {
    if (count < 0x20) goto LAB_23061514;
    iVar1 = uVar3 << 2;
    uVar2 = 0;
    while (uVar2 < X->n - uVar3) {
      pmVar6 = (mbedtls_mpi_uint *)((int)X->p + iVar1);
      iVar1 = iVar1 + 4;
      X->p[uVar2] = *pmVar6;
      uVar2 = uVar2 + 1;
    }
  }
  while (uVar2 < X->n) {
    X->p[uVar2] = 0;
    uVar2 = uVar2 + 1;
  }
LAB_23061514:
  if (uVar4 != 0) {
    sVar5 = X->n;
    uVar3 = 0;
    while (sVar5 = sVar5 - 1, sVar5 != 0xffffffff) {
      uVar2 = X->p[sVar5];
      X->p[sVar5] = uVar2 >> uVar4;
      X->p[sVar5] = X->p[sVar5] | uVar3;
      uVar3 = uVar2 << (0x20 - uVar4 & 0x1f);
    }
  }
  return 0;
}



int mbedtls_mpi_cmp_abs(mbedtls_mpi *X,mbedtls_mpi *Y)

{
  uint uVar1;
  uint uVar2;
  
  uVar2 = X->n;
  while ((uVar2 != 0 && (X->p[uVar2 - 1] == 0))) {
    uVar2 = uVar2 - 1;
  }
  uVar1 = Y->n;
  while( true ) {
    if (uVar1 == 0) {
      return (uint)(uVar2 != 0);
    }
    if (Y->p[uVar1 - 1] != 0) break;
    uVar1 = uVar1 - 1;
  }
  if (uVar2 <= uVar1) {
    if (uVar2 < uVar1) {
      return -1;
    }
    while( true ) {
      uVar2 = uVar2 - 1;
      if (uVar2 == 0xffffffff) {
        return 0;
      }
      uVar1 = Y->p[uVar2];
      if (uVar1 < X->p[uVar2]) break;
      if (X->p[uVar2] < uVar1) {
        return -1;
      }
    }
    return 1;
  }
  return 1;
}



int mpi_montmul(mbedtls_mpi *A,mbedtls_mpi *B,mbedtls_mpi *N,mbedtls_mpi_uint mm,mbedtls_mpi *T)

{
  int iVar1;
  mbedtls_mpi_uint *d;
  mbedtls_mpi_uint mVar2;
  mbedtls_mpi_uint *s;
  mbedtls_mpi_uint mVar3;
  size_t n;
  uint i;
  uint i_00;
  mbedtls_mpi_uint b;
  
  if ((N->n + 1 <= T->n) && (T->p != (mbedtls_mpi_uint *)0x0)) {
    memset(T->p,0,T->n << 2);
    i = N->n;
    s = T->p;
    i_00 = B->n;
    if (i < B->n) {
      i_00 = i;
    }
    n = 0;
    d = s;
    while (n != i) {
      b = A->p[n];
      mVar3 = *B->p;
      mVar2 = *d;
      n = n + 1;
      mpi_mul_hlp(i_00,B->p,d,b);
      mpi_mul_hlp(i,N->p,d,(b * mVar3 + mVar2) * mm);
      *d = b;
      (d + 1)[i + 1] = 0;
      d = d + 1;
    }
    memcpy(A->p,s + i,(i + 1) * 4);
    iVar1 = mbedtls_mpi_cmp_abs(A,N);
    if (iVar1 < 0) {
      d = T->p;
      s = A->p;
    }
    else {
      s = N->p;
      d = A->p;
    }
    mpi_sub_hlp(n,s,d);
    return 0;
  }
  return -4;
}



int mbedtls_mpi_cmp_mpi(mbedtls_mpi *X,mbedtls_mpi *Y)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  uint uVar4;
  
  uVar4 = X->n;
  while ((uVar4 != 0 && (X->p[uVar4 - 1] == 0))) {
    uVar4 = uVar4 - 1;
  }
  uVar2 = Y->n;
  do {
    if (uVar2 == 0) {
      if (uVar4 == 0) {
        return 0;
      }
LAB_23061736:
      return X->s;
    }
    if (Y->p[uVar2 - 1] != 0) {
      if (uVar4 <= uVar2) {
        iVar1 = Y->s;
        if (uVar4 < uVar2) {
          return -iVar1;
        }
        iVar3 = X->s;
        if (iVar3 < 1) {
          if ((0 < iVar1) && (iVar3 != 0)) {
            return -1;
          }
        }
        else {
          if (iVar1 < 0) {
            return 1;
          }
        }
        while( true ) {
          uVar4 = uVar4 - 1;
          if (uVar4 == 0xffffffff) {
            return 0;
          }
          uVar2 = Y->p[uVar4];
          if (uVar2 < X->p[uVar4]) break;
          if (X->p[uVar4] < uVar2) {
            return -iVar3;
          }
        }
        return iVar3;
      }
      goto LAB_23061736;
    }
    uVar2 = uVar2 - 1;
  } while( true );
}



int mbedtls_mpi_cmp_int(mbedtls_mpi *X,mbedtls_mpi_sint z)

{
  int iVar1;
  mbedtls_mpi_uint p [1];
  mbedtls_mpi Y;
  
  p = 1;
  if (z < 0) {
    p = 0xffffffff;
  }
  iVar1 = mbedtls_mpi_cmp_mpi(X,(mbedtls_mpi *)p);
  return iVar1;
}



int mbedtls_mpi_add_abs(mbedtls_mpi *X,mbedtls_mpi *A,mbedtls_mpi *B)

{
  size_t nblimbs;
  mbedtls_mpi *pmVar1;
  uint uVar2;
  int iVar3;
  mbedtls_mpi_uint *pmVar4;
  int iVar5;
  uint uVar6;
  mbedtls_mpi_uint *pmVar7;
  size_t sVar8;
  mbedtls_mpi_uint mVar9;
  uint uVar10;
  mbedtls_mpi_uint *pmVar11;
  
  pmVar1 = A;
  if (((X == B) || (pmVar1 = B, X == A)) || (iVar3 = mbedtls_mpi_copy(X,A), iVar3 == 0)) {
    X->s = 1;
    nblimbs = pmVar1->n;
    while ((nblimbs != 0 && (pmVar1->p[nblimbs - 1] == 0))) {
      nblimbs = nblimbs - 1;
    }
    iVar3 = mbedtls_mpi_grow(X,nblimbs);
    if (iVar3 == 0) {
      pmVar11 = X->p;
      pmVar4 = pmVar1->p;
      sVar8 = 0;
      uVar2 = 0;
      pmVar7 = pmVar11;
      while (nblimbs != sVar8) {
        uVar6 = pmVar4[sVar8];
        mVar9 = *pmVar7;
        sVar8 = sVar8 + 1;
        uVar10 = mVar9 + uVar2 + uVar6;
        *pmVar7 = uVar10;
        uVar2 = (uint)(mVar9 + uVar2 < uVar2) + (uint)(uVar10 < uVar6);
        pmVar7 = pmVar7 + 1;
      }
      pmVar7 = pmVar11 + nblimbs;
      while (uVar2 != 0) {
        if (X->n <= nblimbs) {
          iVar5 = mbedtls_mpi_grow(X,nblimbs + 1);
          if (iVar5 != 0) {
            return iVar5;
          }
          pmVar7 = X->p + nblimbs;
        }
        mVar9 = *pmVar7;
        *pmVar7 = mVar9 + uVar2;
        uVar2 = (uint)(mVar9 + uVar2 < uVar2);
        nblimbs = nblimbs + 1;
        pmVar7 = pmVar7 + 1;
      }
    }
  }
  return iVar3;
}



int mbedtls_mpi_sub_abs(mbedtls_mpi *X,mbedtls_mpi *A,mbedtls_mpi *B)

{
  int iVar1;
  size_t n;
  int iStack44;
  mbedtls_mpi TB;
  
  iVar1 = mbedtls_mpi_cmp_abs(A,B);
  if (iVar1 < 0) {
    return -10;
  }
  iStack44 = 1;
  TB.s = 0;
  TB.n = 0;
  if (B == X) {
    iVar1 = mbedtls_mpi_copy((mbedtls_mpi *)&iStack44,B);
    if (iVar1 != 0) goto cleanup;
    B = (mbedtls_mpi *)&iStack44;
  }
  if ((A == X) || (iVar1 = mbedtls_mpi_copy(X,A), iVar1 == 0)) {
    X->s = 1;
    n = B->n;
    while ((n != 0 && (B->p[n - 1] == 0))) {
      n = n - 1;
    }
    iVar1 = 0;
    mpi_sub_hlp(n,B->p,X->p);
  }
cleanup:
  mbedtls_mpi_free((mbedtls_mpi *)&iStack44);
  return iVar1;
}



int mbedtls_mpi_add_mpi(mbedtls_mpi *X,mbedtls_mpi *A,mbedtls_mpi *B)

{
  int iVar1;
  int iVar2;
  
  iVar1 = A->s;
  if (iVar1 * B->s < 0) {
    iVar2 = mbedtls_mpi_cmp_abs(A,B);
    if (iVar2 < 0) {
      iVar2 = mbedtls_mpi_sub_abs(X,B,A);
      iVar1 = -iVar1;
    }
    else {
      iVar2 = mbedtls_mpi_sub_abs(X,A,B);
    }
  }
  else {
    iVar2 = mbedtls_mpi_add_abs(X,A,B);
  }
  if (iVar2 == 0) {
    X->s = iVar1;
  }
  return iVar2;
}



int mbedtls_mpi_sub_mpi(mbedtls_mpi *X,mbedtls_mpi *A,mbedtls_mpi *B)

{
  int iVar1;
  int iVar2;
  
  iVar1 = A->s;
  if (iVar1 * B->s < 1) {
    iVar2 = mbedtls_mpi_add_abs(X,A,B);
  }
  else {
    iVar2 = mbedtls_mpi_cmp_abs(A,B);
    if (iVar2 < 0) {
      iVar2 = mbedtls_mpi_sub_abs(X,B,A);
      iVar1 = -iVar1;
    }
    else {
      iVar2 = mbedtls_mpi_sub_abs(X,A,B);
    }
  }
  if (iVar2 == 0) {
    X->s = iVar1;
  }
  return iVar2;
}



int mbedtls_mpi_sub_int(mbedtls_mpi *X,mbedtls_mpi *A,mbedtls_mpi_sint b)

{
  int iVar1;
  mbedtls_mpi_uint p [1];
  mbedtls_mpi _B;
  
  p = 1;
  if (b < 0) {
    p = 0xffffffff;
  }
  iVar1 = mbedtls_mpi_sub_mpi(X,A,(mbedtls_mpi *)p);
  return iVar1;
}



// WARNING: Variable defined which should be unmapped: TB

int mbedtls_mpi_mul_mpi(mbedtls_mpi *X,mbedtls_mpi *A,mbedtls_mpi *B)

{
  int iVar1;
  size_t sVar2;
  size_t i;
  int local_38;
  mbedtls_mpi TA;
  mbedtls_mpi TB;
  
  local_38 = 1;
  TA.s = 0;
  TA.n = 0;
  TA.p = (mbedtls_mpi_uint *)0x1;
  if (X == A) {
    iVar1 = mbedtls_mpi_copy((mbedtls_mpi *)&local_38,A);
    A = (mbedtls_mpi *)&local_38;
    if (iVar1 != 0) goto cleanup;
  }
  if (X == B) {
    iVar1 = mbedtls_mpi_copy((mbedtls_mpi *)&TA.p,X);
    if (iVar1 != 0) goto cleanup;
    B = (mbedtls_mpi *)&TA.p;
  }
  i = A->n;
  while ((i != 0 && (A->p[i - 1] == 0))) {
    i = i - 1;
  }
  sVar2 = B->n;
  while ((sVar2 != 0 && (B->p[sVar2 - 1] == 0))) {
    sVar2 = sVar2 - 1;
  }
  iVar1 = mbedtls_mpi_grow(X,i + sVar2);
  if ((iVar1 == 0) && (iVar1 = mbedtls_mpi_lset(X,0), iVar1 == 0)) {
    while (sVar2 = sVar2 - 1, sVar2 != 0xffffffff) {
      mpi_mul_hlp(i,A->p,X->p + sVar2,B->p[sVar2]);
    }
    X->s = A->s * B->s;
  }
cleanup:
  mbedtls_mpi_free((mbedtls_mpi *)&TA.p);
  mbedtls_mpi_free((mbedtls_mpi *)&local_38);
  return iVar1;
}



int mbedtls_mpi_mul_int(mbedtls_mpi *X,mbedtls_mpi *A,mbedtls_mpi_uint b)

{
  int iVar1;
  mbedtls_mpi_uint p [1];
  mbedtls_mpi _B;
  
  p = 1;
  iVar1 = mbedtls_mpi_mul_mpi(X,A,(mbedtls_mpi *)p);
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int mbedtls_mpi_div_mpi(mbedtls_mpi *Q,mbedtls_mpi *R,mbedtls_mpi *A,mbedtls_mpi *B)

{
  int iVar1;
  int iVar2;
  int iVar3;
  size_t count;
  int iVar4;
  undefined4 uVar5;
  uint uVar6;
  uint uVar7;
  undefined4 uVar8;
  int *piVar9;
  size_t count_00;
  uint uVar10;
  int iVar11;
  uint uVar12;
  undefined4 *puVar13;
  int iStack124;
  mbedtls_mpi X;
  mbedtls_mpi Y;
  mbedtls_mpi Z;
  mbedtls_mpi T1;
  mbedtls_mpi T2;
  
  iVar3 = mbedtls_mpi_cmp_int(B,0);
  if (iVar3 == 0) {
    return -0xc;
  }
  iStack124 = 1;
  X.s = 0;
  X.n = 0;
  X.p = (mbedtls_mpi_uint *)0x1;
  Y.s = 0;
  Y.n = 0;
  Y.p = (mbedtls_mpi_uint *)0x1;
  Z.s = 0;
  Z.n = 0;
  Z.p = (mbedtls_mpi_uint *)0x1;
  T1.s = 0;
  T1.n = 0;
  T1.p = (mbedtls_mpi_uint *)0x1;
  iVar3 = mbedtls_mpi_cmp_abs(A,B);
  if (iVar3 < 0) {
    if (((Q == (mbedtls_mpi *)0x0) || (iVar3 = mbedtls_mpi_lset(Q,0), iVar3 == 0)) &&
       ((R == (mbedtls_mpi *)0x0 || (iVar3 = mbedtls_mpi_copy(R,A), iVar3 == 0)))) {
      return 0;
    }
  }
  else {
    iVar3 = mbedtls_mpi_copy((mbedtls_mpi *)&iStack124,A);
    if ((iVar3 == 0) && (iVar3 = mbedtls_mpi_copy((mbedtls_mpi *)&X.p,B), iVar3 == 0)) {
      X.p = (mbedtls_mpi_uint *)0x1;
      iStack124 = 1;
      iVar3 = mbedtls_mpi_grow((mbedtls_mpi *)&Y.p,A->n + 2);
      if ((iVar3 == 0) &&
         (((iVar3 = mbedtls_mpi_lset((mbedtls_mpi *)&Y.p,0), iVar3 == 0 &&
           (iVar3 = mbedtls_mpi_grow((mbedtls_mpi *)&Z.p,2), iVar3 == 0)) &&
          (iVar3 = mbedtls_mpi_grow((mbedtls_mpi *)&T1.p,3), iVar3 == 0)))) {
        count = mbedtls_mpi_bitlen((mbedtls_mpi *)&X.p);
        if ((count & 0x1f) == 0x1f) {
          count = 0;
        }
        else {
          count = 0x1f - (count & 0x1f);
          iVar3 = mbedtls_mpi_shift_l((mbedtls_mpi *)&iStack124,count);
          if ((iVar3 != 0) || (iVar3 = mbedtls_mpi_shift_l((mbedtls_mpi *)&X.p,count), iVar3 != 0))
          goto cleanup;
        }
        iVar4 = Y.s;
        uVar10 = X.s;
        iVar1 = X.s - Y.s;
        count_00 = iVar1 * 0x20;
        iVar3 = mbedtls_mpi_shift_l((mbedtls_mpi *)&X.p,count_00);
        while (iVar3 == 0) {
          iVar3 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&iStack124,(mbedtls_mpi *)&X.p);
          if (iVar3 < 0) {
            iVar1 = mbedtls_mpi_shift_r((mbedtls_mpi *)&X.p,count_00);
            iVar3 = iVar1;
            if (iVar1 == 0) {
              uVar12 = iVar4 - 1;
              iVar2 = ((uVar10 + 0x3fffffff) - iVar4) * 4;
              goto LAB_23061c8a;
            }
            break;
          }
          piVar9 = (int *)(Z.n + iVar1 * 4);
          *piVar9 = *piVar9 + 1;
          iVar3 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)&iStack124,(mbedtls_mpi *)&iStack124,
                                      (mbedtls_mpi *)&X.p);
        }
      }
    }
  }
cleanup:
  mbedtls_mpi_free((mbedtls_mpi *)&iStack124);
  mbedtls_mpi_free((mbedtls_mpi *)&X.p);
  mbedtls_mpi_free((mbedtls_mpi *)&Y.p);
  mbedtls_mpi_free((mbedtls_mpi *)&Z.p);
  mbedtls_mpi_free((mbedtls_mpi *)&T1.p);
  return iVar3;
LAB_23061c8a:
  uVar10 = uVar10 - 1;
  if (uVar10 <= uVar12) goto code_r0x23061c8e;
  iVar11 = uVar10 * 4;
  uVar6 = *(uint *)(X.n + iVar11);
  uVar7 = *(uint *)(Y.n + uVar12 * 4);
  puVar13 = (undefined4 *)(Z.n + iVar2);
  if (uVar6 < uVar7) {
    uVar5 = *(undefined4 *)(X.n + iVar11 + -4);
    uVar8 = 0xffffffff;
    if ((uVar7 != 0) && (__udivdi3(), uVar8 = uVar5, uVar6 != 0)) {
      uVar8 = 0xffffffff;
    }
    *puVar13 = uVar8;
  }
  else {
    *puVar13 = 0xffffffff;
  }
  *(int *)(Z.n + iVar2) = *(int *)(Z.n + iVar2) + 1;
  do {
    *(int *)(Z.n + iVar2) = *(int *)(Z.n + iVar2) + -1;
    iVar3 = mbedtls_mpi_lset((mbedtls_mpi *)&Z.p,0);
    if (iVar3 != 0) goto cleanup;
    uVar8 = 0;
    if (uVar12 != 0) {
      uVar8 = *(undefined4 *)(Y.n + iVar4 * 4 + -8);
    }
    *(undefined4 *)T1.n = uVar8;
    *(undefined4 *)(T1.n + 4) = *(undefined4 *)(Y.n + uVar12 * 4);
    iVar3 = mbedtls_mpi_mul_int((mbedtls_mpi *)&Z.p,(mbedtls_mpi *)&Z.p,
                                *(mbedtls_mpi_uint *)(Z.n + iVar2));
    if ((iVar3 != 0) || (iVar3 = mbedtls_mpi_lset((mbedtls_mpi *)&T1.p,0), iVar3 != 0))
    goto cleanup;
    ___EM_SIZE = 0;
    if (uVar10 != 1) {
      ___EM_SIZE = *(undefined4 *)(X.n + iVar11 + -8);
    }
    _DAT_00000004 = *(undefined4 *)(X.n + iVar11 + -4);
    _DAT_00000008 = *(mbedtls_mpi_uint *)(X.n + iVar11);
    iVar3 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&Z.p,(mbedtls_mpi *)&T1.p);
  } while (0 < iVar3);
  iVar3 = mbedtls_mpi_mul_int((mbedtls_mpi *)&Z.p,(mbedtls_mpi *)&X.p,
                              *(mbedtls_mpi_uint *)(Z.n + iVar2));
  if (iVar3 != 0) goto cleanup;
  iVar3 = mbedtls_mpi_shift_l((mbedtls_mpi *)&Z.p,iVar2 << 3);
  if ((iVar3 != 0) ||
     (iVar3 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)&iStack124,(mbedtls_mpi *)&iStack124,
                                  (mbedtls_mpi *)&Z.p), iVar3 != 0)) goto cleanup;
  iVar3 = mbedtls_mpi_cmp_int((mbedtls_mpi *)&iStack124,0);
  if (iVar3 < 0) {
    iVar3 = mbedtls_mpi_copy((mbedtls_mpi *)&Z.p,(mbedtls_mpi *)&X.p);
    if (((iVar3 != 0) || (iVar3 = mbedtls_mpi_shift_l((mbedtls_mpi *)&Z.p,iVar2 << 3), iVar3 != 0))
       || (iVar3 = mbedtls_mpi_add_mpi((mbedtls_mpi *)&iStack124,(mbedtls_mpi *)&iStack124,
                                       (mbedtls_mpi *)&Z.p), iVar3 != 0)) goto cleanup;
    *(int *)(Z.n + iVar2) = *(int *)(Z.n + iVar2) + -1;
  }
  iVar2 = iVar2 + -4;
  goto LAB_23061c8a;
code_r0x23061c8e:
  if (Q != (mbedtls_mpi *)0x0) {
    iVar3 = mbedtls_mpi_copy(Q,(mbedtls_mpi *)&Y.p);
    if (iVar3 != 0) goto cleanup;
    Q->s = A->s * B->s;
  }
  iVar3 = iVar1;
  if ((R != (mbedtls_mpi *)0x0) &&
     (iVar3 = mbedtls_mpi_shift_r((mbedtls_mpi *)&iStack124,count), iVar3 == 0)) {
    iStack124 = A->s;
    iVar3 = mbedtls_mpi_copy(R,(mbedtls_mpi *)&iStack124);
    if ((iVar3 == 0) && (iVar4 = mbedtls_mpi_cmp_int(R,0), iVar3 = iVar1, iVar4 == 0)) {
      R->s = 1;
      iVar3 = 0;
    }
  }
  goto cleanup;
}



int mbedtls_mpi_mod_mpi(mbedtls_mpi *R,mbedtls_mpi *A,mbedtls_mpi *B)

{
  int iVar1;
  int iVar2;
  
  iVar1 = mbedtls_mpi_cmp_int(B,0);
  if (iVar1 < 0) {
    return -10;
  }
  iVar2 = mbedtls_mpi_div_mpi((mbedtls_mpi *)0x0,R,A,B);
  iVar1 = iVar2;
  while( true ) {
    if (iVar1 != 0) {
      return iVar1;
    }
    iVar1 = mbedtls_mpi_cmp_int(R,0);
    if (-1 < iVar1) break;
    iVar1 = mbedtls_mpi_add_mpi(R,R,B);
  }
  do {
    iVar1 = mbedtls_mpi_cmp_mpi(R,B);
    if (iVar1 < 0) {
      return iVar2;
    }
    iVar1 = mbedtls_mpi_sub_mpi(R,R,B);
  } while (iVar1 == 0);
  return iVar1;
}



int mbedtls_mpi_exp_mod(mbedtls_mpi *X,mbedtls_mpi *A,mbedtls_mpi *E,mbedtls_mpi *N,mbedtls_mpi *_RR
                       )

{
  uint uVar1;
  mbedtls_mpi_uint mm;
  int iVar2;
  size_t nblimbs;
  mbedtls_mpi *X_00;
  mbedtls_mpi *X_01;
  uint uVar3;
  int iVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  size_t sVar10;
  mbedtls_mpi_uint mStack1652;
  mbedtls_mpi_uint z;
  mbedtls_mpi RR;
  mbedtls_mpi T;
  mbedtls_mpi Apos;
  mbedtls_mpi U;
  mbedtls_mpi W [128];
  
  iVar2 = mbedtls_mpi_cmp_int(N,0);
  if (iVar2 < 0) {
    return -4;
  }
  uVar6 = *N->p;
  uVar9 = uVar6 & 1;
  if (uVar9 == 0) {
    return -4;
  }
  iVar2 = mbedtls_mpi_cmp_int(E,0);
  if (iVar2 < 0) {
    return -4;
  }
  iVar2 = ((uVar6 + 2) * 2 & 8) + uVar6;
  iVar4 = 3;
  do {
    iVar4 = iVar4 + -1;
    iVar2 = iVar2 * (2 - uVar6 * iVar2);
  } while (iVar4 != 0);
  z = 1;
  RR.p = (mbedtls_mpi_uint *)0x1;
  T.p = (mbedtls_mpi_uint *)0x1;
  RR.s = 0;
  RR.n = 0;
  T.s = 0;
  T.n = 0;
  Apos.s = 0;
  Apos.n = 0;
  memset(&U.p,0,0x600);
  nblimbs = mbedtls_mpi_bitlen(E);
  uVar6 = 6;
  if ((((nblimbs < 0x2a0) && (uVar6 = 5, nblimbs < 0xf0)) && (uVar6 = 4, nblimbs < 0x50)) &&
     (uVar6 = 3, nblimbs < 0x18)) {
    uVar6 = uVar9;
  }
  nblimbs = N->n + 1;
  iVar4 = mbedtls_mpi_grow(X,nblimbs);
  if (((iVar4 != 0) || (iVar4 = mbedtls_mpi_grow((mbedtls_mpi *)&W[0].p,nblimbs), iVar4 != 0)) ||
     (iVar4 = mbedtls_mpi_grow((mbedtls_mpi *)&RR.p,nblimbs * 2), iVar4 != 0)) goto cleanup;
  iVar5 = A->s;
  if (iVar5 == -1) {
    iVar4 = mbedtls_mpi_copy((mbedtls_mpi *)&T.p,A);
    if (iVar4 != 0) goto cleanup;
    T.p = (mbedtls_mpi_uint *)0x1;
    A = (mbedtls_mpi *)&T.p;
  }
  if ((_RR == (mbedtls_mpi *)0x0) || (_RR->p == (mbedtls_mpi_uint *)0x0)) {
    iVar4 = mbedtls_mpi_lset((mbedtls_mpi *)&z,1);
    if ((iVar4 != 0) ||
       ((iVar4 = mbedtls_mpi_shift_l((mbedtls_mpi *)&z,N->n << 6), iVar4 != 0 ||
        (iVar4 = mbedtls_mpi_mod_mpi((mbedtls_mpi *)&z,(mbedtls_mpi *)&z,N), iVar4 != 0))))
    goto cleanup;
    if (_RR != (mbedtls_mpi *)0x0) {
      X_00 = _RR;
      X_01 = (mbedtls_mpi *)&z;
      goto LAB_23062022;
    }
  }
  else {
    X_00 = (mbedtls_mpi *)&z;
    X_01 = _RR;
LAB_23062022:
    memcpy(X_00,X_01,0xc);
  }
  iVar4 = mbedtls_mpi_cmp_mpi(A,N);
  if (iVar4 < 0) {
    iVar4 = mbedtls_mpi_copy((mbedtls_mpi *)&W[0].p,A);
  }
  else {
    iVar4 = mbedtls_mpi_mod_mpi((mbedtls_mpi *)&W[0].p,A,N);
  }
  if (iVar4 == 0) {
    mm = -iVar2;
    iVar4 = mpi_montmul((mbedtls_mpi *)&W[0].p,(mbedtls_mpi *)&z,N,mm,(mbedtls_mpi *)&RR.p);
    if ((iVar4 == 0) && (iVar4 = mbedtls_mpi_copy(X,(mbedtls_mpi *)&z), iVar4 == 0)) {
      U.n = (size_t)&mStack1652;
      mStack1652 = 1;
      Apos.p = (mbedtls_mpi_uint *)0x1;
      U.s = 1;
      iVar4 = mpi_montmul(X,(mbedtls_mpi *)&Apos.p,N,mm,(mbedtls_mpi *)&RR.p);
      if (iVar4 == 0) {
        if (uVar6 == 1) {
LAB_2306208c:
          nblimbs = E->n;
          uVar7 = 0;
          uVar1 = 0;
          do {
            sVar10 = 0;
            uVar8 = 0;
LAB_23062182:
            do {
              if (uVar7 == 0) {
                if (nblimbs == 0) {
                  goto LAB_23062190;
                }
                nblimbs = nblimbs - 1;
                uVar7 = 0x20;
              }
              uVar7 = uVar7 - 1;
              uVar3 = E->p[nblimbs] >> (uVar7 & 0x1f) & 1;
              if (uVar3 == 0) {
                if (uVar1 == 0) goto LAB_23062182;
                if (uVar1 == 1) {
                  iVar4 = mpi_montmul(X,X,N,mm,(mbedtls_mpi *)&RR.p);
                  if (iVar4 != 0) goto cleanup;
                  goto LAB_23062182;
                }
              }
              sVar10 = sVar10 + 1;
              uVar8 = uVar8 | uVar3 << (uVar6 - sVar10 & 0x1f);
              uVar1 = 2;
            } while (uVar6 != sVar10);
            uVar1 = 0;
            do {
              iVar4 = mpi_montmul(X,X,N,mm,(mbedtls_mpi *)&RR.p);
              if (iVar4 != 0) goto cleanup;
              uVar1 = uVar1 + 1;
            } while (uVar1 < sVar10);
            iVar4 = mpi_montmul(X,(mbedtls_mpi *)&(&U)[uVar8].p,N,mm,(mbedtls_mpi *)&RR.p);
            uVar1 = uVar9;
          } while (iVar4 == 0);
        }
        else {
          uVar7 = uVar6 - 1;
          X_00 = (mbedtls_mpi *)((int)&U.p + (0xc << (uVar7 & 0x1f)));
          iVar4 = mbedtls_mpi_grow(X_00,N->n + 1);
          uVar1 = 1 << (uVar7 & 0x1f);
          if ((iVar4 == 0) && (iVar4 = mbedtls_mpi_copy(X_00,(mbedtls_mpi *)&W[0].p), iVar4 == 0)) {
            uVar8 = 0;
            do {
              iVar4 = mpi_montmul(X_00,X_00,N,mm,(mbedtls_mpi *)&RR.p);
              if (iVar4 != 0) goto cleanup;
              uVar8 = uVar8 + 1;
            } while (uVar8 < uVar7);
            do {
              uVar1 = uVar1 + 1;
              if ((uint)(1 << uVar6) <= uVar1) goto LAB_2306208c;
              X_01 = X_00 + 1;
              iVar4 = mbedtls_mpi_grow(X_01,N->n + 1);
            } while (((iVar4 == 0) && (iVar4 = mbedtls_mpi_copy(X_01,X_00), iVar4 == 0)) &&
                    (iVar4 = mpi_montmul(X_01,(mbedtls_mpi *)&W[0].p,N,mm,(mbedtls_mpi *)&RR.p),
                    X_00 = X_01, iVar4 == 0));
          }
        }
      }
    }
  }
cleanup:
  uVar9 = 1 << (uVar6 - 1 & 0x1f);
  while (uVar9 < (uint)(1 << uVar6)) {
    mbedtls_mpi_free((mbedtls_mpi *)&(&U)[uVar9].p);
    uVar9 = uVar9 + 1;
  }
  mbedtls_mpi_free((mbedtls_mpi *)&W[0].p);
  mbedtls_mpi_free((mbedtls_mpi *)&RR.p);
  mbedtls_mpi_free((mbedtls_mpi *)&T.p);
  if ((_RR == (mbedtls_mpi *)0x0) || (_RR->p == (mbedtls_mpi_uint *)0x0)) {
    mbedtls_mpi_free((mbedtls_mpi *)&z);
  }
  return iVar4;
LAB_23062190:
  if (nblimbs == sVar10) goto code_r0x23062194;
  iVar4 = mpi_montmul(X,X,N,mm,(mbedtls_mpi *)&RR.p);
  if ((iVar4 != 0) ||
     ((uVar8 = uVar8 << 1, (1 << uVar6 & uVar8) != 0 &&
      (iVar4 = mpi_montmul(X,(mbedtls_mpi *)&W[0].p,N,mm,(mbedtls_mpi *)&RR.p), iVar4 != 0))))
  goto cleanup;
  nblimbs = nblimbs + 1;
  goto LAB_23062190;
code_r0x23062194:
  mStack1652 = 1;
  Apos.p = (mbedtls_mpi_uint *)0x1;
  U.s = 1;
  U.n = (size_t)&mStack1652;
  iVar4 = mpi_montmul(X,(mbedtls_mpi *)&Apos.p,N,mm,(mbedtls_mpi *)&RR.p);
  if ((iVar4 == 0) && (iVar5 == -1)) {
    X->s = -1;
    iVar4 = mbedtls_mpi_add_mpi(X,N,X);
  }
  goto cleanup;
}



// WARNING: Variable defined which should be unmapped: TB

int mbedtls_mpi_gcd(mbedtls_mpi *G,mbedtls_mpi *A,mbedtls_mpi *B)

{
  mbedtls_mpi *pmVar1;
  int iVar2;
  size_t count;
  size_t count_00;
  int iStack52;
  mbedtls_mpi TG;
  mbedtls_mpi TA;
  mbedtls_mpi TB;
  
  iStack52 = 1;
  TG.s = 0;
  TG.n = 0;
  TG.p = (mbedtls_mpi_uint *)0x1;
  TA.s = 0;
  TA.n = 0;
  TA.p = (mbedtls_mpi_uint *)0x1;
  iVar2 = mbedtls_mpi_copy((mbedtls_mpi *)&TG.p,A);
  if ((iVar2 == 0) && (iVar2 = mbedtls_mpi_copy((mbedtls_mpi *)&TA.p,B), iVar2 == 0)) {
    count = mbedtls_mpi_lsb((mbedtls_mpi *)&TG.p);
    count_00 = mbedtls_mpi_lsb((mbedtls_mpi *)&TA.p);
    if (count_00 < count) {
      count = count_00;
    }
    iVar2 = mbedtls_mpi_shift_r((mbedtls_mpi *)&TG.p,count);
    if ((iVar2 == 0) && (iVar2 = mbedtls_mpi_shift_r((mbedtls_mpi *)&TA.p,count), iVar2 == 0)) {
      TA.p = (mbedtls_mpi_uint *)0x1;
      TG.p = (mbedtls_mpi_uint *)0x1;
      do {
        iVar2 = mbedtls_mpi_cmp_int((mbedtls_mpi *)&TG.p,0);
        if (iVar2 == 0) {
          iVar2 = mbedtls_mpi_shift_l((mbedtls_mpi *)&TA.p,count);
          if (iVar2 == 0) {
            iVar2 = mbedtls_mpi_copy(G,(mbedtls_mpi *)&TA.p);
          }
          break;
        }
        count_00 = mbedtls_mpi_lsb((mbedtls_mpi *)&TG.p);
        iVar2 = mbedtls_mpi_shift_r((mbedtls_mpi *)&TG.p,count_00);
        if (iVar2 != 0) break;
        count_00 = mbedtls_mpi_lsb((mbedtls_mpi *)&TA.p);
        iVar2 = mbedtls_mpi_shift_r((mbedtls_mpi *)&TA.p,count_00);
        if (iVar2 != 0) break;
        iVar2 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&TG.p,(mbedtls_mpi *)&TA.p);
        if (iVar2 < 0) {
          iVar2 = mbedtls_mpi_sub_abs((mbedtls_mpi *)&TA.p,(mbedtls_mpi *)&TA.p,(mbedtls_mpi *)&TG.p
                                     );
          if (iVar2 != 0) break;
          pmVar1 = &TA;
        }
        else {
          iVar2 = mbedtls_mpi_sub_abs((mbedtls_mpi *)&TG.p,(mbedtls_mpi *)&TG.p,(mbedtls_mpi *)&TA.p
                                     );
          if (iVar2 != 0) break;
          pmVar1 = &TG;
        }
        iVar2 = mbedtls_mpi_shift_r((mbedtls_mpi *)&pmVar1->p,1);
      } while (iVar2 == 0);
    }
  }
  mbedtls_mpi_free((mbedtls_mpi *)&iStack52);
  mbedtls_mpi_free((mbedtls_mpi *)&TG.p);
  mbedtls_mpi_free((mbedtls_mpi *)&TA.p);
  return iVar2;
}



int mbedtls_mpi_fill_random
              (mbedtls_mpi *X,size_t size,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng
              )

{
  int iVar1;
  uchar auStack1040 [4];
  uchar buf [1024];
  
  if (size < 0x401) {
    iVar1 = (*f_rng)(p_rng,auStack1040,size);
    if (iVar1 == 0) {
      iVar1 = mbedtls_mpi_read_binary(X,auStack1040,size);
    }
    return iVar1;
  }
  return -4;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int mbedtls_mpi_inv_mod(mbedtls_mpi *X,mbedtls_mpi *A,mbedtls_mpi *N)

{
  mbedtls_mpi *pmVar1;
  mbedtls_mpi *pmVar2;
  int iVar3;
  int iVar4;
  int iStack140;
  mbedtls_mpi G;
  mbedtls_mpi TA;
  mbedtls_mpi TU;
  mbedtls_mpi U1;
  mbedtls_mpi U2;
  mbedtls_mpi TB;
  mbedtls_mpi TV;
  mbedtls_mpi V1;
  mbedtls_mpi V2;
  
  iVar3 = mbedtls_mpi_cmp_int(N,0);
  if (iVar3 < 1) {
    return -4;
  }
  G.p = (mbedtls_mpi_uint *)0x1;
  TA.s = 0;
  TA.n = 0;
  TA.p = (mbedtls_mpi_uint *)0x1;
  TU.s = 0;
  TU.n = 0;
  TU.p = (mbedtls_mpi_uint *)0x1;
  U1.s = 0;
  U1.n = 0;
  U1.p = (mbedtls_mpi_uint *)0x1;
  U2.s = 0;
  U2.n = 0;
  iStack140 = 1;
  G.s = 0;
  G.n = 0;
  U2.p = (mbedtls_mpi_uint *)0x1;
  TB.s = 0;
  TB.n = 0;
  TB.p = (mbedtls_mpi_uint *)0x1;
  TV.s = 0;
  TV.n = 0;
  TV.p = (mbedtls_mpi_uint *)0x1;
  V1.s = 0;
  V1.n = 0;
  V1.p = (mbedtls_mpi_uint *)0x1;
  iVar3 = mbedtls_mpi_gcd((mbedtls_mpi *)&iStack140,A,N);
  if (iVar3 == 0) {
    iVar4 = mbedtls_mpi_cmp_int((mbedtls_mpi *)&iStack140,1);
    iVar3 = -0xe;
    if (((((iVar4 == 0) && (iVar3 = mbedtls_mpi_mod_mpi((mbedtls_mpi *)&G.p,A,N), iVar3 == 0)) &&
         (iVar3 = mbedtls_mpi_copy((mbedtls_mpi *)&TA.p,(mbedtls_mpi *)&G.p), iVar3 == 0)) &&
        ((iVar3 = mbedtls_mpi_copy((mbedtls_mpi *)&U2.p,N), iVar3 == 0 &&
         (iVar3 = mbedtls_mpi_copy((mbedtls_mpi *)&TB.p,N), iVar3 == 0)))) &&
       ((iVar3 = mbedtls_mpi_lset((mbedtls_mpi *)&TU.p,1), iVar3 == 0 &&
        ((iVar3 = mbedtls_mpi_lset((mbedtls_mpi *)&U1.p,0), iVar3 == 0 &&
         (iVar3 = mbedtls_mpi_lset((mbedtls_mpi *)&TV.p,0), iVar3 == 0)))))) {
      iVar3 = mbedtls_mpi_lset((mbedtls_mpi *)&V1.p,1);
      while (iVar3 == 0) {
        while ((*(uint *)TU.n & 1) != 0) {
          while ((*(uint *)TV.n & 1) == 0) {
            iVar3 = mbedtls_mpi_shift_r((mbedtls_mpi *)&TB.p,1);
            if ((iVar3 != 0) ||
               (((((*(uint *)V1.n & 1) != 0 || ((___EM_SIZE & 1) != 0)) &&
                 ((iVar3 = mbedtls_mpi_add_mpi((mbedtls_mpi *)&TV.p,(mbedtls_mpi *)&TV.p,
                                               (mbedtls_mpi *)&U2.p), iVar3 != 0 ||
                  (iVar3 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)&V1.p,(mbedtls_mpi *)&V1.p,
                                               (mbedtls_mpi *)&G.p), iVar3 != 0)))) ||
                ((iVar3 = mbedtls_mpi_shift_r((mbedtls_mpi *)&TV.p,1), iVar3 != 0 ||
                 (iVar3 = mbedtls_mpi_shift_r((mbedtls_mpi *)&V1.p,1), iVar3 != 0))))))
            goto cleanup;
          }
          iVar3 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&TA.p,(mbedtls_mpi *)&TB.p);
          if (iVar3 < 0) {
            iVar3 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)&TB.p,(mbedtls_mpi *)&TB.p,
                                        (mbedtls_mpi *)&TA.p);
            if ((iVar3 != 0) ||
               (iVar3 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)&TV.p,(mbedtls_mpi *)&TV.p,
                                            (mbedtls_mpi *)&TU.p), iVar3 != 0)) goto cleanup;
            pmVar1 = &U1;
            pmVar2 = &V1;
          }
          else {
            iVar3 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)&TA.p,(mbedtls_mpi *)&TA.p,
                                        (mbedtls_mpi *)&TB.p);
            if ((iVar3 != 0) ||
               (iVar3 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)&TU.p,(mbedtls_mpi *)&TU.p,
                                            (mbedtls_mpi *)&TV.p), iVar3 != 0)) goto cleanup;
            pmVar1 = &V1;
            pmVar2 = &U1;
          }
          iVar3 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)&pmVar2->p,(mbedtls_mpi *)&pmVar2->p,
                                      (mbedtls_mpi *)&pmVar1->p);
          if (iVar3 != 0) goto cleanup;
          iVar3 = mbedtls_mpi_cmp_int((mbedtls_mpi *)&TA.p,0);
          if (iVar3 == 0) goto LAB_23062556;
        }
        iVar3 = mbedtls_mpi_shift_r((mbedtls_mpi *)&TA.p,1);
        if (((iVar3 != 0) ||
            ((((*(uint *)U1.n & 1) != 0 || ((*(uint *)U2.n & 1) != 0)) &&
             ((iVar3 = mbedtls_mpi_add_mpi((mbedtls_mpi *)&TU.p,(mbedtls_mpi *)&TU.p,
                                           (mbedtls_mpi *)&U2.p), iVar3 != 0 ||
              (iVar3 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)&U1.p,(mbedtls_mpi *)&U1.p,
                                           (mbedtls_mpi *)&G.p), iVar3 != 0)))))) ||
           (iVar3 = mbedtls_mpi_shift_r((mbedtls_mpi *)&TU.p,1), iVar3 != 0)) break;
        iVar3 = mbedtls_mpi_shift_r((mbedtls_mpi *)&U1.p,1);
      }
    }
  }
  goto cleanup;
  while (iVar3 = mbedtls_mpi_add_mpi((mbedtls_mpi *)&TV.p,(mbedtls_mpi *)&TV.p,N), iVar3 == 0) {
LAB_23062556:
    iVar3 = mbedtls_mpi_cmp_int((mbedtls_mpi *)&TV.p,0);
    if (-1 < iVar3) goto LAB_23062562;
  }
  goto cleanup;
  while (iVar3 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)&TV.p,(mbedtls_mpi *)&TV.p,N), iVar3 == 0) {
LAB_23062562:
    iVar3 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&TV.p,N);
    if (iVar3 < 0) {
      iVar3 = mbedtls_mpi_copy(X,(mbedtls_mpi *)&TV.p);
      break;
    }
  }
cleanup:
  mbedtls_mpi_free((mbedtls_mpi *)&G.p);
  mbedtls_mpi_free((mbedtls_mpi *)&TA.p);
  mbedtls_mpi_free((mbedtls_mpi *)&TU.p);
  mbedtls_mpi_free((mbedtls_mpi *)&U1.p);
  mbedtls_mpi_free((mbedtls_mpi *)&iStack140);
  mbedtls_mpi_free((mbedtls_mpi *)&U2.p);
  mbedtls_mpi_free((mbedtls_mpi *)&TB.p);
  mbedtls_mpi_free((mbedtls_mpi *)&TV.p);
  mbedtls_mpi_free((mbedtls_mpi *)&V1.p);
  return iVar3;
}



uint mbedtls_cipher_get_block_size(mbedtls_cipher_context_t *ctx)

{
  if ((ctx != (mbedtls_cipher_context_t *)0x0) && (ctx->cipher_info != (mbedtls_cipher_info_t *)0x0)
     ) {
    return ctx->cipher_info->block_size;
  }
  return 0;
}



void add_pkcs_padding(uchar *output,size_t output_len,size_t data_len)

{
  uint uVar1;
  
  uVar1 = 0;
  while (uVar1 < output_len - data_len) {
    output[data_len + uVar1] = (uchar)(output_len - data_len);
    uVar1 = uVar1 + 1 & 0xff;
  }
  return;
}



int get_pkcs_padding(uchar *input,size_t input_len,size_t *data_len)

{
  byte bVar1;
  bool bVar2;
  byte *pbVar3;
  uint uVar4;
  bool bVar5;
  uint uVar6;
  
  if ((input == (uchar *)0x0) || (data_len == (size_t *)0x0)) {
    return -0x6100;
  }
  bVar1 = input[input_len - 1];
  uVar6 = input_len - bVar1;
  bVar5 = input_len < bVar1 || bVar1 == 0;
  *data_len = uVar6;
  uVar4 = 0;
  while (uVar4 != input_len) {
    pbVar3 = input + uVar4;
    bVar2 = uVar6 <= uVar4;
    uVar4 = uVar4 + 1;
    bVar5 = (bool)(bVar5 | bVar2 * (bVar1 ^ *pbVar3));
  }
  if (bVar5 == false) {
    return 0;
  }
  return -0x6200;
}



void add_zeros_padding(uchar *output,size_t output_len,size_t data_len)

{
  if (output_len <= data_len) {
    return;
  }
  output[data_len] = '\0';
  add_zeros_padding(output,output_len,data_len + 1);
  return;
}



int get_no_padding(uchar *input,size_t input_len,size_t *data_len)

{
  if ((input != (uchar *)0x0) && (data_len != (size_t *)0x0)) {
    *data_len = input_len;
    return 0;
  }
  return -0x6100;
}



int get_zeros_padding(uchar *input,size_t input_len,size_t *data_len)

{
  uint uVar1;
  uint uVar2;
  
  if ((input != (uchar *)0x0) && (data_len != (size_t *)0x0)) {
    *data_len = 0;
    uVar2 = 0;
    while (input_len != 0) {
      uVar1 = input[input_len - 1] != '\0' | uVar2;
      *data_len = (uVar2 ^ uVar1) * input_len | *data_len;
      input_len = input_len - 1;
      uVar2 = uVar1;
    }
    return 0;
  }
  return -0x6100;
}



mbedtls_cipher_info_t * mbedtls_cipher_info_from_type(mbedtls_cipher_type_t cipher_type)

{
  undefined3 in_register_00002029;
  mbedtls_cipher_definition_t *pmVar1;
  
  pmVar1 = mbedtls_cipher_definitions;
  while ((pmVar1->info != (mbedtls_cipher_info_t *)0x0 &&
         ((uint)pmVar1->type != CONCAT31(in_register_00002029,cipher_type)))) {
    pmVar1 = pmVar1 + 1;
  }
  return pmVar1->info;
}



mbedtls_cipher_info_t *
mbedtls_cipher_info_from_values
          (mbedtls_cipher_id_t cipher_id,int key_bitlen,mbedtls_cipher_mode_t mode)

{
  undefined3 in_register_00002029;
  undefined3 in_register_00002031;
  mbedtls_cipher_definition_t *pmVar1;
  mbedtls_cipher_info_t *pmVar2;
  
  pmVar1 = mbedtls_cipher_definitions;
  while ((pmVar2 = pmVar1->info, pmVar2 != (mbedtls_cipher_info_t *)0x0 &&
         ((((uint)pmVar2->base->cipher != CONCAT31(in_register_00002029,cipher_id) ||
           (pmVar2->key_bitlen != key_bitlen)) ||
          ((uint)pmVar2->mode != CONCAT31(in_register_00002031,mode)))))) {
    pmVar1 = pmVar1 + 1;
  }
  return pmVar2;
}



void mbedtls_cipher_init(mbedtls_cipher_context_t *ctx)

{
  memset(ctx,0,0x40);
  return;
}



void mbedtls_cipher_free(mbedtls_cipher_context_t *ctx)

{
  mbedtls_cipher_context_t *pmVar1;
  
  if (ctx != (mbedtls_cipher_context_t *)0x0) {
    if (ctx->cipher_ctx != (void *)0x0) {
      (*ctx->cipher_info->base->ctx_free_func)(ctx->cipher_ctx);
    }
    pmVar1 = ctx + 1;
    while (ctx != pmVar1) {
      *(undefined *)&ctx->cipher_info = 0;
      ctx = (mbedtls_cipher_context_t *)((int)&ctx->cipher_info + 1);
    }
    return;
  }
  return;
}



// WARNING: Exceeded maximum restarts with more pending

int mbedtls_cipher_setkey
              (mbedtls_cipher_context_t *ctx,uchar *key,int key_bitlen,mbedtls_operation_t operation
              )

{
  anon_subr_int_void_ptr_uchar_ptr_uint_for_setkey_enc_func *UNRECOVERED_JUMPTABLE;
  int iVar1;
  undefined3 in_register_00002035;
  mbedtls_cipher_info_t *pmVar2;
  
  if (((ctx != (mbedtls_cipher_context_t *)0x0) &&
      (pmVar2 = ctx->cipher_info, pmVar2 != (mbedtls_cipher_info_t *)0x0)) &&
     (((pmVar2->flags & 2U) != 0 || (pmVar2->key_bitlen == key_bitlen)))) {
    ctx->key_bitlen = key_bitlen;
    ctx->operation = operation;
    if ((CONCAT31(in_register_00002035,operation) == 1) ||
       ((pmVar2->mode + ~MBEDTLS_MODE_CBC & 0xfd) == 0)) {
      UNRECOVERED_JUMPTABLE = pmVar2->base->setkey_enc_func;
    }
    else {
      if (CONCAT31(in_register_00002035,operation) != 0) {
        return -0x6100;
      }
      UNRECOVERED_JUMPTABLE =
           (anon_subr_int_void_ptr_uchar_ptr_uint_for_setkey_enc_func *)
           pmVar2->base->setkey_dec_func;
    }
                    // WARNING: Could not recover jumptable at 0x2306284c. Too many branches
                    // WARNING: Treating indirect jump as call
    iVar1 = (*UNRECOVERED_JUMPTABLE)(ctx->cipher_ctx);
    return iVar1;
  }
  return -0x6100;
}



int mbedtls_cipher_set_iv(mbedtls_cipher_context_t *ctx,uchar *iv,size_t iv_len)

{
  mbedtls_cipher_info_t *pmVar1;
  size_t __n;
  
  if (ctx == (mbedtls_cipher_context_t *)0x0) {
    return -0x6100;
  }
  pmVar1 = ctx->cipher_info;
  if ((pmVar1 != (mbedtls_cipher_info_t *)0x0) && (iv != (uchar *)0x0)) {
    if (0x10 < iv_len) {
      return -0x6080;
    }
    __n = iv_len;
    if (((pmVar1->flags & 1U) != 0) || (__n = pmVar1->iv_size, __n <= iv_len)) {
      memcpy(ctx->iv,iv,__n);
      ctx->iv_size = __n;
      return 0;
    }
  }
  return -0x6100;
}



int mbedtls_cipher_reset(mbedtls_cipher_context_t *ctx)

{
  if ((ctx != (mbedtls_cipher_context_t *)0x0) && (ctx->cipher_info != (mbedtls_cipher_info_t *)0x0)
     ) {
    ctx->unprocessed_len = 0;
    return 0;
  }
  return -0x6100;
}



int mbedtls_cipher_update
              (mbedtls_cipher_context_t *ctx,uchar *input,size_t ilen,uchar *output,size_t *olen)

{
  mbedtls_cipher_mode_t mVar1;
  uint uVar2;
  int iVar3;
  mbedtls_cipher_info_t *pmVar4;
  size_t sVar5;
  uint __n;
  
  if (ctx == (mbedtls_cipher_context_t *)0x0) {
    return -0x6100;
  }
  if ((ctx->cipher_info == (mbedtls_cipher_info_t *)0x0) || (olen == (size_t *)0x0)) {
    return -0x6100;
  }
  *olen = 0;
  uVar2 = mbedtls_cipher_get_block_size(ctx);
  pmVar4 = ctx->cipher_info;
  mVar1 = pmVar4->mode;
  if (mVar1 == MBEDTLS_MODE_ECB) {
    if (uVar2 != ilen) {
      return -0x6280;
    }
    *olen = uVar2;
                    // WARNING: Could not recover jumptable at 0x2306295c. Too many branches
                    // WARNING: Treating indirect jump as call
    iVar3 = (*ctx->cipher_info->base->ecb_func)(ctx->cipher_ctx,ctx->operation,input,output);
    return iVar3;
  }
  if (mVar1 == MBEDTLS_MODE_GCM) {
    *olen = ilen;
    iVar3 = mbedtls_gcm_update((mbedtls_gcm_context *)ctx->cipher_ctx,ilen,input,output);
    return iVar3;
  }
  if (uVar2 == 0) {
    return -0x6380;
  }
  if (input == output) {
    if (ctx->unprocessed_len != 0) {
      return -0x6100;
    }
    if (ilen % uVar2 != 0) {
      return -0x6100;
    }
  }
  if (mVar1 == MBEDTLS_MODE_CBC) {
    sVar5 = ctx->unprocessed_len;
    if (ctx->operation == MBEDTLS_DECRYPT) {
      if (ilen <= uVar2 - sVar5) {
LAB_230629b2:
        memcpy(ctx->unprocessed_data + sVar5,input,ilen);
        ctx->unprocessed_len = ilen + ctx->unprocessed_len;
        return 0;
      }
    }
    else {
      if ((ctx->operation == MBEDTLS_ENCRYPT) && (ilen < uVar2 - sVar5)) goto LAB_230629b2;
    }
    if (sVar5 != 0) {
      memcpy(ctx->unprocessed_data + sVar5,input,uVar2 - sVar5);
      iVar3 = (*ctx->cipher_info->base->cbc_func)
                        (ctx->cipher_ctx,ctx->operation,uVar2,ctx->iv,ctx->unprocessed_data,output);
      if (iVar3 != 0) {
        return iVar3;
      }
      output = output + uVar2;
      *olen = *olen + uVar2;
      ctx->unprocessed_len = 0;
      input = input + (uVar2 - sVar5);
      ilen = (ilen + sVar5) - uVar2;
    }
    if (ilen != 0) {
      __n = ilen % uVar2;
      if ((__n == 0) && (ctx->operation == MBEDTLS_DECRYPT)) {
        __n = uVar2;
      }
      ilen = ilen - __n;
      memcpy(ctx->unprocessed_data,input + ilen,__n);
      ctx->unprocessed_len = __n + ctx->unprocessed_len;
      if (ilen != 0) {
        iVar3 = (*ctx->cipher_info->base->cbc_func)
                          (ctx->cipher_ctx,ctx->operation,ilen,ctx->iv,input,output);
        if (iVar3 != 0) {
          return iVar3;
        }
        ilen = ilen + *olen;
        goto LAB_23062a78;
      }
    }
    return 0;
  }
  if (mVar1 == MBEDTLS_MODE_CFB) {
    iVar3 = (*pmVar4->base->cfb_func)
                      (ctx->cipher_ctx,ctx->operation,ilen,&ctx->unprocessed_len,ctx->iv,input,
                       output);
  }
  else {
    if (mVar1 != MBEDTLS_MODE_CTR) {
      return -0x6080;
    }
    iVar3 = (*pmVar4->base->ctr_func)
                      (ctx->cipher_ctx,ilen,&ctx->unprocessed_len,ctx->iv,ctx->unprocessed_data,
                       input,output);
  }
  if (iVar3 != 0) {
    return iVar3;
  }
LAB_23062a78:
  *olen = ilen;
  return iVar3;
}



int mbedtls_cipher_finish(mbedtls_cipher_context_t *ctx,uchar *output,size_t *olen)

{
  mbedtls_cipher_mode_t mVar1;
  int iVar2;
  uint uVar3;
  size_t sVar4;
  size_t sVar5;
  
  if (((ctx == (mbedtls_cipher_context_t *)0x0) ||
      (ctx->cipher_info == (mbedtls_cipher_info_t *)0x0)) || (olen == (size_t *)0x0)) {
    return -0x6100;
  }
  *olen = 0;
  mVar1 = ctx->cipher_info->mode;
  if ((mVar1 == MBEDTLS_MODE_CFB) || ((byte)(mVar1 + ~MBEDTLS_MODE_OFB) < 3)) {
    return 0;
  }
  if (mVar1 == MBEDTLS_MODE_ECB) {
    sVar5 = ctx->unprocessed_len;
joined_r0x23062b46:
    if (sVar5 == 0) {
      return 0;
    }
LAB_23062b24:
    iVar2 = -0x6280;
  }
  else {
    if (mVar1 != MBEDTLS_MODE_CBC) {
      return -0x6080;
    }
    sVar5 = ctx->unprocessed_len;
    if (ctx->operation == MBEDTLS_ENCRYPT) {
      if (ctx->add_padding == (anon_subr_void_uchar_ptr_size_t_size_t_for_add_padding *)0x0)
      goto joined_r0x23062b46;
      sVar4 = ctx->iv_size;
      if (sVar4 == 0) {
        sVar4 = ctx->cipher_info->iv_size;
      }
      (*ctx->add_padding)(ctx->unprocessed_data,sVar4,sVar5);
    }
    else {
      uVar3 = mbedtls_cipher_get_block_size(ctx);
      if (uVar3 != sVar5) {
        if ((ctx->add_padding == (anon_subr_void_uchar_ptr_size_t_size_t_for_add_padding *)0x0) &&
           (sVar5 == 0)) {
          return 0;
        }
        goto LAB_23062b24;
      }
    }
    uVar3 = mbedtls_cipher_get_block_size(ctx);
    iVar2 = (*ctx->cipher_info->base->cbc_func)
                      (ctx->cipher_ctx,ctx->operation,uVar3,ctx->iv,ctx->unprocessed_data,output);
    if (iVar2 == 0) {
      uVar3 = mbedtls_cipher_get_block_size(ctx);
      if (ctx->operation == MBEDTLS_DECRYPT) {
                    // WARNING: Could not recover jumptable at 0x23062bb2. Too many branches
                    // WARNING: Treating indirect jump as call
        iVar2 = (*ctx->get_padding)(output,uVar3,olen);
        return iVar2;
      }
      *olen = uVar3;
    }
  }
  return iVar2;
}



int mbedtls_cipher_set_padding_mode(mbedtls_cipher_context_t *ctx,mbedtls_cipher_padding_t mode)

{
  undefined3 in_register_0000202d;
  int iVar1;
  code *pcVar2;
  
  iVar1 = CONCAT31(in_register_0000202d,mode);
  if ((ctx != (mbedtls_cipher_context_t *)0x0) && (ctx->cipher_info->mode == MBEDTLS_MODE_CBC)) {
    if (iVar1 == 3) {
      ctx->add_padding = add_zeros_padding;
      pcVar2 = get_zeros_padding;
    }
    else {
      if (iVar1 == 4) {
        ctx->add_padding = (anon_subr_void_uchar_ptr_size_t_size_t_for_add_padding *)0x0;
        pcVar2 = get_no_padding;
      }
      else {
        if (iVar1 != 0) {
          return -0x6080;
        }
        ctx->add_padding = add_pkcs_padding;
        pcVar2 = get_pkcs_padding;
      }
    }
    ctx->get_padding = pcVar2;
    return 0;
  }
  return -0x6100;
}



int mbedtls_cipher_setup(mbedtls_cipher_context_t *ctx,mbedtls_cipher_info_t *cipher_info)

{
  void *pvVar1;
  int iVar2;
  anon_subr_void_ptr_for_ctx_alloc_func *paVar3;
  
  if (cipher_info != (mbedtls_cipher_info_t *)0x0) {
    if (ctx == (mbedtls_cipher_context_t *)0x0) {
      iVar2 = -0x6100;
    }
    else {
      memset(ctx,0,0x40);
      paVar3 = cipher_info->base->ctx_alloc_func;
      pvVar1 = (*paVar3)(paVar3);
      ctx->cipher_ctx = pvVar1;
      if (pvVar1 == (void *)0x0) {
        iVar2 = -0x6180;
      }
      else {
        ctx->cipher_info = cipher_info;
        mbedtls_cipher_set_padding_mode(ctx,MBEDTLS_PADDING_PKCS7);
        iVar2 = 0;
      }
    }
    return iVar2;
  }
  return -0x6100;
}



int mbedtls_cipher_crypt
              (mbedtls_cipher_context_t *ctx,uchar *iv,size_t iv_len,uchar *input,size_t ilen,
              uchar *output,size_t *olen)

{
  int iVar1;
  size_t sStack36;
  size_t finish_olen;
  
  iVar1 = mbedtls_cipher_set_iv(ctx,iv,iv_len);
  if ((((iVar1 == 0) && (iVar1 = mbedtls_cipher_reset(ctx), iVar1 == 0)) &&
      (iVar1 = mbedtls_cipher_update(ctx,input,ilen,output,olen), iVar1 == 0)) &&
     (iVar1 = mbedtls_cipher_finish(ctx,output + *olen,&sStack36), iVar1 == 0)) {
    *olen = *olen + sStack36;
  }
  return iVar1;
}



int mbedtls_cipher_auth_encrypt
              (mbedtls_cipher_context_t *ctx,uchar *iv,size_t iv_len,uchar *ad,size_t ad_len,
              uchar *input,size_t ilen,uchar *output,size_t *olen,uchar *tag,size_t tag_len)

{
  int iVar1;
  size_t *in_stack_00000000;
  
  if (ctx->cipher_info->mode == MBEDTLS_MODE_GCM) {
    *in_stack_00000000 = ilen;
    iVar1 = mbedtls_gcm_crypt_and_tag
                      ((mbedtls_gcm_context *)ctx->cipher_ctx,1,ilen,iv,iv_len,ad,ad_len,input,
                       (uchar *)olen,(size_t)tag,(uchar *)tag_len);
    return iVar1;
  }
  return -0x6080;
}



int mbedtls_cipher_auth_decrypt
              (mbedtls_cipher_context_t *ctx,uchar *iv,size_t iv_len,uchar *ad,size_t ad_len,
              uchar *input,size_t ilen,uchar *output,size_t *olen,uchar *tag,size_t tag_len)

{
  int iVar1;
  size_t *in_stack_00000000;
  uchar *in_stack_00000004;
  size_t in_stack_00000008;
  
  if (ctx->cipher_info->mode == MBEDTLS_MODE_GCM) {
    *in_stack_00000000 = ilen;
    iVar1 = mbedtls_gcm_auth_decrypt
                      ((mbedtls_gcm_context *)ctx->cipher_ctx,ilen,iv,iv_len,ad,ad_len,
                       in_stack_00000004,in_stack_00000008,(uchar *)olen,tag);
    if (iVar1 == -0x12) {
      iVar1 = -0x6300;
    }
    return iVar1;
  }
  return -0x6080;
}



void gcm_ctx_free(void *ctx)

{
  mbedtls_gcm_free((mbedtls_gcm_context *)ctx);
  vPortFree(ctx);
  return;
}



void * gcm_ctx_alloc(void)

{
  mbedtls_gcm_context *ctx;
  
  ctx = (mbedtls_gcm_context *)mycalloc(1,0x188);
  if (ctx != (mbedtls_gcm_context *)0x0) {
    mbedtls_gcm_init(ctx);
  }
  return ctx;
}



int gcm_aes_setkey_wrap(void *ctx,uchar *key,uint key_bitlen)

{
  int iVar1;
  
  iVar1 = mbedtls_gcm_setkey((mbedtls_gcm_context *)ctx,MBEDTLS_CIPHER_ID_AES,key,key_bitlen);
  return iVar1;
}



void aes_ctx_free(void *ctx)

{
  mbedtls_aes_free((mbedtls_aes_context *)ctx);
  vPortFree(ctx);
  return;
}



void * aes_ctx_alloc(void)

{
  mbedtls_aes_context *ctx;
  
  ctx = (mbedtls_aes_context *)mycalloc(1,0x118);
  if (ctx != (mbedtls_aes_context *)0x0) {
    mbedtls_aes_init(ctx);
  }
  return ctx;
}



int aes_setkey_dec_wrap(mbedtls_aes_context *ctx,uchar *key,uint keybits)

{
  uint *puVar1;
  int iVar2;
  uint32_t *puVar3;
  uint uVar4;
  uint32_t *puVar5;
  int iVar6;
  mbedtls_aes_context mStack296;
  
  mbedtls_aes_init(&mStack296);
  ctx->rk = ctx->buf;
  iVar2 = mbedtls_aes_setkey_enc(&mStack296,key,keybits);
  if (iVar2 == 0) {
    ctx->nr = mStack296.nr;
    mStack296.rk = mStack296.rk + mStack296.nr * 4;
    ctx->buf[0] = *mStack296.rk;
    ctx->buf[1] = mStack296.rk[1];
    puVar3 = ctx->buf;
    ctx->buf[2] = mStack296.rk[2];
    ctx->buf[3] = mStack296.rk[3];
    while( true ) {
      puVar3 = puVar3 + 4;
      puVar5 = mStack296.rk + -4;
      mStack296.nr = mStack296.nr + -1;
      if (mStack296.nr < 1) break;
      iVar6 = 0;
      do {
        uVar4 = *(uint *)((int)puVar5 + iVar6);
        puVar1 = (uint *)((int)puVar3 + iVar6);
        iVar6 = iVar6 + 4;
        *puVar1 = RT2[FSb[uVar4 >> 0x10 & 0xff]] ^
                  RT0[FSb[uVar4 & 0xff]] ^ RT3[FSb[uVar4 >> 0x18]] ^ RT1[FSb[uVar4 >> 8 & 0xff]];
        mStack296.rk = puVar5;
      } while (iVar6 != 0x10);
    }
    *puVar3 = *puVar5;
    puVar3[1] = mStack296.rk[-3];
    puVar3[2] = mStack296.rk[-2];
    puVar3[3] = mStack296.rk[-1];
  }
  mbedtls_aes_free(&mStack296);
  return iVar2;
}



int aes_setkey_enc_wrap(mbedtls_aes_context *ctx,uchar *key,uint keybits)

{
  byte *pbVar1;
  uint32_t *puVar2;
  uint uVar3;
  int iVar4;
  uint32_t *puVar5;
  uint32_t *puVar6;
  uint uVar7;
  
  if (aes_init_done == 0) {
    aes_gen_tables();
    aes_init_done = 1;
  }
  if (keybits == 0xc0) {
    iVar4 = 0xc;
  }
  else {
    if (keybits == 0x100) {
      iVar4 = 0xe;
    }
    else {
      if (keybits != 0x80) {
        return -0x20;
      }
      iVar4 = 10;
    }
  }
  ctx->nr = iVar4;
  puVar5 = ctx->buf;
  ctx->rk = puVar5;
  pbVar1 = key;
  puVar2 = puVar5;
  while (key + (keybits >> 5) * 4 != pbVar1) {
    *puVar2 = (uint)pbVar1[1] << 8 | (uint)pbVar1[2] << 0x10 | (uint)*pbVar1 |
              (uint)pbVar1[3] << 0x18;
    pbVar1 = pbVar1 + 4;
    puVar2 = puVar2 + 1;
  }
  iVar4 = ctx->nr;
  if (iVar4 == 0xc) {
    puVar2 = RCON;
    do {
      uVar3 = puVar5[5];
      uVar7 = *puVar2;
      puVar6 = puVar5 + 6;
      puVar2 = puVar2 + 1;
      uVar7 = (uint)FSb[uVar3 >> 8 & 0xff] ^ *puVar5 ^ uVar7 ^ (uint)FSb[uVar3 >> 0x18] << 0x10 ^
              (uint)FSb[uVar3 & 0xff] << 0x18 ^ (uint)FSb[uVar3 >> 0x10 & 0xff] << 8;
      *puVar6 = uVar7;
      uVar7 = uVar7 ^ puVar5[1];
      puVar5[7] = uVar7;
      uVar7 = uVar7 ^ puVar5[2];
      puVar5[8] = uVar7;
      uVar7 = uVar7 ^ puVar5[3];
      puVar5[9] = uVar7;
      uVar7 = uVar7 ^ puVar5[4];
      puVar5[10] = uVar7;
      puVar5[0xb] = uVar7 ^ uVar3;
      puVar5 = puVar6;
    } while (puVar6 != ctx->buf + 0x30);
  }
  else {
    if (iVar4 == 0xe) {
      puVar2 = RCON;
      do {
        uVar3 = puVar5[7];
        uVar7 = *puVar2;
        puVar6 = puVar5 + 8;
        puVar2 = puVar2 + 1;
        uVar7 = (uint)FSb[uVar3 >> 8 & 0xff] ^ *puVar5 ^ uVar7 ^ (uint)FSb[uVar3 >> 0x18] << 0x10 ^
                (uint)FSb[uVar3 & 0xff] << 0x18 ^ (uint)FSb[uVar3 >> 0x10 & 0xff] << 8;
        *puVar6 = uVar7;
        uVar7 = uVar7 ^ puVar5[1];
        puVar5[9] = uVar7;
        uVar7 = uVar7 ^ puVar5[2];
        puVar5[10] = uVar7;
        uVar7 = uVar7 ^ puVar5[3];
        puVar5[0xb] = uVar7;
        uVar7 = (uint)FSb[uVar7 >> 0x10 & 0xff] << 0x10 ^
                (uint)FSb[uVar7 & 0xff] ^ puVar5[4] ^ (uint)FSb[uVar7 >> 0x18] << 0x18 ^
                (uint)FSb[uVar7 >> 8 & 0xff] << 8;
        puVar5[0xc] = uVar7;
        uVar7 = uVar7 ^ puVar5[5];
        puVar5[0xd] = uVar7;
        uVar7 = uVar7 ^ puVar5[6];
        puVar5[0xe] = uVar7;
        puVar5[0xf] = uVar7 ^ uVar3;
        puVar5 = puVar6;
      } while (puVar6 != ctx->buf + 0x38);
    }
    else {
      if (iVar4 != 10) {
        return 0;
      }
      puVar2 = RCON;
      do {
        uVar3 = puVar5[3];
        uVar7 = *puVar2;
        puVar6 = puVar5 + 4;
        puVar2 = puVar2 + 1;
        uVar7 = (uint)FSb[uVar3 >> 8 & 0xff] ^ *puVar5 ^ uVar7 ^ (uint)FSb[uVar3 >> 0x18] << 0x10 ^
                (uint)FSb[uVar3 & 0xff] << 0x18 ^ (uint)FSb[uVar3 >> 0x10 & 0xff] << 8;
        *puVar6 = uVar7;
        uVar7 = uVar7 ^ puVar5[1];
        puVar5[5] = uVar7;
        uVar7 = uVar7 ^ puVar5[2];
        puVar5[6] = uVar7;
        puVar5[7] = uVar7 ^ uVar3;
        puVar5 = puVar6;
      } while (puVar6 != ctx->buf + 0x28);
    }
  }
  return 0;
}



int aes_crypt_ctr_wrap(mbedtls_aes_context *ctx,size_t length,size_t *nc_off,uchar *nonce_counter,
                      uchar *stream_block,uchar *input,uchar *output)

{
  bool bVar1;
  uchar uVar2;
  uint uVar3;
  uchar *puVar4;
  byte *pbVar5;
  
  uVar3 = *nc_off;
  pbVar5 = output;
  do {
    if (pbVar5 == output + length) {
      *nc_off = uVar3;
      return 0;
    }
    if (uVar3 == 0) {
      mbedtls_aes_encrypt(ctx,nonce_counter,stream_block);
      puVar4 = nonce_counter + 0xf;
      do {
        uVar2 = *puVar4;
        *puVar4 = uVar2 + '\x01';
        if ((uchar)(uVar2 + '\x01') != '\0') break;
        bVar1 = nonce_counter != puVar4;
        puVar4 = puVar4 + -1;
      } while (bVar1);
    }
    *pbVar5 = stream_block[uVar3] ^ *input;
    uVar3 = uVar3 + 1 & 0xf;
    input = input + 1;
    pbVar5 = pbVar5 + 1;
  } while( true );
}



int aes_crypt_cfb128_wrap
              (mbedtls_aes_context *ctx,int mode,size_t length,size_t *iv_off,uchar *iv,uchar *input
              ,uchar *output)

{
  uint uVar1;
  byte *pbVar2;
  byte bVar3;
  
  uVar1 = *iv_off;
  pbVar2 = output;
  if (mode == 0) {
    while (pbVar2 != output + length) {
      if (uVar1 == 0) {
        mbedtls_aes_encrypt(ctx,iv,iv);
      }
      bVar3 = *input;
      *pbVar2 = iv[uVar1] ^ bVar3;
      iv[uVar1] = bVar3;
      uVar1 = uVar1 + 1 & 0xf;
      pbVar2 = pbVar2 + 1;
      input = input + 1;
    }
  }
  else {
    while (pbVar2 != output + length) {
      if (uVar1 == 0) {
        mbedtls_aes_encrypt(ctx,iv,iv);
      }
      bVar3 = iv[uVar1] ^ *input;
      *pbVar2 = bVar3;
      iv[uVar1] = bVar3;
      uVar1 = uVar1 + 1 & 0xf;
      pbVar2 = pbVar2 + 1;
      input = input + 1;
    }
  }
  *iv_off = uVar1;
  return 0;
}



int aes_crypt_cbc_wrap(mbedtls_aes_context *ctx,int mode,size_t length,uchar *iv,uchar *input,
                      uchar *output)

{
  uint uVar1;
  int iVar2;
  byte *pbVar3;
  byte *pbVar4;
  byte *pbVar5;
  uchar *input_00;
  undefined auStack64 [24];
  
  uVar1 = length & 0xf;
  if (uVar1 == 0) {
    if (mode == 0) {
      while( true ) {
        input_00 = output + -uVar1;
        if (uVar1 + length == 0) break;
        memcpy(auStack64,input + -uVar1,0x10);
        mbedtls_aes_decrypt(ctx,input + -uVar1,input_00);
        iVar2 = 0;
        do {
          pbVar3 = input_00 + iVar2;
          pbVar4 = iv + iVar2;
          iVar2 = iVar2 + 1;
          *pbVar3 = *pbVar4 ^ *pbVar3;
        } while (iVar2 != 0x10);
        memcpy(iv,auStack64,0x10);
        uVar1 = uVar1 - 0x10;
      }
    }
    else {
      while( true ) {
        input_00 = output + -uVar1;
        if (length + uVar1 == 0) break;
        iVar2 = 0;
        do {
          pbVar5 = input + -uVar1 + iVar2;
          pbVar3 = iv + iVar2;
          pbVar4 = input_00 + iVar2;
          iVar2 = iVar2 + 1;
          *pbVar4 = *pbVar5 ^ *pbVar3;
        } while (iVar2 != 0x10);
        mbedtls_aes_crypt_ecb(ctx,mode,input_00,input_00);
        memcpy(iv,input_00,0x10);
        uVar1 = uVar1 - 0x10;
      }
    }
    iVar2 = 0;
  }
  else {
    iVar2 = -0x22;
  }
  return iVar2;
}



int aes_crypt_ecb_wrap(mbedtls_aes_context *ctx,int mode,uchar *input,uchar *output)

{
  if (mode == 1) {
    mbedtls_aes_encrypt(ctx,input,output);
  }
  else {
    mbedtls_aes_decrypt(ctx,input,output);
  }
  return 0;
}



void debug_send_line(int level,char *file,int line,char *str)

{
                    // WARNING: Could not recover jumptable at 0x23062e18. Too many branches
                    // WARNING: Treating indirect jump as call
  (**(code **)(level + 0x10))(*(undefined4 *)(level + 0x14));
  return;
}



void mbedtls_debug_print_mpi
               (mbedtls_ssl_context *ssl,int level,char *file,int line,char *text,mbedtls_mpi *X)

{
  int iVar1;
  size_t sVar2;
  int iVar3;
  bool bVar4;
  uint uVar5;
  uint uVar6;
  char acStack576 [4];
  char str [512];
  
  sVar2 = X->n;
  do {
    sVar2 = sVar2 - 1;
    if (sVar2 == 0) break;
  } while (X->p[sVar2] == 0);
  uVar5 = 0x1f;
  do {
    if ((X->p[sVar2] >> (uVar5 & 0x1f) & 1) != 0) break;
    uVar5 = uVar5 - 1;
  } while (uVar5 != 0xffffffff);
  snprintf(acStack576,0x200,"value of \'%s\' (%d bits) is:\n",text,sVar2 * 0x20 + 1 + uVar5);
  debug_send_line((int)ssl->conf,(char *)level,(int)file,(char *)line);
  iVar1 = 0;
  bVar4 = true;
  uVar5 = 0;
  while (sVar2 != 0xffffffff) {
    if ((!bVar4) || (X->p[sVar2] != 0)) {
      uVar6 = 0x18;
      do {
        if ((!bVar4) || ((X->p[sVar2] >> (uVar6 & 0x1f) & 0xff) != 0)) {
          if (((uVar5 & 0xf) == 0) && (uVar5 != 0)) {
            snprintf(acStack576 + iVar1,0x200 - iVar1,"\n");
            debug_send_line((int)ssl->conf,(char *)level,(int)file,(char *)line);
            iVar1 = 0;
          }
          iVar3 = snprintf(acStack576 + iVar1,0x200 - iVar1," %02x",
                           X->p[sVar2] >> (uVar6 & 0x1f) & 0xff);
          iVar1 = iVar1 + iVar3;
          uVar5 = uVar5 + 1;
          bVar4 = false;
        }
        uVar6 = uVar6 - 8;
      } while (uVar6 != 0xfffffff8);
    }
    sVar2 = sVar2 - 1;
  }
  if (bVar4) {
    iVar3 = snprintf(acStack576 + iVar1,0x200 - iVar1," 00");
    iVar1 = iVar1 + iVar3;
  }
  snprintf(acStack576 + iVar1,0x200 - iVar1,"\n");
  debug_send_line((int)ssl->conf,(char *)level,(int)file,(char *)line);
  return;
}



void mbedtls_debug_print_msg
               (mbedtls_ssl_context *ssl,int level,char *file,int line,char *format,...)

{
  uint uVar1;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list argp;
  char str [512];
  undefined4 uStack12;
  undefined4 uStack8;
  undefined4 uStack4;
  
  if ((((ssl != (mbedtls_ssl_context *)0x0) && (ssl->conf != (mbedtls_ssl_config *)0x0)) &&
      (ssl->conf->f_dbg != (anon_subr_void_void_ptr_int_char_ptr_int_char_ptr_for_f_dbg *)0x0)) &&
     (level <= debug_threshold)) {
    uStack12 = in_a5;
    uStack8 = in_a6;
    uStack4 = in_a7;
    uVar1 = vsnprintf((char *)&argp,0x200,format,&uStack12);
    if (uVar1 < 0x1ff) {
      *(undefined *)((int)&argp + uVar1) = 10;
      *(undefined *)((int)&argp + uVar1 + 1) = 0;
    }
    debug_send_line((int)ssl->conf,(char *)level,(int)file,(char *)line);
  }
  return;
}



void mbedtls_debug_print_ret
               (mbedtls_ssl_context *ssl,int level,char *file,int line,char *text,int ret)

{
  char acStack544 [4];
  char str [512];
  
  if ((((ssl->conf != (mbedtls_ssl_config *)0x0) &&
       (ssl->conf->f_dbg != (anon_subr_void_void_ptr_int_char_ptr_int_char_ptr_for_f_dbg *)0x0)) &&
      (level <= debug_threshold)) && (ret != -0x6900)) {
    snprintf(acStack544,0x200,"%s() returned %d (-0x%04x)\n",text,ret,-ret);
    debug_send_line((int)ssl->conf,(char *)level,(int)file,(char *)line);
  }
  return;
}



void mbedtls_debug_print_buf
               (mbedtls_ssl_context *ssl,int level,char *file,int line,char *text,uchar *buf,
               size_t len)

{
  int iVar1;
  byte bVar2;
  int iVar3;
  uint uVar4;
  byte abStack596 [4];
  char txt [17];
  char str [512];
  
  if (((ssl->conf != (mbedtls_ssl_config *)0x0) &&
      (ssl->conf->f_dbg != (anon_subr_void_void_ptr_int_char_ptr_int_char_ptr_for_f_dbg *)0x0)) &&
     (level <= debug_threshold)) {
    snprintf(txt + 0x10,0x200,"dumping \'%s\' (%u bytes)\n",text,len);
    debug_send_line((int)ssl->conf,(char *)level,(int)file,(char *)line);
    memset(abStack596,0,0x11);
    iVar3 = 0;
    uVar4 = 0;
    while (uVar4 != len) {
      if (uVar4 == 0x1000) goto LAB_23063198;
      if ((uVar4 & 0xf) == 0) {
        if (uVar4 != 0) {
          snprintf(txt + iVar3 + 0x10,0x200 - iVar3,"  %s\n",abStack596);
          debug_send_line((int)ssl->conf,(char *)level,(int)file,(char *)line);
          memset(abStack596,0,0x11);
          iVar3 = 0;
        }
        iVar1 = snprintf(txt + iVar3 + 0x10,0x200 - iVar3,"%04x: ",uVar4);
        iVar3 = iVar3 + iVar1;
      }
      iVar1 = snprintf(txt + iVar3 + 0x10,0x200 - iVar3," %02x",(uint)buf[uVar4]);
      iVar3 = iVar3 + iVar1;
      bVar2 = buf[uVar4];
      if (0x5e < (byte)(bVar2 - 0x20)) {
        bVar2 = 0x2e;
      }
      abStack596[uVar4 & 0xf] = bVar2;
      uVar4 = uVar4 + 1;
    }
    if (len != 0) {
      while( true ) {
        if ((len & 0xf) == 0) break;
        iVar1 = snprintf(txt + iVar3 + 0x10,0x200 - iVar3,"   ");
        iVar3 = iVar3 + iVar1;
        len = len + 1;
      }
LAB_23063198:
      snprintf(txt + iVar3 + 0x10,0x200 - iVar3,"  %s\n",abStack596);
      debug_send_line((int)ssl->conf,(char *)level,(int)file,(char *)line);
    }
  }
  return;
}



void mbedtls_debug_print_mpi
               (mbedtls_ssl_context *ssl,int level,char *file,int line,char *text,mbedtls_mpi *X)

{
  if ((((ssl->conf != (mbedtls_ssl_config *)0x0) &&
       (ssl->conf->f_dbg != (anon_subr_void_void_ptr_int_char_ptr_int_char_ptr_for_f_dbg *)0x0)) &&
      (X != (mbedtls_mpi *)0x0)) && (level <= debug_threshold)) {
    mbedtls_debug_print_mpi(ssl,level,file,line,text,X);
    return;
  }
  return;
}



void mbedtls_debug_print_ecp
               (mbedtls_ssl_context *ssl,int level,char *file,int line,char *text,
               mbedtls_ecp_point *X)

{
  char acStack544 [4];
  char str [512];
  
  snprintf(acStack544,0x200,"%s(X)",text);
  mbedtls_debug_print_mpi(ssl,level,file,line,acStack544,(mbedtls_mpi *)X);
  snprintf(acStack544,0x200,"%s(Y)",text);
  mbedtls_debug_print_mpi(ssl,level,file,line,acStack544,&X->Y);
  return;
}



void mbedtls_debug_print_ecp
               (mbedtls_ssl_context *ssl,int level,char *file,int line,char *text,
               mbedtls_ecp_point *X)

{
  if (((ssl->conf != (mbedtls_ssl_config *)0x0) &&
      (ssl->conf->f_dbg != (anon_subr_void_void_ptr_int_char_ptr_int_char_ptr_for_f_dbg *)0x0)) &&
     (level <= debug_threshold)) {
    mbedtls_debug_print_ecp(ssl,level,file,line,text,X);
    return;
  }
  return;
}



void mbedtls_debug_print_crt
               (mbedtls_ssl_context *ssl,int level,char *file,int line,char *text,
               mbedtls_x509_crt *crt)

{
  int iVar1;
  mbedtls_ssl_config *level_00;
  char *__src;
  int iVar2;
  void **ppvVar3;
  char *__n;
  char *pcVar4;
  char *pcStack2132;
  char acStack2128 [4];
  char name [16];
  char str [512];
  mbedtls_pk_debug_item items [3];
  char local_440 [4];
  char buf [1024];
  
  if ((((ssl->conf != (mbedtls_ssl_config *)0x0) &&
       (ssl->conf->f_dbg != (anon_subr_void_void_ptr_int_char_ptr_int_char_ptr_for_f_dbg *)0x0)) &&
      (crt != (mbedtls_x509_crt *)0x0)) && (iVar2 = 0, level <= debug_threshold)) {
    pcStack2132 = text;
    do {
      iVar2 = iVar2 + 1;
      snprintf(name + 0xc,0x200,"%s #%d:\n",pcStack2132,iVar2);
      debug_send_line((int)ssl->conf,(char *)level,(int)file,(char *)line);
      mbedtls_x509_crt_info(local_440,0x3ff,"",crt);
      __src = local_440;
      pcVar4 = local_440;
      while (__n = pcVar4, *__n != '\0') {
        pcVar4 = __n + 1;
        if (*__n == '\n') {
          __n = __n + (1 - (int)__src);
          if ((char *)0x1ff < __n) {
            __n = (char *)0x1ff;
          }
          memcpy(str + 0x1fc,__src,(size_t)__n);
          level_00 = ssl->conf;
          *(undefined *)((int)__n + (int)register0x00002008 + -0x640) = 0;
          debug_send_line((int)level_00,(char *)level,(int)file,(char *)line);
          __src = pcVar4;
        }
      }
      memset(str + 0x1fc,0,0x24);
      iVar1 = mbedtls_pk_debug(&crt->pk,(mbedtls_pk_debug_item *)(str + 0x1fc));
      if (iVar1 == 0) {
        ppvVar3 = (void **)(str + 0x1fc);
        do {
          if (*(char *)ppvVar3 == '\0') break;
          snprintf(acStack2128,0x10,"%s%s",&UNK_2308b034,ppvVar3[1]);
          name[11] = '\0';
          if (*(char *)ppvVar3 == '\x01') {
            mbedtls_debug_print_mpi(ssl,level,file,line,acStack2128,(mbedtls_mpi *)ppvVar3[2]);
          }
          else {
            if (*(char *)ppvVar3 == '\x02') {
              mbedtls_debug_print_ecp
                        (ssl,level,file,line,acStack2128,(mbedtls_ecp_point *)ppvVar3[2]);
            }
            else {
              debug_send_line((int)ssl->conf,(char *)level,(int)file,(char *)line);
            }
          }
          ppvVar3 = ppvVar3 + 3;
        } while (ppvVar3 != &items[2].value);
      }
      else {
        debug_send_line((int)ssl->conf,(char *)level,(int)file,(char *)line);
      }
      crt = crt->next;
    } while (crt != (mbedtls_x509_crt *)0x0);
  }
  return;
}



ecp_curve_type ecp_get_type(mbedtls_ecp_group *grp)

{
  if ((grp->G).X.p != (mbedtls_mpi_uint *)0x0) {
    return ((grp->G).Y.p == (mbedtls_mpi_uint *)0x0) + ECP_TYPE_SHORT_WEIERSTRASS;
  }
  return ECP_TYPE_NONE;
}



// WARNING: Variable defined which should be unmapped: mQY

int ecp_safe_invert_jac(mbedtls_ecp_group *grp,mbedtls_ecp_point *Q,uchar inv)

{
  mbedtls_mpi *B;
  int iVar1;
  undefined auStack28 [4];
  mbedtls_mpi mQY;
  
  B = &Q->Y;
  mbedtls_mpi_init((mbedtls_mpi *)auStack28);
  iVar1 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)auStack28,&grp->P,B);
  if (iVar1 == 0) {
    iVar1 = mbedtls_mpi_cmp_int(B,0);
    iVar1 = mbedtls_mpi_safe_cond_assign(B,(mbedtls_mpi *)auStack28,inv & iVar1 != 0);
  }
  mbedtls_mpi_free((mbedtls_mpi *)auStack28);
  return iVar1;
}



int ecp_select_comb(mbedtls_ecp_group *grp,mbedtls_ecp_point *R,mbedtls_ecp_point *T,uchar t_len,
                   uchar i)

{
  bool assign;
  uint uVar1;
  int iVar2;
  undefined3 in_register_00002035;
  undefined3 in_register_00002039;
  
  uVar1 = 0;
  while( true ) {
    assign = ((uint)i & 0x7e) >> 1 == uVar1;
    iVar2 = mbedtls_mpi_safe_cond_assign((mbedtls_mpi *)R,(mbedtls_mpi *)T,assign);
    if ((iVar2 != 0) || (iVar2 = mbedtls_mpi_safe_cond_assign(&R->Y,&T->Y,assign), iVar2 != 0))
    break;
    uVar1 = uVar1 + 1 & 0xff;
    T = T + 1;
    if (CONCAT31(in_register_00002035,t_len) == uVar1) {
      iVar2 = ecp_safe_invert_jac(grp,R,(uchar)(CONCAT31(in_register_00002039,i) >> 7));
      return iVar2;
    }
  }
  return iVar2;
}



int ecp_modp(mbedtls_mpi *N,mbedtls_ecp_group *grp)

{
  mbedtls_mpi *B;
  int iVar1;
  size_t sVar2;
  int iVar3;
  
  if (grp->modp == (anon_subr_int_mbedtls_mpi_ptr_for_modp *)0x0) {
    iVar1 = mbedtls_mpi_mod_mpi(N,N,&grp->P);
    return iVar1;
  }
  if (((-1 < N->s) || (iVar1 = mbedtls_mpi_cmp_int(N,0), iVar1 == 0)) &&
     (sVar2 = mbedtls_mpi_bitlen(N), sVar2 <= grp->pbits << 1)) {
    B = &grp->P;
    iVar3 = (*grp->modp)(N);
    iVar1 = iVar3;
    while( true ) {
      if (iVar1 != 0) {
        return iVar1;
      }
      if ((-1 < N->s) || (iVar1 = mbedtls_mpi_cmp_int(N,0), iVar1 == 0)) break;
      iVar1 = mbedtls_mpi_add_mpi(N,N,B);
    }
    do {
      iVar1 = mbedtls_mpi_cmp_mpi(N,B);
      if (iVar1 < 0) {
        return iVar3;
      }
      iVar1 = mbedtls_mpi_sub_abs(N,N,B);
    } while (iVar1 == 0);
    return iVar1;
  }
  return -0x4f80;
}



int ecp_double_jac(mbedtls_ecp_group *grp,mbedtls_ecp_point *R,mbedtls_ecp_point *P)

{
  mbedtls_mpi *X;
  int iVar1;
  mbedtls_mpi *Y;
  mbedtls_mpi *Y_00;
  undefined auStack96 [4];
  mbedtls_mpi M;
  mbedtls_mpi S;
  mbedtls_mpi T;
  mbedtls_mpi U;
  
  X = (mbedtls_mpi *)&M.p;
  mbedtls_mpi_init((mbedtls_mpi *)auStack96);
  mbedtls_mpi_init(X);
  mbedtls_mpi_init((mbedtls_mpi *)&S.p);
  mbedtls_mpi_init((mbedtls_mpi *)&T.p);
  if ((grp->A).p == (mbedtls_mpi_uint *)0x0) {
    iVar1 = mbedtls_mpi_mul_mpi(X,&P->Z,&P->Z);
    if ((iVar1 == 0) && (iVar1 = ecp_modp(X,grp), iVar1 == 0)) {
      iVar1 = mbedtls_mpi_add_mpi((mbedtls_mpi *)&S.p,(mbedtls_mpi *)P,X);
      Y = &grp->P;
      while (iVar1 == 0) {
        iVar1 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&S.p,Y);
        if (iVar1 < 0) {
          iVar1 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)&T.p,(mbedtls_mpi *)P,X);
          goto LAB_230637aa;
        }
        iVar1 = mbedtls_mpi_sub_abs((mbedtls_mpi *)&S.p,(mbedtls_mpi *)&S.p,Y);
      }
    }
  }
  else {
    iVar1 = mbedtls_mpi_mul_mpi(X,(mbedtls_mpi *)P,(mbedtls_mpi *)P);
    if ((iVar1 == 0) && (iVar1 = ecp_modp(X,grp), iVar1 == 0)) {
      iVar1 = mbedtls_mpi_mul_int((mbedtls_mpi *)auStack96,X,3);
      Y = &grp->P;
      while (iVar1 == 0) {
        iVar1 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)auStack96,Y);
        if (iVar1 < 0) {
          iVar1 = mbedtls_mpi_cmp_int(&grp->A,0);
          if (iVar1 == 0) goto LAB_230637e8;
          iVar1 = mbedtls_mpi_mul_mpi(X,&P->Z,&P->Z);
          if (((((iVar1 == 0) && (iVar1 = ecp_modp(X,grp), iVar1 == 0)) &&
               (iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&S.p,X,X), iVar1 == 0)) &&
              ((iVar1 = ecp_modp((mbedtls_mpi *)&S.p,grp), iVar1 == 0 &&
               (iVar1 = mbedtls_mpi_mul_mpi(X,(mbedtls_mpi *)&S.p,&grp->A), iVar1 == 0)))) &&
             (iVar1 = ecp_modp(X,grp), iVar1 == 0)) {
            iVar1 = mbedtls_mpi_add_mpi((mbedtls_mpi *)auStack96,(mbedtls_mpi *)auStack96,X);
            goto LAB_23063a66;
          }
          break;
        }
        iVar1 = mbedtls_mpi_sub_abs((mbedtls_mpi *)auStack96,(mbedtls_mpi *)auStack96,Y);
      }
    }
  }
  goto cleanup;
LAB_23063a66:
  if (iVar1 != 0) goto cleanup;
  iVar1 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)auStack96,Y);
  if (iVar1 < 0) goto LAB_230637e8;
  iVar1 = mbedtls_mpi_sub_abs((mbedtls_mpi *)auStack96,(mbedtls_mpi *)auStack96,Y);
  goto LAB_23063a66;
LAB_230637aa:
  if (iVar1 != 0) goto cleanup;
  if ((-1 < (int)T.p) || (iVar1 = mbedtls_mpi_cmp_int((mbedtls_mpi *)&T.p,0), iVar1 == 0)) {
    iVar1 = mbedtls_mpi_mul_mpi(X,(mbedtls_mpi *)&S.p,(mbedtls_mpi *)&T.p);
    if ((iVar1 == 0) && (iVar1 = ecp_modp(X,grp), iVar1 == 0)) {
      iVar1 = mbedtls_mpi_mul_int((mbedtls_mpi *)auStack96,X,3);
      goto LAB_230637d8;
    }
    goto cleanup;
  }
  iVar1 = mbedtls_mpi_add_mpi((mbedtls_mpi *)&T.p,(mbedtls_mpi *)&T.p,Y);
  goto LAB_230637aa;
LAB_230637d8:
  if (iVar1 != 0) goto cleanup;
  iVar1 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)auStack96,Y);
  if (iVar1 < 0) goto LAB_230637e8;
  iVar1 = mbedtls_mpi_sub_abs((mbedtls_mpi *)auStack96,(mbedtls_mpi *)auStack96,Y);
  goto LAB_230637d8;
LAB_23063848:
  if (iVar1 != 0) goto cleanup;
  iVar1 = mbedtls_mpi_cmp_mpi(X,Y_00);
  if (iVar1 < 0) {
    iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&T.p,(mbedtls_mpi *)&S.p,(mbedtls_mpi *)&S.p);
    if ((iVar1 == 0) && (iVar1 = ecp_modp((mbedtls_mpi *)&T.p,grp), iVar1 == 0)) {
      iVar1 = mbedtls_mpi_shift_l((mbedtls_mpi *)&T.p,1);
      goto LAB_23063880;
    }
    goto cleanup;
  }
  iVar1 = mbedtls_mpi_sub_abs(X,X,Y_00);
  goto LAB_23063848;
LAB_23063880:
  if (iVar1 != 0) goto cleanup;
  iVar1 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&T.p,Y_00);
  if (iVar1 < 0) {
    iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&S.p,(mbedtls_mpi *)auStack96,
                                (mbedtls_mpi *)auStack96);
    if ((iVar1 == 0) && (iVar1 = ecp_modp((mbedtls_mpi *)&S.p,grp), iVar1 == 0)) {
      iVar1 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)&S.p,(mbedtls_mpi *)&S.p,X);
      goto LAB_230638ba;
    }
    goto cleanup;
  }
  iVar1 = mbedtls_mpi_sub_abs((mbedtls_mpi *)&T.p,(mbedtls_mpi *)&T.p,Y_00);
  goto LAB_23063880;
LAB_230638ba:
  if (iVar1 != 0) goto cleanup;
  if ((-1 < (int)S.p) || (iVar1 = mbedtls_mpi_cmp_int((mbedtls_mpi *)&S.p,0), iVar1 == 0)) {
    iVar1 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)&S.p,(mbedtls_mpi *)&S.p,X);
    goto LAB_230638d0;
  }
  iVar1 = mbedtls_mpi_add_mpi((mbedtls_mpi *)&S.p,(mbedtls_mpi *)&S.p,Y_00);
  goto LAB_230638ba;
LAB_230638d0:
  if (iVar1 != 0) goto cleanup;
  if ((-1 < (int)S.p) || (iVar1 = mbedtls_mpi_cmp_int((mbedtls_mpi *)&S.p,0), iVar1 == 0)) {
    iVar1 = mbedtls_mpi_sub_mpi(X,X,(mbedtls_mpi *)&S.p);
    goto LAB_230638e6;
  }
  iVar1 = mbedtls_mpi_add_mpi((mbedtls_mpi *)&S.p,(mbedtls_mpi *)&S.p,Y_00);
  goto LAB_230638d0;
LAB_230638e6:
  if (iVar1 != 0) goto cleanup;
  if ((-1 < (int)M.p) || (iVar1 = mbedtls_mpi_cmp_int(X,0), iVar1 == 0)) {
    iVar1 = mbedtls_mpi_mul_mpi(X,X,(mbedtls_mpi *)auStack96);
    if ((iVar1 == 0) && (iVar1 = ecp_modp(X,grp), iVar1 == 0)) {
      iVar1 = mbedtls_mpi_sub_mpi(X,X,(mbedtls_mpi *)&T.p);
      goto joined_r0x2306391e;
    }
    goto cleanup;
  }
  iVar1 = mbedtls_mpi_add_mpi(X,X,Y_00);
  goto LAB_230638e6;
joined_r0x2306391e:
  if (iVar1 != 0) goto cleanup;
  if ((-1 < (int)M.p) || (iVar1 = mbedtls_mpi_cmp_int(X,0), iVar1 == 0)) {
    iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&T.p,Y,&P->Z);
    if ((iVar1 == 0) && (iVar1 = ecp_modp((mbedtls_mpi *)&T.p,grp), iVar1 == 0)) {
      iVar1 = mbedtls_mpi_shift_l((mbedtls_mpi *)&T.p,1);
      goto LAB_23063950;
    }
    goto cleanup;
  }
  iVar1 = mbedtls_mpi_add_mpi(X,X,Y_00);
  goto joined_r0x2306391e;
LAB_23063950:
  if (iVar1 != 0) goto cleanup;
  iVar1 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&T.p,Y_00);
  if (iVar1 < 0) {
    iVar1 = mbedtls_mpi_copy((mbedtls_mpi *)R,(mbedtls_mpi *)&S.p);
    if ((iVar1 == 0) && (iVar1 = mbedtls_mpi_copy(&R->Y,(mbedtls_mpi *)&M.p), iVar1 == 0)) {
      iVar1 = mbedtls_mpi_copy(&R->Z,(mbedtls_mpi *)&T.p);
    }
    goto cleanup;
  }
  iVar1 = mbedtls_mpi_sub_abs((mbedtls_mpi *)&T.p,(mbedtls_mpi *)&T.p,Y_00);
  goto LAB_23063950;
LAB_230637e8:
  Y = &P->Y;
  iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&S.p,Y,Y);
  if ((iVar1 == 0) && (iVar1 = ecp_modp((mbedtls_mpi *)&S.p,grp), iVar1 == 0)) {
    iVar1 = mbedtls_mpi_shift_l((mbedtls_mpi *)&S.p,1);
    Y_00 = &grp->P;
    while (iVar1 == 0) {
      iVar1 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&S.p,Y_00);
      if (iVar1 < 0) {
        iVar1 = mbedtls_mpi_mul_mpi(X,(mbedtls_mpi *)P,(mbedtls_mpi *)&S.p);
        if ((iVar1 == 0) && (iVar1 = ecp_modp(X,grp), iVar1 == 0)) {
          iVar1 = mbedtls_mpi_shift_l(X,1);
          goto LAB_23063848;
        }
        break;
      }
      iVar1 = mbedtls_mpi_sub_abs((mbedtls_mpi *)&S.p,(mbedtls_mpi *)&S.p,Y_00);
    }
  }
cleanup:
  mbedtls_mpi_free((mbedtls_mpi *)auStack96);
  mbedtls_mpi_free(X);
  mbedtls_mpi_free((mbedtls_mpi *)&S.p);
  mbedtls_mpi_free((mbedtls_mpi *)&T.p);
  return iVar1;
}



int ecp_normalize_jac(mbedtls_ecp_group *grp,mbedtls_ecp_point *pt)

{
  mbedtls_mpi *X;
  int iVar1;
  mbedtls_mpi *X_00;
  undefined auStack56 [4];
  mbedtls_mpi Zi;
  mbedtls_mpi ZZi;
  
  X_00 = &pt->Z;
  iVar1 = mbedtls_mpi_cmp_int(X_00,0);
  if (iVar1 != 0) {
    mbedtls_mpi_init((mbedtls_mpi *)auStack56);
    mbedtls_mpi_init((mbedtls_mpi *)&Zi.p);
    iVar1 = mbedtls_mpi_inv_mod((mbedtls_mpi *)auStack56,X_00,&grp->P);
    if ((((iVar1 == 0) &&
         (iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&Zi.p,(mbedtls_mpi *)auStack56,
                                      (mbedtls_mpi *)auStack56), iVar1 == 0)) &&
        (iVar1 = ecp_modp((mbedtls_mpi *)&Zi.p,grp), iVar1 == 0)) &&
       ((iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)pt,(mbedtls_mpi *)pt,(mbedtls_mpi *)&Zi.p),
        iVar1 == 0 && (iVar1 = ecp_modp((mbedtls_mpi *)pt,grp), iVar1 == 0)))) {
      X = &pt->Y;
      iVar1 = mbedtls_mpi_mul_mpi(X,X,(mbedtls_mpi *)&Zi.p);
      if (((iVar1 == 0) &&
          ((iVar1 = ecp_modp(X,grp), iVar1 == 0 &&
           (iVar1 = mbedtls_mpi_mul_mpi(X,X,(mbedtls_mpi *)auStack56), iVar1 == 0)))) &&
         (iVar1 = ecp_modp(X,grp), iVar1 == 0)) {
        iVar1 = mbedtls_mpi_lset(X_00,1);
      }
    }
    mbedtls_mpi_free((mbedtls_mpi *)auStack56);
    mbedtls_mpi_free((mbedtls_mpi *)&Zi.p);
  }
  return iVar1;
}



int ecp_normalize_jac_many(mbedtls_ecp_group *grp,mbedtls_ecp_point **T,size_t t_len)

{
  mbedtls_ecp_point **ppmVar1;
  size_t sVar2;
  mbedtls_mpi *A;
  int iVar3;
  mbedtls_mpi *X;
  size_t sVar4;
  mbedtls_mpi *X_00;
  undefined auStack84 [4];
  mbedtls_mpi u;
  mbedtls_mpi Zi;
  mbedtls_mpi ZZi;
  
  if (t_len < 2) {
    iVar3 = ecp_normalize_jac(grp,*T);
  }
  else {
    X = (mbedtls_mpi *)mycalloc(t_len,0xc);
    if (X == (mbedtls_mpi *)0x0) {
      iVar3 = -0x4d80;
    }
    else {
      mbedtls_mpi_init((mbedtls_mpi *)auStack84);
      mbedtls_mpi_init((mbedtls_mpi *)&u.p);
      mbedtls_mpi_init((mbedtls_mpi *)&Zi.p);
      iVar3 = mbedtls_mpi_copy(X,&(*T)->Z);
      if (iVar3 == 0) {
        sVar2 = 1;
        A = X;
        do {
          sVar4 = sVar2;
          X_00 = A + 1;
          iVar3 = mbedtls_mpi_mul_mpi(X_00,A,&T[sVar4]->Z);
          if ((iVar3 != 0) || (iVar3 = ecp_modp(X_00,grp), iVar3 != 0)) goto cleanup;
          sVar2 = sVar4 + 1;
          A = X_00;
        } while (t_len != sVar4 + 1);
        iVar3 = mbedtls_mpi_inv_mod((mbedtls_mpi *)auStack84,X + (t_len - 1),&grp->P);
        if (iVar3 == 0) {
          T = T + t_len;
          do {
            if (sVar4 == 0) {
              iVar3 = mbedtls_mpi_copy((mbedtls_mpi *)&u.p,(mbedtls_mpi *)auStack84);
            }
            else {
              iVar3 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&u.p,(mbedtls_mpi *)auStack84,
                                          X + (sVar4 - 1));
              if (((iVar3 != 0) || (iVar3 = ecp_modp((mbedtls_mpi *)&u.p,grp), iVar3 != 0)) ||
                 (iVar3 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)auStack84,(mbedtls_mpi *)auStack84,
                                              &T[-1]->Z), iVar3 != 0)) break;
              iVar3 = ecp_modp((mbedtls_mpi *)auStack84,grp);
            }
            if (((((iVar3 != 0) ||
                  (iVar3 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&Zi.p,(mbedtls_mpi *)&u.p,
                                               (mbedtls_mpi *)&u.p), iVar3 != 0)) ||
                 ((iVar3 = ecp_modp((mbedtls_mpi *)&Zi.p,grp), iVar3 != 0 ||
                  ((iVar3 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)T[-1],(mbedtls_mpi *)T[-1],
                                                (mbedtls_mpi *)&Zi.p), iVar3 != 0 ||
                   (iVar3 = ecp_modp((mbedtls_mpi *)T[-1],grp), iVar3 != 0)))))) ||
                (iVar3 = mbedtls_mpi_mul_mpi(&T[-1]->Y,&T[-1]->Y,(mbedtls_mpi *)&Zi.p), iVar3 != 0))
               || ((((iVar3 = ecp_modp(&T[-1]->Y,grp), iVar3 != 0 ||
                     (iVar3 = mbedtls_mpi_mul_mpi(&T[-1]->Y,&T[-1]->Y,(mbedtls_mpi *)&u.p),
                     iVar3 != 0)) || (iVar3 = ecp_modp(&T[-1]->Y,grp), iVar3 != 0)) ||
                   ((iVar3 = mbedtls_mpi_shrink((mbedtls_mpi *)T[-1],(grp->P).n), iVar3 != 0 ||
                    (iVar3 = mbedtls_mpi_shrink(&T[-1]->Y,(grp->P).n), iVar3 != 0)))))) break;
            ppmVar1 = T + -1;
            T = T + -1;
            mbedtls_mpi_free(&(*ppmVar1)->Z);
            if (sVar4 == 0) break;
            sVar4 = sVar4 - 1;
          } while( true );
        }
      }
cleanup:
      mbedtls_mpi_free((mbedtls_mpi *)auStack84);
      mbedtls_mpi_free((mbedtls_mpi *)&u.p);
      mbedtls_mpi_free((mbedtls_mpi *)&Zi.p);
      A = X;
      do {
        X_00 = A + 1;
        mbedtls_mpi_free(A);
        A = X_00;
      } while (X + t_len != X_00);
      vPortFree(X);
    }
  }
  return iVar3;
}



void mbedtls_ecp_point_init(mbedtls_ecp_point *pt)

{
  mbedtls_mpi_init((mbedtls_mpi *)pt);
  mbedtls_mpi_init(&pt->Y);
  mbedtls_mpi_init(&pt->Z);
  return;
}



void mbedtls_ecp_point_free(mbedtls_ecp_point *pt)

{
  mbedtls_mpi_free((mbedtls_mpi *)pt);
  mbedtls_mpi_free(&pt->Y);
  mbedtls_mpi_free(&pt->Z);
  return;
}



mbedtls_ecp_group_id * mbedtls_ecp_grp_id_list(void)

{
  int init_done;
  int iVar1;
  mbedtls_ecp_curve_info *pmVar2;
  
  if (init_done == 0) {
    iVar1 = 0;
    pmVar2 = ecp_supported_curves;
    while (pmVar2->grp_id != MBEDTLS_ECP_DP_NONE) {
      ecp_supported_grp_id[iVar1] = pmVar2->grp_id;
      pmVar2 = pmVar2 + 1;
      iVar1 = iVar1 + 1;
    }
    ecp_supported_grp_id[iVar1] = MBEDTLS_ECP_DP_NONE;
  }
  return ecp_supported_grp_id;
}



void mbedtls_ecp_point_init(mbedtls_ecp_point *pt)

{
  if (pt != (mbedtls_ecp_point *)0x0) {
    mbedtls_ecp_point_init(pt);
    return;
  }
  return;
}



void mbedtls_ecp_group_init(mbedtls_ecp_group *grp)

{
  if (grp != (mbedtls_ecp_group *)0x0) {
    memset(grp,0,0x7c);
    return;
  }
  return;
}



void mbedtls_ecp_keypair_init(mbedtls_ecp_keypair *key)

{
  if (key != (mbedtls_ecp_keypair *)0x0) {
    mbedtls_ecp_group_init((mbedtls_ecp_group *)key);
    mbedtls_mpi_init(&key->d);
    mbedtls_ecp_point_init(&key->Q);
    return;
  }
  return;
}



void mbedtls_ecp_point_free(mbedtls_ecp_point *pt)

{
  if (pt != (mbedtls_ecp_point *)0x0) {
    mbedtls_ecp_point_free(pt);
    return;
  }
  return;
}



void mbedtls_ecp_group_free(mbedtls_ecp_group *grp)

{
  uint uVar1;
  mbedtls_ecp_group *pmVar2;
  
  if (grp != (mbedtls_ecp_group *)0x0) {
    if (grp->h != 1) {
      mbedtls_mpi_free(&grp->P);
      mbedtls_mpi_free(&grp->A);
      mbedtls_mpi_free(&grp->B);
      mbedtls_ecp_point_free(&grp->G);
      mbedtls_mpi_free(&grp->N);
    }
    uVar1 = 0;
    if (grp->T != (mbedtls_ecp_point *)0x0) {
      while (uVar1 < grp->T_size) {
        mbedtls_ecp_point_free(grp->T + uVar1);
        uVar1 = uVar1 + 1;
      }
      vPortFree(grp->T);
    }
    pmVar2 = grp + 1;
    while (grp != pmVar2) {
      grp->id = MBEDTLS_ECP_DP_NONE;
      grp = (mbedtls_ecp_group *)&grp->field_0x1;
    }
    return;
  }
  return;
}



void mbedtls_ecp_keypair_free(mbedtls_ecp_keypair *key)

{
  if (key != (mbedtls_ecp_keypair *)0x0) {
    mbedtls_ecp_group_free((mbedtls_ecp_group *)key);
    mbedtls_mpi_free(&key->d);
    mbedtls_ecp_point_free(&key->Q);
    return;
  }
  return;
}



int mbedtls_ecp_copy(mbedtls_ecp_point *P,mbedtls_ecp_point *Q)

{
  int iVar1;
  
  iVar1 = mbedtls_mpi_copy((mbedtls_mpi *)P,(mbedtls_mpi *)Q);
  if ((iVar1 == 0) && (iVar1 = mbedtls_mpi_copy(&P->Y,&Q->Y), iVar1 == 0)) {
    iVar1 = mbedtls_mpi_copy(&P->Z,&Q->Z);
    return iVar1;
  }
  return iVar1;
}



int mbedtls_ecp_group_copy(mbedtls_ecp_group *dst,mbedtls_ecp_group *src)

{
  int iVar1;
  
  iVar1 = mbedtls_ecp_group_load(dst,src->id);
  return iVar1;
}



int mbedtls_ecp_set_zero(mbedtls_ecp_point *pt)

{
  int iVar1;
  
  iVar1 = mbedtls_mpi_lset((mbedtls_mpi *)pt,1);
  if ((iVar1 == 0) && (iVar1 = mbedtls_mpi_lset(&pt->Y,1), iVar1 == 0)) {
    iVar1 = mbedtls_mpi_lset(&pt->Z,0);
    return iVar1;
  }
  return iVar1;
}



int ecp_add_mixed(mbedtls_ecp_group *grp,mbedtls_ecp_point *R,mbedtls_ecp_point *P,
                 mbedtls_ecp_point *Q)

{
  int iVar1;
  mbedtls_ecp_point *Q_00;
  mbedtls_mpi *X_00;
  mbedtls_mpi *X_01;
  int iStack132;
  mbedtls_mpi T1;
  mbedtls_mpi T2;
  mbedtls_mpi T3;
  mbedtls_mpi T4;
  mbedtls_mpi X;
  mbedtls_mpi Y;
  mbedtls_mpi Z;
  
  X_01 = &P->Z;
  iVar1 = mbedtls_mpi_cmp_int(X_01,0);
  Q_00 = Q;
  if (iVar1 == 0) {
LAB_2306410a:
    iVar1 = mbedtls_ecp_copy(R,Q_00);
  }
  else {
    if ((Q->Z).p != (mbedtls_mpi_uint *)0x0) {
      iVar1 = mbedtls_mpi_cmp_int(&Q->Z,0);
      Q_00 = P;
      if (iVar1 == 0) goto LAB_2306410a;
      if (((Q->Z).p != (mbedtls_mpi_uint *)0x0) &&
         (iVar1 = mbedtls_mpi_cmp_int(&Q->Z,1), iVar1 != 0)) {
        return -0x4f80;
      }
    }
    mbedtls_mpi_init((mbedtls_mpi *)&iStack132);
    mbedtls_mpi_init((mbedtls_mpi *)&T1.p);
    mbedtls_mpi_init((mbedtls_mpi *)&T2.p);
    mbedtls_mpi_init((mbedtls_mpi *)&T3.p);
    X_00 = (mbedtls_mpi *)&T4.p;
    mbedtls_mpi_init(X_00);
    mbedtls_mpi_init((mbedtls_mpi *)&X.p);
    mbedtls_mpi_init((mbedtls_mpi *)&Y.p);
    iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&iStack132,X_01,X_01);
    if ((((iVar1 == 0) && (iVar1 = ecp_modp((mbedtls_mpi *)&iStack132,grp), iVar1 == 0)) &&
        (iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&T1.p,(mbedtls_mpi *)&iStack132,X_01),
        iVar1 == 0)) &&
       (((iVar1 = ecp_modp((mbedtls_mpi *)&T1.p,grp), iVar1 == 0 &&
         (iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&iStack132,(mbedtls_mpi *)&iStack132,
                                      (mbedtls_mpi *)Q), iVar1 == 0)) &&
        ((iVar1 = ecp_modp((mbedtls_mpi *)&iStack132,grp), iVar1 == 0 &&
         ((iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&T1.p,(mbedtls_mpi *)&T1.p,&Q->Y), iVar1 == 0
          && (iVar1 = ecp_modp((mbedtls_mpi *)&T1.p,grp), iVar1 == 0)))))))) {
      iVar1 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)&iStack132,(mbedtls_mpi *)&iStack132,
                                  (mbedtls_mpi *)P);
      while (iVar1 == 0) {
        if ((-1 < iStack132) ||
           (iVar1 = mbedtls_mpi_cmp_int((mbedtls_mpi *)&iStack132,0), iVar1 == 0)) {
          iVar1 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)&T1.p,(mbedtls_mpi *)&T1.p,&P->Y);
          goto joined_r0x23064178;
        }
        iVar1 = mbedtls_mpi_add_mpi((mbedtls_mpi *)&iStack132,(mbedtls_mpi *)&iStack132,&grp->P);
      }
    }
cleanup:
    mbedtls_mpi_free((mbedtls_mpi *)&iStack132);
    mbedtls_mpi_free((mbedtls_mpi *)&T1.p);
    mbedtls_mpi_free((mbedtls_mpi *)&T2.p);
    mbedtls_mpi_free((mbedtls_mpi *)&T3.p);
    mbedtls_mpi_free(X_00);
    mbedtls_mpi_free((mbedtls_mpi *)&X.p);
    mbedtls_mpi_free((mbedtls_mpi *)&Y.p);
  }
  return iVar1;
joined_r0x23064178:
  if (iVar1 != 0) goto cleanup;
  if ((-1 < (int)T1.p) || (iVar1 = mbedtls_mpi_cmp_int((mbedtls_mpi *)&T1.p,0), iVar1 == 0)) {
    iVar1 = mbedtls_mpi_cmp_int((mbedtls_mpi *)&iStack132,0);
    if (iVar1 == 0) {
      iVar1 = mbedtls_mpi_cmp_int((mbedtls_mpi *)&T1.p,0);
      if (iVar1 == 0) {
        iVar1 = ecp_double_jac(grp,R,P);
      }
      else {
        iVar1 = mbedtls_ecp_set_zero(R);
      }
    }
    else {
      iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&Y.p,X_01,(mbedtls_mpi *)&iStack132);
      if (((((iVar1 == 0) && (iVar1 = ecp_modp((mbedtls_mpi *)&Y.p,grp), iVar1 == 0)) &&
           (iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&T2.p,(mbedtls_mpi *)&iStack132,
                                        (mbedtls_mpi *)&iStack132), iVar1 == 0)) &&
          ((iVar1 = ecp_modp((mbedtls_mpi *)&T2.p,grp), iVar1 == 0 &&
           (iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&T3.p,(mbedtls_mpi *)&T2.p,
                                        (mbedtls_mpi *)&iStack132), iVar1 == 0)))) &&
         ((iVar1 = ecp_modp((mbedtls_mpi *)&T3.p,grp), iVar1 == 0 &&
          ((iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&T2.p,(mbedtls_mpi *)&T2.p,(mbedtls_mpi *)P),
           iVar1 == 0 && (iVar1 = ecp_modp((mbedtls_mpi *)&T2.p,grp), iVar1 == 0)))))) {
        iVar1 = mbedtls_mpi_mul_int((mbedtls_mpi *)&iStack132,(mbedtls_mpi *)&T2.p,2);
        X_01 = &grp->P;
        goto joined_r0x23064214;
      }
    }
    goto cleanup;
  }
  iVar1 = mbedtls_mpi_add_mpi((mbedtls_mpi *)&T1.p,(mbedtls_mpi *)&T1.p,&grp->P);
  goto joined_r0x23064178;
joined_r0x23064214:
  if (iVar1 != 0) goto cleanup;
  iVar1 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&iStack132,X_01);
  if (iVar1 < 0) {
    iVar1 = mbedtls_mpi_mul_mpi(X_00,(mbedtls_mpi *)&T1.p,(mbedtls_mpi *)&T1.p);
    if ((iVar1 == 0) && (iVar1 = ecp_modp(X_00,grp), iVar1 == 0)) {
      iVar1 = mbedtls_mpi_sub_mpi(X_00,X_00,(mbedtls_mpi *)&iStack132);
      goto joined_r0x23064250;
    }
    goto cleanup;
  }
  iVar1 = mbedtls_mpi_sub_abs((mbedtls_mpi *)&iStack132,(mbedtls_mpi *)&iStack132,X_01);
  goto joined_r0x23064214;
joined_r0x23064250:
  if (iVar1 != 0) goto cleanup;
  if ((-1 < (int)T4.p) || (iVar1 = mbedtls_mpi_cmp_int(X_00,0), iVar1 == 0)) {
    iVar1 = mbedtls_mpi_sub_mpi(X_00,X_00,(mbedtls_mpi *)&T3.p);
    goto LAB_23064264;
  }
  iVar1 = mbedtls_mpi_add_mpi(X_00,X_00,X_01);
  goto joined_r0x23064250;
LAB_23064264:
  if (iVar1 != 0) goto cleanup;
  if ((-1 < (int)T4.p) || (iVar1 = mbedtls_mpi_cmp_int(X_00,0), iVar1 == 0)) {
    iVar1 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)&T2.p,(mbedtls_mpi *)&T2.p,X_00);
    goto LAB_2306427a;
  }
  iVar1 = mbedtls_mpi_add_mpi(X_00,X_00,X_01);
  goto LAB_23064264;
LAB_2306427a:
  if (iVar1 != 0) goto cleanup;
  if ((-1 < (int)T2.p) || (iVar1 = mbedtls_mpi_cmp_int((mbedtls_mpi *)&T2.p,0), iVar1 == 0)) {
    iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&T2.p,(mbedtls_mpi *)&T2.p,(mbedtls_mpi *)&T1.p);
    if ((iVar1 == 0) &&
       (((iVar1 = ecp_modp((mbedtls_mpi *)&T2.p,grp), iVar1 == 0 &&
         (iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&T3.p,(mbedtls_mpi *)&T3.p,&P->Y), iVar1 == 0))
        && (iVar1 = ecp_modp((mbedtls_mpi *)&T3.p,grp), iVar1 == 0)))) {
      iVar1 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)&X.p,(mbedtls_mpi *)&T2.p,(mbedtls_mpi *)&T3.p);
      goto LAB_230642cc;
    }
    goto cleanup;
  }
  iVar1 = mbedtls_mpi_add_mpi((mbedtls_mpi *)&T2.p,(mbedtls_mpi *)&T2.p,X_01);
  goto LAB_2306427a;
LAB_230642cc:
  if (iVar1 != 0) goto cleanup;
  if ((-1 < (int)X.p) || (iVar1 = mbedtls_mpi_cmp_int((mbedtls_mpi *)&X.p,0), iVar1 == 0)) {
    iVar1 = mbedtls_mpi_copy((mbedtls_mpi *)R,X_00);
    if ((iVar1 == 0) && (iVar1 = mbedtls_mpi_copy(&R->Y,(mbedtls_mpi *)&X.p), iVar1 == 0)) {
      iVar1 = mbedtls_mpi_copy(&R->Z,(mbedtls_mpi *)&Y.p);
    }
    goto cleanup;
  }
  iVar1 = mbedtls_mpi_add_mpi((mbedtls_mpi *)&X.p,(mbedtls_mpi *)&X.p,X_01);
  goto LAB_230642cc;
}



int ecp_mul_comb(mbedtls_ecp_group *grp,mbedtls_ecp_point *R,mbedtls_mpi *m,mbedtls_ecp_point *P,
                anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  uint uVar4;
  mbedtls_mpi_uint **ppmVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  uint uVar10;
  uchar t_len;
  uint uVar11;
  uint uVar12;
  mbedtls_ecp_point *P_00;
  mbedtls_ecp_point *P_01;
  uint uVar13;
  uint uVar14;
  size_t pos;
  mbedtls_mpi *X;
  uint numitems;
  uint uVar15;
  mbedtls_mpi_uint **ppmVar16;
  int iVar17;
  size_t t_len_00;
  undefined auStack412 [4];
  mbedtls_mpi M;
  mbedtls_mpi mm;
  mbedtls_mpi l;
  mbedtls_mpi ll;
  mbedtls_ecp_point Txi;
  uchar k [262];
  
  mbedtls_mpi_init((mbedtls_mpi *)auStack412);
  mbedtls_mpi_init((mbedtls_mpi *)&M.p);
  iVar6 = mbedtls_mpi_get_bit(&grp->N,0);
  if (iVar6 != 1) {
    return -0x4f80;
  }
  uVar13 = (uint)(0x17f < grp->nbits);
  iVar6 = mbedtls_mpi_cmp_mpi(&P->Y,&(grp->G).Y);
  uVar14 = uVar13 + 4;
  if (iVar6 == 0) {
    iVar7 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)P,(mbedtls_mpi *)&grp->G);
    if (iVar7 == 0) {
      uVar14 = uVar13 + 5;
      iVar6 = 1;
    }
  }
  else {
    iVar6 = 0;
  }
  if (grp->nbits <= uVar14) {
    uVar14 = 2;
  }
  uVar15 = uVar14 - 1;
  numitems = 1 << (uVar15 & 0x1f);
  uVar13 = ((grp->nbits - 1) + uVar14) / uVar14;
  if ((iVar6 == 0) || (P_01 = grp->T, P_01 == (mbedtls_ecp_point *)0x0)) {
    P_01 = (mbedtls_ecp_point *)mycalloc(numitems,0x24);
    if (P_01 == (mbedtls_ecp_point *)0x0) {
      iVar7 = -0x4d80;
      goto LAB_2306451a;
    }
    iVar7 = mbedtls_ecp_copy(P_01,P);
    if (iVar7 == 0) {
      t_len_00 = 0;
      uVar11 = 1;
      while (uVar12 = uVar11 >> (uVar15 & 0x1f), uVar12 == 0) {
        P_00 = P_01 + uVar11;
        iVar7 = mbedtls_ecp_copy(P_00,P_01 + (uVar11 >> 1));
        if (iVar7 != 0) goto LAB_230644f6;
        while (uVar13 != uVar12) {
          iVar7 = ecp_double_jac(grp,P_00,P_00);
          if (iVar7 != 0) goto LAB_230644f6;
          uVar12 = uVar12 + 1;
        }
        *(mbedtls_ecp_point **)(&Txi.Z.p + t_len_00) = P_00;
        uVar11 = (uVar11 & 0x7f) << 1;
        t_len_00 = t_len_00 + 1 & 0xff;
      }
      iVar7 = ecp_normalize_jac_many(grp,(mbedtls_ecp_point **)&Txi.Z.p,t_len_00);
      if (iVar7 == 0) {
        t_len_00 = 0;
        uVar11 = 1;
        while (uVar11 >> (uVar15 & 0x1f) == 0) {
          uVar10 = t_len_00 + uVar11;
          P_00 = P_01 + uVar11;
          uVar12 = uVar11;
          while( true ) {
            t_len_00 = (uVar10 & 0xff) - uVar12 & 0xff;
            uVar4 = uVar12 - 1;
            if (uVar12 == 0) break;
            iVar7 = ecp_add_mixed(grp,P_00 + uVar4,P_01 + uVar4,P_00);
            if (iVar7 != 0) goto LAB_230644f6;
            *(mbedtls_ecp_point **)(&Txi.Z.p + t_len_00) = P_00 + uVar4;
            uVar12 = uVar4;
          }
          uVar11 = (uVar11 & 0x7f) << 1;
        }
        iVar7 = ecp_normalize_jac_many(grp,(mbedtls_ecp_point **)&Txi.Z.p,t_len_00);
        if (iVar7 == 0) {
          if (iVar6 != 0) {
            grp->T = P_01;
            grp->T_size = numitems;
          }
          goto LAB_23064618;
        }
      }
    }
  }
  else {
LAB_23064618:
    iVar8 = mbedtls_mpi_get_bit(m,0);
    iVar7 = mbedtls_mpi_copy((mbedtls_mpi *)auStack412,m);
    if ((iVar7 == 0) && (iVar7 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)&M.p,&grp->N,m), iVar7 == 0)) {
      iVar7 = mbedtls_mpi_safe_cond_assign((mbedtls_mpi *)auStack412,(mbedtls_mpi *)&M.p,iVar8 != 1)
      ;
      if (iVar7 == 0) {
        ppmVar5 = &Txi.Z.p;
        memset(&Txi.Z.p,0,uVar13 + 1);
        t_len_00 = 0;
        ppmVar16 = ppmVar5;
        while (uVar13 != t_len_00) {
          uVar15 = 0;
          pos = t_len_00;
          do {
            iVar7 = mbedtls_mpi_get_bit((mbedtls_mpi *)auStack412,pos);
            *(byte *)ppmVar16 = (byte)(iVar7 << (uVar15 & 0x1f)) | *(byte *)ppmVar16;
            uVar15 = uVar15 + 1;
            pos = pos + uVar13;
          } while (uVar15 < uVar14);
          t_len_00 = t_len_00 + 1;
          ppmVar16 = (mbedtls_mpi_uint **)((int)ppmVar16 + 1);
        }
        uVar13 = 0;
        while (ppmVar5 != (mbedtls_mpi_uint **)((int)&Txi.Z.p + t_len_00)) {
          bVar1 = *(byte *)((int)ppmVar5 + 1);
          uVar14 = bVar1 ^ uVar13;
          uVar15 = ~uVar14 & 1;
          bVar3 = *(byte *)ppmVar5 * (char)uVar15;
          *(byte *)ppmVar5 = (byte)(uVar15 << 7) | *(byte *)ppmVar5;
          bVar2 = (byte)uVar14;
          *(byte *)(mbedtls_mpi_uint **)((int)ppmVar5 + 1) = bVar2 ^ bVar3;
          uVar13 = bVar1 & uVar13 | (int)(char)(bVar2 & bVar3) & 0xffU;
          ppmVar5 = (mbedtls_mpi_uint **)((int)ppmVar5 + 1);
        }
        mbedtls_ecp_point_init((mbedtls_ecp_point *)&ll.p);
        t_len = (uchar)(numitems & 0xff);
        iVar7 = ecp_select_comb(grp,R,P_01,t_len,*(uchar *)((int)&Txi.Z.p + t_len_00));
        if (iVar7 == 0) {
          X = &R->Z;
          iVar9 = mbedtls_mpi_lset(X,1);
          iVar7 = iVar9;
          if (iVar9 == 0) {
            if (f_rng != (anon_subr_int_void_ptr_uchar_ptr_size_t *)0x0) {
              pos = grp->pbits;
              mbedtls_mpi_init((mbedtls_mpi *)&mm.p);
              mbedtls_mpi_init((mbedtls_mpi *)&l.p);
              iVar17 = 0xc;
              do {
                mbedtls_mpi_fill_random((mbedtls_mpi *)&mm.p,pos + 7 >> 3,f_rng,p_rng);
                while (iVar7 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&mm.p,&grp->P), -1 < iVar7) {
                  iVar7 = mbedtls_mpi_shift_r((mbedtls_mpi *)&mm.p,1);
                  if (iVar7 != 0) goto cleanup;
                }
                iVar17 = iVar17 + -1;
                if (iVar17 == 0) {
                  iVar7 = -0x4d00;
                  goto cleanup;
                }
                iVar7 = mbedtls_mpi_cmp_int((mbedtls_mpi *)&mm.p,1);
              } while (iVar7 < 1);
              iVar7 = mbedtls_mpi_mul_mpi(X,X,(mbedtls_mpi *)&mm.p);
              if ((((iVar7 == 0) && (iVar7 = ecp_modp(X,grp), iVar7 == 0)) &&
                  (iVar7 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&l.p,(mbedtls_mpi *)&mm.p,
                                               (mbedtls_mpi *)&mm.p), iVar7 == 0)) &&
                 (((iVar7 = ecp_modp((mbedtls_mpi *)&l.p,grp), iVar7 == 0 &&
                   (iVar7 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)R,(mbedtls_mpi *)R,
                                                (mbedtls_mpi *)&l.p), iVar7 == 0)) &&
                  ((iVar7 = ecp_modp((mbedtls_mpi *)R,grp), iVar7 == 0 &&
                   ((iVar7 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&l.p,(mbedtls_mpi *)&l.p,
                                                 (mbedtls_mpi *)&mm.p), iVar7 == 0 &&
                    (iVar7 = ecp_modp((mbedtls_mpi *)&l.p,grp), iVar7 == 0)))))))) {
                X = &R->Y;
                iVar7 = mbedtls_mpi_mul_mpi(X,X,(mbedtls_mpi *)&l.p);
                if (iVar7 == 0) {
                  iVar7 = ecp_modp(X,grp);
                }
              }
cleanup:
              mbedtls_mpi_free((mbedtls_mpi *)&mm.p);
              mbedtls_mpi_free((mbedtls_mpi *)&l.p);
              if (iVar7 != 0) goto cleanup;
            }
            do {
              iVar7 = iVar9;
              if (((t_len_00 - 1 == 0xffffffff) || (iVar7 = ecp_double_jac(grp,R,R), iVar7 != 0)) ||
                 (iVar7 = ecp_select_comb(grp,(mbedtls_ecp_point *)&ll.p,P_01,t_len,
                                          *(uchar *)((int)&Txi.Z.n + t_len_00 + 3)), iVar7 != 0))
              break;
              iVar7 = ecp_add_mixed(grp,R,R,(mbedtls_ecp_point *)&ll.p);
              t_len_00 = t_len_00 - 1;
            } while (iVar7 == 0);
          }
        }
cleanup:
        mbedtls_ecp_point_free((mbedtls_ecp_point *)&ll.p);
        if ((iVar7 == 0) && (iVar7 = ecp_safe_invert_jac(grp,R,iVar8 != 1), iVar7 == 0)) {
          iVar7 = ecp_normalize_jac(grp,R);
        }
      }
    }
  }
LAB_230644f6:
  if (iVar6 == 0) {
    uVar13 = 0;
    do {
      uVar14 = uVar13 + 1;
      mbedtls_ecp_point_free(P_01 + uVar13);
      uVar13 = uVar14;
    } while ((uVar14 & 0xff) < (numitems & 0xff));
    vPortFree(P_01);
  }
LAB_2306451a:
  mbedtls_mpi_free((mbedtls_mpi *)auStack412);
  mbedtls_mpi_free((mbedtls_mpi *)&M.p);
  if (iVar7 != 0) {
    mbedtls_ecp_point_free(R);
  }
  return iVar7;
}



int mbedtls_ecp_point_read_binary
              (mbedtls_ecp_group *grp,mbedtls_ecp_point *pt,uchar *buf,size_t ilen)

{
  int iVar1;
  size_t buflen;
  
  if (ilen != 0) {
    if (*buf != '\0') {
      buflen = mbedtls_mpi_size(&grp->P);
      if (*buf == '\x04') {
        if (ilen == buflen * 2 + 1) {
          iVar1 = mbedtls_mpi_read_binary((mbedtls_mpi *)pt,buf + 1,buflen);
          if ((iVar1 == 0) &&
             (iVar1 = mbedtls_mpi_read_binary(&pt->Y,buf + buflen + 1,buflen), iVar1 == 0)) {
            iVar1 = mbedtls_mpi_lset(&pt->Z,1);
            return iVar1;
          }
        }
        else {
          iVar1 = -0x4f80;
        }
      }
      else {
        iVar1 = -0x4e80;
      }
      return iVar1;
    }
    if (ilen == 1) {
      iVar1 = mbedtls_ecp_set_zero(pt);
      return iVar1;
    }
  }
  return -0x4f80;
}



int mbedtls_ecp_check_pubkey(mbedtls_ecp_group *grp,mbedtls_ecp_point *pt)

{
  mbedtls_mpi *X;
  ecp_curve_type eVar1;
  int iVar2;
  undefined3 extraout_var;
  mbedtls_mpi *Y;
  undefined auStack56 [4];
  mbedtls_mpi YY;
  mbedtls_mpi RHS;
  
  iVar2 = mbedtls_mpi_cmp_int(&pt->Z,1);
  if (iVar2 == 0) {
    eVar1 = ecp_get_type(grp);
    if (CONCAT31(extraout_var,eVar1) != 1) {
      return -0x4f80;
    }
    iVar2 = mbedtls_mpi_cmp_int((mbedtls_mpi *)pt,0);
    if (-1 < iVar2) {
      X = &pt->Y;
      iVar2 = mbedtls_mpi_cmp_int(X,0);
      if (-1 < iVar2) {
        Y = &grp->P;
        iVar2 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)pt,Y);
        if ((iVar2 < 0) && (iVar2 = mbedtls_mpi_cmp_mpi(X,Y), iVar2 < 0)) {
          mbedtls_mpi_init((mbedtls_mpi *)auStack56);
          mbedtls_mpi_init((mbedtls_mpi *)&YY.p);
          iVar2 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)auStack56,X,X);
          if ((iVar2 == 0) &&
             (((iVar2 = ecp_modp((mbedtls_mpi *)auStack56,grp), iVar2 == 0 &&
               (iVar2 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&YY.p,(mbedtls_mpi *)pt,(mbedtls_mpi *)pt
                                           ), iVar2 == 0)) &&
              (iVar2 = ecp_modp((mbedtls_mpi *)&YY.p,grp), iVar2 == 0)))) {
            if ((grp->A).p == (mbedtls_mpi_uint *)0x0) {
              iVar2 = mbedtls_mpi_sub_int((mbedtls_mpi *)&YY.p,(mbedtls_mpi *)&YY.p,3);
              while (iVar2 == 0) {
                if ((-1 < (int)YY.p) ||
                   (iVar2 = mbedtls_mpi_cmp_int((mbedtls_mpi *)&YY.p,0), iVar2 == 0))
                goto LAB_230649e4;
                iVar2 = mbedtls_mpi_add_mpi((mbedtls_mpi *)&YY.p,(mbedtls_mpi *)&YY.p,Y);
              }
            }
            else {
              iVar2 = mbedtls_mpi_add_mpi((mbedtls_mpi *)&YY.p,(mbedtls_mpi *)&YY.p,&grp->A);
              while (iVar2 == 0) {
                iVar2 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&YY.p,Y);
                if (iVar2 < 0) goto LAB_230649e4;
                iVar2 = mbedtls_mpi_sub_abs((mbedtls_mpi *)&YY.p,(mbedtls_mpi *)&YY.p,Y);
              }
            }
          }
          goto cleanup;
        }
      }
    }
  }
  return -0x4c80;
LAB_230649e4:
  iVar2 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&YY.p,(mbedtls_mpi *)&YY.p,(mbedtls_mpi *)pt);
  if ((iVar2 == 0) && (iVar2 = ecp_modp((mbedtls_mpi *)&YY.p,grp), iVar2 == 0)) {
    iVar2 = mbedtls_mpi_add_mpi((mbedtls_mpi *)&YY.p,(mbedtls_mpi *)&YY.p,&grp->B);
    while (iVar2 == 0) {
      iVar2 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&YY.p,Y);
      if (iVar2 < 0) {
        iVar2 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)auStack56,(mbedtls_mpi *)&YY.p);
        if (iVar2 != 0) {
          iVar2 = -0x4c80;
        }
        break;
      }
      iVar2 = mbedtls_mpi_sub_abs((mbedtls_mpi *)&YY.p,(mbedtls_mpi *)&YY.p,Y);
    }
  }
cleanup:
  mbedtls_mpi_free((mbedtls_mpi *)auStack56);
  mbedtls_mpi_free((mbedtls_mpi *)&YY.p);
  return iVar2;
}



int mbedtls_ecp_check_privkey(mbedtls_ecp_group *grp,mbedtls_mpi *d)

{
  ecp_curve_type eVar1;
  undefined3 extraout_var;
  int iVar2;
  
  eVar1 = ecp_get_type(grp);
  if (CONCAT31(extraout_var,eVar1) == 1) {
    iVar2 = mbedtls_mpi_cmp_int(d,1);
    if ((-1 < iVar2) && (iVar2 = mbedtls_mpi_cmp_mpi(d,&grp->N), iVar2 < 0)) {
      return 0;
    }
    iVar2 = -0x4c80;
  }
  else {
    iVar2 = -0x4f80;
  }
  return iVar2;
}



int mbedtls_ecp_mul(mbedtls_ecp_group *grp,mbedtls_ecp_point *R,mbedtls_mpi *m,mbedtls_ecp_point *P,
                   anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng)

{
  ecp_curve_type eVar1;
  int iVar2;
  undefined3 extraout_var;
  
  iVar2 = mbedtls_mpi_cmp_int(&P->Z,1);
  if (iVar2 == 0) {
    iVar2 = mbedtls_ecp_check_privkey(grp,m);
    if (((iVar2 == 0) && (iVar2 = mbedtls_ecp_check_pubkey(grp,P), iVar2 == 0)) &&
       (eVar1 = ecp_get_type(grp), CONCAT31(extraout_var,eVar1) == 1)) {
      iVar2 = ecp_mul_comb(grp,R,m,P,f_rng,p_rng);
      return iVar2;
    }
  }
  else {
    iVar2 = -0x4f80;
  }
  return iVar2;
}



int mbedtls_ecp_check_pub_priv(mbedtls_ecp_keypair *pub,mbedtls_ecp_keypair *prv)

{
  mbedtls_ecp_group_id mVar1;
  int iVar2;
  mbedtls_mpi *Y;
  mbedtls_mpi *Y_00;
  undefined auStack192 [4];
  mbedtls_ecp_point Q;
  mbedtls_ecp_group grp;
  
  mVar1 = (pub->grp).id;
  if ((mVar1 != MBEDTLS_ECP_DP_NONE) && ((prv->grp).id == mVar1)) {
    iVar2 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&pub->Q,(mbedtls_mpi *)&prv->Q);
    if (iVar2 == 0) {
      Y_00 = &(prv->Q).Y;
      iVar2 = mbedtls_mpi_cmp_mpi(&(pub->Q).Y,Y_00);
      if (iVar2 == 0) {
        Y = &(prv->Q).Z;
        iVar2 = mbedtls_mpi_cmp_mpi(&(pub->Q).Z,Y);
        if (iVar2 == 0) {
          mbedtls_ecp_point_init((mbedtls_ecp_point *)auStack192);
          memset(&Q.Z.p,0,0x7c);
          mbedtls_ecp_group_copy((mbedtls_ecp_group *)&Q.Z.p,(mbedtls_ecp_group *)prv);
          iVar2 = mbedtls_ecp_mul((mbedtls_ecp_group *)&Q.Z.p,(mbedtls_ecp_point *)auStack192,
                                  &prv->d,&(prv->grp).G,
                                  (anon_subr_int_void_ptr_uchar_ptr_size_t *)0x0,(void *)0x0);
          if ((iVar2 == 0) &&
             (((iVar2 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)auStack192,(mbedtls_mpi *)&prv->Q),
               iVar2 != 0 || (iVar2 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&Q.X.p,Y_00), iVar2 != 0))
              || (iVar2 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&Q.Y.p,Y), iVar2 != 0)))) {
            iVar2 = -0x4f80;
          }
          mbedtls_ecp_point_free((mbedtls_ecp_point *)auStack192);
          mbedtls_ecp_group_free((mbedtls_ecp_group *)&Q.Z.p);
          return iVar2;
        }
      }
    }
  }
  return -0x4f80;
}



int ecp_mod_koblitz(mbedtls_mpi *N,mbedtls_mpi_uint *Rp,size_t p_limbs)

{
  int iVar1;
  uint uVar2;
  size_t sVar3;
  mbedtls_mpi_uint **__s;
  int iStack100;
  mbedtls_mpi M;
  mbedtls_mpi R;
  mbedtls_mpi_uint Mp [11];
  
  if (N->n < p_limbs) {
    return 0;
  }
  __s = &R.p;
  M.p = (mbedtls_mpi_uint *)0x1;
  R.s = 2;
  iStack100 = 1;
  uVar2 = N->n - p_limbs;
  M.s = p_limbs;
  if (uVar2 <= p_limbs) {
    M.s = uVar2;
  }
  M.n = (size_t)__s;
  R.n = (size_t)Rp;
  memset(__s,0,0x2c);
  memcpy(__s,N->p + p_limbs,M.s << 2);
  M.s = M.s + R.s;
  sVar3 = p_limbs;
  while (sVar3 < N->n) {
    N->p[sVar3] = 0;
    sVar3 = sVar3 + 1;
  }
  iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&iStack100,(mbedtls_mpi *)&iStack100,
                              (mbedtls_mpi *)&M.p);
  if ((iVar1 == 0) && (iVar1 = mbedtls_mpi_add_abs(N,N,(mbedtls_mpi *)&iStack100), iVar1 == 0)) {
    uVar2 = N->n - p_limbs;
    M.s = p_limbs;
    if (uVar2 <= p_limbs) {
      M.s = uVar2;
    }
    memset(__s,0,0x2c);
    memcpy(__s,N->p + p_limbs,M.s << 2);
    M.s = M.s + R.s;
    while (p_limbs < N->n) {
      N->p[p_limbs] = 0;
      p_limbs = p_limbs + 1;
    }
    iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&iStack100,(mbedtls_mpi *)&iStack100,
                                (mbedtls_mpi *)&M.p);
    if (iVar1 == 0) {
      iVar1 = mbedtls_mpi_add_abs(N,N,(mbedtls_mpi *)&iStack100);
    }
  }
  return iVar1;
}



int ecp_mod_p224k1(mbedtls_mpi *N)

{
  mbedtls_mpi_uint Rp [2];
  int iVar1;
  
  iVar1 = ecp_mod_koblitz(N,(mbedtls_mpi_uint *)&ram0x4200d980,7);
  return iVar1;
}



int ecp_mod_p256k1(mbedtls_mpi *N)

{
  mbedtls_mpi_uint Rp [2];
  int iVar1;
  
  iVar1 = ecp_mod_koblitz(N,(mbedtls_mpi_uint *)&ram0x4200d988,8);
  return iVar1;
}



int mbedtls_ecp_group_load(mbedtls_ecp_group *grp,mbedtls_ecp_group_id id)

{
  size_t sVar1;
  undefined3 in_register_0000202d;
  int iVar2;
  mbedtls_mpi_uint *pmVar3;
  
  iVar2 = CONCAT31(in_register_0000202d,id);
  mbedtls_ecp_group_free(grp);
  grp->id = id;
  if (iVar2 == 0xb) {
    (grp->P).p = secp224k1_p;
    (grp->A).p = secp224k1_a;
    (grp->B).p = secp224k1_b;
    (grp->N).n = 8;
    grp->modp = ecp_mod_p224k1;
    (grp->N).p = secp224k1_n;
    (grp->P).n = 7;
    (grp->G).X.n = 7;
    (grp->G).Y.n = 7;
    (grp->P).s = 1;
    (grp->A).s = 1;
    (grp->A).n = 1;
    (grp->B).s = 1;
    (grp->B).n = 1;
    (grp->N).s = 1;
    (grp->G).X.s = 1;
    (grp->G).X.p = secp224k1_gx;
    (grp->G).Y.s = 1;
    pmVar3 = secp224k1_gy;
  }
  else {
    if (iVar2 == 0xc) {
      (grp->P).p = secp256k1_p;
      (grp->A).p = secp256k1_a;
      (grp->B).p = secp256k1_b;
      grp->modp = ecp_mod_p256k1;
      (grp->N).p = secp256k1_n;
      (grp->P).n = 8;
      (grp->N).n = 8;
      (grp->G).X.n = 8;
      (grp->G).Y.n = 8;
      (grp->P).s = 1;
      (grp->A).s = 1;
      (grp->A).n = 1;
      (grp->B).s = 1;
      (grp->B).n = 1;
      (grp->N).s = 1;
      (grp->G).X.s = 1;
      (grp->G).X.p = secp256k1_gx;
      (grp->G).Y.s = 1;
      pmVar3 = secp256k1_gy;
    }
    else {
      if (iVar2 != 3) {
        mbedtls_ecp_group_free(grp);
        return -0x4e80;
      }
      (grp->P).p = secp256r1_p;
      (grp->B).p = secp256r1_b;
      (grp->N).p = secp256r1_n;
      (grp->P).n = 8;
      (grp->B).n = 8;
      (grp->N).n = 8;
      (grp->G).X.n = 8;
      (grp->G).Y.n = 8;
      (grp->P).s = 1;
      (grp->B).s = 1;
      (grp->N).s = 1;
      (grp->G).X.s = 1;
      (grp->G).X.p = secp256r1_gx;
      (grp->G).Y.s = 1;
      pmVar3 = secp256r1_gy;
    }
  }
  (grp->G).Y.p = pmVar3;
  (grp->G).Z.p = &one_2614;
  (grp->G).Z.s = 1;
  (grp->G).Z.n = 1;
  sVar1 = mbedtls_mpi_bitlen(&grp->P);
  grp->pbits = sVar1;
  sVar1 = mbedtls_mpi_bitlen(&grp->N);
  grp->nbits = sVar1;
  grp->h = 1;
  return 0;
}



void gcm_mult(mbedtls_gcm_context *ctx,uchar *x,uchar *output)

{
  mbedtls_cipher_info_t *pmVar1;
  mbedtls_cipher_info_t **ppmVar2;
  mbedtls_cipher_info_t *pmVar3;
  mbedtls_cipher_info_t *pmVar4;
  mbedtls_cipher_info_t *pmVar5;
  uint uVar6;
  int iVar7;
  uint uVar8;
  uint uVar9;
  
  iVar7 = 0xf;
  ppmVar2 = &(ctx->cipher_ctx).cipher_info + ((uint)x[0xf] & 0xf) * 2;
  pmVar1 = ppmVar2[0x30];
  pmVar4 = ppmVar2[0x31];
  pmVar5 = ppmVar2[0x10];
  pmVar3 = ppmVar2[0x11];
  do {
    uVar8 = (int)pmVar1 << 0x1c;
    uVar6 = (int)pmVar4 << 0x1c;
    if (iVar7 != 0xf) {
      ppmVar2 = &(ctx->cipher_ctx).cipher_info + ((uint)x[iVar7] & 0xf) * 2;
      pmVar4 = (mbedtls_cipher_info_t *)
               ((uint)ppmVar2[0x31] ^
               *(int *)(last4 + ((uint)pmVar5 & 0xf)) << 0x10 ^ (uint)pmVar4 >> 4);
      pmVar1 = (mbedtls_cipher_info_t *)((uint)ppmVar2[0x30] ^ (uVar6 | (uint)pmVar1 >> 4));
      pmVar5 = (mbedtls_cipher_info_t *)
               ((uint)ppmVar2[0x10] ^ ((uint)pmVar5 >> 4 | (int)pmVar3 << 0x1c));
      pmVar3 = (mbedtls_cipher_info_t *)((uint)ppmVar2[0x11] ^ (uVar8 | (uint)pmVar3 >> 4));
    }
    ppmVar2 = &(ctx->cipher_ctx).cipher_info + (uint)(x[iVar7] >> 4) * 2;
    uVar8 = (int)pmVar1 << 0x1c;
    uVar9 = (int)pmVar4 << 0x1c;
    uVar6 = (uint)ppmVar2[0x31] ^ (uint)pmVar4 >> 4;
    pmVar4 = (mbedtls_cipher_info_t *)(uVar6 ^ *(int *)(last4 + ((uint)pmVar5 & 0xf)) << 0x10);
    iVar7 = iVar7 + -1;
    pmVar1 = (mbedtls_cipher_info_t *)((uint)ppmVar2[0x30] ^ (uVar9 | (uint)pmVar1 >> 4));
    pmVar5 = (mbedtls_cipher_info_t *)
             ((uint)ppmVar2[0x10] ^ ((int)pmVar3 << 0x1c | (uint)pmVar5 >> 4));
    pmVar3 = (mbedtls_cipher_info_t *)((uint)ppmVar2[0x11] ^ (uVar8 | (uint)pmVar3 >> 4));
  } while (iVar7 != -1);
  *output = (uchar)((uint)pmVar4 >> 0x18);
  output[1] = (uchar)((uint)pmVar4 >> 0x10);
  output[3] = (uchar)uVar6;
  output[4] = (uchar)((uint)pmVar1 >> 0x18);
  output[5] = (uchar)((uint)pmVar1 >> 0x10);
  output[6] = (uchar)((uint)pmVar1 >> 8);
  output[8] = (uchar)((uint)pmVar3 >> 0x18);
  output[9] = (uchar)((uint)pmVar3 >> 0x10);
  output[10] = (uchar)((uint)pmVar3 >> 8);
  output[0xc] = (uchar)((uint)pmVar5 >> 0x18);
  output[0xd] = (uchar)((uint)pmVar5 >> 0x10);
  output[2] = (uchar)(uVar6 >> 8);
  output[7] = (uchar)pmVar1;
  output[0xb] = (uchar)pmVar3;
  output[0xe] = (uchar)((uint)pmVar5 >> 8);
  output[0xf] = (uchar)pmVar5;
  return;
}



void mbedtls_gcm_init(mbedtls_gcm_context *ctx)

{
  memset(ctx,0,0x188);
  return;
}



// WARNING: Variable defined which should be unmapped: h
// WARNING: Could not reconcile some variable overlaps

int mbedtls_gcm_setkey(mbedtls_gcm_context *ctx,mbedtls_cipher_id_t cipher,uchar *key,uint keybits)

{
  uint64_t *puVar1;
  uint uVar2;
  uint64_t *puVar3;
  mbedtls_cipher_info_t *cipher_info;
  int iVar4;
  uint uVar5;
  mbedtls_cipher_info_t **ppmVar6;
  mbedtls_cipher_info_t *pmVar7;
  mbedtls_cipher_info_t *pmVar8;
  int iVar9;
  mbedtls_cipher_info_t *pmVar10;
  uint64_t *puVar11;
  int iVar12;
  int iVar13;
  uint64_t *puVar14;
  uint uVar15;
  uint *puVar16;
  uint uVar17;
  size_t sStack36;
  size_t olen;
  uchar h [16];
  
  cipher_info = mbedtls_cipher_info_from_values(cipher,keybits,MBEDTLS_MODE_ECB);
  if (cipher_info == (mbedtls_cipher_info_t *)0x0) {
    iVar4 = -0x14;
  }
  else {
    iVar4 = -0x14;
    if (cipher_info->block_size == 0x10) {
      mbedtls_cipher_free((mbedtls_cipher_context_t *)ctx);
      iVar4 = mbedtls_cipher_setup((mbedtls_cipher_context_t *)ctx,cipher_info);
      if ((iVar4 == 0) &&
         (iVar4 = mbedtls_cipher_setkey((mbedtls_cipher_context_t *)ctx,key,keybits,MBEDTLS_ENCRYPT)
         , iVar4 == 0)) {
        sStack36 = 0;
        memset(&olen,0,0x10);
        iVar4 = mbedtls_cipher_update
                          ((mbedtls_cipher_context_t *)ctx,(uchar *)&olen,0x10,(uchar *)&olen,
                           &sStack36);
        if (iVar4 == 0) {
          cipher_info = (mbedtls_cipher_info_t *)
                        ((uint)h[0] << 0x18 | (uint)h[1] << 0x10 | (uint)h[3] | (uint)h[2] << 8);
          pmVar10 = (mbedtls_cipher_info_t *)
                    ((uint)(byte)olen << 0x18 | (uint)olen._1_1_ << 0x10 | (uint)olen._3_1_ |
                    (uint)olen._2_1_ << 8);
          pmVar8 = (mbedtls_cipher_info_t *)
                   ((uint)h[4] << 0x18 | (uint)h[5] << 0x10 | (uint)h[7] | (uint)h[6] << 8);
          *(undefined4 *)((int)ctx->HH + 4) = 0;
          *(undefined4 *)((int)ctx->HL + 4) = 0;
          *(mbedtls_cipher_info_t **)((int)ctx->HL + 0x44) = pmVar8;
          *(mbedtls_cipher_info_t **)(ctx->HH + 8) = cipher_info;
          *(mbedtls_cipher_info_t **)((int)ctx->HH + 0x44) = pmVar10;
          pmVar7 = (mbedtls_cipher_info_t *)
                   ((uint)h[8] << 0x18 | (uint)h[9] << 0x10 | (uint)h[11] | (uint)h[10] << 8);
          *(undefined4 *)ctx->HH = 0;
          *(undefined4 *)ctx->HL = 0;
          *(mbedtls_cipher_info_t **)(ctx->HL + 8) = pmVar7;
          iVar12 = 3;
          iVar13 = 4;
          do {
            uVar5 = (uint)pmVar7 & 1;
            uVar15 = (int)pmVar8 << 0x1f;
            pmVar8 = (mbedtls_cipher_info_t *)((int)cipher_info << 0x1f | (uint)pmVar8 >> 1);
            uVar2 = (int)pmVar10 << 0x1f;
            pmVar7 = (mbedtls_cipher_info_t *)(uVar15 | (uint)pmVar7 >> 1);
            pmVar10 = (mbedtls_cipher_info_t *)((uint)pmVar10 >> 1 ^ uVar5 * -0x1f000000);
            ppmVar6 = &(ctx->cipher_ctx).cipher_info + iVar13 * 2;
            cipher_info = (mbedtls_cipher_info_t *)(uVar2 | (uint)cipher_info >> 1);
            ppmVar6[0x10] = pmVar7;
            ppmVar6[0x11] = pmVar8;
            ppmVar6[0x30] = cipher_info;
            ppmVar6[0x31] = pmVar10;
            iVar12 = iVar12 + -1;
            iVar13 = iVar13 >> 1;
          } while (iVar12 != 0);
          iVar13 = 3;
          iVar12 = 2;
          do {
            puVar14 = ctx->HL + iVar12;
            puVar3 = ctx->HH + iVar12;
            uVar15 = *(uint *)puVar3;
            uVar5 = *(uint *)((int)puVar3 + 4);
            uVar2 = *(uint *)puVar14;
            uVar17 = *(uint *)((int)puVar14 + 4);
            iVar9 = 8;
            puVar1 = ctx->HL;
            do {
              puVar11 = puVar1 + 1;
              *(uint *)((int)puVar3 + iVar9) = *(uint *)(puVar11 + 0x10) ^ uVar15;
              ((uint *)((int)puVar3 + iVar9))[1] = *(uint *)((int)puVar1 + 0x8c) ^ uVar5;
              puVar16 = (uint *)((int)puVar14 + iVar9);
              iVar9 = iVar9 + 8;
              *puVar16 = *(uint *)puVar11 ^ uVar2;
              puVar16[1] = *(uint *)((int)puVar1 + 0xc) ^ uVar17;
              puVar1 = puVar11;
            } while (iVar12 * 8 != iVar9);
            iVar13 = iVar13 + -1;
            iVar12 = iVar12 << 1;
          } while (iVar13 != 0);
        }
      }
    }
  }
  return iVar4;
}



int mbedtls_gcm_starts(mbedtls_gcm_context *ctx,int mode,uchar *iv,size_t iv_len,uchar *add,
                      size_t add_len)

{
  byte bVar1;
  uint uVar2;
  int iVar3;
  byte *pbVar4;
  byte *pbVar5;
  byte *x;
  size_t *psVar6;
  uint uVar7;
  byte *x_00;
  size_t sStack68;
  size_t olen;
  uchar work_buf [16];
  
  x = ctx->y;
  sStack68 = 0;
  x_00 = ctx->buf;
  memset(x,0,0x10);
  memset(x_00,0,0x10);
  *(undefined4 *)&ctx->len = 0;
  *(undefined4 *)&ctx->add_len = 0;
  ctx->mode = mode;
  *(undefined4 *)((int)&ctx->len + 4) = 0;
  *(undefined4 *)((int)&ctx->add_len + 4) = 0;
  if (iv_len == 0xc) {
    memcpy(x,iv,0xc);
    ctx->y[0xf] = '\x01';
  }
  else {
    memset(&olen,0,0x10);
    while (iv_len != 0) {
      uVar2 = iv_len;
      if (0x10 < iv_len) {
        uVar2 = 0x10;
      }
      uVar7 = 0;
      pbVar4 = x;
      do {
        pbVar5 = iv + uVar7;
        uVar7 = uVar7 + 1;
        *pbVar4 = *pbVar5 ^ *pbVar4;
        pbVar4 = pbVar4 + 1;
      } while (uVar2 != uVar7);
      gcm_mult(ctx,x,x);
      iv_len = iv_len - uVar2;
      iv = iv + uVar2;
    }
    psVar6 = &olen;
    pbVar4 = x;
    do {
      bVar1 = *(byte *)psVar6;
      pbVar5 = pbVar4 + 1;
      psVar6 = (size_t *)((int)psVar6 + 1);
      *pbVar4 = *pbVar4 ^ bVar1;
      pbVar4 = pbVar5;
    } while (x_00 != pbVar5);
    gcm_mult(ctx,x,x);
  }
  iVar3 = mbedtls_cipher_update((mbedtls_cipher_context_t *)ctx,x,0x10,ctx->base_ectr,&sStack68);
  if (iVar3 == 0) {
    *(size_t *)&ctx->add_len = add_len;
    *(undefined4 *)((int)&ctx->add_len + 4) = 0;
    while (add_len != 0) {
      uVar2 = add_len;
      if (0x10 < add_len) {
        uVar2 = 0x10;
      }
      uVar7 = 0;
      x = x_00;
      do {
        pbVar4 = add + uVar7;
        uVar7 = uVar7 + 1;
        *x = *pbVar4 ^ *x;
        x = x + 1;
      } while (uVar2 != uVar7);
      gcm_mult(ctx,x_00,x_00);
      add_len = add_len - uVar2;
      add = add + uVar2;
    }
  }
  return iVar3;
}



int mbedtls_gcm_update(mbedtls_gcm_context *ctx,size_t length,uchar *input,uchar *output)

{
  uchar uVar1;
  int iVar2;
  byte bVar3;
  uint uVar4;
  uint uVar5;
  uchar *puVar6;
  uint uVar7;
  byte *x;
  byte *pbVar8;
  size_t sStack68;
  size_t olen;
  uchar ectr [16];
  
  sStack68 = 0;
  if ((output <= input) || (iVar2 = -0x14, length <= output + -(int)input)) {
    uVar4 = *(uint *)((int)&ctx->len + 4);
    uVar5 = length + *(uint *)&ctx->len;
    uVar7 = (uVar5 < length) + uVar4;
    if (((uVar7 < uVar4) || (((uVar4 == uVar7 && (uVar5 < *(uint *)&ctx->len)) || (0xf < uVar7))))
       || ((uVar7 == 0xf && (0xffffffe0 < uVar5)))) {
      iVar2 = -0x14;
    }
    else {
      *(uint *)&ctx->len = uVar5;
      *(uint *)((int)&ctx->len + 4) = uVar7;
      while (length != 0) {
        uVar4 = length;
        if (0x10 < length) {
          uVar4 = 0x10;
        }
        puVar6 = ctx->y + 0xf;
        do {
          uVar1 = *puVar6;
          *puVar6 = uVar1 + '\x01';
          if ((uchar)(uVar1 + '\x01') != '\0') break;
          puVar6 = puVar6 + -1;
        } while (puVar6 != ctx->y + 0xb);
        iVar2 = mbedtls_cipher_update
                          ((mbedtls_cipher_context_t *)ctx,ctx->y,0x10,(uchar *)&olen,&sStack68);
        if (iVar2 != 0) {
          return iVar2;
        }
        x = ctx->buf;
        uVar5 = 0;
        pbVar8 = x;
        do {
          if (ctx->mode == 0) {
            *pbVar8 = input[uVar5] ^ *pbVar8;
          }
          bVar3 = *(byte *)((int)&olen + uVar5) ^ input[uVar5];
          output[uVar5] = bVar3;
          if (ctx->mode == 1) {
            *pbVar8 = bVar3 ^ *pbVar8;
          }
          uVar5 = uVar5 + 1;
          pbVar8 = pbVar8 + 1;
        } while (uVar4 != uVar5);
        gcm_mult(ctx,x,x);
        length = length - uVar4;
        input = input + uVar4;
        output = output + uVar4;
      }
      iVar2 = 0;
    }
  }
  return iVar2;
}



// WARNING: Could not reconcile some variable overlaps

int mbedtls_gcm_finish(mbedtls_gcm_context *ctx,uchar *tag,size_t tag_len)

{
  byte bVar1;
  uint uVar2;
  uint uVar3;
  int *x;
  int iVar4;
  byte *pbVar5;
  int *piVar6;
  int *piVar7;
  byte *pbVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  byte local_40 [4];
  uchar work_buf [16];
  
  pbVar8 = local_40;
  uVar11 = *(uint *)&ctx->len;
  uVar12 = *(uint *)&ctx->add_len;
  uVar2 = *(int *)((int)&ctx->len + 4) << 3;
  uVar3 = uVar2 | uVar11 >> 0x1d;
  uVar9 = *(int *)((int)&ctx->add_len + 4) << 3;
  uVar10 = uVar12 >> 0x1d | uVar9;
  if (tag_len - 4 < 0xd) {
    memcpy(tag,ctx->base_ectr,tag_len);
    if (((uVar11 | uVar12) << 3 | uVar3 | uVar10) != 0) {
      memset(local_40,0,0x10);
      local_40[0] = (byte)(uVar9 >> 0x18);
      local_40[1] = (char)(uVar9 >> 0x10);
      local_40[2] = (char)(uVar9 >> 8);
      work_buf[0] = (uchar)((uVar12 << 3) >> 0x18);
      work_buf[1] = (uchar)((uVar12 << 3) >> 0x10);
      work_buf[4] = (uchar)(uVar2 >> 0x18);
      work_buf[5] = (uchar)(uVar2 >> 0x10);
      work_buf[6] = (uchar)(uVar2 >> 8);
      work_buf[8] = (uchar)((uVar11 << 3) >> 0x18);
      work_buf[7] = (uchar)uVar3;
      x = (int *)ctx->buf;
      work_buf[9] = (uchar)((uVar11 << 3) >> 0x10);
      local_40[3] = (char)uVar10;
      work_buf._2_2_ = (ushort)(uVar12 << 0xb) | (ushort)((uVar12 << 0x13) >> 0x18);
      work_buf._10_2_ = (ushort)(uVar11 << 0xb) | (ushort)((uVar11 << 0x13) >> 0x18);
      piVar6 = x;
      do {
        bVar1 = *pbVar8;
        piVar7 = (int *)((int)piVar6 + 1);
        pbVar8 = pbVar8 + 1;
        *(byte *)piVar6 = *(byte *)piVar6 ^ bVar1;
        piVar6 = piVar7;
      } while (piVar7 != &ctx->mode);
      gcm_mult(ctx,(uchar *)x,(uchar *)x);
      pbVar8 = tag;
      do {
        bVar1 = *(byte *)x;
        pbVar5 = pbVar8 + 1;
        x = (int *)((int)x + 1);
        *pbVar8 = *pbVar8 ^ bVar1;
        pbVar8 = pbVar5;
      } while (tag + tag_len != pbVar5);
    }
    iVar4 = 0;
  }
  else {
    iVar4 = -0x14;
  }
  return iVar4;
}



int mbedtls_gcm_crypt_and_tag
              (mbedtls_gcm_context *ctx,int mode,size_t length,uchar *iv,size_t iv_len,uchar *add,
              size_t add_len,uchar *input,uchar *output,size_t tag_len,uchar *tag)

{
  int iVar1;
  uchar *in_stack_00000000;
  size_t in_stack_00000004;
  uchar *in_stack_00000008;
  
  iVar1 = mbedtls_gcm_starts(ctx,mode,iv,iv_len,add,add_len);
  if ((iVar1 == 0) && (iVar1 = mbedtls_gcm_update(ctx,length,input,in_stack_00000000), iVar1 == 0))
  {
    iVar1 = mbedtls_gcm_finish(ctx,in_stack_00000008,in_stack_00000004);
    return iVar1;
  }
  return iVar1;
}



int mbedtls_gcm_auth_decrypt
              (mbedtls_gcm_context *ctx,size_t length,uchar *iv,size_t iv_len,uchar *add,
              size_t add_len,uchar *tag,size_t tag_len,uchar *input,uchar *output)

{
  undefined *puVar1;
  uint uVar2;
  byte *pbVar3;
  byte *pbVar4;
  size_t sVar5;
  uchar *in_fa2;
  uchar *in_stack_00000000;
  undefined *in_stack_00000004;
  byte local_30 [4];
  uchar check_tag [16];
  
  uVar2 = mbedtls_gcm_crypt_and_tag
                    (ctx,0,length,iv,iv_len,add,add_len,in_stack_00000000,input,(size_t)output,
                     in_fa2);
  sVar5 = 0;
  if (uVar2 == 0) {
    while (sVar5 != tag_len) {
      pbVar4 = tag + sVar5;
      pbVar3 = local_30 + sVar5;
      sVar5 = sVar5 + 1;
      uVar2 = uVar2 | *pbVar4 ^ *pbVar3;
    }
    puVar1 = in_stack_00000004 + length;
    if (uVar2 != 0) {
      while (in_stack_00000004 != puVar1) {
        *in_stack_00000004 = 0;
        in_stack_00000004 = in_stack_00000004 + 1;
      }
      uVar2 = 0xffffffee;
    }
  }
  return uVar2;
}



void mbedtls_gcm_free(mbedtls_gcm_context *ctx)

{
  mbedtls_gcm_context *pmVar1;
  
  mbedtls_cipher_free((mbedtls_cipher_context_t *)ctx);
  pmVar1 = ctx + 1;
  while (ctx != pmVar1) {
    *(undefined *)&(ctx->cipher_ctx).cipher_info = 0;
    ctx = (mbedtls_gcm_context *)((int)&(ctx->cipher_ctx).cipher_info + 1);
  }
  return;
}



mbedtls_md_info_t * mbedtls_md_info_from_type(mbedtls_md_type_t md_type)

{
  uint uVar1;
  
  uVar1 = (uint)md_type - 3 & 0xff;
  if (uVar1 < 4) {
    return *(mbedtls_md_info_t **)(CSWTCH_2 + uVar1 * 4);
  }
  return (mbedtls_md_info_t *)0x0;
}



void mbedtls_md_init(mbedtls_md_context_t *ctx)

{
  memset(ctx,0,0xc);
  return;
}



void mbedtls_md_free(mbedtls_md_context_t *ctx)

{
  undefined *puVar1;
  mbedtls_md_context_t *pmVar2;
  undefined *puVar3;
  
  if (ctx != (mbedtls_md_context_t *)0x0) {
    if (ctx->md_info != (mbedtls_md_info_t *)0x0) {
      if (ctx->md_ctx != (void *)0x0) {
        (*ctx->md_info->ctx_free_func)(ctx->md_ctx);
      }
      puVar3 = (undefined *)ctx->hmac_ctx;
      if (puVar3 != (undefined *)0x0) {
        puVar1 = puVar3 + ctx->md_info->block_size * 2;
        while (puVar3 != puVar1) {
          *puVar3 = 0;
          puVar3 = puVar3 + 1;
        }
        vPortFree(ctx->hmac_ctx);
      }
      pmVar2 = ctx + 1;
      while (ctx != pmVar2) {
        *(undefined *)&ctx->md_info = 0;
        ctx = (mbedtls_md_context_t *)((int)&ctx->md_info + 1);
      }
    }
    return;
  }
  return;
}



int mbedtls_md_setup(mbedtls_md_context_t *ctx,mbedtls_md_info_t *md_info,int hmac)

{
  void *pvVar1;
  int iVar2;
  
  if ((md_info == (mbedtls_md_info_t *)0x0) || (ctx == (mbedtls_md_context_t *)0x0)) {
    return -0x5100;
  }
  pvVar1 = (*md_info->ctx_alloc_func)(md_info->ctx_alloc_func);
  ctx->md_ctx = pvVar1;
  if (pvVar1 == (void *)0x0) {
LAB_230657a0:
    iVar2 = -0x5180;
  }
  else {
    if (hmac != 0) {
      pvVar1 = mycalloc(2,md_info->block_size);
      ctx->hmac_ctx = pvVar1;
      if (pvVar1 == (void *)0x0) {
        (*md_info->ctx_free_func)(ctx->md_ctx);
        goto LAB_230657a0;
      }
    }
    ctx->md_info = md_info;
    iVar2 = 0;
  }
  return iVar2;
}



int mbedtls_md_starts(mbedtls_md_context_t *ctx)

{
  if ((ctx != (mbedtls_md_context_t *)0x0) && (ctx->md_info != (mbedtls_md_info_t *)0x0)) {
    (*ctx->md_info->starts_func)(ctx->md_ctx);
    return 0;
  }
  return -0x5100;
}



int mbedtls_md_update(mbedtls_md_context_t *ctx,uchar *input,size_t ilen)

{
  if ((ctx != (mbedtls_md_context_t *)0x0) && (ctx->md_info != (mbedtls_md_info_t *)0x0)) {
    (*ctx->md_info->update_func)(ctx->md_ctx,input,ilen);
    return 0;
  }
  return -0x5100;
}



int mbedtls_md_finish(mbedtls_md_context_t *ctx,uchar *output)

{
  if ((ctx != (mbedtls_md_context_t *)0x0) && (ctx->md_info != (mbedtls_md_info_t *)0x0)) {
    (*ctx->md_info->finish_func)(ctx->md_ctx,output);
    return 0;
  }
  return -0x5100;
}



int mbedtls_md(mbedtls_md_info_t *md_info,uchar *input,size_t ilen,uchar *output)

{
  if (md_info != (mbedtls_md_info_t *)0x0) {
    (*md_info->digest_func)(input,ilen,output);
    return 0;
  }
  return -0x5100;
}



int mbedtls_md_hmac_starts(mbedtls_md_context_t *ctx,uchar *key,size_t keylen)

{
  int iVar1;
  size_t __n;
  byte *pbVar2;
  byte *pbVar3;
  mbedtls_md_info_t *pmVar4;
  size_t sVar5;
  uchar *puVar6;
  uchar *__s;
  uchar *__s_00;
  uchar local_40 [4];
  uchar sum [32];
  
  if (ctx == (mbedtls_md_context_t *)0x0) {
    return -0x5100;
  }
  puVar6 = local_40;
  pmVar4 = ctx->md_info;
  if ((pmVar4 == (mbedtls_md_info_t *)0x0) || (ctx->hmac_ctx == (void *)0x0)) {
    iVar1 = -0x5100;
  }
  else {
    if ((uint)pmVar4->block_size < keylen) {
      (*pmVar4->starts_func)(ctx->md_ctx);
      (*ctx->md_info->update_func)(ctx->md_ctx,key,keylen);
      (*ctx->md_info->finish_func)(ctx->md_ctx,local_40);
      keylen = ctx->md_info->size;
      key = local_40;
    }
    __s = (uchar *)ctx->hmac_ctx;
    __n = ctx->md_info->block_size;
    __s_00 = __s + __n;
    memset(__s,0x36,__n);
    memset(__s_00,0x5c,ctx->md_info->block_size);
    sVar5 = 0;
    while (keylen != sVar5) {
      pbVar2 = key + sVar5;
      __s[sVar5] = __s[sVar5] ^ *pbVar2;
      pbVar3 = __s_00 + sVar5;
      sVar5 = sVar5 + 1;
      *pbVar3 = *pbVar3 ^ *pbVar2;
    }
    do {
      *puVar6 = '\0';
      puVar6 = puVar6 + 1;
    } while (puVar6 != sum + 0x1c);
    (*ctx->md_info->starts_func)(ctx->md_ctx);
    (*ctx->md_info->update_func)(ctx->md_ctx,__s,ctx->md_info->block_size);
    iVar1 = 0;
  }
  return iVar1;
}



int mbedtls_md_hmac_update(mbedtls_md_context_t *ctx,uchar *input,size_t ilen)

{
  if (((ctx != (mbedtls_md_context_t *)0x0) && (ctx->md_info != (mbedtls_md_info_t *)0x0)) &&
     (ctx->hmac_ctx != (void *)0x0)) {
    (*ctx->md_info->update_func)(ctx->md_ctx,input,ilen);
    return 0;
  }
  return -0x5100;
}



// WARNING: Variable defined which should be unmapped: tmp

int mbedtls_md_hmac_finish(mbedtls_md_context_t *ctx,uchar *output)

{
  int iVar1;
  mbedtls_md_info_t *pmVar2;
  void *pvVar3;
  uchar auStack48 [4];
  uchar tmp [32];
  
  if (((ctx != (mbedtls_md_context_t *)0x0) &&
      (pmVar2 = ctx->md_info, pmVar2 != (mbedtls_md_info_t *)0x0)) &&
     (pvVar3 = ctx->hmac_ctx, pvVar3 != (void *)0x0)) {
    iVar1 = pmVar2->block_size;
    (*pmVar2->finish_func)(ctx->md_ctx,auStack48);
    (*ctx->md_info->starts_func)(ctx->md_ctx);
    (*ctx->md_info->update_func)
              (ctx->md_ctx,(uchar *)(iVar1 + (int)pvVar3),ctx->md_info->block_size);
    (*ctx->md_info->update_func)(ctx->md_ctx,auStack48,ctx->md_info->size);
    (*ctx->md_info->finish_func)(ctx->md_ctx,output);
    return 0;
  }
  return -0x5100;
}



int mbedtls_md_hmac_reset(mbedtls_md_context_t *ctx)

{
  int iVar1;
  uchar *puVar2;
  
  if ((ctx != (mbedtls_md_context_t *)0x0) && (ctx->md_info != (mbedtls_md_info_t *)0x0)) {
    puVar2 = (uchar *)ctx->hmac_ctx;
    if (puVar2 == (uchar *)0x0) {
      iVar1 = -0x5100;
    }
    else {
      (*ctx->md_info->starts_func)(ctx->md_ctx);
      (*ctx->md_info->update_func)(ctx->md_ctx,puVar2,ctx->md_info->block_size);
      iVar1 = 0;
    }
    return iVar1;
  }
  return -0x5100;
}



int mbedtls_md_process(mbedtls_md_context_t *ctx,uchar *data)

{
  if ((ctx != (mbedtls_md_context_t *)0x0) && (ctx->md_info != (mbedtls_md_info_t *)0x0)) {
    (*ctx->md_info->process_func)(ctx->md_ctx,data);
    return 0;
  }
  return -0x5100;
}



uchar mbedtls_md_get_size(mbedtls_md_info_t *md_info)

{
  if (md_info != (mbedtls_md_info_t *)0x0) {
    return *(uchar *)&md_info->size;
  }
  return '\0';
}



void md5_process_wrap(mbedtls_md5_context *ctx,uchar *data)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  int iVar11;
  int iVar12;
  int iVar13;
  int iVar14;
  int iVar15;
  int iVar16;
  uint uVar17;
  uint uVar18;
  uint uVar19;
  uint uVar20;
  uint uVar21;
  uint uVar22;
  uint uVar23;
  uint uVar24;
  uint uVar25;
  
  iVar1 = *(int *)data;
  iVar2 = *(int *)(data + 4);
  iVar3 = *(int *)(data + 0x10);
  iVar4 = *(int *)(data + 8);
  iVar5 = *(int *)(data + 0xc);
  iVar6 = *(int *)(data + 0x14);
  iVar7 = *(int *)(data + 0x18);
  iVar8 = *(int *)(data + 0x24);
  iVar9 = *(int *)(data + 0x1c);
  iVar10 = *(int *)(data + 0x20);
  iVar11 = *(int *)(data + 0x2c);
  iVar12 = *(int *)(data + 0x28);
  iVar13 = *(int *)(data + 0x30);
  uVar19 = ctx->state[3];
  iVar14 = *(int *)(data + 0x34);
  iVar15 = *(int *)(data + 0x38);
  iVar16 = *(int *)(data + 0x3c);
  uVar17 = ctx->state[2];
  uVar18 = ctx->state[1];
  uVar20 = ((uVar17 ^ uVar19) & uVar18 ^ uVar19) + ctx->state[0] + 0xd76aa478 + iVar1;
  uVar21 = (uVar20 >> 0x19 | uVar20 * 0x80) + uVar18;
  uVar20 = ((uVar18 ^ uVar17) & uVar21 ^ uVar17) + uVar19 + 0xe8c7b756 + iVar2;
  uVar23 = (uVar20 >> 0x14 | uVar20 * 0x1000) + uVar21;
  uVar20 = ((uVar18 ^ uVar21) & uVar23 ^ uVar18) + uVar17 + 0x242070db + iVar4;
  uVar22 = (uVar20 * 0x20000 | uVar20 >> 0xf) + uVar23;
  uVar20 = ((uVar21 ^ uVar23) & uVar22 ^ uVar21) + uVar18 + 0xc1bdceee + iVar5;
  uVar20 = (uVar20 * 0x400000 | uVar20 >> 10) + uVar22;
  uVar21 = ((uVar23 ^ uVar22) & uVar20 ^ uVar23) + iVar3 + -0xa83f051 + uVar21;
  uVar21 = (uVar21 >> 0x19 | uVar21 * 0x80) + uVar20;
  uVar23 = ((uVar22 ^ uVar20) & uVar21 ^ uVar22) + iVar6 + 0x4787c62a + uVar23;
  uVar23 = (uVar23 >> 0x14 | uVar23 * 0x1000) + uVar21;
  uVar22 = ((uVar20 ^ uVar21) & uVar23 ^ uVar20) + iVar7 + -0x57cfb9ed + uVar22;
  uVar22 = (uVar22 * 0x20000 | uVar22 >> 0xf) + uVar23;
  uVar20 = ((uVar21 ^ uVar23) & uVar22 ^ uVar21) + iVar9 + -0x2b96aff + uVar20;
  uVar20 = (uVar20 * 0x400000 | uVar20 >> 10) + uVar22;
  uVar21 = ((uVar23 ^ uVar22) & uVar20 ^ uVar23) + iVar10 + 0x698098d8 + uVar21;
  uVar21 = (uVar21 >> 0x19 | uVar21 * 0x80) + uVar20;
  uVar23 = ((uVar22 ^ uVar20) & uVar21 ^ uVar22) + iVar8 + -0x74bb0851 + uVar23;
  uVar23 = (uVar23 >> 0x14 | uVar23 * 0x1000) + uVar21;
  uVar22 = ((uVar20 ^ uVar21) & uVar23 ^ uVar20) + iVar12 + -0xa44f + uVar22;
  uVar22 = (uVar22 * 0x20000 | uVar22 >> 0xf) + uVar23;
  uVar20 = ((uVar21 ^ uVar23) & uVar22 ^ uVar21) + iVar11 + -0x76a32842 + uVar20;
  uVar20 = (uVar20 * 0x400000 | uVar20 >> 10) + uVar22;
  uVar21 = ((uVar23 ^ uVar22) & uVar20 ^ uVar23) + iVar13 + 0x6b901122 + uVar21;
  uVar21 = (uVar21 >> 0x19 | uVar21 * 0x80) + uVar20;
  uVar23 = ((uVar22 ^ uVar20) & uVar21 ^ uVar22) + iVar14 + -0x2678e6d + uVar23;
  uVar23 = (uVar23 >> 0x14 | uVar23 * 0x1000) + uVar21;
  uVar22 = ((uVar20 ^ uVar21) & uVar23 ^ uVar20) + iVar15 + -0x5986bc72 + uVar22;
  uVar22 = (uVar22 * 0x20000 | uVar22 >> 0xf) + uVar23;
  uVar20 = ((uVar21 ^ uVar23) & uVar22 ^ uVar21) + iVar16 + 0x49b40821 + uVar20;
  uVar20 = (uVar20 * 0x400000 | uVar20 >> 10) + uVar22;
  uVar21 = ((uVar22 ^ uVar20) & uVar23 ^ uVar22) + iVar2 + -0x9e1da9e + uVar21;
  uVar21 = (uVar21 >> 0x1b | uVar21 * 0x20) + uVar20;
  uVar23 = ((uVar20 ^ uVar21) & uVar22 ^ uVar20) + iVar7 + -0x3fbf4cc0 + uVar23;
  uVar23 = (uVar23 >> 0x17 | uVar23 * 0x200) + uVar21;
  uVar22 = ((uVar21 ^ uVar23) & uVar20 ^ uVar21) + iVar11 + 0x265e5a51 + uVar22;
  uVar22 = (uVar22 >> 0x12 | uVar22 * 0x4000) + uVar23;
  uVar20 = ((uVar23 ^ uVar22) & uVar21 ^ uVar23) + iVar1 + -0x16493856 + uVar20;
  uVar20 = (uVar20 * 0x100000 | uVar20 >> 0xc) + uVar22;
  uVar21 = ((uVar22 ^ uVar20) & uVar23 ^ uVar22) + iVar6 + -0x29d0efa3 + uVar21;
  uVar21 = (uVar21 >> 0x1b | uVar21 * 0x20) + uVar20;
  uVar23 = ((uVar20 ^ uVar21) & uVar22 ^ uVar20) + iVar12 + 0x2441453 + uVar23;
  uVar23 = (uVar23 >> 0x17 | uVar23 * 0x200) + uVar21;
  uVar22 = ((uVar21 ^ uVar23) & uVar20 ^ uVar21) + iVar16 + -0x275e197f + uVar22;
  uVar22 = (uVar22 >> 0x12 | uVar22 * 0x4000) + uVar23;
  uVar20 = ((uVar23 ^ uVar22) & uVar21 ^ uVar23) + iVar3 + -0x182c0438 + uVar20;
  uVar20 = (uVar20 * 0x100000 | uVar20 >> 0xc) + uVar22;
  uVar21 = ((uVar22 ^ uVar20) & uVar23 ^ uVar22) + iVar8 + 0x21e1cde6 + uVar21;
  uVar21 = (uVar21 >> 0x1b | uVar21 * 0x20) + uVar20;
  uVar23 = ((uVar20 ^ uVar21) & uVar22 ^ uVar20) + iVar15 + -0x3cc8f82a + uVar23;
  uVar23 = (uVar23 >> 0x17 | uVar23 * 0x200) + uVar21;
  uVar22 = ((uVar21 ^ uVar23) & uVar20 ^ uVar21) + iVar5 + -0xb2af279 + uVar22;
  uVar22 = (uVar22 >> 0x12 | uVar22 * 0x4000) + uVar23;
  uVar20 = ((uVar23 ^ uVar22) & uVar21 ^ uVar23) + iVar10 + 0x455a14ed + uVar20;
  uVar20 = (uVar20 * 0x100000 | uVar20 >> 0xc) + uVar22;
  uVar21 = ((uVar22 ^ uVar20) & uVar23 ^ uVar22) + iVar14 + -0x561c16fb + uVar21;
  uVar21 = (uVar21 >> 0x1b | uVar21 * 0x20) + uVar20;
  uVar23 = ((uVar20 ^ uVar21) & uVar22 ^ uVar20) + iVar4 + -0x3105c08 + uVar23;
  uVar24 = (uVar23 >> 0x17 | uVar23 * 0x200) + uVar21;
  uVar22 = ((uVar21 ^ uVar24) & uVar20 ^ uVar21) + iVar9 + 0x676f02d9 + uVar22;
  uVar23 = (uVar22 >> 0x12 | uVar22 * 0x4000) + uVar24;
  uVar20 = ((uVar24 ^ uVar23) & uVar21 ^ uVar24) + iVar13 + -0x72d5b376 + uVar20;
  uVar20 = (uVar20 * 0x100000 | uVar20 >> 0xc) + uVar23;
  uVar21 = (uVar24 ^ uVar23 ^ uVar20) + iVar6 + -0x5c6be + uVar21;
  uVar21 = (uVar21 >> 0x1c | uVar21 * 0x10) + uVar20;
  uVar22 = (uVar23 ^ uVar20 ^ uVar21) + uVar24 + iVar10 + -0x788e097f;
  uVar22 = (uVar22 >> 0x15 | uVar22 * 0x800) + uVar21;
  uVar23 = (uVar20 ^ uVar21 ^ uVar22) + uVar23 + iVar11 + 0x6d9d6122;
  uVar24 = (uVar23 >> 0x10 | uVar23 * 0x10000) + uVar22;
  uVar20 = (uVar21 ^ uVar22 ^ uVar24) + uVar20 + iVar15 + -0x21ac7f4;
  uVar23 = (uVar20 * 0x800000 | uVar20 >> 9) + uVar24;
  uVar20 = (uVar22 ^ uVar24 ^ uVar23) + iVar2 + -0x5b4115bc + uVar21;
  uVar21 = (uVar20 >> 0x1c | uVar20 * 0x10) + uVar23;
  uVar20 = (uVar24 ^ uVar23 ^ uVar21) + uVar22 + iVar3 + 0x4bdecfa9;
  uVar20 = (uVar20 >> 0x15 | uVar20 * 0x800) + uVar21;
  uVar22 = (uVar23 ^ uVar21 ^ uVar20) + iVar9 + -0x944b4a0 + uVar24;
  uVar24 = (uVar22 >> 0x10 | uVar22 * 0x10000) + uVar20;
  uVar22 = (uVar21 ^ uVar20 ^ uVar24) + uVar23 + iVar12 + -0x41404390;
  uVar22 = (uVar22 * 0x800000 | uVar22 >> 9) + uVar24;
  uVar21 = (uVar20 ^ uVar24 ^ uVar22) + uVar21 + iVar14 + 0x289b7ec6;
  uVar23 = (uVar21 >> 0x1c | uVar21 * 0x10) + uVar22;
  uVar20 = (uVar24 ^ uVar22 ^ uVar23) + iVar1 + -0x155ed806 + uVar20;
  uVar20 = (uVar20 >> 0x15 | uVar20 * 0x800) + uVar23;
  uVar21 = (uVar22 ^ uVar23 ^ uVar20) + iVar5 + -0x2b10cf7b + uVar24;
  uVar24 = (uVar21 >> 0x10 | uVar21 * 0x10000) + uVar20;
  uVar21 = (uVar23 ^ uVar20 ^ uVar24) + uVar22 + iVar7 + 0x4881d05;
  uVar21 = (uVar21 * 0x800000 | uVar21 >> 9) + uVar24;
  uVar22 = (uVar20 ^ uVar24 ^ uVar21) + iVar8 + -0x262b2fc7 + uVar23;
  uVar23 = (uVar22 >> 0x1c | uVar22 * 0x10) + uVar21;
  uVar20 = (uVar24 ^ uVar21 ^ uVar23) + uVar20 + iVar13 + -0x1924661b;
  uVar22 = (uVar20 >> 0x15 | uVar20 * 0x800) + uVar23;
  uVar20 = (uVar21 ^ uVar23 ^ uVar22) + uVar24 + iVar16 + 0x1fa27cf8;
  uVar20 = (uVar20 >> 0x10 | uVar20 * 0x10000) + uVar22;
  uVar21 = (uVar23 ^ uVar22 ^ uVar20) + iVar4 + -0x3b53a99b + uVar21;
  uVar21 = (uVar21 * 0x800000 | uVar21 >> 9) + uVar20;
  uVar23 = ((~uVar22 | uVar21) ^ uVar20) + uVar23 + iVar1 + -0xbd6ddbc;
  uVar24 = (uVar23 >> 0x1a | uVar23 * 0x40) + uVar21;
  uVar22 = ((~uVar20 | uVar24) ^ uVar21) + uVar22 + iVar9 + 0x432aff97;
  uVar23 = (uVar22 >> 0x16 | uVar22 * 0x400) + uVar24;
  uVar20 = ((~uVar21 | uVar23) ^ uVar24) + iVar15 + -0x546bdc59 + uVar20;
  uVar20 = (uVar20 >> 0x11 | uVar20 * 0x8000) + uVar23;
  uVar21 = ((~uVar24 | uVar20) ^ uVar23) + iVar6 + -0x36c5fc7 + uVar21;
  uVar22 = (uVar21 * 0x200000 | uVar21 >> 0xb) + uVar20;
  uVar21 = ((~uVar23 | uVar22) ^ uVar20) + iVar13 + 0x655b59c3 + uVar24;
  uVar24 = (uVar21 >> 0x1a | uVar21 * 0x40) + uVar22;
  uVar21 = ((~uVar20 | uVar24) ^ uVar22) + uVar23 + iVar5 + -0x70f3336e;
  uVar21 = (uVar21 >> 0x16 | uVar21 * 0x400) + uVar24;
  uVar20 = ((~uVar22 | uVar21) ^ uVar24) + iVar12 + -0x100b83 + uVar20;
  uVar20 = (uVar20 >> 0x11 | uVar20 * 0x8000) + uVar21;
  uVar22 = ((~uVar24 | uVar20) ^ uVar21) + iVar2 + -0x7a7ba22f + uVar22;
  uVar22 = (uVar22 * 0x200000 | uVar22 >> 0xb) + uVar20;
  uVar23 = ((~uVar21 | uVar22) ^ uVar20) + iVar10 + 0x6fa87e4f + uVar24;
  uVar25 = (uVar23 >> 0x1a | uVar23 * 0x40) + uVar22;
  uVar21 = ((~uVar20 | uVar25) ^ uVar22) + uVar21 + iVar16 + -0x1d31920;
  uVar24 = (uVar21 >> 0x16 | uVar21 * 0x400) + uVar25;
  uVar20 = ((~uVar22 | uVar24) ^ uVar25) + iVar7 + -0x5cfebcec + uVar20;
  uVar20 = (uVar20 >> 0x11 | uVar20 * 0x8000) + uVar24;
  uVar21 = ((~uVar25 | uVar20) ^ uVar24) + iVar14 + 0x4e0811a1 + uVar22;
  uVar23 = (uVar21 * 0x200000 | uVar21 >> 0xb) + uVar20;
  uVar21 = ((~uVar24 | uVar23) ^ uVar20) + uVar25 + iVar3 + -0x8ac817e;
  uVar22 = (uVar21 >> 0x1a | uVar21 * 0x40) + uVar23;
  uVar21 = ((~uVar20 | uVar22) ^ uVar23) + uVar24 + iVar11 + -0x42c50dcb;
  uVar21 = (uVar21 >> 0x16 | uVar21 * 0x400) + uVar22;
  uVar20 = ((~uVar23 | uVar21) ^ uVar22) + uVar20 + iVar4 + 0x2ad7d2bb;
  uVar20 = (uVar20 >> 0x11 | uVar20 * 0x8000) + uVar21;
  uVar23 = ((~uVar22 | uVar20) ^ uVar21) + uVar23 + iVar8 + -0x14792c6f;
  ctx->state[0] = ctx->state[0] + uVar22;
  ctx->state[1] = uVar18 + uVar20 + (uVar23 >> 0xb | uVar23 * 0x200000);
  ctx->state[2] = uVar20 + uVar17;
  ctx->state[3] = uVar21 + uVar19;
  return;
}



void md5_clone_wrap(mbedtls_md5_context *dst,mbedtls_md5_context *src)

{
  memcpy(dst,src,0x58);
  return;
}



void md5_ctx_free(void *ctx)

{
  mbedtls_md5_free((mbedtls_md5_context *)ctx);
  vPortFree(ctx);
  return;
}



void * md5_ctx_alloc(void)

{
  mbedtls_md5_context *ctx;
  
  ctx = (mbedtls_md5_context *)mycalloc(1,0x58);
  if (ctx != (mbedtls_md5_context *)0x0) {
    mbedtls_md5_init(ctx);
  }
  return ctx;
}



void md5_finish_wrap(mbedtls_md5_context *ctx,uchar *output)

{
  uint uVar1;
  int iVar2;
  int iStack24;
  uint uStack20;
  
  uVar1 = ctx->total[0];
  uStack20 = ctx->total[1] << 3 | uVar1 >> 0x1d;
  iStack24 = uVar1 << 3;
  if ((uVar1 & 0x3f) < 0x38) {
    iVar2 = 0x38;
  }
  else {
    iVar2 = 0x78;
  }
  mbedtls_md5_update(ctx,md5_padding,iVar2 - (uVar1 & 0x3f));
  mbedtls_md5_update(ctx,(uchar *)&iStack24,8);
  *output = (uchar)ctx->state[0];
  output[1] = (uchar)(ctx->state[0] >> 8);
  output[2] = (uchar)*(undefined2 *)((int)ctx->state + 2);
  output[3] = *(uchar *)((int)ctx->state + 3);
  output[4] = (uchar)ctx->state[1];
  output[5] = (uchar)(ctx->state[1] >> 8);
  output[6] = (uchar)*(undefined2 *)((int)ctx->state + 6);
  output[7] = *(uchar *)((int)ctx->state + 7);
  output[8] = (uchar)ctx->state[2];
  output[9] = (uchar)(ctx->state[2] >> 8);
  output[10] = (uchar)*(undefined2 *)((int)ctx->state + 10);
  output[0xb] = *(uchar *)((int)ctx->state + 0xb);
  output[0xc] = (uchar)ctx->state[3];
  output[0xd] = (uchar)(ctx->state[3] >> 8);
  output[0xe] = (uchar)*(undefined2 *)((int)ctx->state + 0xe);
  output[0xf] = *(uchar *)((int)ctx->state + 0xf);
  return;
}



void md5_update_wrap(mbedtls_md5_context *ctx,uchar *input,size_t ilen)

{
  if (ilen != 0) {
    mbedtls_md5_update(ctx,input,ilen);
    return;
  }
  return;
}



void md5_starts_wrap(mbedtls_md5_context *ctx)

{
  ctx->state[0] = 0x67452301;
  ctx->state[1] = 0xefcdab89;
  ctx->state[2] = 0x98badcfe;
  ctx->total[0] = 0;
  ctx->total[1] = 0;
  ctx->state[3] = 0x10325476;
  return;
}



void sha1_process_wrap(mbedtls_sha1_context *ctx,uchar *data)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint32_t uVar12;
  uint uVar13;
  uint uVar14;
  uint uVar15;
  uint uVar16;
  uint uVar17;
  uint uVar18;
  uint uVar19;
  uint uVar20;
  uint uVar21;
  uint uVar22;
  uint uVar23;
  uint uVar24;
  uint uVar25;
  uint uVar26;
  uint uVar27;
  uint uVar28;
  
  uVar8 = (uint)*data << 0x18 | (uint)data[1] << 0x10 | (uint)data[3] | (uint)data[2] << 8;
  uVar10 = (uint)data[4] << 0x18 | (uint)data[5] << 0x10 | (uint)data[7] | (uint)data[6] << 8;
  uVar9 = (uint)data[8] << 0x18 | (uint)data[9] << 0x10 | (uint)data[0xb] | (uint)data[10] << 8;
  uVar1 = (uint)data[0xc] << 0x18 | (uint)data[0xd] << 0x10 | (uint)data[0xf] | (uint)data[0xe] << 8
  ;
  uVar27 = (uint)data[0x10] << 0x18 | (uint)data[0x11] << 0x10 | (uint)data[0x13] |
           (uint)data[0x12] << 8;
  uVar25 = (uint)data[0x14] << 0x18 | (uint)data[0x15] << 0x10 | (uint)data[0x17] |
           (uint)data[0x16] << 8;
  uVar14 = (uint)data[0x18] << 0x18 | (uint)data[0x19] << 0x10 | (uint)data[0x1b] |
           (uint)data[0x1a] << 8;
  uVar20 = (uint)data[0x1c] << 0x18 | (uint)data[0x1d] << 0x10 | (uint)data[0x1f] |
           (uint)data[0x1e] << 8;
  uVar28 = (uint)data[0x20] << 0x18 | (uint)data[0x21] << 0x10 | (uint)data[0x23] |
           (uint)data[0x22] << 8;
  uVar26 = (uint)data[0x24] << 0x18 | (uint)data[0x25] << 0x10 | (uint)data[0x27] |
           (uint)data[0x26] << 8;
  uVar2 = (uint)data[0x28] << 0x18 | (uint)data[0x29] << 0x10 | (uint)data[0x2b] |
          (uint)data[0x2a] << 8;
  uVar13 = (uint)data[0x2c] << 0x18 | (uint)data[0x2d] << 0x10 | (uint)data[0x2f] |
           (uint)data[0x2e] << 8;
  uVar11 = (uint)data[0x30] << 0x18 | (uint)data[0x31] << 0x10 | (uint)data[0x33] |
           (uint)data[0x32] << 8;
  uVar16 = ctx->state[2];
  uVar15 = ctx->state[0];
  uVar5 = (uint)data[0x34] << 0x18 | (uint)data[0x35] << 0x10 | (uint)data[0x37] |
          (uint)data[0x36] << 8;
  uVar4 = (uint)data[0x38] << 0x18 | (uint)data[0x39] << 0x10 | (uint)data[0x3b] |
          (uint)data[0x3a] << 8;
  uVar3 = (uint)data[0x3c] << 0x18 | (uint)data[0x3d] << 0x10 | (uint)data[0x3f] |
          (uint)data[0x3e] << 8;
  uVar6 = (uVar15 << 5 | uVar15 >> 0x1b) + ctx->state[4] + 0x5a827999 +
          ((uVar16 ^ ctx->state[3]) & ctx->state[1] ^ ctx->state[3]) + uVar8;
  uVar17 = ctx->state[1] << 0x1e | ctx->state[1] >> 2;
  uVar18 = (uVar6 * 0x20 | uVar6 >> 0x1b) +
           ((uVar16 ^ uVar17) & uVar15 ^ uVar16) + ctx->state[3] + 0x5a827999 + uVar10;
  uVar23 = uVar15 << 0x1e | uVar15 >> 2;
  uVar7 = uVar6 * 0x40000000 | uVar6 >> 2;
  uVar6 = (uVar18 * 0x20 | uVar18 >> 0x1b) +
          ((uVar17 ^ uVar23) & uVar6 ^ uVar17) + uVar16 + 0x5a827999 + uVar9;
  uVar19 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar18 = (uVar6 * 0x20 | uVar6 >> 0x1b) +
           ((uVar23 ^ uVar7) & uVar18 ^ uVar23) + uVar17 + 0x5a827999 + uVar1;
  uVar21 = uVar6 * 0x40000000 | uVar6 >> 2;
  uVar17 = (uVar18 * 0x20 | uVar18 >> 0x1b) +
           ((uVar7 ^ uVar19) & uVar6 ^ uVar7) + uVar23 + 0x5a827999 + uVar27;
  uVar23 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           ((uVar19 ^ uVar21) & uVar18 ^ uVar19) + uVar25 + 0x5a827999 + uVar7;
  uVar6 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar18 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar7 = (uVar23 * 0x20 | uVar23 >> 0x1b) +
          ((uVar21 ^ uVar6) & uVar17 ^ uVar21) + uVar14 + 0x5a827999 + uVar19;
  uVar24 = uVar23 * 0x40000000 | uVar23 >> 2;
  uVar19 = (uVar7 * 0x20 | uVar7 >> 0x1b) +
           ((uVar6 ^ uVar18) & uVar23 ^ uVar6) + uVar21 + uVar20 + 0x5a827999;
  uVar17 = uVar7 * 0x40000000 | uVar7 >> 2;
  uVar7 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
          ((uVar18 ^ uVar24) & uVar7 ^ uVar18) + uVar28 + 0x5a827999 + uVar6;
  uVar23 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar6 = (uVar7 * 0x20 | uVar7 >> 0x1b) +
          ((uVar24 ^ uVar17) & uVar19 ^ uVar24) + uVar18 + uVar26 + 0x5a827999;
  uVar22 = uVar7 * 0x40000000 | uVar7 >> 2;
  uVar19 = (uVar6 * 0x20 | uVar6 >> 0x1b) +
           ((uVar17 ^ uVar23) & uVar7 ^ uVar17) + uVar2 + 0x5a827999 + uVar24;
  uVar18 = uVar6 * 0x40000000 | uVar6 >> 2;
  uVar7 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
          ((uVar23 ^ uVar22) & uVar6 ^ uVar23) + uVar17 + uVar13 + 0x5a827999;
  uVar21 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar6 = (uVar7 * 0x20 | uVar7 >> 0x1b) +
          ((uVar22 ^ uVar18) & uVar19 ^ uVar22) + uVar11 + 0x5a827999 + uVar23;
  uVar17 = uVar7 * 0x40000000 | uVar7 >> 2;
  uVar19 = (uVar6 * 0x20 | uVar6 >> 0x1b) +
           ((uVar18 ^ uVar21) & uVar7 ^ uVar18) + uVar22 + uVar5 + 0x5a827999;
  uVar7 = uVar6 * 0x40000000 | uVar6 >> 2;
  uVar23 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
           ((uVar21 ^ uVar17) & uVar6 ^ uVar21) + uVar4 + 0x5a827999 + uVar18;
  uVar22 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar6 = uVar8 ^ uVar9 ^ uVar28 ^ uVar5;
  uVar18 = (uVar23 * 0x20 | uVar23 >> 0x1b) +
           ((uVar17 ^ uVar7) & uVar19 ^ uVar17) + uVar21 + uVar3 + 0x5a827999;
  uVar8 = uVar6 >> 0x1f | uVar6 << 1;
  uVar6 = uVar10 ^ uVar1 ^ uVar26 ^ uVar4;
  uVar19 = uVar23 * 0x40000000 | uVar23 >> 2;
  uVar10 = uVar6 >> 0x1f | uVar6 << 1;
  uVar17 = (uVar18 * 0x20 | uVar18 >> 0x1b) +
           ((uVar7 ^ uVar22) & uVar23 ^ uVar7) + uVar8 + 0x5a827999 + uVar17;
  uVar21 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar9 = uVar9 ^ uVar27 ^ uVar2 ^ uVar3;
  uVar6 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
          ((uVar22 ^ uVar19) & uVar18 ^ uVar22) + uVar7 + uVar10 + 0x5a827999;
  uVar9 = uVar9 >> 0x1f | uVar9 << 1;
  uVar1 = uVar1 ^ uVar25 ^ uVar13 ^ uVar8;
  uVar23 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar1 = uVar1 >> 0x1f | uVar1 << 1;
  uVar18 = (uVar6 * 0x20 | uVar6 >> 0x1b) +
           ((uVar19 ^ uVar21) & uVar17 ^ uVar19) + uVar9 + 0x5a827999 + uVar22;
  uVar17 = uVar27 ^ uVar14 ^ uVar11 ^ uVar10;
  uVar7 = uVar6 * 0x40000000 | uVar6 >> 2;
  uVar27 = uVar17 >> 0x1f | uVar17 << 1;
  uVar17 = (uVar18 * 0x20 | uVar18 >> 0x1b) +
           ((uVar21 ^ uVar23) & uVar6 ^ uVar21) + uVar1 + 0x5a827999 + uVar19;
  uVar6 = uVar25 ^ uVar20 ^ uVar5 ^ uVar9;
  uVar19 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar24 = uVar6 >> 0x1f | uVar6 << 1;
  uVar21 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           (uVar23 ^ uVar7 ^ uVar18) + uVar21 + uVar27 + 0x6ed9eba1;
  uVar6 = uVar14 ^ uVar28 ^ uVar4 ^ uVar1;
  uVar18 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar17 = (uVar21 * 0x20 | uVar21 >> 0x1b) +
           (uVar7 ^ uVar19 ^ uVar17) + uVar24 + 0x6ed9eba1 + uVar23;
  uVar14 = uVar6 >> 0x1f | uVar6 << 1;
  uVar23 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar6 = uVar20 ^ uVar26 ^ uVar3 ^ uVar27;
  uVar6 = uVar6 >> 0x1f | uVar6 << 1;
  uVar21 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           (uVar19 ^ uVar18 ^ uVar21) + uVar14 + 0x6ed9eba1 + uVar7;
  uVar7 = uVar28 ^ uVar2 ^ uVar8 ^ uVar24;
  uVar20 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar28 = uVar7 >> 0x1f | uVar7 << 1;
  uVar7 = (uVar21 * 0x20 | uVar21 >> 0x1b) +
          (uVar18 ^ uVar23 ^ uVar17) + uVar19 + uVar6 + 0x6ed9eba1;
  uVar17 = uVar26 ^ uVar13 ^ uVar10 ^ uVar14;
  uVar22 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar26 = uVar17 >> 0x1f | uVar17 << 1;
  uVar17 = (uVar7 * 0x20 | uVar7 >> 0x1b) +
           (uVar23 ^ uVar20 ^ uVar21) + uVar18 + uVar28 + 0x6ed9eba1;
  uVar2 = uVar2 ^ uVar11 ^ uVar9 ^ uVar6;
  uVar19 = uVar7 * 0x40000000 | uVar7 >> 2;
  uVar21 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           (uVar20 ^ uVar22 ^ uVar7) + uVar23 + uVar26 + 0x6ed9eba1;
  uVar2 = uVar2 >> 0x1f | uVar2 << 1;
  uVar7 = uVar13 ^ uVar5 ^ uVar1 ^ uVar28;
  uVar18 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar13 = uVar7 >> 0x1f | uVar7 << 1;
  uVar20 = (uVar21 * 0x20 | uVar21 >> 0x1b) +
           (uVar22 ^ uVar19 ^ uVar17) + uVar2 + 0x6ed9eba1 + uVar20;
  uVar7 = uVar11 ^ uVar4 ^ uVar27 ^ uVar26;
  uVar23 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar11 = uVar7 >> 0x1f | uVar7 << 1;
  uVar17 = (uVar20 * 0x20 | uVar20 >> 0x1b) +
           (uVar19 ^ uVar18 ^ uVar21) + uVar13 + 0x6ed9eba1 + uVar22;
  uVar5 = uVar5 ^ uVar3 ^ uVar24 ^ uVar2;
  uVar22 = uVar20 * 0x40000000 | uVar20 >> 2;
  uVar5 = uVar5 >> 0x1f | uVar5 << 1;
  uVar7 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
          (uVar18 ^ uVar23 ^ uVar20) + uVar19 + uVar11 + 0x6ed9eba1;
  uVar4 = uVar4 ^ uVar8 ^ uVar14 ^ uVar13;
  uVar20 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar4 = uVar4 >> 0x1f | uVar4 << 1;
  uVar17 = (uVar7 * 0x20 | uVar7 >> 0x1b) + (uVar23 ^ uVar22 ^ uVar17) + uVar18 + uVar5 + 0x6ed9eba1
  ;
  uVar3 = uVar3 ^ uVar10 ^ uVar6 ^ uVar11;
  uVar19 = uVar7 * 0x40000000 | uVar7 >> 2;
  uVar3 = uVar3 >> 0x1f | uVar3 << 1;
  uVar21 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           (uVar22 ^ uVar20 ^ uVar7) + uVar23 + uVar4 + 0x6ed9eba1;
  uVar7 = uVar8 ^ uVar9 ^ uVar28 ^ uVar5;
  uVar18 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar17 = (uVar21 * 0x20 | uVar21 >> 0x1b) +
           (uVar20 ^ uVar19 ^ uVar17) + uVar3 + 0x6ed9eba1 + uVar22;
  uVar7 = uVar7 >> 0x1f | uVar7 << 1;
  uVar8 = uVar10 ^ uVar1 ^ uVar26 ^ uVar4;
  uVar23 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar10 = uVar8 >> 0x1f | uVar8 << 1;
  uVar21 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           (uVar19 ^ uVar18 ^ uVar21) + uVar7 + 0x6ed9eba1 + uVar20;
  uVar8 = uVar9 ^ uVar27 ^ uVar2 ^ uVar3;
  uVar20 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar8 = uVar8 >> 0x1f | uVar8 << 1;
  uVar17 = (uVar21 * 0x20 | uVar21 >> 0x1b) +
           (uVar18 ^ uVar23 ^ uVar17) + uVar19 + uVar10 + 0x6ed9eba1;
  uVar1 = uVar1 ^ uVar24 ^ uVar13 ^ uVar7;
  uVar22 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar9 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
          (uVar23 ^ uVar20 ^ uVar21) + uVar18 + uVar8 + 0x6ed9eba1;
  uVar1 = uVar1 >> 0x1f | uVar1 << 1;
  uVar19 = uVar27 ^ uVar14 ^ uVar11 ^ uVar10;
  uVar18 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar21 = (uVar9 * 0x20 | uVar9 >> 0x1b) + (uVar20 ^ uVar22 ^ uVar17) + uVar1 + 0x6ed9eba1 + uVar23
  ;
  uVar27 = uVar19 >> 0x1f | uVar19 << 1;
  uVar19 = uVar24 ^ uVar6 ^ uVar5 ^ uVar8;
  uVar17 = uVar9 * 0x40000000 | uVar9 >> 2;
  uVar25 = uVar19 >> 0x1f | uVar19 << 1;
  uVar19 = (uVar21 * 0x20 | uVar21 >> 0x1b) +
           (uVar22 ^ uVar18 ^ uVar9) + uVar27 + 0x6ed9eba1 + uVar20;
  uVar9 = uVar14 ^ uVar28 ^ uVar4 ^ uVar1;
  uVar23 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar14 = uVar9 >> 0x1f | uVar9 << 1;
  uVar20 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
           (uVar18 ^ uVar17 ^ uVar21) + uVar22 + uVar25 + 0x6ed9eba1;
  uVar6 = uVar6 ^ uVar26 ^ uVar3 ^ uVar27;
  uVar21 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar6 = uVar6 >> 0x1f | uVar6 << 1;
  uVar9 = (uVar20 * 0x20 | uVar20 >> 0x1b) +
          (uVar17 ^ uVar23 ^ uVar19) + uVar14 + 0x6ed9eba1 + uVar18;
  uVar18 = uVar28 ^ uVar2 ^ uVar7 ^ uVar25;
  uVar22 = uVar20 * 0x40000000 | uVar20 >> 2;
  uVar28 = uVar18 >> 0x1f | uVar18 << 1;
  uVar17 = (uVar9 * 0x20 | uVar9 >> 0x1b) + (uVar23 ^ uVar21 ^ uVar20) + uVar6 + 0x6ed9eba1 + uVar17
  ;
  uVar19 = uVar9 * 0x40000000 | uVar9 >> 2;
  uVar20 = uVar26 ^ uVar13 ^ uVar10 ^ uVar14;
  uVar18 = ((uVar9 | uVar22) & uVar21 | uVar9 & uVar22) +
           uVar28 + 0x8f1bbcdc + uVar23 + (uVar17 * 0x20 | uVar17 >> 0x1b);
  uVar26 = uVar20 >> 0x1f | uVar20 << 1;
  uVar2 = uVar2 ^ uVar11 ^ uVar8 ^ uVar6;
  uVar23 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar2 = uVar2 >> 0x1f | uVar2 << 1;
  uVar17 = (uVar18 * 0x20 | uVar18 >> 0x1b) +
           ((uVar17 | uVar19) & uVar22 | uVar17 & uVar19) + uVar26 + 0x8f1bbcdc + uVar21;
  uVar9 = uVar13 ^ uVar5 ^ uVar1 ^ uVar28;
  uVar21 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar13 = uVar9 >> 0x1f | uVar9 << 1;
  uVar20 = ((uVar18 | uVar23) & uVar19 | uVar18 & uVar23) +
           uVar2 + 0x8f1bbcdc + uVar22 + (uVar17 * 0x20 | uVar17 >> 0x1b);
  uVar9 = uVar11 ^ uVar4 ^ uVar27 ^ uVar26;
  uVar18 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar11 = uVar9 >> 0x1f | uVar9 << 1;
  uVar9 = (uVar20 * 0x20 | uVar20 >> 0x1b) +
          ((uVar17 | uVar21) & uVar23 | uVar17 & uVar21) + uVar13 + 0x8f1bbcdc + uVar19;
  uVar24 = uVar20 * 0x40000000 | uVar20 >> 2;
  uVar5 = uVar5 ^ uVar3 ^ uVar25 ^ uVar2;
  uVar19 = ((uVar20 | uVar18) & uVar21 | uVar20 & uVar18) +
           uVar11 + 0x8f1bbcdc + uVar23 + (uVar9 * 0x20 | uVar9 >> 0x1b);
  uVar5 = uVar5 >> 0x1f | uVar5 << 1;
  uVar4 = uVar4 ^ uVar7 ^ uVar14 ^ uVar13;
  uVar17 = uVar9 * 0x40000000 | uVar9 >> 2;
  uVar4 = uVar4 >> 0x1f | uVar4 << 1;
  uVar9 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
          ((uVar9 | uVar24) & uVar18 | uVar9 & uVar24) + uVar5 + 0x8f1bbcdc + uVar21;
  uVar3 = uVar3 ^ uVar10 ^ uVar6 ^ uVar11;
  uVar22 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar3 = uVar3 >> 0x1f | uVar3 << 1;
  uVar18 = ((uVar19 | uVar17) & uVar24 | uVar19 & uVar17) +
           uVar4 + 0x8f1bbcdc + uVar18 + (uVar9 * 0x20 | uVar9 >> 0x1b);
  uVar7 = uVar7 ^ uVar8 ^ uVar28 ^ uVar5;
  uVar20 = uVar9 * 0x40000000 | uVar9 >> 2;
  uVar7 = uVar7 >> 0x1f | uVar7 << 1;
  uVar21 = (uVar18 * 0x20 | uVar18 >> 0x1b) +
           ((uVar9 | uVar22) & uVar17 | uVar9 & uVar22) + uVar3 + 0x8f1bbcdc + uVar24;
  uVar9 = uVar10 ^ uVar1 ^ uVar26 ^ uVar4;
  uVar19 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar9 = uVar9 >> 0x1f | uVar9 << 1;
  uVar10 = ((uVar18 | uVar20) & uVar22 | uVar18 & uVar20) +
           uVar7 + 0x8f1bbcdc + uVar17 + (uVar21 * 0x20 | uVar21 >> 0x1b);
  uVar8 = uVar8 ^ uVar27 ^ uVar2 ^ uVar3;
  uVar23 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar8 = uVar8 >> 0x1f | uVar8 << 1;
  uVar18 = (uVar10 * 0x20 | uVar10 >> 0x1b) +
           ((uVar21 | uVar19) & uVar20 | uVar21 & uVar19) + uVar9 + 0x8f1bbcdc + uVar22;
  uVar1 = uVar1 ^ uVar25 ^ uVar13 ^ uVar7;
  uVar17 = uVar10 * 0x40000000 | uVar10 >> 2;
  uVar1 = uVar1 >> 0x1f | uVar1 << 1;
  uVar10 = ((uVar10 | uVar23) & uVar19 | uVar10 & uVar23) +
           uVar8 + 0x8f1bbcdc + uVar20 + (uVar18 * 0x20 | uVar18 >> 0x1b);
  uVar21 = uVar27 ^ uVar14 ^ uVar11 ^ uVar9;
  uVar22 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar27 = uVar21 >> 0x1f | uVar21 << 1;
  uVar18 = (uVar10 * 0x20 | uVar10 >> 0x1b) +
           ((uVar18 | uVar17) & uVar23 | uVar18 & uVar17) + uVar19 + uVar1 + 0x8f1bbcdc;
  uVar19 = uVar25 ^ uVar6 ^ uVar5 ^ uVar8;
  uVar20 = uVar10 * 0x40000000 | uVar10 >> 2;
  uVar24 = uVar19 >> 0x1f | uVar19 << 1;
  uVar21 = ((uVar10 | uVar22) & uVar17 | uVar10 & uVar22) +
           uVar27 + 0x8f1bbcdc + uVar23 + (uVar18 * 0x20 | uVar18 >> 0x1b);
  uVar10 = uVar14 ^ uVar28 ^ uVar4 ^ uVar1;
  uVar19 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar14 = uVar10 >> 0x1f | uVar10 << 1;
  uVar10 = (uVar21 * 0x20 | uVar21 >> 0x1b) +
           ((uVar18 | uVar20) & uVar22 | uVar18 & uVar20) + uVar17 + uVar24 + 0x8f1bbcdc;
  uVar6 = uVar6 ^ uVar26 ^ uVar3 ^ uVar27;
  uVar23 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar6 = uVar6 >> 0x1f | uVar6 << 1;
  uVar18 = ((uVar21 | uVar19) & uVar20 | uVar21 & uVar19) +
           uVar14 + 0x8f1bbcdc + uVar22 + (uVar10 * 0x20 | uVar10 >> 0x1b);
  uVar21 = uVar28 ^ uVar2 ^ uVar7 ^ uVar24;
  uVar17 = uVar10 * 0x40000000 | uVar10 >> 2;
  uVar28 = uVar21 >> 0x1f | uVar21 << 1;
  uVar10 = (uVar18 * 0x20 | uVar18 >> 0x1b) +
           ((uVar10 | uVar23) & uVar19 | uVar10 & uVar23) + uVar20 + uVar6 + 0x8f1bbcdc;
  uVar21 = uVar26 ^ uVar13 ^ uVar9 ^ uVar14;
  uVar22 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar25 = uVar21 >> 0x1f | uVar21 << 1;
  uVar18 = ((uVar18 | uVar17) & uVar23 | uVar18 & uVar17) +
           uVar28 + 0x8f1bbcdc + uVar19 + (uVar10 * 0x20 | uVar10 >> 0x1b);
  uVar2 = uVar2 ^ uVar11 ^ uVar8 ^ uVar6;
  uVar20 = uVar10 * 0x40000000 | uVar10 >> 2;
  uVar2 = uVar2 >> 0x1f | uVar2 << 1;
  uVar21 = (uVar18 * 0x20 | uVar18 >> 0x1b) +
           ((uVar10 | uVar22) & uVar17 | uVar10 & uVar22) + uVar23 + uVar25 + 0x8f1bbcdc;
  uVar10 = uVar13 ^ uVar5 ^ uVar1 ^ uVar28;
  uVar19 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar13 = uVar10 >> 0x1f | uVar10 << 1;
  uVar17 = ((uVar18 | uVar20) & uVar22 | uVar18 & uVar20) +
           uVar2 + 0x8f1bbcdc + uVar17 + (uVar21 * 0x20 | uVar21 >> 0x1b);
  uVar10 = uVar11 ^ uVar4 ^ uVar27 ^ uVar25;
  uVar18 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar10 = uVar10 >> 0x1f | uVar10 << 1;
  uVar23 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           ((uVar21 | uVar19) & uVar20 | uVar21 & uVar19) + uVar22 + uVar13 + 0x8f1bbcdc;
  uVar5 = uVar5 ^ uVar3 ^ uVar24 ^ uVar2;
  uVar11 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar5 = uVar5 >> 0x1f | uVar5 << 1;
  uVar21 = (uVar23 * 0x20 | uVar23 >> 0x1b) +
           (uVar19 ^ uVar18 ^ uVar17) + uVar20 + uVar10 + 0xca62c1d6;
  uVar4 = uVar4 ^ uVar7 ^ uVar14 ^ uVar13;
  uVar20 = uVar23 * 0x40000000 | uVar23 >> 2;
  uVar4 = uVar4 >> 0x1f | uVar4 << 1;
  uVar17 = (uVar21 * 0x20 | uVar21 >> 0x1b) +
           (uVar18 ^ uVar11 ^ uVar23) + uVar19 + uVar5 + 0xca62c1d6;
  uVar3 = uVar3 ^ uVar9 ^ uVar6 ^ uVar10;
  uVar23 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar3 = uVar3 >> 0x1f | uVar3 << 1;
  uVar19 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           (uVar11 ^ uVar20 ^ uVar21) + uVar18 + uVar4 + 0xca62c1d6;
  uVar7 = uVar7 ^ uVar8 ^ uVar28 ^ uVar5;
  uVar18 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar7 = uVar7 >> 0x1f | uVar7 << 1;
  uVar11 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
           (uVar20 ^ uVar23 ^ uVar17) + uVar11 + uVar3 + 0xca62c1d6;
  uVar9 = uVar9 ^ uVar1 ^ uVar25 ^ uVar4;
  uVar21 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar9 = uVar9 >> 0x1f | uVar9 << 1;
  uVar20 = (uVar11 * 0x20 | uVar11 >> 0x1b) +
           (uVar23 ^ uVar18 ^ uVar19) + uVar20 + uVar7 + 0xca62c1d6;
  uVar8 = uVar8 ^ uVar27 ^ uVar2 ^ uVar3;
  uVar17 = uVar11 * 0x40000000 | uVar11 >> 2;
  uVar8 = uVar8 >> 0x1f | uVar8 << 1;
  uVar19 = (uVar20 * 0x20 | uVar20 >> 0x1b) +
           (uVar18 ^ uVar21 ^ uVar11) + uVar23 + uVar9 + 0xca62c1d6;
  uVar1 = uVar1 ^ uVar24 ^ uVar13 ^ uVar7;
  uVar22 = uVar20 * 0x40000000 | uVar20 >> 2;
  uVar1 = uVar1 >> 0x1f | uVar1 << 1;
  uVar11 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
           (uVar21 ^ uVar17 ^ uVar20) + uVar18 + uVar8 + 0xca62c1d6;
  uVar18 = uVar27 ^ uVar14 ^ uVar10 ^ uVar9;
  uVar23 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar26 = uVar18 >> 0x1f | uVar18 << 1;
  uVar19 = (uVar11 * 0x20 | uVar11 >> 0x1b) +
           (uVar17 ^ uVar22 ^ uVar19) + uVar21 + uVar1 + 0xca62c1d6;
  uVar21 = uVar24 ^ uVar6 ^ uVar5 ^ uVar8;
  uVar18 = uVar11 * 0x40000000 | uVar11 >> 2;
  uVar24 = uVar21 >> 0x1f | uVar21 << 1;
  uVar17 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
           (uVar22 ^ uVar23 ^ uVar11) + uVar17 + uVar26 + 0xca62c1d6;
  uVar11 = uVar14 ^ uVar28 ^ uVar4 ^ uVar1;
  uVar21 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar11 = uVar11 >> 0x1f | uVar11 << 1;
  uVar20 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           (uVar23 ^ uVar18 ^ uVar19) + uVar22 + uVar24 + 0xca62c1d6;
  uVar6 = uVar6 ^ uVar25 ^ uVar3 ^ uVar26;
  uVar14 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar6 = uVar6 >> 0x1f | uVar6 << 1;
  uVar19 = (uVar20 * 0x20 | uVar20 >> 0x1b) +
           (uVar18 ^ uVar21 ^ uVar17) + uVar23 + uVar11 + 0xca62c1d6;
  uVar17 = uVar28 ^ uVar2 ^ uVar7 ^ uVar24;
  uVar22 = uVar20 * 0x40000000 | uVar20 >> 2;
  uVar27 = uVar17 >> 0x1f | uVar17 << 1;
  uVar17 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
           (uVar21 ^ uVar14 ^ uVar20) + uVar18 + uVar6 + 0xca62c1d6;
  uVar18 = uVar25 ^ uVar13 ^ uVar9 ^ uVar11;
  uVar23 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar20 = uVar18 >> 0x1f | uVar18 << 1;
  uVar19 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           (uVar14 ^ uVar22 ^ uVar19) + uVar21 + uVar27 + 0xca62c1d6;
  uVar2 = uVar2 ^ uVar10 ^ uVar8 ^ uVar6;
  uVar18 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar2 = uVar2 >> 0x1f | uVar2 << 1;
  uVar8 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
          (uVar22 ^ uVar23 ^ uVar17) + uVar14 + uVar20 + 0xca62c1d6;
  uVar27 = uVar13 ^ uVar5 ^ uVar1 ^ uVar27;
  uVar13 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar21 = uVar27 >> 0x1f | uVar27 << 1;
  uVar14 = uVar22 + uVar2 + 0xca62c1d6 + (uVar23 ^ uVar18 ^ uVar19) + (uVar8 * 0x20 | uVar8 >> 0x1b)
  ;
  uVar20 = uVar10 ^ uVar4 ^ uVar26 ^ uVar20;
  uVar10 = (uVar14 * 0x20 | uVar14 >> 0x1b) +
           (uVar18 ^ uVar13 ^ uVar8) + uVar23 + uVar21 + 0xca62c1d6;
  uVar1 = uVar8 * 0x40000000 | uVar8 >> 2;
  uVar17 = uVar20 >> 0x1f | uVar20 << 1;
  uVar2 = uVar5 ^ uVar3 ^ uVar24 ^ uVar2;
  uVar5 = uVar18 + uVar17 + 0xca62c1d6 + (uVar13 ^ uVar1 ^ uVar14) +
          (uVar10 * 0x20 | uVar10 >> 0x1b);
  uVar8 = uVar14 * 0x40000000 | uVar14 >> 2;
  uVar21 = uVar4 ^ uVar7 ^ uVar11 ^ uVar21;
  uVar4 = uVar13 + (uVar2 << 1 | uVar2 >> 0x1f) + 0xca62c1d6 + (uVar1 ^ uVar8 ^ uVar10) +
          (uVar5 * 0x20 | uVar5 >> 0x1b);
  uVar7 = uVar10 * 0x40000000 | uVar10 >> 2;
  uVar17 = uVar3 ^ uVar9 ^ uVar6 ^ uVar17;
  uVar1 = uVar1 + (uVar21 << 1 | uVar21 >> 0x1f) + 0xca62c1d6 + (uVar8 ^ uVar7 ^ uVar5) +
          (uVar4 * 0x20 | uVar4 >> 0x1b);
  uVar2 = uVar5 * 0x40000000 | uVar5 >> 2;
  uVar12 = ctx->state[1];
  ctx->state[0] =
       uVar8 + (uVar17 << 1 | uVar17 >> 0x1f) + uVar15 + 0xca62c1d6 + (uVar7 ^ uVar2 ^ uVar4) +
       (uVar1 * 0x20 | uVar1 >> 0x1b);
  ctx->state[1] = uVar1 + uVar12;
  ctx->state[2] = uVar16 + (uVar4 >> 2 | uVar4 * 0x40000000);
  ctx->state[3] = uVar2 + ctx->state[3];
  ctx->state[4] = uVar7 + ctx->state[4];
  return;
}



void sha1_clone_wrap(mbedtls_sha1_context *dst,mbedtls_sha1_context *src)

{
  memcpy(dst,src,0x5c);
  return;
}



void sha1_ctx_free(void *ctx)

{
  mbedtls_sha1_free((mbedtls_sha1_context *)ctx);
  vPortFree(ctx);
  return;
}



void * sha1_ctx_alloc(void)

{
  mbedtls_sha1_context *ctx;
  
  ctx = (mbedtls_sha1_context *)mycalloc(1,0x5c);
  if (ctx != (mbedtls_sha1_context *)0x0) {
    mbedtls_sha1_init(ctx);
  }
  return ctx;
}



void sha1_finish_wrap(mbedtls_sha1_context *ctx,uchar *output)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  uchar uStack24;
  undefined uStack23;
  ushort uStack22;
  undefined uStack20;
  undefined uStack19;
  ushort uStack18;
  
  uVar1 = ctx->total[0];
  uVar2 = ctx->total[1] << 3;
  uStack24 = (uchar)(uVar2 >> 0x18);
  uStack23 = (undefined)(uVar2 >> 0x10);
  uStack22 = (ushort)(uVar2 >> 8) & 0xff | (ushort)((uVar2 | uVar1 >> 0x1d) << 8);
  uStack20 = (undefined)((uVar1 << 3) >> 0x18);
  uStack19 = (undefined)((uVar1 << 3) >> 0x10);
  uStack18 = (ushort)((uVar1 << 0x13) >> 0x18) | (ushort)(uVar1 << 0xb);
  if ((uVar1 & 0x3f) < 0x38) {
    iVar3 = 0x38;
  }
  else {
    iVar3 = 0x78;
  }
  mbedtls_sha1_update(ctx,sha1_padding,iVar3 - (uVar1 & 0x3f));
  mbedtls_sha1_update(ctx,&uStack24,8);
  *output = *(uchar *)((int)ctx->state + 3);
  output[1] = (uchar)*(undefined2 *)((int)ctx->state + 2);
  output[2] = (uchar)(ctx->state[0] >> 8);
  output[3] = (uchar)ctx->state[0];
  output[4] = *(uchar *)((int)ctx->state + 7);
  output[5] = (uchar)*(undefined2 *)((int)ctx->state + 6);
  output[6] = (uchar)(ctx->state[1] >> 8);
  output[7] = (uchar)ctx->state[1];
  output[8] = *(uchar *)((int)ctx->state + 0xb);
  output[9] = (uchar)*(undefined2 *)((int)ctx->state + 10);
  output[10] = (uchar)(ctx->state[2] >> 8);
  output[0xb] = (uchar)ctx->state[2];
  output[0xc] = *(uchar *)((int)ctx->state + 0xf);
  output[0xd] = (uchar)*(undefined2 *)((int)ctx->state + 0xe);
  output[0xe] = (uchar)(ctx->state[3] >> 8);
  output[0xf] = (uchar)ctx->state[3];
  output[0x10] = *(uchar *)((int)ctx->state + 0x13);
  output[0x11] = (uchar)*(undefined2 *)((int)ctx->state + 0x12);
  output[0x12] = (uchar)(ctx->state[4] >> 8);
  output[0x13] = (uchar)ctx->state[4];
  return;
}



void sha1_update_wrap(mbedtls_sha1_context *ctx,uchar *input,size_t ilen)

{
  if (ilen != 0) {
    mbedtls_sha1_update(ctx,input,ilen);
    return;
  }
  return;
}



void sha1_starts_wrap(mbedtls_sha1_context *ctx)

{
  ctx->state[0] = 0x67452301;
  ctx->state[1] = 0xefcdab89;
  ctx->state[2] = 0x98badcfe;
  ctx->state[3] = 0x10325476;
  ctx->total[0] = 0;
  ctx->total[1] = 0;
  ctx->state[4] = 0xc3d2e1f0;
  return;
}



void sha224_process_wrap(mbedtls_sha256_context *ctx,uchar *data)

{
  uint uVar1;
  uint32_t *puVar2;
  byte *pbVar3;
  byte *pbVar4;
  uint uVar5;
  uint uVar6;
  uint32_t uVar7;
  uint uVar8;
  uint32_t *puVar9;
  uint *puVar10;
  uint uVar11;
  uint uVar12;
  int iVar13;
  uint uVar14;
  uint uVar15;
  uint uVar16;
  uint uVar17;
  uint32_t *puVar18;
  uint uVar19;
  uint uVar20;
  uint uVar21;
  uint *puVar22;
  uint32_t *puVar23;
  uint uVar24;
  uint uVar25;
  uint32_t uStack336;
  uint uStack332;
  uint uStack328;
  uint uStack324;
  uint uStack320;
  uint uStack316;
  uint uStack312;
  uint uStack308;
  uint auStack304 [67];
  
  puVar18 = &uStack336;
  puVar9 = &uStack336;
  puVar2 = ctx->state;
  do {
    uVar7 = *puVar2;
    puVar2 = puVar2 + 1;
    *puVar9 = uVar7;
    puVar9 = puVar9 + 1;
  } while ((uint32_t *)ctx->buffer != puVar2);
  puVar22 = auStack304;
  pbVar3 = data;
  puVar10 = puVar22;
  do {
    pbVar4 = pbVar3 + 4;
    *puVar10 = (uint)*pbVar3 << 0x18 | (uint)pbVar3[1] << 0x10 | (uint)pbVar3[3] |
               (uint)pbVar3[2] << 8;
    pbVar3 = pbVar4;
    puVar10 = puVar10 + 1;
  } while (data + 0x40 != pbVar4);
  puVar2 = K;
  puVar9 = K;
  puVar10 = puVar22;
  do {
    puVar23 = puVar9 + 8;
    iVar13 = uStack308 +
             ((uStack320 >> 6 | uStack320 << 0x1a) ^ (uStack320 >> 0xb | uStack320 << 0x15) ^
             (uStack320 << 7 | uStack320 >> 0x19)) + *puVar9 + *puVar10 +
             ((uStack312 ^ uStack316) & uStack320 ^ uStack312);
    uVar12 = uStack324 + iVar13;
    uVar14 = iVar13 + ((uStack336 >> 2 | uStack336 << 0x1e) ^ (uStack336 >> 0xd | uStack336 << 0x13)
                      ^ (uStack336 << 10 | uStack336 >> 0x16)) +
                      ((uStack336 | uStack332) & uStack328 | uStack336 & uStack332);
    iVar13 = ((uVar12 >> 6 | uVar12 * 0x4000000) ^ (uVar12 >> 0xb | uVar12 * 0x200000) ^
             (uVar12 * 0x80 | uVar12 >> 0x19)) +
             uStack312 + puVar9[1] + puVar10[1] + ((uStack320 ^ uStack316) & uVar12 ^ uStack316);
    uVar1 = ((uVar14 >> 2 | uVar14 * 0x40000000) ^ (uVar14 >> 0xd | uVar14 * 0x80000) ^
            (uVar14 * 0x400 | uVar14 >> 0x16)) +
            ((uVar14 | uStack336) & uStack332 | uVar14 & uStack336) + iVar13;
    uVar11 = uStack328 + iVar13;
    iVar13 = ((uVar11 >> 6 | uVar11 * 0x4000000) ^ (uVar11 >> 0xb | uVar11 * 0x200000) ^
             (uVar11 * 0x80 | uVar11 >> 0x19)) +
             uStack316 + puVar9[2] + puVar10[2] + ((uVar12 ^ uStack320) & uVar11 ^ uStack320);
    uVar5 = ((uVar1 >> 2 | uVar1 * 0x40000000) ^ (uVar1 >> 0xd | uVar1 * 0x80000) ^
            (uVar1 * 0x400 | uVar1 >> 0x16)) + ((uVar14 | uVar1) & uStack336 | uVar14 & uVar1) +
            iVar13;
    uVar8 = uStack332 + iVar13;
    iVar13 = ((uVar8 >> 6 | uVar8 * 0x4000000) ^ (uVar8 >> 0xb | uVar8 * 0x200000) ^
             (uVar8 * 0x80 | uVar8 >> 0x19)) +
             uStack320 + puVar9[3] + puVar10[3] + ((uVar12 ^ uVar11) & uVar8 ^ uVar12);
    uVar16 = ((uVar5 >> 2 | uVar5 * 0x40000000) ^ (uVar5 >> 0xd | uVar5 * 0x80000) ^
             (uVar5 * 0x400 | uVar5 >> 0x16)) + ((uVar1 | uVar5) & uVar14 | uVar1 & uVar5) + iVar13;
    uVar6 = uStack336 + iVar13;
    iVar13 = ((uVar6 >> 6 | uVar6 * 0x4000000) ^ (uVar6 >> 0xb | uVar6 * 0x200000) ^
             (uVar6 * 0x80 | uVar6 >> 0x19)) +
             uVar12 + puVar9[4] + puVar10[4] + ((uVar11 ^ uVar8) & uVar6 ^ uVar11);
    uStack324 = ((uVar16 >> 2 | uVar16 * 0x40000000) ^ (uVar16 >> 0xd | uVar16 * 0x80000) ^
                (uVar16 * 0x400 | uVar16 >> 0x16)) + ((uVar5 | uVar16) & uVar1 | uVar5 & uVar16) +
                iVar13;
    uStack308 = uVar14 + iVar13;
    iVar13 = ((uStack308 >> 6 | uStack308 * 0x4000000) ^ (uStack308 >> 0xb | uStack308 * 0x200000) ^
             (uStack308 * 0x80 | uStack308 >> 0x19)) +
             uVar11 + puVar9[5] + puVar10[5] + ((uVar8 ^ uVar6) & uStack308 ^ uVar8);
    uStack328 = ((uStack324 >> 2 | uStack324 * 0x40000000) ^
                 (uStack324 >> 0xd | uStack324 * 0x80000) ^ (uStack324 * 0x400 | uStack324 >> 0x16))
                + ((uVar16 | uStack324) & uVar5 | uVar16 & uStack324) + iVar13;
    uStack312 = uVar1 + iVar13;
    iVar13 = ((uStack312 >> 6 | uStack312 * 0x4000000) ^ (uStack312 >> 0xb | uStack312 * 0x200000) ^
             (uStack312 * 0x80 | uStack312 >> 0x19)) +
             uVar8 + puVar9[6] + puVar10[6] + ((uVar6 ^ uStack308) & uStack312 ^ uVar6);
    uStack332 = ((uStack328 >> 2 | uStack328 * 0x40000000) ^
                 (uStack328 >> 0xd | uStack328 * 0x80000) ^ (uStack328 * 0x400 | uStack328 >> 0x16))
                + ((uStack324 | uStack328) & uVar16 | uStack324 & uStack328) + iVar13;
    uStack316 = uVar5 + iVar13;
    iVar13 = ((uStack316 >> 6 | uStack316 * 0x4000000) ^ (uStack316 >> 0xb | uStack316 * 0x200000) ^
             (uStack316 * 0x80 | uStack316 >> 0x19)) +
             uVar6 + puVar9[7] + puVar10[7] + ((uStack308 ^ uStack312) & uStack316 ^ uStack308);
    uStack320 = uVar16 + iVar13;
    uStack336 = ((uStack332 >> 2 | uStack332 * 0x40000000) ^
                 (uStack332 >> 0xd | uStack332 * 0x80000) ^ (uStack332 * 0x400 | uStack332 >> 0x16))
                + ((uStack328 | uStack332) & uStack324 | uStack328 & uStack332) + iVar13;
    puVar9 = puVar23;
    puVar10 = puVar10 + 8;
  } while (puVar23 != K + 0x10);
  do {
    uVar19 = puVar22[0xe];
    uVar1 = puVar22[1];
    uVar20 = puVar22[0xf];
    uVar24 = ((uVar19 << 0xf | uVar19 >> 0x11) ^ (uVar19 << 0xd | uVar19 >> 0x13) ^ uVar19 >> 10) +
             puVar22[9] + *puVar22 +
             ((uVar1 >> 7 | uVar1 << 0x19) ^ (uVar1 << 0xe | uVar1 >> 0x12) ^ uVar1 >> 3);
    uVar11 = puVar22[3];
    iVar13 = uStack308 +
             ((uStack320 >> 6 | uStack320 << 0x1a) ^ (uStack320 >> 0xb | uStack320 << 0x15) ^
             (uStack320 << 7 | uStack320 >> 0x19)) +
             ((uStack312 ^ uStack316) & uStack320 ^ uStack312) + puVar2[0x10] + uVar24;
    uVar16 = uStack324 + iVar13;
    uVar15 = iVar13 + ((uStack336 >> 2 | uStack336 << 0x1e) ^ (uStack336 >> 0xd | uStack336 << 0x13)
                      ^ (uStack336 << 10 | uStack336 >> 0x16)) +
                      ((uStack336 | uStack332) & uStack328 | uStack336 & uStack332);
    uVar6 = puVar22[2];
    uVar1 = ((uVar20 << 0xf | uVar20 >> 0x11) ^ (uVar20 << 0xd | uVar20 >> 0x13) ^ uVar20 >> 10) +
            uVar1 + puVar22[10] +
            ((uVar6 >> 7 | uVar6 << 0x19) ^ (uVar6 << 0xe | uVar6 >> 0x12) ^ uVar6 >> 3);
    iVar13 = ((uStack320 ^ uStack316) & uVar16 ^ uStack316) + uStack312 + puVar2[0x11] + uVar1 +
             ((uVar16 >> 6 | uVar16 * 0x4000000) ^ (uVar16 >> 0xb | uVar16 * 0x200000) ^
             (uVar16 * 0x80 | uVar16 >> 0x19));
    uVar5 = ((uVar15 >> 2 | uVar15 * 0x40000000) ^ (uVar15 >> 0xd | uVar15 * 0x80000) ^
            (uVar15 * 0x400 | uVar15 >> 0x16)) +
            ((uStack336 | uVar15) & uStack332 | uStack336 & uVar15) + iVar13;
    uVar14 = uStack328 + iVar13;
    uVar6 = ((uVar24 * 0x8000 | uVar24 >> 0x11) ^ (uVar24 * 0x2000 | uVar24 >> 0x13) ^ uVar24 >> 10)
            + uVar6 + puVar22[0xb] +
            ((uVar11 >> 7 | uVar11 << 0x19) ^ (uVar11 << 0xe | uVar11 >> 0x12) ^ uVar11 >> 3);
    iVar13 = ((uStack320 ^ uVar16) & uVar14 ^ uStack320) + uStack316 + puVar2[0x12] + uVar6 +
             ((uVar14 >> 6 | uVar14 * 0x4000000) ^ (uVar14 >> 0xb | uVar14 * 0x200000) ^
             (uVar14 * 0x80 | uVar14 >> 0x19));
    puVar22[0x11] = uVar1;
    uVar8 = ((uVar5 >> 2 | uVar5 * 0x40000000) ^ (uVar5 >> 0xd | uVar5 * 0x80000) ^
            (uVar5 * 0x400 | uVar5 >> 0x16)) + ((uVar15 | uVar5) & uStack336 | uVar15 & uVar5) +
            iVar13;
    uVar12 = uStack332 + iVar13;
    uVar25 = puVar22[4];
    uVar1 = ((uVar1 * 0x8000 | uVar1 >> 0x11) ^ (uVar1 * 0x2000 | uVar1 >> 0x13) ^ uVar1 >> 10) +
            uVar11 + puVar22[0xc] +
            ((uVar25 >> 7 | uVar25 << 0x19) ^ (uVar25 << 0xe | uVar25 >> 0x12) ^ uVar25 >> 3);
    iVar13 = ((uVar16 ^ uVar14) & uVar12 ^ uVar16) + uStack320 + puVar2[0x13] + uVar1 +
             ((uVar12 >> 6 | uVar12 * 0x4000000) ^ (uVar12 >> 0xb | uVar12 * 0x200000) ^
             (uVar12 * 0x80 | uVar12 >> 0x19));
    uVar17 = ((uVar8 >> 2 | uVar8 * 0x40000000) ^ (uVar8 >> 0xd | uVar8 * 0x80000) ^
             (uVar8 * 0x400 | uVar8 >> 0x16)) + ((uVar5 | uVar8) & uVar15 | uVar5 & uVar8) + iVar13;
    uVar11 = uStack336 + iVar13;
    puVar22[0x12] = uVar6;
    uVar21 = puVar22[5];
    uVar25 = ((uVar6 * 0x8000 | uVar6 >> 0x11) ^ (uVar6 * 0x2000 | uVar6 >> 0x13) ^ uVar6 >> 10) +
             uVar25 + puVar22[0xd] +
             ((uVar21 >> 7 | uVar21 << 0x19) ^ (uVar21 << 0xe | uVar21 >> 0x12) ^ uVar21 >> 3);
    iVar13 = ((uVar11 >> 6 | uVar11 * 0x4000000) ^ (uVar11 >> 0xb | uVar11 * 0x200000) ^
             (uVar11 * 0x80 | uVar11 >> 0x19)) +
             ((uVar14 ^ uVar12) & uVar11 ^ uVar14) + uVar16 + puVar2[0x14] + uVar25;
    uStack324 = ((uVar17 >> 2 | uVar17 * 0x40000000) ^ (uVar17 >> 0xd | uVar17 * 0x80000) ^
                (uVar17 * 0x400 | uVar17 >> 0x16)) + ((uVar8 | uVar17) & uVar5 | uVar8 & uVar17) +
                iVar13;
    uStack308 = uVar15 + iVar13;
    uVar6 = puVar22[6];
    puVar22[0x13] = uVar1;
    uVar16 = ((uVar1 * 0x8000 | uVar1 >> 0x11) ^ (uVar1 * 0x2000 | uVar1 >> 0x13) ^ uVar1 >> 10) +
             uVar19 + uVar21 +
             ((uVar6 >> 7 | uVar6 << 0x19) ^ (uVar6 << 0xe | uVar6 >> 0x12) ^ uVar6 >> 3);
    iVar13 = ((uStack308 >> 6 | uStack308 * 0x4000000) ^ (uStack308 >> 0xb | uStack308 * 0x200000) ^
             (uStack308 * 0x80 | uStack308 >> 0x19)) +
             ((uVar12 ^ uVar11) & uStack308 ^ uVar12) + uVar14 + puVar2[0x15] + uVar16;
    uStack328 = ((uStack324 >> 2 | uStack324 * 0x40000000) ^
                 (uStack324 >> 0xd | uStack324 * 0x80000) ^ (uStack324 * 0x400 | uStack324 >> 0x16))
                + ((uVar17 | uStack324) & uVar8 | uVar17 & uStack324) + iVar13;
    uStack312 = uVar5 + iVar13;
    uVar1 = puVar22[7];
    puVar22[0x14] = uVar25;
    uVar6 = uVar20 + uVar6 +
            ((uVar25 * 0x8000 | uVar25 >> 0x11) ^ (uVar25 * 0x2000 | uVar25 >> 0x13) ^ uVar25 >> 10)
            + ((uVar1 >> 7 | uVar1 << 0x19) ^ (uVar1 << 0xe | uVar1 >> 0x12) ^ uVar1 >> 3);
    iVar13 = ((uStack312 >> 6 | uStack312 * 0x4000000) ^ (uStack312 >> 0xb | uStack312 * 0x200000) ^
             (uStack312 * 0x80 | uStack312 >> 0x19)) +
             ((uVar11 ^ uStack308) & uStack312 ^ uVar11) + uVar12 + puVar2[0x16] + uVar6;
    uStack332 = ((uStack328 >> 2 | uStack328 * 0x40000000) ^
                 (uStack328 >> 0xd | uStack328 * 0x80000) ^ (uStack328 * 0x400 | uStack328 >> 0x16))
                + ((uStack324 | uStack328) & uVar17 | uStack324 & uStack328) + iVar13;
    uStack316 = uVar8 + iVar13;
    uVar5 = puVar22[8];
    puVar22[0x15] = uVar16;
    puVar22[0x10] = uVar24;
    uVar7 = puVar2[0x17];
    uVar1 = uVar24 + uVar1 +
            ((uVar16 * 0x8000 | uVar16 >> 0x11) ^ (uVar16 * 0x2000 | uVar16 >> 0x13) ^ uVar16 >> 10)
            + ((uVar5 >> 7 | uVar5 << 0x19) ^ (uVar5 << 0xe | uVar5 >> 0x12) ^ uVar5 >> 3);
    puVar22[0x17] = uVar1;
    iVar13 = ((uStack316 >> 6 | uStack316 * 0x4000000) ^ (uStack316 >> 0xb | uStack316 * 0x200000) ^
             (uStack316 * 0x80 | uStack316 >> 0x19)) +
             uVar11 + uVar7 + uVar1 + ((uStack308 ^ uStack312) & uStack316 ^ uStack308);
    puVar22[0x16] = uVar6;
    puVar22 = puVar22 + 8;
    uStack320 = uVar17 + iVar13;
    uStack336 = ((uStack332 >> 2 | uStack332 * 0x40000000) ^
                 (uStack332 >> 0xd | uStack332 * 0x80000) ^ (uStack332 * 0x400 | uStack332 >> 0x16))
                + ((uStack328 | uStack332) & uStack324 | uStack328 & uStack332) + iVar13;
    puVar2 = puVar2 + 8;
  } while (auStack304 + 0x30 != puVar22);
  puVar9 = ctx->state;
  do {
    iVar13 = *puVar18;
    puVar2 = puVar9 + 1;
    puVar18 = (uint32_t *)((int *)puVar18 + 1);
    *puVar9 = *puVar9 + iVar13;
    puVar9 = puVar2;
  } while ((uint32_t *)ctx->buffer != puVar2);
  return;
}



void sha224_clone_wrap(mbedtls_sha256_context *dst,mbedtls_sha256_context *src)

{
  memcpy(dst,src,0x74);
  return;
}



void sha224_ctx_free(void *ctx)

{
  mbedtls_sha256_free((mbedtls_sha256_context *)ctx);
  vPortFree(ctx);
  return;
}



void * sha224_ctx_alloc(void)

{
  mbedtls_sha256_context *ctx;
  
  ctx = (mbedtls_sha256_context *)mycalloc(1,0x74);
  if (ctx != (mbedtls_sha256_context *)0x0) {
    mbedtls_sha256_init(ctx);
  }
  return ctx;
}



void sha224_wrap(uchar *input,size_t ilen,uchar *output)

{
  mbedtls_sha256(input,ilen,output,1);
  return;
}



void sha256_wrap(uchar *input,size_t ilen,uchar *output)

{
  mbedtls_sha256(input,ilen,output,0);
  return;
}



void sha224_finish_wrap(mbedtls_sha256_context *ctx,uchar *output)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  uchar uStack24;
  undefined uStack23;
  ushort uStack22;
  undefined uStack20;
  undefined uStack19;
  ushort uStack18;
  
  uVar1 = ctx->total[0];
  uVar2 = ctx->total[1] << 3;
  uStack24 = (uchar)(uVar2 >> 0x18);
  uStack23 = (undefined)(uVar2 >> 0x10);
  uStack22 = (ushort)(uVar2 >> 8) & 0xff | (ushort)((uVar2 | uVar1 >> 0x1d) << 8);
  uStack20 = (undefined)((uVar1 << 3) >> 0x18);
  uStack19 = (undefined)((uVar1 << 3) >> 0x10);
  uStack18 = (ushort)((uVar1 << 0x13) >> 0x18) | (ushort)(uVar1 << 0xb);
  if ((uVar1 & 0x3f) < 0x38) {
    iVar3 = 0x38;
  }
  else {
    iVar3 = 0x78;
  }
  mbedtls_sha256_update(ctx,sha256_padding,iVar3 - (uVar1 & 0x3f));
  mbedtls_sha256_update(ctx,&uStack24,8);
  *output = *(uchar *)((int)ctx->state + 3);
  output[1] = (uchar)*(undefined2 *)((int)ctx->state + 2);
  output[2] = (uchar)(ctx->state[0] >> 8);
  output[3] = (uchar)ctx->state[0];
  output[4] = *(uchar *)((int)ctx->state + 7);
  output[5] = (uchar)*(undefined2 *)((int)ctx->state + 6);
  output[6] = (uchar)(ctx->state[1] >> 8);
  output[7] = (uchar)ctx->state[1];
  output[8] = *(uchar *)((int)ctx->state + 0xb);
  output[9] = (uchar)*(undefined2 *)((int)ctx->state + 10);
  output[10] = (uchar)(ctx->state[2] >> 8);
  output[0xb] = (uchar)ctx->state[2];
  output[0xc] = *(uchar *)((int)ctx->state + 0xf);
  output[0xd] = (uchar)*(undefined2 *)((int)ctx->state + 0xe);
  output[0xe] = (uchar)(ctx->state[3] >> 8);
  output[0xf] = (uchar)ctx->state[3];
  output[0x10] = *(uchar *)((int)ctx->state + 0x13);
  output[0x11] = (uchar)*(undefined2 *)((int)ctx->state + 0x12);
  output[0x12] = (uchar)(ctx->state[4] >> 8);
  output[0x13] = (uchar)ctx->state[4];
  output[0x14] = *(uchar *)((int)ctx->state + 0x17);
  output[0x15] = (uchar)*(undefined2 *)((int)ctx->state + 0x16);
  output[0x16] = (uchar)(ctx->state[5] >> 8);
  output[0x17] = (uchar)ctx->state[5];
  output[0x18] = *(uchar *)((int)ctx->state + 0x1b);
  output[0x19] = (uchar)*(undefined2 *)((int)ctx->state + 0x1a);
  output[0x1a] = (uchar)(ctx->state[6] >> 8);
  output[0x1b] = (uchar)ctx->state[6];
  if (ctx->is224 == 0) {
    output[0x1c] = *(uchar *)((int)ctx->state + 0x1f);
    output[0x1d] = (uchar)*(undefined2 *)((int)ctx->state + 0x1e);
    output[0x1e] = (uchar)(ctx->state[7] >> 8);
    output[0x1f] = (uchar)ctx->state[7];
  }
  return;
}



void sha224_update_wrap(mbedtls_sha256_context *ctx,uchar *input,size_t ilen)

{
  if (ilen != 0) {
    mbedtls_sha256_update(ctx,input,ilen);
    return;
  }
  return;
}



void sha224_starts_wrap(void *ctx)

{
  mbedtls_sha256_starts((mbedtls_sha256_context *)ctx,1);
  return;
}



void sha256_starts_wrap(void *ctx)

{
  mbedtls_sha256_starts((mbedtls_sha256_context *)ctx,0);
  return;
}



oid_sig_alg_t * oid_sig_alg_from_asn1(mbedtls_asn1_buf *oid)

{
  oid_sig_alg_t *poVar1;
  char *__s1;
  int iVar2;
  size_t __n;
  
  poVar1 = oid_sig_alg;
  while( true ) {
    __s1 = (poVar1->descriptor).asn1;
    if (__s1 == (char *)0x0) {
      return (oid_sig_alg_t *)0x0;
    }
    __n = (poVar1->descriptor).asn1_len;
    if ((__n == oid->len) && (iVar2 = memcmp(__s1,oid->p,__n), iVar2 == 0)) break;
    poVar1 = poVar1 + 1;
  }
  return poVar1;
}



int mbedtls_oid_get_attr_short_name(mbedtls_asn1_buf *oid,char **short_name)

{
  oid_x520_attr_t *poVar1;
  char *__s1;
  int iVar2;
  size_t __n;
  
  if (oid == (mbedtls_asn1_buf *)0x0) {
    return -0x2e;
  }
  poVar1 = oid_x520_attr_type;
  while( true ) {
    __s1 = (poVar1->descriptor).asn1;
    if (__s1 == (char *)0x0) {
      return -0x2e;
    }
    __n = (poVar1->descriptor).asn1_len;
    if ((__n == oid->len) && (iVar2 = memcmp(__s1,oid->p,__n), iVar2 == 0)) break;
    poVar1 = poVar1 + 1;
  }
  *short_name = poVar1->short_name;
  return 0;
}



int mbedtls_oid_get_x509_ext_type(mbedtls_asn1_buf *oid,int *ext_type)

{
  oid_x509_ext_t *poVar1;
  char *__s1;
  int iVar2;
  size_t __n;
  
  if (oid == (mbedtls_asn1_buf *)0x0) {
    return -0x2e;
  }
  poVar1 = oid_x509_ext;
  while( true ) {
    __s1 = (poVar1->descriptor).asn1;
    if (__s1 == (char *)0x0) {
      return -0x2e;
    }
    __n = (poVar1->descriptor).asn1_len;
    if ((__n == oid->len) && (iVar2 = memcmp(__s1,oid->p,__n), iVar2 == 0)) break;
    poVar1 = poVar1 + 1;
  }
  *ext_type = poVar1->ext_type;
  return 0;
}



int mbedtls_oid_get_extended_key_usage(mbedtls_asn1_buf *oid,char **description)

{
  mbedtls_oid_descriptor_t *pmVar1;
  int iVar2;
  
  if (oid == (mbedtls_asn1_buf *)0x0) {
    return -0x2e;
  }
  pmVar1 = oid_ext_key_usage;
  while( true ) {
    if (pmVar1->asn1 == (char *)0x0) {
      return -0x2e;
    }
    if ((pmVar1->asn1_len == oid->len) &&
       (iVar2 = memcmp(pmVar1->asn1,oid->p,pmVar1->asn1_len), iVar2 == 0)) break;
    pmVar1 = pmVar1 + 1;
  }
  *description = pmVar1->description;
  return 0;
}



int mbedtls_oid_get_sig_alg_desc(mbedtls_asn1_buf *oid,char **description)

{
  int iVar1;
  oid_sig_alg_t *poVar2;
  
  if (oid == (mbedtls_asn1_buf *)0x0) {
    return -0x2e;
  }
  poVar2 = oid_sig_alg_from_asn1(oid);
  if (poVar2 == (oid_sig_alg_t *)0x0) {
    iVar1 = -0x2e;
  }
  else {
    iVar1 = 0;
    *description = (poVar2->descriptor).description;
  }
  return iVar1;
}



int mbedtls_oid_get_sig_alg
              (mbedtls_asn1_buf *oid,mbedtls_md_type_t *md_alg,mbedtls_pk_type_t *pk_alg)

{
  int iVar1;
  oid_sig_alg_t *poVar2;
  
  if (oid == (mbedtls_asn1_buf *)0x0) {
    return -0x2e;
  }
  poVar2 = oid_sig_alg_from_asn1(oid);
  if (poVar2 == (oid_sig_alg_t *)0x0) {
    iVar1 = -0x2e;
  }
  else {
    *md_alg = poVar2->md_alg;
    iVar1 = 0;
    *pk_alg = poVar2->pk_alg;
  }
  return iVar1;
}



int mbedtls_oid_get_pk_alg(mbedtls_asn1_buf *oid,mbedtls_pk_type_t *pk_alg)

{
  oid_pk_alg_t *poVar1;
  char *__s1;
  int iVar2;
  size_t __n;
  
  if (oid == (mbedtls_asn1_buf *)0x0) {
    return -0x2e;
  }
  poVar1 = oid_pk_alg;
  while( true ) {
    __s1 = (poVar1->descriptor).asn1;
    if (__s1 == (char *)0x0) {
      return -0x2e;
    }
    __n = (poVar1->descriptor).asn1_len;
    if ((__n == oid->len) && (iVar2 = memcmp(__s1,oid->p,__n), iVar2 == 0)) break;
    poVar1 = poVar1 + 1;
  }
  *pk_alg = poVar1->pk_alg;
  return 0;
}



int mbedtls_oid_get_ec_grp(mbedtls_asn1_buf *oid,mbedtls_ecp_group_id *grp_id)

{
  oid_ecp_grp_t *poVar1;
  char *__s1;
  int iVar2;
  size_t __n;
  
  if (oid == (mbedtls_asn1_buf *)0x0) {
    return -0x2e;
  }
  poVar1 = oid_ecp_grp;
  while( true ) {
    __s1 = (poVar1->descriptor).asn1;
    if (__s1 == (char *)0x0) {
      return -0x2e;
    }
    __n = (poVar1->descriptor).asn1_len;
    if ((__n == oid->len) && (iVar2 = memcmp(__s1,oid->p,__n), iVar2 == 0)) break;
    poVar1 = poVar1 + 1;
  }
  *grp_id = poVar1->grp_id;
  return 0;
}



int mbedtls_oid_get_md_alg(mbedtls_asn1_buf *oid,mbedtls_md_type_t *md_alg)

{
  oid_md_alg_t *poVar1;
  char *__s1;
  int iVar2;
  size_t __n;
  
  if (oid == (mbedtls_asn1_buf *)0x0) {
    return -0x2e;
  }
  poVar1 = oid_md_alg;
  while( true ) {
    __s1 = (poVar1->descriptor).asn1;
    if (__s1 == (char *)0x0) {
      return -0x2e;
    }
    __n = (poVar1->descriptor).asn1_len;
    if ((__n == oid->len) && (iVar2 = memcmp(__s1,oid->p,__n), iVar2 == 0)) break;
    poVar1 = poVar1 + 1;
  }
  *md_alg = poVar1->md_alg;
  return 0;
}



int mbedtls_oid_get_oid_by_md(mbedtls_md_type_t md_alg,char **oid,size_t *olen)

{
  undefined3 in_register_00002029;
  char *pcVar1;
  oid_md_alg_t *poVar2;
  
  poVar2 = oid_md_alg;
  while( true ) {
    pcVar1 = (poVar2->descriptor).asn1;
    if (pcVar1 == (char *)0x0) {
      return -0x2e;
    }
    if ((uint)poVar2->md_alg == CONCAT31(in_register_00002029,md_alg)) break;
    poVar2 = poVar2 + 1;
  }
  *oid = pcVar1;
  *olen = (poVar2->descriptor).asn1_len;
  return 0;
}



// WARNING: Variable defined which should be unmapped: aes_ctx

void pem_aes_decrypt(uchar *aes_iv,uint keylen,uchar *buf,size_t buflen,uchar *pwd,size_t pwdlen)

{
  uchar *key;
  size_t __n;
  uchar *puVar1;
  uchar *puVar2;
  uchar local_1c0 [4];
  uchar md5sum [16];
  uchar aes_key [32];
  mbedtls_md5_context md5_ctx;
  mbedtls_aes_context aes_ctx;
  
  puVar1 = local_1c0;
  puVar2 = local_1c0;
  mbedtls_aes_init((mbedtls_aes_context *)(md5_ctx.buffer + 0x3c));
  mbedtls_md5_init((mbedtls_md5_context *)(aes_key + 0x1c));
  mbedtls_md5_starts((mbedtls_md5_context *)(aes_key + 0x1c));
  mbedtls_md5_update((mbedtls_md5_context *)(aes_key + 0x1c),pwd,pwdlen);
  mbedtls_md5_update((mbedtls_md5_context *)(aes_key + 0x1c),aes_iv,8);
  mbedtls_md5_finish((mbedtls_md5_context *)(aes_key + 0x1c),local_1c0);
  key = md5sum + 0xc;
  if (keylen == 0x10) {
    memcpy(key,local_1c0,0x10);
    mbedtls_md5_free((mbedtls_md5_context *)(aes_key + 0x1c));
    do {
      *puVar1 = '\0';
      puVar1 = puVar1 + 1;
    } while (puVar1 != key);
  }
  else {
    memcpy(key,local_1c0,0x10);
    mbedtls_md5_starts((mbedtls_md5_context *)(aes_key + 0x1c));
    mbedtls_md5_update((mbedtls_md5_context *)(aes_key + 0x1c),local_1c0,0x10);
    mbedtls_md5_update((mbedtls_md5_context *)(aes_key + 0x1c),pwd,pwdlen);
    mbedtls_md5_update((mbedtls_md5_context *)(aes_key + 0x1c),aes_iv,8);
    mbedtls_md5_finish((mbedtls_md5_context *)(aes_key + 0x1c),local_1c0);
    __n = 0x10;
    if (keylen != 0x20) {
      __n = keylen - 0x10;
    }
    memcpy(aes_key + 0xc,local_1c0,__n);
    mbedtls_md5_free((mbedtls_md5_context *)(aes_key + 0x1c));
    do {
      *puVar2 = '\0';
      puVar2 = puVar2 + 1;
    } while (puVar2 != key);
  }
  mbedtls_aes_setkey_dec((mbedtls_aes_context *)(md5_ctx.buffer + 0x3c),key,keylen << 3);
  mbedtls_aes_crypt_cbc((mbedtls_aes_context *)(md5_ctx.buffer + 0x3c),0,buflen,aes_iv,buf,buf);
  mbedtls_aes_free((mbedtls_aes_context *)(md5_ctx.buffer + 0x3c));
  while (keylen = keylen - 1, keylen != 0xffffffff) {
    *key = '\0';
    key = key + 1;
  }
  return;
}



void mbedtls_pem_init(mbedtls_pem_context *ctx)

{
  memset(ctx,0,0xc);
  return;
}



int mbedtls_pem_read_buffer
              (mbedtls_pem_context *ctx,char *header,char *footer,uchar *data,uchar *pwd,
              size_t pwdlen,size_t *use_len)

{
  uchar uVar1;
  bool bVar2;
  uchar *dst;
  uchar *puVar3;
  size_t sVar4;
  int iVar5;
  int iVar6;
  uchar *puVar7;
  byte bVar8;
  uint uVar9;
  uint uVar10;
  byte *pbVar11;
  uint keylen;
  uchar *src;
  size_t sStack68;
  size_t len;
  uchar pem_iv [16];
  
  if (ctx == (mbedtls_pem_context *)0x0) {
    return -0x1480;
  }
  dst = (uchar *)strstr((char *)data,header);
  if (((dst == (uchar *)0x0) ||
      (puVar3 = (uchar *)strstr((char *)data,footer), puVar3 == (uchar *)0x0)) || (puVar3 <= dst)) {
    return -0x1080;
  }
  sVar4 = strlen(header);
  dst = dst + sVar4;
  if (*dst == ' ') {
    dst = dst + 1;
  }
  if (*dst == '\r') {
    dst = dst + 1;
  }
  if (*dst != '\n') {
    return -0x1080;
  }
  sVar4 = strlen(footer);
  puVar7 = puVar3 + sVar4;
  src = dst + 1;
  if (*puVar7 == ' ') {
    puVar7 = puVar7 + 1;
  }
  if (*puVar7 == '\r') {
    puVar7 = puVar7 + 1;
  }
  if (*puVar7 == '\n') {
    puVar7 = puVar7 + 1;
  }
  *(uchar **)use_len = puVar7 + -(int)data;
  if (((int)(puVar3 + -(int)src) < 0x16) ||
     (iVar5 = memcmp(src,"Proc-Type: 4,ENCRYPTED",0x16), iVar5 != 0)) {
    iVar5 = 0;
    bVar2 = false;
  }
  else {
    uVar1 = dst[0x17];
    puVar7 = dst + 0x17;
    if (uVar1 == '\r') {
      uVar1 = dst[0x18];
      puVar7 = dst + 0x18;
    }
    if (uVar1 != '\n') {
      return -0x1100;
    }
    dst = puVar7 + 1;
    if ((((int)(puVar3 + -(int)dst) < 0xe) || (iVar5 = memcmp(dst,"DEK-Info: AES-",0xe), iVar5 != 0)
        ) || ((int)(puVar3 + -(int)dst) < 0x16)) {
      return -0x1280;
    }
    iVar6 = memcmp(dst,"DEK-Info: AES-128-CBC,",0x16);
    iVar5 = 5;
    if (iVar6 != 0) {
      iVar6 = memcmp(dst,"DEK-Info: AES-192-CBC,",0x16);
      iVar5 = 6;
      if (iVar6 != 0) {
        iVar5 = memcmp(dst,"DEK-Info: AES-256-CBC,",0x16);
        if (iVar5 != 0) {
          return -0x1280;
        }
        iVar5 = 7;
      }
    }
    if ((int)(puVar3 + -(int)(puVar7 + 0x17)) < 0x20) {
      return -0x1200;
    }
    memset(&len,0,0x10);
    keylen = 0;
    do {
      uVar10 = (uint)puVar7[keylen + 0x17];
      uVar9 = uVar10 - 0x30;
      if (9 < (uVar9 & 0xff)) {
        if ((uVar10 - 0x41 & 0xff) < 6) {
          uVar9 = uVar10 - 0x37;
        }
        else {
          if (5 < (uVar10 - 0x61 & 0xff)) {
            return -0x1200;
          }
          uVar9 = uVar10 - 0x57;
        }
      }
      bVar8 = (byte)uVar9;
      if ((keylen & 1) == 0) {
        bVar8 = (byte)(uVar9 << 4);
      }
      pbVar11 = (byte *)((int)&len + (keylen >> 1));
      keylen = keylen + 1;
      *pbVar11 = bVar8 | *pbVar11;
    } while (keylen != 0x20);
    src = puVar7 + 0x38;
    if (puVar7[0x37] != '\r') {
      src = puVar7 + 0x37;
    }
    if (*src != '\n') {
      return -0x1100;
    }
    src = src + 1;
    bVar2 = true;
  }
  if (puVar3 <= src) {
    return -0x1100;
  }
  iVar6 = mbedtls_base64_decode((uchar *)0x0,0,&sStack68,src,(size_t)(puVar3 + -(int)src));
  if (iVar6 == -0x2c) {
    return -0x112c;
  }
  dst = (uchar *)mycalloc(1,sStack68);
  if (dst == (uchar *)0x0) {
    return -0x1180;
  }
  iVar6 = mbedtls_base64_decode(dst,sStack68,&sStack68,src,(size_t)(puVar3 + -(int)src));
  if (iVar6 != 0) {
    vPortFree(dst);
    return iVar6 + -0x1100;
  }
  if (!bVar2) goto LAB_230661ca;
  if (pwd == (uchar *)0x0) {
    vPortFree(dst);
    return -0x1300;
  }
  if (iVar5 == 5) {
    keylen = 0x10;
LAB_23066174:
    pem_aes_decrypt((uchar *)&len,keylen,dst,sStack68,pwd,pwdlen);
  }
  else {
    if (iVar5 == 6) {
      keylen = 0x18;
      goto LAB_23066174;
    }
    if (iVar5 == 7) {
      keylen = 0x20;
      goto LAB_23066174;
    }
  }
  if (((sStack68 < 3) || (*dst != '0')) || (0x83 < dst[1])) {
    vPortFree(dst);
    return -0x1380;
  }
LAB_230661ca:
  ctx->buf = dst;
  ctx->buflen = sStack68;
  return 0;
}



void mbedtls_pem_free(mbedtls_pem_context *ctx)

{
  mbedtls_pem_context *pmVar1;
  
  vPortFree(ctx->buf);
  vPortFree(ctx->info);
  pmVar1 = ctx + 1;
  while (ctx != pmVar1) {
    *(undefined *)&ctx->buf = 0;
    ctx = (mbedtls_pem_context *)((int)&ctx->buf + 1);
  }
  return;
}



void mbedtls_md5_init(mbedtls_md5_context *ctx)

{
  memset(ctx,0,0x58);
  return;
}



void mbedtls_md5_free(mbedtls_md5_context *ctx)

{
  mbedtls_md5_context *pmVar1;
  
  pmVar1 = ctx + 1;
  if (ctx != (mbedtls_md5_context *)0x0) {
    while (ctx != pmVar1) {
      *(undefined *)ctx->total = 0;
      ctx = (mbedtls_md5_context *)((int)ctx->total + 1);
    }
  }
  return;
}



void mbedtls_md5_clone(mbedtls_md5_context *dst,mbedtls_md5_context *src)

{
  memcpy(dst,src,0x58);
  return;
}



void mbedtls_md5_starts(mbedtls_md5_context *ctx)

{
  ctx->state[0] = 0x67452301;
  ctx->state[1] = 0xefcdab89;
  ctx->state[2] = 0x98badcfe;
  ctx->total[0] = 0;
  ctx->total[1] = 0;
  ctx->state[3] = 0x10325476;
  return;
}



void mbedtls_md5_process(mbedtls_md5_context *ctx,uchar *data)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  int iVar11;
  int iVar12;
  int iVar13;
  int iVar14;
  int iVar15;
  int iVar16;
  uint uVar17;
  uint uVar18;
  uint uVar19;
  uint uVar20;
  uint uVar21;
  uint uVar22;
  uint uVar23;
  uint uVar24;
  uint uVar25;
  
  iVar1 = *(int *)data;
  iVar2 = *(int *)(data + 4);
  iVar3 = *(int *)(data + 0x10);
  iVar4 = *(int *)(data + 8);
  iVar5 = *(int *)(data + 0xc);
  iVar6 = *(int *)(data + 0x14);
  iVar7 = *(int *)(data + 0x18);
  iVar8 = *(int *)(data + 0x24);
  iVar9 = *(int *)(data + 0x1c);
  iVar10 = *(int *)(data + 0x20);
  iVar11 = *(int *)(data + 0x2c);
  iVar12 = *(int *)(data + 0x28);
  iVar13 = *(int *)(data + 0x30);
  uVar19 = ctx->state[3];
  iVar14 = *(int *)(data + 0x34);
  iVar15 = *(int *)(data + 0x38);
  iVar16 = *(int *)(data + 0x3c);
  uVar17 = ctx->state[2];
  uVar18 = ctx->state[1];
  uVar20 = ((uVar17 ^ uVar19) & uVar18 ^ uVar19) + ctx->state[0] + 0xd76aa478 + iVar1;
  uVar21 = (uVar20 >> 0x19 | uVar20 * 0x80) + uVar18;
  uVar20 = ((uVar18 ^ uVar17) & uVar21 ^ uVar17) + uVar19 + 0xe8c7b756 + iVar2;
  uVar23 = (uVar20 >> 0x14 | uVar20 * 0x1000) + uVar21;
  uVar20 = ((uVar18 ^ uVar21) & uVar23 ^ uVar18) + uVar17 + 0x242070db + iVar4;
  uVar22 = (uVar20 * 0x20000 | uVar20 >> 0xf) + uVar23;
  uVar20 = ((uVar21 ^ uVar23) & uVar22 ^ uVar21) + uVar18 + 0xc1bdceee + iVar5;
  uVar20 = (uVar20 * 0x400000 | uVar20 >> 10) + uVar22;
  uVar21 = ((uVar23 ^ uVar22) & uVar20 ^ uVar23) + iVar3 + -0xa83f051 + uVar21;
  uVar21 = (uVar21 >> 0x19 | uVar21 * 0x80) + uVar20;
  uVar23 = ((uVar22 ^ uVar20) & uVar21 ^ uVar22) + iVar6 + 0x4787c62a + uVar23;
  uVar23 = (uVar23 >> 0x14 | uVar23 * 0x1000) + uVar21;
  uVar22 = ((uVar20 ^ uVar21) & uVar23 ^ uVar20) + iVar7 + -0x57cfb9ed + uVar22;
  uVar22 = (uVar22 * 0x20000 | uVar22 >> 0xf) + uVar23;
  uVar20 = ((uVar21 ^ uVar23) & uVar22 ^ uVar21) + iVar9 + -0x2b96aff + uVar20;
  uVar20 = (uVar20 * 0x400000 | uVar20 >> 10) + uVar22;
  uVar21 = ((uVar23 ^ uVar22) & uVar20 ^ uVar23) + iVar10 + 0x698098d8 + uVar21;
  uVar21 = (uVar21 >> 0x19 | uVar21 * 0x80) + uVar20;
  uVar23 = ((uVar22 ^ uVar20) & uVar21 ^ uVar22) + iVar8 + -0x74bb0851 + uVar23;
  uVar23 = (uVar23 >> 0x14 | uVar23 * 0x1000) + uVar21;
  uVar22 = ((uVar20 ^ uVar21) & uVar23 ^ uVar20) + iVar12 + -0xa44f + uVar22;
  uVar22 = (uVar22 * 0x20000 | uVar22 >> 0xf) + uVar23;
  uVar20 = ((uVar21 ^ uVar23) & uVar22 ^ uVar21) + iVar11 + -0x76a32842 + uVar20;
  uVar20 = (uVar20 * 0x400000 | uVar20 >> 10) + uVar22;
  uVar21 = ((uVar23 ^ uVar22) & uVar20 ^ uVar23) + iVar13 + 0x6b901122 + uVar21;
  uVar21 = (uVar21 >> 0x19 | uVar21 * 0x80) + uVar20;
  uVar23 = ((uVar22 ^ uVar20) & uVar21 ^ uVar22) + iVar14 + -0x2678e6d + uVar23;
  uVar23 = (uVar23 >> 0x14 | uVar23 * 0x1000) + uVar21;
  uVar22 = ((uVar20 ^ uVar21) & uVar23 ^ uVar20) + iVar15 + -0x5986bc72 + uVar22;
  uVar22 = (uVar22 * 0x20000 | uVar22 >> 0xf) + uVar23;
  uVar20 = ((uVar21 ^ uVar23) & uVar22 ^ uVar21) + iVar16 + 0x49b40821 + uVar20;
  uVar20 = (uVar20 * 0x400000 | uVar20 >> 10) + uVar22;
  uVar21 = ((uVar22 ^ uVar20) & uVar23 ^ uVar22) + iVar2 + -0x9e1da9e + uVar21;
  uVar21 = (uVar21 >> 0x1b | uVar21 * 0x20) + uVar20;
  uVar23 = ((uVar20 ^ uVar21) & uVar22 ^ uVar20) + iVar7 + -0x3fbf4cc0 + uVar23;
  uVar23 = (uVar23 >> 0x17 | uVar23 * 0x200) + uVar21;
  uVar22 = ((uVar21 ^ uVar23) & uVar20 ^ uVar21) + iVar11 + 0x265e5a51 + uVar22;
  uVar22 = (uVar22 >> 0x12 | uVar22 * 0x4000) + uVar23;
  uVar20 = ((uVar23 ^ uVar22) & uVar21 ^ uVar23) + iVar1 + -0x16493856 + uVar20;
  uVar20 = (uVar20 * 0x100000 | uVar20 >> 0xc) + uVar22;
  uVar21 = ((uVar22 ^ uVar20) & uVar23 ^ uVar22) + iVar6 + -0x29d0efa3 + uVar21;
  uVar21 = (uVar21 >> 0x1b | uVar21 * 0x20) + uVar20;
  uVar23 = ((uVar20 ^ uVar21) & uVar22 ^ uVar20) + iVar12 + 0x2441453 + uVar23;
  uVar23 = (uVar23 >> 0x17 | uVar23 * 0x200) + uVar21;
  uVar22 = ((uVar21 ^ uVar23) & uVar20 ^ uVar21) + iVar16 + -0x275e197f + uVar22;
  uVar22 = (uVar22 >> 0x12 | uVar22 * 0x4000) + uVar23;
  uVar20 = ((uVar23 ^ uVar22) & uVar21 ^ uVar23) + iVar3 + -0x182c0438 + uVar20;
  uVar20 = (uVar20 * 0x100000 | uVar20 >> 0xc) + uVar22;
  uVar21 = ((uVar22 ^ uVar20) & uVar23 ^ uVar22) + iVar8 + 0x21e1cde6 + uVar21;
  uVar21 = (uVar21 >> 0x1b | uVar21 * 0x20) + uVar20;
  uVar23 = ((uVar20 ^ uVar21) & uVar22 ^ uVar20) + iVar15 + -0x3cc8f82a + uVar23;
  uVar23 = (uVar23 >> 0x17 | uVar23 * 0x200) + uVar21;
  uVar22 = ((uVar21 ^ uVar23) & uVar20 ^ uVar21) + iVar5 + -0xb2af279 + uVar22;
  uVar22 = (uVar22 >> 0x12 | uVar22 * 0x4000) + uVar23;
  uVar20 = ((uVar23 ^ uVar22) & uVar21 ^ uVar23) + iVar10 + 0x455a14ed + uVar20;
  uVar20 = (uVar20 * 0x100000 | uVar20 >> 0xc) + uVar22;
  uVar21 = ((uVar22 ^ uVar20) & uVar23 ^ uVar22) + iVar14 + -0x561c16fb + uVar21;
  uVar21 = (uVar21 >> 0x1b | uVar21 * 0x20) + uVar20;
  uVar23 = ((uVar20 ^ uVar21) & uVar22 ^ uVar20) + iVar4 + -0x3105c08 + uVar23;
  uVar24 = (uVar23 >> 0x17 | uVar23 * 0x200) + uVar21;
  uVar22 = ((uVar21 ^ uVar24) & uVar20 ^ uVar21) + iVar9 + 0x676f02d9 + uVar22;
  uVar23 = (uVar22 >> 0x12 | uVar22 * 0x4000) + uVar24;
  uVar20 = ((uVar24 ^ uVar23) & uVar21 ^ uVar24) + iVar13 + -0x72d5b376 + uVar20;
  uVar20 = (uVar20 * 0x100000 | uVar20 >> 0xc) + uVar23;
  uVar21 = (uVar24 ^ uVar23 ^ uVar20) + iVar6 + -0x5c6be + uVar21;
  uVar21 = (uVar21 >> 0x1c | uVar21 * 0x10) + uVar20;
  uVar22 = (uVar23 ^ uVar20 ^ uVar21) + uVar24 + iVar10 + -0x788e097f;
  uVar22 = (uVar22 >> 0x15 | uVar22 * 0x800) + uVar21;
  uVar23 = (uVar20 ^ uVar21 ^ uVar22) + uVar23 + iVar11 + 0x6d9d6122;
  uVar24 = (uVar23 >> 0x10 | uVar23 * 0x10000) + uVar22;
  uVar20 = (uVar21 ^ uVar22 ^ uVar24) + uVar20 + iVar15 + -0x21ac7f4;
  uVar23 = (uVar20 * 0x800000 | uVar20 >> 9) + uVar24;
  uVar20 = (uVar22 ^ uVar24 ^ uVar23) + iVar2 + -0x5b4115bc + uVar21;
  uVar21 = (uVar20 >> 0x1c | uVar20 * 0x10) + uVar23;
  uVar20 = (uVar24 ^ uVar23 ^ uVar21) + uVar22 + iVar3 + 0x4bdecfa9;
  uVar20 = (uVar20 >> 0x15 | uVar20 * 0x800) + uVar21;
  uVar22 = (uVar23 ^ uVar21 ^ uVar20) + iVar9 + -0x944b4a0 + uVar24;
  uVar24 = (uVar22 >> 0x10 | uVar22 * 0x10000) + uVar20;
  uVar22 = (uVar21 ^ uVar20 ^ uVar24) + uVar23 + iVar12 + -0x41404390;
  uVar22 = (uVar22 * 0x800000 | uVar22 >> 9) + uVar24;
  uVar21 = (uVar20 ^ uVar24 ^ uVar22) + uVar21 + iVar14 + 0x289b7ec6;
  uVar23 = (uVar21 >> 0x1c | uVar21 * 0x10) + uVar22;
  uVar20 = (uVar24 ^ uVar22 ^ uVar23) + iVar1 + -0x155ed806 + uVar20;
  uVar20 = (uVar20 >> 0x15 | uVar20 * 0x800) + uVar23;
  uVar21 = (uVar22 ^ uVar23 ^ uVar20) + iVar5 + -0x2b10cf7b + uVar24;
  uVar24 = (uVar21 >> 0x10 | uVar21 * 0x10000) + uVar20;
  uVar21 = (uVar23 ^ uVar20 ^ uVar24) + uVar22 + iVar7 + 0x4881d05;
  uVar21 = (uVar21 * 0x800000 | uVar21 >> 9) + uVar24;
  uVar22 = (uVar20 ^ uVar24 ^ uVar21) + iVar8 + -0x262b2fc7 + uVar23;
  uVar23 = (uVar22 >> 0x1c | uVar22 * 0x10) + uVar21;
  uVar20 = (uVar24 ^ uVar21 ^ uVar23) + uVar20 + iVar13 + -0x1924661b;
  uVar22 = (uVar20 >> 0x15 | uVar20 * 0x800) + uVar23;
  uVar20 = (uVar21 ^ uVar23 ^ uVar22) + uVar24 + iVar16 + 0x1fa27cf8;
  uVar20 = (uVar20 >> 0x10 | uVar20 * 0x10000) + uVar22;
  uVar21 = (uVar23 ^ uVar22 ^ uVar20) + iVar4 + -0x3b53a99b + uVar21;
  uVar21 = (uVar21 * 0x800000 | uVar21 >> 9) + uVar20;
  uVar23 = ((~uVar22 | uVar21) ^ uVar20) + uVar23 + iVar1 + -0xbd6ddbc;
  uVar24 = (uVar23 >> 0x1a | uVar23 * 0x40) + uVar21;
  uVar22 = ((~uVar20 | uVar24) ^ uVar21) + uVar22 + iVar9 + 0x432aff97;
  uVar23 = (uVar22 >> 0x16 | uVar22 * 0x400) + uVar24;
  uVar20 = ((~uVar21 | uVar23) ^ uVar24) + iVar15 + -0x546bdc59 + uVar20;
  uVar20 = (uVar20 >> 0x11 | uVar20 * 0x8000) + uVar23;
  uVar21 = ((~uVar24 | uVar20) ^ uVar23) + iVar6 + -0x36c5fc7 + uVar21;
  uVar22 = (uVar21 * 0x200000 | uVar21 >> 0xb) + uVar20;
  uVar21 = ((~uVar23 | uVar22) ^ uVar20) + iVar13 + 0x655b59c3 + uVar24;
  uVar24 = (uVar21 >> 0x1a | uVar21 * 0x40) + uVar22;
  uVar21 = ((~uVar20 | uVar24) ^ uVar22) + uVar23 + iVar5 + -0x70f3336e;
  uVar21 = (uVar21 >> 0x16 | uVar21 * 0x400) + uVar24;
  uVar20 = ((~uVar22 | uVar21) ^ uVar24) + iVar12 + -0x100b83 + uVar20;
  uVar20 = (uVar20 >> 0x11 | uVar20 * 0x8000) + uVar21;
  uVar22 = ((~uVar24 | uVar20) ^ uVar21) + iVar2 + -0x7a7ba22f + uVar22;
  uVar22 = (uVar22 * 0x200000 | uVar22 >> 0xb) + uVar20;
  uVar23 = ((~uVar21 | uVar22) ^ uVar20) + iVar10 + 0x6fa87e4f + uVar24;
  uVar25 = (uVar23 >> 0x1a | uVar23 * 0x40) + uVar22;
  uVar21 = ((~uVar20 | uVar25) ^ uVar22) + uVar21 + iVar16 + -0x1d31920;
  uVar24 = (uVar21 >> 0x16 | uVar21 * 0x400) + uVar25;
  uVar20 = ((~uVar22 | uVar24) ^ uVar25) + iVar7 + -0x5cfebcec + uVar20;
  uVar20 = (uVar20 >> 0x11 | uVar20 * 0x8000) + uVar24;
  uVar21 = ((~uVar25 | uVar20) ^ uVar24) + iVar14 + 0x4e0811a1 + uVar22;
  uVar23 = (uVar21 * 0x200000 | uVar21 >> 0xb) + uVar20;
  uVar21 = ((~uVar24 | uVar23) ^ uVar20) + uVar25 + iVar3 + -0x8ac817e;
  uVar22 = (uVar21 >> 0x1a | uVar21 * 0x40) + uVar23;
  uVar21 = ((~uVar20 | uVar22) ^ uVar23) + uVar24 + iVar11 + -0x42c50dcb;
  uVar21 = (uVar21 >> 0x16 | uVar21 * 0x400) + uVar22;
  uVar20 = ((~uVar23 | uVar21) ^ uVar22) + uVar20 + iVar4 + 0x2ad7d2bb;
  uVar20 = (uVar20 >> 0x11 | uVar20 * 0x8000) + uVar21;
  uVar23 = ((~uVar22 | uVar20) ^ uVar21) + uVar23 + iVar8 + -0x14792c6f;
  ctx->state[0] = ctx->state[0] + uVar22;
  ctx->state[1] = uVar18 + uVar20 + (uVar23 >> 0xb | uVar23 * 0x200000);
  ctx->state[2] = uVar20 + uVar17;
  ctx->state[3] = uVar21 + uVar19;
  return;
}



void mbedtls_md5_update(mbedtls_md5_context *ctx,uchar *input,size_t ilen)

{
  size_t __n;
  uint uVar1;
  uint uVar2;
  uint __n_00;
  
  uVar2 = ctx->total[0] & 0x3f;
  uVar1 = ctx->total[0] + ilen;
  ctx->total[0] = uVar1;
  if (uVar1 < ilen) {
    ctx->total[1] = ctx->total[1] + 1;
  }
  uVar1 = ilen;
  if ((uVar2 != 0) && (__n_00 = 0x40 - uVar2, __n_00 <= ilen)) {
    memcpy(ctx->buffer + uVar2,input,__n_00);
    ilen = (ilen - 0x40) + uVar2;
    mbedtls_md5_process(ctx,ctx->buffer);
    input = input + __n_00;
    uVar2 = 0;
    uVar1 = ilen;
  }
  while (0x3f < ilen) {
    mbedtls_md5_process(ctx,input + (uVar1 - ilen));
    ilen = ilen - 0x40;
  }
  __n = (uVar1 >> 6) * -0x40 + uVar1;
  if (__n == 0) {
    return;
  }
  memcpy(ctx->buffer + uVar2,input + (uVar1 & 0xffffffc0),__n);
  return;
}



void mbedtls_md5_update(mbedtls_md5_context *ctx,uchar *input,size_t ilen)

{
  if (ilen != 0) {
    mbedtls_md5_update(ctx,input,ilen);
    return;
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

void mbedtls_md5_finish(mbedtls_md5_context *ctx,uchar *output)

{
  uint uVar1;
  int iVar2;
  int iStack24;
  uchar msglen [8];
  
  uVar1 = ctx->total[0];
  msglen._0_4_ = ctx->total[1] << 3 | uVar1 >> 0x1d;
  iStack24 = uVar1 << 3;
  if ((uVar1 & 0x3f) < 0x38) {
    iVar2 = 0x38;
  }
  else {
    iVar2 = 0x78;
  }
  mbedtls_md5_update(ctx,md5_padding,iVar2 - (uVar1 & 0x3f));
  mbedtls_md5_update(ctx,(uchar *)&iStack24,8);
  *output = (uchar)ctx->state[0];
  output[1] = (uchar)(ctx->state[0] >> 8);
  output[2] = (uchar)*(undefined2 *)((int)ctx->state + 2);
  output[3] = *(uchar *)((int)ctx->state + 3);
  output[4] = (uchar)ctx->state[1];
  output[5] = (uchar)(ctx->state[1] >> 8);
  output[6] = (uchar)*(undefined2 *)((int)ctx->state + 6);
  output[7] = *(uchar *)((int)ctx->state + 7);
  output[8] = (uchar)ctx->state[2];
  output[9] = (uchar)(ctx->state[2] >> 8);
  output[10] = (uchar)*(undefined2 *)((int)ctx->state + 10);
  output[0xb] = *(uchar *)((int)ctx->state + 0xb);
  output[0xc] = (uchar)ctx->state[3];
  output[0xd] = (uchar)(ctx->state[3] >> 8);
  output[0xe] = (uchar)*(undefined2 *)((int)ctx->state + 0xe);
  output[0xf] = *(uchar *)((int)ctx->state + 0xf);
  return;
}



void mbedtls_md5(uchar *input,size_t ilen,uchar *output)

{
  undefined auStack104 [4];
  mbedtls_md5_context ctx;
  
  mbedtls_md5_init((mbedtls_md5_context *)auStack104);
  mbedtls_md5_starts((mbedtls_md5_context *)auStack104);
  mbedtls_md5_update((mbedtls_md5_context *)auStack104,input,ilen);
  mbedtls_md5_finish((mbedtls_md5_context *)auStack104,output);
  mbedtls_md5_free((mbedtls_md5_context *)auStack104);
  return;
}



void mbedtls_sha1_init(mbedtls_sha1_context *ctx)

{
  memset(ctx,0,0x5c);
  return;
}



void mbedtls_sha1_free(mbedtls_sha1_context *ctx)

{
  mbedtls_sha1_context *pmVar1;
  
  pmVar1 = ctx + 1;
  if (ctx != (mbedtls_sha1_context *)0x0) {
    while (ctx != pmVar1) {
      *(undefined *)ctx->total = 0;
      ctx = (mbedtls_sha1_context *)((int)ctx->total + 1);
    }
  }
  return;
}



void mbedtls_sha1_clone(mbedtls_sha1_context *dst,mbedtls_sha1_context *src)

{
  memcpy(dst,src,0x5c);
  return;
}



void mbedtls_sha1_starts(mbedtls_sha1_context *ctx)

{
  ctx->state[0] = 0x67452301;
  ctx->state[1] = 0xefcdab89;
  ctx->state[2] = 0x98badcfe;
  ctx->state[3] = 0x10325476;
  ctx->total[0] = 0;
  ctx->total[1] = 0;
  ctx->state[4] = 0xc3d2e1f0;
  return;
}



void mbedtls_sha1_process(mbedtls_sha1_context *ctx,uchar *data)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint32_t uVar12;
  uint uVar13;
  uint uVar14;
  uint uVar15;
  uint uVar16;
  uint uVar17;
  uint uVar18;
  uint uVar19;
  uint uVar20;
  uint uVar21;
  uint uVar22;
  uint uVar23;
  uint uVar24;
  uint uVar25;
  uint uVar26;
  uint uVar27;
  uint uVar28;
  
  uVar8 = (uint)*data << 0x18 | (uint)data[1] << 0x10 | (uint)data[3] | (uint)data[2] << 8;
  uVar10 = (uint)data[4] << 0x18 | (uint)data[5] << 0x10 | (uint)data[7] | (uint)data[6] << 8;
  uVar9 = (uint)data[8] << 0x18 | (uint)data[9] << 0x10 | (uint)data[0xb] | (uint)data[10] << 8;
  uVar1 = (uint)data[0xc] << 0x18 | (uint)data[0xd] << 0x10 | (uint)data[0xf] | (uint)data[0xe] << 8
  ;
  uVar27 = (uint)data[0x10] << 0x18 | (uint)data[0x11] << 0x10 | (uint)data[0x13] |
           (uint)data[0x12] << 8;
  uVar25 = (uint)data[0x14] << 0x18 | (uint)data[0x15] << 0x10 | (uint)data[0x17] |
           (uint)data[0x16] << 8;
  uVar14 = (uint)data[0x18] << 0x18 | (uint)data[0x19] << 0x10 | (uint)data[0x1b] |
           (uint)data[0x1a] << 8;
  uVar20 = (uint)data[0x1c] << 0x18 | (uint)data[0x1d] << 0x10 | (uint)data[0x1f] |
           (uint)data[0x1e] << 8;
  uVar28 = (uint)data[0x20] << 0x18 | (uint)data[0x21] << 0x10 | (uint)data[0x23] |
           (uint)data[0x22] << 8;
  uVar26 = (uint)data[0x24] << 0x18 | (uint)data[0x25] << 0x10 | (uint)data[0x27] |
           (uint)data[0x26] << 8;
  uVar2 = (uint)data[0x28] << 0x18 | (uint)data[0x29] << 0x10 | (uint)data[0x2b] |
          (uint)data[0x2a] << 8;
  uVar13 = (uint)data[0x2c] << 0x18 | (uint)data[0x2d] << 0x10 | (uint)data[0x2f] |
           (uint)data[0x2e] << 8;
  uVar11 = (uint)data[0x30] << 0x18 | (uint)data[0x31] << 0x10 | (uint)data[0x33] |
           (uint)data[0x32] << 8;
  uVar16 = ctx->state[2];
  uVar15 = ctx->state[0];
  uVar5 = (uint)data[0x34] << 0x18 | (uint)data[0x35] << 0x10 | (uint)data[0x37] |
          (uint)data[0x36] << 8;
  uVar4 = (uint)data[0x38] << 0x18 | (uint)data[0x39] << 0x10 | (uint)data[0x3b] |
          (uint)data[0x3a] << 8;
  uVar3 = (uint)data[0x3c] << 0x18 | (uint)data[0x3d] << 0x10 | (uint)data[0x3f] |
          (uint)data[0x3e] << 8;
  uVar6 = (uVar15 << 5 | uVar15 >> 0x1b) + ctx->state[4] + 0x5a827999 +
          ((uVar16 ^ ctx->state[3]) & ctx->state[1] ^ ctx->state[3]) + uVar8;
  uVar17 = ctx->state[1] << 0x1e | ctx->state[1] >> 2;
  uVar18 = (uVar6 * 0x20 | uVar6 >> 0x1b) +
           ((uVar16 ^ uVar17) & uVar15 ^ uVar16) + ctx->state[3] + 0x5a827999 + uVar10;
  uVar23 = uVar15 << 0x1e | uVar15 >> 2;
  uVar7 = uVar6 * 0x40000000 | uVar6 >> 2;
  uVar6 = (uVar18 * 0x20 | uVar18 >> 0x1b) +
          ((uVar17 ^ uVar23) & uVar6 ^ uVar17) + uVar16 + 0x5a827999 + uVar9;
  uVar19 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar18 = (uVar6 * 0x20 | uVar6 >> 0x1b) +
           ((uVar23 ^ uVar7) & uVar18 ^ uVar23) + uVar17 + 0x5a827999 + uVar1;
  uVar21 = uVar6 * 0x40000000 | uVar6 >> 2;
  uVar17 = (uVar18 * 0x20 | uVar18 >> 0x1b) +
           ((uVar7 ^ uVar19) & uVar6 ^ uVar7) + uVar23 + 0x5a827999 + uVar27;
  uVar23 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           ((uVar19 ^ uVar21) & uVar18 ^ uVar19) + uVar25 + 0x5a827999 + uVar7;
  uVar6 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar18 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar7 = (uVar23 * 0x20 | uVar23 >> 0x1b) +
          ((uVar21 ^ uVar6) & uVar17 ^ uVar21) + uVar14 + 0x5a827999 + uVar19;
  uVar24 = uVar23 * 0x40000000 | uVar23 >> 2;
  uVar19 = (uVar7 * 0x20 | uVar7 >> 0x1b) +
           ((uVar6 ^ uVar18) & uVar23 ^ uVar6) + uVar21 + uVar20 + 0x5a827999;
  uVar17 = uVar7 * 0x40000000 | uVar7 >> 2;
  uVar7 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
          ((uVar18 ^ uVar24) & uVar7 ^ uVar18) + uVar28 + 0x5a827999 + uVar6;
  uVar23 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar6 = (uVar7 * 0x20 | uVar7 >> 0x1b) +
          ((uVar24 ^ uVar17) & uVar19 ^ uVar24) + uVar18 + uVar26 + 0x5a827999;
  uVar22 = uVar7 * 0x40000000 | uVar7 >> 2;
  uVar19 = (uVar6 * 0x20 | uVar6 >> 0x1b) +
           ((uVar17 ^ uVar23) & uVar7 ^ uVar17) + uVar2 + 0x5a827999 + uVar24;
  uVar18 = uVar6 * 0x40000000 | uVar6 >> 2;
  uVar7 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
          ((uVar23 ^ uVar22) & uVar6 ^ uVar23) + uVar17 + uVar13 + 0x5a827999;
  uVar21 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar6 = (uVar7 * 0x20 | uVar7 >> 0x1b) +
          ((uVar22 ^ uVar18) & uVar19 ^ uVar22) + uVar11 + 0x5a827999 + uVar23;
  uVar17 = uVar7 * 0x40000000 | uVar7 >> 2;
  uVar19 = (uVar6 * 0x20 | uVar6 >> 0x1b) +
           ((uVar18 ^ uVar21) & uVar7 ^ uVar18) + uVar22 + uVar5 + 0x5a827999;
  uVar7 = uVar6 * 0x40000000 | uVar6 >> 2;
  uVar23 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
           ((uVar21 ^ uVar17) & uVar6 ^ uVar21) + uVar4 + 0x5a827999 + uVar18;
  uVar22 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar6 = uVar8 ^ uVar9 ^ uVar28 ^ uVar5;
  uVar18 = (uVar23 * 0x20 | uVar23 >> 0x1b) +
           ((uVar17 ^ uVar7) & uVar19 ^ uVar17) + uVar21 + uVar3 + 0x5a827999;
  uVar8 = uVar6 >> 0x1f | uVar6 << 1;
  uVar6 = uVar10 ^ uVar1 ^ uVar26 ^ uVar4;
  uVar19 = uVar23 * 0x40000000 | uVar23 >> 2;
  uVar10 = uVar6 >> 0x1f | uVar6 << 1;
  uVar17 = (uVar18 * 0x20 | uVar18 >> 0x1b) +
           ((uVar7 ^ uVar22) & uVar23 ^ uVar7) + uVar8 + 0x5a827999 + uVar17;
  uVar21 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar9 = uVar9 ^ uVar27 ^ uVar2 ^ uVar3;
  uVar6 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
          ((uVar22 ^ uVar19) & uVar18 ^ uVar22) + uVar7 + uVar10 + 0x5a827999;
  uVar9 = uVar9 >> 0x1f | uVar9 << 1;
  uVar1 = uVar1 ^ uVar25 ^ uVar13 ^ uVar8;
  uVar23 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar1 = uVar1 >> 0x1f | uVar1 << 1;
  uVar18 = (uVar6 * 0x20 | uVar6 >> 0x1b) +
           ((uVar19 ^ uVar21) & uVar17 ^ uVar19) + uVar9 + 0x5a827999 + uVar22;
  uVar17 = uVar27 ^ uVar14 ^ uVar11 ^ uVar10;
  uVar7 = uVar6 * 0x40000000 | uVar6 >> 2;
  uVar27 = uVar17 >> 0x1f | uVar17 << 1;
  uVar17 = (uVar18 * 0x20 | uVar18 >> 0x1b) +
           ((uVar21 ^ uVar23) & uVar6 ^ uVar21) + uVar1 + 0x5a827999 + uVar19;
  uVar6 = uVar25 ^ uVar20 ^ uVar5 ^ uVar9;
  uVar19 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar24 = uVar6 >> 0x1f | uVar6 << 1;
  uVar21 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           (uVar23 ^ uVar7 ^ uVar18) + uVar21 + uVar27 + 0x6ed9eba1;
  uVar6 = uVar14 ^ uVar28 ^ uVar4 ^ uVar1;
  uVar18 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar17 = (uVar21 * 0x20 | uVar21 >> 0x1b) +
           (uVar7 ^ uVar19 ^ uVar17) + uVar24 + 0x6ed9eba1 + uVar23;
  uVar14 = uVar6 >> 0x1f | uVar6 << 1;
  uVar23 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar6 = uVar20 ^ uVar26 ^ uVar3 ^ uVar27;
  uVar6 = uVar6 >> 0x1f | uVar6 << 1;
  uVar21 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           (uVar19 ^ uVar18 ^ uVar21) + uVar14 + 0x6ed9eba1 + uVar7;
  uVar7 = uVar28 ^ uVar2 ^ uVar8 ^ uVar24;
  uVar20 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar28 = uVar7 >> 0x1f | uVar7 << 1;
  uVar7 = (uVar21 * 0x20 | uVar21 >> 0x1b) +
          (uVar18 ^ uVar23 ^ uVar17) + uVar19 + uVar6 + 0x6ed9eba1;
  uVar17 = uVar26 ^ uVar13 ^ uVar10 ^ uVar14;
  uVar22 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar26 = uVar17 >> 0x1f | uVar17 << 1;
  uVar17 = (uVar7 * 0x20 | uVar7 >> 0x1b) +
           (uVar23 ^ uVar20 ^ uVar21) + uVar18 + uVar28 + 0x6ed9eba1;
  uVar2 = uVar2 ^ uVar11 ^ uVar9 ^ uVar6;
  uVar19 = uVar7 * 0x40000000 | uVar7 >> 2;
  uVar21 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           (uVar20 ^ uVar22 ^ uVar7) + uVar23 + uVar26 + 0x6ed9eba1;
  uVar2 = uVar2 >> 0x1f | uVar2 << 1;
  uVar7 = uVar13 ^ uVar5 ^ uVar1 ^ uVar28;
  uVar18 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar13 = uVar7 >> 0x1f | uVar7 << 1;
  uVar20 = (uVar21 * 0x20 | uVar21 >> 0x1b) +
           (uVar22 ^ uVar19 ^ uVar17) + uVar2 + 0x6ed9eba1 + uVar20;
  uVar7 = uVar11 ^ uVar4 ^ uVar27 ^ uVar26;
  uVar23 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar11 = uVar7 >> 0x1f | uVar7 << 1;
  uVar17 = (uVar20 * 0x20 | uVar20 >> 0x1b) +
           (uVar19 ^ uVar18 ^ uVar21) + uVar13 + 0x6ed9eba1 + uVar22;
  uVar5 = uVar5 ^ uVar3 ^ uVar24 ^ uVar2;
  uVar22 = uVar20 * 0x40000000 | uVar20 >> 2;
  uVar5 = uVar5 >> 0x1f | uVar5 << 1;
  uVar7 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
          (uVar18 ^ uVar23 ^ uVar20) + uVar19 + uVar11 + 0x6ed9eba1;
  uVar4 = uVar4 ^ uVar8 ^ uVar14 ^ uVar13;
  uVar20 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar4 = uVar4 >> 0x1f | uVar4 << 1;
  uVar17 = (uVar7 * 0x20 | uVar7 >> 0x1b) + (uVar23 ^ uVar22 ^ uVar17) + uVar18 + uVar5 + 0x6ed9eba1
  ;
  uVar3 = uVar3 ^ uVar10 ^ uVar6 ^ uVar11;
  uVar19 = uVar7 * 0x40000000 | uVar7 >> 2;
  uVar3 = uVar3 >> 0x1f | uVar3 << 1;
  uVar21 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           (uVar22 ^ uVar20 ^ uVar7) + uVar23 + uVar4 + 0x6ed9eba1;
  uVar7 = uVar8 ^ uVar9 ^ uVar28 ^ uVar5;
  uVar18 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar17 = (uVar21 * 0x20 | uVar21 >> 0x1b) +
           (uVar20 ^ uVar19 ^ uVar17) + uVar3 + 0x6ed9eba1 + uVar22;
  uVar7 = uVar7 >> 0x1f | uVar7 << 1;
  uVar8 = uVar10 ^ uVar1 ^ uVar26 ^ uVar4;
  uVar23 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar10 = uVar8 >> 0x1f | uVar8 << 1;
  uVar21 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           (uVar19 ^ uVar18 ^ uVar21) + uVar7 + 0x6ed9eba1 + uVar20;
  uVar8 = uVar9 ^ uVar27 ^ uVar2 ^ uVar3;
  uVar20 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar8 = uVar8 >> 0x1f | uVar8 << 1;
  uVar17 = (uVar21 * 0x20 | uVar21 >> 0x1b) +
           (uVar18 ^ uVar23 ^ uVar17) + uVar19 + uVar10 + 0x6ed9eba1;
  uVar1 = uVar1 ^ uVar24 ^ uVar13 ^ uVar7;
  uVar22 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar9 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
          (uVar23 ^ uVar20 ^ uVar21) + uVar18 + uVar8 + 0x6ed9eba1;
  uVar1 = uVar1 >> 0x1f | uVar1 << 1;
  uVar19 = uVar27 ^ uVar14 ^ uVar11 ^ uVar10;
  uVar18 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar21 = (uVar9 * 0x20 | uVar9 >> 0x1b) + (uVar20 ^ uVar22 ^ uVar17) + uVar1 + 0x6ed9eba1 + uVar23
  ;
  uVar27 = uVar19 >> 0x1f | uVar19 << 1;
  uVar19 = uVar24 ^ uVar6 ^ uVar5 ^ uVar8;
  uVar17 = uVar9 * 0x40000000 | uVar9 >> 2;
  uVar25 = uVar19 >> 0x1f | uVar19 << 1;
  uVar19 = (uVar21 * 0x20 | uVar21 >> 0x1b) +
           (uVar22 ^ uVar18 ^ uVar9) + uVar27 + 0x6ed9eba1 + uVar20;
  uVar9 = uVar14 ^ uVar28 ^ uVar4 ^ uVar1;
  uVar23 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar14 = uVar9 >> 0x1f | uVar9 << 1;
  uVar20 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
           (uVar18 ^ uVar17 ^ uVar21) + uVar22 + uVar25 + 0x6ed9eba1;
  uVar6 = uVar6 ^ uVar26 ^ uVar3 ^ uVar27;
  uVar21 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar6 = uVar6 >> 0x1f | uVar6 << 1;
  uVar9 = (uVar20 * 0x20 | uVar20 >> 0x1b) +
          (uVar17 ^ uVar23 ^ uVar19) + uVar14 + 0x6ed9eba1 + uVar18;
  uVar18 = uVar28 ^ uVar2 ^ uVar7 ^ uVar25;
  uVar22 = uVar20 * 0x40000000 | uVar20 >> 2;
  uVar28 = uVar18 >> 0x1f | uVar18 << 1;
  uVar17 = (uVar9 * 0x20 | uVar9 >> 0x1b) + (uVar23 ^ uVar21 ^ uVar20) + uVar6 + 0x6ed9eba1 + uVar17
  ;
  uVar19 = uVar9 * 0x40000000 | uVar9 >> 2;
  uVar20 = uVar26 ^ uVar13 ^ uVar10 ^ uVar14;
  uVar18 = ((uVar9 | uVar22) & uVar21 | uVar9 & uVar22) +
           uVar28 + 0x8f1bbcdc + uVar23 + (uVar17 * 0x20 | uVar17 >> 0x1b);
  uVar26 = uVar20 >> 0x1f | uVar20 << 1;
  uVar2 = uVar2 ^ uVar11 ^ uVar8 ^ uVar6;
  uVar23 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar2 = uVar2 >> 0x1f | uVar2 << 1;
  uVar17 = (uVar18 * 0x20 | uVar18 >> 0x1b) +
           ((uVar17 | uVar19) & uVar22 | uVar17 & uVar19) + uVar26 + 0x8f1bbcdc + uVar21;
  uVar9 = uVar13 ^ uVar5 ^ uVar1 ^ uVar28;
  uVar21 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar13 = uVar9 >> 0x1f | uVar9 << 1;
  uVar20 = ((uVar18 | uVar23) & uVar19 | uVar18 & uVar23) +
           uVar2 + 0x8f1bbcdc + uVar22 + (uVar17 * 0x20 | uVar17 >> 0x1b);
  uVar9 = uVar11 ^ uVar4 ^ uVar27 ^ uVar26;
  uVar18 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar11 = uVar9 >> 0x1f | uVar9 << 1;
  uVar9 = (uVar20 * 0x20 | uVar20 >> 0x1b) +
          ((uVar17 | uVar21) & uVar23 | uVar17 & uVar21) + uVar13 + 0x8f1bbcdc + uVar19;
  uVar24 = uVar20 * 0x40000000 | uVar20 >> 2;
  uVar5 = uVar5 ^ uVar3 ^ uVar25 ^ uVar2;
  uVar19 = ((uVar20 | uVar18) & uVar21 | uVar20 & uVar18) +
           uVar11 + 0x8f1bbcdc + uVar23 + (uVar9 * 0x20 | uVar9 >> 0x1b);
  uVar5 = uVar5 >> 0x1f | uVar5 << 1;
  uVar4 = uVar4 ^ uVar7 ^ uVar14 ^ uVar13;
  uVar17 = uVar9 * 0x40000000 | uVar9 >> 2;
  uVar4 = uVar4 >> 0x1f | uVar4 << 1;
  uVar9 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
          ((uVar9 | uVar24) & uVar18 | uVar9 & uVar24) + uVar5 + 0x8f1bbcdc + uVar21;
  uVar3 = uVar3 ^ uVar10 ^ uVar6 ^ uVar11;
  uVar22 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar3 = uVar3 >> 0x1f | uVar3 << 1;
  uVar18 = ((uVar19 | uVar17) & uVar24 | uVar19 & uVar17) +
           uVar4 + 0x8f1bbcdc + uVar18 + (uVar9 * 0x20 | uVar9 >> 0x1b);
  uVar7 = uVar7 ^ uVar8 ^ uVar28 ^ uVar5;
  uVar20 = uVar9 * 0x40000000 | uVar9 >> 2;
  uVar7 = uVar7 >> 0x1f | uVar7 << 1;
  uVar21 = (uVar18 * 0x20 | uVar18 >> 0x1b) +
           ((uVar9 | uVar22) & uVar17 | uVar9 & uVar22) + uVar3 + 0x8f1bbcdc + uVar24;
  uVar9 = uVar10 ^ uVar1 ^ uVar26 ^ uVar4;
  uVar19 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar9 = uVar9 >> 0x1f | uVar9 << 1;
  uVar10 = ((uVar18 | uVar20) & uVar22 | uVar18 & uVar20) +
           uVar7 + 0x8f1bbcdc + uVar17 + (uVar21 * 0x20 | uVar21 >> 0x1b);
  uVar8 = uVar8 ^ uVar27 ^ uVar2 ^ uVar3;
  uVar23 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar8 = uVar8 >> 0x1f | uVar8 << 1;
  uVar18 = (uVar10 * 0x20 | uVar10 >> 0x1b) +
           ((uVar21 | uVar19) & uVar20 | uVar21 & uVar19) + uVar9 + 0x8f1bbcdc + uVar22;
  uVar1 = uVar1 ^ uVar25 ^ uVar13 ^ uVar7;
  uVar17 = uVar10 * 0x40000000 | uVar10 >> 2;
  uVar1 = uVar1 >> 0x1f | uVar1 << 1;
  uVar10 = ((uVar10 | uVar23) & uVar19 | uVar10 & uVar23) +
           uVar8 + 0x8f1bbcdc + uVar20 + (uVar18 * 0x20 | uVar18 >> 0x1b);
  uVar21 = uVar27 ^ uVar14 ^ uVar11 ^ uVar9;
  uVar22 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar27 = uVar21 >> 0x1f | uVar21 << 1;
  uVar18 = (uVar10 * 0x20 | uVar10 >> 0x1b) +
           ((uVar18 | uVar17) & uVar23 | uVar18 & uVar17) + uVar19 + uVar1 + 0x8f1bbcdc;
  uVar19 = uVar25 ^ uVar6 ^ uVar5 ^ uVar8;
  uVar20 = uVar10 * 0x40000000 | uVar10 >> 2;
  uVar24 = uVar19 >> 0x1f | uVar19 << 1;
  uVar21 = ((uVar10 | uVar22) & uVar17 | uVar10 & uVar22) +
           uVar27 + 0x8f1bbcdc + uVar23 + (uVar18 * 0x20 | uVar18 >> 0x1b);
  uVar10 = uVar14 ^ uVar28 ^ uVar4 ^ uVar1;
  uVar19 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar14 = uVar10 >> 0x1f | uVar10 << 1;
  uVar10 = (uVar21 * 0x20 | uVar21 >> 0x1b) +
           ((uVar18 | uVar20) & uVar22 | uVar18 & uVar20) + uVar17 + uVar24 + 0x8f1bbcdc;
  uVar6 = uVar6 ^ uVar26 ^ uVar3 ^ uVar27;
  uVar23 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar6 = uVar6 >> 0x1f | uVar6 << 1;
  uVar18 = ((uVar21 | uVar19) & uVar20 | uVar21 & uVar19) +
           uVar14 + 0x8f1bbcdc + uVar22 + (uVar10 * 0x20 | uVar10 >> 0x1b);
  uVar21 = uVar28 ^ uVar2 ^ uVar7 ^ uVar24;
  uVar17 = uVar10 * 0x40000000 | uVar10 >> 2;
  uVar28 = uVar21 >> 0x1f | uVar21 << 1;
  uVar10 = (uVar18 * 0x20 | uVar18 >> 0x1b) +
           ((uVar10 | uVar23) & uVar19 | uVar10 & uVar23) + uVar20 + uVar6 + 0x8f1bbcdc;
  uVar21 = uVar26 ^ uVar13 ^ uVar9 ^ uVar14;
  uVar22 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar25 = uVar21 >> 0x1f | uVar21 << 1;
  uVar18 = ((uVar18 | uVar17) & uVar23 | uVar18 & uVar17) +
           uVar28 + 0x8f1bbcdc + uVar19 + (uVar10 * 0x20 | uVar10 >> 0x1b);
  uVar2 = uVar2 ^ uVar11 ^ uVar8 ^ uVar6;
  uVar20 = uVar10 * 0x40000000 | uVar10 >> 2;
  uVar2 = uVar2 >> 0x1f | uVar2 << 1;
  uVar21 = (uVar18 * 0x20 | uVar18 >> 0x1b) +
           ((uVar10 | uVar22) & uVar17 | uVar10 & uVar22) + uVar23 + uVar25 + 0x8f1bbcdc;
  uVar10 = uVar13 ^ uVar5 ^ uVar1 ^ uVar28;
  uVar19 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar13 = uVar10 >> 0x1f | uVar10 << 1;
  uVar17 = ((uVar18 | uVar20) & uVar22 | uVar18 & uVar20) +
           uVar2 + 0x8f1bbcdc + uVar17 + (uVar21 * 0x20 | uVar21 >> 0x1b);
  uVar10 = uVar11 ^ uVar4 ^ uVar27 ^ uVar25;
  uVar18 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar10 = uVar10 >> 0x1f | uVar10 << 1;
  uVar23 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           ((uVar21 | uVar19) & uVar20 | uVar21 & uVar19) + uVar22 + uVar13 + 0x8f1bbcdc;
  uVar5 = uVar5 ^ uVar3 ^ uVar24 ^ uVar2;
  uVar11 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar5 = uVar5 >> 0x1f | uVar5 << 1;
  uVar21 = (uVar23 * 0x20 | uVar23 >> 0x1b) +
           (uVar19 ^ uVar18 ^ uVar17) + uVar20 + uVar10 + 0xca62c1d6;
  uVar4 = uVar4 ^ uVar7 ^ uVar14 ^ uVar13;
  uVar20 = uVar23 * 0x40000000 | uVar23 >> 2;
  uVar4 = uVar4 >> 0x1f | uVar4 << 1;
  uVar17 = (uVar21 * 0x20 | uVar21 >> 0x1b) +
           (uVar18 ^ uVar11 ^ uVar23) + uVar19 + uVar5 + 0xca62c1d6;
  uVar3 = uVar3 ^ uVar9 ^ uVar6 ^ uVar10;
  uVar23 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar3 = uVar3 >> 0x1f | uVar3 << 1;
  uVar19 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           (uVar11 ^ uVar20 ^ uVar21) + uVar18 + uVar4 + 0xca62c1d6;
  uVar7 = uVar7 ^ uVar8 ^ uVar28 ^ uVar5;
  uVar18 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar7 = uVar7 >> 0x1f | uVar7 << 1;
  uVar11 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
           (uVar20 ^ uVar23 ^ uVar17) + uVar11 + uVar3 + 0xca62c1d6;
  uVar9 = uVar9 ^ uVar1 ^ uVar25 ^ uVar4;
  uVar21 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar9 = uVar9 >> 0x1f | uVar9 << 1;
  uVar20 = (uVar11 * 0x20 | uVar11 >> 0x1b) +
           (uVar23 ^ uVar18 ^ uVar19) + uVar20 + uVar7 + 0xca62c1d6;
  uVar8 = uVar8 ^ uVar27 ^ uVar2 ^ uVar3;
  uVar17 = uVar11 * 0x40000000 | uVar11 >> 2;
  uVar8 = uVar8 >> 0x1f | uVar8 << 1;
  uVar19 = (uVar20 * 0x20 | uVar20 >> 0x1b) +
           (uVar18 ^ uVar21 ^ uVar11) + uVar23 + uVar9 + 0xca62c1d6;
  uVar1 = uVar1 ^ uVar24 ^ uVar13 ^ uVar7;
  uVar22 = uVar20 * 0x40000000 | uVar20 >> 2;
  uVar1 = uVar1 >> 0x1f | uVar1 << 1;
  uVar11 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
           (uVar21 ^ uVar17 ^ uVar20) + uVar18 + uVar8 + 0xca62c1d6;
  uVar18 = uVar27 ^ uVar14 ^ uVar10 ^ uVar9;
  uVar23 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar26 = uVar18 >> 0x1f | uVar18 << 1;
  uVar19 = (uVar11 * 0x20 | uVar11 >> 0x1b) +
           (uVar17 ^ uVar22 ^ uVar19) + uVar21 + uVar1 + 0xca62c1d6;
  uVar21 = uVar24 ^ uVar6 ^ uVar5 ^ uVar8;
  uVar18 = uVar11 * 0x40000000 | uVar11 >> 2;
  uVar24 = uVar21 >> 0x1f | uVar21 << 1;
  uVar17 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
           (uVar22 ^ uVar23 ^ uVar11) + uVar17 + uVar26 + 0xca62c1d6;
  uVar11 = uVar14 ^ uVar28 ^ uVar4 ^ uVar1;
  uVar21 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar11 = uVar11 >> 0x1f | uVar11 << 1;
  uVar20 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           (uVar23 ^ uVar18 ^ uVar19) + uVar22 + uVar24 + 0xca62c1d6;
  uVar6 = uVar6 ^ uVar25 ^ uVar3 ^ uVar26;
  uVar14 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar6 = uVar6 >> 0x1f | uVar6 << 1;
  uVar19 = (uVar20 * 0x20 | uVar20 >> 0x1b) +
           (uVar18 ^ uVar21 ^ uVar17) + uVar23 + uVar11 + 0xca62c1d6;
  uVar17 = uVar28 ^ uVar2 ^ uVar7 ^ uVar24;
  uVar22 = uVar20 * 0x40000000 | uVar20 >> 2;
  uVar27 = uVar17 >> 0x1f | uVar17 << 1;
  uVar17 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
           (uVar21 ^ uVar14 ^ uVar20) + uVar18 + uVar6 + 0xca62c1d6;
  uVar18 = uVar25 ^ uVar13 ^ uVar9 ^ uVar11;
  uVar23 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar20 = uVar18 >> 0x1f | uVar18 << 1;
  uVar19 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           (uVar14 ^ uVar22 ^ uVar19) + uVar21 + uVar27 + 0xca62c1d6;
  uVar2 = uVar2 ^ uVar10 ^ uVar8 ^ uVar6;
  uVar18 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar2 = uVar2 >> 0x1f | uVar2 << 1;
  uVar8 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
          (uVar22 ^ uVar23 ^ uVar17) + uVar14 + uVar20 + 0xca62c1d6;
  uVar27 = uVar13 ^ uVar5 ^ uVar1 ^ uVar27;
  uVar13 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar21 = uVar27 >> 0x1f | uVar27 << 1;
  uVar14 = uVar22 + uVar2 + 0xca62c1d6 + (uVar23 ^ uVar18 ^ uVar19) + (uVar8 * 0x20 | uVar8 >> 0x1b)
  ;
  uVar20 = uVar10 ^ uVar4 ^ uVar26 ^ uVar20;
  uVar10 = (uVar14 * 0x20 | uVar14 >> 0x1b) +
           (uVar18 ^ uVar13 ^ uVar8) + uVar23 + uVar21 + 0xca62c1d6;
  uVar1 = uVar8 * 0x40000000 | uVar8 >> 2;
  uVar17 = uVar20 >> 0x1f | uVar20 << 1;
  uVar2 = uVar5 ^ uVar3 ^ uVar24 ^ uVar2;
  uVar5 = uVar18 + uVar17 + 0xca62c1d6 + (uVar13 ^ uVar1 ^ uVar14) +
          (uVar10 * 0x20 | uVar10 >> 0x1b);
  uVar8 = uVar14 * 0x40000000 | uVar14 >> 2;
  uVar21 = uVar4 ^ uVar7 ^ uVar11 ^ uVar21;
  uVar4 = uVar13 + (uVar2 << 1 | uVar2 >> 0x1f) + 0xca62c1d6 + (uVar1 ^ uVar8 ^ uVar10) +
          (uVar5 * 0x20 | uVar5 >> 0x1b);
  uVar7 = uVar10 * 0x40000000 | uVar10 >> 2;
  uVar17 = uVar3 ^ uVar9 ^ uVar6 ^ uVar17;
  uVar1 = uVar1 + (uVar21 << 1 | uVar21 >> 0x1f) + 0xca62c1d6 + (uVar8 ^ uVar7 ^ uVar5) +
          (uVar4 * 0x20 | uVar4 >> 0x1b);
  uVar2 = uVar5 * 0x40000000 | uVar5 >> 2;
  uVar12 = ctx->state[1];
  ctx->state[0] =
       uVar8 + (uVar17 << 1 | uVar17 >> 0x1f) + uVar15 + 0xca62c1d6 + (uVar7 ^ uVar2 ^ uVar4) +
       (uVar1 * 0x20 | uVar1 >> 0x1b);
  ctx->state[1] = uVar1 + uVar12;
  ctx->state[2] = uVar16 + (uVar4 >> 2 | uVar4 * 0x40000000);
  ctx->state[3] = uVar2 + ctx->state[3];
  ctx->state[4] = uVar7 + ctx->state[4];
  return;
}



void mbedtls_sha1_update(mbedtls_sha1_context *ctx,uchar *input,size_t ilen)

{
  size_t __n;
  uint uVar1;
  uint uVar2;
  uint __n_00;
  
  uVar2 = ctx->total[0] & 0x3f;
  uVar1 = ctx->total[0] + ilen;
  ctx->total[0] = uVar1;
  if (uVar1 < ilen) {
    ctx->total[1] = ctx->total[1] + 1;
  }
  uVar1 = ilen;
  if ((uVar2 != 0) && (__n_00 = 0x40 - uVar2, __n_00 <= ilen)) {
    memcpy(ctx->buffer + uVar2,input,__n_00);
    ilen = (ilen - 0x40) + uVar2;
    mbedtls_sha1_process(ctx,ctx->buffer);
    input = input + __n_00;
    uVar2 = 0;
    uVar1 = ilen;
  }
  while (0x3f < ilen) {
    mbedtls_sha1_process(ctx,input + (uVar1 - ilen));
    ilen = ilen - 0x40;
  }
  __n = (uVar1 >> 6) * -0x40 + uVar1;
  if (__n == 0) {
    return;
  }
  memcpy(ctx->buffer + uVar2,input + (uVar1 & 0xffffffc0),__n);
  return;
}



void mbedtls_sha1_update(mbedtls_sha1_context *ctx,uchar *input,size_t ilen)

{
  if (ilen != 0) {
    mbedtls_sha1_update(ctx,input,ilen);
    return;
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

void mbedtls_sha1_finish(mbedtls_sha1_context *ctx,uchar *output)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  uchar uStack24;
  undefined uStack23;
  ushort uStack22;
  uchar msglen [8];
  
  uVar1 = ctx->total[0];
  uVar2 = ctx->total[1] << 3;
  uStack24 = (uchar)(uVar2 >> 0x18);
  uStack23 = (undefined)(uVar2 >> 0x10);
  uStack22 = (ushort)(uVar2 >> 8) & 0xff | (ushort)((uVar2 | uVar1 >> 0x1d) << 8);
  msglen[0] = (uchar)((uVar1 << 3) >> 0x18);
  msglen[1] = (uchar)((uVar1 << 3) >> 0x10);
  msglen._2_2_ = (ushort)((uVar1 << 0x13) >> 0x18) | (ushort)(uVar1 << 0xb);
  if ((uVar1 & 0x3f) < 0x38) {
    iVar3 = 0x38;
  }
  else {
    iVar3 = 0x78;
  }
  mbedtls_sha1_update(ctx,sha1_padding,iVar3 - (uVar1 & 0x3f));
  mbedtls_sha1_update(ctx,&uStack24,8);
  *output = *(uchar *)((int)ctx->state + 3);
  output[1] = (uchar)*(undefined2 *)((int)ctx->state + 2);
  output[2] = (uchar)(ctx->state[0] >> 8);
  output[3] = (uchar)ctx->state[0];
  output[4] = *(uchar *)((int)ctx->state + 7);
  output[5] = (uchar)*(undefined2 *)((int)ctx->state + 6);
  output[6] = (uchar)(ctx->state[1] >> 8);
  output[7] = (uchar)ctx->state[1];
  output[8] = *(uchar *)((int)ctx->state + 0xb);
  output[9] = (uchar)*(undefined2 *)((int)ctx->state + 10);
  output[10] = (uchar)(ctx->state[2] >> 8);
  output[0xb] = (uchar)ctx->state[2];
  output[0xc] = *(uchar *)((int)ctx->state + 0xf);
  output[0xd] = (uchar)*(undefined2 *)((int)ctx->state + 0xe);
  output[0xe] = (uchar)(ctx->state[3] >> 8);
  output[0xf] = (uchar)ctx->state[3];
  output[0x10] = *(uchar *)((int)ctx->state + 0x13);
  output[0x11] = (uchar)*(undefined2 *)((int)ctx->state + 0x12);
  output[0x12] = (uchar)(ctx->state[4] >> 8);
  output[0x13] = (uchar)ctx->state[4];
  return;
}



void mbedtls_sha1(uchar *input,size_t ilen,uchar *output)

{
  undefined auStack108 [4];
  mbedtls_sha1_context ctx;
  
  mbedtls_sha1_init((mbedtls_sha1_context *)auStack108);
  mbedtls_sha1_starts((mbedtls_sha1_context *)auStack108);
  mbedtls_sha1_update((mbedtls_sha1_context *)auStack108,input,ilen);
  mbedtls_sha1_finish((mbedtls_sha1_context *)auStack108,output);
  mbedtls_sha1_free((mbedtls_sha1_context *)auStack108);
  return;
}



mbedtls_ssl_ciphersuite_t * mbedtls_ssl_ciphersuite_from_id(int ciphersuite)

{
  mbedtls_ssl_ciphersuite_t *pmVar1;
  
  pmVar1 = ciphersuite_definitions;
  while( true ) {
    if (pmVar1->id == 0) {
      return (mbedtls_ssl_ciphersuite_t *)0x0;
    }
    if (pmVar1->id == ciphersuite) break;
    pmVar1 = pmVar1 + 1;
  }
  return pmVar1;
}



int * mbedtls_ssl_list_ciphersuites(void)

{
  int *piVar1;
  int *piVar2;
  mbedtls_ssl_ciphersuite_t *pmVar3;
  int ciphersuite;
  
  if (supported_init == 0) {
    piVar1 = supported_ciphersuites;
    piVar2 = ciphersuite_preference;
    while ((ciphersuite = *piVar2, ciphersuite != 0 && (piVar1 < supported_ciphersuites + 5))) {
      pmVar3 = mbedtls_ssl_ciphersuite_from_id(ciphersuite);
      if (pmVar3 != (mbedtls_ssl_ciphersuite_t *)0x0) {
        *piVar1 = ciphersuite;
        piVar1 = piVar1 + 1;
      }
      piVar2 = piVar2 + 1;
    }
    *piVar1 = 0;
    supported_init = 1;
  }
  return supported_ciphersuites;
}



char * mbedtls_ssl_get_ciphersuite_name(int ciphersuite_id)

{
  mbedtls_ssl_ciphersuite_t *pmVar1;
  char *pcVar2;
  
  pmVar1 = mbedtls_ssl_ciphersuite_from_id(ciphersuite_id);
  if (pmVar1 == (mbedtls_ssl_ciphersuite_t *)0x0) {
    pcVar2 = "unknown";
  }
  else {
    pcVar2 = pmVar1->name;
  }
  return pcVar2;
}



mbedtls_pk_type_t mbedtls_ssl_get_ciphersuite_sig_pk_alg(mbedtls_ssl_ciphersuite_t *info)

{
  mbedtls_pk_type_t mVar1;
  uint uVar2;
  
  if (info->key_exchange < MBEDTLS_KEY_EXCHANGE_ECJPAKE) {
    uVar2 = 1 << ((uint)info->key_exchange & 0x1f);
    mVar1 = MBEDTLS_PK_RSA;
    if (((uVar2 & 0x8e) == 0) && (mVar1 = MBEDTLS_PK_ECKEY, (uVar2 & 0x600) == 0)) {
      return (mbedtls_pk_type_t)(((uVar2 & 0x10) != 0) << 2);
    }
  }
  else {
    mVar1 = MBEDTLS_PK_NONE;
  }
  return mVar1;
}



mbedtls_pk_context * mbedtls_ssl_own_key(mbedtls_ssl_context *ssl)

{
  mbedtls_ssl_key_cert *pmVar1;
  
  if (((ssl->handshake != (mbedtls_ssl_handshake_params *)0x0) &&
      (pmVar1 = ssl->handshake->key_cert, pmVar1 != (mbedtls_ssl_key_cert *)0x0)) ||
     (pmVar1 = ssl->conf->key_cert, pmVar1 != (mbedtls_ssl_key_cert *)0x0)) {
    pmVar1 = (mbedtls_ssl_key_cert *)pmVar1->key;
  }
  return (mbedtls_pk_context *)pmVar1;
}



size_t mbedtls_ssl_hs_hdr_len(void)

{
  int in_a0;
  
  if ((*(ushort *)(in_a0 + 0x74) & 2) != 0) {
    return 0xc;
  }
  return 4;
}



// WARNING: Type propagation algorithm not settling

int mbedtls_ssl_handshake_client_step(mbedtls_ssl_context *ssl)

{
  uchar uVar1;
  mbedtls_key_exchange_type_t mVar2;
  byte bVar3;
  byte bVar4;
  byte bVar5;
  byte bVar6;
  bool bVar7;
  uchar *puVar8;
  uchar *puVar9;
  uchar uVar10;
  uint ret;
  mbedtls_ssl_session *pmVar11;
  size_t __n;
  mbedtls_x509_crt *pmVar12;
  mbedtls_pk_context *pk;
  size_t len;
  mbedtls_md_type_t md_alg;
  int line;
  int line_00;
  char *format;
  uint __n_00;
  size_t sVar13;
  uchar *buf;
  int *piVar14;
  undefined *puVar15;
  mbedtls_ssl_config *pmVar16;
  mbedtls_ssl_key_cert *pmVar17;
  uchar *buf_00;
  ushort *puVar18;
  byte *buf_01;
  mbedtls_ssl_handshake_params *pmVar19;
  uint size;
  mbedtls_ssl_ciphersuite_t *ciphersuite_info;
  uchar *puVar20;
  uint uVar21;
  byte *pbVar22;
  uchar *puVar23;
  mbedtls_ssl_transform *pmVar24;
  char **ppcVar25;
  uchar *ver;
  byte *buf_02;
  uchar *puVar26;
  size_t local_74;
  int major_ver;
  int minor_ver;
  
  if (ssl->state == 0x10) {
    return -0x7100;
  }
  if (ssl->handshake == (mbedtls_ssl_handshake_params *)0x0) {
    return -0x7100;
  }
  mbedtls_debug_print_msg(ssl,2,"file1",0xccf,"client state: %d");
  ret = mbedtls_ssl_flush_output(ssl);
  if (ret != 0) {
    return ret;
  }
  if ((((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) &&
      (ssl->handshake->retransmit_state == '\x01')) &&
     (line_00 = mbedtls_ssl_resend(ssl), line_00 != 0)) {
    return line_00;
  }
  if ((ssl->state == 0xc) && (ssl->handshake->new_session_ticket != 0)) {
    ssl->state = 0x11;
  }
  __n_00 = ssl->state;
  switch(__n_00) {
  case 0:
    ssl->state = 1;
    break;
  case 1:
    mbedtls_debug_print_msg(ssl,2,"file1",0x2cd,"=> write client hello");
    pmVar16 = ssl->conf;
    if (pmVar16->f_rng == (mbedtls_ssl_recv_t *)0x0) {
      mbedtls_debug_print_msg(ssl,1,"file1",0x2d1,"no RNG provided");
      return -0x7400;
    }
    ssl->major_ver = (uint)pmVar16->min_major_ver;
    ssl->minor_ver = (uint)pmVar16->min_minor_ver;
    if (pmVar16->max_major_ver == 0) {
      mbedtls_debug_print_msg
                (ssl,1,"file1",0x2e0,
                                  
                 "configured max major version is invalid, consider using mbedtls_ssl_config_defaults()"
                );
      return -0x7100;
    }
    ver = ssl->out_msg;
    mbedtls_ssl_write_version
              ((uint)pmVar16->max_major_ver,(uint)pmVar16->max_minor_ver,
               *(uint *)&pmVar16->field_0x74 >> 1 & 1,ver + 4);
    mbedtls_debug_print_msg
              (ssl,3,"file1",0x2f3,"client hello, max version: [%d:%d]",(uint)ver[4],(uint)ver[5]);
    pmVar16 = ssl->conf;
    pmVar19 = ssl->handshake;
    if ((((*(ushort *)&pmVar16->field_0x74 & 2) == 0) || (pmVar19->verify_cookie == (uchar *)0x0))
       && ((ret = (*pmVar16->f_rng)(pmVar16->p_rng,pmVar19->randbytes,4), ret != 0 ||
           (ret = (*ssl->conf->f_rng)(ssl->conf->p_rng,pmVar19->randbytes + 4,0x1c), ret != 0)))) {
      format = "ssl_generate_random";
      line_00 = 0x2f7;
    }
    else {
      memcpy(ver + 6,ssl->handshake->randbytes,0x20);
      mbedtls_debug_print_buf(ssl,3,"file1",0x2fc,"client hello, random bytes",ver + 6,0x20);
      pmVar11 = ssl->session_negotiate;
      len = pmVar11->id_len;
      if ((0x10 < len - 0x10) || (ssl->handshake->resume == 0)) {
        len = 0;
      }
      if ((pmVar11->ticket != (uchar *)0x0) && (pmVar11->ticket_len != 0)) {
        line_00 = (*ssl->conf->f_rng)(ssl->conf->p_rng,pmVar11->id,0x20);
        if (line_00 != 0) {
          return line_00;
        }
        len = 0x20;
        ssl->session_negotiate->id_len = 0x20;
      }
      ver[0x26] = (uchar)len;
      sVar13 = 0;
      while (len != sVar13) {
        ver[sVar13 + 0x27] = ssl->session_negotiate->id[sVar13];
        sVar13 = sVar13 + 1;
      }
      puVar20 = ver + 0x27 + len;
      mbedtls_debug_print_msg(ssl,3,"file1",0x331,"client hello, session id len.: %d",len);
      mbedtls_debug_print_buf(ssl,3,"file1",0x332,"client hello, session id",ver + 0x27,len);
      buf_00 = puVar20;
      if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
        buf_00 = puVar20 + 1;
        buf = ssl->handshake->verify_cookie;
        if (buf == (uchar *)0x0) {
          mbedtls_debug_print_msg(ssl,3,"file1",0x33c,"no verify cookie to send");
          *puVar20 = '\0';
        }
        else {
          mbedtls_debug_print_buf
                    (ssl,3,"file1",0x343,"client hello, cookie",buf,
                     (uint)ssl->handshake->verify_cookie_len);
          *puVar20 = ssl->handshake->verify_cookie_len;
          memcpy(buf_00,ssl->handshake->verify_cookie,(uint)ssl->handshake->verify_cookie_len);
          buf_00 = buf_00 + ssl->handshake->verify_cookie_len;
        }
      }
      piVar14 = ssl->conf->ciphersuite_list[ssl->minor_ver];
      line_00 = 0;
      puVar20 = buf_00 + 2;
      while (*piVar14 != 0) {
        ciphersuite_info = mbedtls_ssl_ciphersuite_from_id(*piVar14);
        buf = puVar20;
        if ((((ciphersuite_info != (mbedtls_ssl_ciphersuite_t *)0x0) &&
             (pmVar16 = ssl->conf,
             ciphersuite_info->min_minor_ver <= (int)(uint)pmVar16->max_minor_ver)) &&
            ((int)(uint)pmVar16->min_minor_ver <= ciphersuite_info->max_minor_ver)) &&
           (((*(ushort *)&pmVar16->field_0x74 & 2) == 0 || ((ciphersuite_info->flags & 4) == 0)))) {
          mbedtls_debug_print_msg
                    (ssl,3,"file1",0x375,"client hello, add ciphersuite: %04x",*piVar14);
          line_00 = line_00 + 1;
          buf = puVar20 + 2;
          *puVar20 = (uchar)((uint)*piVar14 >> 8);
          puVar20[1] = (uchar)*piVar14;
        }
        piVar14 = piVar14 + 1;
        puVar20 = buf;
      }
      puVar20[1] = -1;
      *puVar20 = '\0';
      *buf_00 = (uchar)(line_00 + 1U >> 7);
      buf_00[1] = (char)(line_00 + 1U) * '\x02';
      mbedtls_debug_print_msg(ssl,3,"file1",0x396,"client hello, got %d ciphersuites");
      mbedtls_debug_print_msg(ssl,3,"file1",0x3b5,"client hello, compress len.: %d",1);
      mbedtls_debug_print_msg(ssl,3,"file1",0x3b7,"client hello, compress alg.: %d",0);
      puVar20[2] = '\x01';
      puVar20[3] = '\0';
      buf_00 = puVar20 + 4;
      buf = puVar20 + 6;
      puVar23 = (uchar *)0x0;
      if (ssl->hostname != (char *)0x0) {
        puVar8 = ssl->out_msg;
        mbedtls_debug_print_msg(ssl,3,"file1",0x48,"client hello, adding server name extension: %s")
        ;
        __n = strlen(ssl->hostname);
        if ((puVar8 + 0x4000 < buf) ||
           (puVar23 = (uchar *)(__n + 9), puVar8 + 0x4000 + -(int)buf < puVar23)) {
          mbedtls_debug_print_msg(ssl,1,"file1",0x4e,"buffer too small");
          puVar23 = (uchar *)0x0;
        }
        else {
          puVar20[8] = (uchar)(__n + 5 >> 8);
          uVar10 = (uchar)__n;
          puVar20[9] = uVar10 + '\x05';
          puVar20[10] = (uchar)(__n + 3 >> 8);
          puVar20[0xb] = uVar10 + '\x03';
          puVar20[6] = '\0';
          puVar20[7] = '\0';
          puVar20[0xc] = '\0';
          puVar20[0xd] = (uchar)(__n >> 8);
          puVar20[0xe] = uVar10;
          memcpy(puVar20 + 0xf,ssl->hostname,__n);
        }
      }
      line_00 = 0;
      if (ssl->conf->max_minor_ver == '\x03') {
        puVar8 = ssl->out_msg;
        mbedtls_debug_print_msg
                  (ssl,3,"file1",0xb2,"client hello, adding signature_algorithms extension");
        piVar14 = ssl->conf->sig_hashes;
        line_00 = 0;
        while (*(int *)(line_00 * 2 + (int)piVar14) != 0) {
          line_00 = line_00 + 2;
        }
        puVar9 = puVar23 + 2 + (int)buf_00;
        if ((puVar8 + 0x4000 < puVar9) || (puVar8 + 0x4000 + -(int)puVar9 < (uchar *)(line_00 + 6)))
        {
          mbedtls_debug_print_msg(ssl,1,"file1",0xc0,"buffer too small");
          line_00 = 0;
        }
        else {
          puVar8 = puVar9 + 6;
          line_00 = 0;
          while( true ) {
            line = *(int *)(line_00 * 2 + (int)piVar14);
            if (line == 0) break;
            uVar10 = mbedtls_ssl_hash_from_md_alg(line);
            *puVar8 = uVar10;
            puVar8[1] = '\x01';
            puVar8 = puVar8 + 2;
            line_00 = line_00 + 2;
          }
          puVar9[1] = '\r';
          puVar9[3] = (uchar)line_00 + '\x02';
          *puVar9 = '\0';
          puVar9[2] = (uchar)((uint)(line_00 + 2) >> 8);
          puVar9[4] = (uchar)((uint)line_00 >> 8);
          puVar9[5] = (uchar)line_00;
          line_00 = line_00 + 6;
        }
      }
      puVar23 = puVar23 + line_00;
      line_00 = 0;
      if ((*(ushort *)&ssl->conf->field_0x74 & 0x1c0) != 0) {
        puVar9 = ssl->out_msg;
        puVar8 = buf_00 + (int)(puVar23 + 2);
        mbedtls_debug_print_msg
                  (ssl,3,"file1",0x1b8,"client hello, adding max_fragment_length extension");
        if ((puVar9 + 0x4000 < puVar8) || (puVar9 + 0x4000 + -(int)puVar8 < &DAT_00000005)) {
          mbedtls_debug_print_msg(ssl,1,"file1",0x1bc,"buffer too small");
          line_00 = 0;
        }
        else {
          *puVar8 = '\0';
          puVar8[1] = '\x01';
          puVar8[2] = '\0';
          puVar8[3] = '\x01';
          puVar8[4] = (byte)(*(uint *)&ssl->conf->field_0x74 >> 6) & 7;
          line_00 = 5;
        }
      }
      puVar23 = puVar23 + line_00;
      buf_02 = (byte *)0x0;
      if (ssl->conf->alpn_list != (char **)0x0) {
        puVar8 = ssl->out_msg;
        mbedtls_debug_print_msg(ssl,3,"file1",0x26c,"client hello, adding alpn extension");
        ppcVar25 = ssl->conf->alpn_list;
        while (*ppcVar25 != (char *)0x0) {
          __n = strlen(*ppcVar25);
          buf_02 = buf_02 + (__n & 0xff) + 1;
          ppcVar25 = ppcVar25 + 1;
        }
        puVar9 = buf_00 + (int)(puVar23 + 2);
        if ((puVar8 + 0x4000 < puVar9) || (puVar8 + 0x4000 + -(int)puVar9 < buf_02 + 6)) {
          mbedtls_debug_print_msg(ssl,1,"file1",0x273,"buffer too small");
          buf_02 = (byte *)0x0;
        }
        else {
          *puVar9 = '\0';
          puVar9[1] = '\x10';
          buf_02 = puVar9 + 6;
          ppcVar25 = ssl->conf->alpn_list;
          while (*ppcVar25 != (char *)0x0) {
            __n = strlen(*ppcVar25);
            *buf_02 = (byte)__n;
            memcpy(buf_02 + 1,*ppcVar25,__n & 0xff);
            ppcVar25 = ppcVar25 + 1;
            buf_02 = buf_02 + (uint)*buf_02 + 1;
          }
          buf_02 = buf_02 + -(int)puVar9;
          puVar9[4] = (uchar)((uint)(buf_02 + -6) >> 8);
          puVar9[5] = (char)buf_02 + -6;
          puVar9[2] = (uchar)((uint)(buf_02 + -4) >> 8);
          puVar9[3] = (char)buf_02 + -4;
        }
      }
      puVar8 = (uchar *)0x0;
      if ((*(ushort *)&ssl->conf->field_0x74 & 0x200) != 0) {
        puVar26 = ssl->out_msg;
        puVar9 = buf_00 + (int)(buf_02 + (int)puVar23 + 2);
        __n = ssl->session_negotiate->ticket_len;
        mbedtls_debug_print_msg(ssl,3,"file1",0x23f,"client hello, adding session ticket extension")
        ;
        if ((puVar26 + 0x4000 < puVar9) ||
           (puVar8 = (uchar *)(__n + 4), puVar26 + 0x4000 + -(int)puVar9 < puVar8)) {
          mbedtls_debug_print_msg(ssl,1,"file1",0x243,"buffer too small");
          puVar8 = (uchar *)0x0;
        }
        else {
          puVar9[1] = '#';
          *puVar9 = '\0';
          puVar9[2] = (uchar)(__n >> 8);
          puVar9[3] = (uchar)__n;
          if ((ssl->session_negotiate->ticket == (uchar *)0x0) || (__n == 0)) {
            puVar8 = &DAT_00000004;
          }
          else {
            mbedtls_debug_print_msg(ssl,3,"file1",0x254,"sending session ticket of length %d",__n);
            memcpy(puVar9 + 4,ssl->session_negotiate->ticket,__n);
          }
        }
      }
      puVar8 = puVar8 + (int)(buf_02 + (int)puVar23);
      mbedtls_debug_print_msg(ssl,3,"file1",0x3ff,"client hello, total extension length: %d",puVar8)
      ;
      if (puVar8 != (uchar *)0x0) {
        puVar20[4] = (uchar)((uint)puVar8 >> 8);
        puVar20[5] = (uchar)puVar8;
        buf_00 = buf + (int)puVar8;
      }
      ssl->out_msgtype = 0x16;
      *(uchar **)&ssl->out_msglen = buf_00 + -(int)ver;
      *ssl->out_msg = '\x01';
      ssl->state = ssl->state + 1;
      if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
        mbedtls_ssl_send_flight_completed(ssl);
      }
      ret = mbedtls_ssl_write_record(ssl);
      if (ret == 0) {
        format = "<= write client hello";
        line_00 = 0x419;
        goto LAB_2306920e;
      }
      format = "mbedtls_ssl_write_record";
      line_00 = 0x415;
    }
    goto LAB_230690ee;
  case 2:
    mbedtls_debug_print_msg(ssl,2,"file1",0x582,"=> parse server hello");
    buf_02 = ssl->in_msg;
    ret = mbedtls_ssl_read_record(ssl);
    if (ret == 0) {
      if (ssl->in_msgtype == 0x16) {
        if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
          if (*buf_02 == 3) {
            mbedtls_debug_print_msg(ssl,2,"file1",0x5a9,"received hello verify request");
            mbedtls_debug_print_msg(ssl,2,"file1",0x5aa,"<= parse server hello");
            len = mbedtls_ssl_hs_hdr_len();
            ver = ssl->in_msg + len;
            mbedtls_debug_print_msg(ssl,2,"file1",0x52e,"=> parse hello verify request");
            mbedtls_debug_print_buf(ssl,3,"file1",0x536,"server version",ver,2);
            mbedtls_ssl_read_version
                      ((int *)&local_74,&major_ver,*(uint *)&ssl->conf->field_0x74 >> 1 & 1,ver);
            if (((((int)local_74 < 3) || (major_ver < 2)) ||
                ((int)(uint)ssl->conf->max_major_ver < (int)local_74)) ||
               ((int)(uint)ssl->conf->max_minor_ver < major_ver)) {
              mbedtls_debug_print_msg(ssl,1,"file1",0x543,"bad server version");
              goto LAB_2306935a;
            }
            buf_00 = ver + 3;
            bVar3 = ver[2];
            __n_00 = (uint)bVar3;
            mbedtls_debug_print_buf(ssl,3,"file1",0x54c,"cookie",buf_00,__n_00);
            if ((int)(ssl->in_msg + (ssl->in_msglen - (int)buf_00)) < (int)__n_00) {
              mbedtls_debug_print_msg
                        (ssl,1,"file1",0x551,"cookie length does not match incoming message size");
              mbedtls_ssl_send_alert_message(ssl,'\x02','2');
              return -0x7980;
            }
            vPortFree(ssl->handshake->verify_cookie);
            pmVar19 = ssl->handshake;
            ver = (uchar *)mycalloc(1,__n_00);
            pmVar19->verify_cookie = ver;
            ver = ssl->handshake->verify_cookie;
            if (ver == (uchar *)0x0) {
              mbedtls_debug_print_msg(ssl,1,"file1",0x55c,"alloc failed (%d bytes)",__n_00);
              return -0x7f00;
            }
            memcpy(ver,buf_00,__n_00);
            ssl->handshake->verify_cookie_len = bVar3;
            ssl->state = 1;
            mbedtls_ssl_reset_checksum(ssl);
            mbedtls_ssl_recv_flight_completed(ssl);
            format = "<= parse hello verify request";
            line_00 = 0x569;
            goto LAB_2306920e;
          }
          vPortFree(ssl->handshake->verify_cookie);
          ssl->handshake->verify_cookie = (uchar *)0x0;
          ssl->handshake->verify_cookie_len = '\0';
        }
        len = mbedtls_ssl_hs_hdr_len();
        if ((ssl->in_hslen < len + 0x26) || (bVar3 = *buf_02, bVar3 != 2)) {
          line_00 = 0x5ba;
        }
        else {
          buf_02 = buf_02 + len;
          mbedtls_debug_print_buf(ssl,3,"file1",0x5cb,"server hello, version",buf_02,2);
          mbedtls_ssl_read_version
                    (&ssl->major_ver,&ssl->minor_ver,*(uint *)&ssl->conf->field_0x74 >> 1 & 1,buf_02
                    );
          pmVar16 = ssl->conf;
          if (((ssl->major_ver < (int)(uint)pmVar16->min_major_ver) ||
              (ssl->minor_ver < (int)(uint)pmVar16->min_minor_ver)) ||
             (((int)(uint)pmVar16->max_major_ver < ssl->major_ver ||
              ((int)(uint)pmVar16->max_minor_ver < ssl->minor_ver)))) {
            mbedtls_debug_print_msg
                      (ssl,1,"file1",0x5d8,
                       "server version out of bounds -  min: [%d:%d], server: [%d:%d], max: [%d:%d]"
                      );
LAB_2306935a:
            mbedtls_ssl_send_alert_message(ssl,'\x02','F');
            return -0x6e80;
          }
          mbedtls_debug_print_msg
                    (ssl,3,"file1",0x5e5,"server hello, current time: %lu",
                     (uint)buf_02[4] << 8 |
                     (uint)buf_02[2] << 0x18 | (uint)buf_02[3] << 0x10 | (uint)buf_02[5]);
          memcpy(ssl->handshake->randbytes + 0x20,buf_02 + 2,0x20);
          bVar4 = buf_02[0x22];
          size = (uint)bVar4;
          mbedtls_debug_print_buf(ssl,3,"file1",0x5ec,"server hello, random bytes",buf_02 + 2,0x20);
          if (bVar4 < 0x21) {
            __n_00 = ssl->in_hslen;
            len = mbedtls_ssl_hs_hdr_len();
            line_00 = len + size;
            if (line_00 + 0x27U < __n_00) {
              uVar21 = (uint)CONCAT11((buf_02 + size)[0x26],(buf_02 + size)[0x27]);
              if ((uVar21 - 1 <= (uint)bVar3) || (__n_00 != line_00 + uVar21 + 0x28)) {
                line_00 = 0x5fc;
                goto LAB_2306948e;
              }
            }
            else {
              uVar21 = 0;
              if (__n_00 != line_00 + 0x26U) {
                line_00 = 0x606;
                goto LAB_2306948e;
              }
            }
            __n_00 = (uint)CONCAT11((buf_02 + size)[0x23],(buf_02 + size)[0x24]);
            if (buf_02[size + 0x25] != 0) {
              mbedtls_debug_print_msg(ssl,1,"file1",0x621,"server hello, bad compression: %d");
              return -0x7080;
            }
            pmVar24 = ssl->transform_negotiate;
            ciphersuite_info = mbedtls_ssl_ciphersuite_from_id(__n_00);
            pmVar24->ciphersuite_info = ciphersuite_info;
            ciphersuite_info = ssl->transform_negotiate->ciphersuite_info;
            if (ciphersuite_info == (mbedtls_ssl_ciphersuite_t *)0x0) {
              format = "ciphersuite info for %04x not found";
              line_00 = 0x62c;
LAB_2306966a:
              mbedtls_debug_print_msg(ssl,1,"file1",line_00,format,__n_00);
              return -0x7100;
            }
            mbedtls_ssl_optimize_checksum(ssl,ciphersuite_info);
            mbedtls_debug_print_msg(ssl,3,"file1",0x632,"server hello, session id len.: %d",size);
            buf_01 = buf_02 + 0x23;
            mbedtls_debug_print_buf(ssl,3,"file1",0x633,"server hello, session id",buf_01,size);
            if ((((ssl->handshake->resume == 0) || (bVar4 == 0)) ||
                (pmVar11 = ssl->session_negotiate, __n_00 != pmVar11->ciphersuite)) ||
               (((pmVar11->compression != 0 || (size != pmVar11->id_len)) ||
                (line_00 = memcmp(pmVar11->id,buf_01,size), line_00 != 0)))) {
              ssl->state = ssl->state + 1;
              ssl->handshake->resume = 0;
              ssl->session_negotiate->ciphersuite = __n_00;
              ssl->session_negotiate->compression = 0;
              ssl->session_negotiate->id_len = size;
              memcpy(ssl->session_negotiate->id,buf_01,size);
            }
            else {
              ssl->state = 0xc;
              line_00 = mbedtls_ssl_derive_keys(ssl);
              if (line_00 != 0) {
                mbedtls_debug_print_ret(ssl,1,"file1",0x651,"mbedtls_ssl_derive_keys",line_00);
                return line_00;
              }
            }
            if (ssl->handshake->resume == 0) {
              puVar15 = &UNK_2308c4d8;
            }
            else {
              puVar15 = (undefined *)0x230873f4;
            }
            mbedtls_debug_print_msg(ssl,3,"file1",0x657,"%s session has been resumed",puVar15);
            mbedtls_debug_print_msg
                      (ssl,3,"file1",0x659,"server hello, chosen ciphersuite: %04x",__n_00);
            mbedtls_debug_print_msg
                      (ssl,3,"file1",0x65a,"server hello, compress alg.: %d",
                       (uint)buf_02[size + 0x25]);
            ciphersuite_info = mbedtls_ssl_ciphersuite_from_id(ssl->session_negotiate->ciphersuite);
            if (ciphersuite_info == (mbedtls_ssl_ciphersuite_t *)0x0) {
              line_00 = 0x664;
            }
            else {
              mbedtls_debug_print_msg
                        (ssl,3,"file1",0x668,"server hello, chosen ciphersuite: %s",
                         ciphersuite_info->name);
              piVar14 = ssl->conf->ciphersuite_list[ssl->minor_ver];
              do {
                line_00 = *piVar14;
                if (line_00 == 0) {
                  line_00 = 0x66f;
                  goto LAB_2306948e;
                }
                piVar14 = piVar14 + 1;
              } while (line_00 != ssl->session_negotiate->ciphersuite);
              ssl->session_negotiate->compression = 0;
              puVar18 = (ushort *)(buf_02 + size + 0x28);
              mbedtls_debug_print_msg
                        (ssl,2,"file1",0x687,"server hello, total extension length: %d",uVar21);
              do {
                if (uVar21 == 0) {
                  if ((ssl->secure_renegotiation == 0) &&
                     ((*(ushort *)&ssl->conf->field_0x74 & 0x30) == 0x20)) {
                    line_00 = -0x430;
                    line = 0x720;
LAB_23069934:
                    mbedtls_debug_print_msg
                              (ssl,1,"file1",line,(char *)((int)&PTR_caseD_e_2308d000 + line_00));
                    line_00 = mbedtls_ssl_send_fatal_handshake_failure(ssl);
                    if (line_00 == 0) {
                      return -0x7980;
                    }
                    return line_00;
                  }
                  format = "<= parse server hello";
                  line_00 = 0x743;
                  goto LAB_2306920e;
                }
                __n_00 = (uint)(*puVar18 >> 8) | ((uint)*puVar18 & 0xff) << 8;
                size = ((uint)puVar18[1] & 0xff) << 8 | (uint)(puVar18[1] >> 8);
                if (uVar21 < size + 4) {
                  line_00 = 0x692;
                  goto LAB_2306948e;
                }
                if (__n_00 == 0x10) {
                  mbedtls_debug_print_msg(ssl,3,"file1",0x703,"found alpn extension");
                  ppcVar25 = ssl->conf->alpn_list;
                  if (ppcVar25 == (char **)0x0) {
                    return -0x7980;
                  }
                  if (size < 4) {
                    return -0x7980;
                  }
                  if (((uint)(puVar18[2] >> 8) | ((uint)puVar18[2] & 0xff) << 8) != size - 2) {
                    return -0x7980;
                  }
                  __n_00 = (uint)*(byte *)(puVar18 + 3);
                  if (__n_00 != size - 3) {
                    return -0x7980;
                  }
                  while( true ) {
                    if (*ppcVar25 == (char *)0x0) {
                      return -0x7980;
                    }
                    __n = strlen(*ppcVar25);
                    if ((__n_00 == __n) &&
                       (line_00 = memcmp((byte *)((int)puVar18 + 7),*ppcVar25,__n_00), line_00 == 0)
                       ) break;
                    ppcVar25 = ppcVar25 + 1;
                  }
                  ssl->alpn_chosen = *ppcVar25;
                }
                else {
                  if (__n_00 < 0x11) {
                    if (__n_00 == 1) {
                      mbedtls_debug_print_msg
                                (ssl,3,"file1",0x6a6,"found max_fragment_length extension");
                      if ((*(ushort *)&ssl->conf->field_0x74 & 0x1c0) == 0) {
                        return -0x7980;
                      }
                      if (size != 1) {
                        return -0x7980;
                      }
                      if ((uint)*(byte *)(puVar18 + 2) != (*(uint *)&ssl->conf->field_0x74 >> 6 & 7)
                         ) {
                        return -0x7980;
                      }
                    }
                    else {
LAB_230698de:
                      mbedtls_debug_print_msg
                                (ssl,3,"file1",0x70d,"unknown extension found: %d (ignoring)");
                    }
                  }
                  else {
                    if (__n_00 == 0x23) {
                      mbedtls_debug_print_msg(ssl,3,"file1",0x6da,"found session_ticket extension");
                      if ((*(ushort *)&ssl->conf->field_0x74 & 0x200) == 0) {
                        return -0x7980;
                      }
                      if (size != 0) {
                        return -0x7980;
                      }
                      ssl->handshake->new_session_ticket = 1;
                    }
                    else {
                      if (__n_00 != 0xff01) goto LAB_230698de;
                      mbedtls_debug_print_msg(ssl,3,"file1",0x699,"found renegotiation extension");
                      if ((size != 1) || (*(byte *)(puVar18 + 2) != 0)) {
                        line_00 = -0x4d8;
                        line = 0x43c;
                        goto LAB_23069934;
                      }
                      ssl->secure_renegotiation = 1;
                    }
                  }
                }
                line_00 = uVar21 - size;
                uVar21 = line_00 - 4;
                puVar18 = (ushort *)((int)puVar18 + size + 4);
              } while (2 < line_00 - 5U);
              line_00 = 0x715;
            }
          }
          else {
            line_00 = 0x5f0;
          }
        }
LAB_2306948e:
        mbedtls_debug_print_msg(ssl,1,"file1",line_00,"bad server hello message");
        return -0x7980;
      }
      format = "bad server hello message";
      line_00 = 0x5a0;
LAB_2306926a:
      line = 1;
LAB_23069270:
      mbedtls_debug_print_msg(ssl,line,"file1",line_00,format);
      return -0x7700;
    }
    format = "mbedtls_ssl_read_record";
    line_00 = 0x588;
    goto LAB_230690ee;
  case 3:
    __n_00 = mbedtls_ssl_parse_certificate(ssl);
    break;
  case 4:
    ciphersuite_info = ssl->transform_negotiate->ciphersuite_info;
    mbedtls_debug_print_msg(ssl,2,"file1",0x896,"=> parse server key exchange");
    if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA) {
      format = "<= skip parse server key exchange";
      line_00 = 0x89b;
LAB_23069ac2:
      mbedtls_debug_print_msg(ssl,2,"file1",line_00,format);
      line_00 = ssl->state + 1;
      __n_00 = ret;
      goto LAB_23069ad4;
    }
    ret = mbedtls_ssl_read_record(ssl);
    if (ret == 0) {
      if (ssl->in_msgtype == 0x16) {
        ver = ssl->in_msg;
        if (*ver == '\f') {
          len = mbedtls_ssl_hs_hdr_len();
          mbedtls_debug_print_buf
                    (ssl,3,"file1",0x8d6,"server key exchange",ver + len,ssl->in_hslen - len);
          line_00 = 0x91b;
          goto LAB_23069b94;
        }
        if ((ciphersuite_info->key_exchange & 0xfd) == 5) {
          ssl->record_read = 1;
          ssl->state = ssl->state + 1;
          format = "<= parse server key exchange";
          line_00 = 0x9d4;
          goto LAB_2306920e;
        }
        format = "bad server key exchange message";
        line_00 = 0x8d0;
      }
      else {
        format = "bad server key exchange message";
        line_00 = 0x8bf;
      }
      goto LAB_2306926a;
    }
    format = "mbedtls_ssl_read_record";
    line_00 = 0x8b9;
    goto LAB_230690ee;
  case 5:
    ciphersuite_info = ssl->transform_negotiate->ciphersuite_info;
    mbedtls_debug_print_msg(ssl,2,"file1",0x9fc,"=> parse certificate request");
    mVar2 = ciphersuite_info->key_exchange;
    if (((byte)(mVar2 + ~MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA) < 4) ||
       (mVar2 == MBEDTLS_KEY_EXCHANGE_ECJPAKE)) {
      format = "<= skip parse certificate request";
      line_00 = 0xa04;
      goto LAB_23069ac2;
    }
    if (ssl->record_read == 0) {
      line_00 = mbedtls_ssl_read_record(ssl);
      if (line_00 != 0) {
        line = 0xa0d;
        goto LAB_23069c12;
      }
      if (ssl->in_msgtype != 0x16) {
        format = "bad certificate request message";
        line_00 = 0xa13;
        goto LAB_2306926a;
      }
      ssl->record_read = 1;
    }
    ssl->client_auth = 0;
    ssl->state = ssl->state + 1;
    if (*ssl->in_msg == '\r') {
      ssl->client_auth = 1;
      puVar15 = (undefined *)0x230873f4;
    }
    else {
      puVar15 = &UNK_2308c4d8;
    }
    mbedtls_debug_print_msg(ssl,3,"file1",0xa21,"got %s certificate request",puVar15);
    if (ssl->client_auth != 0) {
      ver = ssl->in_msg;
      ssl->record_read = 0;
      len = mbedtls_ssl_hs_hdr_len();
      buf_01 = (byte *)(uint)ver[len];
      buf_02 = buf_01 + len;
      if ((byte *)ssl->in_hslen < buf_02 + 2) {
        line_00 = 0xa48;
LAB_23069cc2:
        mbedtls_debug_print_msg(ssl,1,"file1",line_00,"bad certificate request message");
        return -0x7a80;
      }
      if (ssl->minor_ver == 3) {
        uVar10 = ver[(int)(buf_02 + 1)];
        uVar1 = ver[(int)(buf_02 + 2)];
        pbVar22 = ver + (int)(buf_02 + 3);
        while (pbVar22 + -(int)(ver + (int)(buf_02 + 3)) < (byte *)(uint)CONCAT11(uVar10,uVar1)) {
          mbedtls_debug_print_msg
                    (ssl,3,"file1",0xa58,"Supported Signature Algorithm found: %d,%d",(uint)*pbVar22
                     ,(uint)pbVar22[1]);
          pbVar22 = pbVar22 + 2;
        }
        buf_01 = (byte *)(uint)CONCAT11(uVar10,uVar1) + (int)(buf_01 + 2);
        len = mbedtls_ssl_hs_hdr_len();
        if ((byte *)ssl->in_hslen < buf_01 + len + 2) {
          line_00 = 0xa60;
          goto LAB_23069cc2;
        }
      }
      len = mbedtls_ssl_hs_hdr_len();
      buf_01 = buf_01 + len;
      if ((byte *)ssl->in_hslen !=
          buf_01 + (uint)CONCAT11((ver + (int)buf_01)[1],(ver + (int)buf_01)[2]) + 3) {
        line_00 = 0xa6d;
        goto LAB_23069cc2;
      }
    }
    format = "<= parse certificate request";
    line_00 = 0xa72;
    goto LAB_2306920e;
  case 6:
    mbedtls_debug_print_msg(ssl,2,"file1",0xa81,"=> parse server hello done");
    if (ssl->record_read == 0) {
      line_00 = mbedtls_ssl_read_record(ssl);
      if (line_00 != 0) {
        line = 0xa87;
LAB_23069c12:
        mbedtls_debug_print_ret(ssl,1,"file1",line,"mbedtls_ssl_read_record",line_00);
        return line_00;
      }
      if (ssl->in_msgtype != 0x16) {
        format = "bad server hello done message";
        line_00 = 0xa8d;
        goto LAB_2306926a;
      }
    }
    pmVar16 = ssl->conf;
    ssl->record_read = 0;
    len = mbedtls_ssl_hs_hdr_len();
    if ((ssl->in_hslen != len) || (*ssl->in_msg != '\x0e')) {
      mbedtls_debug_print_msg(ssl,1,"file1",0xa96,"bad server hello done message");
      return -0x7b80;
    }
    ssl->state = ssl->state + 1;
    if ((*(ushort *)&pmVar16->field_0x74 & 2) != 0) {
      mbedtls_ssl_recv_flight_completed(ssl);
    }
    format = "<= parse server hello done";
    line_00 = 0xaa1;
LAB_2306920e:
    mbedtls_debug_print_msg(ssl,2,"file1",line_00,format);
    __n_00 = ret;
    break;
  case 7:
    __n_00 = mbedtls_ssl_write_certificate(ssl);
    break;
  case 8:
    ciphersuite_info = ssl->transform_negotiate->ciphersuite_info;
    mbedtls_debug_print_msg(ssl,2,"file1",0xaac,"=> write client key exchange");
    if (ciphersuite_info->key_exchange != MBEDTLS_KEY_EXCHANGE_RSA) {
      line_00 = 0xb91;
LAB_23069b94:
      mbedtls_debug_print_msg(ssl,1,"file1",line_00,"should never happen");
      return -0x6c00;
    }
    pmVar16 = ssl->conf;
    pmVar19 = ssl->handshake;
    line_00 = ssl->minor_ver;
    ver = pmVar19->premaster;
    mbedtls_ssl_write_version
              ((uint)pmVar16->max_major_ver,(uint)pmVar16->max_minor_ver,
               *(uint *)&pmVar16->field_0x74 >> 1 & 1,ver);
    bVar7 = line_00 != 0;
    ret = (*ssl->conf->f_rng)(ssl->conf->p_rng,pmVar19->premaster + 2,0x2e);
    line_00 = (uint)bVar7 * 2 + 4;
    if (ret == 0) {
      ssl->handshake->pmslen = 0x30;
      pmVar12 = ssl->session_negotiate->peer_cert;
      if (pmVar12 == (mbedtls_x509_crt *)0x0) {
        format = "certificate required";
        line_00 = 0x801;
        line = 2;
        goto LAB_23069270;
      }
      line = mbedtls_pk_can_do(&pmVar12->pk,MBEDTLS_PK_RSA);
      if (line == 0) {
        mbedtls_debug_print_msg(ssl,1,"file1",0x80b,"certificate key type mismatch");
        return -0x6d00;
      }
      ret = mbedtls_pk_encrypt(&ssl->session_negotiate->peer_cert->pk,ver,ssl->handshake->pmslen,
                               ssl->out_msg + line_00,(size_t *)&major_ver,0x4000 - line_00,
                               (anon_subr_int_void_ptr_uchar_ptr_size_t *)ssl->conf->f_rng,
                               ssl->conf->p_rng);
      if (ret == 0) {
        if (bVar7) {
          ssl->out_msg[4] = (uchar)((uint)major_ver >> 8);
          ssl->out_msg[5] = (uchar)major_ver;
          major_ver = major_ver + 2;
        }
        ssl->out_msglen = major_ver + 4;
        ssl->out_msgtype = 0x16;
        *ssl->out_msg = '\x10';
        ssl->state = ssl->state + 1;
        ret = mbedtls_ssl_write_record(ssl);
        if (ret == 0) {
          format = "<= write client key exchange";
          line_00 = 0xba1;
          goto LAB_2306920e;
        }
        format = "mbedtls_ssl_write_record";
        line_00 = 0xb9d;
      }
      else {
        format = "mbedtls_rsa_pkcs1_encrypt";
        line_00 = 0x815;
      }
    }
    else {
      format = "f_rng";
      line_00 = 0x7f9;
    }
    goto LAB_230690ee;
  case 9:
    ciphersuite_info = ssl->transform_negotiate->ciphersuite_info;
    local_74 = 0;
    mbedtls_debug_print_msg(ssl,2,"file1",0xbd2,"=> write certificate verify");
    ret = mbedtls_ssl_derive_keys(ssl);
    if (ret == 0) {
      mVar2 = ciphersuite_info->key_exchange;
      if (((byte)(mVar2 + ~MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA) < 4) ||
         (mVar2 == MBEDTLS_KEY_EXCHANGE_ECJPAKE)) {
        format = "<= skip write certificate verify";
        line_00 = 0xbe0;
      }
      else {
        if ((ssl->client_auth != 0) &&
           ((((pmVar19 = ssl->handshake, pmVar19 != (mbedtls_ssl_handshake_params *)0x0 &&
              (pmVar17 = pmVar19->key_cert, pmVar17 != (mbedtls_ssl_key_cert *)0x0)) ||
             (pmVar17 = ssl->conf->key_cert, pmVar17 != (mbedtls_ssl_key_cert *)0x0)) &&
            (pmVar17->cert != (mbedtls_x509_crt *)0x0)))) {
          pk = mbedtls_ssl_own_key(ssl);
          if (pk == (mbedtls_pk_context *)0x0) {
            mbedtls_debug_print_msg(ssl,1,"file1",0xbee,"got no private key for certificate");
            return -0x7600;
          }
          (*pmVar19->calc_verify)(ssl,(uchar *)&major_ver);
          if (ssl->minor_ver != 3) {
            line_00 = 0xc3d;
            goto LAB_23069b94;
          }
          md_alg = ssl->transform_negotiate->ciphersuite_info->mac;
          if (md_alg == MBEDTLS_MD_SHA384) {
            ssl->out_msg[4] = '\x05';
          }
          else {
            ssl->out_msg[4] = '\x04';
            md_alg = MBEDTLS_MD_SHA256;
          }
          pk = mbedtls_ssl_own_key(ssl);
          ver = ssl->out_msg;
          uVar10 = mbedtls_ssl_sig_from_pk(pk);
          ver[5] = uVar10;
          pk = mbedtls_ssl_own_key(ssl);
          ret = mbedtls_pk_sign(pk,md_alg,(uchar *)&major_ver,0,ssl->out_msg + 8,&local_74,
                                (anon_subr_int_void_ptr_uchar_ptr_size_t *)ssl->conf->f_rng,
                                ssl->conf->p_rng);
          if (ret == 0) {
            ssl->out_msg[6] = (uchar)(local_74 >> 8);
            ssl->out_msg[7] = (uchar)local_74;
            ssl->out_msglen = local_74 + 8;
            ssl->out_msgtype = 0x16;
            *ssl->out_msg = '\x0f';
            ssl->state = ssl->state + 1;
            ret = mbedtls_ssl_write_record(ssl);
            if (ret == 0) {
              format = "<= write certificate verify";
              line_00 = 0xc58;
              goto LAB_2306920e;
            }
            format = "mbedtls_ssl_write_record";
            line_00 = 0xc54;
          }
          else {
            format = "mbedtls_pk_sign";
            line_00 = 0xc45;
          }
          goto LAB_230690ee;
        }
        format = "<= skip write certificate verify";
        line_00 = 0xbe7;
      }
      goto LAB_23069ac2;
    }
    format = "mbedtls_ssl_derive_keys";
    line_00 = 0xbd6;
    goto LAB_230690ee;
  case 10:
    __n_00 = mbedtls_ssl_write_change_cipher_spec(ssl);
    break;
  case 0xb:
    __n_00 = mbedtls_ssl_write_finished(ssl);
    break;
  case 0xc:
    __n_00 = mbedtls_ssl_parse_change_cipher_spec(ssl);
    break;
  case 0xd:
    __n_00 = mbedtls_ssl_parse_finished(ssl);
    break;
  case 0xe:
    mbedtls_debug_print_msg(ssl,2,"file1",0xd3e,"handshake: done");
    line_00 = 0xf;
    __n_00 = ret;
LAB_23069ad4:
    ssl->state = line_00;
    break;
  case 0xf:
    mbedtls_ssl_handshake_wrapup(ssl);
    __n_00 = ret;
    break;
  default:
    format = "invalid state %d";
    line_00 = 0xd47;
    goto LAB_2306966a;
  case 0x11:
    mbedtls_debug_print_msg(ssl,2,"file1",0xc6c,"=> parse new session ticket");
    ret = mbedtls_ssl_read_record(ssl);
    if (ret == 0) {
      if (ssl->in_msgtype == 0x16) {
        ver = ssl->in_msg;
        if (*ver == '\x04') {
          __n_00 = ssl->in_hslen;
          len = mbedtls_ssl_hs_hdr_len();
          if (len + 6 <= __n_00) {
            buf_02 = ver + len;
            bVar3 = *buf_02;
            size = ((uint)*(ushort *)(buf_02 + 4) & 0xff) << 8 |
                   (uint)(*(ushort *)(buf_02 + 4) >> 8);
            bVar4 = buf_02[1];
            bVar5 = buf_02[2];
            bVar6 = buf_02[3];
            if (__n_00 != len + 6 + size) {
              line_00 = 0xc94;
              goto LAB_2306a270;
            }
            mbedtls_debug_print_msg(ssl,3,"file1",0xc98,"ticket length: %d",size);
            ssl->handshake->new_session_ticket = 0;
            ssl->state = 0xc;
            if (size == 0) {
              return 0;
            }
            buf_00 = ssl->session_negotiate->ticket;
            ver = buf_00 + ssl->session_negotiate->ticket_len;
            while (buf_00 != ver) {
              *buf_00 = '\0';
              buf_00 = buf_00 + 1;
            }
            vPortFree(ssl->session_negotiate->ticket);
            ssl->session_negotiate->ticket = (uchar *)0x0;
            ssl->session_negotiate->ticket_len = 0;
            ver = (uchar *)mycalloc(1,size);
            if (ver == (uchar *)0x0) {
              mbedtls_debug_print_msg(ssl,1,"file1",0xcad,"ticket alloc failed");
              return -0x7f00;
            }
            memcpy(ver,buf_02 + 6,size);
            ssl->session_negotiate->ticket = ver;
            ssl->session_negotiate->ticket_len = size;
            ssl->session_negotiate->ticket_lifetime =
                 (uint)bVar3 << 0x18 | (uint)bVar4 << 0x10 | (uint)bVar6 | (uint)bVar5 << 8;
            mbedtls_debug_print_msg(ssl,3,"file1",0xcbc,"ticket in use, discarding session id");
            format = "<= parse new session ticket";
            ssl->session_negotiate->id_len = 0;
            line_00 = 0xcbf;
            goto LAB_2306920e;
          }
        }
        line_00 = 0xc87;
LAB_2306a270:
        mbedtls_debug_print_msg(ssl,1,"file1",line_00,"bad new session ticket message");
        return -0x6e00;
      }
      format = "bad new session ticket message";
      line_00 = 0xc76;
      goto LAB_2306926a;
    }
    format = "mbedtls_ssl_read_record";
    line_00 = 0xc70;
LAB_230690ee:
    mbedtls_debug_print_ret(ssl,1,"file1",line_00,format,ret);
    __n_00 = ret;
  }
  return __n_00;
}



mbedtls_pk_context * mbedtls_ssl_own_key(mbedtls_ssl_context *ssl)

{
  mbedtls_ssl_key_cert *pmVar1;
  
  if (((ssl->handshake != (mbedtls_ssl_handshake_params *)0x0) &&
      (pmVar1 = ssl->handshake->key_cert, pmVar1 != (mbedtls_ssl_key_cert *)0x0)) ||
     (pmVar1 = ssl->conf->key_cert, pmVar1 != (mbedtls_ssl_key_cert *)0x0)) {
    pmVar1 = (mbedtls_ssl_key_cert *)pmVar1->key;
  }
  return (mbedtls_pk_context *)pmVar1;
}



// WARNING: Could not reconcile some variable overlaps

int mbedtls_ssl_handshake_server_step(mbedtls_ssl_context *ssl)

{
  byte bVar1;
  mbedtls_key_exchange_type_t mVar2;
  ushort uVar3;
  char cVar4;
  mbedtls_x509_crt *pmVar5;
  ushort *buf;
  uchar *__n;
  uchar *puVar6;
  mbedtls_ssl_handshake_params *pmVar7;
  mbedtls_ssl_ciphersuite_t *info;
  uchar message;
  mbedtls_md_type_t md_alg;
  mbedtls_pk_type_t type;
  int ret;
  int iVar8;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  size_t __n_00;
  undefined3 extraout_var_01;
  mbedtls_pk_context *ctx;
  size_t sVar9;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  ushort *puVar10;
  uint uVar11;
  int line;
  mbedtls_ssl_config *pmVar12;
  char *format;
  anon_subr_int_void_ptr_mbedtls_ssl_session_ptr_for_f_get_cache *paVar13;
  mbedtls_ssl_session *pmVar14;
  undefined *puVar15;
  uchar *buf_00;
  uchar *hash;
  uint sig_len;
  byte *pbVar16;
  byte *input;
  uint ilen;
  byte *buf_01;
  uint uVar17;
  byte *len;
  uint *puVar18;
  uchar *puVar19;
  size_t len_00;
  int *piVar20;
  int line_00;
  byte *pbVar21;
  uint uVar22;
  mbedtls_ssl_key_cert *pmVar23;
  uchar *puVar24;
  byte *pbVar25;
  byte *pbVar26;
  char **ppcVar27;
  mbedtls_ssl_key_cert *pmVar28;
  byte bStack236;
  byte bStack235;
  uchar ver [2];
  int major;
  int minor;
  undefined4 local_b4;
  mbedtls_ssl_session session;
  
  if ((ssl->state == 0x10) || (ssl->handshake == (mbedtls_ssl_handshake_params *)0x0)) {
    return -0x7100;
  }
  mbedtls_debug_print_msg(ssl,2,"file1",0xede,"server state: %d");
  ret = mbedtls_ssl_flush_output(ssl);
  if (ret != 0) {
    return ret;
  }
  if ((((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) &&
      (ssl->handshake->retransmit_state == '\x01')) &&
     (line_00 = mbedtls_ssl_resend(ssl), line_00 != 0)) {
    return line_00;
  }
  line_00 = ssl->state;
  switch(line_00) {
  case 0:
    ssl->state = 1;
    break;
  case 1:
    mbedtls_debug_print_msg(ssl,2,"file1",0x440,"=> parse client hello");
    line = mbedtls_ssl_fetch_input(ssl,5);
    if (line == 0) {
      input = ssl->in_hdr;
      len_00 = 5;
      if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
        len_00 = 0xd;
      }
      mbedtls_debug_print_buf(ssl,4,"file1",0x45f,"record header",input,len_00);
      mbedtls_debug_print_msg(ssl,3,"file1",0x46b,"client hello v3, message type: %d",(uint)*input);
      if (*input != 0x16) {
        ret = 0x46f;
        goto LAB_2306a59a;
      }
      mbedtls_debug_print_msg
                (ssl,3,"file1",0x474,"client hello v3, message len.: %d",
                 ((uint)*(ushort *)ssl->in_len & 0xff) << 8 | (uint)(*(ushort *)ssl->in_len >> 8));
      mbedtls_debug_print_msg
                (ssl,3,"file1",0x477,"client hello v3, protocol version: [%d:%d]",(uint)input[1],
                 (uint)input[2]);
      mbedtls_ssl_read_version((int *)ver,&major,*(uint *)&ssl->conf->field_0x74 >> 1 & 1,input + 1)
      ;
      if ((int)_ver < 3) {
        ret = 0x481;
        goto LAB_2306a59a;
      }
      if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
        hash = ssl->in_ctr;
        if ((*hash != '\0') || (hash[1] != '\0')) {
          ret = 0x491;
          goto LAB_2306a59a;
        }
        memcpy(ssl->out_ctr + 2,hash + 2,6);
      }
      ilen = ((uint)*(ushort *)ssl->in_len & 0xff) << 8 | (uint)(*(ushort *)ssl->in_len >> 8);
      if (0x4000 < ilen) {
        ret = 0x4b3;
        goto LAB_2306a59a;
      }
      ret = 5;
      if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
        ret = 0xd;
      }
      iVar8 = mbedtls_ssl_fetch_input(ssl,ret + ilen);
      if (iVar8 != 0) {
        format = "mbedtls_ssl_fetch_input";
        ret = 0x4b9;
        line_00 = iVar8;
        goto LAB_2306a528;
      }
      if ((*(ushort *)&ssl->conf->field_0x74 & 2) == 0) {
        ssl->in_left = 0;
      }
      else {
        ssl->next_record_offset = ilen + 0xd;
      }
      input = ssl->in_msg;
      mbedtls_debug_print_buf(ssl,4,"file1",0x4c8,"record contents",input,ilen);
      (*ssl->handshake->update_checksum)(ssl,input,ilen);
      sig_len = 4;
      if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
        sig_len = 0xc;
      }
      if (ilen < sig_len) {
        ret = 0x4d6;
        goto LAB_2306a59a;
      }
      mbedtls_debug_print_msg
                (ssl,3,"file1",0x4da,"client hello v3, handshake type: %d",(uint)*input);
      if (*input != 1) {
        ret = 0x4de;
        goto LAB_2306a59a;
      }
      mbedtls_debug_print_msg
                (ssl,3,"file1",0x4e3,"client hello v3, handshake len.: %d",
                 (uint)input[1] << 0x10 | (uint)input[2] << 8 | (uint)input[3]);
      if (input[1] == 0) {
        ret = 4;
        uVar3 = *(ushort *)&ssl->conf->field_0x74;
        if ((uVar3 & 2) != 0) {
          ret = 0xc;
        }
        if (ilen == ((uint)(*(ushort *)(input + 2) >> 8) |
                    ((uint)*(ushort *)(input + 2) & 0xff) << 8) + ret) {
          if ((uVar3 & 2) == 0) {
LAB_2306a850:
            ret = 4;
          }
          else {
            sig_len = ((uint)*(ushort *)(ssl->in_msg + 4) & 0xff) << 8 |
                      (uint)(*(ushort *)(ssl->in_msg + 4) >> 8);
            ssl->handshake->out_msg_seq = sig_len;
            ssl->handshake->in_msg_seq = sig_len + 1;
            hash = ssl->in_msg;
            if ((((hash[6] != '\0') || (hash[7] != '\0')) || (hash[8] != '\0')) ||
               (ret = memcmp(hash + 1,hash + 9,3), ret != 0)) {
              mbedtls_debug_print_msg(ssl,1,"file1",0x515,"ClientHello fragmentation not supported")
              ;
              return -0x7080;
            }
            ret = 0xc;
            if ((*(ushort *)&ssl->conf->field_0x74 & 2) == 0) goto LAB_2306a850;
          }
          input = input + ret;
          pbVar21 = (byte *)(ilen - ret);
          if (pbVar21 < (byte *)0x26) {
            ret = 0x535;
            goto LAB_2306a59a;
          }
          mbedtls_debug_print_buf(ssl,3,"file1",0x53c,"client hello, version",input,2);
          mbedtls_ssl_read_version
                    (&ssl->major_ver,&ssl->minor_ver,*(uint *)&ssl->conf->field_0x74 >> 1 & 1,input)
          ;
          ssl->handshake->max_major_ver = ssl->major_ver;
          ret = ssl->minor_ver;
          ssl->handshake->max_minor_ver = ret;
          pmVar12 = ssl->conf;
          if ((ssl->major_ver < (int)(uint)pmVar12->min_major_ver) ||
             (ret < (int)(uint)pmVar12->min_minor_ver)) {
            mbedtls_debug_print_msg
                      (ssl,1,"file1",0x54a,
                       "client only supports ssl smaller than minimum [%d:%d] < [%d:%d]");
            mbedtls_ssl_send_alert_message(ssl,'\x02','F');
            return -0x6e80;
          }
          if ((int)(uint)pmVar12->max_major_ver < ssl->major_ver) {
            ssl->major_ver = (uint)pmVar12->max_major_ver;
            ilen = (uint)pmVar12->max_minor_ver;
LAB_2306a910:
            ssl->minor_ver = ilen;
          }
          else {
            ilen = (uint)pmVar12->max_minor_ver;
            if ((int)ilen < ret) goto LAB_2306a910;
          }
          mbedtls_debug_print_buf(ssl,3,"file1",0x55d,"client hello, random bytes",input + 2,0x20);
          memcpy(ssl->handshake->randbytes,input + 2,0x20);
          ilen = (uint)input[0x22];
          if ((0x20 < input[0x22]) || (len = (byte *)(ilen + 0x24), pbVar21 < len)) {
            ret = 0x569;
            goto LAB_2306a59a;
          }
          mbedtls_debug_print_buf(ssl,3,"file1",0x56d,"client hello, session id",input + 0x23,ilen);
          ssl->session_negotiate->id_len = ilen;
          buf_01 = (byte *)(ilen + 0x23);
          memset(ssl->session_negotiate->id,0,0x20);
          memcpy(ssl->session_negotiate->id,input + 0x23,ssl->session_negotiate->id_len);
          if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
            bVar1 = input[(int)buf_01];
            if (pbVar21 < buf_01 + (uint)bVar1 + 3) {
              ret = 0x580;
              goto LAB_2306a59a;
            }
            mbedtls_debug_print_buf
                      (ssl,3,"file1",0x585,"client hello, cookie",input + (int)len,(uint)bVar1);
            if (bVar1 != 0) {
              ret = 0x5a1;
              goto LAB_2306a59a;
            }
            mbedtls_debug_print_msg(ssl,2,"file1",0x5a5,"cookie verification skipped");
            buf_01 = len;
          }
          bVar1 = (input + (int)buf_01)[1];
          uVar3 = CONCAT11(input[(int)buf_01],bVar1);
          len = (byte *)(uint)uVar3;
          if (1 < uVar3) {
            pbVar25 = len + (int)buf_01;
            if ((pbVar25 + 3 <= pbVar21) && (ilen = (uint)len & 1, (bVar1 & 1) == 0)) {
              buf_01 = input + (int)(buf_01 + 2);
              mbedtls_debug_print_buf
                        (ssl,3,"file1",0x5bd,"client hello, ciphersuitelist",buf_01,(size_t)len);
              sig_len = (uint)input[(int)(pbVar25 + 2)];
              if (sig_len - 1 < 0x10) {
                pbVar26 = pbVar25 + 2 + sig_len;
                pbVar16 = pbVar26 + 1;
                if (pbVar16 <= pbVar21) {
                  mbedtls_debug_print_buf
                            (ssl,3,"file1",0x5cf,"client hello, compression",
                             input + (int)(pbVar25 + 3),sig_len);
                  ssl->session_negotiate->compression = 0;
                  if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
                    ssl->session_negotiate->compression = 0;
                  }
                  pbVar25 = pbVar26 + 3;
                  if (pbVar16 < pbVar21) {
                    if (pbVar21 < pbVar25) {
                      ret = 0x5f0;
                      goto LAB_2306a59a;
                    }
                    ilen = (uint)CONCAT11(input[(int)pbVar16],input[(int)(pbVar26 + 2)]);
                    if ((ilen - 1 < 3) || (pbVar21 != pbVar25 + ilen)) {
                      ret = 0x5fa;
                      goto LAB_2306a59a;
                    }
                  }
                  buf = (ushort *)(input + (int)pbVar25);
                  mbedtls_debug_print_buf
                            (ssl,3,"file1",0x602,"client hello extensions",(uchar *)buf,ilen);
                  do {
                    input = buf_01;
                    if (ilen == 0) goto LAB_2306ab72;
                    sig_len = (uint)(*buf >> 8) | ((uint)*buf & 0xff) << 8;
                    uVar17 = ((uint)buf[1] & 0xff) << 8 | (uint)(buf[1] >> 8);
                    uVar22 = uVar17 + 4;
                    if (ilen < uVar22) {
                      ret = 0x60d;
                      goto LAB_2306a59a;
                    }
                    if (sig_len == 0xd) {
                      mbedtls_debug_print_msg
                                (ssl,3,"file1",0x62c,"found signature_algorithms extension");
                      uVar3 = buf[2] >> 8;
                      if ((uVar17 == (((uint)buf[2] & 0xff) << 8 | (uint)uVar3) + 2) &&
                         ((uVar3 & 1) == 0)) {
                        piVar20 = ssl->conf->sig_hashes;
                        while (*piVar20 != 0) {
                          puVar10 = buf + 3;
                          while (puVar10 < (ushort *)((int)buf + uVar22)) {
                            ret = *piVar20;
                            md_alg = mbedtls_ssl_md_alg_from_hash(*(byte *)puVar10);
                            if (ret == CONCAT31(extraout_var,md_alg)) {
                              line = 0xe4;
                              ssl->handshake->sig_alg = (uint)*(byte *)puVar10;
                              ret = 0x298;
                              sig_len = ssl->handshake->sig_alg;
                              goto LAB_2306aeda;
                            }
                            puVar10 = puVar10 + 1;
                          }
                          piVar20 = piVar20 + 1;
                        }
                        format = "no signature_algorithm in common";
                        ret = 0xdf;
                        goto LAB_2306ae8c;
                      }
                      ret = 0xcb;
                      goto LAB_2306a59a;
                    }
                    if (sig_len < 0xe) {
                      if (sig_len == 0) {
                        mbedtls_debug_print_msg(ssl,3,"file1",0x614,"found ServerName extension");
                        if (ssl->conf->f_sni !=
                            (
                             anon_subr_int_void_ptr_mbedtls_ssl_context_ptr_uchar_ptr_size_t_for_f_sni
                             *)0x0) {
                          mbedtls_debug_print_msg(ssl,3,"file1",0x62,"parse ServerName extension");
                          sig_len = ((uint)buf[2] & 0xff) << 8 | (uint)(buf[2] >> 8);
                          if (uVar17 != sig_len + 2) {
                            ret = 0x67;
                            goto LAB_2306a59a;
                          }
                          puVar10 = buf + 3;
                          while (sig_len != 0) {
                            uVar11 = ((uint)*(ushort *)((int)puVar10 + 1) & 0xff) << 8 |
                                     (uint)(*(ushort *)((int)puVar10 + 1) >> 8);
                            if (sig_len < uVar11 + 3) {
                              ret = 0x71;
                              goto LAB_2306a59a;
                            }
                            if (*(byte *)puVar10 == 0) {
                              ret = (*ssl->conf->f_sni)(ssl->conf->p_sni,ssl,
                                                        (byte *)((int)puVar10 + 3),uVar11);
                              if (ret != 0) {
                                mbedtls_debug_print_ret(ssl,1,"file1",0x7b,"ssl_sni_wrapper",ret);
                                message = 'p';
                                goto LAB_2306adbc;
                              }
                              break;
                            }
                            sig_len = sig_len + (-3 - uVar11);
                            puVar10 = (ushort *)((int)puVar10 + uVar11 + 3);
                          }
                        }
                      }
                      else {
                        if (sig_len == 1) {
                          mbedtls_debug_print_msg
                                    (ssl,3,"file1",0x65a,"found max fragment length extension");
                          if ((uVar17 != 1) || (4 < *(byte *)(buf + 2))) {
                            ret = 0x16a;
                            goto LAB_2306a59a;
                          }
                          ssl->session_negotiate->mfl_code = *(byte *)(buf + 2);
                        }
                        else {
LAB_2306ac44:
                          ret = -0x458;
                          line = 0x696;
LAB_2306aeda:
                          mbedtls_debug_print_msg
                                    (ssl,3,"file1",line,(char *)((int)&PTR_caseD_e_2308d000 + ret),
                                     sig_len);
                        }
                      }
                    }
                    else {
                      if (sig_len == 0x23) {
                        mbedtls_debug_print_msg
                                  (ssl,3,"file1",0x682,"found session ticket extension");
                        mbedtls_ssl_session_init((mbedtls_ssl_session *)&local_b4);
                        if ((ssl->conf->f_ticket_parse !=
                             (
                              anon_subr_int_void_ptr_mbedtls_ssl_session_ptr_uchar_ptr_size_t_for_f_ticket_parse
                              *)0x0) &&
                           (ssl->conf->f_ticket_write !=
                            (
                             anon_subr_int_void_ptr_mbedtls_ssl_session_ptr_uchar_ptr_uchar_ptr_size_t_ptr_uint32_t_ptr_for_f_ticket_write
                             *)0x0)) {
                          ssl->handshake->new_session_ticket = 1;
                          mbedtls_debug_print_msg(ssl,3,"file1",0x1c9,"ticket length: %d",uVar17);
                          if (uVar17 != 0) {
                            ret = (*ssl->conf->f_ticket_parse)
                                            (ssl->conf->p_ticket,(mbedtls_ssl_session *)&local_b4,
                                             (uchar *)(buf + 2),uVar17);
                            if (ret == 0) {
                              session.compression = ssl->session_negotiate->id_len;
                              memcpy(&session.id_len,ssl->session_negotiate->id,session.compression)
                              ;
                              mbedtls_ssl_session_free(ssl->session_negotiate);
                              memcpy(ssl->session_negotiate,&local_b4,0x74);
                              hash = &local_b4;
                              do {
                                *hash = '\0';
                                hash = hash + 1;
                              } while (hash != &session.mfl_code);
                              mbedtls_debug_print_msg
                                        (ssl,3,"file1",0x1f5,
                                         "session successfully restored from ticket");
                              ssl->handshake->resume = 1;
                              ssl->handshake->new_session_ticket = 0;
                            }
                            else {
                              mbedtls_ssl_session_free((mbedtls_ssl_session *)&local_b4);
                              if (ret == -0x7180) {
                                format = "ticket is not authentic";
                                ret = 0x1df;
                              }
                              else {
                                if (ret != -0x6d80) {
                                  mbedtls_debug_print_ret
                                            (ssl,1,"file1",0x1e3,"mbedtls_ssl_ticket_parse",ret);
                                  goto LAB_2306ad3a;
                                }
                                format = "ticket is expired";
                                ret = 0x1e1;
                              }
LAB_2306ae8c:
                              mbedtls_debug_print_msg(ssl,3,"file1",ret,format);
                            }
                          }
                        }
                      }
                      else {
                        if (sig_len == 0xff01) {
                          mbedtls_debug_print_msg
                                    (ssl,3,"file1",0x61f,"found renegotiation extension");
                          if ((uVar17 != 1) || (*(byte *)(buf + 2) != 0)) {
                            format = "non-zero length renegotiation info";
                            ret = 0xad;
                            goto LAB_2306ae02;
                          }
                          ssl->secure_renegotiation = 1;
                        }
                        else {
                          if (sig_len != 0x10) goto LAB_2306ac44;
                          mbedtls_debug_print_msg(ssl,3,"file1",0x68c,"found alpn extension");
                          ppcVar27 = ssl->conf->alpn_list;
                          if (ppcVar27 != (char **)0x0) {
                            if (uVar17 < 4) {
                              return -0x7900;
                            }
                            if (((uint)(buf[2] >> 8) | ((uint)buf[2] & 0xff) << 8) != uVar17 - 2) {
                              return -0x7900;
                            }
                            while (*ppcVar27 != (char *)0x0) {
                              __n_00 = strlen(*ppcVar27);
                              puVar10 = buf + 3;
                              while ((ushort *)((int)buf + uVar22) != puVar10) {
                                if ((ushort *)((int)buf + uVar22) < puVar10) {
                                  return -0x7900;
                                }
                                bVar1 = *(byte *)puVar10;
                                if (bVar1 == 0) {
                                  return -0x7900;
                                }
                                if ((__n_00 == (uint)bVar1) &&
                                   (ret = memcmp((byte *)((int)puVar10 + 1),*ppcVar27,__n_00),
                                   ret == 0)) {
                                  ssl->alpn_chosen = *ppcVar27;
                                  goto LAB_2306ad3a;
                                }
                                puVar10 = (ushort *)((byte *)((int)puVar10 + 1) + (uint)bVar1);
                              }
                              ppcVar27 = ppcVar27 + 1;
                            }
                            message = 'x';
LAB_2306adbc:
                            mbedtls_ssl_send_alert_message(ssl,'\x02',message);
                            return -0x7900;
                          }
                        }
                      }
                    }
LAB_2306ad3a:
                    ret = ilen - uVar17;
                    ilen = ret - 4;
                    buf = (ushort *)((int)buf + uVar22);
                  } while (2 < ret - 5U);
                  ret = 0x69e;
                  goto LAB_2306a59a;
                }
              }
              ret = 0x5ca;
              goto LAB_2306a59a;
            }
          }
          ret = 0x5b8;
          goto LAB_2306a59a;
        }
      }
      ret = 0x4e9;
LAB_2306a59a:
      mbedtls_debug_print_msg(ssl,1,"file1",ret,"bad client hello message");
      return -0x7900;
    }
    format = "mbedtls_ssl_fetch_input";
    ret = 0x450;
    line_00 = line;
    goto LAB_2306a528;
  case 2:
    mbedtls_debug_print_msg(ssl,2,"file1",0x8b1,"=> write server hello");
    if (ssl->conf->f_rng == (mbedtls_ssl_recv_t *)0x0) {
      mbedtls_debug_print_msg(ssl,1,"file1",0x8c0,"no RNG provided");
      return -0x7400;
    }
    puVar24 = ssl->out_msg;
    mbedtls_ssl_write_version
              (ssl->major_ver,ssl->minor_ver,*(uint *)&ssl->conf->field_0x74 >> 1 & 1,puVar24 + 4);
    mbedtls_debug_print_msg
              (ssl,3,"file1",0x8d3,"server hello, chosen version: [%d:%d]",(uint)puVar24[4],
               (uint)puVar24[5]);
    hash = puVar24 + 6;
    ret = (*ssl->conf->f_rng)(ssl->conf->p_rng,hash,4);
    if (ret != 0) {
      return ret;
    }
    ret = (*ssl->conf->f_rng)(ssl->conf->p_rng,puVar24 + 10,0x1c);
    if (ret != 0) {
      return ret;
    }
    memcpy(ssl->handshake->randbytes + 0x20,hash,0x20);
    mbedtls_debug_print_buf(ssl,3,"file1",0x8eb,"server hello, random bytes",hash,0x20);
    if ((ssl->handshake->resume == 0) && (ssl->session_negotiate->id_len != 0)) {
      paVar13 = ssl->conf->f_get_cache;
      if ((paVar13 != (anon_subr_int_void_ptr_mbedtls_ssl_session_ptr_for_f_get_cache *)0x0) &&
         (ret = (*paVar13)(ssl->conf->p_cache,ssl->session_negotiate), ret == 0)) {
        mbedtls_debug_print_msg(ssl,3,"file1",0x8fa,"session successfully restored from cache");
        ssl->handshake->resume = 1;
      }
    }
    pmVar14 = ssl->session_negotiate;
    if (ssl->handshake->resume == 0) {
      ssl->state = ssl->state + 1;
      if (ssl->handshake->new_session_ticket == 0) {
        pmVar14->id_len = 0x20;
        len_00 = 0x20;
        ret = (*ssl->conf->f_rng)(ssl->conf->p_rng,ssl->session_negotiate->id,0x20);
        if (ret != 0) {
          return ret;
        }
      }
      else {
        pmVar14->id_len = 0;
        memset(ssl->session_negotiate->id,0,0x20);
        len_00 = 0;
      }
    }
    else {
      len_00 = pmVar14->id_len;
      ssl->state = 0xc;
      line_00 = mbedtls_ssl_derive_keys(ssl);
      if (line_00 != 0) {
        format = "mbedtls_ssl_derive_keys";
        ret = 0x923;
        goto LAB_2306a528;
      }
    }
    hash = puVar24 + 0x27;
    puVar24[0x26] = (uchar)ssl->session_negotiate->id_len;
    memcpy(hash,ssl->session_negotiate->id,ssl->session_negotiate->id_len);
    sVar9 = ssl->session_negotiate->id_len;
    mbedtls_debug_print_msg(ssl,3,"file1",0x934,"server hello, session id len.: %d",len_00);
    mbedtls_debug_print_buf(ssl,3,"file1",0x935,"server hello, session id",hash,len_00);
    hash = hash + sVar9;
    if (ssl->handshake->resume == 0) {
      puVar15 = &UNK_2308c4d8;
    }
    else {
      puVar15 = (undefined *)0x230873f4;
    }
    mbedtls_debug_print_msg(ssl,3,"file1",0x937,"%s session has been resumed",puVar15);
    puVar19 = hash + 3;
    *hash = (uchar)((uint)ssl->session_negotiate->ciphersuite >> 8);
    hash[1] = (uchar)ssl->session_negotiate->ciphersuite;
    hash[2] = (uchar)ssl->session_negotiate->compression;
    format = mbedtls_ssl_get_ciphersuite_name(ssl->session_negotiate->ciphersuite);
    mbedtls_debug_print_msg(ssl,3,"file1",0x93e,"server hello, chosen ciphersuite: %s",format);
    mbedtls_debug_print_msg
              (ssl,3,"file1",0x940,"server hello, compress alg.: 0x%02X",
               ssl->session_negotiate->compression);
    puVar6 = (uchar *)0x0;
    if (ssl->secure_renegotiation == 1) {
      mbedtls_debug_print_msg(ssl,3,"file1",0x7c3,"server hello, secure renegotiation extension");
      hash[5] = -1;
      hash[6] = '\x01';
      hash[7] = '\0';
      hash[8] = '\x01';
      hash[9] = '\0';
      puVar6 = hash + (10 - (int)(hash + 5));
    }
    ret = 0;
    if (ssl->session_negotiate->mfl_code != '\0') {
      mbedtls_debug_print_msg(ssl,3,"file1",0x7ec,"server hello, max_fragment_length extension");
      __n = puVar6 + 2 + (int)puVar19;
      *__n = '\0';
      __n[1] = '\x01';
      __n[2] = '\0';
      __n[3] = '\x01';
      __n[4] = ssl->session_negotiate->mfl_code;
      ret = 5;
    }
    puVar6 = puVar6 + ret;
    ret = 0;
    if (ssl->handshake->new_session_ticket != 0) {
      mbedtls_debug_print_msg(ssl,3,"file1",0x7ab,"server hello, adding session ticket extension");
      __n = puVar19 + (int)(puVar6 + 2);
      *__n = '\0';
      __n[1] = '#';
      __n[2] = '\0';
      __n[3] = '\0';
      ret = 4;
    }
    line_00 = 0;
    if (ssl->alpn_chosen != (char *)0x0) {
      mbedtls_debug_print_msg(ssl,3,"file1",0x84f,"server hello, adding alpn extension");
      __n = puVar19 + (int)(puVar6 + ret + 2);
      __n[1] = '\x10';
      *__n = '\0';
      __n_00 = strlen(ssl->alpn_chosen);
      line_00 = __n_00 + 7;
      __n[2] = (uchar)(__n_00 + 3 >> 8);
      cVar4 = (char)line_00;
      __n[3] = cVar4 + -4;
      __n[4] = (uchar)(__n_00 + 1 >> 8);
      __n[5] = cVar4 + -6;
      __n[6] = cVar4 + -7;
      memcpy(__n + 7,ssl->alpn_chosen,__n_00);
    }
    puVar6 = puVar6 + ret + line_00;
    mbedtls_debug_print_msg(ssl,3,"file1",0x977,"server hello, total extension length: %d",puVar6);
    if (puVar6 != (uchar *)0x0) {
      hash[3] = (uchar)((uint)puVar6 >> 8);
      hash[4] = (uchar)puVar6;
      puVar19 = hash + 5 + (int)puVar6;
    }
    ssl->out_msgtype = 0x16;
    *(uchar **)&ssl->out_msglen = puVar19 + -(int)puVar24;
    *ssl->out_msg = '\x02';
    line_00 = mbedtls_ssl_write_record(ssl);
    format = "<= write server hello";
    line = 0x98a;
    goto LAB_2306b2ac;
  case 3:
    line_00 = mbedtls_ssl_write_certificate(ssl);
    break;
  case 4:
    info = ssl->transform_negotiate->ciphersuite_info;
    mbedtls_debug_print_msg(ssl,2,"file1",0xa7f,"=> write server key exchange");
    mVar2 = info->key_exchange;
    if (((mVar2 & 0xfb) == 1) || (mVar2 == MBEDTLS_KEY_EXCHANGE_RSA_PSK)) {
      format = "<= skip write server key exchange";
      line_00 = 0xa88;
LAB_2306b7d0:
      mbedtls_debug_print_msg(ssl,2,"file1",line_00,format);
      line_00 = ssl->state + 1;
      goto LAB_2306b7e2;
    }
    ssl->out_msglen = 4;
    ssl->out_msgtype = 0x16;
    *ssl->out_msg = '\f';
    ssl->state = ssl->state + 1;
    line_00 = mbedtls_ssl_write_record(ssl);
    if (line_00 != 0) {
      format = "mbedtls_ssl_write_record";
      ret = 0xbd4;
      goto LAB_2306a528;
    }
    format = "<= write server key exchange";
    line = 0xbd8;
    goto LAB_2306b2ac;
  case 5:
    info = ssl->transform_negotiate->ciphersuite_info;
    hash = ssl->out_msg;
    mbedtls_debug_print_msg(ssl,2,"file1",0x9b5,"=> write certificate request");
    ssl->state = ssl->state + 1;
    ilen = ssl->handshake->sni_authmode;
    if (ilen == 3) {
      ilen = *(uint *)&ssl->conf->field_0x74 >> 2 & 3;
    }
    mVar2 = info->key_exchange;
    if ((((byte)(mVar2 + ~MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA) < 4) ||
        (mVar2 == MBEDTLS_KEY_EXCHANGE_ECJPAKE)) || (ilen == 0)) {
      format = "<= skip write certificate request";
      line = 0x9c7;
      line_00 = ret;
    }
    else {
      puVar19 = ssl->out_msg;
      ret = 0;
      puVar19[5] = '\x01';
      puVar19[4] = '\x01';
      puVar6 = puVar19 + 6;
      puVar24 = puVar6;
      if (ssl->minor_ver == 3) {
        line_00 = 0;
        piVar20 = ssl->conf->sig_hashes;
        while( true ) {
          ret = line_00 + 2;
          puVar24 = puVar6 + ret;
          if (*piVar20 == 0) break;
          message = mbedtls_ssl_hash_from_md_alg(*piVar20);
          if ((CONCAT31(extraout_var_01,message) != 0) &&
             (line = mbedtls_ssl_set_calc_verify_md(ssl,CONCAT31(extraout_var_01,message)),
             line == 0)) {
            *puVar24 = message;
            puVar6[line_00 + 3] = '\x01';
            line_00 = ret;
          }
          piVar20 = piVar20 + 1;
        }
        puVar19[6] = (uchar)((uint)line_00 >> 8);
        puVar19[7] = (uchar)line_00;
      }
      puVar24 = puVar24 + 2;
      pmVar5 = ssl->handshake->sni_ca_chain;
      if (pmVar5 == (mbedtls_x509_crt *)0x0) {
        pmVar5 = ssl->conf->ca_chain;
      }
      hash = hash + 0x4000;
      puVar6 = (uchar *)0x0;
      while( true ) {
        if ((pmVar5 == (mbedtls_x509_crt *)0x0) || (pmVar5->version == 0)) goto LAB_2306b93e;
        __n = (uchar *)(pmVar5->subject_raw).len;
        if ((hash < puVar24) || ((hash + -(int)puVar24 < __n || (hash + -(int)puVar24 < __n + 2))))
        break;
        *puVar24 = (uchar)((uint)__n >> 8);
        puVar24[1] = (uchar)__n;
        buf_00 = puVar24 + 2;
        memcpy(buf_00,(pmVar5->subject_raw).p,(size_t)__n);
        puVar24 = buf_00 + (int)__n;
        puVar6 = __n + 2 + (int)puVar6;
        mbedtls_debug_print_buf(ssl,3,"file1",0xa38,"requested DN",buf_00,(size_t)__n);
        pmVar5 = pmVar5->next;
      }
      mbedtls_debug_print_msg(ssl,1,"file1",0xa2f,"skipping CAs: buffer too short");
LAB_2306b93e:
      *(uchar **)&ssl->out_msglen = puVar24 + -(int)puVar19;
      ssl->out_msgtype = 0x16;
      *ssl->out_msg = '\r';
      ssl->out_msg[ret + 6] = (uchar)((uint)puVar6 >> 8);
      ssl->out_msg[ret + 7] = (uchar)puVar6;
      line_00 = mbedtls_ssl_write_record(ssl);
      format = "<= write certificate request";
      line = 0xa46;
    }
LAB_2306b2ac:
    mbedtls_debug_print_msg(ssl,2,"file1",line,format);
    break;
  case 6:
    mbedtls_debug_print_msg(ssl,2,"file1",0xbe1,"=> write server hello done");
    ssl->out_msglen = 4;
    ssl->out_msgtype = 0x16;
    *ssl->out_msg = '\x0e';
    ssl->state = ssl->state + 1;
    if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
      mbedtls_ssl_send_flight_completed(ssl);
    }
    line_00 = mbedtls_ssl_write_record(ssl);
    if (line_00 == 0) {
      format = "<= write server hello done";
      line = 0xbf4;
      goto LAB_2306b2ac;
    }
    format = "mbedtls_ssl_write_record";
    ret = 0xbf0;
    goto LAB_2306a528;
  case 7:
    line_00 = mbedtls_ssl_parse_certificate(ssl);
    break;
  case 8:
    info = ssl->transform_negotiate->ciphersuite_info;
    mbedtls_debug_print_msg(ssl,2,"file1",0xcd4,"=> parse client key exchange");
    line_00 = mbedtls_ssl_read_record(ssl);
    if (line_00 == 0) {
      hash = ssl->in_msg;
      ret = 4;
      if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
        ret = 0xc;
      }
      len_00 = ssl->in_hslen;
      input = hash + ret;
      if (ssl->in_msgtype == 0x16) {
        if (*hash == '\x10') {
          if (info->key_exchange != MBEDTLS_KEY_EXCHANGE_RSA) {
            ret = 0xdb5;
LAB_2306b108:
            mbedtls_debug_print_msg(ssl,1,"file1",ret,"should never happen");
            ret = -0x7000;
            goto LAB_2306baec;
          }
          ctx = mbedtls_ssl_own_key(ssl);
          sVar9 = mbedtls_pk_get_bitlen(ctx);
          ctx = mbedtls_ssl_own_key(ssl);
          ilen = sVar9 + 7 >> 3;
          pmVar7 = ssl->handshake;
          ret = mbedtls_pk_can_do(ctx,MBEDTLS_PK_RSA);
          if (ret == 0) {
            mbedtls_debug_print_msg(ssl,1,"file1",0xc34,"got no RSA private key");
            line_00 = -0x7600;
          }
          else {
            if ((ssl->minor_ver == 0) ||
               (((uint)*input == (sVar9 + 7 >> 0xb & 0xff) &&
                (pbVar21 = input + 1, input = input + 2, (uint)*pbVar21 == (ilen & 0xff))))) {
              if (hash + len_00 == input + ilen) {
                mbedtls_ssl_write_version
                          (ssl->handshake->max_major_ver,ssl->handshake->max_minor_ver,
                           *(uint *)&ssl->conf->field_0x74 >> 1 & 1,&bStack236);
                line_00 = (*ssl->conf->f_rng)(ssl->conf->p_rng,(uchar *)&major,0x30);
                if (line_00 == 0) {
                  ctx = mbedtls_ssl_own_key(ssl);
                  ilen = mbedtls_pk_decrypt(ctx,input,ilen,&local_b4,(size_t *)ver,0x30,
                                            (anon_subr_int_void_ptr_uchar_ptr_size_t *)
                                            ssl->conf->f_rng,ssl->conf->p_rng);
                  ilen = ilen | (uint)(byte)((byte)local_b4 ^ bStack236 | local_b4._1_1_ ^ bStack235
                                            ) | _ver ^ 0x30;
                  ssl->handshake->pmslen = 0x30;
                  bVar1 = (char)((byte)(ilen >> 0x18) | (byte)(-ilen >> 0x18)) >> 7;
                  ilen = 0;
                  while (ilen < ssl->handshake->pmslen) {
                    pmVar7->premaster[ilen] =
                         (&local_b4)[ilen] & ~bVar1 | *(byte *)((int)&major + ilen) & bVar1;
                    ilen = ilen + 1;
                  }
                  line_00 = mbedtls_ssl_derive_keys(ssl);
                  if (line_00 == 0) {
                    ssl->state = ssl->state + 1;
                    format = "<= parse client key exchange";
                    line = 0xdc1;
                    goto LAB_2306b2ac;
                  }
                  format = "mbedtls_ssl_derive_keys";
                  ret = 0xdbb;
                  goto LAB_2306a528;
                }
                goto LAB_2306bb5c;
              }
              ret = 0xc4a;
            }
            else {
              ret = 0xc42;
            }
            mbedtls_debug_print_msg(ssl,1,"file1",ret,"bad client key exchange message");
            line_00 = -0x7c00;
          }
LAB_2306bb5c:
          format = "ssl_parse_parse_encrypted_pms_secret";
          ret = 0xd98;
          goto LAB_2306a528;
        }
        ret = 0xce7;
      }
      else {
        ret = 0xce1;
      }
      mbedtls_debug_print_msg(ssl,1,"file1",ret,"bad client key exchange message");
      ret = -0x8000;
LAB_2306baec:
      return ret + 0x400;
    }
    format = "mbedtls_ssl_read_record";
    ret = 0xcd8;
    goto LAB_2306a528;
  case 9:
    info = ssl->transform_negotiate->ciphersuite_info;
    mbedtls_debug_print_msg(ssl,2,"file1",0xdee,"=> parse certificate verify");
    mVar2 = info->key_exchange;
    if ((((byte)(mVar2 + ~MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA) < 4) ||
        (mVar2 == MBEDTLS_KEY_EXCHANGE_ECJPAKE)) ||
       (ssl->session_negotiate->peer_cert == (mbedtls_x509_crt *)0x0)) {
      format = "<= skip parse certificate verify";
      line_00 = 0xdf7;
      goto LAB_2306b7d0;
    }
    do {
      line_00 = mbedtls_ssl_read_record_layer(ssl);
      if (line_00 != 0) {
        format = "mbedtls_ssl_read_record_layer";
        ret = 0xe01;
        goto LAB_2306a528;
      }
      line_00 = mbedtls_ssl_handle_message_type(ssl);
    } while (line_00 == -0x6680);
    if (line_00 == 0) {
      ssl->state = ssl->state + 1;
      if ((ssl->in_msgtype != 0x16) || (*ssl->in_msg != '\x0f')) {
        format = "bad certificate verify message";
        ret = 0xe15;
        goto LAB_2306bd9e;
      }
      ret = 4;
      if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
        ret = 0xc;
      }
      if (ssl->minor_ver != 3) {
        ret = 0xe6c;
        goto LAB_2306b108;
      }
      if (ssl->in_hslen < ret + 2U) {
        format = "bad certificate verify message";
        ret = 0xe39;
LAB_2306bd9e:
        mbedtls_debug_print_msg(ssl,1,"file1",ret,format);
        return -0x7d80;
      }
      md_alg = mbedtls_ssl_md_alg_from_hash(ssl->in_msg[ret]);
      if ((CONCAT31(extraout_var_02,md_alg) == 0) ||
         (line_00 = mbedtls_ssl_set_calc_verify_md(ssl,(uint)ssl->in_msg[ret]), line_00 != 0)) {
        format = "peer not adhering to requested sig_alg for verify message";
        ret = 0xe45;
        goto LAB_2306bd9e;
      }
      hash = &local_b4;
      if (CONCAT31(extraout_var_02,md_alg) == 4) {
        hash = session.id;
      }
      type = mbedtls_ssl_pk_alg_from_sig(ssl->in_msg[ret + 1]);
      if (CONCAT31(extraout_var_03,type) == 0) {
        format = "peer not adhering to requested sig_alg for verify message";
        ret = 0xe5a;
        goto LAB_2306bd9e;
      }
      line_00 = mbedtls_pk_can_do(&ssl->session_negotiate->peer_cert->pk,type);
      if (line_00 == 0) {
        format = "sig_alg doesn\'t match cert key";
        ret = 0xe63;
        goto LAB_2306bd9e;
      }
      ilen = ret + 4;
      if (ssl->in_hslen < ilen) {
        format = "bad certificate verify message";
        ret = 0xe72;
        goto LAB_2306bd9e;
      }
      sig_len = (uint)CONCAT11(ssl->in_msg[ret + 2U],ssl->in_msg[ret + 3]);
      if (ssl->in_hslen != ilen + sig_len) {
        format = "bad certificate verify message";
        ret = 0xe7b;
        goto LAB_2306bd9e;
      }
      (*ssl->handshake->calc_verify)(ssl,&local_b4);
      line_00 = mbedtls_pk_verify(&ssl->session_negotiate->peer_cert->pk,md_alg,hash,0,
                                  ssl->in_msg + ilen,sig_len);
      if (line_00 == 0) {
        mbedtls_ssl_update_handshake_status(ssl);
        format = "<= parse certificate verify";
        line = 0xe8c;
        goto LAB_2306b2ac;
      }
      format = "mbedtls_pk_verify";
      ret = 0xe86;
    }
    else {
      format = "mbedtls_ssl_handle_message_type";
      ret = 0xe0b;
    }
    goto LAB_2306a528;
  case 10:
    line_00 = mbedtls_ssl_parse_change_cipher_spec(ssl);
    break;
  case 0xb:
    line_00 = mbedtls_ssl_parse_finished(ssl);
    break;
  case 0xc:
    if (ssl->handshake->new_session_ticket == 0) {
      ret = mbedtls_ssl_write_change_cipher_spec(ssl);
      return ret;
    }
    mbedtls_debug_print_msg(ssl,2,"file1",0xe9e,"=> write new session ticket");
    ssl->out_msgtype = 0x16;
    *ssl->out_msg = '\x04';
    ret = (*ssl->conf->f_ticket_write)
                    (ssl->conf->p_ticket,ssl->session_negotiate,ssl->out_msg + 10,
                     ssl->out_msg + 0x4000,(size_t *)&major,(uint32_t *)&local_b4);
    if (ret != 0) {
      mbedtls_debug_print_ret(ssl,1,"file1",0xeb4,"mbedtls_ssl_ticket_write",ret);
      major = 0;
    }
    ssl->out_msg[4] = (uchar)(local_b4 >> 0x18);
    ssl->out_msg[5] = (uchar)(local_b4 >> 0x10);
    ssl->out_msg[6] = (uchar)(local_b4 >> 8);
    ssl->out_msg[7] = (uchar)local_b4;
    ssl->out_msg[8] = (uchar)((uint)major >> 8);
    ssl->out_msg[9] = (uchar)major;
    ssl->out_msglen = major + 10;
    ssl->handshake->new_session_ticket = 0;
    line_00 = mbedtls_ssl_write_record(ssl);
    if (line_00 == 0) {
      format = "<= write new session ticket";
      line = 0xece;
      goto LAB_2306b2ac;
    }
    format = "mbedtls_ssl_write_record";
    ret = 0xeca;
LAB_2306a528:
    mbedtls_debug_print_ret(ssl,1,"file1",ret,format,line_00);
    break;
  case 0xd:
    line_00 = mbedtls_ssl_write_finished(ssl);
    break;
  case 0xe:
    mbedtls_debug_print_msg(ssl,2,"file1",0xf47,"handshake: done");
    line_00 = 0xf;
LAB_2306b7e2:
    ssl->state = line_00;
    line_00 = ret;
    break;
  case 0xf:
    mbedtls_ssl_handshake_wrapup(ssl);
    line_00 = ret;
    break;
  default:
    mbedtls_debug_print_msg(ssl,1,"file1",0xf50,"invalid state %d",line_00);
    return -0x7100;
  case 0x12:
    line_00 = -0x6a80;
  }
  return line_00;
LAB_2306ab72:
  if ((*input == 0) && (input[1] == 0xff)) {
    mbedtls_debug_print_msg(ssl,3,"file1",0x6c4,"received TLS_EMPTY_RENEGOTIATION_INFO ");
    ssl->secure_renegotiation = 1;
    goto LAB_2306aba0;
  }
  input = input + 2;
  if (len <= input + -(int)buf_01) {
    if ((ssl->secure_renegotiation != 1) && ((*(ushort *)&ssl->conf->field_0x74 & 0x30) == 0x20)) {
      format = "legacy renegotiation, breaking off handshake";
      ret = 0x6db;
LAB_2306ae02:
      mbedtls_debug_print_msg(ssl,1,"file1",ret,format);
      ret = mbedtls_ssl_send_fatal_handshake_failure(ssl);
      if (ret == 0) {
        return -0x7900;
      }
      return ret;
    }
LAB_2306aba0:
    puVar18 = (uint *)ssl->conf->ciphersuite_list[ssl->minor_ver];
    ret = 0;
    do {
      input = buf_01;
      if (*puVar18 == 0) {
        if (ret == 0) {
          mbedtls_debug_print_msg(ssl,1,"file1",0x728,"got no ciphersuites in common");
          mbedtls_ssl_send_fatal_handshake_failure(ssl);
          return -0x7380;
        }
        mbedtls_debug_print_msg
                  (ssl,1,"file1",0x722,"got ciphersuites in common, but none of them usable");
        mbedtls_ssl_send_fatal_handshake_failure(ssl);
        return -0x6980;
      }
      do {
        ilen = *puVar18;
        if (((uint)*input == ((int)ilen >> 8 & 0xffU)) && ((uint)input[1] == (ilen & 0xff))) {
          info = mbedtls_ssl_ciphersuite_from_id(ilen);
          if (info == (mbedtls_ssl_ciphersuite_t *)0x0) {
            ret = 0x2cc;
            goto LAB_2306b108;
          }
          mbedtls_debug_print_msg(ssl,3,"file1",0x2d0,"trying ciphersuite: %s",info->name);
          ret = line_00;
          if ((ssl->minor_ver < info->min_minor_ver) || (info->max_minor_ver < ssl->minor_ver)) {
            format = "ciphersuite mismatch: version";
            line = 0x2d5;
          }
          else {
            if (((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) && ((info->flags & 4) != 0))
            goto LAB_2306b15a;
            type = mbedtls_ssl_get_ciphersuite_sig_pk_alg(info);
            pmVar28 = ssl->handshake->sni_key_cert;
            if (pmVar28 == (mbedtls_ssl_key_cert *)0x0) {
              pmVar28 = ssl->conf->key_cert;
            }
            if (CONCAT31(extraout_var_00,type) == 0) {
have_ciphersuite:
              mbedtls_debug_print_msg(ssl,2,"file1",0x72e,"selected ciphersuite: %s",info->name);
              ssl->session_negotiate->ciphersuite = *puVar18;
              ssl->transform_negotiate->ciphersuite_info = info;
              ssl->state = ssl->state + 1;
              if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
                mbedtls_ssl_recv_flight_completed(ssl);
              }
              format = "<= parse client hello";
              line = 0x73a;
              line_00 = iVar8;
              goto LAB_2306b2ac;
            }
            mbedtls_debug_print_msg(ssl,3,"file1",0x26f,"ciphersuite requires certificate");
            pmVar23 = (mbedtls_ssl_key_cert *)0x0;
            if (pmVar28 == (mbedtls_ssl_key_cert *)0x0) {
              mbedtls_debug_print_msg(ssl,3,"file1",0x273,"server has no certificate");
            }
            else {
              do {
                mbedtls_debug_print_crt
                          (ssl,3,"file1",0x27a,"candidate certificate chain, certificate",
                           pmVar28->cert);
                line = mbedtls_pk_can_do(pmVar28->key,type);
                if (line == 0) {
                  format = "certificate mismatch: key type";
                  line = 0x27e;
                }
                else {
                  line = mbedtls_ssl_check_cert_usage(pmVar28->cert,info,1,(uint32_t *)&local_b4);
                  if (line == 0) {
                    if ((2 < ssl->minor_ver) || (pmVar28->cert->sig_md == MBEDTLS_MD_SHA1))
                    goto LAB_2306b22e;
                    if (pmVar23 == (mbedtls_ssl_key_cert *)0x0) {
                      pmVar23 = pmVar28;
                    }
                    format = "certificate not preferred: sha-2 with pre-TLS 1.2 client";
                    line = 0x2a7;
                  }
                  else {
                    format = "certificate mismatch: (extended) key usage extension";
                    line = 0x28e;
                  }
                }
                mbedtls_debug_print_msg(ssl,3,"file1",line,format);
                pmVar28 = pmVar28->next;
              } while (pmVar28 != (mbedtls_ssl_key_cert *)0x0);
              pmVar28 = pmVar23;
              if (pmVar23 != (mbedtls_ssl_key_cert *)0x0) {
LAB_2306b22e:
                ssl->handshake->key_cert = pmVar28;
                mbedtls_debug_print_crt
                          (ssl,3,"file1",0x2b8,"selected certificate chain, certificate",
                           ssl->handshake->key_cert->cert);
                goto have_ciphersuite;
              }
            }
            format = "ciphersuite mismatch: no suitable certificate";
            line = 0x316;
          }
          mbedtls_debug_print_msg(ssl,3,"file1",line,format);
        }
LAB_2306b15a:
        input = input + 2;
      } while (input + -(int)buf_01 < len);
      puVar18 = puVar18 + 1;
    } while( true );
  }
  goto LAB_2306ab72;
}



int mbedtls_x509_get_serial(uchar **p,uchar *end,mbedtls_x509_buf *serial)

{
  int iVar1;
  byte *pbVar2;
  uchar *puVar3;
  
  pbVar2 = *p;
  if ((int)(end + -(int)pbVar2) < 1) {
    return -0x22e0;
  }
  if ((*pbVar2 & 0x7f) == 2) {
    *p = pbVar2 + 1;
    serial->tag = (uint)*pbVar2;
    iVar1 = mbedtls_asn1_get_len(p,end,&serial->len);
    if (iVar1 == 0) {
      puVar3 = *p;
      serial->p = puVar3;
      *p = puVar3 + serial->len;
    }
    else {
      iVar1 = iVar1 + -0x2280;
    }
    return iVar1;
  }
  return -0x22e2;
}



int mbedtls_x509_get_alg(uchar **p,uchar *end,mbedtls_x509_buf *alg,mbedtls_x509_buf *params)

{
  int iVar1;
  
  iVar1 = mbedtls_asn1_get_alg(p,end,(mbedtls_asn1_buf *)alg,(mbedtls_asn1_buf *)params);
  if (iVar1 != 0) {
    iVar1 = iVar1 + -0x2300;
  }
  return iVar1;
}



int mbedtls_x509_get_name(uchar **p,uchar *end,mbedtls_x509_name *cur)

{
  mbedtls_x509_name *pmVar1;
  int iVar2;
  mbedtls_asn1_named_data *pmVar3;
  uchar *puVar4;
  byte *pbVar5;
  uchar *end_00;
  size_t sStack56;
  size_t set_len;
  size_t len;
  
LAB_2306c13a:
  iVar2 = mbedtls_asn1_get_tag(p,end,&sStack56,0x31);
  if (iVar2 != 0) {
    return iVar2 + -0x2380;
  }
  end_00 = *p + sStack56;
  pmVar1 = cur;
  do {
    iVar2 = mbedtls_asn1_get_tag(p,end_00,&set_len,0x30);
    if (iVar2 == 0) {
      if ((int)(end_00 + -(int)*p) < 1) {
        return -0x23e0;
      }
      (pmVar1->oid).tag = (uint)**p;
      iVar2 = mbedtls_asn1_get_tag(p,end_00,&(pmVar1->oid).len,6);
      if (iVar2 != 0) goto LAB_2306c186;
      puVar4 = *p;
      (pmVar1->oid).p = puVar4;
      pbVar5 = puVar4 + (pmVar1->oid).len;
      *p = pbVar5;
      if ((int)(end_00 + -(int)pbVar5) < 1) {
        return -0x23e0;
      }
      if ((0x1e < *pbVar5) || ((0x50581008U >> ((uint)*pbVar5 & 0x1f) & 1) == 0)) {
        return -0x23e2;
      }
      *p = pbVar5 + 1;
      (pmVar1->val).tag = (uint)*pbVar5;
      iVar2 = mbedtls_asn1_get_len(p,end_00,&(pmVar1->val).len);
      if (iVar2 != 0) goto LAB_2306c186;
      puVar4 = *p;
      (pmVar1->val).p = puVar4;
      *p = puVar4 + (pmVar1->val).len;
      pmVar1->next = (mbedtls_asn1_named_data *)0x0;
    }
    else {
LAB_2306c186:
      if (iVar2 + -0x2380 != 0) {
        return iVar2 + -0x2380;
      }
    }
    if (*p == end_00) break;
    pmVar1->next_merged = '\x01';
    pmVar3 = (mbedtls_asn1_named_data *)mycalloc(1,0x20);
    pmVar1->next = pmVar3;
    pmVar1 = (mbedtls_x509_name *)pmVar3;
    if (pmVar3 == (mbedtls_asn1_named_data *)0x0) {
      return -0x2880;
    }
  } while( true );
  if (end == end_00) {
    return 0;
  }
  cur = (mbedtls_x509_name *)mycalloc(1,0x20);
  *(mbedtls_x509_name **)&pmVar1->next = cur;
  if (cur == (mbedtls_x509_name *)0x0) {
    return -0x2880;
  }
  goto LAB_2306c13a;
}



// WARNING: Variable defined which should be unmapped: len

int mbedtls_x509_get_sig(uchar **p,uchar *end,mbedtls_x509_buf *sig)

{
  byte bVar1;
  int iVar2;
  uchar *puVar3;
  size_t sStack20;
  size_t len;
  
  if (0 < (int)(end + -(int)*p)) {
    bVar1 = **p;
    iVar2 = mbedtls_asn1_get_bitstring_null(p,end,&sStack20);
    if (iVar2 == 0) {
      sig->tag = (uint)bVar1;
      sig->len = sStack20;
      puVar3 = *p;
      sig->p = puVar3;
      *p = puVar3 + sStack20;
    }
    else {
      iVar2 = iVar2 + -0x2480;
    }
    return iVar2;
  }
  return -0x24e0;
}



int mbedtls_x509_get_sig_alg
              (mbedtls_x509_buf *sig_oid,mbedtls_x509_buf *sig_params,mbedtls_md_type_t *md_alg,
              mbedtls_pk_type_t *pk_alg,void **sig_opts)

{
  int iVar1;
  
  if (*sig_opts == (void *)0x0) {
    iVar1 = mbedtls_oid_get_sig_alg((mbedtls_asn1_buf *)sig_oid,md_alg,pk_alg);
    if (iVar1 == 0) {
      if (((sig_params->tag != 5) && (sig_params->tag != 0)) || (sig_params->len != 0)) {
        iVar1 = -0x2300;
      }
    }
    else {
      iVar1 = iVar1 + -0x2600;
    }
    return iVar1;
  }
  return -0x2800;
}



int mbedtls_x509_get_ext(uchar **p,uchar *end,mbedtls_x509_buf *ext,int tag)

{
  int iVar1;
  uchar *end_00;
  size_t sStack20;
  size_t len;
  
  if (*p == end) {
    return 0;
  }
  ext->tag = (uint)**p;
  iVar1 = mbedtls_asn1_get_tag(p,end,&ext->len,tag | 0xa0);
  if (iVar1 == 0) {
    end_00 = *p;
    ext->p = end_00;
    end_00 = end_00 + ext->len;
    iVar1 = mbedtls_asn1_get_tag(p,end_00,&sStack20,0x30);
    if (iVar1 == 0) {
      iVar1 = 0;
      if (end_00 != *p + sStack20) {
        iVar1 = -0x2566;
      }
    }
    else {
      iVar1 = iVar1 + -0x2500;
    }
  }
  return iVar1;
}



int mbedtls_x509_dn_gets(char *buf,size_t size,mbedtls_x509_name *dn)

{
  size_t __maxlen;
  uint __maxlen_00;
  uint uVar1;
  int iVar2;
  char *__format;
  byte bVar3;
  uchar uVar4;
  uint uVar5;
  mbedtls_x509_name *oid;
  char *pcStack308;
  char *short_name;
  char s [256];
  
  pcStack308 = (char *)0x0;
  memset(&short_name,0,0x100);
  uVar4 = '\0';
  __maxlen = size;
  oid = dn;
  do {
    if (oid == (mbedtls_x509_name *)0x0) {
      return size - __maxlen;
    }
    if ((oid->oid).p != (uchar *)0x0) {
      if (oid != dn) {
        __format = " + ";
        if (uVar4 == '\0') {
          __format = ", ";
        }
        uVar1 = snprintf(buf,__maxlen,__format);
        if ((int)uVar1 < 0) {
          return -0x2980;
        }
        if (__maxlen <= uVar1) {
          return -0x2980;
        }
        __maxlen = __maxlen - uVar1;
        buf = buf + uVar1;
      }
      iVar2 = mbedtls_oid_get_attr_short_name((mbedtls_asn1_buf *)oid,&pcStack308);
      if (iVar2 == 0) {
        uVar1 = snprintf(buf,__maxlen,"%s=",pcStack308);
      }
      else {
        uVar1 = snprintf(buf,__maxlen,"??=");
      }
      if (((int)uVar1 < 0) || (__maxlen <= uVar1)) {
        return -0x2980;
      }
      __maxlen_00 = __maxlen - uVar1;
      uVar5 = 0;
      while ((uVar5 < (oid->val).len && (uVar5 != 0xff))) {
        bVar3 = (oid->val).p[uVar5];
        if ((bVar3 < 0x20) || ((bVar3 == 0x7f || ((byte)(bVar3 + 0x7f) < 0x1f)))) {
          bVar3 = 0x3f;
        }
        *(byte *)((int)&short_name + uVar5) = bVar3;
        uVar5 = uVar5 + 1;
      }
      *(undefined *)((int)&short_name + uVar5) = 0;
      uVar5 = snprintf(buf + uVar1,__maxlen_00,"%s",&short_name);
      if ((int)uVar5 < 0) {
        return -0x2980;
      }
      if (__maxlen_00 <= uVar5) {
        return -0x2980;
      }
      __maxlen = __maxlen_00 - uVar5;
      buf = buf + uVar1 + uVar5;
      uVar4 = oid->next_merged;
    }
    oid = (mbedtls_x509_name *)oid->next;
  } while( true );
}



int mbedtls_x509_serial_gets(char *buf,size_t size,mbedtls_x509_buf *serial)

{
  size_t __maxlen;
  uint uVar1;
  undefined1 *puVar2;
  uint uVar3;
  uint uVar4;
  
  uVar4 = serial->len;
  if (0x20 < uVar4) {
    uVar4 = 0x1c;
  }
  uVar3 = 0;
  __maxlen = size;
  do {
    if (uVar3 == uVar4) {
      if (serial->len != uVar3) {
        uVar4 = snprintf(buf,__maxlen,"....");
        if (((int)uVar4 < 0) || (__maxlen <= uVar4)) {
          return -0x2980;
        }
        __maxlen = __maxlen - uVar4;
      }
      return size - __maxlen;
    }
    if (((uVar3 != 0) || (uVar4 == 1)) || (*serial->p != '\0')) {
      puVar2 = (undefined1 *)0x23087a70;
      if (uVar4 - 1 <= uVar3) {
        puVar2 = &DAT_23088e60;
      }
      uVar1 = snprintf(buf,__maxlen,"%02X%s",(uint)serial->p[uVar3],puVar2);
      if ((int)uVar1 < 0) {
        return -0x2980;
      }
      if (__maxlen <= uVar1) {
        return -0x2980;
      }
      __maxlen = __maxlen - uVar1;
      buf = buf + uVar1;
    }
    uVar3 = uVar3 + 1;
  } while( true );
}



int mbedtls_x509_sig_alg_gets
              (char *buf,size_t size,mbedtls_x509_buf *sig_oid,mbedtls_pk_type_t pk_alg,
              mbedtls_md_type_t md_alg,void *sig_opts)

{
  int iVar1;
  uint uVar2;
  char *pcStack20;
  char *desc;
  
  pcStack20 = (char *)0x0;
  iVar1 = mbedtls_oid_get_sig_alg_desc((mbedtls_asn1_buf *)sig_oid,&pcStack20);
  if (iVar1 == 0) {
    uVar2 = snprintf(buf,size,"%s",pcStack20);
  }
  else {
    uVar2 = snprintf(buf,size,"???");
  }
  if (((int)uVar2 < 0) || (size <= uVar2)) {
    uVar2 = 0xffffd680;
  }
  return uVar2;
}



int mbedtls_x509_key_size_helper(char *buf,size_t buf_size,char *name)

{
  uint uVar1;
  int iVar2;
  
  uVar1 = snprintf(buf,buf_size,"%s key size",name);
  if (((int)uVar1 < 0) || (buf_size <= uVar1)) {
    iVar2 = -0x2980;
  }
  else {
    iVar2 = 0;
  }
  return iVar2;
}



int mbedtls_x509_time_is_past(mbedtls_x509_time *to)

{
  return 0;
}



undefined4 mbedtls_x509_time_is_future(void)

{
  return 0;
}



int mbedtls_base64_decode(uchar *dst,size_t dlen,size_t *olen,uchar *src,size_t slen)

{
  byte bVar1;
  byte bVar2;
  int iVar3;
  byte *pbVar4;
  uint uVar5;
  uchar *puVar6;
  uint uVar7;
  size_t sVar8;
  uint uVar9;
  int iVar10;
  
  uVar5 = 0;
  uVar7 = 0;
  sVar8 = 0;
  while (sVar8 < slen) {
    iVar3 = 0;
    uVar9 = sVar8;
    while( true ) {
      bVar1 = src[uVar9];
      sVar8 = slen;
      if (bVar1 != 0x20) break;
      uVar9 = uVar9 + 1;
      iVar3 = iVar3 + 1;
      if (slen == uVar9) goto LAB_2306c656;
    }
    if (slen == uVar9) break;
    bVar2 = bVar1;
    if ((1 < slen - uVar9) && (bVar1 == 0xd)) {
      bVar2 = (src + uVar9)[1];
    }
    if (bVar2 != 10) {
      if (iVar3 != 0) {
        return -0x2c;
      }
      if (bVar1 == 0x3d) {
        uVar5 = uVar5 + 1;
        if (2 < uVar5) {
          return -0x2c;
        }
      }
      else {
        if ((char)bVar1 < '\0') {
          return -0x2c;
        }
      }
      if (
          "\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f>\x7f\x7f\x7f?456789:;<=\x7f\x7f\x7f@\x7f\x7f\x7f"
          [bVar1] == 0x7f) {
        return -0x2c;
      }
      if ((
           "\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f>\x7f\x7f\x7f?456789:;<=\x7f\x7f\x7f@\x7f\x7f\x7f"
           [bVar1] < 0x40) && (uVar5 != 0)) {
        return -0x2c;
      }
      uVar7 = uVar7 + 1;
    }
    sVar8 = uVar9 + 1;
  }
LAB_2306c656:
  if (uVar7 == 0) {
    *olen = 0;
  }
  else {
    uVar5 = ((uVar7 >> 3) * 6 - uVar5) + ((uVar7 & 7) * 6 + 7 >> 3);
    if ((dst == (uchar *)0x0) || (dlen < uVar5)) {
      *olen = uVar5;
      return -0x2a;
    }
    pbVar4 = src + sVar8;
    uVar5 = 0;
    iVar10 = 3;
    iVar3 = 0;
    puVar6 = dst;
    while (pbVar4 != src) {
      uVar7 = (uint)*src - 10;
      if ((0x16 < (uVar7 & 0xff)) || ((0x400009U >> (uVar7 & 0x1f) & 1) == 0)) {
        uVar7 = uVar5 << 6;
        iVar3 = iVar3 + 1;
        iVar10 = iVar10 - (uint)(
                                 "\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f>\x7f\x7f\x7f?456789:;<=\x7f\x7f\x7f@\x7f\x7f\x7f"
                                 [(uint)*src] == 0x40);
        uVar5 = (uint)
                      "\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f>\x7f\x7f\x7f?456789:;<=\x7f\x7f\x7f@\x7f\x7f\x7f"
                      [(uint)*src] & 0x3f | uVar7;
        if ((iVar3 == 4) && (iVar3 = 0, iVar10 != 0)) {
          *puVar6 = (uchar)(uVar7 >> 0x10);
          if (iVar10 == 1) {
            puVar6 = puVar6 + 1;
          }
          else {
            puVar6[1] = (uchar)(uVar7 >> 8);
            if (iVar10 == 2) {
              puVar6 = puVar6 + 2;
            }
            else {
              puVar6[2] = (uchar)uVar5;
              puVar6 = puVar6 + 3;
            }
          }
        }
      }
      src = src + 1;
    }
    *(uchar **)olen = puVar6 + -(int)dst;
  }
  return 0;
}



double modf(double __x,double *__iptr)

{
  double *in_a1;
  double **in_a2;
  uint uVar1;
  uint uVar2;
  double in_fa0;
  DFtype DVar3;
  
  uVar1 = (int)in_a1 >> 0x14 & 0x7ff;
  uVar2 = uVar1 - 0x3ff;
  if ((int)uVar2 < 0x14) {
    if ((int)uVar2 < 0) {
      *in_a2 = (double *)0x0;
      in_a2[1] = (double *)((uint)in_a1 & 0x80000000);
      return in_fa0;
    }
    uVar1 = 0xfffff >> (uVar2 & 0x1f);
    if ((uVar1 & (uint)in_a1 | (uint)__iptr) != 0) {
      in_a1 = (double *)(~uVar1 & (uint)in_a1);
      __iptr = (double *)0x0;
LAB_2306c840:
      *in_a2 = __iptr;
      in_a2[1] = in_a1;
      DVar3 = __subdf3();
      return (double)DVar3;
    }
  }
  else {
    if (((int)uVar2 < 0x34) &&
       (uVar1 = 0xffffffff >> (uVar1 - 0x413 & 0x1f), (uVar1 & (uint)__iptr) != 0)) {
      __iptr = (double *)(~uVar1 & (uint)__iptr);
      goto LAB_2306c840;
    }
  }
  in_a2[1] = in_a1;
  *in_a2 = __iptr;
  return in_fa0;
}



DItype __lshrdi3(shift_count_type b)

{
  DItype in_fa0;
  
  return in_fa0;
}



int __clzsi2(USItype x)

{
  int iVar1;
  
  if (x < 0x10000) {
    iVar1 = (uint)(0xff < x) << 3;
  }
  else {
    iVar1 = 0x10;
    if (0xffffff < x) {
      iVar1 = 0x18;
    }
  }
  return (0x20 - iVar1) - (uint)""[x >> iVar1];
}



SFtype __floatundisf(void)

{
  USItype in_a0;
  SFtype SVar1;
  uint in_a1;
  
  if ((0x1fffff < in_a1) && ((in_a0 & 0x7ff) != 0)) {
    in_a0 = in_a0 & 0xfffff800 | 0x800;
  }
  __floatunsidf(in_a1);
  __muldf3();
  __floatunsidf(in_a0);
  __adddf3();
  SVar1 = __truncdfsf2();
  return SVar1;
}



// WARNING: Type propagation algorithm not settling

DItype __divdi3(void)

{
  DItype in_fa0;
  
  return in_fa0;
}



// WARNING: Type propagation algorithm not settling

DItype __moddi3(void)

{
  DItype in_fa0;
  
  return in_fa0;
}



// WARNING: Type propagation algorithm not settling

UDItype __udivdi3(void)

{
  UDItype in_fa0;
  
  return in_fa0;
}



// WARNING: Type propagation algorithm not settling

UDItype __umoddi3(void)

{
  UDItype in_fa0;
  
  return in_fa0;
}


/*
Unable to decompile '__adddf3'
Cause: Exception while decompiling 2306daa4: Decompiler process died

*/

/*
Unable to decompile '__divdf3'
Cause: 
Low-level Error: Assignment to constant at r0x2306ec28
*/


__gcc_CMPtype __eqdf2(void)

{
  uint in_a0;
  uint in_a1;
  uint in_a2;
  uint in_a3;
  uint uVar1;
  uint uVar2;
  uint uVar3;
  
  uVar1 = in_a1 >> 0x14 & 0x7ff;
  uVar2 = in_a1 & 0xfffff;
  uVar3 = in_a3 >> 0x14 & 0x7ff;
  if (uVar1 == 0x7ff) {
    if ((uVar2 | in_a0) != 0) {
      return 1;
    }
    if (uVar3 != 0x7ff) {
      return 1;
    }
  }
  else {
    if (uVar3 != 0x7ff) goto LAB_2306eef8;
  }
  if ((in_a3 & 0xfffff | in_a2) != 0) {
    return 1;
  }
LAB_2306eef8:
  if (((uVar1 == uVar3) && (uVar2 == (in_a3 & 0xfffff))) && (in_a2 == in_a0)) {
    if (in_a1 >> 0x1f == in_a3 >> 0x1f) {
      return 0;
    }
    if (uVar1 == 0) {
      return (uint)((uVar2 | in_a2) != 0);
    }
  }
  return 1;
}



__gcc_CMPtype __gedf2(void)

{
  bool bVar1;
  uint in_a0;
  uint in_a1;
  int iVar2;
  uint in_a2;
  uint in_a3;
  int iVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  
  uVar6 = in_a1 >> 0x14 & 0x7ff;
  uVar7 = in_a1 & 0xfffff;
  uVar5 = in_a3 & 0xfffff;
  iVar2 = -((int)in_a1 >> 0x1f);
  uVar4 = in_a3 >> 0x14 & 0x7ff;
  iVar3 = -((int)in_a3 >> 0x1f);
  if (uVar6 == 0x7ff) {
    if ((uVar7 | in_a0) != 0) {
      return -2;
    }
    if (uVar4 == 0x7ff) {
LAB_2306efbc:
      if ((uVar5 | in_a2) != 0) {
        return -2;
      }
      goto LAB_2306efc4;
    }
LAB_2306f048:
    if (uVar4 == 0) {
      bVar1 = false;
LAB_2306efd4:
      if ((uVar5 | in_a2) == 0) {
        if (bVar1) {
          return 0;
        }
        goto LAB_2306efe8;
      }
      goto LAB_2306efdc;
    }
  }
  else {
    if (uVar4 == 0x7ff) goto LAB_2306efbc;
LAB_2306efc4:
    if (uVar6 != 0) goto LAB_2306f048;
    bVar1 = (uVar7 | in_a0) == 0;
    if (uVar4 == 0) goto LAB_2306efd4;
LAB_2306efdc:
    if (bVar1) {
      if (iVar3 != 0) {
        return iVar3;
      }
      return -1;
    }
  }
  if ((iVar2 == iVar3) && (uVar6 <= uVar4)) {
    if (uVar4 <= uVar6) {
      if (uVar5 < uVar7) goto LAB_2306efe8;
      if (uVar7 == uVar5) {
        if (in_a2 < in_a0) goto LAB_2306efe8;
        if (in_a2 <= in_a0) {
          return 0;
        }
      }
      else {
        if (uVar5 <= uVar7) {
          return 0;
        }
      }
    }
    if (iVar2 == 0) {
      return -1;
    }
    return iVar2;
  }
LAB_2306efe8:
  if (iVar2 != 0) {
    return -1;
  }
  return 1;
}



__gcc_CMPtype __ledf2(void)

{
  bool bVar1;
  uint in_a0;
  uint in_a1;
  int iVar2;
  uint in_a2;
  uint in_a3;
  int iVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  
  uVar6 = in_a1 >> 0x14 & 0x7ff;
  uVar7 = in_a1 & 0xfffff;
  uVar5 = in_a3 & 0xfffff;
  iVar2 = -((int)in_a1 >> 0x1f);
  uVar4 = in_a3 >> 0x14 & 0x7ff;
  iVar3 = -((int)in_a3 >> 0x1f);
  if (uVar6 == 0x7ff) {
    if ((uVar7 | in_a0) != 0) {
      return 2;
    }
    if (uVar4 == 0x7ff) {
LAB_2306f0a8:
      if ((uVar5 | in_a2) != 0) {
        return 2;
      }
      goto LAB_2306f0b0;
    }
LAB_2306f134:
    if (uVar4 == 0) {
      bVar1 = false;
LAB_2306f0c0:
      if ((uVar5 | in_a2) == 0) {
        if (bVar1) {
          return 0;
        }
        goto LAB_2306f0d4;
      }
      goto LAB_2306f0c8;
    }
  }
  else {
    if (uVar4 == 0x7ff) goto LAB_2306f0a8;
LAB_2306f0b0:
    if (uVar6 != 0) goto LAB_2306f134;
    bVar1 = (uVar7 | in_a0) == 0;
    if (uVar4 == 0) goto LAB_2306f0c0;
LAB_2306f0c8:
    if (bVar1) {
      if (iVar3 != 0) {
        return iVar3;
      }
      return -1;
    }
  }
  if ((iVar2 == iVar3) && (uVar6 <= uVar4)) {
    if (uVar4 <= uVar6) {
      if (uVar5 < uVar7) goto LAB_2306f0d4;
      if (uVar7 == uVar5) {
        if (in_a2 < in_a0) goto LAB_2306f0d4;
        if (in_a2 <= in_a0) {
          return 0;
        }
      }
      else {
        if (uVar5 <= uVar7) {
          return 0;
        }
      }
    }
    if (iVar2 == 0) {
      return -1;
    }
    return iVar2;
  }
LAB_2306f0d4:
  if (iVar2 != 0) {
    return -1;
  }
  return 1;
}


/*
Unable to decompile '__muldf3'
Cause: 
Low-level Error: Assignment to constant at r0x2306f3e8
*/

/*
Unable to decompile '__subdf3'
Cause: Exception while decompiling 2306f8dc: Decompiler process died

*/


SItype __fixdfsi(void)

{
  uint in_a0;
  uint in_a1;
  uint uVar1;
  uint uVar2;
  
  uVar1 = in_a1 >> 0x14 & 0x7ff;
  if (uVar1 < 0x3ff) {
    if ((uVar1 != 0) || (uVar2 = in_a1 & 0xfffff | in_a0, uVar2 != 0)) {
      uVar2 = 0;
    }
  }
  else {
    if (uVar1 < 0x41e) {
      uVar2 = in_a1 & 0xfffff | 0x100000;
      if ((int)(0x433 - uVar1) < 0x20) {
        uVar2 = uVar2 << (uVar1 - 0x413 & 0x1f) | in_a0 >> (0x433 - uVar1 & 0x1f);
      }
      else {
        uVar2 = uVar2 >> (0x413 - uVar1 & 0x1f);
      }
      if (-((int)in_a1 >> 0x1f) != 0) {
        uVar2 = -uVar2;
      }
    }
    else {
      uVar2 = -((int)in_a1 >> 0x1f) + 0x7fffffff;
    }
  }
  return uVar2;
}



USItype __fixunsdfsi(void)

{
  uint in_a0;
  USItype UVar1;
  uint in_a1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  
  uVar3 = in_a1 >> 0x14 & 0x7ff;
  if (uVar3 < 0x3ff) {
    if ((uVar3 == 0) && ((in_a1 & 0xfffff | in_a0) == 0)) {
      return 0;
    }
    UVar1 = 0;
  }
  else {
    if ((int)in_a1 < 0) {
      UVar1 = 0;
    }
    else {
      if (uVar3 < 0x41f) {
        uVar5 = in_a1 & 0xfffff | 0x100000;
        uVar2 = 0x433 - uVar3;
        if ((int)uVar2 < 0x20) {
          uVar4 = in_a0 << (uVar3 - 0x413 & 0x1f);
          UVar1 = uVar5 << (uVar3 - 0x413 & 0x1f) | in_a0 >> (uVar2 & 0x1f);
        }
        else {
          uVar4 = 0;
          if (uVar2 != 0x20) {
            uVar4 = uVar5 << (uVar3 - 0x3f3 & 0x1f);
          }
          uVar4 = uVar4 | in_a0;
          UVar1 = uVar5 >> (0x413 - uVar3 & 0x1f);
        }
        if (uVar4 == 0) {
          return UVar1;
        }
      }
      else {
        UVar1 = 0xffffffff;
      }
    }
  }
  return UVar1;
}



DFtype __floatsidf(SItype i)

{
  DFtype in_fa0;
  
  if (i != 0) {
    __clzsi2((i >> 0x1f ^ i) - (i >> 0x1f));
  }
  return in_fa0;
}



DFtype __floatunsidf(USItype i)

{
  DFtype in_fa0;
  
  if (i != 0) {
    __clzsi2(i);
  }
  return in_fa0;
}


/*
Unable to decompile '__extendsfdf2'
Cause: Exception while decompiling 23070708: Decompiler process died

*/


SFtype __truncdfsf2(void)

{
  uint uVar1;
  SFtype in_a0;
  uint in_a1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;
  int in_frm;
  
  uVar1 = in_a1 >> 0x14 & 0x7ff;
  uVar3 = (uint)in_a0 >> 0x1d | (in_a1 & 0xfffff) << 3;
  uVar5 = (int)in_a0 << 3;
  if ((uVar1 + 1 & 0x7fe) == 0) {
    uVar3 = uVar3 | uVar5;
    if (uVar1 == 0) {
      uVar1 = (uint)(uVar3 != 0);
LAB_23070968:
      if (uVar1 == 0) {
        return in_a0;
      }
LAB_2307096c:
      if (((((uVar1 * 2 & 7) != 0) && (in_frm != 2)) && (in_frm != 3)) && (in_frm == 0)) {
        in_a0 = 0.00000000;
      }
    }
    else {
      if (uVar3 == 0) {
        return in_a0;
      }
      uVar1 = 0;
    }
  }
  else {
    iVar6 = uVar1 - 0x380;
    if (0xfe < iVar6) {
      if (in_frm == 0) {
        return in_a0;
      }
      if (in_frm == 3) {
        if (-1 < (int)in_a1) {
          return in_a0;
        }
      }
      else {
        if ((in_frm == 2) && ((int)in_a1 < 0)) {
          return in_a0;
        }
      }
      goto LAB_23070878;
    }
    if (iVar6 < 1) {
      if (-0x18 < iVar6) {
        uVar3 = uVar3 | 0x800000;
        uVar2 = 0x1e - iVar6;
        if ((int)uVar2 < 0x20) {
          uVar1 = uVar5 >> (uVar2 & 0x1f) |
                  (uint)(uVar5 << (uVar1 - 0x37e & 0x1f) != 0) | uVar3 << (uVar1 - 0x37e & 0x1f);
        }
        else {
          in_a0 = 0.00000000;
          uVar4 = 0;
          if (uVar2 != 0x20) {
            uVar4 = uVar3 << (uVar1 - 0x35e & 0x1f);
          }
          uVar1 = uVar3 >> (-iVar6 - 2U & 0x1f) | (uint)((uVar4 | uVar5) != 0);
        }
        goto LAB_23070968;
      }
      uVar1 = 1;
      goto LAB_2307096c;
    }
    in_a0 = (SFtype)(uint)(((uint)in_a0 & 0x3ffffff) != 0);
    uVar1 = (uint)in_a0 | uVar5 >> 0x1d;
  }
  if ((uVar1 & 7) == 0) {
    return in_a0;
  }
LAB_23070878:
  if (((in_frm != 2) && (in_frm != 3)) && (in_frm == 0)) {
    in_a0 = 0.00000000;
  }
  return in_a0;
}



int atoi(char *__nptr)

{
  long lVar1;
  
  lVar1 = strtol(__nptr,(char **)0x0,10);
  return lVar1;
}



void _atoi_r(void)

{
  _strtol_r(0,10);
  return;
}



undefined * __errno(void)

{
  return _impure_ptr;
}



void * memchr(void *__s,int __c,size_t __n)

{
  byte bVar1;
  uint uVar2;
  uint uVar3;
  uint *puVar4;
  uint uVar5;
  
  uVar5 = __c & 0xff;
  if (((uint)__s & 3) != 0) {
    if (__n == 0) {
      return (void *)0x0;
    }
    bVar1 = *(byte *)__s;
    __n = __n - 1;
    while( true ) {
      if ((uint)bVar1 == uVar5) {
        return (uint *)__s;
      }
      __s = (void *)((int)__s + 1);
      if (((uint)__s & 3) == 0) break;
      __n = __n - 1;
      if (__n == 0xffffffff) {
        return (void *)0x0;
      }
      bVar1 = *(byte *)__s;
    }
  }
  if (3 < __n) {
    uVar2 = (__c & 0xffU) << 8 | __c & 0xffU;
    do {
      uVar3 = (uVar2 << 0x10 | uVar2) ^ *(uint *)__s;
      if ((uVar3 + 0xfefefeff & ~uVar3 & 0x80808080) != 0) goto LAB_23070b64;
      __n = __n - 4;
      __s = (uint *)__s + 1;
    } while (3 < __n);
  }
  if (__n != 0) {
LAB_23070b64:
    if ((uint)*(byte *)__s == uVar5) {
      return (uint *)__s;
    }
    puVar4 = (uint *)((int)__s + __n);
    while (__s = (void *)((int)__s + 1), puVar4 != (uint *)__s) {
      if ((uint)*(byte *)__s == uVar5) {
        return (uint *)__s;
      }
    }
  }
  return (void *)0x0;
}



int memcmp(void *__s1,void *__s2,size_t __n)

{
  int *piVar1;
  uint uVar2;
  uint uVar3;
  
  if (3 < __n) {
    if ((((uint)__s1 | (uint)__s2) & 3) != 0) goto LAB_23070c30;
    do {
      if (*(int *)__s1 != *(int *)__s2) goto LAB_23070c30;
      __n = __n - 4;
      __s1 = (int *)__s1 + 1;
      __s2 = (int *)__s2 + 1;
    } while (3 < __n);
  }
  if (__n == 0) {
    return 0;
  }
LAB_23070c30:
  uVar3 = (uint)*(byte *)__s1;
  uVar2 = (uint)*(byte *)__s2;
  if (uVar3 == uVar2) {
    piVar1 = (int *)((int)__s1 + __n);
    do {
      __s1 = (void *)((int)__s1 + 1);
      __s2 = (void *)((int)__s2 + 1);
      if ((int *)__s1 == piVar1) {
        return 0;
      }
      uVar3 = (uint)*(byte *)__s1;
      uVar2 = (uint)*(byte *)__s2;
    } while (uVar3 == uVar2);
  }
  return uVar3 - uVar2;
}



void * memcpy(void *__dest,void *__src,size_t __n)

{
  undefined uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 *puVar4;
  undefined4 *puVar5;
  undefined4 uVar6;
  undefined4 *puVar7;
  uint uVar8;
  undefined4 *puVar9;
  undefined4 *puVar10;
  int iVar11;
  undefined4 uVar12;
  undefined4 *puVar13;
  undefined4 uVar14;
  undefined4 uVar15;
  undefined4 uVar16;
  undefined4 uVar17;
  
  puVar13 = (undefined4 *)((int)__dest + __n);
  if (((((uint)__src ^ (uint)__dest) & 3) == 0) && (3 < __n)) {
    uVar8 = (uint)__dest & 3;
    puVar5 = (undefined4 *)__dest;
    while (puVar4 = (undefined4 *)__src, puVar7 = puVar5, uVar8 != 0) {
      puVar7 = (undefined4 *)((int)puVar5 + 1);
      *(undefined *)puVar5 = *(undefined *)__src;
      puVar4 = (undefined4 *)((int)__src + 1);
      if (((uint)puVar7 & 3) == 0) break;
      uVar8 = (uint)(undefined4 *)((int)puVar5 + 2) & 3;
      *(undefined *)((int)puVar5 + 1) = *(undefined *)puVar4;
      __src = (void *)((int)__src + 2);
      puVar5 = (undefined4 *)((int)puVar5 + 2);
    }
    puVar5 = (undefined4 *)((uint)puVar13 & 0xfffffffc);
    __src = puVar4;
    while (puVar7 < puVar5 + -8) {
      uVar2 = ((undefined4 *)__src)[1];
      uVar17 = ((undefined4 *)__src)[2];
      uVar16 = ((undefined4 *)__src)[3];
      uVar15 = ((undefined4 *)__src)[4];
      uVar14 = ((undefined4 *)__src)[5];
      uVar3 = ((undefined4 *)__src)[6];
      uVar12 = ((undefined4 *)__src)[7];
      *puVar7 = *(undefined4 *)__src;
      uVar6 = ((undefined4 *)__src)[8];
      puVar7[1] = uVar2;
      puVar7[2] = uVar17;
      puVar7[3] = uVar16;
      puVar7[4] = uVar15;
      puVar7[5] = uVar14;
      puVar7[6] = uVar3;
      puVar7[7] = uVar12;
      puVar7[8] = uVar6;
      __src = (undefined4 *)__src + 9;
      puVar7 = puVar7 + 9;
    }
    puVar4 = (undefined4 *)__src;
    puVar9 = puVar7;
    if (puVar7 < puVar5) {
      do {
        puVar10 = puVar9 + 1;
        *puVar9 = *puVar4;
        puVar4 = puVar4 + 1;
        puVar9 = puVar10;
      } while (puVar10 < puVar5);
      iVar11 = ((int)puVar5 + (-1 - (int)puVar7) & 0xfffffffcU) + 4;
      puVar7 = (undefined4 *)((int)puVar7 + iVar11);
      __src = (void *)((int)__src + iVar11);
    }
    if (puVar7 < puVar13) {
LAB_23070cf4:
      do {
        uVar1 = *(undefined *)__src;
        puVar5 = (undefined4 *)((int)puVar7 + 1);
        __src = (void *)((int)__src + 1);
        *(undefined *)puVar7 = uVar1;
        puVar7 = puVar5;
      } while (puVar5 < puVar13);
      return __dest;
    }
  }
  else {
    puVar7 = (undefined4 *)__dest;
    if (__dest < puVar13) goto LAB_23070cf4;
  }
  return __dest;
}



void * memmove(void *__dest,void *__src,size_t __n)

{
  int iVar1;
  undefined *puVar2;
  undefined4 *puVar3;
  undefined *puVar4;
  undefined4 *puVar5;
  undefined4 *puVar6;
  uint uVar7;
  
  if ((__src < __dest) && (puVar4 = (undefined *)((int)__src + __n), __dest < puVar4)) {
    puVar2 = (undefined *)((int)__dest + __n);
    if (__n == 0) {
      return __dest;
    }
    do {
      puVar4 = puVar4 + -1;
      puVar2 = puVar2 + -1;
      *puVar2 = *puVar4;
    } while ((undefined *)__src != puVar4);
    return __dest;
  }
  uVar7 = __n;
  puVar5 = (undefined4 *)__dest;
  if (0xf < __n) {
    if ((((uint)__src | (uint)__dest) & 3) != 0) {
      iVar1 = __n - 1;
      goto LAB_23070dd8;
    }
    iVar1 = (__n - 0x10 & 0xfffffff0) + 0x10;
    puVar3 = (undefined4 *)__src;
    puVar6 = (undefined4 *)__dest;
    do {
      puVar5 = puVar6 + 4;
      *puVar6 = *puVar3;
      puVar6[1] = puVar3[1];
      puVar6[2] = puVar3[2];
      puVar6[3] = puVar3[3];
      puVar3 = puVar3 + 4;
      puVar6 = puVar5;
    } while ((undefined4 *)((int)__dest + iVar1) != puVar5);
    __src = (void *)((int)__src + iVar1);
    uVar7 = __n & 0xf;
    puVar3 = (undefined4 *)__src;
    if ((__n & 0xc) != 0) {
      do {
        puVar3 = puVar3 + 1;
        *puVar6 = *puVar3;
        puVar3 = puVar3;
        puVar6 = puVar6 + 1;
      } while (3 < (int)__src + (uVar7 - (int)puVar3));
      iVar1 = (uVar7 - 4 & 0xfffffffc) + 4;
      __src = (void *)((int)__src + iVar1);
      uVar7 = __n & 3;
      puVar5 = (undefined4 *)((int)puVar5 + iVar1);
    }
  }
  iVar1 = uVar7 - 1;
  if (uVar7 == 0) {
    return __dest;
  }
LAB_23070dd8:
  puVar3 = puVar5;
  do {
    puVar6 = (undefined4 *)((int)puVar3 + 1);
    *(undefined *)puVar3 = *(undefined *)__src;
    __src = (undefined4 *)((int)__src + 1);
    puVar3 = puVar6;
  } while (puVar6 != (undefined4 *)((int)puVar5 + iVar1 + 1));
  return __dest;
}



void * memset(void *__s,int __c,size_t __n)

{
  uint uVar1;
  uint extraout_a1;
  uint *puVar2;
  uint *puVar3;
  void *pvVar4;
  uint uVar5;
  
  uVar1 = 0xf;
  if (0xf < __n) {
    uVar5 = (uint)__s & 0xf;
    puVar3 = (uint *)__s;
    if (uVar5 != 0) {
      pvVar4 = __s;
      __s = (void *)(*(code *)(uVar5 * 4 + 0x23070f0c))();
      puVar3 = (uint *)((int)pvVar4 - (uVar5 - 0x10));
      __n = __n + (uVar5 - 0x10);
      __c = extraout_a1;
      if (__n <= uVar1) goto LAB_23070efc;
    }
    if (__c != 0) {
      uVar5 = __c & 0xffU | (__c & 0xffU) << 8;
      __c = uVar5 | uVar5 << 0x10;
    }
    uVar5 = __n & 0xfffffff0;
    __n = __n & 0xf;
    puVar2 = (uint *)(uVar5 + (int)puVar3);
    do {
      *puVar3 = __c;
      puVar3[1] = __c;
      puVar3[2] = __c;
      puVar3[3] = __c;
      puVar3 = puVar3 + 4;
    } while (puVar3 < puVar2);
    if (__n == 0) {
      return __s;
    }
  }
LAB_23070efc:
                    // WARNING: Could not recover jumptable at 0x23070f0c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar4 = (void *)(*(code *)(&UNK_23070f10 + (uVar1 - __n) * 4))();
  return pvVar4;
}



char * strchr(char *__s,int __c)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  
  uVar3 = __c & 0xff;
  if (uVar3 == 0) {
    if (((uint)__s & 3) != 0) {
      if (*__s == '\0') {
        return __s;
      }
      while (__s = (char *)((int)__s + 1), ((uint)__s & 3) != 0) {
        if (*__s == '\0') {
          return (char *)(uint *)__s;
        }
      }
    }
    uVar3 = *(uint *)__s + 0xfefefeff & ~*(uint *)__s;
    while ((uVar3 & 0x80808080) == 0) {
      __s = (char *)((uint *)__s + 1);
      uVar3 = *(uint *)__s + 0xfefefeff & ~*(uint *)__s;
    }
    if (*__s != '\0') {
      do {
        __s = (char *)((int)__s + 1);
      } while (*__s != '\0');
      return __s;
    }
    return (char *)(uint *)__s;
  }
  if (((uint)__s & 3) != 0) {
    if (*__s == 0) {
      return (char *)0x0;
    }
    if (uVar3 == (uint)(byte)*__s) {
      return __s;
    }
    while (__s = (char *)((int)__s + 1), ((uint)__s & 3) != 0) {
      if (*__s == 0) {
        return (char *)0x0;
      }
      if ((uint)(byte)*__s == uVar3) {
        return (char *)(uint *)__s;
      }
    }
  }
  uVar1 = __c & 0xffU | (__c & 0xffU) << 8;
  uVar4 = *(uint *)__s;
  uVar1 = uVar1 << 0x10 | uVar1;
  uVar2 = uVar1 ^ uVar4;
  uVar2 = ~uVar4 & uVar4 + 0xfefefeff | ~uVar2 & uVar2 + 0xfefefeff;
  while ((uVar2 & 0x80808080) == 0) {
    __s = (char *)((uint *)__s + 1);
    uVar4 = *(uint *)__s;
    uVar2 = uVar4 ^ uVar1;
    uVar2 = uVar4 + 0xfefefeff & ~uVar4 | uVar2 + 0xfefefeff & ~uVar2;
  }
  if (*__s != 0) {
    if (uVar3 == (uint)(byte)*__s) {
      return (char *)(uint *)__s;
    }
    while( true ) {
      __s = (char *)((int)__s + 1);
      if (*__s == 0) break;
      if ((uint)(byte)*__s == uVar3) {
        return __s;
      }
    }
  }
  return (char *)0x0;
}



int strcmp(char *__s1,char *__s2)

{
  byte bVar1;
  byte bVar2;
  uint uVar3;
  uint uVar4;
  
  if ((((uint)__s1 | (uint)__s2) & 3) == 0) {
    do {
      uVar3 = *(uint *)__s1;
      uVar4 = *(uint *)__s2;
      if (((uVar3 & 0x7f7f7f7f) + 0x7f7f7f7f | uVar3 | 0x7f7f7f7f) != 0xffffffff) {
LAB_23071234:
        if (uVar3 == uVar4) {
          return 0;
        }
        goto LAB_2307120c;
      }
      if (uVar3 != uVar4) break;
      uVar3 = ((uint *)__s1)[1];
      uVar4 = ((uint *)__s2)[1];
      if (((uVar3 & 0x7f7f7f7f) + 0x7f7f7f7f | uVar3 | 0x7f7f7f7f) != 0xffffffff) {
        __s1 = (char *)((uint *)__s1 + 1);
        __s2 = (char *)((uint *)__s2 + 1);
        goto LAB_23071234;
      }
      if (uVar3 != uVar4) break;
      uVar3 = ((uint *)__s1)[2];
      uVar4 = ((uint *)__s2)[2];
      if (((uVar3 & 0x7f7f7f7f) + 0x7f7f7f7f | uVar3 | 0x7f7f7f7f) != 0xffffffff) {
        __s1 = (char *)((uint *)__s1 + 2);
        __s2 = (char *)((uint *)__s2 + 2);
        if (uVar3 == uVar4) {
          return 0;
        }
        goto LAB_2307120c;
      }
      if (uVar3 != uVar4) break;
      uVar3 = ((uint *)__s1)[3];
      uVar4 = ((uint *)__s2)[3];
      if (((uVar3 & 0x7f7f7f7f) + 0x7f7f7f7f | uVar3 | 0x7f7f7f7f) != 0xffffffff) {
        __s1 = (char *)((uint *)__s1 + 3);
        __s2 = (char *)((uint *)__s2 + 3);
        if (uVar3 == uVar4) {
          return 0;
        }
        goto LAB_2307120c;
      }
      if (uVar3 != uVar4) break;
      uVar3 = ((uint *)__s1)[4];
      uVar4 = ((uint *)__s2)[4];
      if (((uVar3 & 0x7f7f7f7f) + 0x7f7f7f7f | uVar3 | 0x7f7f7f7f) != 0xffffffff) {
        __s1 = (char *)((uint *)__s1 + 4);
        __s2 = (char *)((uint *)__s2 + 4);
        if (uVar3 == uVar4) {
          return 0;
        }
        goto LAB_2307120c;
      }
      __s1 = (char *)((uint *)__s1 + 5);
      __s2 = (char *)((uint *)__s2 + 5);
    } while (uVar3 == uVar4);
    if (uVar3 << 0x10 == uVar4 << 0x10) {
      uVar3 = uVar3 >> 0x10;
      uVar4 = uVar4 >> 0x10;
      if ((uVar3 - uVar4 & 0xff) == 0) {
        return uVar3 - uVar4;
      }
    }
    else {
      uVar3 = uVar3 & 0xffff;
      uVar4 = uVar4 & 0xffff;
      if ((uVar3 - uVar4 & 0xff) == 0) {
        return uVar3 - uVar4;
      }
    }
    return (uVar3 & 0xff) - (uVar4 & 0xff);
  }
LAB_2307120c:
  do {
    bVar1 = *__s1;
    bVar2 = *__s2;
    __s1 = (char *)((int)__s1 + 1);
    __s2 = (char *)((int)__s2 + 1);
    if ((uint)bVar1 != (uint)bVar2) break;
  } while (bVar1 != 0);
  return (uint)bVar1 - (uint)bVar2;
}



char * strcpy(char *__dest,char *__src)

{
  char cVar1;
  char cVar2;
  char cVar3;
  uint *puVar4;
  uint uVar5;
  uint uVar6;
  char *pcVar7;
  
  pcVar7 = __dest;
  if ((((uint)__dest | (uint)__src) & 3) != 0) {
    do {
      cVar1 = *__src;
      __src = __src + 1;
      *pcVar7 = cVar1;
      pcVar7 = pcVar7 + 1;
    } while (cVar1 != '\0');
    return __dest;
  }
  uVar5 = *(uint *)__src;
  uVar6 = (uVar5 & 0x7f7f7f7f) + 0x7f7f7f7f | uVar5;
  puVar4 = (uint *)__dest;
  while ((uVar6 | 0x7f7f7f7f) == 0xffffffff) {
    __src = (char *)((uint *)__src + 1);
    *puVar4 = uVar5;
    uVar5 = *(uint *)__src;
    uVar6 = (uVar5 & 0x7f7f7f7f) + 0x7f7f7f7f | uVar5;
    puVar4 = puVar4 + 1;
  }
  cVar1 = *__src;
  cVar2 = *(char *)((int)__src + 1);
  cVar3 = *(char *)((int)__src + 2);
  *(char *)puVar4 = cVar1;
  if (((cVar1 != '\0') && (*(char *)((int)puVar4 + 1) = cVar2, cVar2 != '\0')) &&
     (*(char *)((int)puVar4 + 2) = cVar3, cVar3 != '\0')) {
    *(char *)((int)puVar4 + 3) = '\0';
    return __dest;
  }
  return __dest;
}



size_t strlen(char *__s)

{
  char cVar1;
  uint *puVar2;
  uint *puVar3;
  uint uVar4;
  
  uVar4 = (uint)__s & 3;
  puVar3 = (uint *)__s;
  while (uVar4 != 0) {
    cVar1 = *(char *)puVar3;
    puVar3 = (uint *)((int)puVar3 + 1);
    uVar4 = (uint)puVar3 & 3;
    if (cVar1 == '\0') {
      return (int)puVar3 + (-1 - (int)__s);
    }
  }
  do {
    puVar2 = puVar3;
    puVar3 = puVar2 + 1;
  } while (((*puVar2 & 0x7f7f7f7f) + 0x7f7f7f7f | *puVar2 | 0x7f7f7f7f) == 0xffffffff);
  puVar3 = (uint *)((int)(puVar2 + 1) - (int)__s);
  if (*(char *)puVar2 != '\0') {
    if (*(char *)((int)puVar2 + 1) != '\0') {
      return (int)puVar3 + ((uint)(*(char *)((int)puVar2 + 2) != '\0') - 2);
    }
    return (size_t)((int)puVar3 + -3);
  }
  return (size_t)(puVar3 + -1);
}



int strncmp(char *__s1,char *__s2,size_t __n)

{
  int iVar1;
  uint *puVar2;
  uint uVar3;
  uint uVar4;
  
  if (__n == 0) {
    return 0;
  }
  if (((((uint)__s1 | (uint)__s2) & 3) == 0) && (3 < __n)) {
    uVar4 = *(uint *)__s1;
    if (uVar4 != *(uint *)__s2) {
LAB_23071494:
      uVar3 = (uint)(byte)*__s1;
      uVar4 = (uint)(byte)*__s2;
      iVar1 = __n - 1;
      if (uVar4 == uVar3) goto LAB_23071458;
      goto LAB_23071484;
    }
    __n = __n - 4;
    if (__n == 0) {
      return 0;
    }
    uVar4 = uVar4 + 0xfefefeff & ~uVar4;
    while( true ) {
      if ((uVar4 & 0x80808080) != 0) {
        return 0;
      }
      __s1 = (char *)((uint *)__s1 + 1);
      __s2 = (char *)((uint *)__s2 + 1);
      if (__n < 4) break;
      uVar3 = *(uint *)__s1;
      uVar4 = uVar3 + 0xfefefeff & ~uVar3;
      if (uVar3 != *(uint *)__s2) goto LAB_23071494;
      __n = __n - 4;
      if (__n == 0) {
        return 0;
      }
    }
  }
  uVar3 = (uint)(byte)*__s1;
  uVar4 = (uint)(byte)*__s2;
  iVar1 = __n - 1;
  if (uVar4 == uVar3) {
    if (iVar1 == 0) {
      return 0;
    }
LAB_23071458:
    if (uVar3 != 0) {
      puVar2 = (uint *)((int)__s1 + iVar1);
      do {
        __s1 = (char *)((int)__s1 + 1);
        __s2 = (char *)((int)__s2 + 1);
        uVar3 = (uint)(byte)*__s1;
        uVar4 = (uint)(byte)*__s2;
        if (uVar3 != uVar4) goto LAB_23071484;
      } while ((puVar2 != (uint *)__s1) && (*__s1 != 0));
    }
    return 0;
  }
LAB_23071484:
  return uVar3 - uVar4;
}



char * strncpy(char *__dest,char *__src,size_t __n)

{
  char cVar1;
  uint uVar2;
  uint *puVar3;
  uint *puVar4;
  char *pcVar5;
  char *pcVar6;
  char *pcVar7;
  int iVar8;
  
  puVar3 = (uint *)__dest;
  if (((((uint)__src | (uint)__dest) & 3) == 0) && (puVar4 = (uint *)__dest, 3 < __n)) {
    do {
      uVar2 = *(uint *)__src;
      if ((uVar2 + 0xfefefeff & ~uVar2 & 0x80808080) != 0) goto LAB_230714c4;
      puVar3 = puVar4 + 1;
      __n = __n - 4;
      *puVar4 = uVar2;
      __src = (char *)((uint *)__src + 1);
      puVar4 = puVar3;
    } while (3 < __n);
  }
  puVar4 = puVar3;
  if (__n != 0) {
LAB_230714c4:
    cVar1 = *__src;
    *(char *)puVar4 = cVar1;
    pcVar5 = (char *)((int)puVar4 + 1);
    iVar8 = __n - 1;
    if (cVar1 != '\0') {
      pcVar6 = pcVar5;
      do {
        __src = (char *)((int)__src + 1);
        iVar8 = (__n - 1) - (int)pcVar6;
        if (pcVar6 == (char *)((int)puVar4 + __n)) {
          return __dest;
        }
        cVar1 = *__src;
        pcVar5 = pcVar6 + 1;
        *pcVar6 = cVar1;
        pcVar6 = pcVar5;
        iVar8 = (int)puVar4 + iVar8;
      } while (cVar1 != '\0');
    }
    pcVar6 = pcVar5;
    if (iVar8 == 0) {
      return __dest;
    }
    do {
      pcVar7 = pcVar6 + 1;
      *pcVar6 = '\0';
      pcVar6 = pcVar7;
    } while (pcVar7 != pcVar5 + iVar8);
  }
  return __dest;
}



size_t strnlen(char *__string,size_t __maxlen)

{
  char *pcVar1;
  
  if (__maxlen != 0) {
    if (*__string == '\0') {
      __maxlen = 0;
    }
    else {
      pcVar1 = __string;
      while (pcVar1 = pcVar1 + 1, pcVar1 != __string + __maxlen) {
        if (*pcVar1 == '\0') {
          return (size_t)(pcVar1 + -(int)__string);
        }
      }
    }
  }
  return __maxlen;
}



char * strrchr(char *__s,int __c)

{
  char *pcVar1;
  char *pcVar2;
  
  if (__c != 0) {
    pcVar2 = (char *)0x0;
    while (pcVar1 = strchr(__s,__c), pcVar1 != (char *)0x0) {
      __s = pcVar1 + 1;
      pcVar2 = pcVar1;
    }
    return pcVar2;
  }
  pcVar2 = strchr(__s,0);
  return pcVar2;
}



byte * two_way_long_needle(int param_1,int param_2,byte *param_3,byte *param_4)

{
  byte bVar1;
  byte bVar2;
  int iVar3;
  size_t sVar4;
  byte *pbVar5;
  byte *pbVar6;
  byte *__n;
  byte *pbVar7;
  byte *pbVar8;
  byte **ppbVar9;
  byte *pbVar10;
  byte *pbVar11;
  byte *pbVar12;
  byte *pbVar13;
  byte *pbVar14;
  byte *local_440 [256];
  byte *apbStack64 [3];
  
  pbVar13 = (byte *)0x1;
  pbVar6 = (byte *)0x1;
  __n = (byte *)0x0;
  pbVar11 = (byte *)0xffffffff;
  do {
    pbVar14 = pbVar6 + (int)pbVar11;
    pbVar10 = pbVar6 + (int)__n;
    pbVar12 = __n;
    while( true ) {
      __n = pbVar10;
      if (param_4 <= __n) {
        pbVar6 = (byte *)0x1;
        __n = (byte *)0x1;
        pbVar14 = (byte *)0xffffffff;
        pbVar12 = (byte *)0x0;
        goto LAB_230716b8;
      }
      if (param_3[(int)pbVar14] <= param_3[(int)__n]) break;
      pbVar6 = (byte *)0x1;
      pbVar13 = __n + -(int)pbVar11;
      pbVar14 = pbVar11 + 1;
      pbVar10 = __n + 1;
      pbVar12 = __n;
    }
    if (param_3[(int)__n] == param_3[(int)pbVar14]) {
      if (pbVar6 == pbVar13) {
        pbVar6 = (byte *)0x1;
      }
      else {
        pbVar6 = pbVar6 + 1;
        __n = pbVar12;
      }
    }
    else {
      pbVar13 = (byte *)0x1;
      pbVar6 = (byte *)0x1;
      __n = pbVar12 + 1;
      pbVar11 = pbVar12;
    }
  } while( true );
LAB_230716b8:
  pbVar5 = __n + (int)pbVar14;
  pbVar7 = __n + (int)pbVar12;
  pbVar10 = pbVar12;
  while (pbVar12 = pbVar7, pbVar12 < param_4) {
    if (param_3[(int)pbVar12] <= param_3[(int)pbVar5]) goto LAB_2307188c;
    __n = (byte *)0x1;
    pbVar6 = pbVar12 + -(int)pbVar14;
    pbVar5 = pbVar14 + 1;
    pbVar7 = pbVar12 + 1;
    pbVar10 = pbVar12;
  }
  __n = pbVar11 + 1;
  if (pbVar11 + 1 <= pbVar14 + 1) {
    pbVar13 = pbVar6;
    __n = pbVar14 + 1;
  }
  ppbVar9 = local_440;
  do {
    *ppbVar9 = param_4;
    ppbVar9 = ppbVar9 + 1;
  } while (apbStack64 != ppbVar9);
  pbVar11 = param_4 + -1;
  pbVar6 = param_3;
  if (param_4 != (byte *)0x0) {
    do {
      bVar1 = *pbVar6;
      iVar3 = -(int)pbVar6;
      pbVar6 = pbVar6 + 1;
      local_440[bVar1] = param_3 + (int)(pbVar11 + iVar3);
    } while (pbVar6 != param_3 + (int)param_4);
  }
  iVar3 = memcmp(param_3,param_3 + (int)pbVar13,(size_t)__n);
  if (iVar3 != 0) {
    pbVar13 = param_4 + -(int)__n;
    if (param_4 + -(int)__n < __n) {
      pbVar13 = __n;
    }
    pbVar6 = __n + -1;
    pbVar12 = (byte *)0x0;
LAB_2307194c:
    pbVar14 = pbVar12 + param_1;
    pbVar10 = local_440[pbVar11[(int)pbVar14]];
    if (pbVar10 == (byte *)0x0) goto LAB_230719b0;
    do {
      pbVar12 = pbVar10 + (int)pbVar12;
      while( true ) {
        if (pbVar12 <= (byte *)(param_2 - (int)param_4)) goto LAB_2307194c;
        sVar4 = strnlen((char *)(param_1 + param_2),(uint)param_4 | 0x800);
        param_2 = param_2 + sVar4;
        if ((byte *)(param_2 - (int)param_4) < pbVar12) {
          return (byte *)0;
        }
        pbVar14 = pbVar12 + param_1;
        pbVar10 = local_440[pbVar11[(int)pbVar14]];
        if (pbVar10 != (byte *)0x0) break;
LAB_230719b0:
        if (__n < pbVar11) {
          pbVar10 = __n;
          if (__n[(int)pbVar14] == param_3[(int)__n]) {
            do {
              pbVar10 = pbVar10 + 1;
              if (pbVar11 <= pbVar10) goto LAB_230719f0;
            } while (param_3[(int)pbVar10] == pbVar10[(int)(pbVar12 + param_1)]);
          }
          pbVar12 = pbVar10 + (int)(pbVar12 + (1 - (int)__n));
        }
        else {
LAB_230719f0:
          if (pbVar6 == (byte *)0xffffffff) {
            return pbVar14;
          }
          if (pbVar6[(int)pbVar14] == param_3[(int)pbVar6]) {
            pbVar5 = param_3 + (int)(__n + -2);
            pbVar10 = __n + -2 + (int)(pbVar12 + param_1);
            do {
              if (pbVar5 == param_3 + -1) {
                return pbVar14;
              }
              bVar1 = *pbVar5;
              bVar2 = *pbVar10;
              pbVar5 = pbVar5 + -1;
              pbVar10 = pbVar10 + -1;
            } while (bVar1 == bVar2);
          }
          pbVar12 = pbVar13 + (int)(pbVar12 + 1);
        }
      }
    } while( true );
  }
  pbVar6 = __n + -1;
  pbVar12 = (byte *)0x0;
  pbVar14 = (byte *)0x0;
  do {
    pbVar5 = pbVar14 + param_1;
    pbVar10 = local_440[pbVar11[(int)pbVar5]];
    if (pbVar10 == (byte *)0x0) {
      pbVar10 = pbVar12;
      if (pbVar12 < __n) {
        pbVar10 = __n;
      }
      if (pbVar10 < pbVar11) {
        pbVar7 = pbVar10 + (int)(pbVar14 + param_1);
        pbVar8 = param_3 + (int)pbVar10;
        do {
          if (*pbVar7 != *pbVar8) {
            pbVar14 = pbVar14 + (1 - (int)__n);
            goto LAB_230717c4;
          }
          pbVar10 = pbVar10 + 1;
          pbVar7 = param_3 + (int)pbVar10;
          pbVar8 = pbVar10 + (int)(pbVar14 + param_1);
        } while (pbVar10 < pbVar11);
      }
      if ((pbVar12 < __n) &&
         (pbVar10 = pbVar6, pbVar6[(int)(pbVar14 + param_1)] == param_3[(int)pbVar6])) {
        do {
          pbVar7 = pbVar10;
          pbVar10 = pbVar7 + -1;
          if (pbVar12 == pbVar7) break;
        } while (param_3[(int)pbVar10] == pbVar10[(int)(pbVar14 + param_1)]);
        if (pbVar7 < pbVar12 + 1) {
          return pbVar5;
        }
      }
      else {
        if (__n < pbVar12 + 1) {
          return pbVar5;
        }
      }
      pbVar14 = pbVar13 + (int)pbVar14;
      pbVar12 = param_4 + -(int)pbVar13;
    }
    else {
      if ((pbVar12 != (byte *)0x0) && (pbVar10 < pbVar13)) {
        pbVar10 = param_4 + -(int)pbVar13;
      }
LAB_230717c4:
      pbVar14 = pbVar10 + (int)pbVar14;
      pbVar12 = (byte *)0x0;
    }
    if ((byte *)(param_2 - (int)param_4) < pbVar14) {
      sVar4 = strnlen((char *)(param_1 + param_2),(uint)param_4 | 0x800);
      param_2 = param_2 + sVar4;
      if ((byte *)(param_2 - (int)param_4) < pbVar14) {
        return (byte *)0;
      }
    }
  } while( true );
LAB_2307188c:
  if (param_3[(int)pbVar12] == param_3[(int)pbVar5]) {
    if (__n == pbVar6) {
      __n = (byte *)0x1;
    }
    else {
      __n = __n + 1;
      pbVar12 = pbVar10;
    }
  }
  else {
    pbVar6 = (byte *)0x1;
    __n = (byte *)0x1;
    pbVar14 = pbVar10;
    pbVar12 = pbVar10 + 1;
  }
  goto LAB_230716b8;
}



char * strstr(char *__haystack,char *__needle)

{
  byte bVar1;
  byte bVar2;
  char cVar3;
  size_t __n;
  size_t sVar4;
  int iVar5;
  uint __c;
  char *pcVar6;
  uint uVar7;
  byte *pbVar8;
  uint uVar9;
  char *pcVar10;
  byte abStack96 [68];
  
  __c = (uint)(byte)*__needle;
  if (*__needle != 0) {
    uVar7 = (uint)(byte)__needle[1];
    if (__needle[1] == 0) {
      __haystack = strchr(__haystack,__c);
    }
    else {
      bVar1 = __needle[2];
      if (bVar1 == 0) {
        uVar9 = (uint)(byte)*__haystack;
        if (*__haystack != 0) {
          bVar1 = __haystack[1];
          pcVar10 = __haystack + 1;
          while (pcVar6 = pcVar10, uVar9 = (uint)bVar1 | uVar9 << 0x10, bVar1 != 0) {
            bVar1 = pcVar6[1];
            pcVar10 = pcVar6 + 1;
            if ((__c << 0x10 | uVar7) == uVar9) {
              return pcVar6 + -1;
            }
          }
        }
      }
      else {
        if (__needle[3] == 0) {
          if (*__haystack != 0) {
            uVar9 = (uint)(byte)*__haystack << 8;
            bVar2 = __haystack[1];
            pcVar10 = __haystack + 1;
            while (pcVar6 = pcVar10, uVar9 = (bVar2 | uVar9) << 8, bVar2 != 0) {
              bVar2 = pcVar6[1];
              pcVar10 = pcVar6 + 1;
              if ((__c << 0x18 | uVar7 << 0x10 | (uint)bVar1 << 8) == uVar9) {
                return pcVar6 + -2;
              }
            }
          }
        }
        else {
          if (__needle[4] == '\0') {
            bVar2 = *__haystack;
            __c = __c << 0x18 | uVar7 << 0x10 | (uint)(byte)__needle[3] | (uint)bVar1 << 8;
            if (bVar2 != 0) {
              uVar7 = 0;
              do {
                pcVar10 = __haystack;
                uVar7 = (uint)bVar2 | uVar7 << 8;
                bVar2 = pcVar10[1];
                if (bVar2 == 0) {
                  if (__c != uVar7) goto LAB_23071c58;
                  break;
                }
                __haystack = pcVar10 + 1;
              } while (__c != uVar7);
              return pcVar10 + -3;
            }
          }
          else {
            __n = strlen(__needle);
            sVar4 = strnlen(__haystack,__n | 0x200);
            if (__n <= sVar4) {
              if (0xfe < __n) {
                pcVar10 = (char *)two_way_long_needle(__haystack,sVar4,__needle,__n);
                return pcVar10;
              }
              pcVar10 = __haystack + (sVar4 - __n);
              memset(abStack96,__n + 1,0x40);
              if (__n != 0) {
                pbVar8 = (byte *)__needle;
                do {
                  bVar1 = *pbVar8;
                  cVar3 = (char)pbVar8;
                  pbVar8 = pbVar8 + 1;
                  abStack96[(uint)bVar1 & 0x3f] = ((char)__needle + (char)__n) - cVar3;
                } while ((byte *)(__needle + __n) != pbVar8);
              }
              while( true ) {
                __haystack = __haystack + -1 + abStack96[(uint)(byte)(__haystack + -1)[__n] & 0x3f];
                while (__haystack <= pcVar10) {
                  bVar1 = abStack96[(uint)(byte)__haystack[__n] & 0x3f];
                  iVar5 = memcmp(__haystack,__needle,__n);
                  if (iVar5 == 0) {
                    return __haystack;
                  }
                  __haystack = __haystack + bVar1;
                }
                if (pcVar10[__n] == '\0') break;
                sVar4 = strnlen(pcVar10 + __n,0x800);
                pcVar10 = pcVar10 + sVar4;
                if (pcVar10 < __haystack) {
                  return (char *)0x0;
                }
              }
            }
          }
        }
      }
LAB_23071c58:
      __haystack = (char *)0x0;
    }
  }
  return __haystack;
}



uint _strtol_l_isra_0(undefined4 *param_1,byte *param_2,byte **param_3,uint param_4)

{
  byte bVar1;
  bool bVar2;
  uint uVar3;
  byte *pbVar4;
  uint uVar5;
  byte *pbVar6;
  uint uVar7;
  uint uVar8;
  int iVar9;
  uint uVar10;
  
  pbVar6 = param_2;
  do {
    pbVar4 = pbVar6;
    pbVar6 = pbVar4 + 1;
    bVar1 = *pbVar4;
    uVar7 = (uint)bVar1;
  } while ((_ctype_[uVar7 + 1] & 8) != 0);
  if (bVar1 == 0x2d) {
    uVar7 = (uint)*pbVar6;
    bVar2 = true;
    pbVar6 = pbVar4 + 2;
LAB_23071d58:
    if (param_4 != 0) goto LAB_23071d5c;
LAB_23071de0:
    if (uVar7 != 0x30) {
      uVar10 = 10;
      param_4 = 10;
      goto LAB_23071d68;
    }
    if ((*pbVar6 & 0xdf) != 0x58) {
      uVar10 = 8;
      param_4 = 8;
      goto LAB_23071d68;
    }
  }
  else {
    if (bVar1 != 0x2b) {
      bVar2 = false;
      goto LAB_23071d58;
    }
    uVar7 = (uint)*pbVar6;
    bVar2 = false;
    pbVar6 = pbVar4 + 2;
    if (param_4 == 0) goto LAB_23071de0;
LAB_23071d5c:
    uVar10 = param_4;
    if (param_4 != 0x10) goto LAB_23071d68;
    if ((uVar7 != 0x30) || ((*pbVar6 & 0xdf) != 0x58)) {
      uVar10 = 0x10;
      goto LAB_23071d68;
    }
  }
  uVar7 = (uint)pbVar6[1];
  uVar10 = 0x10;
  pbVar6 = pbVar6 + 2;
  param_4 = 0x10;
LAB_23071d68:
  uVar3 = 0x80000000;
  if (!bVar2) {
    uVar3 = 0x7fffffff;
  }
  iVar9 = 0;
  uVar5 = 0;
  do {
    uVar8 = uVar7 - 0x30;
    if (9 < uVar8) {
      if (uVar7 - 0x41 < 0x1a) {
        uVar8 = uVar7 - 0x37;
      }
      else {
        if (0x19 < uVar7 - 0x61) break;
        uVar8 = uVar7 - 0x57;
      }
    }
    if ((int)param_4 <= (int)uVar8) break;
    if (((iVar9 != -1) && (iVar9 = -1, uVar5 <= uVar3 / uVar10)) &&
       ((uVar3 / uVar10 != uVar5 || ((int)uVar8 <= (int)(uVar3 % uVar10))))) {
      iVar9 = 1;
      uVar5 = uVar8 + uVar10 * uVar5;
    }
    uVar7 = (uint)*pbVar6;
    pbVar6 = pbVar6 + 1;
  } while( true );
  if (iVar9 == -1) {
    *param_1 = 0x22;
    if (param_3 == (byte **)0x0) {
      return uVar3;
    }
  }
  else {
    uVar3 = uVar5;
    if (bVar2) {
      uVar3 = -uVar5;
    }
    if (param_3 == (byte **)0x0) {
      return uVar3;
    }
    if (iVar9 == 0) goto LAB_23071e1c;
  }
  param_2 = pbVar6 + -1;
LAB_23071e1c:
  *param_3 = param_2;
  return uVar3;
}



uint _strtol_r(undefined4 *param_1,byte *param_2,byte **param_3,uint param_4)

{
  byte bVar1;
  bool bVar2;
  uint uVar3;
  byte *pbVar4;
  uint uVar5;
  byte *pbVar6;
  uint uVar7;
  uint uVar8;
  int iVar9;
  uint uVar10;
  
  pbVar6 = param_2;
  do {
    pbVar4 = pbVar6;
    pbVar6 = pbVar4 + 1;
    bVar1 = *pbVar4;
    uVar7 = (uint)bVar1;
  } while ((_ctype_[uVar7 + 1] & 8) != 0);
  if (bVar1 == 0x2d) {
    uVar7 = (uint)*pbVar6;
    bVar2 = true;
    pbVar6 = pbVar4 + 2;
LAB_23071d58:
    if (param_4 != 0) goto LAB_23071d5c;
LAB_23071de0:
    if (uVar7 != 0x30) {
      uVar10 = 10;
      param_4 = 10;
      goto LAB_23071d68;
    }
    if ((*pbVar6 & 0xdf) != 0x58) {
      uVar10 = 8;
      param_4 = 8;
      goto LAB_23071d68;
    }
  }
  else {
    if (bVar1 != 0x2b) {
      bVar2 = false;
      goto LAB_23071d58;
    }
    uVar7 = (uint)*pbVar6;
    bVar2 = false;
    pbVar6 = pbVar4 + 2;
    if (param_4 == 0) goto LAB_23071de0;
LAB_23071d5c:
    uVar10 = param_4;
    if (param_4 != 0x10) goto LAB_23071d68;
    if ((uVar7 != 0x30) || ((*pbVar6 & 0xdf) != 0x58)) {
      uVar10 = 0x10;
      goto LAB_23071d68;
    }
  }
  uVar7 = (uint)pbVar6[1];
  uVar10 = 0x10;
  pbVar6 = pbVar6 + 2;
  param_4 = 0x10;
LAB_23071d68:
  uVar3 = 0x80000000;
  if (!bVar2) {
    uVar3 = 0x7fffffff;
  }
  iVar9 = 0;
  uVar5 = 0;
  do {
    uVar8 = uVar7 - 0x30;
    if (9 < uVar8) {
      if (uVar7 - 0x41 < 0x1a) {
        uVar8 = uVar7 - 0x37;
      }
      else {
        if (0x19 < uVar7 - 0x61) break;
        uVar8 = uVar7 - 0x57;
      }
    }
    if ((int)param_4 <= (int)uVar8) break;
    if (((iVar9 != -1) && (iVar9 = -1, uVar5 <= uVar3 / uVar10)) &&
       ((uVar3 / uVar10 != uVar5 || ((int)uVar8 <= (int)(uVar3 % uVar10))))) {
      iVar9 = 1;
      uVar5 = uVar8 + uVar10 * uVar5;
    }
    uVar7 = (uint)*pbVar6;
    pbVar6 = pbVar6 + 1;
  } while( true );
  if (iVar9 == -1) {
    *param_1 = 0x22;
    if (param_3 == (byte **)0x0) {
      return uVar3;
    }
  }
  else {
    uVar3 = uVar5;
    if (bVar2) {
      uVar3 = -uVar5;
    }
    if (param_3 == (byte **)0x0) {
      return uVar3;
    }
    if (iVar9 == 0) goto LAB_23071e1c;
  }
  param_2 = pbVar6 + -1;
LAB_23071e1c:
  *param_3 = param_2;
  return uVar3;
}



long strtol_l(char *__nptr,char **__endptr,int __base,__locale_t __loc)

{
  long lVar1;
  
  lVar1 = _strtol_l_isra_0(_impure_ptr,__nptr,__endptr,__base);
  return lVar1;
}



long strtol(char *__nptr,char **__endptr,int __base)

{
  long lVar1;
  
  lVar1 = _strtol_l_isra_0(_impure_ptr,__nptr,__endptr,__base);
  return lVar1;
}



int stat(char *__file,stat *__buf)

{
  int iVar1;
  
  iVar1 = _stat_r(_impure_ptr,__file,__buf);
  return iVar1;
}



void _stat_r(int *param_1,undefined4 param_2,undefined4 param_3)

{
  int iVar1;
  
  errno = 0;
  iVar1 = _stat(param_2,param_3);
  if ((iVar1 == -1) && (errno != 0)) {
    *param_1 = errno;
    return;
  }
  return;
}



int _stat(int param_1,undefined4 param_2)

{
  int *piVar1;
  undefined auStack144 [132];
  
  ecall();
  if (param_1 < 0) {
    piVar1 = (int *)__errno(auStack144,0,0,0,0,0x40e);
    *piVar1 = -param_1;
    param_1 = -1;
  }
  _conv_stat(param_2,auStack144);
  return param_1;
}



void _conv_stat(undefined2 *param_1,undefined4 *param_2)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  undefined4 uVar10;
  undefined4 uVar11;
  undefined4 uVar12;
  undefined4 uVar13;
  undefined4 uVar14;
  undefined4 uVar15;
  
  uVar3 = param_2[5];
  uVar1 = param_2[6];
  uVar15 = param_2[7];
  uVar14 = param_2[8];
  uVar13 = param_2[0xc];
  uVar12 = param_2[0x10];
  uVar2 = param_2[0xe];
  uVar10 = param_2[0x12];
  uVar11 = param_2[0x13];
  uVar6 = param_2[0x16];
  uVar4 = param_2[4];
  uVar5 = param_2[2];
  uVar7 = param_2[0x17];
  uVar8 = param_2[0x1a];
  uVar9 = param_2[0x1b];
  *param_1 = (short)*param_2;
  param_1[1] = (short)uVar5;
  *(undefined4 *)(param_1 + 2) = uVar4;
  param_1[4] = (short)uVar3;
  param_1[5] = (short)uVar1;
  param_1[6] = (short)uVar15;
  param_1[7] = (short)uVar14;
  *(undefined4 *)(param_1 + 8) = uVar13;
  *(undefined4 *)(param_1 + 0x24) = uVar12;
  *(undefined4 *)(param_1 + 0x22) = uVar2;
  *(undefined4 *)(param_1 + 0xc) = uVar10;
  *(undefined4 *)(param_1 + 0xe) = uVar11;
  *(undefined4 *)(param_1 + 0x14) = uVar6;
  *(undefined4 *)(param_1 + 0x16) = uVar7;
  *(undefined4 *)(param_1 + 0x1c) = uVar8;
  *(undefined4 *)(param_1 + 0x1e) = uVar9;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_On_BG(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c4a0. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010828)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_Off_BG(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c4aa. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101082c)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_On_LDO11_SOC(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c4b4. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010830)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_Off_LDO11_SOC(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c4be. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010834)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_On_LDO15_RF(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c4c8. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010838)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_Off_LDO15_RF(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c4d2. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101083c)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_On_SFReg(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c4dc. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010840)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_Off_SFReg(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c4e6. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010844)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_LowPower_Enter_PDS0(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c4f0. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010848)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_LowPower_Exit_PDS0(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c4fa. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101084c)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ASM_Delay_Us(uint32_t core,uint32_t cnt)

{
                    // WARNING: Could not recover jumptable at 0x4200c504. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010850)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void BL602_Delay_US(uint32_t cnt)

{
                    // WARNING: Could not recover jumptable at 0x4200c50e. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010854)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void BL602_Delay_MS(uint32_t cnt)

{
                    // WARNING: Could not recover jumptable at 0x4200c518. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010858)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void * BL602_MemCpy(void *dst,void *src,uint32_t n)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c522. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*_DAT_2101085c)();
  return pvVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t * BL602_MemCpy4(uint32_t *dst,uint32_t *src,uint32_t n)

{
  uint32_t *puVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c52c. Too many branches
                    // WARNING: Treating indirect jump as call
  puVar1 = (uint32_t *)(*_DAT_21010860)();
  return puVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void * BL602_MemCpy_Fast(void *pdst,void *psrc,uint32_t n)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c536. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*_DAT_21010864)();
  return pvVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void * BL602_MemSet(void *s,uint8_t c,uint32_t n)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c540. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*_DAT_21010868)();
  return pvVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t * BL602_MemSet4(uint32_t *dst,uint32_t val,uint32_t n)

{
  uint32_t *puVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c54a. Too many branches
                    // WARNING: Treating indirect jump as call
  puVar1 = (uint32_t *)(*_DAT_2101086c)();
  return puVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int BL602_MemCmp(void *s1,void *s2,uint32_t n)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c554. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*_DAT_21010870)();
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void EF_Ctrl_Sw_AHB_Clk_0(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c55e. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010874)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void EF_Ctrl_Program_Efuse_0(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c568. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010878)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void EF_Ctrl_Load_Efuse_R0(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c572. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_2101087c)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Sts_Type EF_Ctrl_Busy(void)

{
  BL_Sts_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c57c. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010880)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Sts_Type EF_Ctrl_AutoLoad_Done(void)

{
  BL_Sts_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c586. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010884)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void EF_Ctrl_Clear(uint32_t index,uint32_t len)

{
                    // WARNING: Could not recover jumptable at 0x4200c590. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010894)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_SW_System_Reset(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c59a. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108bc)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_SW_CPU_Reset(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c5a4. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108c0)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_SW_POR_Reset(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c5ae. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108c4)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_Select_Internal_Flash(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c5b8. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108c8)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_Select_External_Flash(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c5c2. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108cc)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_Deswap_Flash_Pin(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c5cc. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108d0)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_Swap_Flash_Pin(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c5d6. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108d4)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_GPIO_Init(GLB_GPIO_Cfg_Type *cfg)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c5e0. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108d8)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_GPIO_OUTPUT_Enable(GLB_GPIO_Type gpioPin)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c5ea. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108dc)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_GPIO_OUTPUT_Disable(GLB_GPIO_Type gpioPin)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c5f4. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108e0)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_GPIO_Set_HZ(GLB_GPIO_Type gpioPin)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c5fe. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108e4)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t GLB_GPIO_Get_Fun(GLB_GPIO_Type gpioPin)

{
  uint8_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c608. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*_DAT_210108e8)();
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void HBN_Mode_Enter(HBN_APP_CFG_Type *cfg)

{
                    // WARNING: Could not recover jumptable at 0x4200c612. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210108ec)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void HBN_Power_Down_Flash(SPI_Flash_Cfg_Type *flashCfg)

{
                    // WARNING: Could not recover jumptable at 0x4200c61c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210108f0)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void HBN_Enable(uint8_t aGPIOIeCfg,HBN_LDO_LEVEL_Type ldoLevel,HBN_LEVEL_Type hbnLevel)

{
                    // WARNING: Could not recover jumptable at 0x4200c626. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210108f4)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Reset(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c630. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108f8)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Set_Ldo11_Aon_Vout(HBN_LDO_LEVEL_Type ldoLevel)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c63a. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108fc)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Set_Ldo11_Rt_Vout(HBN_LDO_LEVEL_Type ldoLevel)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c644. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010900)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Set_Ldo11_Soc_Vout(HBN_LDO_LEVEL_Type ldoLevel)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c64e. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010904)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Hw_Pu_Pd_Cfg(uint8_t enable)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c658. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010924)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Pin_WakeUp_Mask(uint8_t maskVal)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c662. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010928)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
HBN_GPIO7_Dbg_Pull_Cfg(BL_Fun_Type pupdEn,BL_Fun_Type iesmtEn,BL_Fun_Type dlyEn,uint8_t dlySec)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c66c. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101092c)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Set_Embedded_Flash_Pullup(uint8_t enable)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c676. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010930)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type L1C_Set_Wrap(BL_Fun_Type wrap)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c680. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010934)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type L1C_Set_Way_Disable(uint8_t disableVal)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c68a. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010938)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type L1C_IROM_2T_Access_Set(uint8_t enable)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c694. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101093c)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_Reset(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c69e. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010940)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_Force_Config(PDS_CTL2_Type *cfg2,PDS_CTL3_Type *cfg3)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c6a8. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010948)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_RAM_Config(PDS_RAM_CFG_Type *ramCfg)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c6b2. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101094c)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
PDS_Default_Level_Config
          (PDS_DEFAULT_LV_CFG_Type *defaultLvCfg,PDS_RAM_CFG_Type *ramCfg,uint32_t pdsSleepCnt)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c6bc. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010950)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SEC_Eng_Turn_On_Sec_Ring(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c6c6. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010978)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SEC_Eng_Turn_Off_Sec_Ring(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c6d0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_2101097c)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_Init(SF_Ctrl_Cfg_Type *pSfCtrlCfg)

{
                    // WARNING: Could not recover jumptable at 0x4200c6da. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010980)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SFlash_SetSPIMode(SF_Ctrl_Mode_Type mode)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c6e4. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010984)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
SFlash_Read_Reg(SPI_Flash_Cfg_Type *flashCfg,uint8_t regIndex,uint8_t *regValue,uint8_t regLen)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c6ee. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010988)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
SFlash_Write_Reg(SPI_Flash_Cfg_Type *flashCfg,uint8_t regIndex,uint8_t *regValue,uint8_t regLen)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c6f8. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101098c)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Sts_Type SFlash_Busy(SPI_Flash_Cfg_Type *flashCfg)

{
  BL_Sts_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c702. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010990)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SFlash_Write_Enable(SPI_Flash_Cfg_Type *flashCfg)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c70c. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010994)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SFlash_Qspi_Enable(SPI_Flash_Cfg_Type *flashCfg)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c716. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010998)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_Volatile_Reg_Write_Enable(SPI_Flash_Cfg_Type *flashCfg)

{
                    // WARNING: Could not recover jumptable at 0x4200c720. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_2101099c)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SFlash_Chip_Erase(SPI_Flash_Cfg_Type *flashCfg)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c72a. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109a0)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SFlash_Sector_Erase(SPI_Flash_Cfg_Type *flashCfg,uint32_t secNum)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c734. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109a4)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SFlash_Blk32_Erase(SPI_Flash_Cfg_Type *flashCfg,uint32_t blkNum)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c73e. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109a8)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SFlash_Blk64_Erase(SPI_Flash_Cfg_Type *flashCfg,uint32_t blkNum)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c748. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109ac)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SFlash_Erase(SPI_Flash_Cfg_Type *flashCfg,uint32_t startaddr,uint32_t endaddr)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c752. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109b0)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
SFlash_Program(SPI_Flash_Cfg_Type *flashCfg,SF_Ctrl_IO_Type ioMode,uint32_t addr,uint8_t *data,
              uint32_t len)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c75c. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109b4)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_GetUniqueId(uint8_t *data,uint8_t idLen)

{
                    // WARNING: Could not recover jumptable at 0x4200c766. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210109b8)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_GetJedecId(SPI_Flash_Cfg_Type *flashCfg,uint8_t *data)

{
                    // WARNING: Could not recover jumptable at 0x4200c770. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210109bc)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_GetDeviceId(uint8_t *data)

{
                    // WARNING: Could not recover jumptable at 0x4200c77a. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210109c0)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_Powerdown(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c784. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210109c4)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_Releae_Powerdown(SPI_Flash_Cfg_Type *flashCfg)

{
                    // WARNING: Could not recover jumptable at 0x4200c78e. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210109c8)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_SetBurstWrap(SPI_Flash_Cfg_Type *flashCfg)

{
                    // WARNING: Could not recover jumptable at 0x4200c798. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210109cc)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_DisableBurstWrap(SPI_Flash_Cfg_Type *flashCfg)

{
                    // WARNING: Could not recover jumptable at 0x4200c7a2. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210109d0)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SFlash_Software_Reset(SPI_Flash_Cfg_Type *flashCfg)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c7ac. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109d4)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_Reset_Continue_Read(SPI_Flash_Cfg_Type *flashCfg)

{
                    // WARNING: Could not recover jumptable at 0x4200c7b6. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210109d8)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
SFlash_Set_IDbus_Cfg
          (SPI_Flash_Cfg_Type *flashCfg,SF_Ctrl_IO_Type ioMode,uint8_t contRead,uint32_t addr,
          uint32_t len)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c7c0. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109dc)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
SFlash_IDbus_Read_Enable(SPI_Flash_Cfg_Type *flashCfg,SF_Ctrl_IO_Type ioMode,uint8_t contRead)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c7ca. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109e0)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SFlash_Cache_Enable_Set(uint8_t wayDisable)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c7d4. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109e4)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SFlash_Cache_Flush(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c7de. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109e8)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
SFlash_Cache_Read_Enable
          (SPI_Flash_Cfg_Type *flashCfg,SF_Ctrl_IO_Type ioMode,uint8_t contRead,uint8_t wayDisable)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c7e8. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109ec)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_Cache_Hit_Count_Get(uint32_t *hitCountLow,uint32_t *hitCountHigh)

{
                    // WARNING: Could not recover jumptable at 0x4200c7f2. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210109f0)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t SFlash_Cache_Miss_Count_Get(void)

{
  uint32_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c7fc. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*_DAT_210109f4)();
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_Cache_Read_Disable(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c806. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210109f8)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
SFlash_Read(SPI_Flash_Cfg_Type *flashCfg,SF_Ctrl_IO_Type ioMode,uint8_t contRead,uint32_t addr,
           uint8_t *data,uint32_t len)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c810. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109fc)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
SFlash_Read_Reg_With_Cmd
          (SPI_Flash_Cfg_Type *flashCfg,uint8_t readRegCmd,uint8_t *regValue,uint8_t regLen)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c81a. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010a00)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
SFlash_Write_Reg_With_Cmd
          (SPI_Flash_Cfg_Type *flashCfg,uint8_t writeRegCmd,uint8_t *regValue,uint8_t regLen)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c824. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010a04)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Cfg_Init_Ext_Flash_Gpio(uint8_t extFlashPin)

{
                    // WARNING: Could not recover jumptable at 0x4200c82e. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a0c)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Cfg_Init_Internal_Flash_Gpio(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c838. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a10)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Cfg_Deinit_Ext_Flash_Gpio(uint8_t extFlashPin)

{
                    // WARNING: Could not recover jumptable at 0x4200c842. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a14)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Cfg_Restore_GPIO17_Fun(uint8_t fun)

{
                    // WARNING: Could not recover jumptable at 0x4200c84c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a18)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SF_Cfg_Get_Flash_Cfg_Need_Lock(uint32_t flashID,SPI_Flash_Cfg_Type *pFlashCfg)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c856. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010a1c)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Cfg_Init_Flash_Gpio(uint8_t flashPinCfg,uint8_t restoreDefault)

{
                    // WARNING: Could not recover jumptable at 0x4200c860. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a20)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t SF_Cfg_Flash_Identify
                   (uint8_t callFromFlash,uint32_t autoScan,uint32_t flashPinCfg,
                   uint8_t restoreDefault,SPI_Flash_Cfg_Type *pFlashCfg)

{
  undefined3 in_register_00002029;
  uint32_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c86a. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*_DAT_21010a24)(CONCAT31(in_register_00002029,callFromFlash));
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_Enable(SF_Ctrl_Cfg_Type *cfg)

{
                    // WARNING: Could not recover jumptable at 0x4200c874. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a28)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_Select_Pad(SF_Ctrl_Pad_Sel sel)

{
                    // WARNING: Could not recover jumptable at 0x4200c87e. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a2c)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_Set_Owner(SF_Ctrl_Owner_Type owner)

{
                    // WARNING: Could not recover jumptable at 0x4200c888. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a30)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_Disable(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c892. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a34)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_AES_Enable_BE(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c89c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a38)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_AES_Enable_LE(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c8a6. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a3c)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_AES_Set_Region
               (uint8_t region,uint8_t enable,uint8_t hwKey,uint32_t startAddr,uint32_t endAddr,
               uint8_t locked)

{
                    // WARNING: Could not recover jumptable at 0x4200c8b0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a40)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_AES_Set_Key(uint8_t region,uint8_t *key,SF_Ctrl_AES_Key_Type keyType)

{
                    // WARNING: Could not recover jumptable at 0x4200c8ba. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a44)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_AES_Set_Key_BE(uint8_t region,uint8_t *key,SF_Ctrl_AES_Key_Type keyType)

{
                    // WARNING: Could not recover jumptable at 0x4200c8c4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a48)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_AES_Set_IV(uint8_t region,uint8_t *iv,uint32_t addrOffset)

{
                    // WARNING: Could not recover jumptable at 0x4200c8ce. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a4c)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_AES_Set_IV_BE(uint8_t region,uint8_t *iv,uint32_t addrOffset)

{
                    // WARNING: Could not recover jumptable at 0x4200c8d8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a50)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_AES_Enable(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c8e2. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a54)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_AES_Disable(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c8ec. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a58)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_Set_Flash_Image_Offset(uint32_t addrOffset)

{
                    // WARNING: Could not recover jumptable at 0x4200c8f6. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a5c)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t SF_Ctrl_Get_Flash_Image_Offset(void)

{
  uint32_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c900. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*_DAT_21010a60)();
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_Select_Clock(SF_Ctrl_Sahb_Type sahbType)

{
                    // WARNING: Could not recover jumptable at 0x4200c90a. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a64)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_SendCmd(SF_Ctrl_Cmd_Cfg_Type *cfg)

{
                    // WARNING: Could not recover jumptable at 0x4200c914. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a68)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_Icache_Set(SF_Ctrl_Cmd_Cfg_Type *cfg,uint8_t cmdValid)

{
                    // WARNING: Could not recover jumptable at 0x4200c91e. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a6c)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_Icache2_Set(SF_Ctrl_Cmd_Cfg_Type *cfg,uint8_t cmdValid)

{
                    // WARNING: Could not recover jumptable at 0x4200c928. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a70)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Sts_Type SF_Ctrl_GetBusyState(void)

{
  BL_Sts_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c932. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010a74)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t SF_Ctrl_Is_AES_Enable(void)

{
  uint8_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c93c. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*_DAT_21010a78)();
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t SF_Ctrl_Get_Clock_Delay(void)

{
  uint8_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c946. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*_DAT_21010a7c)();
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_Set_Clock_Delay(uint8_t delay)

{
                    // WARNING: Could not recover jumptable at 0x4200c950. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a80)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type XIP_SFlash_State_Save(SPI_Flash_Cfg_Type *pFlashCfg,uint32_t *offset)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c95a. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010a84)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type XIP_SFlash_State_Restore(SPI_Flash_Cfg_Type *pFlashCfg,uint32_t offset)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c964. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010a88)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
XIP_SFlash_Erase_Need_Lock(SPI_Flash_Cfg_Type *pFlashCfg,uint32_t startaddr,uint32_t endaddr)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c96e. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010a8c)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
XIP_SFlash_Write_Need_Lock(SPI_Flash_Cfg_Type *pFlashCfg,uint32_t addr,uint8_t *data,uint32_t len)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c978. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010a90)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
XIP_SFlash_Read_Need_Lock(SPI_Flash_Cfg_Type *pFlashCfg,uint32_t addr,uint8_t *data,uint32_t len)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c982. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010a94)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type XIP_SFlash_GetJedecId_Need_Lock(SPI_Flash_Cfg_Type *pFlashCfg,uint8_t *data)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c98c. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010a98)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type XIP_SFlash_GetDeviceId_Need_Lock(SPI_Flash_Cfg_Type *pFlashCfg,uint8_t *data)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c996. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010a9c)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
XIP_SFlash_GetUniqueId_Need_Lock(SPI_Flash_Cfg_Type *pFlashCfg,uint8_t *data,uint8_t idLen)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c9a0. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010aa0)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type XIP_SFlash_Read_Via_Cache_Need_Lock(uint32_t addr,uint8_t *data,uint32_t len)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c9aa. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010aa4)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int XIP_SFlash_Read_With_Lock(SPI_Flash_Cfg_Type *pFlashCfg,uint32_t addr,uint8_t *dst,int len)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c9b4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*_DAT_21010aa8)();
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int XIP_SFlash_Write_With_Lock(SPI_Flash_Cfg_Type *pFlashCfg,uint32_t addr,uint8_t *src,int len)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c9be. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*_DAT_21010aac)();
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int XIP_SFlash_Erase_With_Lock(SPI_Flash_Cfg_Type *pFlashCfg,uint32_t addr,int len)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c9c8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*_DAT_21010ab0)();
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void XIP_SFlash_Opt_Enter(uint8_t *aesEnable)

{
                    // WARNING: Could not recover jumptable at 0x4200c9d2. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010ab4)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void XIP_SFlash_Opt_Exit(uint8_t aesEnable)

{
                    // WARNING: Could not recover jumptable at 0x4200c9dc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010ab8)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t BFLB_Soft_CRC32(void *dataIn,uint32_t len)

{
  uint32_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c9e6. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*_DAT_21010abc)();
  return uVar1;
}



// WARNING: Control flow encountered bad instruction data

BL_Err_Type ADC_Trim_TSEN(uint16_t *tsen_offset)

{
  Efuse_TSEN_Refcode_Corner_Type trim;
  
                    // WARNING: Bad instruction - Truncating control flow here
  halt_baddata();
}



// WARNING: Control flow encountered bad instruction data

BL_Err_Type ADC_Gain_Trim(void)

{
  uint uVar1;
  uint8_t a;
  undefined3 extraout_var;
  Efuse_ADC_Gain_Coeff_Type EStack36;
  Efuse_ADC_Gain_Coeff_Type trim;
  
  EF_Ctrl_Read_ADC_Gain_Trim(&EStack36);
  if ((int)EStack36 << 0x12 < 0) {
    uVar1 = (uint)EStack36 >> 0xc;
    a = EF_Ctrl_Get_Trim_Parity((uint)EStack36 & 0xfff,'\f');
    _a = (SFtype)CONCAT31(extraout_var,a);
    if ((SFtype)(uVar1 & 1) == _a) {
      adcGainCoeffCal.adcGainCoeffEnable = ENABLE;
      adcGainCoeffCal.adcgainCoeffVal = SUB42(EStack36,0) & 0xfff;
      if (((uint)EStack36 & 0x800) == 0) {
        __extendsfdf2(_a);
        __muldf3();
        __subdf3();
      }
      else {
        __extendsfdf2(_a);
        __muldf3();
        __adddf3();
      }
      __truncdfsf2();
                    // WARNING: Bad instruction - Truncating control flow here
      halt_baddata();
    }
  }
  return ERROR;
}



uint8_t EF_Ctrl_Get_Trim_Parity(uint32_t val,uint8_t len)

{
  undefined3 in_register_0000202d;
  uint uVar1;
  byte bVar2;
  
  uVar1 = 0;
  bVar2 = 0;
  while ((uVar1 & 0xff) < CONCAT31(in_register_0000202d,len)) {
    if ((1 << (uVar1 & 0x1f) & val) != 0) {
      bVar2 = bVar2 + 1;
    }
    uVar1 = uVar1 + 1;
  }
  return (uint8_t)(bVar2 & 1);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void EF_Ctrl_Read_RC32M_Trim(Efuse_Ana_RC32M_Trim_Type *trim)

{
  uint uVar1;
  uint uVar2;
  
  EF_Ctrl_Sw_AHB_Clk_0();
  EF_Ctrl_Load_Efuse_R0();
  uVar1 = _DAT_4000700c;
  uVar2 = _DAT_4000700c >> 10;
  *(char *)trim = (char)uVar2;
  *(uint *)trim = (uint)*trim & 0xfffffcff | uVar2 & 0x100 | uVar1 >> 10 & 0x200;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void EF_Ctrl_Read_RC32K_Trim(Efuse_Ana_RC32K_Trim_Type *trim)

{
  EF_Ctrl_Sw_AHB_Clk_0();
  EF_Ctrl_Load_Efuse_R0();
  *(uint *)trim =
       (uint)*trim & 0xfffff000 | _DAT_4000700c >> 0x14 & 0x3ff | _DAT_4000700c >> 0x14 & 0x400 |
       (_DAT_4000700c >> 0x1f) << 0xb;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void EF_Ctrl_Read_TSEN_Trim(Efuse_TSEN_Refcode_Corner_Type *trim)

{
  uint uVar1;
  Efuse_TSEN_Refcode_Corner_Type EVar2;
  uint uVar3;
  uint uVar4;
  
  EF_Ctrl_Sw_AHB_Clk_0();
  EF_Ctrl_Load_Efuse_R0();
  uVar3 = (_DAT_40007078 & 1) << 0xd;
  EVar2 = *trim;
  *(uint *)trim = (uint)EVar2 & 0xffffdfff | uVar3;
  uVar4 = _DAT_4000707c & 0xfff;
  uVar1 = _DAT_4000707c & 0x1000;
  *(uint *)trim = (uint)EVar2 & 0xffffc000 | uVar3 | uVar4 | uVar1;
  *(uint *)trim =
       (uint)EVar2 & 0xffff8000 | uVar3 | uVar4 | uVar1 | (_DAT_40007070 >> 0x1e & 1) << 0xe;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void EF_Ctrl_Read_ADC_Gain_Trim(Efuse_ADC_Gain_Coeff_Type *trim)

{
  EF_Ctrl_Sw_AHB_Clk_0();
  EF_Ctrl_Load_Efuse_R0();
  *(uint *)trim =
       (uint)*trim & 0xffffc000 | (_DAT_40007078 << 0x13) >> 0x14 |
       (_DAT_40007078 >> 0xd & 1) << 0xc | (_DAT_40007078 >> 0xe & 1) << 0xd;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_On_MBG(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cd8e. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010810)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_Off_MBG(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cd98. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010814)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_On_XTAL(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cda2. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010818)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Set_Xtal_CapCode(uint8_t capIn,uint8_t capOut)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cdac. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101081c)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t AON_Get_Xtal_CapCode(void)

{
  uint8_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cdb6. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*_DAT_21010820)();
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_Off_XTAL(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cdc0. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010824)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t EF_Ctrl_Get_Trim_Parity(uint32_t val,uint8_t len)

{
  uint8_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cdca. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*_DAT_21010888)();
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void EF_Ctrl_Read_RC32M_Trim(Efuse_Ana_RC32M_Trim_Type *trim)

{
                    // WARNING: Could not recover jumptable at 0x4200cdd4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_2101088c)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void EF_Ctrl_Read_RC32K_Trim(Efuse_Ana_RC32K_Trim_Type *trim)

{
                    // WARNING: Could not recover jumptable at 0x4200cdde. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010890)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

GLB_ROOT_CLK_Type GLB_Get_Root_CLK_Sel(void)

{
  GLB_ROOT_CLK_Type GVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cde8. Too many branches
                    // WARNING: Treating indirect jump as call
  GVar1 = (*_DAT_21010898)();
  return GVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_Set_System_CLK_Div(uint8_t hclkDiv,uint8_t bclkDiv)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cdf2. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101089c)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t GLB_Get_BCLK_Div(void)

{
  uint8_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cdfc. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*_DAT_210108a0)();
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t GLB_Get_HCLK_Div(void)

{
  uint8_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce06. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*_DAT_210108a4)();
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type Update_SystemCoreClockWith_XTAL(GLB_PLL_XTAL_Type xtalType)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce10. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108a8)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_Set_System_CLK(GLB_PLL_XTAL_Type xtalType,GLB_SYS_CLK_Type clkFreq)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce1a. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108ac)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type System_Core_Clock_Update_From_RC32M(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce24. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108b0)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_Set_SF_CLK(uint8_t enable,GLB_SFLASH_CLK_Type clkSel,uint8_t div)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce2e. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108b4)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_Set_PKA_CLK_Sel(GLB_PKA_CLK_Type clkSel)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce38. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108b8)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_32K_Sel(HBN_32K_CLK_Type clkType)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce42. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010908)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Set_ROOT_CLK_Sel(HBN_ROOT_CLK_Type rootClk)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce4c. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101090c)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Power_On_Xtal_32K(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce56. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010910)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Power_Off_Xtal_32K(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce60. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010914)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Power_On_RC32K(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce6a. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010918)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Power_Off_RC32K(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce74. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101091c)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Trim_RC32K(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce7e. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010920)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_Trim_RC32M(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce88. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010954)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_Select_RC32M_As_PLL_Ref(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce92. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010958)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_Select_XTAL_As_PLL_Ref(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce9c. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101095c)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_Power_On_PLL(PDS_PLL_XTAL_Type xtalType)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cea6. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010960)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_Enable_PLL_All_Clks(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ceb0. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010964)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_Disable_PLL_All_Clks(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ceba. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010968)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_Enable_PLL_Clk(PDS_PLL_CLK_Type pllClk)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cec4. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101096c)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_Disable_PLL_Clk(PDS_PLL_CLK_Type pllClk)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cece. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010970)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_Power_Off_PLL(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ced8. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010974)();
  return BVar1;
}


