// bl602_demo_wifi_text_0007.c
// Generated by decompiling bl602_demo_wifi.elf
// using Reko decompiler version 0.9.3.0.

#include "bl602_demo_wifi.h"

// 23070414: Register Eq_2 __fixdfsi(Register Eq_2 ra, Register Eq_2 a0, Register Eq_64250 a1, Register ptr32 fflags, Register ptr32 frm, Register out Eq_65065 a1Out, Register out Eq_65066 a3Out, Register out (ptr32 word32) a4Out, Register out Eq_2 a5Out)
// Called from:
//      rf_set_channel
//      trpc_get_default_power_idx
//      rf_pri_get_vco_freq_cw
//      rf_pri_get_vco_idac_cw
//      phyif_utils_decode
//      tcpip_stack_input
//      ecvtbuf
Eq_2 __fixdfsi(Eq_2 ra, Eq_2 a0, Eq_64250 a1, ptr32 fflags, ptr32 frm, union Eq_65065 & a1Out, union Eq_65066 & a3Out, word32 & a4Out, union Eq_2 & a5Out)
{
	Eq_2 a5_31;
	__csrrs(frm, fp);
	Eq_65066 a3_28 = a1 >> 0x14 & 0x07FF;
	word32 * a4_10 = (word32 *) 1022;
	if (a3_28 > 1022)
	{
		if (a3_28 > 0x041D)
		{
			a5_31 = (a1 >> 0x1F) + 0x7FFFFFFF;
			if (a1 >> 0x1F == 0x00)
			{
				a4_10 = (word32 *) 16;
				goto l230704C8;
			}
			a4_10 = (word32 *) 16;
			if (a3_28 != 0x041E)
			{
l230704C8:
				__csrrs(fflags, ra);
				goto l23070444;
			}
			a3_28 = a0 >> 0x15;
			if (((a1 & 0x000FFFFF) << 11 | a0 >> 0x15) != 0x00)
				goto l230704C8;
			a4_10 = a0 << 11;
			if (a0 << 11 != 0x00)
			{
				a4_10 = a1 >> 0x1F;
				goto l230704C8;
			}
		}
		else
		{
			uint32 a5_14 = a1 & 0x000FFFFF | 0x00100000;
			int32 a2_16 = 0x0433 - a3_28;
			if (a2_16 <= 31)
			{
				a3_28 = (word32) a3_28 - 0x0413;
				a4_10 = (word32) (a0 << (word32) a3_28 - 0x0413 != 0x00);
				a5_31 = a5_14 << (word32) a3_28 - 0x0413 | a0 >> a2_16;
			}
			else
			{
				int32 a4_19 = 0;
				if (a2_16 != 32)
					a4_19 = a5_14 << (word32) a3_28 - 1011;
				a3_28 = 0x0413 - a3_28;
				a4_10 = (word32) ((a4_19 | a0) != 0x00);
				a5_31 = a5_14 >> a3_28;
			}
			if (a1 >> 0x1F != 0x00)
				a5_31 = 0x00 - a5_31;
			if (a4_10 != null)
				goto l230704C8;
		}
l23070444:
		a1Out = a1 >> 0x1F;
		a3Out = a3_28;
		a4Out = a4_10;
		a5Out = a5_31;
		return a5_31;
	}
	else
	{
		if (a3_28 == 0x00)
		{
			a5_31 = a1 & 0x000FFFFF | a0;
			if (a5_31 == 0x00)
				goto l23070444;
		}
		a5_31.u0 = 0;
		a4_10 = (word32 *) 1;
		goto l230704C8;
	}
}

// 23070510: Register Eq_2 __fixunsdfsi(Register Eq_2 ra, Register Eq_2 a0, Register uint32 a1, Register ptr32 fflags, Register ptr32 frm, Register out Eq_65764 a4Out)
// Called from:
//      rfc_init
//      rf_pri_rccal_iq
Eq_2 __fixunsdfsi(Eq_2 ra, Eq_2 a0, uint32 a1, ptr32 fflags, ptr32 frm, union Eq_65764 & a4Out)
{
	Eq_65764 a4_16;
	Eq_2 a0_13;
	__csrrs(frm, fp);
	int32 a3_9 = a1 >> 0x14 & 0x07FF;
	if (a3_9 > 1022)
	{
		if (a1 >> 0x1F == 0x00)
		{
			if (a3_9 <= 0x041E)
			{
				uint32 a5_18 = a1 & 0x000FFFFF | 0x00100000;
				int32 a2_19 = 0x0433 - a3_9;
				if (a2_19 <= 31)
				{
					a4_16 = (word32) (a0 << a3_9 + -0x0413 != 0x00);
					a0_13 = a5_18 << a3_9 + -0x0413 | a0 >> a2_19;
				}
				else
				{
					int32 a4_22 = 0;
					if (a2_19 != 32)
						a4_22 = a5_18 << a3_9 + -1011;
					a4_16 = (word32) ((a4_22 | a0) != 0x00);
					a0_13 = a5_18 >> 0x0413 - a3_9;
				}
				if (a4_16 == 0x00)
				{
					a4Out = a4_16;
					return a0_13;
				}
				goto l23070580;
			}
			a0_13.u0 = -1;
		}
		else
			a0_13.u0 = 0;
		a4_16.u0 = 16;
		goto l23070580;
	}
	else
	{
		if (a3_9 == 0x00)
		{
			Eq_2 a0_42 = a1 & 0x000FFFFF | a0;
			if (a0_42 == 0x00)
			{
				a4Out.u0 = 0x00100000;
				return a0_42;
			}
		}
		a0_13.u0 = 0;
		a4_16.u0 = 1;
l23070580:
		__csrrs(fflags, ra);
		a4Out = a4_16;
		return a0_13;
	}
}

// 230705D8: Register Eq_64318 __floatsidf(Register Eq_64318 a0, Register out Eq_64319 a1Out)
// Called from:
//      rf_set_channel
//      pa_input
//      trpc_get_default_power_idx
//      phyif_utils_decode
//      tcpip_stack_input
//      ADC_Parse_Result
Eq_64318 __floatsidf(Eq_64318 a0, union Eq_64319 & a1Out)
{
	Eq_64318 s0_27;
	int32 a4_11;
	Eq_358889 a5_12;
	if (a0 != 0x00)
	{
		Eq_2 s0_15 = (a0 >> 0x1F ^ a0) - (a0 >> 0x1F);
		word32 a4_68;
		Eq_2 a0_18 = __clzsi2(s0_15, out a4_68);
		a4_11 = 0x041E - a0_18;
		if (a0_18 <= 0x0A)
		{
			a5_12 = s0_15 >> 11 - a0_18;
			s0_27 = s0_15 << (word32) a0_18 + 21;
			a0 >>= 0x1F;
			goto l2307062C;
		}
		a5_12 = s0_15 << (word32) a0_18 - 11;
		a0 >>= 0x1F;
	}
	else
	{
		a4_11 = 0;
		a5_12.u0 = 0;
	}
	s0_27.u0 = 0;
l2307062C:
	a1Out = (word32) (word20) a5_12 | (a4_11 & 0x07FF) << 0x14 | a0 << 0x1F;
	return s0_27;
}

// 23070684: Register Eq_2 __floatunsidf(Register Eq_2 a0, Register out Eq_65693 a1Out)
// Called from:
//      rfc_init
//      rf_pri_rccal_iq
//      rf_pri_get_vco_freq_cw
//      rf_pri_get_vco_idac_cw
//      __floatundisf
Eq_2 __floatunsidf(Eq_2 a0, union Eq_65693 & a1Out)
{
	int32 a4_11;
	Eq_358933 a5_10;
	Eq_2 s0_20 = a0;
	if (a0 != 0x00)
	{
		word32 a4_46;
		Eq_2 a0_12 = __clzsi2(a0, out a4_46);
		a4_11 = 0x041E - a0_12;
		if (a0_12 <= 0x0A)
		{
			a5_10 = a0 >> 11 - a0_12;
			s0_20 = a0 << (word32) a0_12 + 21;
		}
		else
		{
			a5_10 = a0 << (word32) a0_12 - 11;
			s0_20.u0 = 0;
		}
	}
	else
	{
		a5_10.u0 = 0;
		a4_11 = 0;
	}
	a1Out = (word32) (word20) a5_10 | (a4_11 & 0x07FF) << 0x14;
	return s0_20;
}

// 23070708: Register Eq_2 __extendsfdf2(Register Eq_2 ra, Register Eq_5614 fa0, Register ptr32 fflags, Register ptr32 frm, Register out Eq_64592 a1Out)
// Called from:
//      pa_adapt
//      rfc_init
//      tcpip_stack_input
//      bl_tsen_adc_get
//      iperf_server_udp_recv_fn
//      iperf_client_udp
//      iperf_server
//      iperf_client_tcp
//      convertDataToString
//      ADC_Parse_Result
//      TSEN_Get_Temp
Eq_2 __extendsfdf2(Eq_2 ra, Eq_5614 fa0, ptr32 fflags, ptr32 frm, union Eq_64592 & a1Out)
{
	int32 a0_31;
	Eq_358967 a5_23;
	__csrrs(frm, fp + -16);
	ui32 a0_17 = fa0 >> 0x17 & 0x00FF;
	int32 s1_20 = a0_17 + 1 & 0x00FE;
	Eq_2 s0_21 = (word32) (word23) fa0;
	if (s1_20 != 0x00)
	{
		a5_23 = s0_21 >> 0x03;
		a0_31 = a0_17 + 896;
		s0_21 <<= 0x1D;
		s1_20 = 0;
	}
	else if (a0_17 == 0x00)
	{
		if (s0_21 != 0x00)
		{
			word32 a4_131;
			Eq_2 a0_35 = __clzsi2(s0_21, out a4_131);
			if (a0_35 <= 0x0A)
			{
				a5_23 = s0_21 >> 11 - a0_35;
				s0_21 <<= (word32) a0_35 + 21;
			}
			else
			{
				a5_23 = s0_21 << (word32) a0_35 - 11;
				s0_21.u0 = 0;
			}
			a0_31 = 905 - a0_35;
		}
		else
		{
			a5_23.u0 = 0;
			a0_31 = 0;
		}
	}
	else
	{
		a5_23.u0 = 0;
		if (s0_21 != 0x00)
		{
			if (s0_21 << 0x09 >= 0x00)
				s1_20 = 16;
			s0_21 <<= 0x1D;
			a5_23 = s0_21 >> 0x03 | 0x00080000;
		}
		a0_31 = 0x07FF;
	}
	Eq_64592 a1_73 = (word32) (word20) a5_23 | (a0_31 & 0x07FF) << 0x14 | (fa0 >> 0x1F) << 0x1F;
	if (s1_20 != 0x00)
		__csrrs(fflags, ra);
	a1Out = a1_73;
	return s0_21;
}

// 23070818: Register uint32 __truncdfsf2(Register Eq_2 ra, Register Eq_2 a0, Register uint32 a1, Register ptr32 fflags, Register ptr32 frm, Register out Eq_64455 a2Out, Register out Eq_64456 a3Out, Register out (ptr32 int8) a4Out, Register out (ptr32 Eq_64458) a5Out, Register out (ptr32 Eq_64458) fa0Out)
// Called from:
//      pa_input
//      pa_adapt
//      ADC_Parse_Result
//      TSEN_Get_Temp
//      __floatundisf
uint32 __truncdfsf2(Eq_2 ra, Eq_2 a0, uint32 a1, ptr32 fflags, ptr32 frm, union Eq_64455 & a2Out, union Eq_64456 & a3Out, int8 & a4Out, struct Eq_64458 & a5Out, struct Eq_64458 & fa0Out)
{
	Eq_64455 a2_105;
	int32 a6_112;
	Eq_359054 a5_100;
	int32 t1_10 = a1 >> 0x14 & 0x07FF;
	struct Eq_84 * a7_4 = __csrrs(frm, fp);
	Eq_64456 a3_102 = a0 >> 0x1D | (word32) ((word20) a1) << 0x03;
	int32 a4_103 = t1_10 + 1 & 0x07FE;
	Eq_359077 a1_16 = a1 >> 0x1F;
	if (a4_103 != 0x00)
	{
		a6_112 = t1_10 + -896;
		if (t1_10 > -1150)
		{
			if (a7_4 != null)
			{
				if (a7_4 == (struct Eq_84 *) 3)
				{
					if (a1 >> 0x1F != 0x00)
					{
l23070868:
						a5_100.u0 = -1;
						a6_112 = 0x00FE;
						a4_103 = 0;
						a2_105.u0 = 5;
						goto l23070878;
					}
				}
				else if (a7_4 != (struct Eq_84 *) 2 || a1 >> 0x1F == 0x00)
					goto l23070868;
			}
			a5_100.u0 = 0;
			a6_112 = 0x00FF;
			a2_105.u0 = 5;
			goto l230708C4;
		}
		if (t1_10 > ~0x037F)
		{
			a5_100 = (word32) (a0 << 0x06 != 0x00) | a3_102 << 0x03 | (a0 << 0x03) >> 0x1D;
			a4_103 = 0;
			a2_105.u0 = 0;
			goto l23070A08;
		}
		if (t1_10 < -873)
		{
			a5_100.u0 = 1;
l2307096C:
			uint32 a4_74 = a5_100 << 0x01;
			a2_105.u0 = 0;
			if ((a4_74 & 7) != 0x00)
			{
				if (a7_4 != (struct Eq_84 *) 2)
				{
					if (a7_4 != (struct Eq_84 *) 3)
					{
						a2_105.u0 = 1;
						if (a7_4 == null && (a4_74 & 0x0F) != 4)
							a4_74 += 4;
					}
					else
					{
						a2_105 = a1 >> 0x1F;
						if (a1 >> 0x1F == 0x00)
						{
							a4_74 += 8;
							a2_105.u0 = 1;
						}
					}
				}
				else
				{
					a2_105.u0 = 1;
					if (a1 >> 0x1F != 0x00)
					{
						a4_74 += 8;
						a2_105 = a1 >> 0x1F;
					}
				}
			}
			a4_103 = (a4_74 >> 0x1B ^ 1) & 1;
			a6_112 = 0;
			goto l23070A08;
		}
		a3_102 |= 0x00800000;
		int32 a2_48 = 30 - (t1_10 + -896);
		if (a2_48 <= 31)
		{
			a3_102 = (word32) (a0 << 0x03 << t1_10 + -894 != 0x00) | (a3_102 | 0x00800000) << t1_10 + -894;
			a5_100 = a0 << 0x03 >> a2_48 | a3_102;
		}
		else
		{
			uint32 a6_53 = (a3_102 | 0x00800000) >> -2 - (t1_10 + -896);
			int32 a4_54 = 0;
			if (a2_48 != 32)
				a4_54 = (a3_102 | 0x00800000) << t1_10 + -862;
			a5_100 = a6_53 | (word32) ((a4_54 | a0 << 0x03) != 0x00);
		}
	}
	else
	{
		a5_100 = a3_102 | a0 << 0x03;
		if (t1_10 != 0x00)
		{
			if (a5_100 == 0x00)
			{
				a2_105.u0 = 0;
				a6_112 = 0x00FF;
				goto l230708C4;
			}
			a2_105.u0 = 0;
			if (t1_10 == 0x07FF)
				a2_105 = (word32) ((a3_102 & 0x00400000) < 1) << 0x04;
			a5_100 = a3_102 << 0x03 | 0x02000000;
			a6_112 = 0x00FF;
l23070A08:
			a3_102 = a5_100 & 7;
			if (a3_102 != 0x00)
			{
l23070878:
				a3_102.u0 = 2;
				a2_105 |= 1;
				if (a7_4 != (struct Eq_84 *) 2)
				{
					a3_102.u0 = 3;
					if (a7_4 != (struct Eq_84 *) 3)
					{
						if (a7_4 == null)
						{
							a3_102 = a5_100 & 0x0F;
							if (a3_102 != 4)
								a5_100 = (word32) a5_100.u0 + 4;
						}
						goto l230708A0;
					}
					if (a1 >> 0x1F != 0x00)
						goto l230708A0;
				}
				else if (a1 >> 0x1F == 0x00)
					goto l230708A0;
				a5_100 = (word32) a5_100.u0 + 8;
l230708A0:
				if (a4_103 != 0x00)
					a2_105 |= 2;
				goto l230708C4;
			}
			if (a4_103 != 0x00)
			{
				a4_103 = a2_105 & 1;
				goto l230708A0;
			}
l230708C4:
			if (a5_100 << 0x05 >= 0x00)
			{
l230708E4:
				uint32 a5_177 = a5_100 >> 0x03;
				if (a6_112 == 0x00FF && a5_177 != 0x00)
				{
					a5_177 = 0x00400000;
					a1_16.u0 = 0;
				}
				uint32 a1_192 = a1_16 << 0x1F;
				struct Eq_64458 * a5_194 = (word32) (word23) a5_177 | (a6_112 & 0x00FF) << 0x17 | a1_192;
				if (a2_105 != 0x00)
					__csrrs(fflags, ra);
				a2Out = a2_105;
				a3Out = a3_102;
				a4Out = (int8 *) 0x00FF;
				a5Out = a5_194;
				fa0Out = a5_194;
				return a1_192;
			}
			++a6_112;
			if (a6_112 != 0x00FF)
			{
				a5_100 &= ~0x04000000;
				goto l230708E4;
			}
			a5_100.u0 = 0;
			if (a7_4 != null)
			{
				if (a7_4 == (struct Eq_84 *) 3)
				{
					if (a1 >> 0x1F == 0x00)
						goto l23070AE8;
				}
				else if (a7_4 == (struct Eq_84 *) 2 && a1 >> 0x1F != 0x00)
					goto l23070AE8;
				a5_100.u0 = -1;
				a6_112 = 0x00FE;
			}
l23070AE8:
			a2_105 |= 5;
			goto l230708E4;
		}
		a5_100 = (word32) (a5_100 != 0x00);
	}
	if (a5_100 == 0x00)
	{
		a6_112 = 0;
		a2_105.u0 = 0;
		goto l230708C4;
	}
	goto l2307096C;
}

// 23070AF0: Register Eq_2 atoi(Register Eq_2 a0, Register out ptr32 a1Out, Register out ptr32 a2Out, Register out ptr32 a3Out, Register out Eq_6606 a4Out, Register out ptr32 a5Out)
// Called from:
//      aws_main_entry
//      cmd_wifi_cfg
//      cmd_wifi_ap_start
//      cmd_wifi_ap_conf_max_sta
//      wifi_rc_fixed_enable
//      wifi_capcode_cmd
//      cmd_gpio_get
//      cmd_gpio_set
//      cmd_gpio_func
//      cmd_wdt_init
//      httpc_tcp_recv
//      lwip_getaddrinfo
//      netif_find
//      TCP_Server
//      ping_cmd
Eq_2 atoi(Eq_2 a0, ptr32 & a1Out, ptr32 & a2Out, ptr32 & a3Out, union Eq_6606 & a4Out, ptr32 & a5Out)
{
	ptr32 a1_7;
	ptr32 a2_8;
	ptr32 a3_9;
	Eq_6606 a4_10;
	ptr32 a5_11;
	Eq_2 a0_6 = strtol(a0, null, 0x0A, out a1_7, out a2_8, out a3_9, out a4_10, out a5_11);
	a1Out = a1_7;
	a2Out = a2_8;
	a3Out = a3_9;
	a4Out = a4_10;
	a5Out = a5_11;
	return a0_6;
}

// 23070AFC: void _atoi_r(Register (ptr32 Eq_2) a0, Register Eq_2 a1)
void _atoi_r(union Eq_2 * a0, Eq_2 a1)
{
	_strtol_r(a0, a1, null, 0x0A);
}

// 23070B08: Register (ptr32 Eq_2) __errno(Register out ptr32 a5Out)
// Called from:
//      aos_loop_run
//      _stat
union Eq_2 * __errno(ptr32 & a5Out)
{
	union Eq_2 * a0_6 = g_ptr4200D994;
	a5Out = 0x4200D994;
	return a0_6;
}

// 23070B18: Register Eq_2 memchr(Register Eq_2 a0, Register int32 a1, Register Eq_2 a2, Register out Eq_127893 a3Out, Register out Eq_2 a5Out)
// Called from:
//      fdt_get_string
//      fdt_subnode_offset_namelen
//      tc_blfdtdump
Eq_2 memchr(Eq_2 a0, int32 a1, Eq_2 a2, union Eq_127893 & a3Out, union Eq_2 & a5Out)
{
	Eq_2 a5_100;
	if ((a0 & 3) != 0x00)
	{
		a5_100 = (word32) a2 - 1;
		if (a2 != 0x00)
		{
			if ((word32) *a0.u0 != (a1 & 0x00FF))
			{
				a3.u0 = -1;
				do
				{
					a0 = (word16) a0.u0 + 1;
					if ((a0 & 3) == 0x00)
						goto l23070B58;
					a5_100 = (word32) a5_100 - 1;
					if (a5_100 == -1)
						goto l23070B84;
				} while ((word32) *a0 != (a1 & 0x00FF));
			}
			goto l23070B88;
		}
	}
	else
	{
		a5_100 = a2;
l23070B58:
		if (a5_100 > 3)
		{
			ui32 a1_31 = a1 << 0x08 & 0xFFFF | a1 & 0x00FF;
			ui32 a7_33 = a1_31 << 0x10 | a1_31;
			do
			{
				ui32 a4_43 = a7_33 ^ *a0;
				a3 = a4_43 + ~0x01010100;
				if ((a4_43 + ~0x01010100 & ~a4_43 & 0x80808080) != 0x00)
					goto l23070B64;
				a5_100 = (word32) a5_100 - 4;
				a0 = (word32) a0 + 4;
			} while (a5_100 > 3);
		}
		if (a5_100 != 0x00)
		{
l23070B64:
			if ((word32) *a0 != (a1 & 0x00FF))
			{
				a5_100 = a0 + a5_100;
				do
				{
					a0 = (word32) a0 + 1;
					if (a5_100 == a0)
						goto l23070B84;
				} while ((word32) *a0 != (a1 & 0x00FF));
			}
l23070B88:
			a3Out = a3;
			a5Out = a5_100;
			return a0;
		}
	}
l23070B84:
	a0.u0 = 0;
	goto l23070B88;
}

// 23070BF4: Register Eq_2 memcmp(Register Eq_2 a0, Register Eq_2 a1, Register Eq_2 a2, Register out Eq_2 a1Out, Register out Eq_2 a2Out, Register out (ptr32 Eq_32722) a3Out, Register out (ptr32 Eq_32722) a4Out, Register out Eq_32724 a5Out)
// Called from:
//      rxu_cntrl_frame_handle
//      scanu_search_by_ssid
//      scanu_rm_exist_ssid
//      _aid_list_delete
//      apm_probe_req_handler
//      apm_assoc_req_handler
//      process_rsn_ie
//      process_wpa_ie
//      IsEAPOL_MICValid
//      parseKeyKDE
//      KeyMgmtSta_IsRxEAPOLValid
//      supplicantAkmIsWpaWpa2
//      supplicantAkmIsWpa2
//      supplicantConstructContext
//      pmkCacheFindPSKElement
//      chan_ctxt_add
//      rxu_mgt_ind_handler
//      bl_utils_idx_lookup
//      stateGlobalGuard_scan_beacon
//      fdt_subnode_offset_namelen
//      fdt_get_property_namelen_
//      ota_tcp_cmd
//      ls_cmd
//      psm_test_cmd
//      vfs_uart_init
//      hal_gpio_init_from_dts
//      ethernet_input
//      dhcp_server_recv
//      file_info
//      dirent_file
//      romfs_register
//      mbedtls_rsa_rsassa_pss_verify_ext
//      mbedtls_rsa_pkcs1_verify
//      mbedtls_ssl_prepare_handshake_record
//      mbedtls_ssl_parse_certificate
//      x509_name_cmp
//      x509_crt_check_parent
//      x509_crt_verify_top.isra.7
//      mbedtls_x509_crt_check_extended_key_usage
//      mbedtls_x509_crt_verify_with_profile
//      mbedtls_x509_crt_parse_der
//      oid_sig_alg_from_asn1.part.0
//      mbedtls_oid_get_attr_short_name
//      mbedtls_oid_get_x509_ext_type
//      mbedtls_oid_get_extended_key_usage
//      mbedtls_oid_get_pk_alg
//      mbedtls_oid_get_ec_grp
//      mbedtls_oid_get_md_alg
//      mbedtls_pem_read_buffer
//      mbedtls_ssl_handshake_server_step
//      two_way_long_needle
//      strstr
Eq_2 memcmp(Eq_2 a0, Eq_2 a1, Eq_2 a2, union Eq_2 & a1Out, union Eq_2 & a2Out, struct Eq_32722 & a3Out, struct Eq_32722 & a4Out, union Eq_32724 & a5Out)
{
	Eq_32724 a5_17;
	if (a2 > 3)
	{
		a3 = (struct Eq_32722 *) 3;
		if (((a0 | a1) & 3) != 0x00)
		{
l23070C6C:
			a5_17 = (word32) a2 - 1;
l23070C30:
			a4 = (word32) *a0;
			a3 = (word32) *a1;
			if (a4 == a3)
			{
				a4 = (word32) a5_17 + 1;
				a5_17 = (word32) a0 + 1;
				word32 a0_39 = a0 + a4;
				do
				{
					a1 = (word32) a1 + 1;
					if (a5_17 == a0_39)
						goto l23070C64;
					a4 = (word32) *a5_17;
					a3 = (word32) *a1;
					a5_17 = (word32) a5_17 + 1;
				} while (a4 == a3);
			}
			a1Out = a1;
			a2Out = a2;
			a3Out = a3;
			a4Out = a4;
			a5Out = a5_17;
			return a4 - a3;
		}
		do
		{
			a4 = (struct Eq_32722 *) *a0;
			if (a4 != *a1)
				goto l23070C6C;
			a2 = (word32) a2 - 4;
			a0 = (word32) a0 + 4;
			a1 = (word32) a1 + 4;
		} while (a2 > 3);
	}
	a5_17 = (word32) a2 - 1;
	if (a2 == 0x00)
	{
l23070C64:
		a1Out = a1;
		a2Out = a2;
		a3Out = a3;
		a4Out = a4;
		a5Out = a5_17;
		return 0;
	}
	goto l23070C30;
}

// 23070C7C: Register int32 memcpy(Register Eq_2 a0, Register Eq_2 a1, Register Eq_2 a2, Register out Eq_2 a1Out, Register out Eq_2 a2Out, Register out Eq_2 a3Out, Register out Eq_2 a4Out, Register out Eq_2 a5Out, Register out Eq_1732 a6Out, Register out Eq_2 a7Out)
// Called from:
//      http_test_cmd
//      aws_main_entry
//      mm_sta_add
//      mm_bcn_change
//      ps_send_pspoll
//      scan_probe_req_tx
//      sta_mgmt_register
//      txl_frame_get
//      txl_frame_send_null_frame
//      txl_frame_send_qosnull_frame
//      txl_frame_send_eapol_frame
//      vif_mgmt_register
//      rc_update_stats
//      rc_init
//      rxu_cntrl_frame_handle
//      scanu_scan_next
//      scanu_start
//      sm_scan_bss
//      sm_join_bss
//      sm_set_bss_param
//      sm_disconnect
//      sm_connect_ind
//      sm_auth_send
//      sm_assoc_req_send
//      sm_handle_supplicant_result
//      txu_cntrl_sechdr_len_compute
//      apm_start_cfm
//      apm_set_bss_param
//      apm_sta_add
//      apm_send_mlme
//      apm_bcn_set
//      apm_assoc_req_handler
//      keyMgmtSta_StartSession
//      supplicantInitSession
//      supplicantEnable
//      keyMgmtFormatWpaRsnIe
//      add_key_to_mac
//      add_mfp_key_to_mac
//      keyMgmtPlumbPairwiseKey
//      process_rsn_ie
//      process_wpa_ie
//      isApReplayCounterFresh
//      updateApReplayCounter
//      formEAPOLEthHdr
//      IsEAPOL_MICValid
//      parseKeyDataGTK
//      KeyMgmtSta_PrepareEAPOLFrame
//      supplicantConstructContext
//      KeyMgmtSta_DeriveKeys
//      GetKeyMsgNonceFromEAPOL
//      ProcessRxEAPOL_GrpMsg1
//      bl_sha256_crypto_kdf
//      pmkCacheSetPassphrase
//      pmkCacheAddPSK
//      RC4_Encrypt
//      sha256_compress
//      sha256_vector
//      hmac_sha256_vector
//      ProcessKeyMgmtDataAp
//      GenerateGTK_internal
//      PopulateKeyMsg
//      prepareKDE
//      Encrypt_keyData
//      KeyMgmtAp_DerivePTK
//      KeyData_CopyWPAWP2
//      InitKeyMgmtInfo
//      cm_InitConnection
//      cm_SetPeerAddr
//      cm_SetComData
//      trpc_power_get
//      rf_pri_update_tx_power_offset
//      mm_hw_config_handler
//      me_build_beacon
//      me_rc_stats_req_handler
//      me_chan_config_req_handler
//      me_config_req_handler
//      me_sta_add_req_handler
//      scanu_raw_send_req_handler
//      rxu_mgt_ind_handler
//      scanu_join_cfm_handler
//      sm_connect_req_handler
//      mm_sta_add_cfm_handler
//      apm_start_req_handler
//      Bl_hmac_md5
//      Bl_hmac_sha1
//      Bl_PRF
//      wpa_MD5Update
//      wpa_MD5Final
//      ap_setpsk
//      InitializeAp
//      ipc_host_init
//      bl_main_apm_sta_info_get
//      bl_send_start
//      bl_send_add_if
//      bl_send_sm_connect_req
//      bl_send_apm_start_req
//      bl_rx_apm_sta_add_ind
//      bl_rx_scanu_result_ind
//      bl_output
//      stateGlobalGuard_scan_beacon
//      wifi_mgmr_ap_sta_info_get_internal
//      wifi_mgmr_api_scan_item_beacon
//      wifi_mgmr_api_ap_start
//      cmd_wifi_power_table_update
//      wifi_mgmr_sta_enable
//      wifi_mgmr_sta_ssid_set
//      wifi_mgmr_sta_psk_set
//      wifi_mgmr_sta_connect
//      wifi_mgmr_ap_enable
//      wifi_mgmr_ap_sta_info_get
//      wifi_mgmr_cfg_req
//      wifi_mgmr_profile_add
//      wifi_mgmr_profile_get
//      cmd_mgr_msgind
//      tc_fdt_wifi_module
//      ota_tcp_cmd
//      cli_main_input
//      psm_test_cmd
//      prvCopyDataToQueue
//      prvCopyDataFromQueue
//      prvWriteBytesToBuffer
//      prvReadBytesFromBuffer
//      bl_uart_init
//      bl_chip_info
//      bl_rand_stream
//      bl_wifi_sta_mac_addr_set
//      bl_wifi_ap_mac_addr_set
//      bl_wifi_mac_addr_get
//      bl_wifi_ap_info_set
//      bl_wifi_sta_info_set
//      bl_wifi_sta_info_get
//      cmd_timer_start
//      vfs_uart_init
//      hal_uart_setconfig
//      hal_board_cfg
//      bl_tsen_adc_get
//      PtTable_Update_Entry
//      PtTable_Get_Active_Entries
//      lwip_getaddrinfo
//      lwip_sock_make_addr.isra.3
//      lwip_accept
//      lwip_sendto
//      dns_gethostbyname
//      lwip_chksum_copy
//      etharp_input
//      etharp_request
//      ip4_output_if_opt
//      pbuf_copy
//      pbuf_copy_partial
//      pbuf_take
//      pbuf_take_at
//      tcp_seg_copy
//      ethernet_output
//      icmp_input
//      icmp_dest_unreach
//      dhcp_client_find_by_ip.isra.0
//      dhcp_server_recv
//      dhcpd_start
//      ping_recv
//      romfs_read
//      dirent_file
//      utils_sha256_update
//      Bl_F_fast.constprop.0
//      utils_wifi_psk_cal_fast_bin
//      utils_hmac_sha1_fast
//      inode_reserve
//      aos_poll_read_fd
//      event_write
//      event_read
//      aws_iot_shadow_init
//      aws_iot_shadow_connect
//      isJsonKeyMatchingAndUpdateValue
//      shadow_delta_callback
//      AckStatusCallback
//      addToAckWaitList
//      aws_iot_mqtt_init
//      aws_iot_mqtt_publish
//      aws_iot_mqtt_internal_write_utf8_string
//      mfg_media_read_macaddr
//      Bl_F
//      bl60x_fw_password_hash
//      bl_mtd_write
//      block_cipher_df
//      ctr_drbg_update_internal
//      mbedtls_ctr_drbg_reseed
//      mbedtls_ctr_drbg_random
//      mbedtls_entropy_func
//      mbedtls_rsa_rsaes_oaep_encrypt
//      mbedtls_rsa_pkcs1_encrypt
//      mbedtls_rsa_rsaes_oaep_decrypt
//      mbedtls_rsa_pkcs1_decrypt
//      mbedtls_rsa_pkcs1_sign
//      ssl_swap_epochs
//      tls_prf_sha256
//      mbedtls_ssl_derive_keys
//      mbedtls_ssl_set_hostname
//      mbedtls_ssl_write_record
//      mbedtls_ssl_resend
//      mbedtls_ssl_prepare_handshake_record
//      mbedtls_ssl_write_certificate
//      mbedtls_ssl_write_finished
//      mbedtls_ssl_write
//      mbedtls_ssl_read_record_layer
//      mbedtls_ssl_read
//      mbedtls_x509_crt_parse_der
//      mbedtls_aes_crypt_cbc
//      mbedtls_mpi_grow
//      mbedtls_mpi_shrink
//      mbedtls_mpi_copy
//      mpi_montmul
//      mbedtls_mpi_exp_mod
//      mbedtls_cipher_set_iv
//      mbedtls_cipher_update
//      mbedtls_cipher_auth_encrypt
//      mbedtls_debug_print_crt
//      ecp_mod_p256k1
//      mbedtls_gcm_starts
//      sha224_clone_wrap
//      sha224_update_wrap
//      pem_aes_decrypt
//      mbedtls_md5_clone
//      mbedtls_md5_update
//      mbedtls_sha1_clone
//      mbedtls_sha1_update
//      mbedtls_ssl_handshake_client_step
//      mbedtls_ssl_handshake_server_step
int32 memcpy(Eq_2 a0, Eq_2 a1, Eq_2 a2, union Eq_2 & a1Out, union Eq_2 & a2Out, union Eq_2 & a3Out, union Eq_2 & a4Out, union Eq_2 & a5Out, union Eq_1732 & a6Out, union Eq_2 & a7Out)
{
	Eq_2 a4_11;
	ui32 a5_5 = a1 ^ a0;
	Eq_2 a5_118 = a5_5 & 3;
	word32 a7_8 = a0 + a2;
	if ((a5_5 & 3) == 0x00)
	{
		a5_118.u0 = 3;
		if (a2 > 3)
		{
			a4_11 = (word32) a0 + 1;
			if ((a0 & 3) != 0x00)
			{
				do
				{
					a3 = (word32) *a1;
					a4_11 = a4_11;
					((word32) a4_11 + 0x0FFF)->u1 = (byte) a3;
					a1 = (word32) a1 + 1;
					if ((a4_11 & 3) == 0x00)
						break;
					a3 = (word32) *a1;
					((word32) a4_11 + 0x00001000)->u1 = (byte) a3;
					++a4_11;
					a1 = (word32) a1 + 1;
				} while ((a4_11 + 1 & 3) != 0x00);
			}
			a2 = a7_8 & -4;
			a5_118 = (a7_8 & -4) + -32;
			while (a4_11 < a5_118)
			{
				int32 t0_36 = *((word32) a1 + 4);
				int32 t6_37 = *((word32) a1 + 8);
				int32 t5_38 = *((word32) a1 + 0x0C);
				int32 t4_39 = *((word32) a1 + 16);
				int32 t3_40 = *((word32) a1 + 20);
				t1 = (int32) *((word32) a1 + 24);
				a6 = *((word32) a1 + 28);
				*a4_11 = *a1;
				a1 = (word32) a1 + 36;
				a3 = *((word32) a1 - 4);
				*((word32) a4_11 + 4) = t0_36;
				*((word32) a4_11 + 8) = t6_37;
				*((word32) a4_11 + 0x0C) = t5_38;
				*((word32) a4_11 + 16) = t4_39;
				*((word32) a4_11 + 20) = t3_40;
				*((word32) a4_11 + 24) = t1;
				*((word32) a4_11 + 28) = a6;
				a4_11 = (word32) a4_11 + 36;
				*((word32) a4_11 + 0x0FFC) = a3;
			}
			if (a4_11 < (a7_8 & -4))
			{
				a3 = a1;
				Eq_2 a5_63 = a4_11;
				do
				{
					a6 = *a3;
					a5_63 = (word32) a5_63 + 4;
					*((word32) a5_63 + 0x0FFC) = a6;
					a3 = (word32) a3 + 4;
				} while (a5_63 < (a7_8 & -4));
				a5_118 = ((a7_8 & -4) + -1 - a4_11 & -4) + 4;
				a4_11 += a5_118;
				a1 += a5_118;
			}
			if (a4_11 >= a7_8)
			{
l23070CE8:
				a1Out = a1;
				a2Out = a2;
				a3Out = a3;
				a4Out = a4_11;
				a5Out = a5_118;
				a6Out = a6;
				a7Out.u0 = <invalid>;
				return t1;
			}
l23070CF4:
			do
			{
				Eq_2 a5_87 = (word32) *a1;
				a4_11 = (word32) a4_11 + 1;
				((word32) a4_11 + 0x0FFF)->u1 = (byte) a5_87;
				a1 = (word32) a1 + 1;
			} while (a4_11 < a7_8);
			a1Out = a1;
			a2Out = a2;
			a3Out = a3;
			a4Out = a4_11;
			a5Out = a5_87;
			a6Out = a6;
			a7Out.u0 = <invalid>;
			return t1;
		}
	}
	a4_11 = a0;
	if (a0 >= a7_8)
		goto l23070CE8;
	goto l23070CF4;
}

// 23070D98: Register Eq_2 memmove(Register Eq_2 a0, Register Eq_2 a1, Register (ptr32 Eq_28011) a2, Register out Eq_2 a3Out, Register out (ptr32 byte) a4Out, Register out Eq_2 a5Out)
// Called from:
//      rc_sort_samples_tp
//      mbedtls_ssl_write_record
//      mbedtls_ssl_fetch_input
//      mbedtls_ssl_prepare_handshake_record
//      mbedtls_ssl_read_record_layer
Eq_2 memmove(Eq_2 a0, Eq_2 a1, struct Eq_28011 * a2, union Eq_2 & a3Out, byte & a4Out, union Eq_2 & a5Out)
{
	if (a1 < a0)
	{
		word32 a5_6 = a1 + a2;
		if (a0 < a5_6)
		{
			word32 a4_81 = a0 + a2;
			if (a2 == null)
			{
				a3Out = a3;
				a4Out = a4_81;
				a5Out = a5_6;
				return a1;
			}
			else
			{
				do
				{
					a5_6 = (word32) a5_6 - 1;
					Eq_2 a3_85 = (word32) *a5_6;
					a4_81 += -1;
					*a4_81 = (byte) a3_85;
				} while (a1 != a5_6);
				a3Out = a3_85;
				a4Out = a4_81;
				a5Out = a5_6;
				return a1;
			}
		}
	}
	Eq_2 a5_14;
	Eq_2 a3_13;
	if (a2 <= (struct Eq_28011 *) 0x0F)
		a5_14 = a0;
	else
	{
		if (((a1 | a0) & 3) != 0x00)
		{
			a3_13 = (char *) a2 - 1;
			a5_14 = a0;
			goto l23070DD8;
		}
		ui32 a7_16 = (char *) a2 - 16 & -16;
		Eq_2 a6_18 = (word32) a0 + (a7_16 + 16);
		Eq_2 a4_19 = a1;
		a5_14 = a0;
		do
		{
			a5_14 = (word32) a5_14 + 16;
			*((word32) a5_14 + 0x0FF0) = *a4_19;
			a4_19 = (word32) a4_19 + 16;
			*((word32) a5_14 + 0x0FF4) = *((word32) a4_19 - 0x0C);
			*((word32) a5_14 + 0x0FF8) = *((word32) a4_19 - 8);
			*((word32) a5_14 + 0x0FFC) = *((word32) a4_19 - 4);
		} while (a6_18 != a5_14);
		a4 = a2 & 0x0C;
		a1 = (word32) a1 + (a7_16 + 16);
		if ((a2 & 0x0C) != 0x00)
		{
			Eq_2 a4_42 = a1;
			Eq_2 a7_43 = a5_14;
			do
			{
				a4_42 = (word32) a4_42 + 4;
				a7_43 = (word32) a7_43 + 4;
				*((word32) a7_43 + 0x0FFC) = *((word32) a4_42 - 4);
			} while ((word32) a1 + ((a2 & 0x0F) - a4_42) > 3);
			a4 = ((a2 & 0x0F) + -4 & -4) + 4;
			a2 &= 3;
			a5_14 += a4;
			a1 += a4;
		}
		else
			a2 &= 0x0F;
	}
	a3_13 = (char *) a2 - 1;
	if (a2 == null)
	{
		a3Out = a3_13;
		a4Out = a4;
		a5Out = a5_14;
		return a1;
	}
l23070DD8:
	Eq_2 a3_72 = (word32) a5_14 + ((word32) a3_13 + 1);
	do
	{
		a1 = (word32) a1 + 1;
		byte * a4_76 = (word32) *((word32) a1 - 1);
		a5_14 = (word32) a5_14 + 1;
		((word32) a5_14 + 0x0FFF)->u1 = (byte) a4_76;
	} while (a5_14 != a3_72);
	a3Out = a3_72;
	a4Out = a4_76;
	a5Out = a5_14;
	return a1;
}

// 23070EB8: Register Eq_2 memset(Register Eq_2 ra, Register Eq_2 a0, Register Eq_1196 a1, Register Eq_2 a2, Register out Eq_2 t1Out, Register out Eq_2 a0Out, Register out Eq_1196 a1Out, Register out Eq_2 a2Out, Register out Eq_2 a3Out, Register out Eq_2 a4Out, Register out (ptr32 Eq_1204) a5Out)
// Called from:
//      cmd_httpc_test
//      http_test_cmd
//      event_cb_wifi_event
//      mm_env_init
//      mm_init
//      mm_sta_add
//      mm_sta_del
//      mm_bcn_init_vif
//      ps_init
//      scan_init
//      sta_mgmt_entry_init
//      sta_mgmt_add_key
//      td_reset
//      txl_cntrl_init
//      txl_reset
//      txl_frame_init_desc
//      txl_frame_init
//      vif_mgmt_init
//      vif_mgmt_unregister
//      vif_mgmt_add_key
//      me_init
//      rc_update_stats
//      rc_init
//      rxu_swdesc_upload_evt
//      scanu_init
//      scanu_rm_exist_ssid
//      _aid_list_delete
//      apm_init
//      apm_assoc_req_handler
//      ke_msg_alloc
//      GetTxEAPOLBuffer
//      init_customApp_mibs
//      supplicantInit
//      add_key_to_mac
//      add_mfp_key_to_mac
//      IsEAPOL_MICValid
//      KeyMgmtSta_PrepareEAPOLFrame
//      set_psk
//      pmkCacheInit
//      pmkCacheNewElement
//      pmkCacheDeletePSK
//      hmac_sha256_vector
//      PrepDefaultEapolMsg
//      InitStaKeyInfo
//      prepareKDE
//      cm_InitConnection
//      ipc_emb_init
//      ipc_emb_tx_evt
//      phy_tcal_reset
//      chan_init
//      chan_ctxt_del
//      mm_monitor_enable_req_handler
//      bl_init
//      txl_cfm_init
//      me_build_associate_req
//      me_build_beacon
//      me_build_probe_rsp
//      me_build_associate_rsp
//      rxu_mgt_ind_handler
//      dbg_init
//      generate_subkey
//      bl_aes_cmac
//      Bl_hmac_md5
//      Bl_hmac_sha1
//      Bl_PRF
//      wpa_MD5Transform
//      wpa_MD5Final
//      Bl_SHA1Final
//      InitializeAp
//      ipc_host_init
//      bl_main_monitor
//      bl_main_apm_start
//      bl_main_apm_sta_delete
//      bl_main_connect
//      bl_send_msg
//      bl_msg_zalloc.constprop.3
//      notify_event_scan_done
//      bl_rx_chan_switch_ind
//      bl_rx_sm_connect_ind
//      bl_rx_sm_disconnect_ind
//      bl_rx_scanu_result_ind
//      bl_output
//      tcpip_stack_input
//      bl_ipc_init
//      stateGlobalGuard_scan_beacon
//      wifi_mgmr_ap_sta_info_get_internal
//      wifi_mgmr_api_ip_update
//      wifi_mgmr_api_reconnect
//      wifi_mgmr_api_disable_autoreconnect
//      wifi_mgmr_api_enable_autoreconnect
//      wifi_mgmr_api_disconnect
//      wifi_mgmr_api_ifaceup
//      wifi_mgmr_api_sniffer_enable
//      wifi_mgmr_api_scan_item_beacon
//      wifi_mgmr_api_fw_disconnect
//      wifi_mgmr_api_fw_tsen_reload
//      wifi_mgmr_api_fw_scan
//      wifi_mgmr_api_fw_powersaving
//      wifi_mgmr_api_ap_start
//      wifi_mgmr_api_ap_stop
//      wifi_mgmr_api_idle
//      wifi_mgmr_api_raw_send
//      wifi_ap_sta_list_get_cmd
//      wifi_ap_sta_delete_cmd
//      cmd_wifi_ap_start
//      wifi_denoise_disable_cmd
//      wifi_denoise_enable_cmd
//      wifi_mgmr_sta_connect
//      wifi_mgmr_ap_sta_info_get
//      wifi_mgmr_rate_config
//      wifi_mgmr_conf_max_sta
//      wifi_mgmr_cfg_req
//      wifi_mgmr_profile_add
//      wifi_mgmr_profile_get
//      cb_disconnect_ind
//      cb_connect_ind
//      netif_status_callback
//      bl606a0_wifi_init
//      cmd_blog_info_dump
//      ota_tcp_cmd
//      hexdump_cmd
//      aos_cli_init
//      aos_cli_printf
//      proc_onecmd
//      ls_cmd
//      cli_getchar
//      cli_main_input
//      get_dns_request
//      dns_server_init
//      write_status
//      format_sector.constprop.16
//      move_env
//      create_env_blob
//      ef_port_init
//      psm_test_cmd
//      prvInitialiseNewStreamBuffer
//      vStreamBufferDelete
//      prvInitialiseNewTask.isra.2
//      bl_cks_test
//      bl_dma_test
//      Sec_Eng_AES_Link_Case_CBC_128
//      Sec_Eng_AES_Link_Case_CTR_128
//      Sec_Eng_AES_Link_Case_ECB_128
//      sha256_test_case0
//      bl_wifi_ap_info_set
//      bl_wifi_sta_info_set
//      dev_uart_init
//      hal_gpio_init_from_dts
//      hal_board_cfg
//      httpc_tcp_recv
//      httpc_init_connection_common.constprop.5
//      loopset_led_trigger
//      lwip_getaddrinfo
//      lwip_sock_make_addr.isra.3
//      lwip_accept
//      lwip_select
//      altcp_alloc
//      dns_check_entry
//      dhcp_create_msg
//      dhcp_recv
//      dhcp_start
//      ip4_output_if_opt
//      netif_add
//      raw_new
//      stats_netstat
//      tcp_new_ip_type
//      udp_new_ip_type
//      dhcp_server_recv
//      dhcp_server_start
//      tcpc_entry
//      TCP_Server
//      iperf_server_udp
//      iperf_server_udp_recv_fn
//      iperf_client_udp
//      iperf_server
//      iperf_client_tcp
//      dirent_file
//      romfs_opendir
//      romfs_register
//      sntp_dns_found
//      utils_sha256_init
//      utils_hmac_sha1_fast
//      inode_init
//      aos_register_driver
//      aos_register_fs
//      aos_loop_init
//      aos_task_new
//      event_open
//      Sec_Eng_SHA256_Init
//      Sec_Eng_SHA256_Link_Init
//      mfg_media_read_poweroffset
//      bl_mtd_open
//      bloop_init
//      bloop_timer_init
//      block_cipher_df
//      ctr_drbg_update_internal
//      mbedtls_ctr_drbg_init
//      mbedtls_ctr_drbg_reseed
//      mbedtls_ctr_drbg_seed
//      mbedtls_ctr_drbg_random
//      mbedtls_entropy_init
//      mbedtls_entropy_func
//      pk_get_pk_alg
//      mgf_mask
//      mbedtls_rsa_init
//      mbedtls_rsa_rsaes_oaep_encrypt
//      mbedtls_rsa_pkcs1_sign
//      mbedtls_rsa_rsassa_pss_verify_ext
//      mbedtls_sha256_init
//      mbedtls_ssl_session_init
//      mbedtls_ssl_init
//      mbedtls_ssl_setup
//      mbedtls_ssl_config_init
//      mbedtls_ssl_write_record
//      mbedtls_ssl_prepare_handshake_record
//      mbedtls_ssl_write_finished
//      mbedtls_ssl_parse_change_cipher_spec
//      mbedtls_x509_crt_init
//      mbedtls_x509_crt_parse_der
//      mbedtls_net_connect
//      mycalloc
//      mbedtls_aes_init
//      mbedtls_mpi_copy
//      mbedtls_mpi_lset
//      mbedtls_mpi_write_binary
//      mpi_montmul
//      mbedtls_mpi_exp_mod
//      mbedtls_cipher_init
//      mbedtls_cipher_setup
//      mbedtls_cipher_auth_encrypt
//      mbedtls_debug_print_buf
//      mbedtls_debug_print_crt
//      mbedtls_ecp_group_init
//      mbedtls_ecp_mul
//      mbedtls_ecp_check_pub_priv
//      ecp_mod_p256k1
//      mbedtls_gcm_init
//      mbedtls_gcm_setkey
//      mbedtls_gcm_starts
//      mbedtls_md_init
//      mbedtls_md_hmac_starts
//      mbedtls_pem_init
//      mbedtls_pem_read_buffer
//      mbedtls_md5_init
//      mbedtls_sha1_init
//      mbedtls_ssl_handshake_server_step
//      mbedtls_x509_dn_gets
//      strstr
Eq_2 memset(Eq_2 ra, Eq_2 a0, Eq_1196 a1, Eq_2 a2, union Eq_2 & t1Out, union Eq_2 & a0Out, union Eq_1196 & a1Out, union Eq_2 & a2Out, union Eq_2 & a3Out, union Eq_2 & a4Out, struct Eq_1204 & a5Out)
{
	Eq_2 t1_14 = 0x0F;
	Eq_2 a4_25 = a0;
	if (a2 > 0x0F)
	{
		struct Eq_1204 * a5_24 = a0 & 0x0F;
		if ((a0 & 0x0F) != 0x00)
		{
			Eq_359836 a3_10 = ((a0 & 0x0F) << 0x02) + 587665260;
			word32 a4_16;
			word32 a2_17;
			word32 a5_18;
			Eq_2 t0_22;
			(*((word32) a3_10 - 96))();
			ra = t0_22;
			a5_24 = a5_18 + -16;
			a4_25 = a4_16 - (a5_18 + -16);
			a2 = a2_17 + (a5_18 + -16);
			if (t1_14 >= a2)
				goto l23070EFC;
		}
		if (a1 != 0x00)
		{
			ui32 a1_29 = a1 & 0x00FF;
			ui32 a1_31 = a1_29 | a1_29 << 0x08;
			a1 = a1_31 | a1_31 << 0x10;
		}
		a2 &= 0x0F;
		Eq_2 a3_40 = (word32) a4_25 + (a2 & -16);
		do
		{
			*a4_25 = a1;
			*((word32) a4_25 + 4) = a1;
			*((word32) a4_25 + 8) = a1;
			*((word32) a4_25 + 0x0C) = a1;
			a4_25 = (word32) a4_25 + 16;
		} while (a4_25 < a3_40);
		if (a2 == 0x00)
		{
			t1Out = t1_14;
			a0Out = a0;
			a1Out = a1;
			a2Out = a2;
			a3Out = a3_40;
			a4Out = a4_25;
			a5Out = a5_24;
			return ra;
		}
	}
l23070EFC:
	Eq_359814 a3_58 = (t1_14 - a2 << 0x02) + 587665156;
	Eq_2 t1_73;
	Eq_2 a0_74;
	Eq_2 a4_75;
	Eq_2 a2_76;
	struct Eq_1204 * a5_77;
	Eq_1196 a1_78;
	Eq_2 a3_79;
	Eq_2 ra_80;
	(*((word32) a3_58 + 0x0C))();
	t1Out = t1_73;
	a0Out = a0_74;
	a1Out = a1_78;
	a2Out = a2_76;
	a3Out = a3_79;
	a4Out = a4_75;
	a5Out = a5_77;
	return ra_80;
}

// 23070F0C: void fn23070F0C(Register ptr32 a3)
// Called from:
//      memset
void fn23070F0C(ptr32 a3)
{
	(a3 + 0x0C)();
}

// 23070F10: void fn23070F10(Register word32 a1, Register (ptr32 Eq_359894) a4)
// Called from:
//      memset
void fn23070F10(word32 a1, struct Eq_359894 * a4)
{
	a4->b000E = (byte) a1;
	a4->b000D = (byte) a1;
	a4->b000C = (byte) a1;
	a4->b000B = (byte) a1;
	a4->b000A = (byte) a1;
	a4->b0009 = (byte) a1;
	a4->b0008 = (byte) a1;
	a4->b0007 = (byte) a1;
	a4->b0006 = (byte) a1;
	a4->b0005 = (byte) a1;
	a4->b0004 = (byte) a1;
	a4->b0003 = (byte) a1;
	a4->b0002 = (byte) a1;
	a4->b0001 = (byte) a1;
	a4->b0000 = (byte) a1;
}

// 23070F14: void fn23070F14(Register word32 a1, Register (ptr32 Eq_359956) a4)
// Called from:
//      memset
void fn23070F14(word32 a1, struct Eq_359956 * a4)
{
	a4->b000D = (byte) a1;
	a4->b000C = (byte) a1;
	a4->b000B = (byte) a1;
	a4->b000A = (byte) a1;
	a4->b0009 = (byte) a1;
	a4->b0008 = (byte) a1;
	a4->b0007 = (byte) a1;
	a4->b0006 = (byte) a1;
	a4->b0005 = (byte) a1;
	a4->b0004 = (byte) a1;
	a4->b0003 = (byte) a1;
	a4->b0002 = (byte) a1;
	a4->b0001 = (byte) a1;
	a4->b0000 = (byte) a1;
}

// 23070F18: void fn23070F18(Register word32 a1, Register (ptr32 Eq_360014) a4)
// Called from:
//      memset
void fn23070F18(word32 a1, struct Eq_360014 * a4)
{
	a4->b000C = (byte) a1;
	a4->b000B = (byte) a1;
	a4->b000A = (byte) a1;
	a4->b0009 = (byte) a1;
	a4->b0008 = (byte) a1;
	a4->b0007 = (byte) a1;
	a4->b0006 = (byte) a1;
	a4->b0005 = (byte) a1;
	a4->b0004 = (byte) a1;
	a4->b0003 = (byte) a1;
	a4->b0002 = (byte) a1;
	a4->b0001 = (byte) a1;
	a4->b0000 = (byte) a1;
}

// 23070F1C: void fn23070F1C(Register word32 a1, Register (ptr32 Eq_360068) a4)
// Called from:
//      memset
void fn23070F1C(word32 a1, struct Eq_360068 * a4)
{
	a4->b000B = (byte) a1;
	a4->b000A = (byte) a1;
	a4->b0009 = (byte) a1;
	a4->b0008 = (byte) a1;
	a4->b0007 = (byte) a1;
	a4->b0006 = (byte) a1;
	a4->b0005 = (byte) a1;
	a4->b0004 = (byte) a1;
	a4->b0003 = (byte) a1;
	a4->b0002 = (byte) a1;
	a4->b0001 = (byte) a1;
	a4->b0000 = (byte) a1;
}

// 23070F20: void fn23070F20(Register word32 a1, Register (ptr32 Eq_360118) a4)
// Called from:
//      memset
void fn23070F20(word32 a1, struct Eq_360118 * a4)
{
	a4->b000A = (byte) a1;
	a4->b0009 = (byte) a1;
	a4->b0008 = (byte) a1;
	a4->b0007 = (byte) a1;
	a4->b0006 = (byte) a1;
	a4->b0005 = (byte) a1;
	a4->b0004 = (byte) a1;
	a4->b0003 = (byte) a1;
	a4->b0002 = (byte) a1;
	a4->b0001 = (byte) a1;
	a4->b0000 = (byte) a1;
}

// 23070F24: void fn23070F24(Register word32 a1, Register (ptr32 Eq_360164) a4)
// Called from:
//      memset
void fn23070F24(word32 a1, struct Eq_360164 * a4)
{
	a4->b0009 = (byte) a1;
	a4->b0008 = (byte) a1;
	a4->b0007 = (byte) a1;
	a4->b0006 = (byte) a1;
	a4->b0005 = (byte) a1;
	a4->b0004 = (byte) a1;
	a4->b0003 = (byte) a1;
	a4->b0002 = (byte) a1;
	a4->b0001 = (byte) a1;
	a4->b0000 = (byte) a1;
}

// 23070F28: void fn23070F28(Register word32 a1, Register (ptr32 Eq_360206) a4)
// Called from:
//      memset
void fn23070F28(word32 a1, struct Eq_360206 * a4)
{
	a4->b0008 = (byte) a1;
	a4->b0007 = (byte) a1;
	a4->b0006 = (byte) a1;
	a4->b0005 = (byte) a1;
	a4->b0004 = (byte) a1;
	a4->b0003 = (byte) a1;
	a4->b0002 = (byte) a1;
	a4->b0001 = (byte) a1;
	a4->b0000 = (byte) a1;
}

// 23070F2C: void fn23070F2C(Register word32 a1, Register (ptr32 Eq_360244) a4)
// Called from:
//      memset
void fn23070F2C(word32 a1, struct Eq_360244 * a4)
{
	a4->b0007 = (byte) a1;
	a4->b0006 = (byte) a1;
	a4->b0005 = (byte) a1;
	a4->b0004 = (byte) a1;
	a4->b0003 = (byte) a1;
	a4->b0002 = (byte) a1;
	a4->b0001 = (byte) a1;
	a4->b0000 = (byte) a1;
}

// 23070F30: void fn23070F30(Register word32 a1, Register (ptr32 Eq_360278) a4)
// Called from:
//      memset
void fn23070F30(word32 a1, struct Eq_360278 * a4)
{
	a4->b0006 = (byte) a1;
	a4->b0005 = (byte) a1;
	a4->b0004 = (byte) a1;
	a4->b0003 = (byte) a1;
	a4->b0002 = (byte) a1;
	a4->b0001 = (byte) a1;
	a4->b0000 = (byte) a1;
}

// 23070F34: void fn23070F34(Register word32 a1, Register (ptr32 Eq_360308) a4)
// Called from:
//      memset
void fn23070F34(word32 a1, struct Eq_360308 * a4)
{
	a4->b0005 = (byte) a1;
	a4->b0004 = (byte) a1;
	a4->b0003 = (byte) a1;
	a4->b0002 = (byte) a1;
	a4->b0001 = (byte) a1;
	a4->b0000 = (byte) a1;
}

// 23070F38: void fn23070F38(Register word32 a1, Register (ptr32 Eq_360334) a4)
// Called from:
//      memset
void fn23070F38(word32 a1, struct Eq_360334 * a4)
{
	a4->b0004 = (byte) a1;
	a4->b0003 = (byte) a1;
	a4->b0002 = (byte) a1;
	a4->b0001 = (byte) a1;
	a4->b0000 = (byte) a1;
}

// 23070F3C: void fn23070F3C(Register word32 a1, Register (ptr32 Eq_360356) a4)
// Called from:
//      memset
void fn23070F3C(word32 a1, struct Eq_360356 * a4)
{
	a4->b0003 = (byte) a1;
	a4->b0002 = (byte) a1;
	a4->b0001 = (byte) a1;
	a4->b0000 = (byte) a1;
}

// 23070F40: void fn23070F40(Register word32 a1, Register (ptr32 Eq_360374) a4)
// Called from:
//      memset
void fn23070F40(word32 a1, struct Eq_360374 * a4)
{
	a4->b0002 = (byte) a1;
	a4->b0001 = (byte) a1;
	a4->b0000 = (byte) a1;
}

// 23070F44: void fn23070F44(Register word32 a1, Register (ptr32 Eq_360388) a4)
// Called from:
//      memset
void fn23070F44(word32 a1, struct Eq_360388 * a4)
{
	a4->b0001 = (byte) a1;
	a4->b0000 = (byte) a1;
}

// 23070F48: void fn23070F48(Register word32 a1, Register (ptr32 byte) a4)
// Called from:
//      memset
void fn23070F48(word32 a1, byte * a4)
{
	*a4 = (byte) a1;
}

// 23070F94: Register Eq_2 strchr(Register Eq_2 a0, Register Eq_2 a1, Register out Eq_2 a1Out, Register out Eq_4069 a2Out, Register out Eq_4070 a3Out, Register out Eq_4071 a4Out, Register out Eq_4072 a5Out)
// Called from:
//      event_cb_wifi_event
//      proc_onecmd
//      dhcpd_start
//      dirent_file
//      strrchr
//      strstr
Eq_2 strchr(Eq_2 a0, Eq_2 a1, union Eq_2 & a1Out, union Eq_4069 & a2Out, union Eq_4070 & a3Out, union Eq_4071 & a4Out, union Eq_4072 & a5Out)
{
	Eq_4072 a5_13;
	Eq_4070 a3_123 = a1 & 0x00FF;
	if ((a1 & 0x00FF) == 0x00)
	{
		if ((a0 & 3) != 0x00)
		{
			Eq_4072 a5_8 = (word32) *a0;
			if (a5_8 == 0x00)
			{
				a1Out = a1;
				a2Out = a2;
				a3Out = a1 & 0x00FF;
				a4Out = a4;
				a5Out = a5_8;
				return a0;
			}
			do
			{
				a0 = (word32) a0 + 1;
				if ((a0 & 3) == 0x00)
					goto l23071098;
				a5_13 = (word32) *a0;
			} while (a5_13 != 0x00);
		}
		else
		{
l23071098:
			Eq_360515 a4_16 = *a0;
			a4 = ~a4_16;
			a2.u0 = ~0x01010100;
			a3_123.u0 = 0x80808080;
			if (((word32) a4_16 - 0x01010101 & a4 & 0x80808080) == 0x00)
			{
				do
				{
					a0 = (word32) a0 + 4;
					Eq_360557 a4_28 = *a0;
					a4 = ~a4_28;
				} while (((word32) a4_28 - 0x01010101 & a4 & 0x80808080) == 0x00);
			}
			a5_13 = (word32) *a0;
			if (a5_13 != 0x00)
			{
				do
				{
					a0 = (word32) a0 + 1;
					Eq_4072 a5_41 = (word32) *a0;
				} while (a5_41 != 0x00);
				a1Out = a1;
				a2Out.u0 = ~0x01010100;
				a3Out.u0 = 0x80808080;
				a4Out = a4;
				a5Out = a5_41;
				return a0;
			}
		}
l23071070:
		a1Out = a1;
		a2Out = a2;
		a3Out = a3_123;
		a4Out = a4;
		a5Out = a5_13;
		return a0;
	}
	else
	{
		if ((a0 & 3) != 0x00)
		{
			a5_13 = (word32) *a0;
			if (a5_13 != 0x00)
			{
				if ((a1 & 0x00FF) == a5_13)
				{
					a1Out = a1;
					a2Out = a2;
					a3Out = a1 & 0x00FF;
					a4Out = a4;
					a5Out = a5_13;
					return a0;
				}
				do
				{
					a0 = (word16) a0.u0 + 1;
					if ((a0 & 3) == 0x00)
						goto l23070FCC;
					a5_13 = (word32) *a0;
					if (a5_13 == 0x00)
						goto l2307106C;
				} while (a5_13 != (a1 & 0x00FF));
				goto l23071070;
			}
		}
		else
		{
l23070FCC:
			ui32 a1_53 = a1 & 0x00FF | (a1 & 0x00FF) << 0x08;
			int32 a4_56 = *a0;
			ui32 t1_58 = a1_53 << 0x10 | a1_53;
			ui32 a2_60 = t1_58 ^ a4_56;
			a1 = ~a2_60;
			a2 = a1 & a2_60 + ~0x01010100;
			a4 = a4_56 + ~0x01010100;
			if (((~a4_56 & a4_56 + ~0x01010100 | a2) & 0x80808080) == 0x00)
			{
				do
				{
					a0 = (word32) a0 + 4;
					Eq_360480 a4_75 = *a0;
					ui32 a2_77 = a4_75 ^ t1_58;
					a4 = ~a4_75;
					a2 = a2_77 + ~0x01010100 & ~a2_77;
					a1 = a2_77 + ~0x01010100;
				} while ((((word32) a4_75 - 0x01010101 & a4 | a2) & 0x80808080) == 0x00);
			}
			a5_13 = (word32) *a0;
			if (a5_13 != 0x00)
			{
				if ((a1 & 0x00FF) != a5_13)
				{
					do
					{
						a0 = (word32) a0 + 1;
						a5_13 = (word32) *a0;
						if (a5_13 == 0x00)
							goto l2307106C;
					} while (a5_13 != (a1 & 0x00FF));
					a1Out = a1;
					a2Out = a2;
					a3Out = a1 & 0x00FF;
					a4Out = a4;
					a5Out = a5_13;
					return a0;
				}
				goto l23071070;
			}
		}
l2307106C:
		a0.u0 = 0;
		goto l23071070;
	}
}

// 23071100: Register Eq_2 strcmp(Register Eq_2 a0, Register Eq_2 a1, Register out Eq_2 a1Out, Register out Eq_103467 a2Out, Register out Eq_103467 a3Out, Register out (ptr32 Eq_103469) a4Out, Register out Eq_103470 a5Out)
// Called from:
//      bl_msg_update_channel_cfg
//      stateGlobalGuard_scan_beacon
//      cmd_wifi_cfg
//      cmd_blog_info_dump
//      cmd_blog_set_level
//      proc_onecmd
//      ls_cmd
//      echo_cmd
//      hal_boot2_partition_bus_addr
//      hal_boot2_partition_addr
//      inode_open
//      findIndexOfSubscriptionList
//      AckStatusCallback
//      isSubscriptionPresent
//      incrementSubscriptionCnt
//      aws_iot_mqtt_unsubscribe
Eq_2 strcmp(Eq_2 a0, Eq_2 a1, union Eq_2 & a1Out, union Eq_103467 & a2Out, union Eq_103467 & a3Out, struct Eq_103469 & a4Out, union Eq_103470 & a5Out)
{
	ui32 a4_5 = a0 | a1;
	if ((a4_5 & 3) != 0x00)
	{
l2307120C:
		do
		{
			Eq_103467 a2_60 = (word32) *a0;
			Eq_103467 a3_62 = (word32) *a1;
			a0 = (word32) a0 + 1;
			a1 = (word32) a1 + 1;
		} while (a2_60 == a3_62 && a2_60 != 0x00);
		a1Out = a1;
		a2Out = a2_60;
		a3Out = a3_62;
		a4Out = a4_5 & 3;
		a5Out = a5;
		return a2_60 - a3_62;
	}
	else
	{
		a5.u0 = 0x7F7F7F7F;
		do
		{
			Eq_103467 a2_12 = *a0;
			Eq_103467 a3_14 = *a1;
			if (((a2_12 & 0x7F7F7F7F) + 0x7F7F7F7F | (a2_12 | 0x7F7F7F7F)) != -1)
			{
l23071234:
				if (a2_12 != a3_14)
					goto l2307120C;
				a1Out = a1;
				a2Out = a2_12;
				a3Out = a3_14;
				a4Out = a4_5 & 3;
				a5Out.u0 = 0x7F7F7F7F;
				return 0;
			}
			if (a2_12 != a3_14)
				break;
			a2_12 = *((word32) a0 + 4);
			a3_14 = *((word32) a1 + 4);
			if (((a2_12 & 0x7F7F7F7F) + 0x7F7F7F7F | (a2_12 | 0x7F7F7F7F)) != -1)
			{
				a0 = (word32) a0 + 4;
				a1 = (word32) a1 + 4;
				goto l23071234;
			}
			if (a2_12 != a3_14)
				break;
			a2_12 = *((word32) a0 + 8);
			a3_14 = *((word32) a1 + 8);
			if (((a2_12 & 0x7F7F7F7F) + 0x7F7F7F7F | (a2_12 | 0x7F7F7F7F)) != -1)
			{
				a0 = (word32) a0 + 8;
				a1 = (word32) a1 + 8;
				if (a2_12 != a3_14)
					goto l2307120C;
				a1Out = a1;
				a2Out = a2_12;
				a3Out = a3_14;
				a4Out = a4_5 & 3;
				a5Out.u0 = 0x7F7F7F7F;
				return 0;
			}
			if (a2_12 != a3_14)
				break;
			a2_12 = *((word32) a0 + 0x0C);
			a3_14 = *((word32) a1 + 0x0C);
			if (((a2_12 & 0x7F7F7F7F) + 0x7F7F7F7F | (a2_12 | 0x7F7F7F7F)) != -1)
			{
				a0 = (word32) a0 + 0x0C;
				a1 = (word32) a1 + 0x0C;
				if (a2_12 != a3_14)
					goto l2307120C;
				a1Out = a1;
				a2Out = a2_12;
				a3Out = a3_14;
				a4Out = a4_5 & 3;
				a5Out.u0 = 0x7F7F7F7F;
				return 0;
			}
			if (a2_12 != a3_14)
				break;
			a2_12 = *((word32) a0 + 16);
			a3_14 = *((word32) a1 + 16);
			if (((a2_12 & 0x7F7F7F7F) + 0x7F7F7F7F | (a2_12 | 0x7F7F7F7F)) != -1)
			{
				a0 = (word32) a0 + 16;
				a1 = (word32) a1 + 16;
				if (a2_12 != a3_14)
					goto l2307120C;
				a1Out = a1;
				a2Out = a2_12;
				a3Out = a3_14;
				a4Out = a4_5 & 3;
				a5Out.u0 = 0x7F7F7F7F;
				return 0;
			}
			a0 = (word32) a0 + 20;
			a1 = (word32) a1 + 20;
		} while (a2_12 == a3_14);
		Eq_103470 a5_76;
		struct Eq_103469 * a4_75;
		Eq_2 a1_78;
		uint32 a4_72 = a2_12 << 0x10;
		uint32 a5_74 = a3_14 << 0x10;
		if (a4_72 == a5_74)
		{
			a4_75 = a2_12 >> 0x10;
			a5_76 = a3_14 >> 0x10;
			Eq_2 a0_81 = a4_75 - a5_76;
			a1_78 = a0_81 & 0x00FF;
			if ((a0_81 & 0x00FF) == 0x00)
			{
				a1Out = a0_81 & 0x00FF;
				a2Out = a2_12;
				a3Out = a3_14;
				a4Out = a4_75;
				a5Out = a5_76;
				return a0_81;
			}
		}
		else
		{
			Eq_2 a0_77 = (a4_72 >> 0x10) - (a5_74 >> 0x10);
			a4_75 = a4_72 >> 0x10;
			a5_76 = a5_74 >> 0x10;
			a1_78 = a0_77 & 0x00FF;
			if ((a0_77 & 0x00FF) == 0x00)
			{
				a1Out = a0_77 & 0x00FF;
				a2Out = a2_12;
				a3Out = a3_14;
				a4Out = a4_72 >> 0x10;
				a5Out = a5_74 >> 0x10;
				return a0_77;
			}
		}
		a1Out = a1_78;
		a2Out = a2_12;
		a3Out = a3_14;
		struct Eq_103469 * a4_84 = a4_75 & 0x00FF;
		a4Out = a4_84;
		Eq_103470 a5_86 = a5_76 & 0x00FF;
		a5Out = a5_86;
		return a4_84 - a5_86;
	}
}

// 2307127C: Register (ptr32 Eq_133241) strcpy(Register Eq_2 a0, Register (ptr32 Eq_133241) a1, Register out ptr32 a4Out, Register out Eq_2 a5Out)
// Called from:
//      cmd_blog_info_dump
//      ps_cmd
//      aos_cli_printf
//      vTaskList
//      bl_chip_memory_ram
//      tcpclient_cmd
//      ipus_test_cmd
//      ipu_test_cmd
//      ipc_test_cmd
//      ips_test_cmd
//      bl_mtd_info
union Eq_133241 * strcpy(Eq_2 a0, union Eq_133241 * a1, ptr32 & a4Out, union Eq_2 & a5Out)
{
	if (((a0 | a1) & 3) != 0x00)
	{
		Eq_2 a5_11 = a0;
		do
		{
			ptr32 a4_10 = (word32) *a1;
			a5_11 = (word32) a5_11 + 1;
			((word32) a5_11 + 0x0FFF)->u1 = (byte) a4_10;
			a1 = (union Eq_133241 *) ((char *) a1 + 1);
		} while (a4_10 != 0x00);
		a4Out = a4_10;
		a5Out = a5_11;
		return a1;
	}
	else
	{
		Eq_2 a2_24;
		int32 a4_16 = *a1;
		if (((a4_16 & 0x7F7F7F7F) + 0x7F7F7F7F | a4_16 | 0x7F7F7F7F) == -1)
		{
			a2_24 = a0;
			do
			{
				a2_24 = (word32) a2_24 + 4;
				*((word32) a2_24 + 0x0FFC) = a4_16;
				a1 = (union Eq_133241 *) ((char *) a1 + 4);
				a4_16 = *a1;
			} while (((a4_16 & 0x7F7F7F7F) + 0x7F7F7F7F | a4_16 | 0x7F7F7F7F) == -1);
		}
		else
			a2_24 = a0;
		Eq_2 a5_42 = (word32) *a1;
		ptr32 a4_43 = (word32) *((char *) a1 + 1);
		word32 a3_44 = (word32) *((char *) a1 + 2);
		a2_24->u1 = (byte) a5_42;
		if (a5_42 != 0x00)
		{
			((word32) a2_24 + 1)->u1 = (byte) a4_43;
			if (a4_43 != 0x00)
			{
				((word32) a2_24 + 2)->u1 = (byte) a3_44;
				if (a3_44 != 0x00)
				{
					((word32) a2_24 + 3)->u1 = 0x00;
					a4Out = a4_43;
					a5Out = a5_42;
					return a1;
				}
			}
		}
		a4Out = a4_43;
		a5Out = a5_42;
		return a1;
	}
}

// 2307132C: Register Eq_2 strlen(Register Eq_2 a0, Register out (ptr32 Eq_3566) a1Out, Register out ptr32 a2Out, Register out (ptr32 Eq_2) a3Out, Register out Eq_2 a4Out, Register out Eq_3570 a5Out)
// Called from:
//      event_cb_wifi_event
//      aws_main_entry
//      mm_sta_add
//      set_psk
//      pmkCacheFindPSK
//      KeyMgmtInit
//      GenerateGTK_internal
//      cm_SetComData
//      ap_setpsk
//      InitializeAp
//      bl_send_apm_start_req
//      stateGlobalGuard_scan_beacon
//      wifi_mgmr_api_ap_start
//      wifi_ap_sta_delete_cmd
//      wifi_mgmr_sta_ssid_set
//      wifi_mgmr_sta_psk_set
//      wifi_mgmr_sta_connect
//      fdt_get_name
//      fdt_subnode_offset
//      fdt_getprop
//      utilfdt_print_data
//      tc_blfdtdump
//      cmd_blog_info_dump
//      cmd_blog_set_level
//      cli_putstr
//      ps_cmd
//      aos_cli_printf
//      ls_cmd
//      cli_main_input
//      find_env_cb
//      find_env
//      del_env
//      create_env_blob
//      ef_get_env_blob
//      ef_del_env
//      ef_set_env
//      psm_erase_cmd
//      vTaskList
//      hal_board_cfg
//      httpc_create_request_string.constprop.6
//      lwip_getaddrinfo
//      dns_check_entry
//      dns_gethostbyname
//      dhcp_option_hostname.isra.0
//      tcpclient_cmd
//      ipus_test_cmd
//      ipu_test_cmd
//      ipc_test_cmd
//      ips_test_cmd
//      romfs_ioctl
//      romfs_read
//      file_info
//      dirent_file
//      romfs_opendir
//      romfs_open
//      romfs_register
//      Bl_F_fast.constprop.0
//      utils_wifi_psk_cal_fast_bin
//      aos_open
//      inode_open
//      inode_reserve
//      aws_iot_shadow_connect
//      aws_iot_shadow_update
//      aws_iot_shadow_add_reported
//      aws_iot_finalize_json_document
//      unsubscribeFromAcceptedAndRejected
//      registerJsonTokenOnDelta
//      subscribeToShadowActionAcks
//      publishToShadowAction
//      jsoneq
//      aws_iot_mqtt_set_connect_params
//      iot_tls_connect
//      Default_Handler
//      Bl_F
//      bl60x_fw_password_hash
//      mbedtls_pk_parse_keyfile
//      tls_prf_sha256
//      mbedtls_ssl_set_hostname
//      mbedtls_ssl_conf_alpn_protocols
//      mbedtls_ssl_free
//      x509_check_wildcard
//      mbedtls_x509_crt_verify_with_profile
//      mbedtls_pem_read_buffer
//      mbedtls_ssl_handshake_client_step
//      mbedtls_ssl_handshake_server_step
//      strstr
Eq_2 strlen(Eq_2 a0, struct Eq_3566 & a1Out, ptr32 & a2Out, union Eq_2 & a3Out, union Eq_2 & a4Out, union Eq_3570 & a5Out)
{
	Eq_2 a4_17 = a0;
	if ((a0 & 3) != 0x00)
	{
		do
		{
			a4_17 = (word32) a4_17 + 1;
			Eq_3570 a5_8 = (word32) *a4_17;
			if (a5_8 == 0x00)
			{
				a1Out = a1;
				a2Out = a2;
				a3Out = a4_17 & 3;
				Eq_2 a4_12 = a4_17 - a0;
				a4Out = a4_12;
				a5Out = a5_8;
				return (word32) a4_12 - 1;
			}
		} while ((a4_17 & 3) != 0x00);
	}
	do
	{
		a4_17 = (word32) a4_17 + 4;
		int32 a2_20 = *((word32) a4_17 - 4);
	} while (((a2_20 & 0x7F7F7F7F) + 0x7F7F7F7F | a2_20 | 0x7F7F7F7F) == -1);
	union Eq_2 * a3_27 = (word32) *((word32) a4_17 - 4);
	Eq_3570 a5_30 = a4_17 - a0;
	ptr32 a2_31 = (word32) *((word32) a4_17 - 3);
	word32 a0_32 = (word32) *((word32) a4_17 - 2);
	if (a3_27 == null)
	{
		a1Out = (struct Eq_3566 *) -1;
		a2Out = a2_31;
		a3Out = a3_27;
		a4Out = a4_17;
		a5Out = a5_30;
		return (word32) a5_30 - 4;
	}
	else if (a2_31 == 0x00)
	{
		a1Out = (struct Eq_3566 *) -1;
		a2Out = a2_31;
		a3Out = a3_27;
		a4Out = a4_17;
		a5Out = a5_30;
		return (word32) a5_30 - 3;
	}
	else
	{
		a1Out = (struct Eq_3566 *) -1;
		a2Out = a2_31;
		a3Out = a3_27;
		a4Out = a4_17;
		a5Out = a5_30;
		return (word32) a5_30 + (word32) (a0_32 != 0x00) + -2;
	}
}

// 230713B8: Register Eq_2 strncmp(Register Eq_2 a0, Register Eq_2 a1, Register Eq_2 a2, Register out Eq_2 a1Out, Register out Eq_2 a2Out, Register out Eq_2 a3Out, Register out Eq_2 a4Out, Register out Eq_2 a5Out)
// Called from:
//      proc_onecmd
//      cli_main_input
//      find_env_cb
//      find_env
//      romfs_open
//      inode_open
//      jsoneq
//      parseBooleanValue
//      aws_iot_mqtt_internal_cycle_read
Eq_2 strncmp(Eq_2 a0, Eq_2 a1, Eq_2 a2, union Eq_2 & a1Out, union Eq_2 & a2Out, union Eq_2 & a3Out, union Eq_2 & a4Out, union Eq_2 & a5Out)
{
	if (a2 != 0x00)
	{
		ui32 a5_6 = a0 | a1;
		a5 = a5_6 & 3;
		if ((a5_6 & 3) == 0x00)
		{
			a5.u0 = 3;
			if (a2 > 3)
			{
				a5 = *a0;
				a4 = *a1;
				if (a5 == a4)
				{
					a2 = (word32) a2 - 4;
					if (a2 != ~0x03)
					{
						ui32 a5_18 = (word16) a5.u0 - 0x01010101 & ~a5;
						a4 = (word16) a5.u0 - 0x01010101;
						a5 = a5_18 & 0x80808080;
						if ((a5_18 & 0x80808080) == 0x00)
						{
							do
							{
								a0 = (word32) a0 + 4;
								a1 = (word32) a1 + 4;
								if (a2 <= 3)
									goto l23071444;
								a4 = *a0;
								ui32 a5_34 = (word32) a4 - 0x01010101 & ~a4;
								a3 = *a1;
								a5 = a5_34 & 0x80808080;
								if (a4 != a3)
									goto l23071494;
								a2 = (word32) a2 - 4;
							} while (a2 != 0x00 && (a5_34 & 0x80808080) == 0x00);
						}
					}
					goto l2307148C;
				}
l23071494:
				a4 = (word32) *a0;
				a3 = (word32) *a1;
				a2 = (word32) a2 - 1;
				if (a3 != a4)
				{
l23071484:
					a1Out = a1;
					a2Out = a2;
					a3Out = a3;
					a4Out = a4;
					a5Out = a5;
					return a4 - a3;
				}
				goto l23071458;
			}
		}
l23071444:
		a4 = (word32) *a0;
		a3 = (word32) *a1;
		a2 = (word32) a2 - 1;
		if (a3 != a4)
			goto l23071484;
		if (a2 != 0x00)
		{
l23071458:
			if (a4 != 0x00)
			{
				a5 = (word32) a0 + 1;
				a2 = a0 + a2;
				do
				{
					a1 = (word32) a1 + 1;
					a4 = (word32) *a5;
					a3 = (word32) *a1;
					if (a4 != a3)
						goto l23071484;
					if (a2 == a5)
						break;
					a5 = (word32) a5 + 1;
				} while (a4 != 0x00);
			}
			goto l2307148C;
		}
	}
l2307148C:
	a1Out = a1;
	a2Out = a2;
	a3Out = a3;
	a4Out = a4;
	a5Out = a5;
	return 0;
}

// 230714A8: Register Eq_2 strncpy(Register Eq_2 a0, Register Eq_2 a1, Register Eq_2995 a2, Register out Eq_2996 a3Out, Register out Eq_2 a4Out, Register out Eq_2 a5Out)
// Called from:
//      check_dts_config
//      event_cb_wifi_event
//      stateGlobalGuard_scan_beacon
//      wifi_mgmr_set_country_code_internal
//      cli_main_input
//      move_env
//      lwip_gethostbyname
//      romfs_readdir
//      aos_task_new
//      extractClientToken
//      topicNameFromThingAndAction
//      parseStringValue
//      bl_mtd_open
Eq_2 strncpy(Eq_2 a0, Eq_2 a1, Eq_2995 a2, union Eq_2996 & a3Out, union Eq_2 & a4Out, union Eq_2 & a5Out)
{
	Eq_2 a4_25;
	ui32 a5_5 = a1 | a0;
	Eq_2 a5_24 = a5_5 & 3;
	if ((a5_5 & 3) == 0x00)
	{
		a5_24.u0 = 3;
		a4_25 = a0;
		while (a2 > 3)
		{
			a3 = *a1;
			ui32 a5_22 = (word32) a3 - 0x01010101 & ~a3;
			a5_24 = a5_22 & 0x80808080;
			if ((a5_22 & 0x80808080) != 0x00)
				goto l230714C4;
			a4_25 += 4;
			*((word32) a4_25 + 0x0FFC) = a3;
			a2 = (word32) a2 - 4;
			a1 = (word32) a1 + 4;
		}
	}
	else
		a4_25 = a0;
	if (a2 != 0x00)
	{
l230714C4:
		Eq_2996 a6_46;
		word32 a6_38 = (word32) *a1;
		a4_25->u1 = (byte) a6_38;
		a3 = (word32) a2 - 1;
		a1 = (word32) a1 + 1;
		a5_24 = (word32) a4_25 + 1;
		if (a6_38 != 0x00)
		{
			word32 a2_47 = a4_25 + a2;
			a3 = a4_25 + a3;
			do
			{
				a1 = (word32) a1 + 1;
				a6_46 = a3 - a5_24;
				if (a5_24 == a2_47)
				{
					a3Out = a3;
					a4Out = a4_25;
					a5Out = a5_24;
					return a1;
				}
				a4_25 = (word32) *((word32) a1 - 1);
				++a5_24;
				((word32) a5_24 + 0x0FFF)->u1 = (byte) a4_25;
			} while (a4_25 != 0x00);
		}
		else
			a6_46 = a3;
		a4_25 = a5_24 + a6_46;
		if (a6_46 == 0x00)
		{
			a3Out = a3;
			a4Out = a4_25;
			a5Out = a5_24;
			return a1;
		}
		do
		{
			++a5_24;
			((word32) a5_24 + 0x0FFF)->u1 = 0x00;
		} while (a5_24 != a4_25);
	}
	a3Out = a3;
	a4Out = a4_25;
	a5Out = a5_24;
	return a1;
}

// 23071574: Register Eq_2 strnlen(Register Eq_2 a0, Register Eq_2 a1, Register out Eq_2 a1Out, Register out Eq_2 a3Out, Register out (ptr32 byte) a4Out, Register out Eq_2 a5Out)
// Called from:
//      fdt_stringlist_count
//      fdt_stringlist_get
//      flt
//      two_way_long_needle
//      strstr
Eq_2 strnlen(Eq_2 a0, Eq_2 a1, union Eq_2 & a1Out, union Eq_2 & a3Out, byte & a4Out, union Eq_2 & a5Out)
{
	if (a1 != 0x00)
	{
		a5 = (word32) *a0;
		if (a5 != 0x00)
		{
			a3 = a0 + a1;
			a5 = a0;
			do
			{
				a5 = (word32) a5 + 1;
				if (a5 == a3)
					goto l2307159C;
				a4 = (word32) *a5;
			} while (a4 != null);
			Eq_2 a1_16 = a5 - a0;
			a1Out = a1_16;
			a3Out = a3;
			a4Out = a4;
			a5Out = a5;
			return a1_16;
		}
		a1.u0 = 0;
	}
l2307159C:
	a1Out = a1;
	a3Out = a3;
	a4Out = a4;
	a5Out = a5;
	return a1;
}

// 230715B8: Register Eq_2 strrchr(Register Eq_2 a0, Register Eq_2 a1, Register out ptr32 a5Out)
// Called from:
//      fdt_get_name
Eq_2 strrchr(Eq_2 a0, Eq_2 a1, ptr32 & a5Out)
{
	if (a1 == 0x00)
	{
		ptr32 a5_8;
		word32 a1_71;
		word32 a2_72;
		word32 a3_73;
		word32 a4_74;
		Eq_2 a0_9 = strchr(a0, a1, out a1_71, out a2_72, out a3_73, out a4_74, out a5_8);
		a5Out = a5_8;
		return a0_9;
	}
	else
	{
		Eq_2 a5_22 = a0;
		Eq_2 s1_23 = 0;
		while (true)
		{
			ptr32 a5_31;
			word32 a1_67;
			word32 a2_68;
			word32 a3_69;
			word32 a4_70;
			Eq_2 a0_32 = strchr(a5_22, a1, out a1_67, out a2_68, out a3_69, out a4_70, out a5_31);
			if (a0_32 == 0x00)
				break;
			a5_22 = (word32) a0_32 + 1;
			s1_23 = a0_32;
		}
		a5Out = a5_31;
		return s1_23;
	}
}

// 23071610: Register Eq_2 two_way_long_needle(Register Eq_2 a0, Register Eq_2 a1, Register Eq_2 a2, Register Eq_2 a3, Register out Eq_2 a1Out, Register out Eq_2 a3Out, Register out Eq_2 a4Out, Register out Eq_2 a5Out)
// Called from:
//      strstr
Eq_2 two_way_long_needle(Eq_2 a0, Eq_2 a1, Eq_2 a2, Eq_2 a3, union Eq_2 & a1Out, union Eq_2 & a3Out, union Eq_2 & a4Out, union Eq_2 & a5Out)
{
	Eq_2 s10_221 = a1;
	Eq_2 s7_125 = 1;
	Eq_2 a3_39 = 1;
	Eq_2 a2_40 = 0;
	Eq_2 s11_41 = -1;
l23071668:
	word32 a5_48 = a3_39 + a2_40;
	word32 a4_46 = a2 + s11_41 + a3_39;
	word32 a1_49 = a2 + a5_48;
	while (a5_48 < a3)
	{
		up32 a1_53 = (word32) *a1_49;
		up32 a4_55 = (word32) *a4_46;
		if (a1_53 >= a4_55)
		{
			if (a1_53 != a4_55)
			{
				s11_41 = a2_40;
				s7_125.u0 = 1;
				a2_40 = (word32) a2_40 + 1;
				a3_39.u0 = 1;
			}
			else if (a3_39 != s7_125)
				a3_39 = (word16) a3_39.u0 + 1;
			else
			{
				a2_40 = a5_48;
				a3_39.u0 = 1;
			}
			goto l23071668;
		}
		a5_48 = (word32) a5_48 + 1;
		a2_40 = a5_48;
		a3_39.u0 = 1;
		s7_125 = a5_48 - s11_41;
		a4_46 = a2 + s11_41 + 1;
		a1_49 = a2 + a5_48;
	}
	Eq_2 a7_103 = 1;
	Eq_2 a3_100 = 1;
	Eq_2 a2_101 = 0;
	Eq_2 a1_102 = -1;
l230716B8:
	word32 a5_113 = a3_100 + a2_101;
	word32 a4_112 = a2 + a1_102 + a3_100;
	word32 a0_114 = a2 + a5_113;
	while (a5_113 < a3)
	{
		up32 a0_92 = (word32) *a0_114;
		up32 a4_94 = (word32) *a4_112;
		if (a4_94 >= a0_92)
		{
			if (a0_92 != a4_94)
			{
				a1_102 = a2_101;
				a7_103.u0 = 1;
				a2_101 = (word32) a2_101 + 1;
				a3_100.u0 = 1;
			}
			else if (a3_100 != a7_103)
				a3_100 = (word16) a3_100.u0 + 1;
			else
			{
				a2_101 = a5_113;
				a3_100.u0 = 1;
			}
			goto l230716B8;
		}
		a5_113 = (word32) a5_113 + 1;
		a2_101 = a5_113;
		a3_100.u0 = 1;
		a7_103 = a5_113 - a1_102;
		a4_112 = a2 + a1_102 + 1;
		a0_114 = a2 + a5_113;
	}
	Eq_2 a1_117 = (word32) a1_102 + 1;
	Eq_2 s11_122 = (word32) s11_41 + 1;
	if (a1_117 >= s11_122)
	{
		s7_125 = a7_103;
		s11_122 = a1_117;
	}
	word32 * a5_134 = fp + -0x0440;
	do
	{
		*a5_134 = (word32) a3;
		++a5_134;
	} while (fp + -64 != a5_134);
	word32 a1_145 = a2 + a3;
	Eq_2 a4_146 = a2;
	word32 a2_147 = (word32) a2 + ((word32) a3 - 1);
	if (a3 != 0x00)
	{
		do
		{
			(fp + -64 + ((word32) (*a4_146) << 0x02))->dw0C00 = a2_147 - a4_146;
			a4_146 = (word32) a4_146 + 1;
		} while (a4_146 != a1_145);
	}
	Eq_2 a4_1194;
	Eq_2 a5_1204;
	Eq_2 a0_1153;
	word32 a4_1274;
	word32 a2_1273;
	word32 a5_1275;
	Eq_2 a3_1181;
	Eq_2 a1_1154;
	if (memcmp(a2, a2 + s7_125, s11_122, out a1_1154, out a2_1273, out a3_1181, out a4_1274, out a5_1275) == 0x00)
	{
		word32 s5_332 = s11_122 + -1;
		word32 a5_343 = a0 + s5_332;
		word32 a5_347 = a2 + s5_332;
		Eq_2 s6_349 = 0;
		Eq_2 s8_350 = 0;
		int32 s4_352 = 1 - s11_122;
		do
		{
			word32 a2_356 = a0 + s8_350;
			a4_1194 = fp + -64;
			a5_1204 = (fp + -64 + ((word32) (*((word32) a2_356 + ((word32) a3 - 1))) << 0x02))->tFFFFFC00;
			if (a5_1204 != 0x00)
			{
				if (s6_349 != 0x00 && a5_1204 < s7_125)
					a5_1204 = a3 - s7_125;
l230717C4:
				s8_350 += a5_1204;
				s6_349.u0 = 0;
				goto l230717CC;
			}
			a5_1204 = s6_349;
			if (s6_349 < s11_122)
				a5_1204 = s11_122;
			if (a5_1204 < (word32) a3 - 1)
			{
				word32 a3_375 = a0 + a5_1204 + s8_350;
				a4_1194 = a2 + a5_1204;
				do
				{
					if ((word32) *a3_375 != (word32) (*a4_1194))
					{
						s8_350 = (word32) s8_350 + s4_352;
						goto l230717C4;
					}
					++a5_1204;
					a3_375 = a2 + a5_1204;
					a4_1194 = a0 + (a5_1204 + s8_350);
				} while (a5_1204 < (word32) a3 - 1);
			}
			a3_1181 = s5_332;
			if (s6_349 < s11_122)
			{
				a4_1194 = (word32) *((word32) s8_350 + a5_343);
				a5_1204 = (word32) *a5_347;
				if (a4_1194 != a5_1204)
					goto l23071A68;
				while (true)
				{
					a4_1194 = a3_1181 + -1;
					a1_1154 = a2 + a4_1194;
					a5_1204 = a0 + (a4_1194 + s8_350);
					if (s6_349 == a3_1181)
						break;
					a1_1154 = (word32) *a1_1154;
					a5_1204 = (word32) *a5_1204;
					if (a1_1154 != a5_1204)
						break;
					a3_1181 = a4_1194;
				}
				if (a3_1181 >= (word16) s6_349.u0 + 1)
					goto l230718F4;
l23071A74:
				a0_1153 = a2_356;
				goto l230717F0;
			}
l23071A68:
			a3_1181 = s11_122;
			if (s11_122 < (word16) s6_349.u0 + 1)
				goto l23071A74;
l230718F4:
			s8_350 += s7_125;
			s6_349 = a3 - s7_125;
l230717CC:
			if (s10_221 - a3 >= s8_350)
				continue;
			word32 a5_1276;
			s10_221 += strnlen(a0 + s10_221, a3 | 0x0800, out a1_1154, out a3_1181, out a4_1194, out a5_1276);
			a5_1204 = s10_221 - a3;
		} while (a5_1204 >= s8_350);
l230717EC:
		a0_1153.u0 = 0;
		goto l230717F0;
	}
	Eq_2 s7_186 = a3 - s11_122;
	if (s7_186 < s11_122)
		s7_186 = s11_122;
	word32 s5_189 = s11_122 + -1;
	word32 a5_192 = a2 + s5_189;
	word32 s7_196 = s7_186 + 1;
	Eq_2 s8_197 = 0;
	word32 s6_202 = s11_122 + -2;
	int32 s4_203 = 1 - s11_122;
l2307194C:
	a1_1154 = a0 + s8_197;
	Mem211 = Mem201;
	int32 a5_217 = (fp + -64 + ((word32) (*((word32) a1_1154 + ((word32) a3 - 1))) << 0x02))->dwFFFFFC00;
	while (a5_217 != 0x00)
	{
		s8_197 = (word32) s8_197 + a5_217;
l23071970:
		Mem239 = Mem201;
		if (s10_221 - a3 >= s8_197)
			goto l2307194C;
		word32 a5_1277;
		s10_221 += strnlen(a0 + s10_221, a3 | 0x0800, out a1_1154, out a3_1181, out a4_1194, out a5_1277);
		a5_1204 = s10_221 - a3;
		if (a5_1204 < s8_197)
			goto l230717EC;
		a1_1154 = a0 + s8_197;
		a5_217 = (fp + -64 + ((word32) (*((word32) a1_1154 + ((word32) a3 - 1))) << 0x02))->dwFFFFFC00;
	}
	a4_1194 = fp + -64;
	Mem256 = Mem201;
	if (s11_122 < (word32) a3 - 1)
	{
		Eq_2 a5_259 = s11_122;
		if (CONVERT(Mem256[a1_1154 + s11_122:byte], byte, word32) == CONVERT(Mem256[a2 + s11_122:byte], byte, word32))
		{
			do
			{
				++a5_259;
				word32 a2_265 = a2 + a5_259;
				a4_1194 = a0 + (s8_197 + a5_259);
				if (a5_259 >= (word32) a3 - 1)
					goto l230719F0;
			} while ((word32) *a2_265 == (word32) (*a4_1194));
		}
		a3_1181 = (word32) s8_197 + s4_203;
		s8_197 = a3_1181 + a5_259;
	}
	else
	{
l230719F0:
		a5_1204.u0 = -1;
		if (s5_189 == (byte *) -1)
		{
l23071A7C:
			a0_1153 = a1_1154;
l230717F0:
			a1Out = a1_1154;
			a3Out = a3_1181;
			a4Out = a4_1194;
			a5Out = a5_1204;
			return a0_1153;
		}
		if (CONVERT(Mem256[a1_1154 + s5_189:byte], byte, word32) == CONVERT(Mem256[a5_192 + 0x00:byte], byte, word32))
		{
			a5_1204 = a2 + s6_202;
			a4_1194 = a0 + (s8_197 + s6_202);
			do
			{
				if (a5_1278 == (word32) a2 - 1)
					goto l23071A7C;
				a5_1204 = (word32) a5_1278 - 1;
				a4_1194 = (word32) a4_1279 - 1;
				a5_1278 = a5_1204;
				a4_1279 = a4_1194;
			} while ((word32) *a5_1278 == (word32) (*a4_1279));
		}
		s8_197 += s7_196;
	}
	goto l23071970;
}

// 23071A84: Register Eq_2 strstr(Register Eq_2 ra, Register Eq_2 a0, Register Eq_2 a1, Register out Eq_2 a1Out, Register out (ptr32 Eq_133368) a3Out, Register out Eq_2 a4Out, Register out Eq_2 a5Out)
// Called from:
//      cmd_blog_info_dump
//      ota_tcp_cmd
//      AckStatusCallback
//      mbedtls_pk_load_file
//      mbedtls_x509_crt_parse
//      mbedtls_pem_read_buffer
Eq_2 strstr(Eq_2 ra, Eq_2 a0, Eq_2 a1, union Eq_2 & a1Out, struct Eq_133368 & a3Out, union Eq_2 & a4Out, union Eq_2 & a5Out)
{
	Eq_2 a1_104 = (word32) *a1;
	Eq_2 s0_121 = a0;
	if (a1_104 == 0x00)
	{
l23071BA8:
		a1Out = a1_104;
		a3Out = a3;
		a4Out = a4;
		a5Out = a5;
		return s0_121;
	}
	else
	{
		a3 = (word32) *((word32) a1 + 1);
		if (a3 == null)
		{
			word32 a2_407;
			s0_121 = strchr(a0, a1_104, out a1_104, out a2_407, out a3, out a4, out a5);
			goto l23071BA8;
		}
		ui32 a2_34 = (word32) *((word32) a1 + 2);
		if (a2_34 != 0x00)
		{
			a4 = (word32) *((word32) a1 + 3);
			if (a4 != 0x00)
			{
				if ((word32) *((word32) a1 + 4) != 0x00)
				{
					word32 a3_410;
					word32 a5_412;
					word32 a1_408;
					word32 a2_409;
					word32 a4_411;
					Eq_2 a0_94 = strlen(a1, out a1_408, out a2_409, out a3_410, out a4_411, out a5_412);
					Eq_2 a0_103 = strnlen(a0, a0_94 | 0x0200, out a1_104, out a3, out a4, out a5);
					if (a0_103 >= a0_94)
					{
						if (a0_94 <= 0x00FE)
						{
							word32 a4_416;
							word32 a5_417;
							word32 a0_414;
							word32 a2_415;
							word32 t1_413;
							memset(ra, fp + -96, (word32) a0_94 + 1, 64, out t1_413, out a0_414, out a1_104, out a2_415, out a3, out a4_416, out a5_417);
							word32 s3_126 = a0 + (a0_103 - a0_94);
							if (a0_94 != 0x00)
							{
								Eq_2 a4_137 = a1;
								a1_104 = a0_94 + a1;
								word32 a2_139 = a1 + (a0_94 & 0x00FF);
								do
								{
									a3 = a2_139 - a4_137;
									(fp + -32 + ((word32) (*a4_137) & 63))->b0FC0 = (byte) a3;
									++a4_137;
								} while (a1_104 != a4_137);
							}
							do
							{
								word32 s0_155 = s0_121 + -1;
								a4 = fp + -32;
								for (s0_121 = s0_155 + CONVERT(Mem231[((fp + -32) + (CONVERT(Mem231[s0_155 + a0_94:byte], byte, word32) & 63)) + -64:byte], byte, word32); s3_126 >= s0_121; s0_121 += s4_180)
								{
									word32 s4_180 = CONVERT(Mem231[fp + -32 + (CONVERT(Mem231[s0_121 + a0_94:byte], byte, word32) & 63) + -64:byte], byte, word32);
									word32 a2_418;
									if (memcmp(s0_121, a1, a0_94, out a1_104, out a2_418, out a3, out a4, out a5) == 0x00)
										goto l23071BA8;
								}
								word32 a0_191 = s3_126 + a0_94;
								a5 = (word32) *a0_191;
								if (a5 == 0x00)
									goto l23071C58;
								s3_126 += strnlen(a0_191, 0x0800, out a1_104, out a3, out a4, out a5);
							} while (s3_126 >= s0_121);
							s0_121.u0 = 0;
						}
						else
							s0_121 = two_way_long_needle(a0, a0_103, a1, a0_94, out a1_104, out a3, out a4, out a5);
						goto l23071BA8;
					}
				}
				else
				{
					a1_104 <<= 0x18;
					a3 = (word32) *a0;
					a5 = a1_104 << 0x18 | a3 << 0x10 | a4 | a2_34 << 0x08;
					if (a3 != null)
					{
						a4.u0 = 0;
						while (true)
						{
							a4 = a3 | a4 << 0x08;
							a3 = (word32) *((word16) s0_121.u0 + 1);
							word32 a2_88 = s0_121 + 1;
							if (a3 == null)
								break;
							if (a5 == a4)
								goto l23071CE0;
							s0_121 = a2_88;
						}
						if (a5 == a4)
						{
l23071CE0:
							s0_121 += -3;
							goto l23071BA8;
						}
					}
				}
			}
			else
			{
				a4 = (word32) *a0;
				a1_104 = a3 << 0x10;
				a5 = a1_104 << 0x18 | a3 << 0x10 | a2_34 << 0x08;
				if (a4 != 0x00)
				{
					a4 <<= 0x08;
					Eq_2 a2_59 = (word32) a0 + 1;
					a3 = (word32) *((word32) a0 + 1);
					while (true)
					{
						ui32 a4_63 = a3 | a4;
						a4 = a4_63 << 0x08;
						if (a3 == null)
							break;
						a1_104 = (word32) a2_59 + 1;
						a3 = (word32) *((word32) a2_59 + 1);
						if (a5 == a4_63 << 0x08)
						{
							s0_121 = a2_59 + -2;
							goto l23071BA8;
						}
						a2_59 = a1_104;
					}
				}
			}
		}
		else
		{
			a5 = (word32) *a0;
			a1_104 = a1_104 << 0x10 | a3;
			if (a5 != 0x00)
			{
				a3 = (word32) a0 + 1;
				a4 = (word32) *((word32) a0 + 1);
				while (true)
				{
					a5 = a4 | a5 << 0x10;
					if (a4 == 0x00)
						break;
					struct Eq_133368 * a2_45 = a3 + 1;
					a4 = (word32) a3[1];
					if (a1_104 == a5)
					{
						s0_121 = (char *) a3 - 1;
						goto l23071BA8;
					}
					a3 = a2_45;
				}
			}
		}
l23071C58:
		s0_121.u0 = 0;
		goto l23071BA8;
	}
}

// 23071D04: Register (ptr32 Eq_2) _strtol_l.isra.0(Register (ptr32 Eq_2) a0, Register Eq_2 a1, Register (ptr32 Eq_2) a2, Register Eq_139492 a3, Register out Eq_2 a1Out, Register out Eq_139492 a3Out, Register out Eq_2 a4Out, Register out Eq_361890 a5Out)
// Called from:
//      _strtol_r
//      strtol_l
//      strtol
union Eq_2 * _strtol_l.isra.0(union Eq_2 * a0, Eq_2 a1, union Eq_2 * a2, Eq_139492 a3, union Eq_2 & a1Out, union Eq_139492 & a3Out, union Eq_2 & a4Out, union Eq_361890 & a5Out)
{
	Eq_2 t1_11 = a1;
	while (true)
	{
		Eq_2 a4_125 = (word32) t1_11 + 1;
		Eq_361895 a5_17 = (word32) *((word32) a4_125 - 1);
		if (((word32) *((word32) a5_17.u0 + 587783277) & 8) == 0x00)
			break;
		t1_11 = a4_125;
	}
	Eq_361895 a6_183;
	Eq_139492 t6_46;
	int32 s0_25;
	if (a5_17 != 45)
	{
		if (a5_17 == 43)
		{
			a6_183 = (word32) *a4_125;
			s0_25 = 0;
			a4_125 = (word32) t1_11 + 2;
			if (a3 != 0x00)
			{
l23071D5C:
				t6_46 = a3;
				if (a3 != 16)
					goto l23071D68;
				if (a6_183 != 48 || ((word32) (*a4_125) & 223) != 88)
				{
					t6_46.u0 = 16;
					goto l23071D68;
				}
l23071E8C:
				a6_183 = (word32) *((word32) a4_125 + 1);
				t6_46.u0 = 16;
				a4_125 = (word32) a4_125 + 2;
				a3.u0 = 16;
				goto l23071D68;
			}
l23071DE0:
			if (a6_183 != 48)
			{
				t6_46.u0 = 0x0A;
				a3.u0 = 0x0A;
			}
			else
			{
				if (((word32) *a4_125 & 223) == 88)
					goto l23071E8C;
				t6_46.u0 = 8;
				a3.u0 = 8;
			}
l23071D68:
			union Eq_2 * t0_122 = (union Eq_2 *) 0x80000000;
			if (s0_25 == 0x00)
				t0_122 = (union Eq_2 *) 0x7FFFFFFF;
			Eq_139492 s1_78 = t0_122 & t6_46;
			int32 a7_158 = 0;
			union Eq_2 * a0_108 = null;
			union Eq_2 * t4_84 = t0_122 >> t6_46;
l23071D90:
			Eq_139492 a5_166 = (word32) a6_183 - 48;
			if (a5_166 > 9)
			{
				if (a6_183 > -90)
				{
					if (a6_183 <= -122)
					{
						a5_166 = (word32) a6_183 - 87;
						if (a5_166 < a3)
						{
l23071DA8:
							if (a7_158 != -1)
							{
								a7_158 = -1;
								if (t4_84 >= a0_108 && (t4_84 != a0_108 || s1_78 >= a5_166))
								{
									a7_158 = 1;
									a0_108 = a5_166 + (t6_46 + a0_108);
								}
							}
							a4_125 = (word32) a4_125 + 1;
							a6_183 = (word32) *((word32) a4_125 - 1);
							goto l23071D90;
						}
					}
l23071E04:
					Eq_361890 a5_100 = -1;
					if (a7_158 != -1)
					{
						if (s0_25 != 0x00)
							a0_108 = 0x00 - a0_108;
						if (a2 != null)
						{
							if (a7_158 == 0x00)
								goto l23071E1C;
							t0_122 = a0_108;
l23071E48:
							a1 = (word32) a4_125 - 1;
							a0_108 = t0_122;
l23071E1C:
							*a2 = (union Eq_2 *) a1;
							goto l23071E20;
						}
					}
					else
					{
						*a0 = (union Eq_2 *) 0x0022;
						a5_100.u0 = 0x0022;
						a0_108 = t0_122;
						if (a2 != null)
							goto l23071E48;
					}
l23071E20:
					a1Out = a1;
					a3Out = a3;
					a4Out = a4_125;
					a5Out = a5_100;
					return a0_108;
				}
				a5_166 = (word32) a6_183 - 55;
			}
			if (a5_166 < a3)
				goto l23071DA8;
			goto l23071E04;
		}
		a6_183 = a5_17;
		s0_25 = 0;
	}
	else
	{
		a6_183 = (word32) *a4_125;
		s0_25 = 1;
		a4_125 = (word32) t1_11 + 2;
	}
	if (a3 != 0x00)
		goto l23071D5C;
	goto l23071DE0;
}

// 23071EBC: void _strtol_r(Register (ptr32 Eq_2) a0, Register Eq_2 a1, Register (ptr32 Eq_2) a2, Register Eq_139492 a3)
// Called from:
//      _atoi_r
void _strtol_r(union Eq_2 * a0, Eq_2 a1, union Eq_2 * a2, Eq_139492 a3)
{
	word32 a1_21;
	word32 a3_22;
	word32 a4_23;
	word32 a5_24;
	_strtol_l.isra.0(a0, a1, a2, a3, out a1_21, out a3_22, out a4_23, out a5_24);
}

// 23071EC0: void strtol_l(Register Eq_2 a0, Register (ptr32 Eq_2) a1, Register Eq_139492 a2)
void strtol_l(Eq_2 a0, union Eq_2 * a1, Eq_139492 a2)
{
	union Eq_2 * a0_12 = g_ptr4200D994;
	word32 a1_27;
	word32 a3_28;
	word32 a4_29;
	word32 a5_30;
	_strtol_l.isra.0(a0_12, a0, a1, a2, out a1_27, out a3_28, out a4_29, out a5_30);
}

// 23071EDC: Register Eq_2 strtol(Register Eq_2 a0, Register (ptr32 Eq_2) a1, Register Eq_139492 a2, Register out ptr32 a1Out, Register out (ptr32 Eq_2) a2Out, Register out ptr32 a3Out, Register out ptr32 a4Out, Register out ptr32 a5Out)
// Called from:
//      mmem_cmd
//      pmem_cmd
//      atoi
Eq_2 strtol(Eq_2 a0, union Eq_2 * a1, Eq_139492 a2, ptr32 & a1Out, union Eq_2 & a2Out, ptr32 & a3Out, ptr32 & a4Out, ptr32 & a5Out)
{
	union Eq_2 * a0_12 = g_ptr4200D994;
	ptr32 a3_14;
	ptr32 a4_15;
	ptr32 a5_16;
	ptr32 a1_26;
	Eq_2 a0_13 = _strtol_l.isra.0(a0_12, a0, a1, a2, out a1_26, out a3_14, out a4_15, out a5_16);
	a1Out = a1_26;
	a2Out = a1;
	a3Out = a3_14;
	a4Out = a4_15;
	a5Out = a5_16;
	return a0_13;
}

// 23071EF8: void stat(Register int32 a0, Register (ptr32 Eq_362078) a1)
void stat(int32 a0, struct Eq_362078 * a1)
{
	union Eq_2 * a0_10 = g_ptr4200D994;
	_stat_r(a0_10, a0, a1);
}

// 23071F10: void _stat_r(Register (ptr32 Eq_2) a0, Register int32 a1, Register (ptr32 Eq_362078) a2)
// Called from:
//      stat
void _stat_r(union Eq_2 * a0, int32 a1, struct Eq_362078 * a2)
{
	g_t42020D50.u0 = 0x00;
	if (_stat(a1, a2) != -1)
		return;
	Eq_2 a5_35 = g_t4201FD50;
	if (a5_35 == 0x00)
		return;
	*a0 = (union Eq_2 *) a5_35;
}

// 23071F74: Register int32 _stat(Register int32 a0, Register (ptr32 Eq_362078) a1)
// Called from:
//      _stat_r
int32 _stat(int32 a0, struct Eq_362078 * a1)
{
	__syscall();
	int32 s0_19 = a0;
	if (a0 < 0x00)
	{
		word32 a5_55;
		*__errno(out a5_55) = 0x00 - a0;
		s0_19 = -1;
	}
	_conv_stat(a1, fp + -144);
	return s0_19;
}

// 23071FE4: void _conv_stat(Register (ptr32 Eq_362078) a0, Register (ptr32 Eq_362124) a1)
// Called from:
//      _stat
void _conv_stat(struct Eq_362078 * a0, struct Eq_362124 * a1)
{
	int32 t2_6 = a1->dw0014;
	int32 t0_7 = a1->dw0018;
	int32 t6_8 = a1->dw001C;
	int32 t5_9 = a1->dw0020;
	int32 t4_10 = a1->dw0030;
	int32 t3_11 = a1->dw0040;
	int32 t1_12 = a1->dw0038;
	int32 a6_13 = a1->dw0048;
	int32 a7_14 = a1->dw004C;
	int32 a2_15 = a1->dw0058;
	int32 s0_20 = a1->dw0010;
	int32 s1_21 = a1->dw0008;
	int32 a3_25 = a1->dw005C;
	int32 a4_26 = a1->dw0068;
	int32 a5_27 = a1->dw006C;
	a0->w0000 = a1->w0000;
	a0->w0002 = (word16) s1_21;
	a0->dw0004 = s0_20;
	a0->w0008 = (word16) t2_6;
	a0->w000A = (word16) t0_7;
	a0->w000C = (word16) t6_8;
	a0->w000E = (word16) t5_9;
	a0->dw0010 = t4_10;
	a0->dw0048 = t3_11;
	a0->dw0044 = t1_12;
	a0->dw0018 = a6_13;
	a0->dw001C = a7_14;
	a0->dw0028 = a2_15;
	a0->dw002C = a3_25;
	a0->dw0038 = a4_26;
	a0->dw003C = a5_27;
}

