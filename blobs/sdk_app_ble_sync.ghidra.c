#include "sdk_app_ble_sync.ghidra.h"



// WARNING: Removing unreachable block (ram,0x230000d8)

void bl602_start(void)

{
  uint32_t *puVar1;
  undefined4 *puVar2;
  uint8_t *puVar3;
  ipc_shared_env_tag_conflict7 *piVar4;
  anon_struct_conflict1 *paVar5;
  anon_struct_conflict2 *paVar6;
  code *pcVar7;
  
  puVar2 = (undefined4 *)&__boot2_pt_addr_src;
  paVar5 = &boot2_partition_table;
  do {
    *(undefined4 *)paVar5 = *puVar2;
    puVar2 = puVar2 + 1;
    paVar5 = (anon_struct_conflict1 *)&paVar5->table;
  } while (paVar5 < &boot2_flashCfg);
  puVar1 = (uint32_t *)hal_boot2_get_flash_addr();
  paVar6 = &boot2_flashCfg;
  do {
    paVar6->magic = *puVar1;
    puVar1 = puVar1 + 1;
    paVar6 = (anon_struct_conflict2 *)&paVar6->flashCfg;
  } while (paVar6 < (anon_struct_conflict2 *)&__boot2_flashCfg_end);
  puVar2 = (undefined4 *)&_bl_static_blogfile_code_end;
  pcVar7 = AON_Power_On_BG;
  do {
    *(undefined4 *)pcVar7 = *puVar2;
    puVar2 = puVar2 + 1;
    pcVar7 = (code *)&((anon_struct_conflict1 *)pcVar7)->table;
  } while (pcVar7 < &boot2_partition_table);
  puVar3 = &stack_wifi_init;
  do {
    *(undefined4 *)puVar3 = 0;
    puVar3 = (uint8_t *)((undefined4 *)puVar3 + 1);
  } while (puVar3 < &__bss_end);
  piVar4 = &ipc_shared_env;
  do {
    (piVar4->msg_a2e_buf).dummy_word = 0;
    piVar4 = (ipc_shared_env_tag_conflict7 *)(piVar4->msg_a2e_buf).msg;
  } while (piVar4 < (ipc_shared_env_tag_conflict7 *)&_heap_wifi_start);
  DAT_4203fff8 = 0x230000e8;
  bfl_main(0,0);
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void _dump_partition(void)

{
  int iVar1;
  anon_struct_conflict1 *paVar2;
  
  bl_printk("======= PtTable_Config @%p=======\r\n",0x4200ddd8);
  bl_printk("magicCode 0x%08X;",boot2_partition_table.table.ptTable.magicCode);
  bl_printk(" version 0x%04X;",(uint)boot2_partition_table.table.ptTable.version);
  bl_printk(" entryCnt %u;",(uint)boot2_partition_table.table.ptTable.entryCnt);
  bl_printk(" age %lu;",boot2_partition_table.table.ptTable.age);
  bl_printk(" crc32 0x%08X\r\n");
  bl_printk(
           "idx  type device activeIndex     name   Address[0]  Address[1]  Length[0]   Length[1]   age\r\n"
           );
  iVar1 = 0;
  paVar2 = &boot2_partition_table;
  while( true ) {
    if ((int)(uint)boot2_partition_table.table.ptTable.entryCnt <= iVar1) break;
    bl_printk("[%02d] ",iVar1);
    iVar1 = iVar1 + 1;
    bl_printk(" %02u",(uint)(paVar2->table).ptEntries[0].type);
    bl_printk("     %u",(uint)(paVar2->table).ptEntries[0].device);
    bl_printk("         %u",(uint)(paVar2->table).ptEntries[0].activeIndex);
    bl_printk("      %8s",(paVar2->table).ptEntries[0].name);
    bl_printk("  %p",(paVar2->table).ptEntries[0].Address[0]);
    bl_printk("  %p",(paVar2->table).ptEntries[0].Address[1]);
    bl_printk("  %p",(paVar2->table).ptEntries[0].maxLen[0]);
    bl_printk("  %p",(paVar2->table).ptEntries[0].maxLen[1]);
    bl_printk("  %lu\r\n");
    paVar2 = (anon_struct_conflict1 *)((paVar2->table).ptEntries[0].Address + 1);
  }
  return;
}



uint32_t hal_boot2_get_flash_addr(void)

{
  return (uint32_t)
         (&__boot2_flashCfg_src + (uint)boot2_partition_table.table.ptTable.entryCnt * 0x24);
}



int hal_boot2_partition_bus_addr
              (char *name,uint32_t *addr0,uint32_t *addr1,uint32_t *size0,uint32_t *size1,
              int *active)

{
  byte bVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  anon_struct_conflict1 *paVar5;
  uint uVar6;
  uint uVar7;
  anon_struct_conflict1 *paVar8;
  
  if (boot2_partition_table.table.ptTable.magicCode != 0x54504642) {
    return -5;
  }
  paVar8 = &boot2_partition_table;
  paVar5 = &boot2_partition_table;
  uVar2 = 0;
  while ((int)uVar2 < (int)(uint)boot2_partition_table.table.ptTable.entryCnt) {
    iVar4 = strcmp((char *)(paVar5->table).ptEntries[0].name,name);
    paVar5 = (anon_struct_conflict1 *)((paVar5->table).ptEntries[0].Address + 1);
    if (iVar4 == 0) break;
    uVar2 = uVar2 + 1;
  }
  iVar4 = -2;
  if (uVar2 != (uint)boot2_partition_table.table.ptTable.entryCnt) {
    uVar7 = boot2_partition_table.table.ptEntries[uVar2].Address[0];
    uVar6 = boot2_partition_table.table.ptEntries[uVar2].Address[1];
    *active = (uint)boot2_partition_table.table.ptEntries[uVar2].activeIndex;
    *size0 = boot2_partition_table.table.ptEntries[uVar2].maxLen[0];
    uVar3 = 0;
    *size1 = *(uint32_t *)((int)&boot2_partition_table.table.ptTable + (uVar2 + 1) * 0x24 + 4);
    while ((int)uVar3 < (int)(uint)boot2_partition_table.table.ptTable.entryCnt) {
      iVar4 = strcmp((char *)(paVar8->table).ptEntries[0].name,"FW");
      paVar8 = (anon_struct_conflict1 *)((paVar8->table).ptEntries[0].Address + 1);
      if (iVar4 == 0) break;
      uVar3 = uVar3 + 1;
    }
    iVar4 = -0x48;
    if (uVar3 != (uint)boot2_partition_table.table.ptTable.entryCnt) {
      if (uVar7 != 0) {
        if (uVar7 < boot2_partition_table.table.ptEntries[uVar3].Address[0]) {
          return -0x16;
        }
        if (uVar7 < boot2_partition_table.table.ptEntries[uVar3].Address[1]) {
          return -0x16;
        }
      }
      if (uVar6 != 0) {
        if (uVar6 < boot2_partition_table.table.ptEntries[uVar3].Address[0]) {
          return -0x16;
        }
        if (uVar6 < boot2_partition_table.table.ptEntries[uVar3].Address[1]) {
          return -0x16;
        }
      }
      iVar4 = -0xe;
      bVar1 = boot2_partition_table.table.ptEntries[uVar3].activeIndex;
      if (bVar1 < 2) {
        iVar4 = 0;
        *addr0 = (uVar7 + 0x22fff000) -
                 (&boot2_partition_table.table.ptTable.crc32)[(uint)bVar1 + uVar3 * 9 + 4];
        *addr1 = (uVar6 + 0x22fff000) -
                 (&boot2_partition_table.table.ptTable.crc32)
                 [uVar3 * 9 + (uint)boot2_partition_table.table.ptEntries[uVar3].activeIndex + 4];
      }
    }
  }
  return iVar4;
}



int hal_boot2_partition_bus_addr_active(char *name,uint32_t *addr,uint32_t *size)

{
  int iVar1;
  uint32_t uStack36;
  uint32_t addr0;
  uint32_t addr1;
  uint32_t size0;
  uint32_t size1;
  int active;
  
  iVar1 = hal_boot2_partition_bus_addr(name,&uStack36,&addr0,&addr1,&size0,(int *)&size1);
  if (iVar1 == 0) {
    if (size1 != 0) {
      uStack36 = addr0;
    }
    *addr = uStack36;
    if (size1 != 0) {
      addr1 = size0;
    }
    *size = addr1;
  }
  return iVar1;
}



int hal_boot2_partition_bus_addr_inactive(char *name,uint32_t *addr,uint32_t *size)

{
  int iVar1;
  uint32_t uStack36;
  uint32_t addr0;
  uint32_t addr1;
  uint32_t size0;
  uint32_t size1;
  int active;
  
  iVar1 = hal_boot2_partition_bus_addr(name,&uStack36,&addr0,&addr1,&size0,(int *)&size1);
  if (iVar1 == 0) {
    if (size1 != 0) {
      addr0 = uStack36;
    }
    *addr = addr0;
    if (size1 != 0) {
      size0 = addr1;
    }
    *size = size0;
  }
  return iVar1;
}



int hal_boot2_partition_addr
              (char *name,uint32_t *addr0,uint32_t *addr1,uint32_t *size0,uint32_t *size1,
              int *active)

{
  uint uVar1;
  anon_struct_conflict1 *paVar2;
  int iVar3;
  
  if (boot2_partition_table.table.ptTable.magicCode == 0x54504642) {
    paVar2 = &boot2_partition_table;
    uVar1 = 0;
    while ((int)uVar1 < (int)(uint)boot2_partition_table.table.ptTable.entryCnt) {
      iVar3 = strcmp((char *)(paVar2->table).ptEntries[0].name,name);
      paVar2 = (anon_struct_conflict1 *)((paVar2->table).ptEntries[0].Address + 1);
      if (iVar3 == 0) break;
      uVar1 = uVar1 + 1;
    }
    iVar3 = -2;
    if (uVar1 != (uint)boot2_partition_table.table.ptTable.entryCnt) {
      *addr0 = boot2_partition_table.table.ptEntries[uVar1].Address[0];
      *addr1 = boot2_partition_table.table.ptEntries[uVar1].Address[1];
      *size0 = boot2_partition_table.table.ptEntries[uVar1].maxLen[0];
      *size1 = *(uint32_t *)((int)&boot2_partition_table.table.ptTable + (uVar1 + 1) * 0x24 + 4);
      iVar3 = 0;
      *active = (uint)boot2_partition_table.table.ptEntries[uVar1].activeIndex;
    }
  }
  else {
    iVar3 = -5;
  }
  return iVar3;
}



int hal_boot2_partition_addr_active(char *name,uint32_t *addr,uint32_t *size)

{
  int iVar1;
  uint32_t uStack36;
  uint32_t addr0;
  uint32_t addr1;
  uint32_t size0;
  uint32_t size1;
  int active;
  
  iVar1 = hal_boot2_partition_addr(name,&uStack36,&addr0,&addr1,&size0,(int *)&size1);
  if (iVar1 == 0) {
    if (size1 != 0) {
      uStack36 = addr0;
    }
    *addr = uStack36;
    if (size1 != 0) {
      addr1 = size0;
    }
    *size = addr1;
  }
  return iVar1;
}



int hal_boot2_partition_addr_inactive(char *name,uint32_t *addr,uint32_t *size)

{
  int iVar1;
  uint32_t uStack36;
  uint32_t addr0;
  uint32_t addr1;
  uint32_t size0;
  uint32_t size1;
  int active;
  
  iVar1 = hal_boot2_partition_addr(name,&uStack36,&addr0,&addr1,&size0,(int *)&size1);
  if (iVar1 == 0) {
    if (size1 != 0) {
      addr0 = uStack36;
    }
    *addr = addr0;
    if (size1 != 0) {
      size0 = addr1;
    }
    *size = size0;
  }
  return iVar1;
}



int hal_boot2_init(void)

{
  TickType_t TVar1;
  
  boot2_partition_table.partition_active_idx = __boot2_pt_addr_src;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvhal_boot2 < BLOG_LEVEL_WARN))
  {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [HAL] [BOOT2] Active Partition[%u] consumed %d Bytes\r\n",TVar1,
              &DAT_2306e4ac,"hal_boot2.c",0x114,(uint)boot2_partition_table.partition_active_idx,
              0x254);
  }
  _dump_partition();
  bl_flash_config_update();
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int bl_flash_erase(uint32_t addr,int len)

{
  if (boot2_flashCfg.flashCfg.mid != '\0') {
    (*_DAT_21010ab0)(0x4200e030,addr,len,_DAT_21010ab0);
    return 0;
  }
  return -1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int bl_flash_write(uint32_t addr,uint8_t *src,int len)

{
  if (boot2_flashCfg.flashCfg.mid != '\0') {
    (*_DAT_21010aac)(0x4200e030,addr,src,len,_DAT_21010aac);
    return 0;
  }
  return -1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int bl_flash_read(uint32_t addr,uint8_t *dst,int len)

{
  if (boot2_flashCfg.flashCfg.mid != '\0') {
    (*_DAT_21010aa8)(0x4200e030,addr,dst,len,_DAT_21010aa8);
    return 0;
  }
  return -1;
}



undefined4 bl_flash_config_update(void)

{
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_flash < BLOG_LEVEL_WARN))
  {
    if (TrapNetCounter == 0) {
      xTaskGetTickCount();
    }
    else {
      xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] ======= FlashCfg magiccode @%p, code 0x%08lX =======\r\n",
              &DAT_2306e4ac,"bl_flash.c",0x60,&__boot2_flashCfg_src,boot2_flashCfg.magic);
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_flash < BLOG_LEVEL_WARN)
       ) {
      if (TrapNetCounter == 0) {
        xTaskGetTickCount();
      }
      else {
        xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] mid \t\t0x%X\r\n",&DAT_2306e4ac,"bl_flash.c",0x61,
                (uint)boot2_flashCfg.flashCfg.mid);
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvbl_flash < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          xTaskGetTickCount();
        }
        else {
          xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] clkDelay \t0x%X\r\n",&DAT_2306e4ac,"bl_flash.c",0x62,
                  (uint)boot2_flashCfg.flashCfg.clkDelay);
        if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
           (_fsymf_level_hal_drvbl_flash < BLOG_LEVEL_WARN)) {
          if (TrapNetCounter == 0) {
            xTaskGetTickCount();
          }
          else {
            xTaskGetTickCountFromISR();
          }
          bl_printk("[%10u][%s: %s:%4d] clkInvert \t0x%X\r\n",&DAT_2306e4ac,"bl_flash.c",99,
                    (uint)boot2_flashCfg.flashCfg.clkInvert);
          if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
             (_fsymf_level_hal_drvbl_flash < BLOG_LEVEL_WARN)) {
            if (TrapNetCounter == 0) {
              xTaskGetTickCount();
            }
            else {
              xTaskGetTickCountFromISR();
            }
            bl_printk("[%10u][%s: %s:%4d] sector size\t%uKBytes\r\n",&DAT_2306e4ac,"bl_flash.c",100,
                      (uint)boot2_flashCfg.flashCfg.sectorSize);
            if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
               (_fsymf_level_hal_drvbl_flash < BLOG_LEVEL_WARN)) {
              if (TrapNetCounter == 0) {
                xTaskGetTickCount();
              }
              else {
                xTaskGetTickCountFromISR();
              }
              bl_printk("[%10u][%s: %s:%4d] page size\t%uBytes\r\n",&DAT_2306e4ac,"bl_flash.c",0x65,
                        (uint)boot2_flashCfg.flashCfg.pageSize);
              if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                 (_fsymf_level_hal_drvbl_flash < BLOG_LEVEL_WARN)) {
                if (TrapNetCounter == 0) {
                  xTaskGetTickCount();
                }
                else {
                  xTaskGetTickCountFromISR();
                }
                bl_printk(
                          "[%10u][%s: %s:%4d] ---------------------------------------------------------------\r\n"
                          ,&DAT_2306e4ac,"bl_flash.c",0x66);
              }
            }
          }
        }
      }
    }
  }
  return 0;
}



void cmd_blsync_ble_stop(char *buf,int len,int argc,char **argv)

{
  aos_post_event(5,2,0);
  return;
}



void stack_wifi(void)

{
  uint8_t stack_wifi_init;
  
  if (stack_wifi_init == '\x01') {
    puts("Wi-Fi Stack Started already!!!\r\n");
    return;
  }
  stack_wifi_init = '\x01';
  hal_wifi_start_firmware_task();
  aos_post_event(2,1,0);
  return;
}



void cmd_blsync_ble_start(char *buf,int len,int argc,char **argv)

{
  stack_wifi();
  vTaskDelay(1000);
  blsync_ble_start();
  vTaskDelay(1000);
  aos_post_event(5,1,0);
  return;
}



void app_delayed_action_ble(void *arg)

{
  blsync_ble_start();
  aos_post_delayed_action(1000,app_delayed_action_wifi,(void *)0x0);
  return;
}



void app_delayed_action_wifi(void *arg)

{
  stack_wifi();
  aos_post_delayed_action(1000,app_delayed_action_bleadv,(void *)0x0);
  return;
}



void app_delayed_action_bleadv(void *arg)

{
  size_t count;
  
  count = strlen("ble_init\r\n");
  aos_cli_input_direct("ble_init\r\n",count);
  count = strlen("ble_start_adv 0 0 0x100 0x100\r\n");
  aos_cli_input_direct("ble_start_adv 0 0 0x100 0x100\r\n",count);
  return;
}



void scan_complete_cb(void *p_arg,void *param)

{
  wifi_mgmr_scan_ap_all((wifi_mgmr_ap_item_t *)0x0,(uint32_t *)p_arg,scan_item_cb);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void scan_item_cb(wifi_mgmr_ap_item_t *env,uint32_t *param1,wifi_mgmr_ap_item_t *item)

{
  undefined auStack64 [4];
  _wifi_item_t wifi_item;
  
  wifi_item.bssid[4] = item->rssi;
  wifi_item.bssid._2_2_ = *(undefined2 *)&item->channel;
  wifi_item.ssid._28_4_ = item->ssid_len;
  memcpy(auStack64,item,0x20);
  memcpy(&wifi_item.ssid_len,item->bssid,6);
  if (param1 != (uint32_t *)0x0) {
    (*(code *)param1)(auStack64);
  }
  return;
}



void wifiprov_wifi_state_get(void *p_arg)

{
  char *__src;
  int iStack296;
  int tmp_state;
  ip4_addr_t ip;
  ip4_addr_t gw;
  ip4_addr_t mask;
  _wifi_state state;
  wifi_mgmr_sta_connect_ind_stat_info_t info;
  
  memset(&mask,0,0x58);
  memset(state.bssid + 3,0,0xae);
  wifi_mgmr_state_get(&iStack296);
  wifi_mgmr_sta_ip_get((uint32_t *)&tmp_state,(uint32_t *)&ip,(uint32_t *)&gw);
  wifi_mgmr_sta_connect_ind_stat_get((wifi_mgmr_sta_connect_ind_stat_info_t *)(state.bssid + 3));
  __src = ip4addr_ntoa((ip4_addr_t *)&tmp_state);
  strcpy((char *)&mask,__src);
  __src = ip4addr_ntoa(&gw);
  strcpy(state.gw + 0xc,__src);
  __src = ip4addr_ntoa(&ip);
  strcpy(state.ip + 0xc,__src);
  memcpy(state.mask + 0xc,&state.state,0x20);
  memcpy(state.ssid + 0x1d,info.pmk + 0x3c,6);
  state.ssid[28] = '\0';
  printf("IP  :%s \r\n",&mask);
  printf("GW  :%s \r\n",state.ip + 0xc);
  printf("MASK:%s \r\n",state.gw + 0xc);
  if (p_arg != (void *)0x0) {
    (*(code *)p_arg)(&mask);
  }
  return;
}



__uint8_t char_to_hex(char asccode)

{
  char cVar1;
  byte bVar2;
  
  bVar2 = asccode - 0x30;
  if (9 < bVar2) {
    if ((byte)(asccode + 0x9fU) < 6) {
      cVar1 = -0x57;
    }
    else {
      if (5 < (byte)(asccode + 0xbfU)) {
        return '\0';
      }
      cVar1 = -0x37;
    }
    bVar2 = asccode + cVar1;
  }
  return (__uint8_t)bVar2;
}



void _connect_wifi(undefined4 param_1)

{
  int iVar1;
  uint8_t *puVar2;
  char *__dest;
  __uint8_t band;
  __uint8_t _Var3;
  __uint8_t _Var4;
  wifi_interface_t pvVar5;
  char *value_buf;
  size_t ssid_len;
  size_t sVar6;
  size_t sVar7;
  undefined3 extraout_var;
  char *__src;
  uint16_t freq;
  int iVar8;
  uint uVar9;
  int iVar10;
  char *__dest_00;
  longlong lVar11;
  byte abStack340 [4];
  uint8_t mac [6];
  char chan [10];
  char bssid [32];
  char ssid [33];
  char pmk [66];
  char password [66];
  char val_buf [66];
  
  pvVar5 = wifi_mgmr_sta_enable();
  wifi_interface = pvVar5;
  lVar11 = aos_now_ms();
  __dest = ssid + 0x20;
  printf(
         "[APP] [WIFI] [T] %lld\r\n[APP]   Get STA %p from Wi-Fi Mgmr, pmk ptr %p, ssid ptr %p, password %p\r\n"
         ,pvVar5,param_1,wifi_interface,__dest,bssid + 0x1c,pmk + 0x40,(int)lVar11);
  memset(__dest,0,0x42);
  memset(bssid + 0x1c,0,0x21);
  memset(pmk + 0x40,0,0x42);
  __dest_00 = chan + 8;
  memset(__dest_00,0,0x20);
  memset(abStack340,0,6);
  memset(mac + 4,0,10);
  memset(password + 0x40,0,0x42);
  ef_get_env_blob("conf_ap_ssid",password + 0x40,0x41,(size_t *)0x0);
  if (password[64] == '\0') {
    puts("[APP]    Empty Config\r\n");
    puts("[APP]    Try to set the following ENV with psm_set command, then reboot\r\n");
    puts("[APP]    NOTE: conf_ap_pmk MUST be psm_unset when conf is changed\r\n");
    puts("[APP]    env: conf_ap_ssid\r\n");
    puts("[APP]    env: conf_ap_psk\r\n");
    puts("[APP]    env(optinal): conf_ap_pmk\r\n");
    return;
  }
  strncpy(bssid + 0x1c,password + 0x40,0x20);
  memset(password + 0x40,0,0x42);
  ef_get_env_blob("conf_ap_psk",password + 0x40,0x41,(size_t *)0x0);
  if (password[64] != '\0') {
    strncpy(pmk + 0x40,password + 0x40,0x41);
  }
  memset(password + 0x40,0,0x42);
  __src = password + 0x40;
  value_buf = (char *)ef_get_env_blob("conf_ap_pmk",__src,0x41,(size_t *)0x0);
  if (password[64] != '\0') {
    __src = password + 0x40;
    value_buf = strncpy(__dest,__src,0x41);
  }
  if (ssid[32] == '\0') {
    lVar11 = aos_now_ms();
    printf("[APP] [WIFI] [T] %lld\r\n",value_buf,__src,(int)lVar11);
    puts("[APP]    Re-cal pmk\r\n");
    ssid_len = strlen(bssid + 0x1c);
    wifi_mgmr_psk_cal(pmk + 0x40,bssid + 0x1c,ssid_len,__dest);
    ef_set_env("conf_ap_pmk",__dest);
    ef_save_env();
  }
  memset(password + 0x40,0,0x42);
  ef_get_env_blob("conf_ap_channel",password + 0x40,0x41,(size_t *)0x0);
  if (password[64] != '\0') {
    strncpy((char *)(mac + 4),password + 0x40,9);
    printf("connect wifi channel = %s\r\n",mac + 4);
    value_buf = strchr((char *)(mac + 4),0x7c);
    if (value_buf + 1 != (char *)0x0) {
      iVar10 = 1;
      iVar8 = 0;
      band = char_to_hex(value_buf[1]);
      ssid_len = strlen((char *)(mac + 4));
      sVar7 = strlen(value_buf + 1);
      iVar1 = ssid_len - sVar7;
      mac[iVar1 + 3] = '\0';
      uVar9 = 0;
      puVar2 = mac + iVar1 + 4;
      while( true ) {
        freq = (uint16_t)uVar9;
        if (iVar1 + -1 <= iVar8) break;
        iVar8 = iVar8 + 1;
        _Var3 = char_to_hex(puVar2[-2]);
        uVar9 = uVar9 + CONCAT31(extraout_var,_Var3) * iVar10 & 0xffff;
        iVar10 = iVar10 * 10;
        puVar2 = puVar2 + -1;
      }
      goto LAB_23000e8a;
    }
  }
  freq = 0;
  band = '\0';
LAB_23000e8a:
  memset(password + 0x40,0,0x42);
  value_buf = password + 0x40;
  sVar6 = ef_get_env_blob("conf_ap_bssid",value_buf,0x41,(size_t *)0x0);
  if (password[64] != '\0') {
    strncpy(__dest_00,password + 0x40,0x1f);
    printf("connect wifi bssid = %s\r\n",__dest_00);
    ssid_len = strlen(__dest_00);
    if ((ssid_len & 1) != 0) {
      ssid_len = ssid_len - (int)ssid_len % 2;
    }
    if (ssid_len != 0) {
      uVar9 = 0;
      while ((int)uVar9 < (int)ssid_len) {
        _Var3 = char_to_hex(*__dest_00);
        _Var4 = char_to_hex(__dest_00[1]);
        abStack340[uVar9 >> 1] = _Var3 * '\x10' + _Var4;
        uVar9 = uVar9 + 2;
        __dest_00 = __dest_00 + 2;
      }
    }
    value_buf = (char *)(uint)abStack340[0];
    sVar6 = printf("mac = %02X:%02X:%02X:%02X:%02X:%02X\r\n",(uint)abStack340[1],(uint)abStack340[2]
                   ,(uint)abStack340[3],(uint)mac[0],(uint)mac[1]);
  }
  aos_now_ms();
  ssid_len = strlen(bssid + 0x1c);
  sVar7 = strlen(pmk + 0x40);
  printf(
         "[APP] [WIFI] [T] %lld\r\n[APP]    SSID %s\r\n[APP]    SSID len %d\r\n[APP]    password %s\r\n[APP]    password len %d\r\n[APP]    pmk %s\r\n[APP]    bssid %s\r\n[APP]    channel band %d\r\n[APP]    channel freq %d\r\n"
         ,sVar6,value_buf,bssid + 0x1c,ssid_len,pmk + 0x40,sVar7);
  wifi_mgmr_sta_connect
            ((wifi_interface_t *)wifi_interface,bssid + 0x1c,pmk + 0x40,__dest,abStack340,band,freq)
  ;
  return;
}



void event_cb_wifi_event(input_event_t *event,void *private_data)

{
  ushort uVar1;
  size_t sVar2;
  wifi_interface_t *wifi_interface;
  input_event_t *piVar3;
  char *ssid;
  undefined4 uVar4;
  longlong lVar5;
  
  uVar1 = event->code;
  switch((uint)uVar1 - 1 & 0xffff) {
  case 0:
    lVar5 = aos_now_ms();
    printf("[APP] [EVT] INIT DONE %lld\r\n",event,private_data,(int)lVar5);
    wifi_mgmr_start_background(&conf);
    return;
  case 1:
    lVar5 = aos_now_ms();
    printf("[APP] [EVT] MGMR DONE %lld\r\n",event,private_data,(int)lVar5);
    _connect_wifi();
    return;
  case 2:
    lVar5 = aos_now_ms();
    uVar4 = (undefined4)lVar5;
    ssid = "[APP] [EVT] Reconnect %lld\r\n";
    break;
  case 3:
  case 5:
    lVar5 = aos_now_ms();
    uVar4 = (undefined4)lVar5;
    ssid = "[APP] [EVT] connected %lld\r\n";
    break;
  case 4:
    piVar3 = event;
    aos_now_ms();
    ssid = wifi_mgmr_status_code_str(*(uint16_t *)&event->value);
    printf("[APP] [EVT] disconnect %lld, Reason: %s\r\n",piVar3,private_data,ssid);
    goto LAB_2300113c;
  case 6:
    lVar5 = aos_now_ms();
    printf("[APP] [EVT] GOT IP %lld\r\n",event,private_data,(int)lVar5);
    sVar2 = xPortGetFreeHeapSize();
    printf("[SYS] Memory left is %d Bytes\r\n",sVar2);
    return;
  case 7:
    lVar5 = aos_now_ms();
    uVar4 = (undefined4)lVar5;
    ssid = "[APP] [EVT] Connecting %lld\r\n";
    break;
  case 8:
    piVar3 = event;
    lVar5 = aos_now_ms();
    if (event->value == 0) {
      ssid = "OK";
    }
    else {
      ssid = "Busy now";
    }
    printf("[APP] [EVT] SCAN Done %lld, SCAN Result: %s\r\n",piVar3,private_data,ssid,(int)lVar5);
    wifi_mgmr_cli_scanlist();
    return;
  default:
    lVar5 = aos_now_ms();
    printf("[APP] [EVT] Unknown code %u, %lld\r\n",(uint)uVar1,event,private_data,(int)lVar5);
    return;
  case 0xf:
    piVar3 = event;
    lVar5 = aos_now_ms();
    printf("[APP] [EVT] [PROV] [CONNECT] %lld\r\n",piVar3,private_data,(int)lVar5);
    ssid = (char *)event->value;
    wifi_interface = (wifi_interface_t *)wifi_mgmr_sta_enable();
    wifi_mgmr_sta_connect(wifi_interface,ssid,ssid + 0x21,(char *)0x0,(uint8_t *)0x0,'\0',0);
    return;
  case 0x10:
    lVar5 = aos_now_ms();
    printf("[APP] [EVT] [PROV] [DISCONNECT] %lld\r\n",event,private_data,(int)lVar5);
    wifi_mgmr_sta_disconnect();
LAB_2300113c:
    vTaskDelay(1000);
    wifi_mgmr_sta_disable((wifi_interface_t *)0x0);
    return;
  case 0x11:
    piVar3 = event;
    lVar5 = aos_now_ms();
    printf("[APP] [EVT] [PROV] [SCAN] %lld\r\n",piVar3,private_data,(int)lVar5);
    wifi_mgmr_scan((void *)event->value,scan_complete_cb);
    return;
  case 0x12:
    piVar3 = event;
    lVar5 = aos_now_ms();
    printf("[APP] [EVT] [PROV] [STATE] %lld\r\n",piVar3,private_data,(int)lVar5);
    wifiprov_wifi_state_get((void *)event->value);
    return;
  }
  printf(ssid,event,private_data,uVar4);
  return;
}



void event_cb_cli(input_event_t *event,void *p_arg)

{
  size_t count;
  
  if (event->code == 1) {
    count = strlen("ble_init\r\n");
    aos_cli_input_direct("ble_init\r\n",count);
    count = strlen("ble_start_adv 0 0 0x100 0x100\r\n");
    aos_cli_input_direct("ble_start_adv 0 0 0x100 0x100\r\n",count);
    return;
  }
  if (event->code != 2) {
    return;
  }
  count = strlen("ble_stop_adv\r\n");
  aos_cli_input_direct("ble_stop_adv\r\n",count);
  blsync_ble_stop();
  printf("blsync ble stop\r\n");
  return;
}



void aos_loop_proc(void *pvParameters)

{
  StackType_t proc_stack_looprt [512];
  StaticTask_t proc_task_looprt;
  void *fdt;
  int sock;
  aos_poll_call_t *cb;
  
  looprt_start((StackType_t *)&ram0x4200f4ac,0x200,(StaticTask_t *)&ram0x4200fcac);
  loopset_led_hook_on_looprt();
  easyflash_init();
  vfs_init();
  vfs_device_init();
  fdt = (void *)hal_board_get_factory_addr();
  sock = fdt_subnode_offset(fdt,0,"uart");
  if (sock == 0) {
    printf("%s NULL.\r\n",0x230794f8);
  }
  else {
    vfs_uart_init(fdt,sock);
  }
  fdt = (void *)hal_board_get_factory_addr();
  sock = fdt_subnode_offset(fdt,0,"gpio");
  if (sock == 0) {
    printf("%s NULL.\r\n",0x23079a94);
  }
  else {
    hal_gpio_init_from_dts(fdt,sock);
  }
  romfs_register();
  aos_loop_init();
  sock = aos_open("/dev/ttyS0",0);
  if (-1 < sock) {
    printf("Init CLI with event Driven\r\n");
    aos_cli_init(0);
    cb = (aos_poll_call_t *)aos_cli_event_cb_read_get();
    aos_poll_read_fd(sock,cb,(void *)0x12345678);
    wifi_mgmr_cli_init();
  }
  aos_register_event_filter(2,event_cb_wifi_event,(void *)0x0);
  aos_register_event_filter(5,event_cb_cli,(void *)0x0);
  aos_post_delayed_action(1000,app_delayed_action_ble,(void *)0x0);
  aos_loop_run();
  puts("------------------------------------------\r\n");
  puts("+++++++++Critical Exit From Loop++++++++++\r\n");
  puts("******************************************\r\n");
  vTaskDelete((TaskHandle_t)0x0);
  return;
}



void vApplicationStackOverflowHook(TaskHandle_t xTask,char *pcTaskName)

{
  puts("Stack Overflow checked\r\n");
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void vApplicationMallocFailedHook(void)

{
  size_t sVar1;
  
  sVar1 = xPortGetFreeHeapSize();
  printf("Memory Allocate Failed. Current left size is %d bytes\r\n",sVar1);
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void vApplicationIdleHook(void)

{
  wfi();
  return;
}



void vApplicationGetIdleTaskMemory
               (StaticTask_t **ppxIdleTaskTCBBuffer,StackType_t **ppxIdleTaskStackBuffer,
               uint32_t *pulIdleTaskStackSize)

{
  StackType_t uxIdleTaskStack [96];
  StaticTask_t xIdleTaskTCB;
  
  *ppxIdleTaskTCBBuffer = (StaticTask_t *)&ram0x420104cc;
  *ppxIdleTaskStackBuffer = (StackType_t *)&ram0x4200fd0c;
  *pulIdleTaskStackSize = 0x60;
  return;
}



void vApplicationGetTimerTaskMemory
               (StaticTask_t **ppxTimerTaskTCBBuffer,StackType_t **ppxTimerTaskStackBuffer,
               uint32_t *pulTimerTaskStackSize)

{
  StackType_t uxTimerTaskStack [400];
  StaticTask_t xTimerTaskTCB;
  
  *ppxTimerTaskTCBBuffer = (StaticTask_t *)&ram0x4201052c;
  *ppxTimerTaskStackBuffer = (StackType_t *)&ram0x4200fe8c;
  *pulTimerTaskStackSize = 400;
  return;
}



// WARNING: Removing unreachable block (ram,0x230014ae)

void vAssertCalled(void)

{
  uint32_t ulSetTo1ToExitFunction;
  
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void bfl_main(void)

{
  StackType_t aos_loop_proc_stack [1024];
  StaticTask_t aos_loop_proc_task;
  int iVar1;
  char *pcStack76;
  char *banner;
  char chip_feature [40];
  
  bl_sys_early_init();
  bl_uart_init('\0','\x10','\a',-1,-1,(uint32_t)&DAT_001e8480);
  puts("Starting bl602 now....\r\n");
  bl_sys_init();
  puts("Booting BL602 Chip...\r\n");
  iVar1 = bl_chip_banner(&pcStack76);
  if (iVar1 == 0) {
    puts(pcStack76);
  }
  puts("\r\n");
  puts("\r\n");
  puts("------------------------------------------------------------\r\n");
  puts("RISC-V Core Feature:");
  bl_chip_info((char *)&banner);
  puts((char *)&banner);
  puts("\r\n");
  puts("Build Version: ");
  puts("release_bl_iot_sdk_1.6.11-1-g66bb28da-dirty");
  puts("\r\n");
  puts("Build Version: ");
  puts("release_bl_iot_sdk_1.6.11-1-g66bb28da-dirty");
  puts("\r\n");
  puts("PHY   Version: ");
  puts("a0_final-44-geb7fadd");
  puts("\r\n");
  puts("RF    Version: ");
  puts("f76e39a");
  puts("\r\n");
  puts("Build Date: ");
  puts("Oct 30 2020");
  puts("\r\n");
  puts("Build Time: ");
  puts("01:04:04");
  puts("\r\n");
  puts("------------------------------------------------------------\r\n");
  vPortDefineHeapRegions(xHeapRegions);
  printf("Heap %u@%p, %u@%p\r\n",&_heap_size,&__bss_end,0x860,&_heap_wifi_start);
  blog_init();
  bl_irq_init();
  bl_sec_init();
  bl_sec_test();
  bl_dma_init();
  hal_boot2_init();
  hal_board_cfg(0);
  puts("[OS] Starting aos_loop_proc task...\r\n");
  xTaskCreateStatic(aos_loop_proc,"event_loop",0x400,(void *)0x0,0xf,(StackType_t *)&ram0x4200e44c,
                    (StaticTask_t *)&ram0x4200f44c);
  puts("[OS] Starting TCP/IP Stack...\r\n");
  tcpip_init((tcpip_init_done_fn)0x0,(void *)0x0);
  puts("[OS] Starting OS Scheduler...\r\n");
  vTaskStartScheduler();
  return;
}



void blesync_complete_cb(void *p_arg)

{
  bl_ble_sync_stop((bl_ble_sync_t *)p_arg);
  vPortFree(p_arg);
  return;
}



void wifiprov_api_state_get(anon_subr_void_void_ptr *state_get)

{
  printf("Recevied indication to wifi state get\r\n");
  wifi_prov_api_event_state_get(state_get);
  return;
}



void wifiprov_wifi_scan(anon_subr_void_void_ptr *complete)

{
  printf("Recevied indication to wifi scan\r\n");
  wifi_prov_api_event_trigger_scan(complete);
  return;
}



void wifiprov_disc_from_ap_ind(void)

{
  printf("Recevied indication to disconnect to AP\r\n");
  wifi_prov_api_event_trigger_disconnect();
  return;
}



void wifiprov_connect_ap_ind(wifi_conn *info)

{
  wifi_mgmr_status_code_clean_internal();
  printf("Recevied indication to connect to AP\r\n");
  wifi_prov_api_event_trigger_connect(info);
  return;
}



void blsync_init(int err)

{
  if (err != 0) {
    return;
  }
  if (gp_index != (bl_ble_sync_t *)0x0) {
    printf("blsync already started\r\n");
    return;
  }
  ble_cli_register();
  gp_index = (bl_ble_sync_t *)pvPortMalloc(0x1908);
  if (gp_index != (bl_ble_sync_t *)0x0) {
    bl_ble_sync_start(gp_index,&WifiProv_conn_callback,blesync_complete_cb,gp_index);
    return;
  }
  return;
}



void blsync_ble_start(void)

{
  uint8_t stack_started;
  
  if (stack_started == '\x01') {
    blsync_init(0);
    return;
  }
  ble_controller_init('\x1f');
  hci_driver_init();
  bt_enable(blsync_init);
  return;
}



void blsync_ble_stop(void)

{
  bl_ble_sync_stop(gp_index);
  vPortFree(gp_index);
  gp_index = (bl_ble_sync_t *)0x0;
  return;
}



int wifi_prov_api_event_trigger_connect(wifi_conn *info)

{
  int iVar1;
  
  iVar1 = aos_post_event(2,0x10,(ulong)info);
  if (iVar1 < 0) {
    puts("[APP] [PROV] trigger CONNECT event failed\r\n");
    iVar1 = -1;
  }
  else {
    puts("[APP] [PROV] trigger CONNECT event OK\r\n");
    iVar1 = 0;
  }
  return iVar1;
}



int wifi_prov_api_event_trigger_disconnect(void)

{
  int iVar1;
  
  iVar1 = aos_post_event(2,0x11,0);
  if (iVar1 < 0) {
    puts("[APP] [PROV] trigger DISCONNECT event failed\r\n");
    iVar1 = -1;
  }
  else {
    puts("[APP] [PROV] trigger DISCONNECT event OK\r\n");
    iVar1 = 0;
  }
  return iVar1;
}



int wifi_prov_api_event_trigger_scan(anon_subr_void_void_ptr *complete)

{
  int iVar1;
  
  iVar1 = aos_post_event(2,0x12,(ulong)complete);
  if (iVar1 < 0) {
    puts("[APP] [PROV] trigger scan event failed\r\n");
    iVar1 = -1;
  }
  else {
    puts("[APP] [PROV] trigger scan event OK\r\n");
    iVar1 = 0;
  }
  return iVar1;
}



int wifi_prov_api_event_state_get(anon_subr_void_void_ptr *state_get)

{
  int iVar1;
  
  iVar1 = aos_post_event(2,0x13,(ulong)state_get);
  if (iVar1 < 0) {
    puts("[APP] [PROV] trigger scan event failed\r\n");
    iVar1 = -1;
  }
  else {
    puts("[APP] [PROV] trigger scan event OK\r\n");
    iVar1 = 0;
  }
  return iVar1;
}



void bl_printk(char *format,...)

{
  undefined4 in_a1;
  undefined4 in_a2;
  undefined4 in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list args;
  undefined4 uStack28;
  undefined4 uStack24;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  undefined4 uStack8;
  undefined4 uStack4;
  
  if (sys_log_all_enable != false) {
    uStack28 = in_a1;
    uStack24 = in_a2;
    uStack20 = in_a3;
    uStack16 = in_a4;
    uStack12 = in_a5;
    uStack8 = in_a6;
    uStack4 = in_a7;
    vprint(format,&uStack28);
  }
  return;
}



int log_buf_out(char *file,int line,void *inbuf,int len,LOG_BUF_OUT_DATA_TYPE_T type)

{
  bool bVar1;
  int iVar2;
  int iVar3;
  TickType_t TVar4;
  char *format;
  uint uVar5;
  undefined3 in_register_00002039;
  int iVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  void *pvVar10;
  
  iVar6 = CONCAT31(in_register_00002039,type);
  if (len < 1) {
    return -1;
  }
  iVar9 = len / 0x32;
  if (len % 0x32 == 0) {
    pvVar10 = (void *)(iVar9 * 0x32 + (int)inbuf);
    while (pvVar10 != inbuf) {
      iVar7 = 0;
      iVar9 = 0;
      do {
        uVar5 = (uint)*(byte *)((int)inbuf + iVar9);
        if (iVar6 == 1) {
          uVar5 = SEXT14((char)*(byte *)((int)inbuf + iVar9));
          format = "%3d ";
        }
        else {
          format = "%3u ";
          if (iVar6 != 2) {
            format = "%02x ";
          }
        }
        iVar3 = sprintf(log_buf + iVar7,format,uVar5);
        iVar9 = iVar9 + 1;
        iVar7 = iVar7 + iVar3;
      } while (iVar9 != 0x32);
      if (TrapNetCounter == 0) {
        TVar4 = xTaskGetTickCount();
      }
      else {
        TVar4 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] %.*s\r\n",TVar4,&UNK_2306f124,file,line,iVar7,log_buf);
      inbuf = (void *)((int)inbuf + 0x32);
    }
  }
  else {
    iVar7 = 0;
    do {
      iVar3 = 0;
      iVar8 = 0;
      if (iVar9 == iVar7) {
        do {
          uVar5 = (uint)*(byte *)((int)inbuf + iVar8);
          if (iVar6 == 1) {
            uVar5 = SEXT14((char)*(byte *)((int)inbuf + iVar8));
            format = "%3d ";
          }
          else {
            format = "%3u ";
            if (iVar6 != 2) {
              format = "%02x ";
            }
          }
          iVar2 = sprintf(log_buf + iVar3,format,uVar5);
          iVar8 = iVar8 + 1;
          iVar3 = iVar3 + iVar2;
        } while (len % 0x32 != iVar8);
      }
      else {
        do {
          uVar5 = (uint)*(byte *)((int)inbuf + iVar8);
          if (iVar6 == 1) {
            uVar5 = SEXT14((char)*(byte *)((int)inbuf + iVar8));
            format = "%3d ";
          }
          else {
            format = "%3u ";
            if (iVar6 != 2) {
              format = "%02x ";
            }
          }
          iVar2 = sprintf(log_buf + iVar3,format,uVar5);
          iVar8 = iVar8 + 1;
          iVar3 = iVar3 + iVar2;
        } while (iVar8 != 0x32);
      }
      if (TrapNetCounter == 0) {
        TVar4 = xTaskGetTickCount();
      }
      else {
        TVar4 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] %.*s\r\n",TVar4,&UNK_2306f124,file,line,iVar3,log_buf);
      inbuf = (void *)((int)inbuf + 0x32);
      bVar1 = iVar7 < iVar9;
      iVar7 = iVar7 + 1;
    } while (bVar1);
  }
  return 0;
}



int vfs_init(void)

{
  int iVar1;
  
  iVar1 = 0;
  if (g_vfs_init != '\x01') {
    g_vfs_mutex = (SemaphoreHandle_t)xQueueCreateMutexStatic('\x01',(StaticQueue_t *)&xMutexBuffer);
    iVar1 = -1;
    if (g_vfs_mutex != (SemaphoreHandle_t)0x0) {
      inode_init();
      iVar1 = 0;
      g_vfs_init = '\x01';
    }
  }
  return iVar1;
}



int aos_open(char *path,int flags)

{
  size_t sVar1;
  BaseType_t BVar2;
  inode_t *node;
  file_t *file;
  int iVar3;
  code *pcVar4;
  
  if (path == (char *)0x0) {
    iVar3 = -0x16;
  }
  else {
    sVar1 = strlen(path);
    if (0x400 < sVar1) {
      return -0x1a;
    }
    BVar2 = xQueueSemaphoreTake((QueueHandle_t)g_vfs_mutex,0xffffffff);
    if (BVar2 != 1) {
      return -1;
    }
    node = inode_open(path);
    if (node == (inode_t *)0x0) {
      xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
      return -2;
    }
    node->i_flags = flags;
    file = new_file(node);
    xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
    if (file == (file_t *)0x0) {
      return -0x17;
    }
    pcVar4 = *(code **)node->ops;
    if (node->type == '\x03') {
      if (pcVar4 == (code *)0x0) goto LAB_23001bd8;
      iVar3 = (*pcVar4)(file,path,flags);
    }
    else {
      if (pcVar4 == (code *)0x0) goto LAB_23001bd8;
      iVar3 = (*pcVar4)(node,file);
    }
    if (iVar3 == 0) {
LAB_23001bd8:
      iVar3 = get_fd(file);
      return iVar3;
    }
    del_file(file);
  }
  return iVar3;
}



int aos_close(int fd)

{
  int iVar1;
  file_t *file;
  BaseType_t BVar2;
  code *pcVar3;
  
  file = get_file(fd);
  iVar1 = -2;
  if (file != (file_t *)0x0) {
    iVar1 = 0;
    pcVar3 = *(code **)(file->node->ops + 4);
    if (pcVar3 != (code *)0x0) {
      iVar1 = (*pcVar3)();
    }
    BVar2 = xQueueSemaphoreTake((QueueHandle_t)g_vfs_mutex,0xffffffff);
    if (BVar2 == 1) {
      del_file(file);
      xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
    }
    else {
      iVar1 = -1;
    }
  }
  return iVar1;
}



ssize_t aos_read(int fd,void *buf,size_t nbytes)

{
  code *UNRECOVERED_JUMPTABLE;
  file_t *pfVar1;
  ssize_t sVar2;
  
  pfVar1 = get_file(fd);
  if (pfVar1 == (file_t *)0x0) {
    sVar2 = -2;
  }
  else {
    UNRECOVERED_JUMPTABLE = *(code **)(pfVar1->node->ops + 8);
    if (UNRECOVERED_JUMPTABLE != (code *)0x0) {
                    // WARNING: Could not recover jumptable at 0x23001c72. Too many branches
                    // WARNING: Treating indirect jump as call
      sVar2 = (*UNRECOVERED_JUMPTABLE)(buf,nbytes);
      return sVar2;
    }
    sVar2 = -1;
  }
  return sVar2;
}



ssize_t aos_write(int fd,void *buf,size_t nbytes)

{
  code *UNRECOVERED_JUMPTABLE;
  file_t *pfVar1;
  ssize_t sVar2;
  
  pfVar1 = get_file(fd);
  if (pfVar1 == (file_t *)0x0) {
    sVar2 = -2;
  }
  else {
    UNRECOVERED_JUMPTABLE = *(code **)(pfVar1->node->ops + 0xc);
    if (UNRECOVERED_JUMPTABLE != (code *)0x0) {
                    // WARNING: Could not recover jumptable at 0x23001ca0. Too many branches
                    // WARNING: Treating indirect jump as call
      sVar2 = (*UNRECOVERED_JUMPTABLE)(buf,nbytes);
      return sVar2;
    }
    sVar2 = -1;
  }
  return sVar2;
}



int aos_ioctl(int fd,int cmd,ulong arg)

{
  code *UNRECOVERED_JUMPTABLE;
  file_t *pfVar1;
  int iVar2;
  
  if (fd < 0) {
    return -0x16;
  }
  pfVar1 = get_file(fd);
  if (pfVar1 == (file_t *)0x0) {
    iVar2 = -2;
  }
  else {
    iVar2 = pfVar1->node->ops;
    if (pfVar1->node->type == '\x03') {
      UNRECOVERED_JUMPTABLE = *(code **)(iVar2 + 0x44);
    }
    else {
      UNRECOVERED_JUMPTABLE = *(code **)(iVar2 + 0x10);
    }
    if (UNRECOVERED_JUMPTABLE != (code *)0x0) {
                    // WARNING: Could not recover jumptable at 0x23001cdc. Too many branches
                    // WARNING: Treating indirect jump as call
      iVar2 = (*UNRECOVERED_JUMPTABLE)(cmd,arg);
      return iVar2;
    }
    iVar2 = -0x47;
  }
  return iVar2;
}



int aos_stat(char *path,stat *st)

{
  int iVar1;
  BaseType_t BVar2;
  inode_t *node;
  file_t *file;
  code *pcVar3;
  
  if (path == (char *)0x0) {
    return -0x16;
  }
  BVar2 = xQueueSemaphoreTake((QueueHandle_t)g_vfs_mutex,0xffffffff);
  if (BVar2 == 1) {
    node = inode_open(path);
    if (node == (inode_t *)0x0) {
      xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
      return -0x13;
    }
    file = new_file(node);
    xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
    if (file == (file_t *)0x0) {
      return -2;
    }
    iVar1 = -0x47;
    if ((node->type == '\x03') && (pcVar3 = *(code **)(node->ops + 0x18), pcVar3 != (code *)0x0)) {
      iVar1 = (*pcVar3)(file,path,st);
    }
    BVar2 = xQueueSemaphoreTake((QueueHandle_t)g_vfs_mutex,0xffffffff);
    if (BVar2 == 1) {
      del_file(file);
      xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
      return iVar1;
    }
  }
  return -1;
}



aos_dir_t * aos_opendir(char *path)

{
  BaseType_t BVar1;
  inode_t *node;
  file_t *file;
  aos_dir_t *paVar2;
  int iVar3;
  code *pcVar4;
  
  if ((path != (char *)0x0) &&
     (BVar1 = xQueueSemaphoreTake((QueueHandle_t)g_vfs_mutex,0xffffffff), BVar1 == 1)) {
    node = inode_open(path);
    if (node == (inode_t *)0x0) {
      xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
      return (aos_dir_t *)0x0;
    }
    file = new_file(node);
    xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
    if (file != (file_t *)0x0) {
      if (((node->type == '\x03') && (pcVar4 = *(code **)(node->ops + 0x24), pcVar4 != (code *)0x0))
         && (paVar2 = (aos_dir_t *)(*pcVar4)(file,path), paVar2 != (aos_dir_t *)0x0)) {
        iVar3 = get_fd(file);
        paVar2->dd_vfs_fd = iVar3;
        return paVar2;
      }
      BVar1 = xQueueSemaphoreTake((QueueHandle_t)g_vfs_mutex,0xffffffff);
      if (BVar1 == 1) {
        del_file(file);
        xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
      }
    }
  }
  return (aos_dir_t *)0x0;
}



int aos_closedir(aos_dir_t *dir)

{
  int iVar1;
  file_t *file;
  BaseType_t BVar2;
  code *pcVar3;
  
  iVar1 = -0x16;
  if (dir != (aos_dir_t *)0x0) {
    iVar1 = -2;
    file = get_file(dir->dd_vfs_fd);
    if (file != (file_t *)0x0) {
      iVar1 = -0x47;
      if ((file->node->type == '\x03') &&
         (pcVar3 = *(code **)(file->node->ops + 0x2c), pcVar3 != (code *)0x0)) {
        iVar1 = (*pcVar3)(dir);
      }
      BVar2 = xQueueSemaphoreTake((QueueHandle_t)g_vfs_mutex,0xffffffff);
      if (BVar2 == 1) {
        del_file(file);
        xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
      }
      else {
        iVar1 = -1;
      }
    }
  }
  return iVar1;
}



aos_dirent_t * aos_readdir(aos_dir_t *dir)

{
  code *UNRECOVERED_JUMPTABLE;
  file_t *pfVar1;
  aos_dirent_t *paVar2;
  
  if (dir == (aos_dir_t *)0x0) {
    return (aos_dirent_t *)0x0;
  }
  pfVar1 = get_file(dir->dd_vfs_fd);
  if (pfVar1 != (file_t *)0x0) {
    if (pfVar1->node->type == '\x03') {
      UNRECOVERED_JUMPTABLE = *(code **)(pfVar1->node->ops + 0x28);
      if (UNRECOVERED_JUMPTABLE != (code *)0x0) {
                    // WARNING: Could not recover jumptable at 0x23001efc. Too many branches
                    // WARNING: Treating indirect jump as call
        paVar2 = (aos_dirent_t *)(*UNRECOVERED_JUMPTABLE)(dir);
        return paVar2;
      }
    }
  }
  return (aos_dirent_t *)0x0;
}



file_t * new_file(inode_t *node)

{
  file_t *pfVar1;
  int iVar2;
  
  pfVar1 = files;
  iVar2 = 0;
  do {
    if (pfVar1->node == (inode_t *)0x0) {
      files[iVar2].node = node;
      files[iVar2].f_arg = (void *)0x0;
      files[iVar2].offset = 0;
      inode_ref(node);
      return files + iVar2;
    }
    iVar2 = iVar2 + 1;
    pfVar1 = pfVar1 + 1;
  } while (iVar2 != 0x3c);
  return (file_t *)0x0;
}



void del_file(file_t *file)

{
  inode_unref(file->node);
  file->node = (inode_t *)0x0;
  return;
}



int get_fd(file_t *file)

{
  return ((int)(file + -0x58015fd) >> 2) * -0x55555555 + 2;
}



file_t * get_file(int fd)

{
  inode_t *piVar1;
  
  if (fd - 2U < 0x3c) {
    piVar1 = files[fd - 2U].node;
    if (piVar1 != (inode_t *)0x0) {
      return files + (fd - 2U);
    }
  }
  else {
    piVar1 = (inode_t *)0x0;
  }
  return (file_t *)piVar1;
}



int inode_init(void)

{
  memset(g_vfs_dev_nodes,0,600);
  return 0;
}



int inode_alloc(void)

{
  int iVar1;
  inode_t *piVar2;
  
  piVar2 = g_vfs_dev_nodes;
  iVar1 = 0;
  do {
    if (piVar2->type == '\0') {
      return iVar1;
    }
    iVar1 = iVar1 + 1;
    piVar2 = piVar2 + 1;
  } while (iVar1 != 0x1e);
  return -0xc;
}



inode_t * inode_open(char *path)

{
  inode_t *piVar1;
  int iVar2;
  size_t __n;
  char *__s;
  
  piVar1 = g_vfs_dev_nodes;
  do {
    __s = piVar1->i_name;
    if (__s != (char *)0x0) {
      if (piVar1->type == '\x03') {
        __n = strlen(__s);
        iVar2 = strncmp(__s,path,__n);
        if ((iVar2 == 0) && (__n = strlen(piVar1->i_name), path[__n] == '/')) {
          return piVar1;
        }
      }
      iVar2 = strcmp(piVar1->i_name,path);
      if (iVar2 == 0) {
        return piVar1;
      }
    }
    piVar1 = piVar1 + 1;
    if (piVar1 == (inode_t *)string) {
      return (inode_t *)0x0;
    }
  } while( true );
}



int inode_forearch_name(anon_subr_int_void_ptr_inode_t_ptr *cb,void *arg)

{
  inode_t *piVar1;
  int iVar2;
  int iVar3;
  
  piVar1 = g_vfs_dev_nodes;
  iVar2 = 0;
  do {
    if (piVar1->i_name != (char *)0x0) {
      iVar2 = iVar2 + 1;
      iVar3 = (*cb)(arg,piVar1);
      if (iVar3 != 0) {
        return iVar2;
      }
    }
    piVar1 = piVar1 + 1;
  } while (piVar1 != (inode_t *)string);
  return iVar2;
}



void inode_ref(inode_t *node)

{
  node->refs = node->refs + '\x01';
  return;
}



void inode_unref(inode_t *node)

{
  if (node->refs != '\0') {
    node->refs = node->refs + -1;
  }
  return;
}



int inode_reserve(char *path,inode_t **inode)

{
  inode_t *piVar1;
  int iVar2;
  size_t __n;
  char *__dest;
  
  if (((path != (char *)0x0) && (inode != (inode_t **)0x0)) &&
     (*inode = (inode_t *)0x0, *path == '/')) {
    iVar2 = inode_alloc();
    if (-1 < iVar2) {
      piVar1 = (inode_t *)0x0;
      if (iVar2 < 0x1e) {
        piVar1 = g_vfs_dev_nodes + iVar2;
      }
      __n = strlen(path);
      __dest = (char *)pvPortMalloc(__n + 1);
      iVar2 = -0xc;
      if (__dest != (char *)0x0) {
        memcpy(__dest,path,__n);
        piVar1->i_name = __dest;
        __dest[__n] = '\0';
        *inode = piVar1;
        iVar2 = 0;
      }
    }
    return iVar2;
  }
  return -0x16;
}



yloop_ctx_t * get_context(void)

{
  yloop_ctx_t *pyVar1;
  
  pyVar1 = (yloop_ctx_t *)aos_task_getspecific(g_loop_key);
  if (pyVar1 == (yloop_ctx_t *)0x0) {
    aos_task_setspecific(g_loop_key,g_main_ctx);
    pyVar1 = g_main_ctx;
  }
  return pyVar1;
}



void aos_loop_set_eventfd(int fd)

{
  yloop_ctx_t *pyVar1;
  
  pyVar1 = get_context();
  pyVar1->eventfd = fd;
  return;
}



aos_loop_t aos_loop_init(void)

{
  aos_task_key_t key;
  void *pvVar1;
  yloop_ctx_t *__s;
  
  pvVar1 = aos_task_getspecific(g_loop_key);
  if (g_main_ctx == (yloop_ctx_t *)0x0) {
    aos_task_key_create(&g_loop_key);
  }
  else {
    if (pvVar1 != (void *)0x0) {
      printf("yloopyloop already inited");
      return pvVar1;
    }
  }
  __s = (yloop_ctx_t *)pvPortMalloc(0x1c);
  if (__s != (yloop_ctx_t *)0x0) {
    memset(__s,0,0x1c);
  }
  if (g_main_ctx == (yloop_ctx_t *)0x0) {
    g_main_ctx = __s;
  }
  *(yloop_ctx_t **)&(__s->timeouts).prev = __s;
  key = g_loop_key;
  __s->eventfd = -1;
  *(yloop_ctx_t **)&(__s->timeouts).next = __s;
  aos_task_setspecific(key,__s);
  aos_event_service_init();
  return __s;
}



int aos_poll_read_fd(int sock,aos_poll_call_t *cb,void *private_data)

{
  yloop_sock_t *__dest;
  yloop_ctx_t *pyVar1;
  pollfd *__dest_00;
  uint uVar2;
  int iVar3;
  uint uVar4;
  
  pyVar1 = get_context();
  if (sock < 0) {
    iVar3 = -0x16;
  }
  else {
    uVar4 = (uint)pyVar1->reader_count;
    __dest = (yloop_sock_t *)pvPortMalloc((uVar4 + 1) * 0xc);
    __dest_00 = (pollfd *)pvPortMalloc((uVar4 + 1) * 8);
    if ((__dest == (yloop_sock_t *)0x0) || (__dest_00 == (pollfd *)0x0)) {
      printf("yloopout of memory");
      vPortFree(__dest);
      vPortFree(__dest_00);
      iVar3 = -0xc;
    }
    else {
      uVar2 = aos_fcntl(sock,3,0);
      aos_fcntl(sock,4,uVar2 | 0x4000);
      pyVar1->reader_count = pyVar1->reader_count + '\x01';
      memcpy(__dest,pyVar1->readers,uVar4 * 0xc);
      vPortFree(pyVar1->readers);
      pyVar1->readers = __dest;
      memcpy(__dest_00,pyVar1->pollfds,uVar4 << 3);
      __dest = __dest + uVar4;
      vPortFree(pyVar1->pollfds);
      pyVar1->pollfds = __dest_00;
      __dest->sock = sock;
      __dest->private_data = private_data;
      __dest->cb = cb;
      iVar3 = 0;
      if ((int)(uint)pyVar1->max_sock < sock) {
        pyVar1->max_sock = (uint16_t)sock;
        iVar3 = 0;
      }
    }
  }
  return iVar3;
}



int aos_post_delayed_action(int ms,aos_call_t *action,void *param)

{
  yloop_ctx_t *pyVar1;
  dlist_s *pdVar2;
  int iVar3;
  pollfd *ppVar4;
  aos_call_t *paVar5;
  yloop_sock_t *pyVar6;
  dlist_s *pdVar7;
  yloop_ctx_t *pyVar8;
  
  if (action != (aos_call_t *)0x0) {
    paVar5 = action;
    pyVar1 = get_context();
    pdVar2 = (dlist_s *)pvPortMalloc(0x20);
    iVar3 = -0xc;
    if (pdVar2 != (dlist_s *)0x0) {
      aos_now_ms();
      ppVar4 = (pollfd *)(iVar3 + ms);
      pyVar6 = (yloop_sock_t *)(paVar5 + (uint)(ppVar4 < (uint)ms) + (ms >> 0x1f));
      *(pollfd **)&pdVar2[1].prev = ppVar4;
      *(yloop_sock_t **)&pdVar2[1].next = pyVar6;
      pdVar2[2].prev = param;
      *(aos_call_t **)&pdVar2[2].next = action;
      *(int *)&pdVar2[3].prev = ms;
      pyVar8 = (yloop_ctx_t *)(pyVar1->timeouts).next;
      while (((pyVar8 != pyVar1 && ((int)pyVar8->readers <= (int)pyVar6)) &&
             ((pyVar8->readers != pyVar6 || (pyVar8->pollfds <= ppVar4))))) {
        pyVar8 = (yloop_ctx_t *)(pyVar8->timeouts).next;
      }
      pdVar7 = (pyVar8->timeouts).prev;
      *(yloop_ctx_t **)&pdVar2->next = pyVar8;
      iVar3 = 0;
      pdVar2->prev = pdVar7;
      pdVar7->next = pdVar2;
      (pyVar8->timeouts).prev = pdVar2;
    }
    return iVar3;
  }
  return -0x16;
}



void aos_loop_run(yloop_sock_t *param_1)

{
  yloop_ctx_t *pyVar1;
  yloop_sock_t *pyVar2;
  yloop_ctx_t *pyVar3;
  yloop_ctx_t *pyVar4;
  yloop_sock_t *extraout_a1;
  yloop_sock_t *extraout_a1_00;
  yloop_ctx_t *pv;
  dlist_s *pdVar5;
  int iVar6;
  dlist_s *pdVar7;
  yloop_sock_t *pyVar8;
  yloop_sock_t *nfds;
  undefined4 extraout_fa0;
  longlong lVar9;
  
  pyVar3 = get_context();
  pyVar4 = pyVar3;
  while (pyVar3->terminate == false) {
    pyVar1 = (yloop_ctx_t *)(pyVar3->timeouts).next;
    nfds = (yloop_sock_t *)(uint)pyVar3->reader_count;
    if ((pyVar3 == pyVar1) && (pyVar3->reader_count == 0)) break;
    pv = (yloop_ctx_t *)0xffffffff;
    if (pyVar3 != pyVar1) {
      aos_now_ms();
      if (((int)param_1 < (int)pyVar1->readers) ||
         ((pyVar1->readers == param_1 && (pyVar4 < (yloop_ctx_t *)pyVar1->pollfds)))) {
        pv = (yloop_ctx_t *)((int)(yloop_ctx_t *)pyVar1->pollfds - (int)pyVar4);
      }
      else {
        pv = (yloop_ctx_t *)0x0;
      }
    }
    iVar6 = 0;
    while (iVar6 < (int)nfds) {
      pyVar3->pollfds[iVar6].fd = pyVar3->readers[iVar6].sock;
      pyVar3->pollfds[iVar6].events = 1;
      iVar6 = iVar6 + 1;
    }
    param_1 = nfds;
    pyVar1 = (yloop_ctx_t *)aos_poll(pyVar3->pollfds,(int)nfds,(int)pv);
    pyVar4 = pyVar1;
    if ((int)pyVar1 < 0) {
      pyVar4 = (yloop_ctx_t *)__errno();
      param_1 = extraout_a1;
      if ((pyVar4->timeouts).prev != (dlist_s *)0x4) {
        printf("yloopaos_poll",extraout_fa0);
        return;
      }
    }
    pv = (yloop_ctx_t *)(pyVar3->timeouts).next;
    if (pyVar3 != pv) {
      lVar9 = aos_now_ms();
      if (((int)pv->readers <= (int)param_1) &&
         ((pv->readers != param_1 || ((yloop_ctx_t *)pv->pollfds <= pyVar4)))) {
        pdVar7 = (pv->timeouts).next;
        pdVar5 = (pv->timeouts).prev;
        pdVar5->next = pdVar7;
        pdVar7->prev = pdVar5;
        param_1 = (yloop_sock_t *)
                  (**(code **)&pv->max_sock)(pv->eventfd,*(code **)&pv->max_sock,(int)lVar9);
        vPortFree(pv);
        pyVar4 = pv;
      }
    }
    pyVar2 = (yloop_sock_t *)0x0;
    if (0 < (int)pyVar1) {
      while (pyVar2 != nfds) {
        if ((pyVar3->pollfds[(int)pyVar2].revents & 1U) != 0) {
          pyVar8 = pyVar3->readers + (int)pyVar2;
          pyVar4 = (yloop_ctx_t *)(*pyVar8->cb)(pyVar8->sock,pyVar8->private_data);
          param_1 = extraout_a1_00;
        }
        pyVar2 = (yloop_sock_t *)((int)&pyVar2->sock + 1);
      }
    }
  }
  pyVar3->terminate = false;
  return;
}



void vfs_poll_notify(pollfd *fd,void *arg)

{
  aos_sem_signal((aos_sem_t *)arg);
  return;
}



int aos_poll(pollfd *fds,int nfds,int timeout)

{
  ushort *puVar1;
  int iVar2;
  uint fd;
  file_t *pfVar3;
  ushort *puVar4;
  int iVar5;
  code *pcVar6;
  int iVar7;
  pollfd *ppVar8;
  aos_sem_t aStack60;
  poll_arg parg;
  _types_fd_set rfds;
  
  aos_sem_new(&aStack60,0);
  iVar5 = 0;
  do {
    *(undefined *)((int)&parg.sem.hdl + iVar5) = 0;
    iVar5 = iVar5 + 1;
  } while (iVar5 != 8);
  puVar1 = (ushort *)&fds->revents;
  iVar5 = 0;
  puVar4 = puVar1;
  while (iVar5 < nfds) {
    *puVar4 = 0;
    iVar5 = iVar5 + 1;
    puVar4 = puVar4 + 4;
  }
  iVar5 = 0;
  ppVar8 = fds;
  do {
    if (nfds <= iVar5) {
      if (timeout < 0) {
        timeout = 0xffffffff;
      }
      aos_sem_wait(&aStack60,timeout);
      iVar5 = 0;
      while (iVar5 < nfds) {
        if ((1 << (*(uint *)(puVar1 + -3) & 0x1f) &
            (uint)(&parg)[*(uint *)(puVar1 + -3) >> 5].sem.hdl) != 0) {
          *puVar1 = *puVar1 | 1;
        }
        iVar5 = iVar5 + 1;
        puVar1 = puVar1 + 4;
      }
      iVar5 = 0;
check_poll:
      iVar2 = 0;
      iVar7 = 0;
      while (iVar7 < nfds) {
        if (((1 < fds->fd) && (pfVar3 = get_file(fds->fd), pfVar3 != (file_t *)0x0)) &&
           (pcVar6 = *(code **)(pfVar3->node->ops + 0x14), (*pcVar6)(0,0,0,0,pcVar6),
           fds->revents != 0)) {
          iVar2 = iVar2 + 1;
        }
        iVar7 = iVar7 + 1;
        fds = fds + 1;
      }
      aos_sem_free(&aStack60);
      if (iVar5 != 0) {
        iVar2 = 0;
      }
      return iVar2;
    }
    fd = ppVar8->fd;
    if ((int)fd < 2) {
      (&parg)[fd >> 5].sem.hdl = (void *)(1 << (fd & 0x1f) | (uint)(&parg)[fd >> 5].sem.hdl);
    }
    else {
      pfVar3 = get_file(fd);
      if (pfVar3 == (file_t *)0x0) {
        iVar5 = -1;
        goto check_poll;
      }
      pcVar6 = *(code **)(pfVar3->node->ops + 0x14);
      (*pcVar6)(1,vfs_poll_notify,ppVar8,&aStack60,pcVar6);
    }
    iVar5 = iVar5 + 1;
    ppVar8 = ppVar8 + 1;
  } while( true );
}



int aos_fcntl(int fd,int cmd,int val)

{
  int iVar1;
  
  iVar1 = -0x16;
  if ((-1 < fd) && (iVar1 = 0, fd < 2)) {
    iVar1 = -2;
  }
  return iVar1;
}



void dfl_entry(void *arg)

{
  code *pcVar1;
  undefined4 uVar2;
  
  uVar2 = *(undefined4 *)((int)arg + 8);
  pcVar1 = *(code **)((int)arg + 4);
  vPortFree(arg);
  (*pcVar1)(uVar2);
  vTaskDelete((TaskHandle_t)0x0);
  return;
}



int aos_task_new(char *name,anon_subr_void_void_ptr *fn,void *arg,int stack_size)

{
  StaticTask_t *pxTaskBuffer;
  StaticTask_t **pvParameters;
  StackType_t *puxStackBuffer;
  TaskHandle_t ptVar1;
  int iVar2;
  
  pxTaskBuffer = (StaticTask_t *)pvPortMalloc(0x9c);
  pvParameters = (StaticTask_t **)pvPortMalloc(0xc);
  puxStackBuffer = (StackType_t *)pvPortMalloc(stack_size);
  memset(puxStackBuffer,0,stack_size);
  memset(pxTaskBuffer,0,0x9c);
  pxTaskBuffer[1].pxDummy1 = (void *)0xfffffff0;
  *(StackType_t **)(pxTaskBuffer[1].xDummy3[0].pvDummy3 + 3) = puxStackBuffer;
  strncpy((char *)(pxTaskBuffer[1].xDummy3 + 1),name,0x1f);
  *(undefined4 *)(pxTaskBuffer[1].ucDummy7 + 4) = 0x20171020;
  *pvParameters = pxTaskBuffer;
  *(anon_subr_void_void_ptr **)(pvParameters + 1) = fn;
  pvParameters[2] = arg;
  ptVar1 = xTaskCreateStatic(dfl_entry,name,(uint)stack_size >> 2,pvParameters,10,puxStackBuffer,
                             pxTaskBuffer);
  if (ptVar1 == (TaskHandle_t)0x0) {
    vPortFree(pxTaskBuffer);
    vPortFree(puxStackBuffer);
    vPortFree(pvParameters);
    iVar2 = -1;
  }
  else {
    iVar2 = 0;
  }
  return iVar2;
}



void aos_task_exit(int code)

{
  vTaskDelete((TaskHandle_t)0x0);
  return;
}



int aos_task_key_create(aos_task_key_t *key)

{
  TaskHandle_t ptVar1;
  uint uVar2;
  aos_task_key_t aVar3;
  int iVar4;
  StackType_t *pSVar5;
  
  ptVar1 = xTaskGetCurrentTaskHandle();
  if (*(int *)(ptVar1[1].pcTaskName + 4) == 0x20171020) {
    pSVar5 = ptVar1[1].pxTopOfStack;
    if (((uint)pSVar5 & 1) == 0) {
      aVar3 = 0;
      uVar2 = 1;
    }
    else {
      if (((uint)pSVar5 & 2) == 0) {
        aVar3 = 1;
        uVar2 = 2;
      }
      else {
        if (((uint)pSVar5 & 4) == 0) {
          aVar3 = 2;
          uVar2 = 4;
        }
        else {
          if (((uint)pSVar5 & 8) != 0) {
            return -1;
          }
          aVar3 = 3;
          uVar2 = 8;
        }
      }
    }
    ptVar1[1].pxTopOfStack = (StackType_t *)((uint)pSVar5 | uVar2);
    *key = aVar3;
    iVar4 = 0;
  }
  else {
    iVar4 = -1;
  }
  return iVar4;
}



int aos_task_setspecific(aos_task_key_t key,void *vp)

{
  TaskHandle_t ptVar1;
  int iVar2;
  
  ptVar1 = xTaskGetCurrentTaskHandle();
  if (key < 4) {
    iVar2 = -1;
    if (*(int *)(ptVar1[1].pcTaskName + 4) == 0x20171020) {
      *(void **)(&(ptVar1->xStateListItem).xItemValue + key + 0x18) = vp;
      iVar2 = 0;
    }
  }
  else {
    iVar2 = -1;
  }
  return iVar2;
}



void * aos_task_getspecific(aos_task_key_t key)

{
  TaskHandle_t ptVar1;
  void *pvVar2;
  
  ptVar1 = xTaskGetCurrentTaskHandle();
  if (key < 4) {
    pvVar2 = (void *)0x0;
    if (*(int *)(ptVar1[1].pcTaskName + 4) == 0x20171020) {
      pvVar2 = (void *)(&(ptVar1->xStateListItem).xItemValue)[key + 0x18];
    }
  }
  else {
    pvVar2 = (void *)0x0;
  }
  return pvVar2;
}



int aos_mutex_new(aos_mutex_t *mutex)

{
  QueueHandle_t pQVar1;
  
  pQVar1 = xQueueCreateMutex('\x01');
  *(QueueHandle_t *)&mutex->hdl = pQVar1;
  return -(uint)(pQVar1 == (QueueHandle_t)0x0);
}



void aos_mutex_free(aos_mutex_t *mutex)

{
  vQueueDelete((QueueHandle_t)mutex->hdl);
  return;
}



int aos_mutex_lock(aos_mutex_t *mutex,uint ms)

{
  if (mutex != (aos_mutex_t *)0x0) {
    xQueueSemaphoreTake((QueueHandle_t)mutex->hdl,ms);
    return 0;
  }
  return 0;
}



int aos_mutex_unlock(aos_mutex_t *mutex)

{
  if (mutex != (aos_mutex_t *)0x0) {
    xQueueGenericSend((QueueHandle_t)mutex->hdl,(void *)0x0,0,0);
    return 0;
  }
  return 0;
}



int aos_sem_new(aos_sem_t *sem,int count)

{
  QueueHandle_t pQVar1;
  
  pQVar1 = xQueueCreateCountingSemaphore(0x80,count);
  *(QueueHandle_t *)&sem->hdl = pQVar1;
  return 0;
}



void aos_sem_free(aos_sem_t *sem)

{
  if (sem != (aos_sem_t *)0x0) {
    vQueueDelete((QueueHandle_t)sem->hdl);
    return;
  }
  return;
}



int aos_sem_wait(aos_sem_t *sem,uint ms)

{
  BaseType_t BVar1;
  
  if (sem != (aos_sem_t *)0x0) {
    BVar1 = xQueueSemaphoreTake((QueueHandle_t)sem->hdl,ms);
    return -(uint)(BVar1 != 1);
  }
  return -1;
}



void aos_sem_signal(aos_sem_t *sem)

{
  BaseType_t BStack20;
  BaseType_t xHigherPriorityTaskWoken;
  
  BStack20 = 0;
  if (sem != (aos_sem_t *)0x0) {
    if (TrapNetCounter == 0) {
      xQueueGenericSend((QueueHandle_t)sem->hdl,(void *)0x0,0,0);
    }
    else {
      xQueueGiveFromISR((QueueHandle_t)sem->hdl,&BStack20);
      if (BStack20 != 0) {
        vTaskSwitchContext();
      }
    }
  }
  return;
}



void * aos_malloc(size_t xWantedSize)

{
  size_t sVar1;
  size_t sVar2;
  BlockLink_t *pBVar3;
  A_BLOCK_LINK *pAVar4;
  BlockLink_t *pxBlockToInsert;
  uint uVar5;
  uint uVar6;
  
  if (pxEnd == (BlockLink_t *)0x0) {
    vAssertCalled();
  }
  vTaskSuspendAll();
  sVar2 = xFreeBytesRemaining;
  sVar1 = xBlockAllocatedBit;
  if (((xBlockAllocatedBit & xWantedSize) == 0) && (xWantedSize != 0)) {
    uVar6 = xWantedSize + 8;
    if ((uVar6 & 7) != 0) {
      uVar6 = (uVar6 & 0xfffffff8) + 8;
    }
    if ((uVar6 != 0) && (uVar6 <= xFreeBytesRemaining)) {
      pAVar4 = xStart.pxNextFreeBlock;
      pBVar3 = &xStart;
      do {
        pxBlockToInsert = pBVar3;
        pBVar3 = (BlockLink_t *)pAVar4;
        if (uVar6 <= pBVar3->xBlockSize) break;
        pAVar4 = pBVar3->pxNextFreeBlock;
      } while (pBVar3->pxNextFreeBlock != (A_BLOCK_LINK *)0x0);
      if (pxEnd != pBVar3) {
        pAVar4 = pxBlockToInsert->pxNextFreeBlock;
        pxBlockToInsert->pxNextFreeBlock = pBVar3->pxNextFreeBlock;
        uVar5 = pBVar3->xBlockSize;
        pAVar4 = pAVar4 + 1;
        if (0x10 < uVar5 - uVar6) {
          pxBlockToInsert = (BlockLink_t *)((int)&pBVar3->pxNextFreeBlock + uVar6);
          pxBlockToInsert->xBlockSize = uVar5 - uVar6;
          pBVar3->xBlockSize = uVar6;
          prvInsertBlockIntoFreeList(pxBlockToInsert);
          uVar5 = pBVar3->xBlockSize;
        }
        xFreeBytesRemaining = sVar2 - uVar5;
        if (xFreeBytesRemaining < xMinimumEverFreeBytesRemaining) {
          xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
        }
        pBVar3->xBlockSize = sVar1 | uVar5;
        pBVar3->pxNextFreeBlock = (A_BLOCK_LINK *)0x0;
        xTaskResumeAll();
        if (pAVar4 != (A_BLOCK_LINK *)0x0) {
          return pAVar4;
        }
        goto LAB_230359be;
      }
    }
  }
  xTaskResumeAll();
LAB_230359be:
  vApplicationMallocFailedHook();
  return (void *)0x0;
}



void free(void *pv)

{
  uint uVar1;
  
  if (pv == (void *)0x0) {
    return;
  }
  uVar1 = *(uint *)((int)pv + -4);
  if ((uVar1 & xBlockAllocatedBit) == 0) {
    vAssertCalled();
    if (*(int *)((int)pv + -8) == 0) {
      uVar1 = *(uint *)((int)pv + -4);
      if ((uVar1 & xBlockAllocatedBit) == 0) {
        return;
      }
      goto LAB_23035ace;
    }
  }
  else {
    if (*(int *)((int)pv + -8) == 0) goto LAB_23035ace;
  }
  vAssertCalled();
  uVar1 = *(uint *)((int)pv + -4);
  if (((uVar1 & xBlockAllocatedBit) == 0) || (*(int *)((int)pv + -8) != 0)) {
    return;
  }
LAB_23035ace:
  *(uint *)((int)pv + -4) = ~xBlockAllocatedBit & uVar1;
  vTaskSuspendAll();
  xFreeBytesRemaining = *(int *)((int)pv + -4) + xFreeBytesRemaining;
  prvInsertBlockIntoFreeList((BlockLink_t *)((int)pv + -8));
  xTaskResumeAll();
  return;
}



void aos_free(void *pv)

{
  uint uVar1;
  
  if (pv == (void *)0x0) {
    return;
  }
  uVar1 = *(uint *)((int)pv + -4);
  if ((uVar1 & xBlockAllocatedBit) == 0) {
    vAssertCalled();
    if (*(int *)((int)pv + -8) == 0) {
      uVar1 = *(uint *)((int)pv + -4);
      if ((uVar1 & xBlockAllocatedBit) == 0) {
        return;
      }
      goto LAB_23035ace;
    }
  }
  else {
    if (*(int *)((int)pv + -8) == 0) goto LAB_23035ace;
  }
  vAssertCalled();
  uVar1 = *(uint *)((int)pv + -4);
  if (((uVar1 & xBlockAllocatedBit) == 0) || (*(int *)((int)pv + -8) != 0)) {
    return;
  }
LAB_23035ace:
  *(uint *)((int)pv + -4) = ~xBlockAllocatedBit & uVar1;
  vTaskSuspendAll();
  xFreeBytesRemaining = *(int *)((int)pv + -4) + xFreeBytesRemaining;
  prvInsertBlockIntoFreeList((BlockLink_t *)((int)pv + -8));
  xTaskResumeAll();
  return;
}



void * malloc(size_t xWantedSize)

{
  size_t sVar1;
  size_t sVar2;
  BlockLink_t *pBVar3;
  A_BLOCK_LINK *pAVar4;
  BlockLink_t *pxBlockToInsert;
  uint uVar5;
  uint uVar6;
  
  if (pxEnd == (BlockLink_t *)0x0) {
    vAssertCalled();
  }
  vTaskSuspendAll();
  sVar2 = xFreeBytesRemaining;
  sVar1 = xBlockAllocatedBit;
  if (((xBlockAllocatedBit & xWantedSize) == 0) && (xWantedSize != 0)) {
    uVar6 = xWantedSize + 8;
    if ((uVar6 & 7) != 0) {
      uVar6 = (uVar6 & 0xfffffff8) + 8;
    }
    if ((uVar6 != 0) && (uVar6 <= xFreeBytesRemaining)) {
      pAVar4 = xStart.pxNextFreeBlock;
      pBVar3 = &xStart;
      do {
        pxBlockToInsert = pBVar3;
        pBVar3 = (BlockLink_t *)pAVar4;
        if (uVar6 <= pBVar3->xBlockSize) break;
        pAVar4 = pBVar3->pxNextFreeBlock;
      } while (pBVar3->pxNextFreeBlock != (A_BLOCK_LINK *)0x0);
      if (pxEnd != pBVar3) {
        pAVar4 = pxBlockToInsert->pxNextFreeBlock;
        pxBlockToInsert->pxNextFreeBlock = pBVar3->pxNextFreeBlock;
        uVar5 = pBVar3->xBlockSize;
        pAVar4 = pAVar4 + 1;
        if (0x10 < uVar5 - uVar6) {
          pxBlockToInsert = (BlockLink_t *)((int)&pBVar3->pxNextFreeBlock + uVar6);
          pxBlockToInsert->xBlockSize = uVar5 - uVar6;
          pBVar3->xBlockSize = uVar6;
          prvInsertBlockIntoFreeList(pxBlockToInsert);
          uVar5 = pBVar3->xBlockSize;
        }
        xFreeBytesRemaining = sVar2 - uVar5;
        if (xFreeBytesRemaining < xMinimumEverFreeBytesRemaining) {
          xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
        }
        pBVar3->xBlockSize = sVar1 | uVar5;
        pBVar3->pxNextFreeBlock = (A_BLOCK_LINK *)0x0;
        xTaskResumeAll();
        if (pAVar4 != (A_BLOCK_LINK *)0x0) {
          return pAVar4;
        }
        goto LAB_230359be;
      }
    }
  }
  xTaskResumeAll();
LAB_230359be:
  vApplicationMallocFailedHook();
  return (void *)0x0;
}



longlong aos_now_ms(void)

{
  BaseType_t BVar1;
  longlong in_fa0;
  TickType_t TStack24;
  TickType_t ticks;
  BaseType_t overflow_count;
  
  TStack24 = 0;
  ticks = 0;
  BVar1 = xTaskGetTickCount2(&TStack24,(BaseType_t *)&ticks);
  if (BVar1 != 1) {
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  return in_fa0;
}



int event_poll(file_t *f,_Bool setup,poll_notify_t *notify,pollfd *fd,void *opa)

{
  aos_mutex_t *mutex;
  undefined3 in_register_0000202d;
  
  mutex = (aos_mutex_t *)f->f_arg;
  aos_mutex_lock(mutex,0xffffffff);
  if (CONCAT31(in_register_0000202d,setup) == 0) {
    mutex[1].hdl = (void *)0x0;
    mutex[3].hdl = (void *)0x0;
  }
  else {
    *(poll_notify_t **)&mutex[1].hdl = notify;
    *(pollfd **)&mutex[2].hdl = fd;
    mutex[3].hdl = opa;
    if (mutex[4].hdl != (void *)0x0) {
      fd->revents = fd->revents | 1;
      (*notify)(fd,opa);
    }
  }
  aos_mutex_unlock(mutex);
  return 0;
}



int event_open(inode_t *node,file_t *file)

{
  aos_mutex_t *mutex;
  
  mutex = (aos_mutex_t *)aos_malloc(0x28);
  memset(mutex,0,0x28);
  aos_mutex_new(mutex);
  *(aos_mutex_t **)&mutex[5].hdl = mutex + 5;
  *(aos_mutex_t **)&mutex[6].hdl = mutex + 5;
  *(aos_mutex_t **)&mutex[8].hdl = mutex + 8;
  *(aos_mutex_t **)&mutex[9].hdl = mutex + 8;
  *(aos_mutex_t **)&file->f_arg = mutex;
  return 0;
}



ssize_t _event_write(void *buf,size_t len,_Bool urgent)

{
  int *piVar1;
  undefined3 in_register_00002031;
  int in_a3;
  int iVar2;
  int *piVar3;
  int **ppiVar4;
  size_t __n;
  
  __n = CONCAT31(in_register_00002031,urgent);
  aos_mutex_lock((aos_mutex_t *)buf,0xffffffff);
  if ((*(int *)((int)buf + 0x1c) < 1) || (piVar1 = *(int **)((int)buf + 0x24), __n != piVar1[2])) {
    piVar1 = (int *)aos_malloc(__n + 0xc);
    if (piVar1 == (int *)0x0) {
      __n = 0xffffffff;
      goto out;
    }
  }
  else {
    piVar3 = (int *)piVar1[1];
    iVar2 = *piVar1;
    *(int **)(iVar2 + 4) = piVar3;
    *piVar3 = iVar2;
    *(int *)((int)buf + 0x1c) = *(int *)((int)buf + 0x1c) + -1;
  }
  *(int *)((int)buf + 0x10) = *(int *)((int)buf + 0x10) + 1;
  piVar1[2] = __n;
  memcpy(piVar1 + 3,(void *)len,__n);
  if (in_a3 == 0) {
    iVar2 = *(int *)((int)buf + 0x14);
    piVar1[1] = (int)buf + 0x14;
    *piVar1 = iVar2;
    *(int **)(iVar2 + 4) = piVar1;
    *(int **)((int)buf + 0x14) = piVar1;
  }
  else {
    ppiVar4 = *(int ***)((int)buf + 0x18);
    *piVar1 = (int)buf + 0x14;
    *(int ***)(piVar1 + 1) = ppiVar4;
    *(int **)((int)buf + 0x18) = piVar1;
    *ppiVar4 = piVar1;
  }
  if (*(int *)((int)buf + 4) != 0) {
    *(ushort *)(*(int *)((int)buf + 8) + 6) = *(ushort *)(*(int *)((int)buf + 8) + 6) | 1;
    (**(code **)((int)buf + 4))
              (*(undefined4 *)((int)buf + 8),*(undefined4 *)((int)buf + 0xc),
               *(code **)((int)buf + 4));
  }
out:
  aos_mutex_unlock((aos_mutex_t *)buf);
  return __n;
}



int event_ioctl(file_t *f,int cmd,ulong arg)

{
  ssize_t sVar1;
  
  if (((cmd & 0xfU) != 1) && ((cmd & 0xfU) != 2)) {
    return -1;
  }
  sVar1 = _event_write(f->f_arg,arg,SUB41(cmd >> 4,0));
  return sVar1;
}



ssize_t event_write(file_t *f,void *buf,size_t len)

{
  ssize_t sVar1;
  
  sVar1 = _event_write(f->f_arg,(size_t)buf,SUB41(len,0));
  return sVar1;
}



int event_close(file_t *file)

{
  aos_mutex_t *mutex;
  aos_mutex_t *pv;
  void *pvVar1;
  void **ppvVar2;
  
  mutex = (aos_mutex_t *)file->f_arg;
  aos_mutex_free(mutex);
  while (pv = (aos_mutex_t *)mutex[6].hdl, pv != mutex + 5) {
    pvVar1 = pv->hdl;
    ppvVar2 = (void **)pv[1].hdl;
    *(void ***)((int)pvVar1 + 4) = ppvVar2;
    *ppvVar2 = pvVar1;
    aos_free(pv);
  }
  while (pv = (aos_mutex_t *)mutex[9].hdl, pv != mutex + 8) {
    pvVar1 = pv->hdl;
    ppvVar2 = (void **)pv[1].hdl;
    *(void ***)((int)pvVar1 + 4) = ppvVar2;
    *ppvVar2 = pvVar1;
    aos_free(pv);
  }
  aos_free(mutex);
  return 0;
}



// WARNING: Type propagation algorithm not settling

ssize_t event_read(file_t *f,void *buf,size_t len)

{
  aos_mutex_t *mutex;
  void *pv;
  int iVar1;
  int *piVar2;
  void **ppvVar3;
  uint __n;
  
  mutex = (aos_mutex_t *)f->f_arg;
  __n = (uint)mutex[4].hdl;
  if (__n != 0) {
    aos_mutex_lock(mutex,0xffffffff);
    pv = mutex[6].hdl;
    iVar1 = *(int *)pv;
    piVar2 = *(int **)((int)pv + 4);
    *(int **)(iVar1 + 4) = piVar2;
    *piVar2 = iVar1;
    __n = *(uint *)((int)pv + 8);
    if (len < *(uint *)((int)pv + 8)) {
      __n = len;
    }
    memcpy(buf,(void *)((int)pv + 0xc),__n);
    if ((int)mutex[7].hdl < 4) {
      ppvVar3 = (void **)mutex[9].hdl;
      *(aos_mutex_t **)pv = mutex + 8;
      *(void ***)((int)pv + 4) = ppvVar3;
      mutex[9].hdl = pv;
      *ppvVar3 = pv;
      mutex[7].hdl = (void *)((int)mutex[7].hdl + 1);
    }
    else {
      aos_free(pv);
    }
    mutex[4].hdl = (void *)((int)mutex[4].hdl + -1);
    aos_mutex_unlock(mutex);
  }
  return __n;
}



int vfs_device_init(void)

{
  int iVar1;
  
  iVar1 = 0;
  if ((inited != 1) &&
     (iVar1 = aos_register_driver("/dev/event",(file_ops_t *)&event_fops,(void *)0x0), iVar1 == 0))
  {
    inited = 1;
  }
  return iVar1;
}



// WARNING: Could not reconcile some variable overlaps

void event_read_cb(int fd,void *param)

{
  dlist_s *pdVar1;
  ssize_t sVar2;
  undefined auStack32 [4];
  input_event_t event;
  
  sVar2 = aos_read(fd,auStack32,0x10);
  if (sVar2 == 0x10) {
    pdVar1 = g_local_event_list.next;
    if ((short)event.time == 0x100) {
      (*event._4_4_)(event.value,event._4_4_);
    }
    else {
      while (pdVar1 != (dlist_s *)&g_local_event_list) {
        if ((*(short *)&((dlist_t *)pdVar1)[2].prev == 0) ||
           ((short)event.time == *(short *)&((dlist_t *)pdVar1)[2].prev)) {
          (*(code *)((dlist_t *)pdVar1)[1].prev)
                    (auStack32,((dlist_t *)pdVar1)[1].next,((dlist_t *)pdVar1)[1].prev);
        }
        pdVar1 = ((dlist_t *)pdVar1)->next;
      }
    }
  }
  return;
}



int aos_event_service_init(void)

{
  int sock;
  
  sock = aos_open("/dev/event",0);
  if (local_event.fd < 0) {
    local_event.fd = sock;
  }
  aos_poll_read_fd(sock,event_read_cb,(void *)0x0);
  aos_loop_set_eventfd(sock);
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

int aos_post_event(uint16_t type,uint16_t code,ulong value)

{
  undefined2 in_register_0000202a;
  int iVar1;
  undefined4 local_20;
  input_event_t event;
  
  event.time._0_2_ = (ushort)((CONCAT22(in_register_0000202a,type) << 0x11) >> 0x11);
  local_20 = 0;
  event.value = 0;
  event.time._2_2_ = code;
  event._4_4_ = value;
  iVar1 = aos_ioctl(local_event.fd,(CONCAT22(in_register_0000202a,type) >> 0xf) + 0x101,
                    (ulong)&local_20);
  return iVar1;
}



int aos_register_event_filter(uint16_t type,aos_event_cb *cb,void *priv)

{
  dlist_s *pdVar1;
  int iVar2;
  
  if (cb != (aos_event_cb *)0x0) {
    pdVar1 = (dlist_s *)aos_malloc(0x14);
    iVar2 = -0xc;
    if (pdVar1 != (dlist_s *)0x0) {
      *(aos_event_cb **)&pdVar1[1].prev = cb;
      *(uint16_t *)&pdVar1[2].prev = type;
      pdVar1->prev = g_local_event_list.prev;
      pdVar1[1].next = priv;
      *(dlist_t **)&pdVar1->next = &g_local_event_list;
      (g_local_event_list.prev)->next = pdVar1;
      iVar2 = 0;
      g_local_event_list.prev = pdVar1;
    }
    return iVar2;
  }
  return -0x16;
}



size_t format_int(char *q,size_t n,uint flags,int base,int width,int prec)

{
  char "0123456789abcdef" [17];
  char "0123456789ABCDEF" [17];
  int iVar1;
  uint uVar2;
  uint uVar3;
  char cVar4;
  uint uVar5;
  uint uVar6;
  int in_a6;
  int in_a7;
  int iVar7;
  int iVar8;
  uint uVar9;
  char *pcVar10;
  int iVar11;
  char *pcStack84;
  
  if ((width & 0x80U) == 0) {
    pcStack84 = "0123456789abcdef";
  }
  else {
    pcStack84 = "0123456789ABCDEF";
  }
  uVar9 = 0;
  if (((width & 0x40U) != 0) && (base < 0)) {
    flags = -flags;
    base = -(uint)(flags != 0) - base;
    uVar9 = 1;
  }
  iVar7 = 0;
  uVar2 = flags;
  uVar6 = base;
  while ((uVar2 | uVar6) != 0) {
    __udivdi3();
    iVar7 = iVar7 + 1;
  }
  uVar2 = width & 0x20;
  if ((uVar2 == 0) || (prec != 8)) {
LAB_23002cf4:
    if ((in_a7 <= iVar7) && (in_a7 = iVar7, (flags | base) == 0)) {
      in_a7 = 1;
    }
  }
  else {
    if (in_a7 <= iVar7) {
      in_a7 = iVar7 + 1;
      goto LAB_23002cf4;
    }
  }
  iVar7 = in_a7;
  if (((width & 8U) != 0) && (iVar7 = 4, prec != 0x10)) {
    iVar7 = 3;
  }
  iVar8 = (in_a7 + -1) / iVar7 + in_a7;
  iVar1 = (uint)((width & 0x14U | uVar9) != 0) + iVar8;
  if ((uVar2 != 0) && (prec == 0x10)) {
    iVar1 = iVar1 + 2;
  }
  uVar3 = width & 3;
  uVar6 = 0;
  if ((uVar3 == 0) && (uVar6 = uVar3, iVar1 < in_a6)) {
    uVar6 = in_a6 - iVar1;
    uVar5 = 0;
    do {
      if (uVar5 < n) {
        *q = ' ';
        q = q + 1;
      }
      uVar5 = uVar5 + 1;
      in_a6 = iVar1;
    } while (uVar5 != uVar6);
  }
  if (uVar9 == 0) {
    if ((width & 4U) == 0) {
      if ((width & 0x10U) == 0) goto LAB_23002d76;
      if (uVar6 < n) {
        *q = ' ';
        q = q + 1;
      }
    }
    else {
      if (uVar6 < n) {
        *q = '+';
        q = q + 1;
      }
    }
  }
  else {
    if (uVar6 < n) {
      *q = '-';
      q = q + 1;
    }
  }
  uVar6 = uVar6 + 1;
LAB_23002d76:
  if ((uVar2 != 0) && (prec == 0x10)) {
    if (uVar6 < n) {
      *q = '0';
      q = q + 1;
    }
    if (uVar6 + 1 < n) {
      cVar4 = 'X';
      if ((width & 0x80U) == 0) {
        cVar4 = 'x';
      }
      *q = cVar4;
      q = q + 1;
    }
    uVar6 = uVar6 + 2;
  }
  if ((uVar3 == 1) && (iVar8 < in_a6)) {
    while (iVar1 < in_a6) {
      if (uVar6 < n) {
        *q = '0';
        q = q + 1;
      }
      uVar6 = uVar6 + 1;
      in_a6 = in_a6 + -1;
    }
  }
  uVar6 = iVar8 + uVar6;
  q = q + iVar8;
  pcVar10 = q;
  uVar9 = uVar6;
  iVar11 = iVar7;
  while (0 < iVar8) {
    if (iVar11 == 0) {
      uVar9 = uVar9 - 1;
      if (uVar9 < n) {
        pcVar10[-1] = '_';
      }
      pcVar10 = pcVar10 + -1;
      iVar8 = iVar8 + -1;
      iVar11 = iVar7;
    }
    iVar11 = iVar11 + -1;
    uVar9 = uVar9 - 1;
    iVar8 = iVar8 + -1;
    if (uVar9 < n) {
      uVar2 = flags;
      __umoddi3();
      pcVar10[-1] = pcStack84[uVar2];
    }
    __udivdi3();
    pcVar10 = pcVar10 + -1;
  }
  iVar7 = in_a6 + uVar6;
  while (((width & 2U) != 0 && (iVar1 < (int)(iVar7 - uVar6)))) {
    if (uVar6 < n) {
      *q = ' ';
      q = q + 1;
    }
    uVar6 = uVar6 + 1;
  }
  return uVar6;
}



char * cvt(int ndigits,int *decpt,int *sign,char *buf,int eflag)

{
  int *piVar1;
  byte *pbVar2;
  __gcc_CMPtype _Var3;
  double *__iptr;
  SItype SVar4;
  byte *in_a5;
  byte *pbVar5;
  int in_a6;
  byte *pbVar6;
  byte *pbVar7;
  double in_fa1;
  double *pdStack80;
  double fi;
  double fj;
  
  piVar1 = (int *)0x4e;
  if (((int)sign < 0x4f) && (piVar1 = sign, (int)sign < 0)) {
    piVar1 = (int *)0x0;
  }
  _Var3 = __ledf2();
  if (_Var3 < 0) {
    *(undefined4 *)eflag = 1;
  }
  else {
    *(undefined4 *)eflag = 0;
  }
  modf(in_fa1,(double *)ndigits);
  pbVar6 = in_a5 + 0x50;
  _Var3 = __eqdf2();
  pbVar2 = pbVar6;
  pbVar5 = in_a5;
  if (_Var3 == 0) {
    _Var3 = __gedf2();
    pbVar7 = (byte *)0x0;
    if (0 < _Var3) {
      while( true ) {
        __iptr = (double *)ndigits;
        __muldf3();
        _Var3 = __ledf2();
        if (-1 < _Var3) break;
        pbVar7 = pbVar7 + -1;
        ndigits = (int)__iptr;
      }
    }
  }
  else {
    while( true ) {
      _Var3 = __eqdf2();
      pbVar7 = pbVar6 + -(int)pbVar2;
      if (_Var3 == 0) break;
      __iptr = pdStack80;
      __divdf3();
      modf(in_fa1,__iptr);
      __adddf3();
      __muldf3();
      SVar4 = __fixdfsi();
      pbVar2[-1] = (char)SVar4 + 0x30;
      pbVar2 = pbVar2 + -1;
    }
    while (pbVar2 < pbVar6) {
      *pbVar5 = *pbVar2;
      pbVar5 = pbVar5 + 1;
      pbVar2 = pbVar2 + 1;
    }
  }
  pbVar2 = (byte *)((int)piVar1 + (int)in_a5);
  if (in_a6 == 0) {
    pbVar2 = pbVar2 + (int)pbVar7;
  }
  *(byte **)buf = pbVar7;
  if (pbVar2 < in_a5) {
    *in_a5 = 0;
  }
  else {
    while ((pbVar5 <= pbVar2 && (pbVar5 < pbVar6))) {
      __muldf3();
      modf(in_fa1,(double *)ndigits);
      SVar4 = __fixdfsi();
      *pbVar5 = (char)SVar4 + 0x30;
      pbVar5 = pbVar5 + 1;
    }
    if (pbVar2 < pbVar6) {
      *pbVar2 = *pbVar2 + 5;
      pbVar5 = pbVar2;
      while (0x39 < *pbVar5) {
        *pbVar5 = 0x30;
        if (in_a5 < pbVar5) {
          pbVar6 = pbVar5 + -1;
          pbVar5 = pbVar5 + -1;
          *pbVar5 = *pbVar6 + 1;
        }
        else {
          *pbVar5 = 0x31;
          *(int *)buf = *(int *)buf + 1;
          if (in_a6 == 0) {
            if (in_a5 < pbVar2) {
              *pbVar2 = 0x30;
            }
            pbVar2 = pbVar2 + 1;
          }
        }
      }
      *pbVar2 = 0;
    }
    else {
      in_a5[0x4f] = 0;
    }
  }
  return (char *)in_a5;
}



char * ecvtbuf(int ndigits,int *decpt,int *sign,char *buf)

{
  char *pcVar1;
  int in_a4;
  
  pcVar1 = cvt(ndigits,decpt,sign,buf,in_a4);
  return pcVar1;
}



char * fcvtbuf(int ndigits,int *decpt,int *sign,char *buf)

{
  char *pcVar1;
  int in_a4;
  
  pcVar1 = cvt(ndigits,decpt,sign,buf,in_a4);
  return pcVar1;
}



char * flt(char *str,int size,int precision,char fmt,int flags)

{
  bool bVar1;
  byte bVar2;
  int iVar3;
  __gcc_CMPtype _Var4;
  char *pcVar5;
  undefined *puVar6;
  size_t sVar7;
  int *sign_00;
  undefined3 in_register_00002035;
  char *pcVar8;
  int *piVar9;
  uint uVar10;
  int *__string;
  char cVar11;
  uint in_a5;
  uint uVar12;
  char *pcVar13;
  int iVar14;
  uint in_a6;
  char cVar15;
  char cVar16;
  char *pcVar17;
  char *pcStack232;
  int decpt;
  int sign;
  char tmp [80];
  char cvtbuf [80];
  
  iVar3 = CONCAT31(in_register_00002035,fmt);
  uVar12 = in_a6 & 0x10;
  if (uVar12 == 0) {
    cVar16 = '0';
    if ((in_a6 & 1) == 0) {
      cVar16 = ' ';
    }
  }
  else {
    in_a6 = in_a6 & 0xfffffffe;
    cVar16 = ' ';
  }
  cVar15 = '\0';
  if ((in_a6 & 2) != 0) {
    _Var4 = __ledf2();
    if (_Var4 < 0) {
      precision = precision ^ 0x80000000;
      iVar3 = iVar3 + -1;
      cVar15 = '-';
    }
    else {
      if ((in_a6 & 4) == 0) {
        if ((in_a6 & 8) != 0) {
          iVar3 = iVar3 + -1;
          cVar15 = ' ';
        }
      }
      else {
        iVar3 = iVar3 + -1;
        cVar15 = '+';
      }
    }
  }
  if (flags < 0) {
    flags = 6;
  }
  bVar1 = (in_a5 & 0xfd) != 0x45;
  uVar10 = in_a5;
  if (!bVar1) {
    uVar10 = in_a5 + 0x20 & 0xff;
  }
  if (uVar10 == 0x67) {
    ecvtbuf(size,(int *)precision,(int *)flags,(char *)&pcStack232);
    if ((-5 < (int)(pcStack232 + -1)) && ((int)(pcStack232 + -1) < flags)) {
      sign_00 = (int *)(flags - (int)pcStack232);
LAB_230032d2:
      pcVar5 = fcvtbuf(size,(int *)precision,sign_00,(char *)&pcStack232);
      __string = &sign;
      if (decpt != 0) {
        sign._0_1_ = 0x2d;
        __string = (int *)((int)&sign + 1);
      }
      if (*pcVar5 == '\0') {
        *(char *)__string = '0';
        if ((int)sign_00 < 1) {
          __string = (int *)((int)__string + 1);
        }
        else {
          *(char *)((int)__string + 1) = '.';
          pcVar5 = (char *)((int)__string + 2);
          piVar9 = (int *)((int)__string + (int)sign_00);
          do {
            *(char *)((int)__string + 2) = '0';
            __string = (int *)((int)__string + 1);
          } while (piVar9 != __string);
          __string = (int *)(pcVar5 + (int)sign_00);
        }
      }
      else {
        pcVar17 = pcVar5;
        if ((int)pcStack232 < 1) {
          *(char *)__string = '0';
          *(char *)((int)__string + 1) = '.';
          sign_00 = __string;
          while ((int *)((int)__string - (int)pcStack232) != sign_00) {
            *(char *)((int)sign_00 + 2) = '0';
            sign_00 = (int *)((int)sign_00 + 1);
          }
          __string = (int *)((int)__string + (2 - (int)pcStack232));
          while (cVar11 = *pcVar5, cVar11 != '\0') {
            pcVar5 = pcVar5 + 1;
            *(char *)__string = cVar11;
            __string = (int *)((int)__string + 1);
          }
        }
        else {
          do {
            sign_00 = __string;
            if (pcStack232 == pcVar17 + -(int)pcVar5) {
              sign_00 = (int *)((int)__string + 1);
              *(char *)__string = '.';
            }
            pcVar8 = pcVar17 + 1;
            __string = (int *)((int)sign_00 + 1);
            *(char *)sign_00 = *pcVar17;
            pcVar17 = pcVar8;
          } while (*pcVar8 != '\0');
        }
      }
      goto LAB_2300327a;
    }
    __string = (int *)(flags + -1);
  }
  else {
    __string = (int *)flags;
    if (uVar10 != 0x65) {
      __string = &sign;
      sign_00 = (int *)flags;
      if (uVar10 != 0x66) goto LAB_2300327a;
      goto LAB_230032d2;
    }
  }
  pcVar5 = ecvtbuf(size,(int *)precision,(int *)((int)__string + 1),(char *)&pcStack232);
  sign_00 = &sign;
  if (decpt != 0) {
    sign._0_1_ = 0x2d;
    sign_00 = (int *)((int)&sign + 1);
  }
  pcVar17 = (char *)((int)sign_00 + 1);
  *(char *)sign_00 = *pcVar5;
  if (0 < (int)__string) {
    pcVar17 = (char *)((int)sign_00 + 2);
    *(undefined *)((int)sign_00 + 1) = 0x2e;
  }
  pcVar8 = pcVar5 + 1;
  pcVar13 = pcVar17;
  while (pcVar5 + 1 + (int)__string != pcVar8) {
    *pcVar13 = *pcVar8;
    pcVar8 = pcVar8 + 1;
    pcVar13 = pcVar13 + 1;
  }
  pcVar17 = pcVar17 + (int)__string;
  cVar11 = 'E';
  if (bVar1) {
    cVar11 = 'e';
  }
  *pcVar17 = cVar11;
  if (pcStack232 == (char *)0x0) {
    _Var4 = __eqdf2();
    if (_Var4 != 0) {
      pcStack232 = (char *)0xffffffff;
      goto LAB_23003238;
    }
LAB_2300335e:
    cVar11 = '+';
  }
  else {
    pcStack232 = pcStack232 + -1;
    if (-1 < (int)pcStack232) goto LAB_2300335e;
LAB_23003238:
    pcStack232 = (char *)-(int)pcStack232;
    cVar11 = '-';
  }
  pcVar17[1] = cVar11;
  pcVar17[4] = (char)((int)pcStack232 % 10) + '0';
  pcVar17[2] = (char)(((int)pcStack232 / 100) % 10) + '0';
  pcVar17[3] = (char)(((int)pcStack232 / 10) % 10) + '0';
  __string = (int *)(pcVar17 + 5);
LAB_2300327a:
  *(char *)__string = '\0';
  if ((in_a6 & 0x20) == 0) {
    if (in_a5 == 0x67) {
      __string = &sign;
      do {
        bVar2 = *(byte *)__string;
        __string = (int *)((int)__string + 1);
        if (bVar2 == 0) goto LAB_23003412;
      } while (bVar2 != 0x2e);
      while ((sign_00 = __string, *(byte *)__string != 0 && ((*(byte *)__string & 0xdf) != 0x45))) {
        __string = (int *)((int)__string + 1);
      }
      do {
        piVar9 = sign_00;
        sign_00 = (int *)((int)piVar9 + -1);
      } while (*(byte *)sign_00 == 0x30);
      if (*(byte *)sign_00 == 0x2e) {
        sign_00 = (int *)((int)piVar9 + -2);
      }
      while (__string != sign_00) {
        sign_00 = (int *)((int)sign_00 + 1);
        *(byte *)sign_00 = 0;
      }
    }
  }
  else {
    if ((int *)flags == (int *)0x0) {
      __string = &sign;
      while (bVar2 = *(byte *)__string, bVar2 != 0) {
        if (bVar2 == 0x2e) goto LAB_23003412;
        if ((bVar2 & 0xdf) == 0x45) {
          sVar7 = strnlen((char *)__string,0x100);
          puVar6 = (undefined *)(sVar7 + (int)__string);
          while (0 < (int)(puVar6 + -(int)__string)) {
            puVar6[1] = *puVar6;
            puVar6 = puVar6 + -1;
          }
          *(byte *)__string = 0x2e;
          goto LAB_23003412;
        }
        __string = (int *)((int)__string + 1);
      }
      *(byte *)__string = 0x2e;
      *(byte *)((int)__string + 1) = 0;
    }
  }
LAB_23003412:
  sVar7 = strnlen((char *)&sign,0x100);
  iVar3 = iVar3 - sVar7;
  pcVar5 = str;
  if ((in_a6 & 0x11) == 0) {
    while (0 < (int)(str + (iVar3 - (int)pcVar5))) {
      *pcVar5 = ' ';
      pcVar5 = pcVar5 + 1;
    }
    iVar14 = iVar3;
    if (iVar3 < 0) {
      iVar14 = 0;
    }
    str = str + iVar14;
    iVar3 = (iVar3 + -1) - iVar14;
  }
  if (cVar15 != '\0') {
    *str = cVar15;
    str = str + 1;
  }
  pcVar5 = str;
  if (uVar12 == 0) {
    while (0 < (int)(str + (iVar3 - (int)pcVar5))) {
      *pcVar5 = cVar16;
      pcVar5 = pcVar5 + 1;
    }
    iVar14 = iVar3;
    if (iVar3 < 0) {
      iVar14 = 0;
    }
    str = str + iVar14;
    iVar3 = (iVar3 + -1) - iVar14;
  }
  iVar14 = 0;
  while (iVar14 < (int)sVar7) {
    pcVar5 = (char *)((int)&sign + iVar14);
    pcVar17 = str + iVar14;
    iVar14 = iVar14 + 1;
    *pcVar17 = *pcVar5;
  }
  if ((int)sVar7 < 0) {
    sVar7 = 0;
  }
  str = str + sVar7;
  pcVar5 = str;
  while (0 < (int)(str + (iVar3 - (int)pcVar5))) {
    *pcVar5 = ' ';
    pcVar5 = pcVar5 + 1;
  }
  if (iVar3 < 0) {
    iVar3 = 0;
  }
  return str + iVar3;
}



int vsnprintf(char *buffer,size_t n,char *format,va_list ap)

{
  char *pcVar1;
  size_t n_00;
  byte *pbVar2;
  int *piVar3;
  undefined4 uVar4;
  char *pcVar5;
  byte bVar6;
  uint uVar7;
  char **ppcVar8;
  int prec;
  char *pcVar9;
  char *pcVar10;
  int iVar11;
  uint width;
  char *flags;
  byte *str;
  char *pcVar12;
  char *pcStack104;
  char *pcStack100;
  char *pcStack88;
  char acStack65 [4];
  char carg;
  
  uVar4 = 0;
  width = 0;
  flags = (char *)0xffffffff;
  iVar11 = 0;
  pcStack104 = (char *)0x0;
  pcStack100 = (char *)0x0;
  pcVar5 = (char *)0x0;
  str = (byte *)buffer;
  pcVar12 = (char *)0x0;
switchD_230035c2_caseD_5:
  do {
    pbVar2 = (byte *)format;
    format = (char *)(pbVar2 + 1);
    bVar6 = *pbVar2;
    uVar7 = (uint)bVar6;
    if (bVar6 == 0) {
      if (pcVar5 < n) {
        *str = 0;
      }
      else {
        if (n != 0) {
          buffer[n - 1] = '\0';
        }
      }
      return (int)pcVar5;
    }
    switch(uVar4) {
    case 0:
      if (bVar6 == 0x25) {
        uVar4 = 1;
        width = 0;
        flags = (char *)0xffffffff;
        iVar11 = 0;
        pcVar12 = (char *)0x0;
      }
      else {
        if (pcVar5 < n) {
          *str = bVar6;
          str = str + 1;
        }
        pcVar5 = pcVar5 + 1;
      }
      break;
    case 1:
      switch(uVar7 - 0x20 & 0xff) {
      case 0:
        width = width | 0x10;
        break;
      default:
        uVar4 = 2;
        format = (char *)pbVar2;
        break;
      case 3:
        width = width | 0x20;
        break;
      case 7:
        width = width | 8;
        break;
      case 0xb:
        width = width | 4;
        break;
      case 0xd:
        width = width | 2;
        break;
      case 0x10:
        width = width | 1;
      }
      break;
    case 2:
      if ((uVar7 - 0x30 & 0xff) < 10) {
        pcVar12 = (char *)((int)pcVar12 * 10 + (uVar7 - 0x30));
      }
      else {
        if (bVar6 == 0x2a) {
          ppcVar8 = (char **)ap + 1;
          pcVar12 = *(char **)ap;
          ap = ppcVar8;
          if ((int)pcVar12 < 0) {
            width = width | 2;
            pcVar12 = (char *)-(int)pcVar12;
          }
        }
        else {
          if (bVar6 == 0x2e) {
            uVar4 = 3;
            flags = (char *)0x0;
          }
          else {
            uVar4 = 4;
            format = (char *)pbVar2;
          }
        }
      }
      break;
    case 3:
      if ((uVar7 - 0x30 & 0xff) < 10) {
        flags = (char *)((int)flags * 10 + (uVar7 - 0x30));
      }
      else {
        if (bVar6 == 0x2a) {
          ppcVar8 = (char **)ap + 1;
          flags = *(char **)ap;
          ap = ppcVar8;
          if ((int)flags < 0) {
            flags = (char *)0xffffffff;
          }
        }
        else {
          uVar4 = 4;
          format = (char *)pbVar2;
        }
      }
      break;
    case 4:
      switch(uVar7 - 0x4c & 0xff) {
      case 0:
      case 0x25:
        iVar11 = iVar11 + 2;
        break;
      default:
        if (2 < iVar11) {
          iVar11 = 2;
        }
        if (iVar11 < -2) {
          iVar11 = -2;
        }
        switch(uVar7 - 0x50 & 0xff) {
        case 0:
          width = width | 0x80;
          goto switchD_2300371e_caseD_20;
        default:
          if (pcVar5 < n) {
            *str = bVar6;
            str = str + 1;
          }
          uVar4 = 0;
          pcVar5 = pcVar5 + 1;
          goto switchD_230035c2_caseD_5;
        case 8:
          width = width | 0x80;
          prec = 0x10;
          break;
        case 0x13:
          acStack65[0] = (char)*(char **)ap;
          pcVar1 = (char *)0x1;
          pcStack88 = acStack65;
          goto is_string;
        case 0x14:
        case 0x19:
          width = width | 0x40;
                    // WARNING: Could not find normalized switch variable to match jumptable
          switch(iVar11) {
          case -2:
            pcStack104 = (char *)(int)*(char *)ap;
            pcStack100 = (char *)((int)pcStack104 >> 0x1f);
            ap = (char **)ap + 1;
            prec = 10;
            break;
          case 0:
            pcStack104 = *(char **)ap;
            pcStack100 = (char *)((int)pcStack104 >> 0x1f);
            ap = (char **)ap + 1;
            prec = 10;
            break;
          case 2:
            ppcVar8 = (char **)((int)ap + 7U & 0xfffffff8);
            ap = ppcVar8 + 2;
            pcStack104 = *ppcVar8;
            pcStack100 = ppcVar8[1];
            prec = 10;
            break;
          default:
            prec = 10;
          }
          goto is_integer;
        case 0x16:
          piVar3 = (int *)((int)ap + 7U & 0xfffffff8);
          str = (byte *)flt((char *)str,*piVar3,piVar3[1],(char)pcVar12,(int)flags);
          uVar4 = 0;
          ap = piVar3 + 2;
          goto switchD_230035c2_caseD_5;
        case 0x1e:
          if (iVar11 + 2U < 5) {
                    // WARNING: Could not recover jumptable at 0x2300392e. Too many branches
                    // WARNING: Treating indirect jump as call
            iVar11 = (*(code *)(&PTR_LAB_2306f398)[iVar11 + 2U])((&PTR_LAB_2306f398)[iVar11 + 2U]);
            return iVar11;
          }
          uVar4 = 0;
          goto switchD_230035c2_caseD_5;
        case 0x1f:
          prec = 8;
          break;
        case 0x20:
switchD_2300371e_caseD_20:
          width = width | 0x20;
          pcStack104 = *(char **)ap;
          pcStack100 = (char *)0x0;
          ap = (char **)ap + 1;
          prec = 0x10;
          flags = &DAT_00000008;
          goto is_integer;
        case 0x23:
          pcStack88 = *(char **)ap;
          if (pcStack88 == (char *)0x0) {
            pcStack88 = "(null)";
          }
          pcVar1 = (char *)strlen(pcStack88);
is_string:
          ap = (char **)ap + 1;
          if ((flags != (char *)0xffffffff) && ((int)flags < (int)pcVar1)) {
            pcVar1 = flags;
          }
          pcVar9 = pcVar5;
          if (((int)pcVar1 < (int)pcVar12) && ((width & 2) == 0)) {
            if ((width & 1) == 0) {
              bVar6 = 0x20;
            }
            else {
              bVar6 = 0x30;
            }
            pcVar9 = pcVar12 + (int)(pcVar5 + -(int)pcVar1);
            do {
              if (pcVar5 < n) {
                *str = bVar6;
                str = str + 1;
              }
              pcVar5 = pcVar5 + 1;
              pcVar12 = pcVar1;
            } while (pcVar5 != pcVar9);
          }
          pcVar5 = pcVar9;
          if (pcVar1 != (char *)0x0) {
            pcVar10 = pcVar9;
            do {
              if (pcVar10 < n) {
                *str = pcStack88[(int)(pcVar10 + -(int)pcVar9)];
                str = str + 1;
              }
              pcVar10 = pcVar10 + 1;
              pcVar5 = pcVar1 + (int)pcVar9;
            } while (pcVar10 != pcVar1 + (int)pcVar9);
          }
          if ((int)pcVar1 < (int)pcVar12) {
            if ((width & 2) == 0) {
              uVar4 = 0;
            }
            else {
              pcVar9 = pcVar5 + -(int)pcVar1;
              do {
                if (pcVar5 < n) {
                  *str = 0x20;
                  str = str + 1;
                }
                pcVar5 = pcVar5 + 1;
              } while (pcVar5 != pcVar12 + (int)pcVar9);
              uVar4 = 0;
              pcVar5 = pcVar12 + (int)pcVar9;
              pcVar12 = pcVar1;
            }
          }
          else {
            uVar4 = 0;
          }
          goto switchD_230035c2_caseD_5;
        case 0x25:
          prec = 10;
          break;
        case 0x28:
          prec = 0x10;
        }
                    // WARNING: Could not find normalized switch variable to match jumptable
        switch(iVar11) {
        case -2:
          pcStack104 = (char *)(uint)*(byte *)ap;
          pcStack100 = (char *)0x0;
          ap = (char **)ap + 1;
          break;
        case 0:
          pcStack104 = *(char **)ap;
          pcStack100 = (char *)0x0;
          ap = (char **)ap + 1;
          break;
        case 2:
          ppcVar8 = (char **)((int)ap + 7U & 0xfffffff8);
          ap = ppcVar8 + 2;
          pcStack104 = *ppcVar8;
          pcStack100 = ppcVar8[1];
        }
is_integer:
        if (pcVar5 < n) {
          n_00 = n - (int)pcVar5;
        }
        else {
          n_00 = 0;
        }
        n_00 = format_int((char *)str,n_00,(uint)pcStack104,(int)pcStack100,width,prec);
        str = str + n_00;
        uVar4 = 0;
        pcVar5 = pcVar5 + n_00;
        break;
      case 0x1c:
        iVar11 = iVar11 + -1;
        break;
      case 0x1e:
        iVar11 = 2;
        break;
      case 0x20:
        iVar11 = iVar11 + 1;
        break;
      case 0x28:
      case 0x2e:
        iVar11 = 1;
      }
    }
  } while( true );
}



int vsprintf(char *buffer,char *format,va_list ap)

{
  int iVar1;
  
  iVar1 = vsnprintf(buffer,0x1e0,format,ap);
  return iVar1;
}



void vprint(char *fmt,va_list argp)

{
  uint8_t *puVar1;
  int iVar2;
  
  if (sys_log_all_enable == false) {
    return;
  }
  iVar2 = vsprintf(string,fmt,argp);
  puVar1 = (uint8_t *)string;
  if (0 < iVar2) {
    while( true ) {
      if (*puVar1 == '\0') break;
      bl_uart_data_send('\0',*puVar1);
      puVar1 = puVar1 + 1;
    }
  }
  return;
}



int bl_putchar(int c)

{
  bl_uart_data_send('\0',(uint8_t)c);
  return 0;
}



int puts(char *s)

{
  int iVar1;
  
  iVar1 = 0;
  if (sys_log_all_enable != false) {
    iVar1 = 0;
    while (s[iVar1] != '\0') {
      bl_uart_data_send('\0',s[iVar1]);
      iVar1 = iVar1 + 1;
    }
  }
  return iVar1;
}



int printf(char *fmt,...)

{
  undefined4 in_a1;
  undefined4 in_a2;
  undefined4 in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list argp;
  undefined4 uStack28;
  undefined4 uStack24;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  undefined4 uStack8;
  undefined4 uStack4;
  
  if (sys_log_all_enable != false) {
    uStack28 = in_a1;
    uStack24 = in_a2;
    uStack20 = in_a3;
    uStack16 = in_a4;
    uStack12 = in_a5;
    uStack8 = in_a6;
    uStack4 = in_a7;
    vprint(fmt,&uStack28);
  }
  return 0;
}



int sprintf(char *buffer,char *format,...)

{
  int iVar1;
  undefined4 in_a2;
  undefined4 in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list ap;
  undefined4 uStack24;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  undefined4 uStack8;
  undefined4 uStack4;
  
  uStack24 = in_a2;
  uStack20 = in_a3;
  uStack16 = in_a4;
  uStack12 = in_a5;
  uStack8 = in_a6;
  uStack4 = in_a7;
  iVar1 = vsnprintf(buffer,0xffffffff,format,&uStack24);
  return iVar1;
}



int snprintf(char *buffer,size_t n,char *format,...)

{
  int iVar1;
  undefined4 in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list ap;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  undefined4 uStack8;
  undefined4 uStack4;
  
  uStack20 = in_a3;
  uStack16 = in_a4;
  uStack12 = in_a5;
  uStack8 = in_a6;
  uStack4 = in_a7;
  iVar1 = vsnprintf(buffer,n,format,&uStack20);
  return iVar1;
}



_Bool stateSnifferGuard(void *ch,event *event)

{
  return (_Bool)(ch == (void *)(uint)*(byte *)event->data);
}



_Bool stateConnectedIPYesGuard_ip_update(void *ch,event *event)

{
  return (_Bool)(ch == (void *)(uint)*(byte *)event->data);
}



void printErrMsg(void *stateData,event *event)

{
  printf("ENTERED ERROR STATE!");
  return;
}



void stateSnifferExit(void *stateData,event *event)

{
  printf("[WF][SM] Exiting %s state\r\n",stateData);
  return;
}



void stateSnifferAction(void *oldStateData,event *event,void *newStateData)

{
  printf("[WF][SM] State Action ###%s### --->>> ###%s###\r\n",oldStateData);
  return;
}



void stateConnectedIPNoAction_ipgot(void *oldStateData,event *event,void *newStateData)

{
  uint *puVar1;
  uint *puVar2;
  uint uVar3;
  uint uVar4;
  
  puVar1 = (uint *)((int)event->data + 0xd);
  puVar2 = (uint *)((int)event->data + 0x11);
  uVar4 = *puVar1;
  uVar3 = *puVar2;
  printf(
         "[WF][SM] IP GOT IP:%u.%u.%u.%u, MASK: %u.%u.%u.%u, Gateway: %u.%u.%u.%u, dns1: %u.%u.%u.%u, dns2: %u.%u.%u.%u\r\n"
         ,uVar4 & 0xff,uVar4 >> 8 & 0xff,(uint)(*(uint3 *)puVar1 >> 0x10),uVar4 >> 0x18,uVar3 & 0xff
         ,uVar3 >> 8 & 0xff,(uint)(*(uint3 *)puVar2 >> 0x10));
  printf("[WF][SM] State Action ###%s### --->>> ###%s###\r\n",oldStateData,newStateData);
  return;
}



void stateGlobalEnter(void *stateData,event *event)

{
  printf("[WF][SM] Entering %s state\r\n",stateData);
  return;
}



void stateGlobalAction(void *oldStateData,event *event,void *newStateData)

{
  printf("[WF][SM] Global Action\r\n");
  return;
}



void stateConnectingEnter(void *stateData,event *event)

{
  printf("[WF][SM] Entering %s state\r\n",stateData);
  aos_post_event(2,8,0);
  return;
}



_Bool stateSnifferGuard_ChannelSet(void *ch,event *event)

{
  byte *pbVar1;
  
  pbVar1 = (byte *)event->data;
  if (ch == (void *)(uint)*pbVar1) {
    bl_main_monitor_channel_set(*(int *)(pbVar1 + 1),*(int *)(pbVar1 + 5));
    return false;
  }
  return false;
}



_Bool stateIdleGuard_sniffer(void *ev,event *event)

{
  if (ev == (void *)(uint)*(byte *)event->data) {
    bl_main_monitor();
    return true;
  }
  return false;
}



void stateConnectedIPNoExit(void *stateData,event *event)

{
  printf("[WF][SM] Exiting %s state\r\n",stateData);
  xTimerGenericCommand((TimerHandle_t)((int)stateData + 0x20),3,0,(BaseType_t *)0x0,0);
  xTimerGenericCommand((TimerHandle_t)((int)stateData + 0x20),5,0,(BaseType_t *)0x0,0);
  return;
}



void stateDisconnect_action_idle(void *oldStateData,event *event,void *newStateData)

{
  printf("[WF][SM] State Action ###%s### --->>> ###%s###\r\n",oldStateData);
  printf("[WF][SM] Removing STA interface...\r\n");
  bl_main_if_remove(wifiMgmr.wlan_sta.vif_index);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void stateDisconnect_action_reconnect(void *oldStateData,event *event,void *newStateData)

{
  printf("[WF][SM] State Action ###%s### --->>> ###%s###\r\n",oldStateData);
  printf("[WF][SM]  Action Connect\r\n");
  printf("           ssid %s\r\n",(uint8_t *)((int)oldStateData + 0x4d));
  printf("           ssid len %u\r\n",*(undefined4 *)((int)oldStateData + 0x6e));
  printf("           psk %s\r\n",(uint8_t *)((int)oldStateData + 0x72));
  printf("           psk len %u\r\n",*(undefined4 *)((int)oldStateData + 0xf4));
  printf("           pmk %s\r\n",(uint8_t *)((int)oldStateData + 0xb3));
  printf("           pmk len %u\r\n",*(undefined4 *)((int)oldStateData + 0xf8));
  printf("           mac %02X:%02X:%02X:%02X:%02X:%02X\r\n",
         (uint)*(byte *)((int)oldStateData + 0x101),(uint)*(byte *)((int)oldStateData + 0x100),
         (uint)*(byte *)((int)oldStateData + 0xff),(uint)*(byte *)((int)oldStateData + 0xfe),
         (uint)*(byte *)((int)oldStateData + 0xfd),(uint)*(byte *)((int)oldStateData + 0xfc));
  bl_main_connect((uint8_t *)((int)oldStateData + 0x4d),*(int *)((int)oldStateData + 0x6e),
                  (uint8_t *)((int)oldStateData + 0x72),*(int *)((int)oldStateData + 0xf4),
                  (uint8_t *)((int)oldStateData + 0xb3),*(int *)((int)oldStateData + 0xf8),
                  (uint8_t *)((int)oldStateData + 0xfc),'\0',_DAT_00000010);
  aos_post_event(2,3,0);
  return;
}



void ip_obtaining_timeout(timer_cb_arg_t data)

{
  pvTimerGetTimerID((TimerHandle_t)data);
  printf("[WF][SM] IP obtaining timeout\r\n");
  wifi_mgmr_api_fw_disconnect();
  return;
}



void stateConnectedIPNoEnter(void *stateData,event *event)

{
  uint32_t uVar1;
  uint32_t uVar2;
  uint32_t uVar3;
  uint32_t uVar4;
  uint32_t uVar5;
  TickType_t xOptionalValue;
  ip4_addr_t iStack44;
  ip4_addr_t addr_ipaddr;
  ip4_addr_t addr_netmask;
  ip4_addr_t addr_gw;
  
  printf("[WF][SM] Entering %s state\r\n",stateData);
  xTimerCreateStatic("wifi IP obtaining",15000,0,stateData,ip_obtaining_timeout,
                     (StaticTimer_t *)(TimerHandle_t)((int)stateData + 0x20));
  xOptionalValue = xTaskGetTickCount();
  xTimerGenericCommand
            ((TimerHandle_t)((int)stateData + 0x20),1,xOptionalValue,(BaseType_t *)0x0,0xffffffff);
  vTaskEnterCritical();
  uVar5 = wifiMgmr.wlan_sta.ipv4.dns2;
  uVar4 = wifiMgmr.wlan_sta.ipv4.dns1;
  uVar3 = wifiMgmr.wlan_sta.ipv4.gw;
  uVar2 = wifiMgmr.wlan_sta.ipv4.mask;
  uVar1 = wifiMgmr.wlan_sta.ipv4.ip;
  vTaskExitCritical();
  if (uVar1 == 0) {
    printf("[WF][SM] DHCP Starting...%p\r\n",0x42016fc8);
    wifi_netif_dhcp_start(&wifiMgmr.wlan_sta.netif);
  }
  else {
    printf("[WF][SM] Static IP Starting...%p\r\n",0x42016fc8);
    iStack44 = (ip_addr_t)uVar4;
    dns_setserver('\0',(ip_addr_t *)&iStack44);
    iStack44 = (ip_addr_t)uVar5;
    dns_setserver('\x01',(ip_addr_t *)&iStack44);
    iStack44 = (ip_addr_t)uVar1;
    addr_ipaddr = uVar2;
    addr_netmask = uVar3;
    netifapi_netif_common(&wifiMgmr.wlan_sta.netif,dhcp_stop,(netifapi_errt_fn)0x0);
    netifapi_netif_set_addr(&wifiMgmr.wlan_sta.netif,&iStack44,&addr_ipaddr,&addr_netmask);
  }
  aos_post_event(2,4,0);
  return;
}



_Bool stateConnectedIPNoGuard_disconnect(void *ch,event *event)

{
  if (ch == (void *)(uint)*(byte *)event->data) {
    bl_main_disconnect();
    return false;
  }
  return false;
}



_Bool stateConnectedIPYesGuard_disconnect(void *ch,event *event)

{
  if (ch == (void *)(uint)*(byte *)event->data) {
    bl_main_disconnect();
    return false;
  }
  return false;
}



_Bool stateConnectedIPYesGuard_rcconfig(void *ch,event *event)

{
  byte *pbVar1;
  
  pbVar1 = (byte *)event->data;
  if (ch == (void *)(uint)*pbVar1) {
    printf("[WF][SM] rate config, use sta_idx 0, rate_config %04X\r\n",*(undefined4 *)(pbVar1 + 1));
    bl_main_rate_config('\0',*(uint16_t *)(pbVar1 + 1));
  }
  return false;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void stateIdleAction_connect(void *oldStateData,event *event,void *newStateData)

{
  void *pvVar1;
  wifi_mgmr_profile_msg_t *profile_msg;
  char *pcVar2;
  
  pvVar1 = event->data;
  *(undefined *)((int)pvVar1 + 0x2d) = 0;
  *(undefined *)((int)pvVar1 + 0x72) = 0;
  printf("[WF][SM] Action Connect\r\n");
  profile_msg = (wifi_mgmr_profile_msg_t *)((int)pvVar1 + 0xd);
  printf("           ssid %s\r\n",profile_msg);
  printf("           ssid len %u\r\n",*(undefined4 *)((int)pvVar1 + 0x2e));
  printf("           psk %s\r\n",(uint8_t *)((int)pvVar1 + 0x32));
  printf("           psk len %u\r\n",*(undefined4 *)((int)pvVar1 + 0xb4));
  printf("           pmk %s\r\n",(uint8_t *)((int)pvVar1 + 0x73));
  printf("           pmk len %u\r\n",*(undefined4 *)((int)pvVar1 + 0xb8));
  printf("           channel band %d\r\n",(uint)*(byte *)((int)pvVar1 + 0xc2));
  printf("           channel freq %d\r\n",(uint)*(ushort *)((int)pvVar1 + 0xc3));
  printf("           mac %02X:%02X:%02X:%02X:%02X:%02X\r\n",(uint)*(byte *)((int)pvVar1 + 0xc1),
         (uint)*(byte *)((int)pvVar1 + 0xc0),(uint)*(byte *)((int)pvVar1 + 0xbf),
         (uint)*(byte *)((int)pvVar1 + 0xbe),(uint)*(byte *)((int)pvVar1 + 0xbd),
         (uint)*(byte *)((int)pvVar1 + 0xbc));
  if (*(char *)((int)pvVar1 + 0xc5) == '\0') {
    pcVar2 = "false";
  }
  else {
    pcVar2 = "true";
  }
  printf("           dhcp status: %s\r\n",pcVar2);
  wifi_mgmr_profile_add(&wifiMgmr,profile_msg,-1);
  printf("[WF][SM] State Action ###%s### --->>> ###%s###\r\n",oldStateData,newStateData);
  bl_main_connect((uint8_t *)profile_msg,*(int *)((int)pvVar1 + 0x2e),
                  (uint8_t *)((int)pvVar1 + 0x32),*(int *)((int)pvVar1 + 0xb4),
                  (uint8_t *)((int)pvVar1 + 0x73),*(int *)((int)pvVar1 + 0xb8),
                  (uint8_t *)((int)pvVar1 + 0xbc),*(uint8_t *)((int)pvVar1 + 0xc2),_DAT_00000010);
  return;
}



_Bool stateGlobal_cfg_req(void *ch,event *event)

{
  char *pcVar1;
  
  pcVar1 = (char *)event->data;
  if (*pcVar1 == '\x16') {
    bl_main_cfg_task_req
              (*(uint32_t *)(pcVar1 + 0xd),*(uint32_t *)(pcVar1 + 0x11),*(uint32_t *)(pcVar1 + 0x15)
               ,*(uint32_t *)(pcVar1 + 0x19),pcVar1 + 0x21,(void *)0x0);
    return false;
  }
  return false;
}



_Bool stateGlobalGuard_fw_powersaving(void *ch,event *event)

{
  char *pcVar1;
  
  pcVar1 = (char *)event->data;
  if (*pcVar1 == '\x10') {
    printf("------>>>>>> Powersaving CMD, mode: %u\r\n",*(undefined4 *)(pcVar1 + 1));
    bl_main_powersaving(*(int *)(pcVar1 + 1));
  }
  return false;
}



_Bool stateGlobalGuard_conf_max_sta(void *ev,event *event)

{
  char *pcVar1;
  
  pcVar1 = (char *)event->data;
  if (*pcVar1 == '\n') {
    printf("[WF][SM] Conf max sta supported %lu...\r\n",*(undefined4 *)(pcVar1 + 1));
    bl_main_conf_max_sta(pcVar1[1]);
  }
  return false;
}



_Bool stateGlobalGuard_AP(void *ev,event *event)

{
  char "stateGlobalGuard_AP" [20];
  char *pcVar1;
  int iVar2;
  
  pcVar1 = (char *)event->data;
  if (*pcVar1 == '\b') {
    iVar2 = bl_main_if_add(0,&wifiMgmr.wlan_ap.netif,&wifiMgmr.wlan_ap.vif_index);
    if (iVar2 == 0) {
      netifapi_netif_common(&wifiMgmr.wlan_ap.netif,netif_set_link_up,(netifapi_errt_fn)0x0);
      netifapi_netif_common(&wifiMgmr.wlan_ap.netif,dhcpd_start,(netifapi_errt_fn)0x0);
      printf("[WF][SM] start AP with ssid %s;\r\n",pcVar1 + 0x11);
      printf("[WF][SM]               pwd  %s;\r\n",pcVar1 + 0x37);
      printf("[WF][SM]               channel  %ld;\r\n",*(undefined4 *)(pcVar1 + 0xd));
      bl_main_apm_start(pcVar1 + 0x11,pcVar1 + 0x37,*(int *)(pcVar1 + 0xd),
                        wifiMgmr.wlan_ap.vif_index,pcVar1[0x32]);
      wifiMgmr.inf_ap_enabled = 1;
      dns_server_init();
      aos_post_event(2,0xb,0);
    }
    else {
      printf("[WF][SM] %s: add AP iface failed\r\n","stateGlobalGuard_AP");
    }
  }
  return false;
}



_Bool stateGlobalGuard_scan_beacon(void *ch,event *event)

{
  byte bVar1;
  bool bVar2;
  byte *pbVar3;
  int iVar4;
  int iVar5;
  TickType_t TVar6;
  size_t sVar7;
  int iVar8;
  int iVar9;
  TickType_t TVar10;
  uint32_t uVar11;
  wifi_mgmr_t *pwVar12;
  int iVar13;
  wifi_mgmr_scan_item_t *__s;
  uint32_t uVar14;
  
  pbVar3 = (byte *)event->data;
  if (ch == (void *)(uint)*pbVar3) {
    pwVar12 = &wifiMgmr;
    if ((((int)(uint)pbVar3[0x3b] <= wifiMgmr.channel_nums) && (pbVar3[0x3b] != 0)) &&
       ((pbVar3[0xd] != 0 || ((wifiMgmr.features & 1) != 0)))) {
      TVar6 = xTaskGetTickCount();
      bVar2 = false;
      uVar14 = 0xffffffff;
      iVar4 = -1;
      iVar13 = 0;
      iVar9 = -1;
      do {
        iVar5 = iVar13;
        if (wifiMgmr.channel_nums < (int)(uint)pwVar12->scan_items[0].channel) {
          memset(pwVar12->scan_items,0,0x3c);
          pwVar12->scan_items[0].is_used = '\0';
        }
        else {
          if (pwVar12->scan_items[0].is_used != '\0') {
            uVar11 = pwVar12->scan_items[0].timestamp_lastseen;
            if ((!bVar2) || ((int)(uVar11 - uVar14) < 0)) {
              iVar4 = iVar13;
              uVar14 = uVar11;
            }
            iVar8 = memcmp(pwVar12->scan_items[0].bssid,pbVar3 + 0x35,6);
            iVar5 = iVar9;
            bVar2 = true;
            if ((iVar8 == 0) &&
               (iVar9 = strcmp((char *)(pbVar3 + 0xd),(char *)pwVar12->scan_items), bVar2 = true,
               iVar9 == 0)) {
              if (((char)pbVar3[0x3c] < wifiMgmr.scan_items[iVar13].rssi) &&
                 (TVar10 = xTaskGetTickCount(),
                 (int)(TVar10 - wifiMgmr.scan_items[iVar13].timestamp_lastseen) < 3000)) {
                return false;
              }
              wifiMgmr.scan_items[iVar13].channel = pbVar3[0x3b];
              wifiMgmr.scan_items[iVar13].rssi = pbVar3[0x3c];
              wifiMgmr.scan_items[iVar13].ppm_abs = pbVar3[0x3d];
              bVar1 = pbVar3[0x3e];
              wifiMgmr.scan_items[iVar13].timestamp_lastseen = TVar6;
              wifiMgmr.scan_items[iVar13].ppm_rel = bVar1;
              wifiMgmr.scan_items[iVar13].auth = pbVar3[0x3f];
              wifiMgmr.scan_items[iVar13].cipher = pbVar3[0x40];
              return false;
            }
          }
        }
        iVar13 = iVar13 + 1;
        pwVar12 = (wifi_mgmr_t *)&(pwVar12->wlan_sta).netif.input;
        iVar9 = iVar5;
      } while (iVar13 != 0x32);
      if ((iVar5 != -1) || (iVar5 = iVar4, iVar4 != -1)) {
        __s = wifiMgmr.scan_items + iVar5;
        memset(__s,0,0x3c);
        strncpy((char *)__s,(char *)(pbVar3 + 0xd),0x20);
        wifiMgmr.scan_items[iVar5].ssid_tail[0] = '\0';
        sVar7 = strlen((char *)__s);
        wifiMgmr.scan_items[iVar5].ssid_len = sVar7;
        memcpy(wifiMgmr.scan_items[iVar5].bssid,pbVar3 + 0x35,6);
        wifiMgmr.scan_items[iVar5].channel = pbVar3[0x3b];
        bVar1 = pbVar3[0x3c];
        wifiMgmr.scan_items[iVar5].timestamp_lastseen = TVar6;
        wifiMgmr.scan_items[iVar5].rssi = bVar1;
        wifiMgmr.scan_items[iVar5].auth = pbVar3[0x3f];
        wifiMgmr.scan_items[iVar5].cipher = pbVar3[0x40];
        wifiMgmr.scan_items[iVar5].is_used = '\x01';
      }
    }
  }
  return false;
}



void __reload_tsen(timer_cb_arg_t data)

{
  pvTimerGetTimerID((TimerHandle_t)data);
  wifi_mgmr_api_fw_tsen_reload();
  return;
}



void event_cb_wifi_event_mgmr(input_event_t *event,void *private_data)

{
  if (event->code == 0x14) {
    aos_post_delayed_action(0x55,trigger_auto_denoise,(void *)0x0);
    return;
  }
  return;
}



void trigger_auto_denoise(void *arg)

{
  if (auto_repeat != 0) {
    wifi_mgmr_api_denoise_enable();
    aos_post_delayed_action(0x55,trigger_auto_denoise,(void *)0x0);
    return;
  }
  return;
}



void stateDisconnect_exit(void *stateData,event *event)

{
  printf("[WF][SM] Exiting %s state\r\n",stateData);
  if (*(char *)((int)stateData + 0x4c) != '\0') {
    printf("Delete Timer.\r\n");
    xTimerGenericCommand((TimerHandle_t)((int)stateData + 0x20),3,0,(BaseType_t *)0x0,0);
    xTimerGenericCommand((TimerHandle_t)((int)stateData + 0x20),5,0,(BaseType_t *)0x0,0);
    *(undefined *)((int)stateData + 0x4c) = 0;
    return;
  }
  printf("Delete Timer Skipped\r\n");
  return;
}



void disconnect_retry(timer_cb_arg_t data)

{
  void *pvVar1;
  int iVar2;
  
  pvVar1 = pvTimerGetTimerID((TimerHandle_t)data);
  iVar2 = wifi_mgmr_profile_get(&wifiMgmr,(wifi_mgmr_profile_msg_t *)((int)pvVar1 + 0x4d));
  if (iVar2 != 0) {
    printf("[WF][SM] Retry Again --->>> retry Abort, since profile copy failed\r\n");
    return;
  }
  printf("[WF][SM] Retry Again --->>> retry connect\r\n");
  wifi_mgmr_api_reconnect();
  return;
}



_Bool stateGlobalGuard_fw_disconnect(void *ch,event *event)

{
  if (*(char *)event->data == '\x0f') {
    printf("Disconnect CMD\r\n");
    bl_main_disconnect();
    return false;
  }
  return false;
}



void stateConnectedIPYes_exit(void *stateData,event *event)

{
  ip4_addr_t iStack20;
  ip4_addr_t addr_ipaddr;
  
  iStack20 = (ip4_addr_t)0x0;
  printf("[WF][SM] Exiting %s state\r\n",stateData);
  netifapi_netif_common(&wifiMgmr.wlan_sta.netif,dhcp_stop,(netifapi_errt_fn)0x0);
  netifapi_netif_set_addr(&wifiMgmr.wlan_sta.netif,&iStack20,&iStack20,&iStack20);
  if (auto_repeat != 0) {
    auto_repeat = 0;
    bl_main_denoise(0);
  }
  return;
}



_Bool stateGlobalGuard_denoise(void *ev,event *event)

{
  int mode;
  
  if (*(char *)event->data != '\f') {
    return false;
  }
  if (*(int *)(event->data + 1) == 0) {
    auto_repeat = 0;
    mode = 0;
  }
  else {
    if (wifiMgmr.m.currentState != &stateConnectedIPYes) {
      return false;
    }
    mode = 3;
    if (auto_repeat == 0) {
      auto_repeat = 1;
      bl_main_denoise(1);
      aos_post_event(2,0x14,0);
      return false;
    }
  }
  bl_main_denoise(mode);
  return false;
}



_Bool stateIdleGuard_connect(void *ev,event *event)

{
  int iVar1;
  
  if (ev == (void *)(uint)*(byte *)event->data) {
    iVar1 = bl_main_if_add(1,&wifiMgmr.wlan_sta.netif,&wifiMgmr.wlan_sta.vif_index);
    if (iVar1 != 0) {
      printf("[WF][SM] %s: add STA iface failed\r\n","stateIdleGuard_connect");
    }
    return (_Bool)(iVar1 == 0);
  }
  return false;
}



_Bool stateIfaceDownGuard_phyup(void *ev,event *event)

{
  bool bVar1;
  int iVar2;
  
  if (ev == (void *)(uint)*(byte *)event->data) {
    iVar2 = bl_main_phy_up();
    bVar1 = iVar2 == 0;
  }
  else {
    printf("[WF][SM] state mismatch\r\n");
    bVar1 = false;
  }
  return (_Bool)bVar1;
}



_Bool stateSnifferGuard_raw_send(void *ch,event *event)

{
  char *pcVar1;
  
  if (((wifiMgmr.m.currentState != &stateIdle) && (wifiMgmr.m.currentState != &stateIfaceDown)) &&
     (pcVar1 = (char *)event->data, *pcVar1 == '\x15')) {
    bl_main_raw_send(*(uint8_t **)(pcVar1 + 1),*(int *)(pcVar1 + 5));
    return false;
  }
  return false;
}



_Bool stateGlobalGuard_stop(void *ev,event *event)

{
  if (*(char *)event->data == '\t') {
    printf("[WF][SM] Stoping AP interface...\r\n");
    bl_main_apm_stop(wifiMgmr.wlan_ap.vif_index);
    printf("[WF][SM] Removing and deauth all sta client...\r\n");
    bl_main_apm_remove_all_sta();
    printf("[WF][SM] Removing AP interface...\r\n");
    bl_main_if_remove(wifiMgmr.wlan_ap.vif_index);
    printf("[WF][SM] Stopping DHCP on AP interface...\r\n");
    netifapi_netif_common(&wifiMgmr.wlan_ap.netif,(netifapi_void_fn)0x0,dhcp_server_stop);
    printf("[WF][SM] Removing ETH interface ...\r\n");
    netifapi_netif_common(&wifiMgmr.wlan_ap.netif,netif_remove,(netifapi_errt_fn)0x0);
    wifiMgmr.inf_ap_enabled = 0;
    aos_post_event(2,0xc,0);
    return false;
  }
  return false;
}



_Bool stateGlobalGuard_enable_autoreconnect(void *ch,event *event)

{
  if (ch == (void *)(uint)*(byte *)event->data) {
    printf("Enable Auto Reconnect\r\n");
    wifi_mgmr_profile_autoreconnect_enable(&wifiMgmr,-1);
    return false;
  }
  return false;
}



_Bool stateGlobalGuard_disable_autoreconnect(void *ch,event *event)

{
  bool bVar1;
  
  if (ch == (void *)(uint)*(byte *)event->data) {
    bVar1 = wifiMgmr.m.currentState != &stateDisconnect;
    if (bVar1) {
      printf("Disable Auto Reconnect\r\n");
      wifi_mgmr_profile_autoreconnect_disable(&wifiMgmr,-1);
    }
    else {
      printf("Disable Autoreconnect in Disconnec State\r\n");
      printf("[WF][SM] Removing STA interface...\r\n");
      bl_main_if_remove(wifiMgmr.wlan_sta.vif_index);
    }
    return (_Bool)!bVar1;
  }
  return false;
}



// WARNING: Variable defined which should be unmapped: is_ok

void stateDisconnect_enter(void *stateData,event *event)

{
  int iVar1;
  TickType_t xOptionalValue;
  uint uVar2;
  uint uStack20;
  int is_ok;
  
  uStack20 = 0;
  printf("[WF][SM] Entering %s state\r\n",stateData);
  iVar1 = wifi_mgmr_profile_autoreconnect_is_enabled(&wifiMgmr,-1);
  if (iVar1 == 0) {
    printf("[WF][SM] Will NOT retry connect\r\n");
  }
  else {
    xTimerCreateStatic("wifi disconnect",2000,0,stateData,disconnect_retry,
                       (StaticTimer_t *)(TimerHandle_t)((int)stateData + 0x20));
    printf("[WF][SM] Will retry in 2000 ticks\r\n");
    xOptionalValue = xTaskGetTickCount();
    xTimerGenericCommand
              ((TimerHandle_t)((int)stateData + 0x20),1,xOptionalValue,(BaseType_t *)0x0,0xffffffff)
    ;
    *(undefined *)((int)stateData + 0x4c) = 1;
  }
  aos_post_event(2,5,(uint)wifiMgmr.wifi_mgmr_stat_info.status_code);
  uVar2 = bl60x_check_mac_status((int *)&uStack20);
  if ((uVar2 | uStack20) == 0) {
    aos_post_event(2,0x17,0);
    helper_record_dump();
  }
  if ((wifiMgmr.pending_task & 1) != 0) {
    printf("[WF][SM] Pending Scan Sent\r\n");
    bl_main_scan();
    wifiMgmr.pending_task = wifiMgmr.pending_task & 0xfffffffe;
  }
  return;
}



_Bool stateGlobalGuard_fw_scan(void *ch,event *event)

{
  if (*(char *)event->data == '\x12') {
    if (((wifiMgmr.m.currentState == &stateConnecting) ||
        (wifiMgmr.m.currentState == &stateConnectedIPNo)) ||
       (wifiMgmr.m.currentState == &stateDisconnect)) {
      printf("------>>>>>> Scan CMD Pending\r\n");
      wifiMgmr.pending_task = wifiMgmr.pending_task | 1;
    }
    else {
      if (((wifiMgmr.m.currentState == &stateIdle) ||
          (wifiMgmr.m.currentState == &stateConnectedIPYes)) ||
         (wifiMgmr.m.currentState == &stateSniffer)) {
        printf("------>>>>>> Scan CMD\r\n");
        bl_main_scan();
      }
      else {
        printf("------>>>>>> FW busy\r\n");
        aos_post_event(2,9,1);
      }
    }
    return false;
  }
  return false;
}



uint stateDisconnect_guard(uint param_1,int param_2)

{
  return (uint)(param_1 == (uint)**(byte **)(param_2 + 4));
}



void stateGlobalExit(void)

{
  printf("[WF][SM] Entering %s state\r\n");
  return;
}



void stateSnifferEnter(void)

{
  printf("[WF][SM] Entering %s state\r\n");
  return;
}



uint stateConnectingGuard(uint param_1,int param_2)

{
  return (uint)(param_1 == (uint)**(byte **)(param_2 + 4));
}



void stateConnectingAction_connected(void)

{
  printf("[WF][SM] State Action ###%s### --->>> ###%s###\r\n");
  return;
}



void stateConnectingAction_disconnect(void)

{
  printf("[WF][SM] State Action ###%s### --->>> ###%s###\r\n");
  return;
}



void stateConnectingExit(void)

{
  printf("[WF][SM] Exiting %s state\r\n");
  return;
}



void stateIdleAction_sniffer(void)

{
  printf("[WF][SM] State Action ###%s### --->>> ###%s###\r\n");
  return;
}



void stateIdleEnter(void)

{
  printf("[WF][SM] Entering %s state\r\n");
  return;
}



void stateIdleExit(void)

{
  printf("[WF][SM] Entering %s state\r\n");
  return;
}



void stateIfaceDownAction_phyup(void)

{
  printf("[WF][SM] State Action ###%s### --->>> ###%s###\r\n");
  return;
}



void stateIfaceDownEnter(void)

{
  printf("[WF][SM] Entering %s state\r\n");
  return;
}



void stateIfaceDownExit(void)

{
  printf("[WF][SM] Exiting %s state\r\n");
  return;
}



uint stateConnectedIPNoGuard(uint param_1,int param_2)

{
  return (uint)(param_1 == (uint)**(byte **)(param_2 + 4));
}



void stateConnectedIPNoAction_disconnect(void)

{
  printf("[WF][SM] State Action ###%s### --->>> ###%s###\r\n");
  return;
}



uint stateConnectedIPYesGuard(uint param_1,int param_2)

{
  return (uint)(param_1 == (uint)**(byte **)(param_2 + 4));
}



void stateConnectedIPYes_action(void)

{
  printf("[WF][SM] State Action ###%s### --->>> ###%s###\r\n");
  return;
}



void stateConnectedIPYes_enter(void *stateData,event *event)

{
  printf("[WF][SM] Entering %s state\r\n",stateData);
  aos_post_event(2,7,0);
  if ((wifiMgmr.pending_task & 1) != 0) {
    printf("[WF][SM] Pending Scan Sent\r\n");
    bl_main_scan();
    wifiMgmr.pending_task = wifiMgmr.pending_task & 0xfffffffe;
  }
  return;
}



char * wifi_mgmr_auth_to_str(uint8_t auth)

{
  undefined3 in_register_00002029;
  
  switch(CONCAT31(in_register_00002029,auth)) {
  case 0:
    return "Open";
  case 1:
    return "WEP";
  case 2:
    return "WPA-PSK";
  case 3:
    return "WPA2-PSK";
  case 4:
    return "WPA2-PSK/WPA-PSK";
  case 5:
    return "WPA/WPA2-Enterprise";
  default:
    return "Unknown";
  }
}



char * wifi_mgmr_cipher_to_str(uint8_t cipher)

{
  undefined3 in_register_00002029;
  int iVar1;
  
  iVar1 = CONCAT31(in_register_00002029,cipher);
  if (iVar1 == 0) {
    return "NONE";
  }
  if (iVar1 == 1) {
    return "WEP";
  }
  if (iVar1 == 2) {
    return "AES";
  }
  if (iVar1 != 3) {
    if (iVar1 != 4) {
      return "Unknown";
    }
    return "TKIP/AES";
  }
  return "TKIP";
}



int wifi_mgmr_event_notify(wifi_mgmr_msg_t *msg)

{
  size_t sVar1;
  int iVar2;
  
  while (wifiMgmr.ready == '\0') {
    printf("Wait Wi-Fi Mgmr Start up...\r\n");
    vTaskDelay(0x14);
  }
  sVar1 = xStreamBufferSend((StreamBufferHandle_t)&wifiMgmr.mq,msg,msg->len,0xffffffff);
  iVar2 = 0;
  if (sVar1 == 0) {
    printf("Failed when send msg 0x%p, len dec:%u\r\n",msg,msg->len);
    iVar2 = -1;
  }
  return iVar2;
}



// WARNING: Could not reconcile some variable overlaps

void wifi_mgmr_start(void)

{
  TickType_t xOptionalValue;
  size_t sVar1;
  void *pvRxData;
  int16_t iStack274;
  int16_t temp;
  int iStack272;
  event ev;
  uint8_t buffer [232];
  
  pvRxData = (void *)((int)&ev.data + 1);
  iStack272 = 1;
  ev.type = (int)pvRxData;
  stateM_init(&wifiMgmr.m,&stateIfaceDown,&stateError);
  wifi_mgmr_event_init();
  aos_register_event_filter(2,event_cb_wifi_event_mgmr,(void *)0x0);
  aos_post_event(2,2,0);
  hal_sys_capcode_update(-1,-1);
  printf("[WF][SM] reload tsen \r\n");
  xTimerCreateStatic("wifi reload tsen",10000,1,&state_tsen_reload_data,__reload_tsen,
                     (StaticTimer_t *)&state_tsen_reload_data.timer);
  xOptionalValue = xTaskGetTickCount();
  xTimerGenericCommand
            ((TimerHandle_t)&state_tsen_reload_data.timer,1,xOptionalValue,(BaseType_t *)0x0,
             0xffffffff);
  do {
    while( true ) {
      do {
        sVar1 = xStreamBufferReceive((StreamBufferHandle_t)&wifiMgmr.mq,pvRxData,0xe0,0xffffffff);
      } while (sVar1 == 0);
      if (ev.data._1_1_ != 0xd) break;
      iStack274 = 0;
      if ((((wifiMgmr.m.currentState == &stateConnecting) ||
           (wifiMgmr.m.currentState == &stateDisconnect)) ||
          (wifiMgmr.m.currentState == &stateConnectedIPYes)) ||
         ((wifiMgmr.m.currentState == &stateSniffer ||
          (wifiMgmr.m.currentState == &stateConnectedIPNo)))) {
        bl_tsen_adc_get(&iStack274,0);
        phy_tcal_callback(iStack274);
      }
    }
    iStack272 = 1;
    if (0xd < ev.data._1_1_) {
      iStack272 = (uint)(0x16 < ev.data._1_1_) << 1;
    }
    stateM_handleEvent(&wifiMgmr.m,(event *)&stack0xfffffef0);
  } while( true );
}



void _wifi_mgmr_entry(void *pvParameters)

{
  wifi_conf_t *conf;
  TaskHandle_t aptStack36 [4];
  code *pcStack20;
  
  pcStack20 = wifi_mgmr_start_background;
  conf = (wifi_conf_t *)wifi_mgmr_start();
  wifi_mgmr_drv_init(conf);
  aptStack36[0] = (TaskHandle_t)0x0;
  xTaskCreate(_wifi_mgmr_entry,"wifi_mgmr",0x300,(void *)0x0,0x1c,aptStack36);
  return;
}



void wifi_mgmr_start_background(wifi_conf_t *conf)

{
  TaskHandle_t ptStack20;
  TaskHandle_t xHandle;
  
  wifi_mgmr_drv_init(conf);
  ptStack20 = (TaskHandle_t)0x0;
  xTaskCreate(_wifi_mgmr_entry,"wifi_mgmr",0x300,(void *)0x0,0x1c,&ptStack20);
  return;
}



int wifi_mgmr_init(void)

{
  StreamBufferHandle_t pSVar1;
  
  pSVar1 = xStreamBufferGenericCreateStatic
                     (0x8c0,0,1,wifiMgmr.mq_pool,(StaticStreamBuffer_t *)&wifiMgmr.mq);
  wifiMgmr.ready = '\x01';
  wifiMgmr.scan_item_timeout = 15000;
  return (uint)(pSVar1 == (StreamBufferHandle_t)0x0);
}



int wifi_mgmr_status_code_clean_internal(void)

{
  wifiMgmr.wifi_mgmr_stat_info.status_code = 0;
  return 0;
}



int wifi_mgmr_state_get_internal(int *state)

{
  uint16_t uVar1;
  int iVar2;
  
  uVar1 = wifiMgmr.wifi_mgmr_stat_info.status_code;
  if (wifiMgmr.m.currentState == &stateIdle) {
    if (wifiMgmr.inf_ap_enabled != 0) {
      iVar2 = 0x11;
      goto LAB_230051bc;
    }
    iVar2 = 1;
  }
  else {
    if (wifiMgmr.m.currentState == &stateConnecting) {
      if (wifiMgmr.inf_ap_enabled != 0) {
        iVar2 = 0x12;
        goto LAB_230051bc;
      }
      iVar2 = 2;
    }
    else {
      if (wifiMgmr.m.currentState == &stateConnectedIPNo) {
        if (wifiMgmr.inf_ap_enabled == 0) {
          iVar2 = 3;
        }
        else {
          iVar2 = 0x13;
        }
        goto LAB_230051bc;
      }
      if (wifiMgmr.m.currentState == &stateConnectedIPYes) {
        if (wifiMgmr.inf_ap_enabled == 0) {
          iVar2 = 4;
        }
        else {
          iVar2 = 0x14;
        }
        goto LAB_230051bc;
      }
      if (wifiMgmr.m.currentState != &stateDisconnect) {
        if (wifiMgmr.m.currentState == &stateIfaceDown) {
          iVar2 = 6;
        }
        else {
          if (wifiMgmr.m.currentState != &stateSniffer) {
            *state = 0;
            return 0;
          }
          iVar2 = 7;
        }
        goto LAB_230051bc;
      }
      if (wifiMgmr.inf_ap_enabled != 0) {
        iVar2 = 0x15;
        goto LAB_230051bc;
      }
      iVar2 = 5;
    }
  }
  *state = iVar2;
  if (uVar1 == 8) {
    iVar2 = 8;
  }
  else {
    if (uVar1 != 0xc) {
      return 0;
    }
    iVar2 = 9;
  }
LAB_230051bc:
  *state = iVar2;
  return 0;
}



void wifi_mgmr_set_connect_stat_info(wifi_event_sm_connect_ind *ind,uint8_t type_ind)

{
  uint8_t uVar1;
  uint8_t *puVar2;
  uint8_t *puVar3;
  
  wifiMgmr.wifi_mgmr_stat_info.status_code = ind->status_code;
  puVar2 = ind->bssid;
  puVar3 = wifiMgmr.wifi_mgmr_stat_info.bssid;
  do {
    uVar1 = *puVar2;
    puVar2 = puVar2 + 1;
    *puVar3 = uVar1;
    puVar3 = puVar3 + 1;
  } while (puVar2 != &ind->vif_idx);
  wifiMgmr.wifi_mgmr_stat_info.type_ind = type_ind;
  wifiMgmr.wifi_mgmr_stat_info.chan_freq = ind->center_freq;
  wifiMgmr.wifi_mgmr_stat_info.chan_band = ind->band;
  return;
}



int wifi_mgmr_set_country_code_internal(char *country_code)

{
  bl_main_set_country_code(country_code);
  strncpy(wifiMgmr.country_code,country_code,3);
  wifiMgmr.country_code[2] = '\0';
  wifiMgmr.channel_nums = bl_main_get_channel_nums();
  return 0;
}



int wifi_mgmr_ap_sta_cnt_get_internal(uint8_t *sta_cnt)

{
  bl_main_apm_sta_cnt_get(sta_cnt);
  return 0;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Could not reconcile some variable overlaps

int wifi_mgmr_ap_sta_info_get_internal(wifi_mgmr_sta_basic_info_t *sta_info_internal,uint8_t idx)

{
  undefined2 uStack40;
  wifi_apm_sta_info apm_sta_info;
  
  memset(&uStack40,0,0x18);
  bl_main_apm_sta_info_get((wifi_apm_sta_info *)&uStack40,idx);
  *(undefined2 *)sta_info_internal = uStack40;
  sta_info_internal->rssi = apm_sta_info.tsflo;
  sta_info_internal->tsflo = apm_sta_info.tsfhi;
  sta_info_internal->tsfhi = apm_sta_info.sta_mac._2_4_;
  sta_info_internal->data_rate = (uint8_t)apm_sta_info.rssi;
  memcpy(sta_info_internal->sta_mac,&uStack40 + 1,6);
  return 0;
}



int wifi_mgmr_ap_sta_delete_internal(uint8_t sta_idx)

{
  bl_main_apm_sta_delete(sta_idx);
  return 0;
}



int wifi_mgmr_scan_complete_notify(void)

{
  wifi_mgmr_scan_complete_callback();
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

int wifi_mgmr_api_connect(char *ssid,char *psk,char *pmk,uint8_t *mac,uint8_t band,uint16_t freq)

{
  size_t __n;
  int iVar1;
  undefined3 in_register_00002039;
  undefined2 in_register_0000203e;
  WIFI_MGMR_EVENT_T WStack232;
  undefined uStack231;
  undefined uStack230;
  undefined uStack229;
  uint8_t buffer [198];
  
  memset(&WStack232,0,0xc6);
  WStack232 = WIFI_MGMR_EVENT_APP_CONNECT;
  uStack231 = 0x44;
  uStack230 = 0x33;
  uStack229 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = -0x3a;
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  __n = strlen(ssid);
  buffer._42_2_ = (undefined2)__n;
  buffer._44_2_ = (undefined2)(__n >> 0x10);
  memcpy(buffer + 9,ssid,__n);
  buffer[41] = '\0';
  if (psk == (char *)0x0) {
    buffer._176_4_ = 0;
LAB_23005414:
    buffer[110] = '\0';
    if (pmk == (char *)0x0) {
      buffer._180_4_ = 0;
    }
    else {
      buffer._180_4_ = strlen(pmk);
      if (buffer._180_4_ != 0) {
        if (buffer._180_4_ != 0x40) goto LAB_23005472;
        memcpy(buffer + 0x6f,pmk,0x40);
      }
    }
    buffer[175] = '\0';
    if (mac != (uint8_t *)0x0) {
      memcpy(buffer + 0xb8,mac,6);
    }
    if (CONCAT22(in_register_0000203e,freq) != 0) {
      buffer[191] = (uint8_t)freq;
      buffer[192] = (uint8_t)(freq >> 8);
      buffer[190] = band;
      printf("wifi mgmr band:%d freq: %d\r\n",CONCAT31(in_register_00002039,band),
             CONCAT22(in_register_0000203e,freq));
    }
    buffer[193] = '\x01';
    wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&WStack232);
    iVar1 = 0;
  }
  else {
    buffer._176_4_ = strlen(psk);
    if (buffer._176_4_ < 0x41) {
      if (buffer._176_4_ != 0) {
        memcpy(buffer + 0x2e,psk,buffer._176_4_);
      }
      goto LAB_23005414;
    }
LAB_23005472:
    iVar1 = -1;
  }
  return iVar1;
}



int wifi_mgmr_api_cfg_req
              (uint32_t ops,uint32_t task,uint32_t element,uint32_t type,uint32_t length,
              uint32_t *buf)

{
  int iVar1;
  WIFI_MGMR_EVENT_T WStack100;
  undefined uStack99;
  undefined uStack98;
  undefined uStack97;
  uint8_t buffer [65];
  
  if (length < 0x21) {
    memset(&WStack100,0,0x41);
    WStack100 = WIFI_MGMR_EVENT_FW_CFG_REQ;
    uStack99 = 0x44;
    uStack98 = 0x33;
    uStack97 = 0x22;
    buffer[0] = '\x11';
    buffer[1] = -0x78;
    buffer[2] = 'w';
    iVar1 = length + 0xc6;
    buffer[3] = 'f';
    buffer[4] = 'U';
    buffer[6] = (uint8_t)((uint)iVar1 >> 8);
    buffer[7] = (uint8_t)((uint)iVar1 >> 0x10);
    buffer[10] = (uint8_t)(ops >> 8);
    buffer[11] = (uint8_t)(ops >> 0x10);
    buffer[14] = (uint8_t)(task >> 8);
    buffer[15] = (uint8_t)(task >> 0x10);
    buffer[18] = (uint8_t)(element >> 8);
    buffer[19] = (uint8_t)(element >> 0x10);
    buffer[22] = (uint8_t)(type >> 8);
    buffer[23] = (uint8_t)(type >> 0x10);
    buffer[5] = (uint8_t)iVar1;
    buffer[9] = (uint8_t)ops;
    buffer[13] = (uint8_t)task;
    buffer[17] = (uint8_t)element;
    buffer[21] = (uint8_t)type;
    buffer[26] = (uint8_t)(length >> 8);
    buffer[27] = (uint8_t)(length >> 0x10);
    buffer[8] = (uint8_t)((uint)iVar1 >> 0x18);
    buffer[12] = (uint8_t)(ops >> 0x18);
    buffer[16] = (uint8_t)(task >> 0x18);
    buffer[20] = (uint8_t)(element >> 0x18);
    buffer[24] = (uint8_t)(type >> 0x18);
    buffer[25] = (uint8_t)length;
    buffer[28] = (uint8_t)(length >> 0x18);
    if (length != 0) {
      memcpy(buffer + 0x1d,buf,length);
    }
    wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&WStack100);
    return 0;
  }
  return -1;
}



// WARNING: Variable defined which should be unmapped: buffer

int wifi_mgmr_api_ip_got(uint32_t ip,uint32_t mask,uint32_t gw,uint32_t dns1,uint32_t dns2)

{
  WIFI_MGMR_EVENT_T WStack52;
  undefined uStack51;
  undefined uStack50;
  undefined uStack49;
  uint8_t buffer [33];
  
  memset(&WStack52,0,0x21);
  WStack52 = WIFI_MGMR_EVENT_APP_IP_GOT;
  uStack51 = 0x44;
  uStack50 = 0x33;
  uStack49 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = '!';
  buffer[10] = (uint8_t)(ip >> 8);
  buffer[11] = (uint8_t)(ip >> 0x10);
  buffer[14] = (uint8_t)(mask >> 8);
  buffer[15] = (uint8_t)(mask >> 0x10);
  buffer[18] = (uint8_t)(gw >> 8);
  buffer[19] = (uint8_t)(gw >> 0x10);
  buffer[9] = (uint8_t)ip;
  buffer[13] = (uint8_t)mask;
  buffer[17] = (uint8_t)gw;
  buffer[21] = (uint8_t)dns1;
  buffer[22] = (uint8_t)(dns1 >> 8);
  buffer[12] = (uint8_t)(ip >> 0x18);
  buffer[16] = (uint8_t)(mask >> 0x18);
  buffer[20] = (uint8_t)(gw >> 0x18);
  buffer[23] = (uint8_t)(dns1 >> 0x10);
  buffer[24] = (uint8_t)(dns1 >> 0x18);
  buffer[25] = (uint8_t)dns2;
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  buffer[26] = (uint8_t)(dns2 >> 8);
  buffer[27] = (uint8_t)(dns2 >> 0x10);
  buffer[28] = (uint8_t)(dns2 >> 0x18);
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&WStack52);
  return 0;
}



int wifi_mgmr_api_ip_update(void)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  local_20 = WIFI_MGMR_EVENT_GLB_IP_UPDATE;
  uStack31 = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



int wifi_mgmr_api_reconnect(void)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  local_20 = WIFI_MGMR_EVENT_APP_RECONNECT;
  uStack31 = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



int wifi_mgmr_api_disable_autoreconnect(void)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  local_20 = WIFI_MGMR_EVENT_GLB_DISABLE_AUTORECONNECT;
  uStack31 = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



int wifi_mgmr_api_enable_autoreconnect(void)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  local_20 = WIFI_MGMR_EVENT_GLB_ENABLE_AUTORECONNECT;
  uStack31 = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



int wifi_mgmr_api_disconnect(void)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  local_20 = WIFI_MGMR_EVENT_APP_DISCONNECT;
  uStack31 = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



int wifi_mgmr_api_rate_config(uint16_t config)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  local_20 = WIFI_MGMR_EVENT_APP_RC_CONFIG;
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  uStack31 = (undefined)config;
  buffer[4] = 'U';
  uStack30 = (undefined)(config >> 8);
  uStack29 = 0;
  buffer[0] = '\0';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



int wifi_mgmr_api_conf_max_sta(uint8_t max_sta_supported)

{
  WIFI_MGMR_EVENT_T local_20;
  uint8_t uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  local_20 = WIFI_MGMR_EVENT_APP_CONF_MAX_STA;
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  uStack30 = 0;
  uStack29 = 0;
  buffer[0] = '\0';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  uStack31 = max_sta_supported;
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



int wifi_mgmr_api_ifaceup(void)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  local_20 = WIFI_MGMR_EVENT_APP_PHY_UP;
  uStack31 = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



int wifi_mgmr_api_sniffer_enable(void)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  local_20 = WIFI_MGMR_EVENT_APP_SNIFFER;
  uStack31 = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



int wifi_mgmr_api_scan_item_beacon
              (uint8_t channel,int8_t rssi,uint8_t auth,uint8_t *mac,uint8_t *ssid,int len,
              int8_t ppm_abs,int8_t ppm_rel,uint8_t cipher)

{
  WIFI_MGMR_EVENT_T WStack108;
  undefined uStack107;
  undefined uStack106;
  undefined uStack105;
  uint8_t buffer [73];
  
  memset(&WStack108,0,0x49);
  WStack108 = WIFI_MGMR_EVENT_GLB_SCAN_IND_BEACON;
  uStack107 = 0x44;
  uStack106 = 0x33;
  uStack105 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = 'I';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  memcpy(buffer + 9,ssid,len);
  buffer[45] = (uint8_t)len;
  buffer[46] = (uint8_t)((uint)len >> 8);
  buffer[47] = (uint8_t)((uint)len >> 0x10);
  buffer[48] = (uint8_t)((uint)len >> 0x18);
  buffer[41] = '\0';
  memcpy(buffer + 0x31,mac,6);
  buffer[55] = channel;
  buffer[56] = rssi;
  buffer[57] = ppm_abs;
  buffer[58] = ppm_rel;
  buffer[59] = auth;
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&WStack108);
  return 0;
}



int wifi_mgmr_api_fw_disconnect(void)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  local_20 = WIFI_MGMR_EVENT_FW_DISCONNECT;
  uStack31 = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



int wifi_mgmr_api_fw_tsen_reload(void)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  uStack31 = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  local_20 = WIFI_MGMR_EVENT_APP_RELOAD_TSEN;
  buffer[4] = 'U';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



int wifi_mgmr_api_fw_scan(void)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  local_20 = WIFI_MGMR_EVENT_FW_SCAN;
  uStack31 = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



int wifi_mgmr_api_fw_powersaving(int mode)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  local_20 = WIFI_MGMR_EVENT_FW_POWERSAVING;
  uStack30 = (undefined)((uint)mode >> 8);
  uStack29 = (undefined)((uint)mode >> 0x10);
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  uStack31 = (undefined)mode;
  buffer[4] = 'U';
  buffer[0] = (uint8_t)((uint)mode >> 0x18);
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

int wifi_mgmr_api_ap_start(char *ssid,char *passwd,int channel,uint8_t hidden_ssid)

{
  size_t sVar1;
  int iVar2;
  undefined3 in_register_00002035;
  WIFI_MGMR_EVENT_T WStack156;
  undefined uStack155;
  undefined uStack154;
  undefined uStack153;
  uint8_t buffer [124];
  
  if (ssid == (char *)0x0) {
    return -1;
  }
  memset(&WStack156,0,0x7c);
  sVar1 = strlen(ssid);
  buffer[47] = (uint8_t)sVar1;
  buffer._48_4_ = buffer._48_4_ & 0xff000000 | sVar1 >> 8;
  if (sVar1 < 0x21) {
    if (passwd != (char *)0x0) {
      buffer._116_4_ = strlen(passwd);
      if (0x20 < buffer._116_4_) goto LAB_23005e90;
    }
    WStack156 = WIFI_MGMR_EVENT_APP_AP_START;
    uStack155 = 0x44;
    uStack154 = 0x33;
    uStack153 = 0x22;
    buffer[0] = '\x11';
    buffer[1] = -0x78;
    buffer[2] = 'w';
    buffer[3] = 'f';
    buffer[4] = 'U';
    buffer[5] = '|';
    buffer[6] = '\0';
    buffer[7] = '\0';
    buffer[8] = '\0';
    memcpy(buffer + 0xd,ssid,(uint)buffer[47] | buffer._48_4_ << 8);
    if (passwd == (char *)0x0) {
      buffer._116_4_ = 0;
    }
    else {
      memcpy(buffer + 0x33,passwd,buffer._116_4_);
    }
    buffer[9] = (uint8_t)channel;
    buffer[10] = (uint8_t)((uint)channel >> 8);
    buffer[46] = CONCAT31(in_register_00002035,hidden_ssid) != 0;
    buffer[11] = (uint8_t)((uint)channel >> 0x10);
    buffer[12] = (uint8_t)((uint)channel >> 0x18);
    wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&WStack156);
    iVar2 = 0;
  }
  else {
LAB_23005e90:
    iVar2 = -1;
  }
  return iVar2;
}



int wifi_mgmr_api_ap_stop(void)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  local_20 = WIFI_MGMR_EVENT_APP_AP_STOP;
  uStack31 = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



int wifi_mgmr_api_idle(void)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  uStack31 = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  local_20 = WIFI_MGMR_EVENT_APP_IDLE;
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



int wifi_mgmr_api_denoise_enable(void)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  local_20 = WIFI_MGMR_EVENT_APP_DENOISE;
  uStack31 = 1;
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  uStack30 = 0;
  uStack29 = 0;
  buffer[0] = '\0';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



int wifi_mgmr_api_denoise_disable(void)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  local_20 = WIFI_MGMR_EVENT_APP_DENOISE;
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  uStack31 = 0;
  uStack30 = 0;
  uStack29 = 0;
  buffer[0] = '\0';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



int wifi_mgmr_api_raw_send(uint8_t *pkt,int len)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(&local_20,0,0xd);
  local_20 = WIFI_MGMR_EVENT_FW_DATA_RAW_SEND;
  uStack30 = (undefined)((uint)pkt >> 8);
  uStack29 = (undefined)((uint)pkt >> 0x10);
  buffer[2] = (uint8_t)((uint)len >> 8);
  uStack31 = SUB41(pkt,0);
  buffer[1] = (uint8_t)len;
  buffer[3] = (uint8_t)((uint)len >> 0x10);
  buffer[0] = (uint8_t)((uint)pkt >> 0x18);
  buffer[4] = (uint8_t)((uint)len >> 0x18);
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return 0;
}



int wifi_mgmr_api_set_country_code(char *country_code)

{
  wifi_mgmr_set_country_code_internal(country_code);
  return 0;
}



void cmd_rf_dump(char *buf,int len,int argc,char **argv)

{
  return;
}



void cmd_dump_reset(char *buf,int len,int argc,char **argv)

{
  pkt_counter = 10;
  return;
}



void cmd_wifi_power_table_update(char *buf,int len,int argc,char **argv)

{
  int8_t aiStack56 [4];
  int8_t power_table_test [38];
  
  memcpy(aiStack56,&DAT_2306fe08,0x26);
  bl_tpc_update_power_table(aiStack56);
  return;
}



void cmd_wifi_state_get(char *buf,int len,int argc,char **argv)

{
  char *fmt;
  int iStack20;
  int state;
  
  iStack20 = 0;
  wifi_mgmr_state_get(&iStack20);
  switch(iStack20) {
  case 0:
    fmt = "wifi state unknown\r\n";
    break;
  case 1:
    fmt = "wifi state idle\r\n";
    break;
  case 2:
    fmt = "wifi state connecting\r\n";
    break;
  case 3:
    fmt = "wifi state connected ip getting\r\n";
    break;
  case 4:
    fmt = "wifi state connected ip got\r\n";
    break;
  case 5:
    fmt = "wifi state disconnect\r\n";
    break;
  case 6:
    fmt = "wifi state ifdown\r\n";
    break;
  case 7:
    fmt = "wifi state sniffer\r\n";
    break;
  case 8:
    fmt = "wifi state psk error\r\n";
    break;
  case 9:
    fmt = "wifi state no ap found\r\n";
    break;
  default:
    goto switchD_2300615c_caseD_a;
  case 0x11:
    fmt = "wifi state with ap idle\r\n";
    break;
  case 0x12:
    fmt = "wifi state with ap connecting\r\n";
    break;
  case 0x13:
    fmt = "wifi state with ap connected ip getting\r\n";
    break;
  case 0x14:
    fmt = "wifi state with ap connected ip got\r\n";
    break;
  case 0x15:
    fmt = "wifi state with ap disconnect\r\n";
  }
  printf(fmt);
switchD_2300615c_caseD_a:
  return;
}



void wifi_sta_get_state_cmd(char *buf,int len,int argc,char **argv)

{
  char "wifi_sta_get_state_cmd" [23];
  char *fmt;
  int iStack20;
  int state;
  
  iStack20 = 0;
  wifi_mgmr_state_get(&iStack20);
  printf("%s:wifi state = 0x%x\r\n","wifi_sta_get_state_cmd",iStack20);
  if (iStack20 == 0) {
    fmt = "wifi current state: WIFI_STATE_UNKNOWN\r\n";
  }
  else {
    if (iStack20 == 1) {
      fmt = "wifi current state: WIFI_STATE_IDLE\r\n";
    }
    else {
      if (iStack20 == 2) {
        fmt = "wifi current state: WIFI_STATE_CONNECTING\r\n";
      }
      else {
        if (iStack20 == 3) {
          fmt = "wifi current state: WIFI_STATE_CONNECTED_IP_GETTING\r\n";
        }
        else {
          if (iStack20 == 4) {
            fmt = "wifi current state: WIFI_STATE_CONNECTED_IP_GOT\r\n";
          }
          else {
            if (iStack20 == 5) {
              fmt = "wifi current state: WIFI_STATE_DISCONNECT\r\n";
            }
            else {
              if (iStack20 == 0x11) {
                fmt = "wifi current state: WIFI_STATE_WITH_AP_IDLE\r\n";
              }
              else {
                if (iStack20 == 0x12) {
                  fmt = "wifi current state: WIFI_STATE_WITH_AP_CONNECTING\r\n";
                }
                else {
                  if (iStack20 == 0x13) {
                    fmt = "wifi current state: WIFI_STATE_WITH_AP_CONNECTED_IP_GETTING\r\n";
                  }
                  else {
                    if (iStack20 == 0x14) {
                      fmt = "wifi current state: WIFI_STATE_WITH_AP_CONNECTED_IP_GOT\r\n";
                    }
                    else {
                      if (iStack20 == 0x15) {
                        fmt = "wifi current state: WIFI_STATE_WITH_AP_DISCONNECT\r\n";
                      }
                      else {
                        if (iStack20 == 6) {
                          fmt = "wifi current state: WIFI_STATE_IFDOWN\r\n";
                        }
                        else {
                          if (iStack20 == 7) {
                            fmt = "wifi current state: WIFI_STATE_SNIFFER\r\n";
                          }
                          else {
                            if (iStack20 == 8) {
                              fmt = "wifi current state: WIFI_STATE_PSK_ERROR\r\n";
                            }
                            else {
                              if (iStack20 == 9) {
                                fmt = "wifi current state: WIFI_STATE_NO_AP_FOUND\r\n";
                              }
                              else {
                                fmt = "wifi current state: invalid\r\n";
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  printf(fmt);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void wifi_edca_dump_cmd(char *buf,int len,int argc,char **argv)

{
  byte local_15;
  byte local_14;
  byte local_13;
  uint8_t aifs;
  ushort uStack18;
  uint8_t cwmin;
  uint8_t cwmax;
  uint16_t txop;
  
  local_15 = 0;
  local_14 = 0;
  local_13 = 0;
  uStack18 = 0;
  puts("EDCA Statistic:\r\n");
  bl60x_edca_get(0,&local_15,&local_14,&local_13,(uint16_t *)&stack0xffffffee);
  puts("  AC_BK:");
  printf("aifs %3u, cwmin %3u, cwmax %3u, txop %4u\r\n",(uint)local_15,(uint)local_14,(uint)local_13
         ,(uint)uStack18);
  bl60x_edca_get(1,&local_15,&local_14,&local_13,(uint16_t *)&stack0xffffffee);
  puts("  AC_BE:");
  printf("aifs %3u, cwmin %3u, cwmax %3u, txop %4u\r\n",(uint)local_15,(uint)local_14,(uint)local_13
         ,(uint)uStack18);
  bl60x_edca_get(2,&local_15,&local_14,&local_13,(uint16_t *)&stack0xffffffee);
  puts("  AC_VI:");
  printf("aifs %3u, cwmin %3u, cwmax %3u, txop %4u\r\n",(uint)local_15,(uint)local_14,(uint)local_13
         ,(uint)uStack18);
  bl60x_edca_get(3,&local_15,&local_14,&local_13,(uint16_t *)&stack0xffffffee);
  puts("  AC_VO:");
  printf("aifs %3u, cwmin %3u, cwmax %3u, txop %4u\r\n",(uint)local_15,(uint)local_14,(uint)local_13
         ,(uint)uStack18);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void wifi_ap_sta_list_get_cmd(char *buf,int len,int argc,char **argv)

{
  char cVar1;
  uint uVar2;
  char *fmt;
  wifi_ap_data_rate *pwVar3;
  byte bStack77;
  uint8_t sta_cnt;
  uint uStack76;
  int state;
  wifi_sta_basic_info sta_info;
  
  uStack76 = 0;
  bStack77 = 0;
  wifi_mgmr_state_get((int *)&stack0xffffffb4);
  if ((uStack76 & 0x10) == 0) {
    fmt = "wifi AP is not enabled, state = %d\r\n";
    uVar2 = uStack76;
  }
  else {
    wifi_mgmr_ap_sta_cnt_get(&bStack77);
    if (bStack77 != 0) {
      memset(&state,0,0x18);
      printf("sta list:\r\n");
      printf(
            "-----------------------------------------------------------------------------------\r\n"
            );
      printf(
            "No.      StaIndex      Mac-Address       Signal      DateRate            TimeStamp\r\n"
            );
      printf(
            "-----------------------------------------------------------------------------------\r\n"
            );
      uVar2 = 0;
      do {
        if (bStack77 <= uVar2) {
          return;
        }
        wifi_mgmr_ap_sta_info_get((wifi_sta_basic_info *)&state,(uint8_t)uVar2);
        if ((state._1_1_ != '\0') && ((uint8_t)state != -0x11)) {
          pwVar3 = data_rate_list;
          cVar1 = '\0';
          do {
            if (pwVar3->data_rate == (uint8_t)sta_info.rssi) break;
            cVar1 = cVar1 + '\x01';
            pwVar3 = pwVar3 + 1;
          } while (cVar1 != '\f');
          printf(
                 " %u          %u        %02X:%02X:%02X:%02X:%02X:%02X    %d      %s      0x%llx\r\n"
                 ,uVar2,(uint)state._2_1_,(uint)state._3_1_,(uint)sta_info.sta_idx,
                 (uint)sta_info.is_used,(uint)sta_info.sta_mac[0]);
        }
        uVar2 = uVar2 + 1 & 0xff;
      } while( true );
    }
    uVar2 = 0;
    fmt = "no sta connect current AP, sta_cnt = %d\r\n";
  }
  printf(fmt,uVar2);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void wifi_ap_sta_delete_cmd(char *buf,int len,int argc,char **argv)

{
  char cVar1;
  byte idx;
  char *fmt;
  size_t sVar2;
  char *pcVar3;
  char *__s;
  byte bVar4;
  char cVar5;
  byte bStack45;
  uint8_t sta_cnt;
  char *pcStack44;
  int state;
  wifi_sta_basic_info sta_info;
  
  pcStack44 = (char *)0x0;
  bStack45 = 0;
  if (argc == 2) {
    wifi_mgmr_state_get((int *)&stack0xffffffd4);
    if (((uint)pcStack44 & 0x10) == 0) {
      fmt = "wifi AP is not enabled, state = %d\r\n";
      pcVar3 = pcStack44;
    }
    else {
      printf("Delete Sta No.%s \r\n",argv[1]);
      __s = argv[1];
      idx = 0;
      sVar2 = strlen(__s);
      cVar5 = '\x01';
      fmt = __s + sVar2;
      *fmt = '\0';
      pcVar3 = fmt;
      while ((int)(fmt + -(int)pcVar3) < (int)sVar2) {
        cVar1 = pcVar3[-1];
        bVar4 = cVar1 - 0x30;
        if (9 < bVar4) {
          if ((byte)(cVar1 + 0x9fU) < 6) {
            bVar4 = cVar1 + 0xa9;
          }
          else {
            bVar4 = 0;
            if ((byte)(cVar1 + 0xbfU) < 6) {
              bVar4 = cVar1 - 0x37;
            }
          }
        }
        pcVar3 = pcVar3 + -1;
        idx = idx + bVar4 * cVar5;
        cVar5 = cVar5 * '\n';
      }
      pcVar3 = (char *)(uint)idx;
      printf("sta_str: %s, str_len: %d, sta_num: %d, q: %s\r\n",__s,pcVar3);
      printf("sta num = %d \r\n",pcVar3);
      wifi_mgmr_ap_sta_cnt_get(&bStack45);
      if ((bStack45 == 0) || ((char *)(uint)bStack45 < pcVar3)) {
        fmt = "no valid sta in list or sta idx(%d) is invalid\r\n";
        pcVar3 = (char *)(uint)bStack45;
      }
      else {
        memset(&state,0,0x18);
        wifi_mgmr_ap_sta_info_get((wifi_sta_basic_info *)&state,idx);
        if ((state._1_1_ != '\0') && ((uint8_t)state != -0x11)) {
          printf("sta info: No.%u,sta_idx = %u,mac = %02X:%02X:%02X:%02X:%02X:%02X,rssi = %d\r\n",
                 pcVar3,(uint)state._2_1_,(uint)state._3_1_,(uint)sta_info.sta_idx,
                 (uint)sta_info.is_used,(uint)sta_info.sta_mac[0]);
          wifi_mgmr_ap_sta_delete((uint8_t)state);
          return;
        }
        fmt = "No.%d sta is invalid\r\n";
      }
    }
  }
  else {
    fmt = "[USAGE]: %s sta_num\r\n";
    pcVar3 = *argv;
  }
  printf(fmt,pcVar3);
  return;
}



void cmd_wifi_coex_pta_force_off(char *buf,int len,int argc,char **argv)

{
  coex_wifi_pta_forece_enable(0);
  return;
}



void cmd_wifi_coex_pta_force_on(char *buf,int len,int argc,char **argv)

{
  coex_wifi_pta_forece_enable(1);
  return;
}



void cmd_wifi_coex_pti_force_off(char *buf,int len,int argc,char **argv)

{
  coex_wifi_pti_forece_enable(0);
  return;
}



void cmd_wifi_coex_pti_force_on(char *buf,int len,int argc,char **argv)

{
  coex_wifi_pti_forece_enable(1);
  return;
}



void cmd_wifi_coex_rf_force_off(char *buf,int len,int argc,char **argv)

{
  coex_wifi_rf_forece_enable(0);
  return;
}



void cmd_wifi_coex_rf_force_on(char *buf,int len,int argc,char **argv)

{
  coex_wifi_rf_forece_enable(1);
  return;
}



void cmd_wifi_mib(char *buf,int len,int argc,char **argv)

{
  hal_mib_dump();
  utils_hexdump(*argv,0x1e);
  return;
}



void cmd_wifi_cfg(char *buf,int len,int argc,char **argv)

{
  uint uVar1;
  uint32_t task;
  int iVar2;
  uint32_t ops;
  uint32_t length;
  uint32_t *buf_00;
  uint32_t element;
  uint32_t type;
  uint32_t uStack88;
  uint32_t val [1];
  getopt_env_t getopt_env;
  
  type = 0;
  utils_getopt_init((getopt_env_t *)val,0);
  element = 0;
  task = 0;
  uVar1 = 4;
  while (iVar2 = utils_getopt((getopt_env_t *)val,argc,argv,":c:T:e:t:v:"), iVar2 != -1) {
    if (iVar2 == 99) {
      iVar2 = strcmp("dump",(char *)val);
      if (iVar2 == 0) {
        uVar1 = 3;
      }
      else {
        iVar2 = strcmp("set",(char *)val);
        if (iVar2 == 0) {
          uVar1 = 0;
        }
        else {
          iVar2 = strcmp("get",(char *)val);
          if (iVar2 == 0) {
            uVar1 = 1;
          }
          else {
            iVar2 = strcmp("reset",(char *)val);
            if (iVar2 == 0) {
              uVar1 = 2;
            }
          }
        }
      }
    }
    else {
      if (iVar2 < 100) {
        if (iVar2 == 0x3f) {
          printf("%s: unknown option %c\r\n",*argv,getopt_env.opterr);
          return;
        }
        if (iVar2 == 0x54) {
          type = atoi((char *)val);
        }
      }
      else {
        if (iVar2 == 0x74) {
          task = atoi((char *)val);
        }
        else {
          if (iVar2 == 0x76) {
            uStack88 = atoi((char *)val);
          }
          else {
            if (iVar2 == 0x65) {
              element = atoi((char *)val);
            }
          }
        }
      }
    }
  }
  printf("Target CFG Element Info, task: %lu, element %lu, type %lu, val %lu\r\n",task,element,type,
         uStack88);
  if (uVar1 == 2) {
    printf("    OPS: %s\r\n","reset");
    buf_00 = (uint32_t *)0x0;
    length = 0;
    type = 0;
    ops = 2;
  }
  else {
    if (uVar1 < 3) {
      if (uVar1 == 1) {
        printf("    OPS: %s\r\n",&DAT_2306fec0);
        buf_00 = &uStack88;
        length = 4;
        ops = 1;
        goto LAB_230067b4;
      }
    }
    else {
      if (uVar1 == 3) {
        printf("    OPS: %s\r\n",0x23077238);
        buf_00 = (uint32_t *)0x0;
        length = 0;
        type = 0;
        element = 0;
        task = 0;
        ops = 3;
        goto LAB_230067b4;
      }
      if (uVar1 == 4) {
        printf("UNKNOWN OPS\r\n");
        return;
      }
    }
    printf("    OPS: %s\r\n",0x230702a8);
    buf_00 = &uStack88;
    length = 4;
    ops = 0;
  }
LAB_230067b4:
  wifi_mgmr_cfg_req(ops,task,element,type,length,buf_00);
  return;
}



void cmd_wifi_ap_stop(char *buf,int len,int argc,char **argv)

{
  wifi_mgmr_ap_stop((wifi_interface_t *)0x0);
  printf("--->>> cmd_wifi_ap_stop\r\n");
  return;
}



// WARNING: Variable defined which should be unmapped: ssid_name

void cmd_wifi_ap_start(char *buf,int len,int argc,char **argv)

{
  wifi_interface_t *interface;
  uint hidden_ssid;
  char *passwd;
  int channel;
  uint8_t auStack56 [3];
  byte bStack53;
  uint8_t mac [6];
  char ssid_name [32];
  
  memset(auStack56,0,6);
  bl_wifi_mac_addr_get(auStack56);
  memset(mac + 4,0,0x20);
  snprintf((char *)(mac + 4),0x20,"BL60X_uAP_%02X%02X%02X",(uint)bStack53,(uint)mac[0],(uint)mac[1])
  ;
  interface = (wifi_interface_t *)wifi_mgmr_ap_enable();
  if (argc == 1) {
    channel = 1;
    passwd = (char *)0x0;
    hidden_ssid = 0;
  }
  else {
    channel = atoi(argv[1]);
    if (10 < channel - 1U) {
      return;
    }
    passwd = "12345678";
    hidden_ssid = (uint)(argc == 3);
  }
  wifi_mgmr_ap_start(interface,(char *)(mac + 4),hidden_ssid,passwd,channel);
  return;
}



void wifi_sniffer_off_cmd(char *buf,int len,int argc,char **argv)

{
  wifi_mgmr_sniffer_disable();
  wifi_mgmr_sniffer_unregister((void *)0x0);
  return;
}



void wifi_sniffer_on_cmd(char *buf,int len,int argc,char **argv)

{
  wifi_mgmr_sniffer_enable();
  wifi_mgmr_sniffer_register((void *)0x0,sniffer_cb);
  return;
}



int wifi_denoise_disable_cmd(void)

{
  WIFI_MGMR_EVENT_T WStack32;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  undefined uStack28;
  undefined uStack27;
  undefined uStack26;
  undefined uStack25;
  undefined uStack24;
  undefined uStack23;
  undefined uStack22;
  undefined uStack21;
  undefined uStack20;
  
  memset(&WStack32,0,0xd);
  WStack32 = WIFI_MGMR_EVENT_APP_DENOISE;
  uStack27 = 0x88;
  uStack26 = 0x77;
  uStack25 = 0x66;
  uStack24 = 0x55;
  uStack31 = 0;
  uStack30 = 0;
  uStack29 = 0;
  uStack28 = 0;
  uStack23 = 0xd;
  uStack22 = 0;
  uStack21 = 0;
  uStack20 = 0;
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&WStack32);
  return 0;
}



int wifi_denoise_enable_cmd(void)

{
  WIFI_MGMR_EVENT_T WStack32;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  undefined uStack28;
  undefined uStack27;
  undefined uStack26;
  undefined uStack25;
  undefined uStack24;
  undefined uStack23;
  undefined uStack22;
  undefined uStack21;
  undefined uStack20;
  
  memset(&WStack32,0,0xd);
  WStack32 = WIFI_MGMR_EVENT_APP_DENOISE;
  uStack31 = 1;
  uStack27 = 0x88;
  uStack26 = 0x77;
  uStack25 = 0x66;
  uStack24 = 0x55;
  uStack30 = 0;
  uStack29 = 0;
  uStack28 = 0;
  uStack23 = 0xd;
  uStack22 = 0;
  uStack21 = 0;
  uStack20 = 0;
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&WStack32);
  return 0;
}



void wifi_power_saving_off_cmd(char *buf,int len,int argc,char **argv)

{
  wifi_mgmr_sta_powersaving(0);
  return;
}



void wifi_power_saving_on_cmd(char *buf,int len,int argc,char **argv)

{
  wifi_mgmr_sta_powersaving(2);
  return;
}



void wifi_rc_fixed_disable(char *buf,int len,int argc,char **argv)

{
  wifi_mgmr_rate_config(0xffff);
  return;
}



int wifi_disable_autoreconnect_cmd(void)

{
  wifi_mgmr_api_disable_autoreconnect();
  return 0;
}



int wifi_enable_autoreconnect_cmd(void)

{
  wifi_mgmr_api_enable_autoreconnect();
  return 0;
}



void wifi_disconnect_cmd(char *buf,int len,int argc,char **argv)

{
  wifi_mgmr_sta_disconnect();
  vTaskDelay(1000);
  wifi_mgmr_sta_disable((wifi_interface_t *)0x0);
  return;
}



int wifi_sta_ip_unset_cmd(void)

{
  int iVar1;
  
  iVar1 = wifi_mgmr_sta_ip_set(0,0,0,0,0);
  return iVar1;
}



// WARNING: Could not reconcile some variable overlaps

void wifi_sta_ip_info(char *buf,int len,int argc,char **argv)

{
  char *pcVar1;
  ip4_addr_t iStack80;
  ip4_addr_t ip;
  ip4_addr_t gw;
  ip4_addr_t mask;
  ip4_addr_t dns1;
  ip4_addr_t dns2;
  int rssi;
  int8_t power_rate_table [38];
  
  wifi_mgmr_sta_ip_get((uint32_t *)&iStack80,(uint32_t *)&ip,(uint32_t *)&gw);
  wifi_mgmr_sta_dns_get((uint32_t *)&mask,(uint32_t *)&dns1);
  wifi_mgmr_rssi_get((int *)&dns2);
  bl_tpc_power_table_get((int8_t *)&rssi);
  printf("RSSI:   %ddbm\r\n",dns2);
  pcVar1 = ip4addr_ntoa(&iStack80);
  printf("IP  :   %s \r\n",pcVar1);
  pcVar1 = ip4addr_ntoa(&gw);
  printf("MASK:   %s \r\n",pcVar1);
  pcVar1 = ip4addr_ntoa(&ip);
  printf("GW  :   %s \r\n",pcVar1);
  pcVar1 = ip4addr_ntoa(&mask);
  printf("DNS1:   %s \r\n",pcVar1);
  pcVar1 = ip4addr_ntoa(&dns1);
  printf("DNS2:   %s \r\n",pcVar1);
  puts("Power Table (dbm):\r\n");
  puts("--------------------------------\r\n");
  printf("  11b: %u %u %u %u             (1Mbps 2Mbps 5.5Mbps 11Mbps)\r\n",(int)(char)rssi,
         (int)rssi._1_1_,(int)rssi._2_1_,(int)rssi._3_1_);
  printf(
         "  11g: %u %u %u %u %u %u %u %u (6Mbps 9Mbps 12Mbps 18Mbps 24Mbps 36Mbps 48Mbps 54Mbps)\r\n"
         ,(int)power_rate_table[4],(int)power_rate_table[5],(int)power_rate_table[6],
         (int)power_rate_table[7],(int)power_rate_table[8],(int)power_rate_table[9],
         (int)power_rate_table[10]);
  printf("  11n: %u %u %u %u %u %u %u %u (MCS0 ~ MCS7)\r\n",(int)power_rate_table[12],
         (int)power_rate_table[13],(int)power_rate_table[14],(int)power_rate_table[15],
         (int)power_rate_table[16],(int)power_rate_table[17],(int)power_rate_table[18]);
  puts("--------------------------------\r\n");
  return;
}



void cmd_wifi_raw_send(char *buf,int len,int argc,char **argv)

{
  uint32_t seq;
  char *s;
  int iVar1;
  
  iVar1 = seq << 4;
  packet_raw[22] = (uint8_t)iVar1;
  seq = seq + 1;
  packet_raw[23] = (uint8_t)((uint)iVar1 >> 8);
  iVar1 = wifi_mgmr_raw_80211_send(packet_raw,0x18);
  if (iVar1 == 0) {
    s = "Raw send succeed\r\n";
  }
  else {
    s = "Raw send failed\r\n";
  }
  puts(s);
  return;
}



void wifi_scan_cmd(char *buf,int len,int argc,char **argv)

{
  wifi_mgmr_scan((void *)0x0,(scan_complete_cb_t *)0x0);
  return;
}



void sniffer_cb(void *env,uint8_t *pkt,int len)

{
  TickType_t TVar1;
  
  sniffer_counter_5067 = sniffer_counter_5067 + 1;
  TVar1 = xTaskGetTickCount();
  if (10000 < (int)(TVar1 - last_tick_5069)) {
    last_tick_5069 = xTaskGetTickCount();
  }
  return;
}



void cmd_wifi_dump(char *buf,int len,int argc,char **argv)

{
  if (argc < 2) {
    puts("[CLI] Dump statistic use normal mode\r\n");
    vTaskEnterCritical();
  }
  else {
    puts("[CLI] Dump statistic use forced mode\r\n");
    vTaskEnterCritical();
  }
  bl60x_fw_dump_statistic((uint)(argc >= 2));
  vTaskExitCritical();
  return;
}



void cmd_wifi_ap_conf_max_sta(char *buf,int len,int argc,char **argv)

{
  int iVar1;
  
  if (argc != 2) {
    printf("Usage: wifi_ap_max_sta [num]\r\n");
    return;
  }
  iVar1 = atoi(argv[1]);
  printf("Conf Max Sta to %d\r\n",iVar1);
  wifi_mgmr_conf_max_sta((uint8_t)iVar1);
  return;
}



void wifi_mon_cmd(char *buf,int len,int argc,char **argv)

{
  if (1 < argc) {
    wifi_mgmr_sniffer_enable();
    return;
  }
  wifi_mgmr_sniffer_register((void *)0x0,sniffer_cb);
  return;
}



void wifi_rc_fixed_enable(char *buf,int len,int argc,char **argv)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  char *pcVar4;
  uint uVar5;
  
  if (argc != 4) {
    printf("rc_fix_en [b/g/n] [MCS] [GI]");
    return;
  }
  uVar1 = atoi(argv[1]);
  uVar5 = uVar1 & 0xff;
  uVar2 = atoi(argv[2]);
  uVar3 = atoi(argv[3]);
  if (uVar5 == 1) {
    pcVar4 = "n mode";
  }
  else {
    pcVar4 = "b/g mdoe";
  }
  printf("wifi set mode:%s, mcs:%d, gi:%d\r\n",pcVar4,uVar2 & 0xff,uVar3 & 0xff);
  if (uVar5 == 1) {
    uVar1 = ((uVar1 & 0xff) << 0xc | (uVar3 & 0xff) << 9) & 0xffff | uVar2 & 0xff;
  }
  else {
    uVar1 = 0;
    if (uVar5 == 0) {
      uVar1 = uVar2 & 0xff | 0x600;
    }
  }
  printf("wifi rc:0x%x\r\n",uVar1);
  wifi_mgmr_rate_config((uint16_t)uVar1);
  return;
}



void wifi_connect_cmd(char *buf,int len,int argc,char **argv)

{
  wifi_interface_t *wifi_interface;
  
  if (argc != 3) {
    printf("[USAGE]: %s [ssid] [password]\r\n",*argv);
    return;
  }
  wifi_interface = (wifi_interface_t *)wifi_mgmr_sta_enable();
  wifi_mgmr_sta_connect(wifi_interface,argv[1],argv[2],(char *)0x0,(uint8_t *)0x0,'\0',0);
  return;
}



void wifi_sta_ip_set_cmd(char *buf,int len,int argc,char **argv)

{
  ip4_addr_t ip;
  ip4_addr_t mask;
  ip4_addr_t gw;
  ip4_addr_t dns1;
  ip4_addr_t dns2;
  ip4_addr_t iStack56;
  ip4_addr_t addr;
  char addr_str [20];
  
  if (argc == 6) {
    ip = (ip4_addr_t)ipaddr_addr(argv[1]);
    mask = (ip4_addr_t)ipaddr_addr(argv[2]);
    gw = (ip4_addr_t)ipaddr_addr(argv[3]);
    dns1 = (ip4_addr_t)ipaddr_addr(argv[4]);
    dns2 = (ip4_addr_t)ipaddr_addr(argv[5]);
    iStack56 = ip;
    ip4addr_ntoa_r(&iStack56,(char *)&addr,0x14);
    puts("IP  : ");
    puts((char *)&addr);
    puts("\r\n");
    iStack56 = mask;
    ip4addr_ntoa_r(&iStack56,(char *)&addr,0x14);
    puts("MASK: ");
    puts((char *)&addr);
    puts("\r\n");
    iStack56 = gw;
    ip4addr_ntoa_r(&iStack56,(char *)&addr,0x14);
    puts("GW  : ");
    puts((char *)&addr);
    puts("\r\n");
    iStack56 = dns1;
    ip4addr_ntoa_r(&iStack56,(char *)&addr,0x14);
    puts("DNS1: ");
    puts((char *)&addr);
    puts("\r\n");
    iStack56 = dns2;
    ip4addr_ntoa_r(&iStack56,(char *)&addr,0x14);
    puts("DNS2: ");
    puts((char *)&addr);
    puts("\r\n");
    wifi_mgmr_sta_ip_set((uint32_t)ip,(uint32_t)mask,(uint32_t)gw,(uint32_t)dns1,(uint32_t)dns2);
  }
  else {
    puts("Illegal CMD format\r\n");
  }
  return;
}



void wifi_scan_filter_cmd(char *buf,int len,int argc,char **argv)

{
  if (argc == 2) {
    wifi_mgmr_scan_filter_hidden_ssid((uint)(*argv[1] == '1'));
    return;
  }
  return;
}



void wifi_capcode_cmd(char *buf,int len,int argc,char **argv)

{
  uint8_t uVar1;
  char *fmt;
  undefined3 extraout_var;
  int iVar2;
  char *pcVar3;
  
  if (argc - 1U < 2) {
    if (argc != 1) {
      iVar2 = atoi(argv[1]);
      printf("Setting capcode to %d\r\n",iVar2);
      if (0 < iVar2) {
        hal_sys_capcode_update((uint8_t)iVar2,(uint8_t)iVar2);
        return;
      }
      return;
    }
    uVar1 = hal_sys_capcode_get();
    pcVar3 = (char *)CONCAT31(extraout_var,uVar1);
    fmt = "Capcode %u is being used\r\n";
  }
  else {
    pcVar3 = *argv;
    fmt = "Usage: %s capcode\r\n";
  }
  printf(fmt,pcVar3);
  return;
}



int wifi_mgmr_cli_scanlist(void)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  byte bVar5;
  byte bVar6;
  wifi_mgmr_t *pwVar7;
  int iVar8;
  TickType_t TVar9;
  
  printf("cached scan list\r\n");
  pwVar7 = &wifiMgmr;
  printf(
        "****************************************************************************************************\r\n"
        );
  iVar8 = 0;
  do {
    if (pwVar7->scan_items[0].is_used == '\0') {
LAB_23007022:
      printf("index[%02d]: empty\r\n",iVar8);
    }
    else {
      TVar9 = xTaskGetTickCount();
      if ((uint)wifiMgmr.scan_item_timeout <= TVar9 - pwVar7->scan_items[0].timestamp_lastseen)
      goto LAB_23007022;
      bVar1 = pwVar7->scan_items[0].channel;
      bVar2 = pwVar7->scan_items[0].bssid[0];
      bVar3 = pwVar7->scan_items[0].bssid[1];
      bVar4 = pwVar7->scan_items[0].bssid[2];
      bVar5 = pwVar7->scan_items[0].bssid[3];
      bVar6 = pwVar7->scan_items[0].bssid[4];
      wifi_mgmr_auth_to_str(pwVar7->scan_items[0].auth);
      wifi_mgmr_cipher_to_str(pwVar7->scan_items[0].cipher);
      printf(
             "index[%02d]: channel %02u, bssid %02X:%02X:%02X:%02X:%02X:%02X, rssi %3d, ppm abs:rel %3d : %3d, auth %20s, cipher:%12s, SSID %s\r\n"
             ,iVar8,(uint)bVar1,(uint)bVar2,(uint)bVar3,(uint)bVar4,(uint)bVar5,(uint)bVar6);
    }
    iVar8 = iVar8 + 1;
    pwVar7 = (wifi_mgmr_t *)&(pwVar7->wlan_sta).netif.input;
    if (iVar8 == 0x32) {
      printf(
            "----------------------------------------------------------------------------------------------------\r\n"
            );
      return 0;
    }
  } while( true );
}



int wifi_mgmr_ext_dump_needed(void)

{
  bool bVar1;
  
  bVar1 = 0 < pkt_counter;
  if (bVar1) {
    pkt_counter = pkt_counter + -1;
  }
  return (uint)bVar1;
}



int wifi_mgmr_cli_init(void)

{
  return 0;
}



int mac_is_unvalid(uint8_t *mac)

{
  int iVar1;
  
  iVar1 = 1;
  do {
    if (mac[iVar1] != *mac) {
      return 0;
    }
    iVar1 = iVar1 + 1;
  } while (iVar1 != 6);
  return (uint)((byte)(*mac - 1) < 0xfe) ^ 1;
}



int wifi_mgmr_psk_cal(char *password,char *ssid,int ssid_len,char *output)

{
  int iVar1;
  uchar auStack48 [4];
  char psk [32];
  
  iVar1 = bl60x_fw_password_hash(password,(uchar *)ssid,ssid_len,auStack48);
  if (iVar1 == 0) {
    utils_bin2hex(output,auStack48,0x20);
  }
  return iVar1;
}



int wifi_mgmr_drv_init(wifi_conf_t *conf)

{
  bl606a0_wifi_init(conf);
  wifi_mgmr_api_set_country_code((char *)conf);
  wifi_mgmr_init();
  wifi_mgmr_api_ifaceup();
  return 0;
}



// WARNING: Variable defined which should be unmapped: gw

wifi_interface_t wifi_mgmr_sta_enable(void)

{
  int done;
  int iVar1;
  ip4_addr_t iStack28;
  ip4_addr_t ipaddr;
  ip4_addr_t netmask;
  ip4_addr_t gw;
  
  if (done == 1) {
    printf("----- BUG FIXME? NOT do STA enable again\r\n");
  }
  else {
    done = 1;
    printf("---------STA enable\r\n");
    wifiMgmr.wlan_sta.mode = 0;
    iStack28 = (ip4_addr_t)0x0;
    ipaddr = 0;
    netmask = 0;
    memcpy(wifiMgmr.wlan_sta.netif.hwaddr,wifiMgmr.wlan_sta.mac,6);
    iVar1 = mac_is_unvalid(wifiMgmr.wlan_sta.netif.hwaddr);
    if (iVar1 != 0) {
      bl_wifi_mac_addr_get(wifiMgmr.wlan_sta.netif.hwaddr);
      iVar1 = mac_is_unvalid(wifiMgmr.wlan_sta.netif.hwaddr);
      if (iVar1 != 0) {
        wifiMgmr.wlan_sta.netif.hwaddr._0_2_ = 0x50c0;
        wifiMgmr.wlan_sta.netif.hwaddr._2_4_ = 0x100c943;
      }
      memcpy(wifiMgmr.wlan_sta.mac,wifiMgmr.wlan_sta.netif.hwaddr,6);
    }
    netifapi_netif_add(&wifiMgmr.wlan_sta.netif,&iStack28,&ipaddr,&netmask,(void *)0x0,
                       bl606a0_wifi_netif_init,tcpip_input);
    wifiMgmr.wlan_sta.netif.name = 0x7473;
    wifiMgmr.wlan_sta.netif.flags = wifiMgmr.wlan_sta.netif.flags | 0x24;
    netif_set_default(&wifiMgmr.wlan_sta.netif);
    netif_set_up(&wifiMgmr.wlan_sta.netif);
  }
  return &wifiMgmr.wlan_sta;
}



int wifi_mgmr_sta_disable(wifi_interface_t *interface)

{
  wifi_mgmr_api_idle();
  return 0;
}



int wifi_mgmr_sta_ip_get(uint32_t *ip,uint32_t *gw,uint32_t *mask)

{
  *ip = wifiMgmr.wlan_sta.netif.ip_addr;
  *mask = wifiMgmr.wlan_sta.netif.netmask;
  *gw = wifiMgmr.wlan_sta.netif.gw;
  return 0;
}



int wifi_mgmr_sta_dns_get(uint32_t *dns1,uint32_t *dns2)

{
  ip_addr_t *piVar1;
  
  piVar1 = dns_getserver('\0');
  *dns1 = piVar1->addr;
  piVar1 = dns_getserver('\x01');
  *dns2 = piVar1->addr;
  return 0;
}



int wifi_mgmr_sta_ip_set(uint32_t ip,uint32_t mask,uint32_t gw,uint32_t dns1,uint32_t dns2)

{
  vTaskEnterCritical();
  wifiMgmr.wlan_sta.ipv4.ip = ip;
  wifiMgmr.wlan_sta.ipv4.mask = mask;
  wifiMgmr.wlan_sta.ipv4.gw = gw;
  wifiMgmr.wlan_sta.ipv4.dns1 = dns1;
  wifiMgmr.wlan_sta.ipv4.dns2 = dns2;
  vTaskExitCritical();
  wifi_mgmr_api_ip_update();
  return 0;
}



int wifi_mgmr_sta_ip_unset(void)

{
  int iVar1;
  
  iVar1 = wifi_mgmr_sta_ip_set(0,0,0,0,0);
  return iVar1;
}



int wifi_mgmr_sta_disconnect(void)

{
  wifi_mgmr_api_disconnect();
  return 0;
}



int wifi_mgmr_sta_powersaving(int ps)

{
  if ((ps == 1) || (ps == 2)) {
    wifi_mgmr_api_fw_powersaving(ps);
    ps = 0;
  }
  else {
    if (ps == 0) {
      wifi_mgmr_api_fw_powersaving(0);
    }
    else {
      ps = -1;
    }
  }
  return ps;
}



int wifi_mgmr_sta_autoconnect_enable(void)

{
  wifi_mgmr_api_enable_autoreconnect();
  return 0;
}



int wifi_mgmr_sta_autoconnect_disable(void)

{
  wifi_mgmr_api_disable_autoreconnect();
  return 0;
}



void wifi_mgmr_sta_connect_ind_stat_get(wifi_mgmr_sta_connect_ind_stat_info_t *wifi_mgmr_ind_stat)

{
  size_t __n;
  
  __n = strlen(wifiMgmr.wifi_mgmr_stat_info.ssid);
  if (0 < (int)__n) {
    memcpy(wifi_mgmr_ind_stat->ssid,wifiMgmr.wifi_mgmr_stat_info.ssid,__n);
    wifi_mgmr_ind_stat->ssid[__n] = '\0';
  }
  __n = strlen(wifiMgmr.wifi_mgmr_stat_info.psk);
  if (0 < (int)__n) {
    memcpy(wifi_mgmr_ind_stat->psk,wifiMgmr.wifi_mgmr_stat_info.psk,__n);
    wifi_mgmr_ind_stat->psk[__n] = '\0';
  }
  memcpy(wifi_mgmr_ind_stat->bssid,wifiMgmr.wifi_mgmr_stat_info.bssid,6);
  wifi_mgmr_ind_stat->status_code = wifiMgmr.wifi_mgmr_stat_info.status_code;
  wifi_mgmr_ind_stat->chan_band = wifiMgmr.wifi_mgmr_stat_info.chan_band;
  wifi_mgmr_ind_stat->chan_freq = wifiMgmr.wifi_mgmr_stat_info.chan_freq;
  wifi_mgmr_ind_stat->type_ind = wifiMgmr.wifi_mgmr_stat_info.type_ind;
  printf("wifi mgmr ind status code = %d\r\n");
  printf("ssid: %s, psk: %s, band: %d, freq: %d, type_ind: %d\r\n",wifi_mgmr_ind_stat->ssid,
         wifi_mgmr_ind_stat->psk,(uint)wifi_mgmr_ind_stat->chan_band,
         (uint)wifi_mgmr_ind_stat->chan_freq,(uint)wifi_mgmr_ind_stat->type_ind);
  printf("bssid: %02x%02x%02x%02x%02x%02x\r\n",(uint)wifi_mgmr_ind_stat->bssid[0],
         (uint)wifi_mgmr_ind_stat->bssid[1],(uint)wifi_mgmr_ind_stat->bssid[2],
         (uint)wifi_mgmr_ind_stat->bssid[3],(uint)wifi_mgmr_ind_stat->bssid[4],
         (uint)wifi_mgmr_ind_stat->bssid[5]);
  return;
}



void wifi_mgmr_sta_ssid_set(char *ssid)

{
  size_t __n;
  
  __n = strlen(ssid);
  if (__n != 0) {
    __n = strlen(ssid);
    memcpy(wifiMgmr.wifi_mgmr_stat_info.ssid,ssid,__n);
    return;
  }
  return;
}



void wifi_mgmr_sta_psk_set(char *psk)

{
  size_t __n;
  
  __n = strlen(psk);
  if (__n != 0) {
    __n = strlen(psk);
    memcpy(wifiMgmr.wifi_mgmr_stat_info.psk,psk,__n);
    return;
  }
  return;
}



int wifi_mgmr_sta_connect
              (wifi_interface_t *wifi_interface,char *ssid,char *psk,char *pmk,uint8_t *mac,
              uint8_t band,uint16_t freq)

{
  int iVar1;
  
  wifi_mgmr_sta_ssid_set(ssid);
  wifi_mgmr_sta_psk_set(psk);
  iVar1 = wifi_mgmr_api_connect(ssid,psk,pmk,mac,band,freq);
  return iVar1;
}



// WARNING: Variable defined which should be unmapped: gw

wifi_interface_t wifi_mgmr_ap_enable(void)

{
  int iVar1;
  ip4_addr_t iStack28;
  ip4_addr_t ipaddr;
  ip4_addr_t netmask;
  ip4_addr_t gw;
  
  wifiMgmr.wlan_ap.mode = 1;
  iStack28 = (ip4_addr_t)0x10ba8c0;
  ipaddr = 0xffffff;
  netmask = 0;
  memcpy(wifiMgmr.wlan_ap.netif.hwaddr,wifiMgmr.wlan_ap.mac,6);
  iVar1 = mac_is_unvalid(wifiMgmr.wlan_ap.netif.hwaddr);
  if (iVar1 != 0) {
    bl_wifi_mac_addr_get(wifiMgmr.wlan_ap.netif.hwaddr);
    iVar1 = mac_is_unvalid(wifiMgmr.wlan_ap.netif.hwaddr);
    if (iVar1 != 0) {
      wifiMgmr.wlan_ap.netif.hwaddr._0_2_ = 0x50c0;
      wifiMgmr.wlan_ap.netif.hwaddr._2_4_ = 0x100c943;
    }
    memcpy(wifiMgmr.wlan_ap.mac,wifiMgmr.wlan_ap.netif.hwaddr,6);
  }
  netifapi_netif_add(&wifiMgmr.wlan_ap.netif,&iStack28,&ipaddr,&netmask,(void *)0x0,
                     bl606a0_wifi_netif_init,tcpip_input);
  wifiMgmr.wlan_ap.netif.name = 0x7061;
  netif_set_default(&wifiMgmr.wlan_ap.netif);
  netif_set_up(&wifiMgmr.wlan_ap.netif);
  return &wifiMgmr.wlan_ap;
}



int wifi_mgmr_ap_start(wifi_interface_t *interface,char *ssid,int hidden_ssid,char *passwd,
                      int channel)

{
  wifi_mgmr_api_ap_start(ssid,passwd,channel,(uint8_t)hidden_ssid);
  return 0;
}



int wifi_mgmr_ap_stop(wifi_interface_t *interface)

{
  wifi_mgmr_api_ap_stop();
  return 0;
}



int wifi_mgmr_ap_sta_cnt_get(uint8_t *sta_cnt)

{
  wifi_mgmr_ap_sta_cnt_get_internal(sta_cnt);
  return 0;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Could not reconcile some variable overlaps

int wifi_mgmr_ap_sta_info_get(wifi_sta_basic_info *sta_info,uint8_t idx)

{
  undefined2 uStack40;
  wifi_mgmr_sta_basic_info sta_info_internal;
  
  memset(&uStack40,0,0x18);
  wifi_mgmr_ap_sta_info_get_internal((wifi_mgmr_sta_basic_info_t *)&uStack40,idx);
  *(undefined2 *)sta_info = uStack40;
  sta_info->rssi = sta_info_internal.tsflo;
  sta_info->tsflo = sta_info_internal.tsfhi;
  sta_info->tsfhi = sta_info_internal.sta_mac._2_4_;
  sta_info->data_rate = (uint8_t)sta_info_internal.rssi;
  memcpy(sta_info->sta_mac,&uStack40 + 1,6);
  return 0;
}



int wifi_mgmr_ap_sta_delete(uint8_t sta_idx)

{
  wifi_mgmr_ap_sta_delete_internal(sta_idx);
  return 0;
}



int wifi_mgmr_sniffer_register(void *env,sniffer_cb_t *cb)

{
  bl_rx_pkt_cb_register(env,(wifi_event_pkt_cb_t *)cb);
  return 0;
}



int wifi_mgmr_sniffer_unregister(void *env)

{
  bl_rx_pkt_cb_unregister(env);
  return 0;
}



int wifi_mgmr_sniffer_enable(void)

{
  wifi_mgmr_api_sniffer_enable();
  return 0;
}



int wifi_mgmr_sniffer_disable(void)

{
  wifi_mgmr_api_idle();
  return 0;
}



int wifi_mgmr_rate_config(uint16_t config)

{
  WIFI_MGMR_EVENT_T WStack32;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  undefined uStack28;
  undefined uStack27;
  undefined uStack26;
  undefined uStack25;
  undefined uStack24;
  undefined uStack23;
  undefined uStack22;
  undefined uStack21;
  undefined uStack20;
  
  memset(&WStack32,0,0xd);
  WStack32 = WIFI_MGMR_EVENT_APP_RC_CONFIG;
  uStack27 = 0x88;
  uStack26 = 0x77;
  uStack25 = 0x66;
  uStack31 = (undefined)config;
  uStack24 = 0x55;
  uStack30 = (undefined)(config >> 8);
  uStack29 = 0;
  uStack28 = 0;
  uStack23 = 0xd;
  uStack22 = 0;
  uStack21 = 0;
  uStack20 = 0;
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&WStack32);
  return 0;
}



int wifi_mgmr_conf_max_sta(uint8_t max_sta_supported)

{
  WIFI_MGMR_EVENT_T WStack32;
  uint8_t uStack31;
  undefined uStack30;
  undefined uStack29;
  undefined uStack28;
  undefined uStack27;
  undefined uStack26;
  undefined uStack25;
  undefined uStack24;
  undefined uStack23;
  undefined uStack22;
  undefined uStack21;
  undefined uStack20;
  
  memset(&WStack32,0,0xd);
  WStack32 = WIFI_MGMR_EVENT_APP_CONF_MAX_STA;
  uStack27 = 0x88;
  uStack26 = 0x77;
  uStack25 = 0x66;
  uStack24 = 0x55;
  uStack30 = 0;
  uStack29 = 0;
  uStack28 = 0;
  uStack23 = 0xd;
  uStack22 = 0;
  uStack21 = 0;
  uStack20 = 0;
  uStack31 = max_sta_supported;
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&WStack32);
  return 0;
}



int wifi_mgmr_state_get(int *state)

{
  uint16_t uVar1;
  int iVar2;
  
  uVar1 = wifiMgmr.wifi_mgmr_stat_info.status_code;
  if (wifiMgmr.m.currentState == &stateIdle) {
    if (wifiMgmr.inf_ap_enabled != 0) {
      iVar2 = 0x11;
      goto LAB_230051bc;
    }
    iVar2 = 1;
  }
  else {
    if (wifiMgmr.m.currentState == &stateConnecting) {
      if (wifiMgmr.inf_ap_enabled != 0) {
        iVar2 = 0x12;
        goto LAB_230051bc;
      }
      iVar2 = 2;
    }
    else {
      if (wifiMgmr.m.currentState == &stateConnectedIPNo) {
        if (wifiMgmr.inf_ap_enabled == 0) {
          iVar2 = 3;
        }
        else {
          iVar2 = 0x13;
        }
        goto LAB_230051bc;
      }
      if (wifiMgmr.m.currentState == &stateConnectedIPYes) {
        if (wifiMgmr.inf_ap_enabled == 0) {
          iVar2 = 4;
        }
        else {
          iVar2 = 0x14;
        }
        goto LAB_230051bc;
      }
      if (wifiMgmr.m.currentState != &stateDisconnect) {
        if (wifiMgmr.m.currentState == &stateIfaceDown) {
          iVar2 = 6;
        }
        else {
          if (wifiMgmr.m.currentState != &stateSniffer) {
            *state = 0;
            return 0;
          }
          iVar2 = 7;
        }
        goto LAB_230051bc;
      }
      if (wifiMgmr.inf_ap_enabled != 0) {
        iVar2 = 0x15;
        goto LAB_230051bc;
      }
      iVar2 = 5;
    }
  }
  *state = iVar2;
  if (uVar1 == 8) {
    iVar2 = 8;
  }
  else {
    if (uVar1 != 0xc) {
      return 0;
    }
    iVar2 = 9;
  }
LAB_230051bc:
  *state = iVar2;
  return 0;
}



int wifi_mgmr_rssi_get(int *rssi)

{
  *rssi = (int)wifiMgmr.wlan_sta.field_5;
  return 0;
}



int wifi_mgmr_raw_80211_send(uint8_t *pkt,int len)

{
  if (len < 0x1e1) {
    wifi_mgmr_api_raw_send(pkt,len);
    return 0;
  }
  return -1;
}



int wifi_mgmr_scan(void *data,scan_complete_cb_t *cb)

{
  scan_cb = cb;
  scan_data = data;
  wifi_mgmr_api_fw_scan();
  return 0;
}



int wifi_mgmr_cfg_req(uint32_t ops,uint32_t task,uint32_t element,uint32_t type,uint32_t length,
                     uint32_t *buf)

{
  int iVar1;
  WIFI_MGMR_EVENT_T WStack100;
  undefined uStack99;
  undefined uStack98;
  undefined uStack97;
  undefined uStack96;
  undefined uStack95;
  undefined uStack94;
  undefined uStack93;
  undefined uStack92;
  undefined uStack91;
  undefined uStack90;
  undefined uStack89;
  undefined uStack88;
  undefined uStack87;
  undefined uStack86;
  undefined uStack85;
  undefined uStack84;
  undefined uStack83;
  undefined uStack82;
  undefined uStack81;
  undefined uStack80;
  undefined uStack79;
  undefined uStack78;
  undefined uStack77;
  undefined uStack76;
  undefined uStack75;
  undefined uStack74;
  undefined uStack73;
  undefined uStack72;
  undefined uStack71;
  undefined uStack70;
  undefined uStack69;
  undefined uStack68;
  undefined auStack67 [39];
  
  if (length < 0x21) {
    memset(&WStack100,0,0x41);
    WStack100 = WIFI_MGMR_EVENT_FW_CFG_REQ;
    uStack99 = 0x44;
    uStack98 = 0x33;
    uStack97 = 0x22;
    uStack96 = 0x11;
    uStack95 = 0x88;
    uStack94 = 0x77;
    iVar1 = length + 0xc6;
    uStack93 = 0x66;
    uStack92 = 0x55;
    uStack90 = (undefined)((uint)iVar1 >> 8);
    uStack89 = (undefined)((uint)iVar1 >> 0x10);
    uStack86 = (undefined)(ops >> 8);
    uStack85 = (undefined)(ops >> 0x10);
    uStack82 = (undefined)(task >> 8);
    uStack81 = (undefined)(task >> 0x10);
    uStack78 = (undefined)(element >> 8);
    uStack77 = (undefined)(element >> 0x10);
    uStack74 = (undefined)(type >> 8);
    uStack73 = (undefined)(type >> 0x10);
    uStack91 = (undefined)iVar1;
    uStack87 = (undefined)ops;
    uStack83 = (undefined)task;
    uStack79 = (undefined)element;
    uStack75 = (undefined)type;
    uStack70 = (undefined)(length >> 8);
    uStack69 = (undefined)(length >> 0x10);
    uStack88 = (undefined)((uint)iVar1 >> 0x18);
    uStack84 = (undefined)(ops >> 0x18);
    uStack80 = (undefined)(task >> 0x18);
    uStack76 = (undefined)(element >> 0x18);
    uStack72 = (undefined)(type >> 0x18);
    uStack71 = (undefined)length;
    uStack68 = (undefined)(length >> 0x18);
    if (length != 0) {
      memcpy(auStack67,buf,length);
    }
    wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&WStack100);
    return 0;
  }
  return -1;
}



int wifi_mgmr_scan_filter_hidden_ssid(int filter)

{
  vTaskEnterCritical();
  if (filter == 0) {
    wifiMgmr.features = wifiMgmr.features | 1;
  }
  else {
    wifiMgmr.features = wifiMgmr.features & 0xfffffffe;
  }
  vTaskExitCritical();
  return 0;
}



int wifi_mgmr_scan_complete_callback(void)

{
  char "wifi_mgmr_scan_complete_callback" [33];
  undefined4 uStack20;
  int status;
  
  uStack20 = 0;
  printf("%s: scan complete\r\n","wifi_mgmr_scan_complete_callback");
  if (scan_cb != (scan_complete_cb_t *)0x0) {
    uStack20 = 1;
    (*scan_cb)(scan_data,&uStack20);
  }
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

int wifi_mgmr_scan_ap_all(wifi_mgmr_ap_item_t *env,uint32_t *param1,scan_item_cb_t *cb)

{
  wifi_mgmr_t *pwVar1;
  TickType_t TVar2;
  undefined auStack84 [4];
  wifi_mgmr_ap_item_t item;
  
  pwVar1 = &wifiMgmr;
  do {
    if (pwVar1->scan_items[0].is_used != '\0') {
      TVar2 = xTaskGetTickCount();
      if (TVar2 - pwVar1->scan_items[0].timestamp_lastseen < (uint)wifiMgmr.scan_item_timeout) {
        memcpy(auStack84,pwVar1->scan_items,0x20);
        item.ssid[28] = '\0';
        item._32_4_ = strlen(auStack84);
        memcpy(&item.ssid_len,pwVar1->scan_items[0].bssid,6);
        item.bssid[2] = pwVar1->scan_items[0].channel;
        item.bssid[4] = pwVar1->scan_items[0].rssi;
        item.bssid[3] = pwVar1->scan_items[0].auth;
        (*cb)(env,param1,(wifi_mgmr_ap_item_t *)auStack84);
      }
    }
    pwVar1 = (wifi_mgmr_t *)&(pwVar1->wlan_sta).netif.input;
  } while (pwVar1 != (wifi_mgmr_t *)0x42017b54);
  return 0;
}



char * wifi_mgmr_status_code_str(uint16_t status_code)

{
  undefined2 in_register_0000202a;
  
  if (CONCAT22(in_register_0000202a,status_code) < 0x11) {
    return *(char **)(CSWTCH_17 + CONCAT22(in_register_0000202a,status_code) * 4);
  }
  return "Unknown Status Code";
}



int wifi_mgmr_profile_add(wifi_mgmr_t *mgmr,wifi_mgmr_profile_msg_t *profile_msg,int index)

{
  wifi_mgmr_profile_t *__s;
  int iVar1;
  
  if (index == -1) {
    __s = mgmr->profiles;
    if (__s == (wifi_mgmr_profile_t *)0x0) {
      return -1;
    }
  }
  else {
    if (mgmr->profiles[0].isUsed == '\0') {
      iVar1 = 0;
    }
    else {
      if (mgmr->profiles[1].isUsed != '\0') {
        return -1;
      }
      iVar1 = 1;
    }
    mgmr->profile_active_index = iVar1;
    __s = mgmr->profiles + iVar1;
    printf("[WF][PF] Using free profile, idx is @%d\r\n");
  }
  memset(__s,0,0xc4);
  *(undefined2 *)&__s->isActive = 0x100;
  __s->ssid_len = profile_msg->ssid_len;
  __s->psk_len = profile_msg->psk_len;
  __s->pmk_len = profile_msg->pmk_len;
  __s->priority = -1;
  memcpy(__s,profile_msg,0x21);
  memcpy(__s->psk,profile_msg->psk,0x41);
  memcpy(__s->pmk,profile_msg->pmk,0x41);
  memcpy(__s->mac,profile_msg->mac,6);
  __s->dhcp_use = profile_msg->dhcp_use;
  return 0;
}



int wifi_mgmr_profile_get(wifi_mgmr_t *mgmr,wifi_mgmr_profile_msg_t *profile_msg)

{
  int iVar1;
  uint8_t *puVar2;
  undefined4 uVar3;
  
  if (mgmr->profiles[0].isUsed == '\x01') {
    iVar1 = 0;
  }
  else {
    iVar1 = 1;
    if (mgmr->profiles[1].isUsed != '\x01') {
      return -1;
    }
  }
  printf("[WF][PF] Using profile, idx is @%d\r\n",iVar1);
  memset(profile_msg,0,0xb9);
  puVar2 = &mgmr->ready + iVar1 * 0xc4;
  uVar3 = *(undefined4 *)(puVar2 + 0x114);
  *(char *)&profile_msg->ssid_len = (char)uVar3;
  *(undefined *)((int)&profile_msg->ssid_len + 1) = (char)((uint)uVar3 >> 8);
  *(undefined *)((int)&profile_msg->ssid_len + 2) = (char)((uint)uVar3 >> 0x10);
  *(undefined *)((int)&profile_msg->ssid_len + 3) = (char)((uint)uVar3 >> 0x18);
  uVar3 = *(undefined4 *)(puVar2 + 0x15c);
  *(char *)&profile_msg->psk_len = (char)uVar3;
  *(undefined *)((int)&profile_msg->psk_len + 1) = (char)((uint)uVar3 >> 8);
  *(undefined *)((int)&profile_msg->psk_len + 2) = (char)((uint)uVar3 >> 0x10);
  *(undefined *)((int)&profile_msg->psk_len + 3) = (char)((uint)uVar3 >> 0x18);
  uVar3 = *(undefined4 *)(puVar2 + 0x1a4);
  *(char *)&profile_msg->pmk_len = (char)uVar3;
  *(undefined *)((int)&profile_msg->pmk_len + 1) = (char)((uint)uVar3 >> 8);
  *(undefined *)((int)&profile_msg->pmk_len + 2) = (char)((uint)uVar3 >> 0x10);
  *(undefined *)((int)&profile_msg->pmk_len + 3) = (char)((uint)uVar3 >> 0x18);
  profile_msg->dhcp_use = puVar2[0x1ae];
  memcpy(profile_msg,mgmr->profiles + iVar1,0x21);
  memcpy(profile_msg->psk,mgmr->profiles[iVar1].psk,0x41);
  memcpy(profile_msg->pmk,mgmr->profiles[iVar1].pmk,0x41);
  memcpy(profile_msg->mac,mgmr->profiles[iVar1].mac,6);
  return 0;
}



int wifi_mgmr_profile_autoreconnect_is_enabled(wifi_mgmr_t *mgmr,int index)

{
  return (uint)(mgmr->disable_autoreconnect == '\0');
}



int wifi_mgmr_profile_autoreconnect_disable(wifi_mgmr_t *mgmr,int index)

{
  mgmr->disable_autoreconnect = '\x01';
  return 0;
}



int wifi_mgmr_profile_autoreconnect_enable(wifi_mgmr_t *mgmr,int index)

{
  mgmr->disable_autoreconnect = '\0';
  return 0;
}



int wifi_netif_dhcp_start(netif *netif)

{
  netifapi_netif_common(netif,(netifapi_void_fn)0x0,dhcp_start);
  return 0;
}



void cb_rssi_ind(void *env,int8_t rssi)

{
  wifiMgmr.wlan_sta.field_5 = rssi;
  return;
}



void cb_probe_resp_ind(void *env)

{
  printf("timestamp = 0x%llx\r\n");
  return;
}



void cb_beacon_ind(void *env,wifi_event_beacon_ind *ind)

{
  wifi_mgmr_api_scan_item_beacon
            (ind->channel,ind->rssi,ind->auth,(uint8_t *)ind,ind->ssid,ind->ssid_len,ind->ppm_abs,
             ind->ppm_rel,DAT_00000010);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void cb_disconnect_ind(void *env,wifi_event_sm_disconnect_ind *ind)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  wifi_mgmr_msg_t msg_wifi;
  
  memset(&local_20,0,0xd);
  printf("sending disconnect\r\n");
  local_20 = WIFI_MGMR_EVENT_FW_IND_DISCONNECT;
  uStack31 = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  msg_wifi.ev = WIFI_MGMR_EVENT_FW_CHANNEL_SET;
  msg_wifi.data1._0_1_ = 0x88;
  msg_wifi.data1._1_1_ = 0x77;
  msg_wifi.data1._2_1_ = 0x66;
  msg_wifi.data1._3_1_ = 0x55;
  msg_wifi.data2._0_1_ = 0xd;
  wifiMgmr.wifi_mgmr_stat_info.type_ind = '\x02';
  wifiMgmr.wifi_mgmr_stat_info.status_code = ind->reason_code;
  msg_wifi.data2._1_1_ = 0;
  msg_wifi.data2._2_1_ = 0;
  msg_wifi.data2._3_1_ = 0;
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void cb_connect_ind(void *env,wifi_event_sm_connect_ind *ind)

{
  WIFI_MGMR_EVENT_T local_20;
  undefined uStack31;
  undefined uStack30;
  undefined uStack29;
  wifi_mgmr_msg_t msg_wifi;
  
  memset(&local_20,0,0xd);
  local_20 = (ind->status_code == 0) + WIFI_MGMR_EVENT_FW_IND_DISCONNECT;
  uStack31 = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  msg_wifi.ev = WIFI_MGMR_EVENT_FW_CHANNEL_SET;
  msg_wifi.data1._0_1_ = 0x88;
  msg_wifi.data1._1_1_ = 0x77;
  msg_wifi.data1._2_1_ = 0x66;
  msg_wifi.data1._3_1_ = 0x55;
  msg_wifi.data2._0_1_ = 0xd;
  msg_wifi.data2._1_1_ = 0;
  msg_wifi.data2._2_1_ = 0;
  msg_wifi.data2._3_1_ = 0;
  wifi_mgmr_set_connect_stat_info(ind,'\x01');
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)&local_20);
  return;
}



void cb_event_ind(void *env,wifi_event *event)

{
  int iVar1;
  uint16_t code;
  uint32_t uVar2;
  
  uVar2 = event->id;
  if (uVar2 == 1) {
    puts("[WIFI] [IND] SCAN Done\r\n");
    wifi_mgmr_scan_complete_notify();
    code = 9;
LAB_23007bdc:
    aos_post_event(2,code,0);
    return;
  }
  if (uVar2 == 0) {
    uVar2 = event[1].id;
    iVar1 = 0x6bc;
    wifiMgmr.channel = uVar2;
  }
  else {
    if (uVar2 == 2) {
      code = 10;
      goto LAB_23007bdc;
    }
    iVar1 = 0x6f8;
  }
  printf("wifi current state: WIFI_STATE_WITH_AP_CONNECTED_IP_GETTING\r\n" + iVar1 + 0x28,uVar2);
  return;
}



int wifi_mgmr_event_init(void)

{
  bl_rx_sm_connect_ind_cb_register((void *)0x0,cb_connect_ind);
  bl_rx_sm_disconnect_ind_cb_register((void *)0x0,cb_disconnect_ind);
  bl_rx_beacon_ind_cb_register((void *)0x0,cb_beacon_ind);
  bl_rx_probe_resp_ind_cb_register((void *)0x0,cb_probe_resp_ind);
  bl_rx_rssi_cb_register((void *)0x0,cb_rssi_ind);
  bl_rx_event_register((void *)0x0,cb_event_ind);
  return 0;
}



int bl_main_disconnect(void)

{
  bl_send_sm_disconnect_req(&wifi_hw,0x34);
  return 0;
}



int bl_main_powersaving(int mode)

{
  int iVar1;
  
  iVar1 = bl_send_mm_powersaving_req(&wifi_hw,mode);
  return iVar1;
}



int bl_main_denoise(int mode)

{
  int iVar1;
  
  iVar1 = bl_send_mm_denoise_req(&wifi_hw,mode);
  return iVar1;
}



int bl_main_monitor(void)

{
  undefined auStack56 [4];
  mm_monitor_cfm cfm;
  
  memset(auStack56,0,0x28);
  bl_send_monitor_enable(&wifi_hw,(mm_monitor_cfm *)auStack56);
  return 0;
}



int bl_main_phy_up(void)

{
  int iVar1;
  
  iVar1 = bl_send_start(&wifi_hw);
  if (iVar1 == 0) {
    wifi_hw.drv_flags = wifi_hw.drv_flags | 4;
  }
  else {
    iVar1 = -1;
  }
  return iVar1;
}



int bl_main_monitor_channel_set(int channel,int use_40MHZ)

{
  undefined auStack56 [4];
  mm_monitor_channel_cfm cfm;
  
  bl_send_monitor_channel_set(&wifi_hw,(mm_monitor_channel_cfm *)auStack56,channel,use_40MHZ);
  return 0;
}



int bl_main_if_remove(uint8_t vif_index)

{
  undefined3 in_register_00002029;
  
  printf("[WF] MM_REMOVE_IF_REQ Sending with vif_index %u...\r\n",
         CONCAT31(in_register_00002029,vif_index));
  bl_send_remove_if(&wifi_hw,vif_index);
  printf("[WF] MM_REMOVE_IF_REQ Done\r\n");
  return 0;
}



int bl_main_raw_send(uint8_t *pkt,int len)

{
  int iVar1;
  
  iVar1 = bl_send_scanu_raw_send(&wifi_hw,pkt,len);
  return iVar1;
}



int bl_main_rate_config(uint8_t sta_idx,uint16_t fixed_rate_cfg)

{
  int iVar1;
  
  iVar1 = bl_send_me_rate_config_req(&wifi_hw,sta_idx,fixed_rate_cfg);
  return iVar1;
}



int bl_main_set_country_code(char *country_code)

{
  bl_msg_update_channel_cfg(country_code);
  bl_send_me_chan_config_req(&wifi_hw);
  return 0;
}



int bl_main_get_channel_nums(void)

{
  return channel_num_default;
}



int bl_main_if_add(int is_sta,netif *netif,uint8_t *vif_index)

{
  uint uVar1;
  int iVar2;
  undefined *puVar3;
  mm_add_if_cfm amStack36 [2];
  mm_add_if_cfm add_if_cfm;
  
  if (is_sta == 0) {
    puVar3 = &UNK_23071888;
  }
  else {
    puVar3 = &UNK_23071884;
  }
  printf("[WF] MM_ADD_IF_REQ Sending: %s\r\n",puVar3);
  iVar2 = bl_send_add_if(&wifi_hw,netif->hwaddr,(is_sta == 0) + NL80211_IFTYPE_STATION,false,
                         amStack36);
  printf("[WF] MM_ADD_IF_REQ Done\r\n");
  if (iVar2 == 0) {
    if (amStack36[0].status == '\0') {
      uVar1 = (uint)amStack36[0].inst_nbr;
      if (is_sta != 0) {
        wifi_hw.vif_index_sta = (uint)amStack36[0].inst_nbr;
        uVar1 = wifi_hw.vif_index_ap;
      }
      wifi_hw.vif_index_ap = uVar1;
      *vif_index = amStack36[0].inst_nbr;
      printf("[WF] vif_index from LAMC is %d\r\n");
      wifi_hw.vif_table[amStack36[0].inst_nbr].dev = netif;
      wifi_hw.vif_table[amStack36[0].inst_nbr].up = true;
    }
    else {
      printf("%s: Status Error(%d)\n",&UNK_230718cc);
      iVar2 = -5;
    }
  }
  return iVar2;
}



int bl_main_apm_start(char *ssid,char *password,int channel,uint8_t vif_index,uint8_t hidden_ssid)

{
  int iVar1;
  undefined3 in_register_00002035;
  apm_start_cfm local_24;
  apm_start_cfm start_ap_cfm;
  
  memset(&local_24,0,4);
  printf("[WF] APM_START_REQ Sending with vif_index %u\r\n",CONCAT31(in_register_00002035,vif_index)
        );
  iVar1 = bl_send_apm_start_req(&wifi_hw,&local_24,ssid,password,channel,vif_index,hidden_ssid);
  printf("[WF] APM_START_REQ Done\r\n");
  printf("[WF] status is %02X\r\n",(uint)local_24.status);
  printf("[WF] vif_idx is %02X\r\n",(uint)local_24.vif_idx);
  printf("[WF] ch_idx is %02X\r\n",(uint)local_24.ch_idx);
  printf("[WF] bcmc_idx is %02X\r\n",(uint)local_24.bcmc_idx);
  wifi_hw.ap_bcmc_idx = (uint)local_24.bcmc_idx;
  return iVar1;
}



int bl_main_apm_stop(uint8_t vif_index)

{
  undefined3 in_register_00002029;
  int iVar1;
  
  printf("[WF] APM_STOP_REQ Sending with vif_index %u\r\n",CONCAT31(in_register_00002029,vif_index))
  ;
  iVar1 = bl_send_apm_stop_req(&wifi_hw,vif_index);
  printf("[WF] APM_STOP_REQ Done\r\n");
  return iVar1;
}



int bl_main_apm_sta_cnt_get(uint8_t *sta_cnt)

{
  *sta_cnt = '\f';
  return 0;
}



int bl_main_apm_sta_info_get(wifi_apm_sta_info *apm_sta_info,uint8_t idx)

{
  undefined3 in_register_0000202d;
  int iVar1;
  
  iVar1 = CONCAT31(in_register_0000202d,idx);
  if (wifi_hw.sta_table[iVar1].is_used != '\0') {
    apm_sta_info->sta_idx = wifi_hw.sta_table[iVar1].sta_idx;
    apm_sta_info->is_used = wifi_hw.sta_table[iVar1].is_used;
    apm_sta_info->rssi = (int)wifi_hw.sta_table[iVar1].rssi;
    apm_sta_info->tsflo = wifi_hw.sta_table[iVar1].tsflo;
    apm_sta_info->tsfhi = wifi_hw.sta_table[iVar1].tsfhi;
    apm_sta_info->data_rate = wifi_hw.sta_table[iVar1].data_rate;
    memcpy(apm_sta_info->sta_mac,wifi_hw.sta_table + iVar1,6);
    return 0;
  }
  return 0;
}



int bl_main_apm_sta_delete(uint8_t sta_idx)

{
  byte vif_idx;
  undefined3 in_register_00002029;
  int iVar1;
  int iVar2;
  apm_sta_del_cfm aStack36;
  apm_sta_del_cfm sta_del_cfm;
  
  iVar1 = CONCAT31(in_register_00002029,sta_idx);
  memset(&aStack36,0,3);
  vif_idx = wifi_hw.sta_table[iVar1].vif_idx;
  printf("[WF] APM_STA_DEL_REQ: sta_idx = %u, vif_idx = %u\r\n",iVar1,(uint)vif_idx);
  bl_send_apm_sta_del_req(&wifi_hw,&aStack36,sta_idx,vif_idx);
  iVar2 = -1;
  if (aStack36.status == '\0') {
    memset(wifi_hw.sta_table + iVar1,0,0x1c);
    iVar2 = 0;
  }
  return iVar2;
}



int bl_main_apm_remove_all_sta(void)

{
  uint8_t sta_idx;
  u8 *puVar1;
  
  puVar1 = &wifi_hw.sta_table[0].is_used;
  sta_idx = '\0';
  do {
    if (*puVar1 == '\x01') {
      bl_main_apm_sta_delete(sta_idx);
    }
    sta_idx = sta_idx + '\x01';
    puVar1 = puVar1 + 0x1c;
  } while (sta_idx != '\f');
  return 0;
}



int bl_main_conf_max_sta(uint8_t max_sta_supported)

{
  int iVar1;
  
  iVar1 = bl_send_apm_conf_max_sta_req(&wifi_hw,max_sta_supported);
  return iVar1;
}



int bl_main_cfg_task_req
              (uint32_t ops,uint32_t task,uint32_t element,uint32_t type,void *arg1,void *arg2)

{
  int iVar1;
  
  iVar1 = bl_send_cfg_task_req(&wifi_hw,ops,task,element,type,arg1,arg2);
  return iVar1;
}



int bl_main_scan(void)

{
  bl_send_scanu_req(&wifi_hw);
  return 0;
}



int bl_cfg80211_connect(bl_hw *bl_hw,cfg80211_connect_params *sme)

{
  int iVar1;
  sm_connect_cfm asStack20 [4];
  sm_connect_cfm sm_connect_cfm;
  
  iVar1 = bl_send_sm_connect_req(bl_hw,sme,asStack20);
  if (iVar1 == 0) {
    iVar1 = -5;
    if ((byte)asStack20[0] < 10) {
      iVar1 = (int)(char)CSWTCH_6[(byte)asStack20[0]];
    }
  }
  return iVar1;
}



// WARNING: Could not reconcile some variable overlaps

int bl_main_connect(uint8_t *ssid,int ssid_len,uint8_t *psk,int psk_len,uint8_t *pmk,int pmk_len,
                   uint8_t *mac,uint8_t band,uint16_t freq)

{
  short in_stack_00000000;
  nl80211_band anStack272 [4];
  cfg80211_connect_params sme;
  
  memset(anStack272,0,0xf0);
  sme.crypto.cipher_group = 0;
  sme.ssid_len._0_1_ = __NL80211_AUTHTYPE_NUM;
  sme.pmk._0_1_ = (u8)psk_len;
  sme.pmk._1_1_ = (u8)pmk_len;
  if (mac != (uint8_t *)0x0) {
    sme.channel_hint = (ieee80211_channel *)mac;
  }
  if (in_stack_00000000 != 0) {
    sme.channel._4_4_ = 0;
    anStack272[0] = band;
  }
  sme.bssid_hint = ssid;
  sme.ssid = (u8 *)ssid_len;
  sme.crypto.wep_tx_key = (int)psk;
  sme.key = pmk;
  bl_cfg80211_connect(&wifi_hw,(cfg80211_connect_params *)anStack272);
  return 0;
}



void bl_main_event_handle(void)

{
  bl_irq_bottomhalf(&wifi_hw);
  bl_tx_try_flush();
  return;
}



void bl_main_lowlevel_init(void)

{
  bl_irqs_init(&wifi_hw);
  return;
}



int bl_main_rtthread_start(bl_hw **bl_hw)

{
  int iVar1;
  char *fmt;
  
  bl_main_lowlevel_init();
  *bl_hw = &wifi_hw;
  wifi_hw.vifs.next = &wifi_hw.vifs;
  wifi_hw.vifs.prev = &wifi_hw.vifs;
  wifi_hw.mod_params = &bl_mod_params;
  iVar1 = bl_platform_on(&wifi_hw);
  if (iVar1 == 0) {
    ipc_host_enable_irq(wifi_hw.ipc_env,0x7ff);
    bl_wifi_enable_irq();
    iVar1 = bl_send_reset(&wifi_hw);
    if (iVar1 == 0) {
      vTaskDelay(5);
      iVar1 = bl_send_version_req(&wifi_hw,&wifi_hw.version_cfm);
      if (iVar1 != 0) {
        return 0;
      }
      printf("[version] lmac %u.%u.%u.%u\r\n",wifi_hw.version_cfm.version_lmac >> 0x18,
             wifi_hw.version_cfm.version_lmac >> 0x10 & 0xff,
             wifi_hw.version_cfm.version_lmac >> 8 & 0xff,wifi_hw.version_cfm.version_lmac & 0xff);
      printf("[version] version_machw_1 %08X\r\n",wifi_hw.version_cfm.version_machw_1);
      printf("[version] version_machw_2 %08X\r\n",wifi_hw.version_cfm.version_machw_2);
      printf("[version] version_phy_1 %08X\r\n",wifi_hw.version_cfm.version_phy_1);
      printf("[version] version_phy_2 %08X\r\n",wifi_hw.version_cfm.version_phy_2);
      printf("[version] features %08X\r\n",wifi_hw.version_cfm.features);
      iVar1 = bl_handle_dynparams(&wifi_hw);
      if (iVar1 == 0) {
        bl_send_me_config_req(&wifi_hw);
        bl_send_me_chan_config_req(&wifi_hw);
        wifi_hw.status = RWNX_INTERFACE_STATUS_UP;
        return 0;
      }
      fmt = "bl_handle_dynparams Error\r\n";
    }
    else {
      fmt = "bl_send_reset Error\r\n";
    }
  }
  else {
    fmt = "bl_platform_on Error\r\n";
  }
  printf(fmt);
  return 0;
}



int bl_handle_dynparams(bl_hw *bl_hw)

{
  ushort uVar1;
  short sVar2;
  char "bl_handle_dynparams" [20];
  int iVar3;
  short sVar4;
  uint uVar5;
  bl_mod_params *pbVar6;
  
  uVar5 = bl_hw->flags;
  bl_hw->flags = uVar5 | 0x40000;
  pbVar6 = bl_hw->mod_params;
  if (pbVar6->tdls != false) {
    bl_hw->flags = uVar5 | 0x58000;
  }
  if (pbVar6->ap_uapsd_on != false) {
    bl_hw->flags = bl_hw->flags | 0x4000;
  }
  if (5 < (uint)pbVar6->phy_cfg) {
    pbVar6->phy_cfg = 2;
  }
  if (2 < (uint)bl_hw->mod_params->mcs_map) {
    bl_hw->mod_params->mcs_map = 0;
  }
  uVar1 = (bl_hw->ht_cap).cap;
  pbVar6 = bl_hw->mod_params;
  iVar3 = pbVar6->nss;
  (bl_hw->ht_cap).cap = uVar1 | 0x100;
  if (pbVar6->ldpc_on != false) {
    (bl_hw->ht_cap).cap = uVar1 | 0x101;
  }
  sVar2 = (short)iVar3;
  if (pbVar6->use_2040 == false) {
    (bl_hw->ht_cap).mcs.rx_highest = sVar2 * 0x41;
    (bl_hw->ht_cap).mcs.rx_mask[0] = -1;
  }
  else {
    uVar1 = (bl_hw->ht_cap).cap;
    (bl_hw->ht_cap).mcs.rx_mask[4] = '\x01';
    (bl_hw->ht_cap).cap = uVar1 | 2;
    (bl_hw->ht_cap).mcs.rx_highest = sVar2 * 0x87;
  }
  if (1 < iVar3) {
    (bl_hw->ht_cap).cap = (bl_hw->ht_cap).cap | 0x80;
  }
  if (pbVar6->sgi != false) {
    uVar1 = (bl_hw->ht_cap).cap;
    (bl_hw->ht_cap).cap = uVar1 | 0x20;
    if (pbVar6->use_2040 == false) {
      sVar4 = 0x48;
    }
    else {
      (bl_hw->ht_cap).cap = uVar1 | 0x60;
      sVar4 = 0x96;
    }
    (bl_hw->ht_cap).mcs.rx_highest = sVar2 * sVar4;
  }
  (bl_hw->ht_cap).cap = (bl_hw->ht_cap).cap | 0xc;
  if (pbVar6->ht_on == false) {
    (bl_hw->ht_cap).ht_supported = false;
  }
  if (pbVar6->custregd != false) {
    printf("\n\n%s: CAUTION: USING PERMISSIVE CUSTOM REGULATORY RULES\n\n","bl_handle_dynparams");
    return 0;
  }
  return 0;
}



int bl_send_msg(bl_hw *bl_hw,void *msg_params,int reqcfm,lmac_msg_id_t reqid,void *cfm)

{
  ushort uVar1;
  lmac_msg_id_t lVar2;
  bool bVar3;
  char "bl_send_msg" [12];
  bl_cmd *__s;
  int iVar4;
  undefined2 in_register_00002036;
  lmac_msg *pv;
  
  iVar4 = CONCAT22(in_register_00002036,reqid);
  pv = (lmac_msg *)((int)msg_params + -8);
  if ((((((bl_hw->drv_flags >> 2 & 1) == 0) && ((reqid & 0xfffd) != 1)) && (iVar4 != 5)) &&
      ((iVar4 != 0x23 && ((reqid & 0xfffd) != 0x1401)))) && (iVar4 != 0x32)) {
    printf("%s: bypassing (RWNX_DEV_RESTARTING set) 0x%02x\n","bl_send_msg",iVar4);
  }
  else {
    if (bl_hw->ipc_env != (ipc_host_env_tag *)0x0) {
      uVar1 = *(ushort *)((int)msg_params + -8);
      bVar3 = true;
      if (((uVar1 != 0x41) && (uVar1 != 0x50)) && ((uVar1 + 0xebf4 & 0xfffb) != 0)) {
        bVar3 = (uVar1 & 0xfffb) == 0x2408;
      }
      __s = (bl_cmd *)pvPortMalloc(0x40);
      if (__s == (bl_cmd *)0x0) {
        vPortFree(pv);
        printf("%s: failed to allocate mem for cmd, size is %d\r\n",0x23071b08,0x40);
        return -0xc;
      }
      memset(__s,0,0x40);
      __s->result = 4;
      lVar2 = *(lmac_msg_id_t *)((int)msg_params + -8);
      __s->reqid = reqid;
      __s->a2e_msg = pv;
      __s->id = lVar2;
      __s->e2a_msg = cfm;
      if (bVar3) {
        __s->flags = 1;
      }
      if (reqcfm != 0) {
        __s->flags = __s->flags | 2;
      }
      iVar4 = (*(bl_hw->cmd_mgr).queue)(&bl_hw->cmd_mgr,__s);
      if (!bVar3) {
        vPortFree(__s);
        return iVar4;
      }
      return __s->result;
    }
    printf("%s: bypassing (restart must have failed)\r\n",0x23071b08);
  }
  vPortFree(pv);
  return -0x10;
}



void * bl_msg_zalloc(lmac_msg_id_t id,lmac_task_id_t dest_id,uint16_t param_len)

{
  lmac_msg_id_t *__s;
  undefined2 in_register_00002032;
  size_t xWantedSize;
  
  xWantedSize = CONCAT22(in_register_00002032,param_len) + 8;
  __s = (lmac_msg_id_t *)pvPortMalloc(xWantedSize);
  if (__s == (lmac_msg_id_t *)0x0) {
    printf("%s: msg allocation failed\n",0x23071af8);
  }
  else {
    memset(__s,0,xWantedSize);
    *__s = id;
    __s[1] = dest_id;
    __s[2] = 100;
    __s[3] = param_len;
    __s = __s + 4;
  }
  return __s;
}



void bl_msg_update_channel_cfg(char *code)

{
  int iVar1;
  int iVar2;
  char *fmt;
  ieee80211_dot_d *piVar3;
  
  piVar3 = country_list;
  iVar1 = 0;
  do {
    iVar2 = strcmp(piVar3->code,code);
    if (iVar2 == 0) {
      fmt = "[WF] country code %s used, num of channel %d\r\n";
      channel_num_default = country_list[iVar1].channel_num;
      channels_default = country_list[iVar1].channels;
      goto LAB_23008642;
    }
    iVar1 = iVar1 + 1;
    piVar3 = piVar3 + 1;
  } while (iVar1 != 4);
  channel_num_default = 0xe;
  channels_default = bl_channels_24_JP;
  fmt = "[WF] %s NOT found, using JP instead, num of channel %d\r\n";
LAB_23008642:
  printf(fmt,code,channel_num_default);
  return;
}



int bl_msg_get_channel_nums(void)

{
  return channel_num_default;
}



int bl_send_reset(bl_hw *bl_hw)

{
  void *msg_params;
  int iVar1;
  
  msg_params = bl_msg_zalloc(0,0,0);
  if (msg_params != (void *)0x0) {
    iVar1 = bl_send_msg(bl_hw,msg_params,1,1,(void *)0x0);
    return iVar1;
  }
  return -0xc;
}



int bl_send_monitor_enable(bl_hw *bl_hw,mm_monitor_cfm *cfm)

{
  undefined4 *msg_params;
  int iVar1;
  
  msg_params = (undefined4 *)bl_msg_zalloc(0x5c,0,4);
  if (msg_params != (undefined4 *)0x0) {
    *msg_params = 1;
    iVar1 = bl_send_msg(bl_hw,msg_params,1,0x5d,cfm);
    return iVar1;
  }
  return -0xc;
}



int bl_send_monitor_channel_set(bl_hw *bl_hw,mm_monitor_channel_cfm *cfm,int channel,int use_40Mhz)

{
  uint uVar1;
  uint *msg_params;
  int iVar2;
  
  msg_params = (uint *)bl_msg_zalloc(0x5e,0,0xc);
  if (msg_params == (uint *)0x0) {
    return -0xc;
  }
  if (channel - 1U < 0xe) {
    if (channel == 0xe) {
      uVar1 = 0x9b4;
    }
    else {
      uVar1 = channel * 5 + 0x967U & 0xffff;
    }
  }
  else {
    uVar1 = 0xffff;
  }
  *msg_params = uVar1;
  if (use_40Mhz == 0) {
    msg_params[1] = 0;
  }
  else {
    msg_params[1] = 1;
    if (use_40Mhz != 1) {
      msg_params[2] = 1;
      goto LAB_23008764;
    }
  }
  msg_params[2] = 0;
LAB_23008764:
  iVar2 = bl_send_msg(bl_hw,msg_params,1,0x5f,cfm);
  return iVar2;
}



int bl_send_version_req(bl_hw *bl_hw,mm_version_cfm *cfm)

{
  void *msg_params;
  int iVar1;
  
  msg_params = bl_msg_zalloc(4,0,0);
  if (msg_params != (void *)0x0) {
    iVar1 = bl_send_msg(bl_hw,msg_params,1,5,cfm);
    return iVar1;
  }
  return -0xc;
}



int bl_send_me_config_req(bl_hw *bl_hw)

{
  u8 *puVar1;
  u16 *msg_params;
  int iVar2;
  u8 *puVar3;
  ieee80211_mcs_info *piVar4;
  
  msg_params = (u16 *)bl_msg_zalloc(0x1400,5,0x34);
  if (msg_params != (u16 *)0x0) {
    printf("[ME] HT supp %d, VHT supp %d\r\n",1,0);
    msg_params[0x17] = 1;
    *msg_params = (bl_hw->ht_cap).cap;
    *(u8 *)(msg_params + 1) = (bl_hw->ht_cap).ampdu_density << 2 | (bl_hw->ht_cap).ampdu_factor;
    piVar4 = &(bl_hw->ht_cap).mcs;
    puVar3 = (u8 *)((int)msg_params + 3);
    while (piVar4 != (ieee80211_mcs_info *)&bl_hw->vif_started) {
      puVar1 = piVar4->rx_mask;
      piVar4 = (ieee80211_mcs_info *)(piVar4->rx_mask + 1);
      *puVar3 = *puVar1;
      puVar3 = puVar3 + 1;
    }
    msg_params[10] = 0;
    *(undefined4 *)(msg_params + 0xc) = 0;
    *(undefined *)(msg_params + 0xe) = 0;
    *(_Bool *)(msg_params + 0x18) = bl_hw->mod_params->ps_on;
    msg_params[0x16] = (u16)bl_hw->mod_params->tx_lft;
    iVar2 = bl_send_msg(bl_hw,msg_params,1,0x1401,(void *)0x0);
    return iVar2;
  }
  return -0xc;
}



int bl_send_me_chan_config_req(bl_hw *bl_hw)

{
  byte bVar1;
  void *msg_params;
  int iVar2;
  uint uVar3;
  u16 *puVar4;
  
  msg_params = bl_msg_zalloc(0x1402,5,0xfe);
  if (msg_params == (void *)0x0) {
    return -0xc;
  }
  *(undefined *)((int)msg_params + 0xfc) = 0;
  iVar2 = 0;
  while (iVar2 < channel_num_default) {
    bVar1 = *(byte *)((int)msg_params + 0xfc);
    puVar4 = (u16 *)((uint)bVar1 * 6 + (int)msg_params);
    *(undefined *)((int)puVar4 + 3) = 0;
    if ((channels_default[iVar2].flags & 1) != 0) {
      *(undefined *)((int)puVar4 + 3) = 2;
    }
    uVar3 = channels_default[iVar2].flags;
    *(undefined *)(puVar4 + 1) = 0;
    *(byte *)((int)puVar4 + 3) = (uVar3 & 10) != 0 | *(byte *)((int)puVar4 + 3);
    *puVar4 = channels_default[iVar2].center_freq;
    *(char *)(puVar4 + 2) = (char)channels_default[iVar2].max_power;
    uVar3 = (uint)bVar1 + 1 & 0xff;
    *(undefined *)((int)msg_params + 0xfc) = (char)uVar3;
    if (uVar3 == 0xe) break;
    iVar2 = iVar2 + 1;
  }
  *(undefined *)((int)msg_params + 0xfd) = 0;
  iVar2 = bl_send_msg(bl_hw,msg_params,1,0x1403,(void *)0x0);
  return iVar2;
}



int bl_send_me_rate_config_req(bl_hw *bl_hw,uint8_t sta_idx,uint16_t fixed_rate_cfg)

{
  uint8_t *msg_params;
  int iVar1;
  
  msg_params = (uint8_t *)bl_msg_zalloc(0x1410,5,4);
  if (msg_params != (uint8_t *)0x0) {
    *msg_params = sta_idx;
    *(uint16_t *)(msg_params + 2) = fixed_rate_cfg;
    iVar1 = bl_send_msg(bl_hw,msg_params,0,0,(void *)0x0);
    return iVar1;
  }
  return -0xc;
}



int bl_send_start(bl_hw *bl_hw)

{
  void *__dest;
  int iVar1;
  
  __dest = bl_msg_zalloc(2,0,0x48);
  if (__dest != (void *)0x0) {
    (bl_hw->phy_config).parameters[0] = 1;
    memcpy(__dest,&bl_hw->phy_config,0x40);
    *(int *)((int)__dest + 0x40) = bl_hw->mod_params->uapsd_timeout;
    *(undefined2 *)((int)__dest + 0x44) = (short)bl_hw->mod_params->lp_clk_ppm;
    iVar1 = bl_send_msg(bl_hw,__dest,1,3,(void *)0x0);
    return iVar1;
  }
  return -0xc;
}



int bl_send_add_if(bl_hw *bl_hw,uchar *mac,nl80211_iftype iftype,_Bool p2p,mm_add_if_cfm *cfm)

{
  undefined *msg_params;
  int iVar1;
  undefined uVar2;
  
  msg_params = (undefined *)bl_msg_zalloc(6,0,8);
  if (msg_params == (undefined *)0x0) {
    return -0xc;
  }
  memcpy(msg_params + 1,mac,6);
  switch((uint)iftype - 1 & 0xff) {
  case 0:
    uVar2 = 1;
    break;
  case 3:
    return -1;
  case 6:
    uVar2 = 3;
    break;
  case 7:
    msg_params[7] = 1;
  default:
    *msg_params = 0;
    goto LAB_23008a6e;
  case 8:
    msg_params[7] = 1;
  case 2:
    uVar2 = 2;
  }
  *msg_params = uVar2;
LAB_23008a6e:
  iVar1 = bl_send_msg(bl_hw,msg_params,1,7,cfm);
  return iVar1;
}



int bl_send_remove_if(bl_hw *bl_hw,uint8_t inst_nbr)

{
  uint8_t *msg_params;
  int iVar1;
  
  msg_params = (uint8_t *)bl_msg_zalloc(8,0,1);
  if (msg_params != (uint8_t *)0x0) {
    *msg_params = inst_nbr;
    iVar1 = bl_send_msg(bl_hw,msg_params,1,9,(void *)0x0);
    return iVar1;
  }
  return -0xc;
}



int bl_send_scanu_req(bl_hw *bl_hw)

{
  u16 uVar1;
  u16 *msg_params;
  int iVar2;
  ieee80211_channel *piVar3;
  int iVar4;
  u16 *puVar5;
  
  msg_params = (u16 *)bl_msg_zalloc(0x1000,4,0x154);
  if (msg_params != (u16 *)0x0) {
    iVar4 = bl_hw->vif_index_sta;
    msg_params[0xa6] = 0;
    *(char *)(msg_params + 0xa7) = (char)iVar4;
    iVar4 = channel_num_default;
    *(undefined *)((int)msg_params + 0x14f) = (char)channel_num_default;
    *(undefined4 *)(msg_params + 0xa0) = 0xffffffff;
    msg_params[0xa2] = 0xffff;
    msg_params[0xa8] = 0x100;
    *(undefined4 *)(msg_params + 0xa4) = 0;
    iVar2 = 0;
    puVar5 = msg_params;
    while (iVar2 < (int)(iVar4 & 0xffU)) {
      piVar3 = channels_default + iVar2;
      *(nl80211_band *)(puVar5 + 1) = piVar3->band;
      uVar1 = piVar3->center_freq;
      *(undefined *)((int)puVar5 + 3) = 1;
      *puVar5 = uVar1;
      *(char *)(puVar5 + 2) = (char)piVar3->max_reg_power;
      iVar2 = iVar2 + 1;
      puVar5 = puVar5 + 3;
    }
    iVar4 = bl_send_msg(bl_hw,msg_params,0,0,(void *)0x0);
    return iVar4;
  }
  return -0xc;
}



int bl_send_scanu_raw_send(bl_hw *bl_hw,uint8_t *pkt,int len)

{
  uint8_t **msg_params;
  int iVar1;
  undefined auStack36 [4];
  scanu_raw_send_cfm cfm;
  
  msg_params = (uint8_t **)bl_msg_zalloc(0x1005,4,8);
  if (msg_params == (uint8_t **)0x0) {
    iVar1 = -0xc;
  }
  else {
    *msg_params = pkt;
    *(int *)(msg_params + 1) = len;
    iVar1 = bl_send_msg(bl_hw,msg_params,1,0x1006,auStack36);
  }
  return iVar1;
}



int bl_send_sm_connect_req(bl_hw *bl_hw,cfg80211_connect_params *sme,sm_connect_cfm *cfm)

{
  _Bool _Var1;
  char "bl_send_sm_connect_req" [23];
  undefined *msg_params;
  int iVar2;
  nl80211_auth_type nVar3;
  u32 uVar4;
  uint uVar5;
  uint uVar6;
  __be16 _Var7;
  u8 *puVar8;
  uint __n;
  
  msg_params = (undefined *)bl_msg_zalloc(0x1800,6,0x1c4);
  if (msg_params == (undefined *)0x0) {
    return -0xc;
  }
  __n = 0;
  if ((sme->crypto).n_ciphers_pairwise != 0) {
    uVar4 = (sme->crypto).ciphers_pairwise[0];
    __n = 4;
    if ((1 < uVar4 - 0xfac01) && (__n = 0, uVar4 == 0xfac05)) {
      __n = 4;
    }
  }
  if ((sme->crypto).control_port != false) {
    __n = __n | 1;
  }
  if ((sme->crypto).control_port_no_encrypt != false) {
    __n = __n | 2;
  }
  if (((sme->crypto).cipher_group & 0xfffffffb) != 0xfac01) {
    __n = __n | 8;
  }
  if (sme->mfp == NL80211_MFP_REQUIRED) {
    __n = __n | 0x10;
  }
  _Var7 = (sme->crypto).control_port_ethertype;
  if (_Var7 == 0) {
    _Var7 = 0x888e;
  }
  *(__be16 *)(msg_params + 0x34) = _Var7;
  puVar8 = sme->bssid;
  if (puVar8 == (u8 *)0x0) {
LAB_23008cb8:
    memcpy(msg_params + 0x22,&mac_addr_bcst,6);
  }
  else {
    if (*puVar8 == -1) {
      uVar5 = 0;
      if (((puVar8[1] == -1) && (puVar8[2] == -1)) &&
         ((puVar8[3] == -1 && ((puVar8[4] == -1 && (puVar8[5] == -1)))))) goto LAB_23008cb8;
    }
    else {
      if ((((*puVar8 == '\0') && (puVar8[1] == '\0')) && (puVar8[2] == '\0')) &&
         ((puVar8[3] == '\0' && (uVar5 = (uint)puVar8[4], puVar8[4] == 0)))) {
        if (puVar8[5] == '\0') goto LAB_23008cb8;
      }
      else {
        uVar5 = 0;
      }
    }
    do {
      uVar6 = uVar5 + 1;
      msg_params[uVar5 + 0x22] = sme->bssid[uVar5];
      uVar5 = uVar6;
    } while (uVar6 != 6);
  }
  msg_params[0x3d] = (char)bl_hw->vif_index_sta;
  if ((sme->channel).center_freq == 0) {
    *(undefined2 *)(msg_params + 0x28) = 0xffff;
  }
  else {
    msg_params[0x2a] = (sme->channel).band;
    *(u16 *)(msg_params + 0x28) = (sme->channel).center_freq;
    *(bool *)(msg_params + 0x2b) = ((sme->channel).flags & 10) != 0;
  }
  uVar5 = 0;
  while (uVar5 < sme->ssid_len) {
    msg_params[uVar5 + 1] = sme->ssid[uVar5];
    uVar5 = uVar5 + 1;
  }
  *msg_params = (char)sme->ssid_len;
  *(uint *)(msg_params + 0x30) = __n;
  __n = sme->ie_len;
  if (0x100 < __n) {
    printf("%s:%d\r\n","bl_send_sm_connect_req",0x30a);
    return -0x16;
  }
  if (__n != 0) {
    memcpy(msg_params + 0x40,sme->ie,__n);
  }
  *(short *)(msg_params + 0x36) = (short)sme->ie_len;
  _Var1 = bl_mod_params.listen_bcmc;
  *(short *)(msg_params + 0x38) = (short)bl_mod_params.listen_itv;
  msg_params[0x3a] = _Var1 ^ 1;
  nVar3 = sme->auth_type;
  if (nVar3 == __NL80211_AUTHTYPE_NUM) {
    nVar3 = NL80211_AUTHTYPE_OPEN_SYSTEM;
  }
  msg_params[0x3b] = nVar3;
  msg_params[0x3c] = (char)bl_mod_params.uapsd_queues;
  msg_params[0x140] = 1;
  if (sme->key_len != 0) {
    memcpy(msg_params + 0x141,sme->key,(uint)sme->key_len);
  }
  if (sme->pmk_len != 0) {
    memcpy(msg_params + 0x181,sme->pmk,(uint)sme->pmk_len);
  }
  iVar2 = bl_send_msg(bl_hw,msg_params,1,0x1801,cfm);
  return iVar2;
}



int bl_send_sm_disconnect_req(bl_hw *bl_hw,u16 reason)

{
  u16 *msg_params;
  int iVar1;
  
  msg_params = (u16 *)bl_msg_zalloc(0x1803,6,4);
  if (msg_params != (u16 *)0x0) {
    *msg_params = reason;
    *(char *)(msg_params + 1) = (char)bl_hw->vif_index_sta;
    iVar1 = bl_send_msg(bl_hw,msg_params,1,0x1804,(void *)0x0);
    return iVar1;
  }
  return -0xc;
}



int bl_send_mm_powersaving_req(bl_hw *bl_hw,int mode)

{
  undefined *msg_params;
  int iVar1;
  
  msg_params = (undefined *)bl_msg_zalloc(0x31,0,1);
  if (msg_params != (undefined *)0x0) {
    *msg_params = (char)mode;
    iVar1 = bl_send_msg(bl_hw,msg_params,1,0x32,(void *)0x0);
    return iVar1;
  }
  return -0xc;
}



int bl_send_mm_denoise_req(bl_hw *bl_hw,int mode)

{
  undefined *msg_params;
  int iVar1;
  
  msg_params = (undefined *)bl_msg_zalloc(0x30,0,1);
  if (msg_params != (undefined *)0x0) {
    *msg_params = (char)mode;
    iVar1 = bl_send_msg(bl_hw,msg_params,1,0x32,(void *)0x0);
    return iVar1;
  }
  return -0xc;
}



int bl_send_apm_start_req
              (bl_hw *bl_hw,apm_start_cfm *cfm,char *ssid,char *password,int channel,
              uint8_t vif_index,uint8_t hidden_ssid)

{
  void *msg_params;
  size_t __n;
  int iVar1;
  uint uVar2;
  undefined auStack44 [4];
  uint8_t rate [12];
  
  memcpy(auStack44,&DAT_23071aec,0xc);
  msg_params = bl_msg_zalloc(0x1c00,7,0xa8);
  if (msg_params == (void *)0x0) {
    iVar1 = -0xc;
  }
  else {
    *(undefined *)((int)msg_params + 0x10) = 0;
    if (channel - 1U < 0xe) {
      if (channel == 0xe) {
        uVar2 = 0x9b4;
      }
      else {
        uVar2 = channel * 5 + 0x967U & 0xffff;
      }
    }
    else {
      uVar2 = 0xffff;
    }
    *(undefined2 *)((int)msg_params + 0xe) = (short)uVar2;
    *(uint *)((int)msg_params + 0x14) = uVar2;
    *(undefined2 *)((int)msg_params + 0x28) = 100;
    *(undefined4 *)((int)msg_params + 0x2c) = 8;
    *(undefined2 *)((int)msg_params + 0x30) = 0x8e88;
    *(undefined *)((int)msg_params + 0x32) = 6;
    *(uint8_t *)((int)msg_params + 0x1d) = hidden_ssid;
    *(uint8_t *)((int)msg_params + 0x33) = vif_index;
    *(undefined *)((int)msg_params + 0x11) = 0;
    *(undefined *)((int)msg_params + 0x12) = 0;
    *(undefined4 *)((int)msg_params + 0x18) = 0;
    *(undefined *)((int)msg_params + 0x1c) = 0;
    *(undefined4 *)((int)msg_params + 0x20) = 0;
    *(undefined4 *)((int)msg_params + 0x24) = 0;
    __n = strlen(password);
    *(undefined *)((int)msg_params + 0x34) = 1;
    *(bool *)((int)msg_params + 0x66) = __n != 0;
    __n = strlen(ssid);
    memcpy((void *)((int)msg_params + 0x45),ssid,__n);
    __n = strlen(password);
    memcpy((void *)((int)msg_params + 0x67),password,__n);
    __n = strlen(ssid);
    *(undefined *)((int)msg_params + 0x44) = (char)__n;
    *(undefined *)((int)msg_params + 0x35) = 0xc;
    memcpy((void *)((int)msg_params + 0x36),auStack44,0xc);
    *(undefined2 *)((int)msg_params + 0x42) = 0x101;
    iVar1 = bl_send_msg(bl_hw,msg_params,1,0x1c01,cfm);
  }
  return iVar1;
}



int bl_send_apm_stop_req(bl_hw *bl_hw,uint8_t vif_idx)

{
  uint8_t *msg_params;
  int iVar1;
  
  msg_params = (uint8_t *)bl_msg_zalloc(0x1c02,7,1);
  if (msg_params != (uint8_t *)0x0) {
    *msg_params = vif_idx;
    iVar1 = bl_send_msg(bl_hw,msg_params,1,0x1c03,(void *)0x0);
    return iVar1;
  }
  return -0xc;
}



int bl_send_apm_sta_del_req(bl_hw *bl_hw,apm_sta_del_cfm *cfm,uint8_t sta_idx,uint8_t vif_idx)

{
  uint8_t *msg_params;
  int iVar1;
  
  msg_params = (uint8_t *)bl_msg_zalloc(0x1c0b,7,2);
  if (msg_params != (uint8_t *)0x0) {
    msg_params[1] = sta_idx;
    *msg_params = vif_idx;
    iVar1 = bl_send_msg(bl_hw,msg_params,1,0x1c0c,cfm);
    return iVar1;
  }
  return -0xc;
}



int bl_send_apm_conf_max_sta_req(bl_hw *bl_hw,uint8_t max_sta_supported)

{
  uint8_t *msg_params;
  int iVar1;
  
  msg_params = (uint8_t *)bl_msg_zalloc(0x1c0d,7,1);
  if (msg_params != (uint8_t *)0x0) {
    *msg_params = max_sta_supported;
    iVar1 = bl_send_msg(bl_hw,msg_params,1,0x1c0e,(void *)0x0);
    return iVar1;
  }
  return -0xc;
}



int bl_send_cfg_task_req
              (bl_hw *bl_hw,uint32_t ops,uint32_t task,uint32_t element,uint32_t type,void *arg1,
              void *arg2)

{
  uint32_t *msg_params;
  int iVar1;
  TickType_t TVar2;
  uint32_t uVar3;
  
  msg_params = (uint32_t *)bl_msg_zalloc(0x3000,0xc,0x24);
  if (msg_params == (uint32_t *)0x0) {
    return -0xc;
  }
  *msg_params = ops;
  if (ops < 3) {
    if (ops == 0) {
      msg_params[1] = task;
      msg_params[2] = element;
      msg_params[3] = type;
      uVar3 = utils_tlv_bl_pack_auto(msg_params + 5,8,(uint16_t)type,arg1);
      msg_params[4] = uVar3;
    }
  }
  else {
    if (ops != 3) {
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] ASSERT: %s:%d\r\n",TVar2,&UNK_2307261c,&UNK_23072610,0x40f,
                &UNK_23072610,0x40f);
      do {
                    // WARNING: Do nothing block with infinite loop
      } while( true );
    }
    msg_params[1] = task;
    msg_params[2] = element;
    msg_params[4] = 0;
  }
  iVar1 = bl_send_msg(bl_hw,msg_params,1,0x3001,(void *)0x0);
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int bl_platform_on(bl_hw *bl_hw)

{
  int iVar1;
  
  ipc_shenv = &ipc_shared_env;
  iVar1 = bl_ipc_init(bl_hw,(ipc_shared_env_tag *)&ipc_shared_env);
  if (iVar1 == 0) {
    _DAT_44800008 = 0xffffffff;
  }
  return iVar1;
}



int bl_rx_chan_pre_switch_ind(bl_hw *bl_hw,bl_cmd *cmd,ipc_e2a_msg *msg)

{
  return 0;
}



int bl_rx_rssi_status_ind(bl_hw *bl_hw,bl_cmd *cmd,ipc_e2a_msg *msg)

{
  if (cb_rssi != (wifi_event_rssi_cb_t *)0x0) {
    (*cb_rssi)(cb_rssi_env,*(int8_t *)((int)msg->param + 2));
    return 0;
  }
  return 0;
}



int bl_rx_apm_sta_del_ind(bl_hw *bl_hw,bl_cmd *cmd,ipc_e2a_msg *msg)

{
  printf("[WF] APM_STA_DEL_IND\r\n");
  printf("[WF]    sta_idx %u\r\n",(uint)*(byte *)msg->param);
  if (*(byte *)msg->param < 0xc) {
    bl_hw->sta_table[*(byte *)msg->param].is_used = '\0';
  }
  else {
    printf("[WF]    --------- Potential illegal sta_idx\r\n");
  }
  aos_post_event(2,0x16,(uint)*(byte *)msg->param);
  return 0;
}



int bl_rx_apm_sta_add_ind(bl_hw *bl_hw,bl_cmd *cmd,ipc_e2a_msg *msg)

{
  byte bVar1;
  int *piVar2;
  
  printf("[WF] APM_STA_ADD_IND\r\n");
  printf("[WF]    flags %08X\r\n",msg->param[0]);
  printf("[WF]    MAC %02X:%02X:%02X:%02X:%02X:%02X\r\n",(uint)*(byte *)(msg->param + 1),
         (uint)*(byte *)((int)msg->param + 5),(uint)*(byte *)((int)msg->param + 6),
         (uint)*(byte *)((int)msg->param + 7),(uint)*(byte *)(msg->param + 2),
         (uint)*(byte *)((int)msg->param + 9));
  printf("[WF]    vif_idx %u\r\n",(uint)*(byte *)((int)msg->param + 10));
  printf("[WF]    sta_idx %u\r\n",(uint)*(byte *)((int)msg->param + 0xb));
  bVar1 = *(byte *)((int)msg->param + 0xb);
  if (bVar1 < 0xc) {
    memcpy(bl_hw->sta_table + (uint)bVar1,msg->param + 1,6);
    piVar2 = &bl_hw->is_up + (uint)bVar1 * 7;
    *(undefined *)((int)piVar2 + 0xc99) = *(undefined *)((int)msg->param + 0xb);
    *(undefined *)((int)piVar2 + 0xc9a) = *(undefined *)((int)msg->param + 10);
    *(undefined *)(piVar2 + 0x326) = 1;
    *(undefined *)(piVar2 + 0x327) = *(undefined *)(msg->param + 3);
    piVar2[0x328] = msg->param[4];
    piVar2[0x329] = msg->param[5];
    *(undefined *)(piVar2 + 0x32a) = *(undefined *)(msg->param + 6);
  }
  else {
    printf("[WF]    ------ Potential illegal sta_idx\r\n");
  }
  aos_post_event(2,0x15,(uint)*(byte *)((int)msg->param + 0xb));
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

void notify_event_scan_done(int join_scan)

{
  wifi_event wStack24;
  uint8_t buffer [8];
  
  memset(&wStack24,0,4);
  memset(buffer,0,4);
  buffer._0_4_ = 0xec;
  wStack24 = (wifi_event)((uint)(join_scan != 0) + 1);
  if (cb_event != (wifi_event_cb_t *)0x0) {
    (*cb_event)(cb_event_env,&wStack24);
  }
  return;
}



int bl_rx_scanu_join_cfm(bl_hw *bl_hw,bl_cmd *cmd,ipc_e2a_msg *msg)

{
  notify_event_scan_done(1);
  return 0;
}



int bl_rx_scanu_start_cfm(bl_hw *bl_hw,bl_cmd *cmd,ipc_e2a_msg *msg)

{
  notify_event_scan_done(0);
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

int bl_rx_chan_switch_ind(bl_hw *bl_hw,bl_cmd *cmd,ipc_e2a_msg *msg)

{
  wifi_event wStack24;
  uint8_t buffer [8];
  
  buffer._0_4_ = (uint)*(byte *)msg->param;
  memset(&wStack24,0,4);
  memset(buffer,0,4);
  wStack24 = (wifi_event)0x0;
  if (cb_event != (wifi_event_cb_t *)0x0) {
    (*cb_event)(cb_event_env,&wStack24);
  }
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

int bl_rx_sm_connect_ind(bl_hw *bl_hw,bl_cmd *cmd,ipc_e2a_msg *msg)

{
  netif *netif;
  sm_reason_code *psVar1;
  uint uVar2;
  int iVar3;
  u32_l local_40;
  wifi_event_sm_connect_ind ind_new;
  
  psVar1 = reason_list;
  iVar3 = 0;
  do {
    if (psVar1->reason_code == *(uint16_t *)msg->param) goto LAB_2300949e;
    iVar3 = iVar3 + 1;
    psVar1 = psVar1 + 1;
  } while (iVar3 != 0x10);
  iVar3 = 0;
LAB_2300949e:
  printf("[RX] Connection Status\r\n");
  printf("[RX]   status_code %u\r\n",(uint)*(ushort *)msg->param);
  printf("[RX]   connect result: %s\r\n",reason_list[iVar3].action);
  printf("[RX]   MAC %02X:%02X:%02X:%02X:%02X:%02X\r\n",(uint)*(byte *)((int)msg->param + 2),
         (uint)*(byte *)((int)msg->param + 3),(uint)*(byte *)(msg->param + 1),
         (uint)*(byte *)((int)msg->param + 5),(uint)*(byte *)((int)msg->param + 6),
         (uint)*(byte *)((int)msg->param + 7));
  printf("[RX]   vif_idx %u\r\n",(uint)*(byte *)((int)msg->param + 9));
  printf("[RX]   ap_idx %u\r\n",(uint)*(byte *)((int)msg->param + 10));
  printf("[RX]   ch_idx %u\r\n",(uint)*(byte *)((int)msg->param + 0xb));
  printf("[RX]   qos %u\r\n",(uint)*(byte *)(msg->param + 3));
  printf("[RX]   acm %u\r\n",(uint)*(byte *)((int)msg->param + 0xd));
  printf("[RX]   assoc_req_ie_len %u\r\n",(uint)*(ushort *)((int)msg->param + 0xe));
  printf("[RX]   assoc_rsp_ie_len %u\r\n",(uint)*(ushort *)(msg->param + 4));
  printf("[RX]   aid %u\r\n",(uint)*(ushort *)(msg->param + 0xcd));
  printf("[RX]   band %u\r\n",(uint)*(byte *)((int)msg->param + 0x336));
  printf("[RX]   center_freq %u\r\n",(uint)*(ushort *)(msg->param + 0xce));
  printf("[RX]   width %u\r\n",(uint)*(byte *)((int)msg->param + 0x33a));
  printf("[RX]   center_freq1 %u\r\n",msg->param[0xcf]);
  printf("[RX]   center_freq2 %u\r\n",msg->param[0xd0]);
  if (*(short *)msg->param == 0) {
    bl_hw->sta_idx = (uint)*(byte *)((int)msg->param + 10);
    bl_hw->is_up = 1;
  }
  else {
    bl_hw->is_up = 0;
  }
  memset(&local_40,0,0x20);
  local_40 = msg->param[0];
  ind_new._0_4_ = msg->param[1];
  ind_new.bssid[2] = *(uint8_t *)((int)msg->param + 9);
  ind_new.bssid[3] = *(uint8_t *)((int)msg->param + 10);
  ind_new.bssid[4] = *(uint8_t *)((int)msg->param + 0xb);
  ind_new._8_4_ = (uint)*(byte *)(msg->param + 3);
  ind_new.qos._0_2_ = *(uint16_t *)(msg->param + 0xcd);
  ind_new.qos._2_1_ = *(uint8_t *)((int)msg->param + 0x336);
  ind_new.aid = *(uint16_t *)(msg->param + 0xce);
  ind_new.band = *(uint8_t *)((int)msg->param + 0x33a);
  ind_new._20_4_ = msg->param[0xcf];
  ind_new.center_freq1 = msg->param[0xd0];
  if (cb_sm_connect_ind != (wifi_event_sm_connect_ind_cb_t *)0x0) {
    (*cb_sm_connect_ind)(cb_sm_connect_ind_env,(wifi_event_sm_connect_ind *)&local_40);
  }
  if (*(short *)msg->param == 0) {
    uVar2 = (uint)*(byte *)((int)msg->param + 9);
    if (bl_hw->vif_table + uVar2 != (bl_vif *)0x0) {
      netif = (netif *)(&bl_hw->is_up + uVar2 * 0x31)[0xda];
      if (netif != (netif *)0x0) {
        netifapi_netif_common(netif,netif_set_link_up,(netifapi_errt_fn)0x0);
        netifapi_netif_common
                  ((netif *)(&bl_hw->is_up + uVar2 * 0x31)[0xda],netif_set_default,
                   (netifapi_errt_fn)0x0);
        return 0;
      }
    }
    printf("[RX]  -------- CRITICAL when check netif. ptr is %p:%p\r\n");
  }
  return 0;
}



// WARNING: Variable defined which should be unmapped: ind_new
// WARNING: Could not reconcile some variable overlaps

int bl_rx_sm_disconnect_ind(bl_hw *bl_hw,bl_cmd *cmd,ipc_e2a_msg *msg)

{
  netif *netif;
  uint uVar1;
  ip4_addr_t iStack28;
  ip4_addr_t addr_any;
  wifi_event_sm_disconnect_ind ind_new;
  
  iStack28 = (ip4_addr_t)ipaddr_addr("0.0.0.0");
  printf("[RX] sm_disconnect_ind\r\n       reason_code %u\r\n",(uint)*(ushort *)msg->param);
  printf("[RX]    vif_idx %u\r\n",(uint)*(byte *)((int)msg->param + 2));
  printf("[RX]     ft_over_ds %u\r\n",(uint)*(byte *)((int)msg->param + 3));
  if (cb_sm_disconnect_ind != (wifi_event_sm_disconnect_ind_cb_t *)0x0) {
    memset(&addr_any,0,8);
    addr_any.addr._0_2_ = *(uint16_t *)msg->param;
    addr_any.addr._2_1_ = *(uint8_t *)((int)msg->param + 2);
    (*cb_sm_disconnect_ind)(cb_sm_disconnect_ind_env,(wifi_event_sm_disconnect_ind *)&addr_any);
  }
  uVar1 = (uint)*(byte *)((int)msg->param + 2);
  if (bl_hw->vif_table + uVar1 != (bl_vif *)0x0) {
    netif = (netif *)(&bl_hw->is_up + uVar1 * 0x31)[0xda];
    if (netif != (netif *)0x0) {
      netifapi_netif_common(netif,netif_set_link_down,(netifapi_errt_fn)0x0);
      netifapi_netif_set_addr
                ((netif *)(&bl_hw->is_up + uVar1 * 0x31)[0xda],&iStack28,&iStack28,&iStack28);
    }
  }
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

undefined4 bl_rx_scanu_result_ind(int param_1,longlong param_2)

{
  uchar uVar1;
  void *__src;
  undefined3 extraout_var;
  uint __n;
  SecurityMode_t *security_mode;
  _Bool wpa2_prefered;
  byte bVar2;
  ushort uVar3;
  int iVar4;
  byte *pbVar5;
  byte *pbVar6;
  _Bool _Stack121;
  uint8_t auStack120 [32];
  undefined2 uStack88;
  undefined2 uStack86;
  undefined2 uStack84;
  undefined auStack82 [33];
  int8_t iStack49;
  int8_t iStack48;
  int8_t iStack47;
  byte bStack46;
  uint8_t uStack45;
  undefined4 uStack44;
  undefined4 uStack40;
  uint uStack36;
  SecurityMode_t aSStack32 [4];
  
  _Stack121 = false;
  memset(auStack120,0,0x20);
  security_mode = (SecurityMode_t *)0x80;
  uVar3 = *(ushort *)(param_1 + 0x24) & 0xfc;
  if (uVar3 != 0x80) {
    if (uVar3 != 0x50) {
      printf("Bug Scan IND?\r\n");
      return 0;
    }
    printf("Probe Response\r\n");
    if (cb_probe_resp_ind == (wifi_event_probe_resp_ind_cb_t *)0x0) {
      return 0;
    }
    (*cb_probe_resp_ind)((void *)0x0,param_2);
    return 0;
  }
  if (cb_beacon_ind == (wifi_event_beacon_ind_cb_t *)0x0) {
    return 0;
  }
  memset(&uStack88,0,0x38);
  uVar3 = *(ushort *)(param_1 + 8);
  pbVar6 = (byte *)(param_1 + 0x48);
  iVar4 = 0;
  pbVar5 = pbVar6;
  while (iVar4 < (int)(uint)uVar3) {
    security_mode = (SecurityMode_t *)(uint)*pbVar5;
    __n = (uint)pbVar5[1];
    if (*pbVar5 == 0) {
      if (pbVar5[1] < 0x21) {
        uStack36 = __n;
        memcpy(auStack82,pbVar5 + 2,__n);
        security_mode = aSStack32;
        auStack82[pbVar5[1]] = 0;
      }
      break;
    }
    iVar4 = iVar4 + __n + 2;
    pbVar5 = pbVar5 + __n + 2;
  }
  iVar4 = 0;
  pbVar5 = pbVar6;
  while (iVar4 < (int)(uint)*(ushort *)(param_1 + 8)) {
    security_mode = (SecurityMode_t *)(uint)pbVar5[1];
    if (*pbVar5 == 3) {
      if (pbVar5[1] < 0x21) {
        bStack46 = pbVar5[2];
      }
      break;
    }
    security_mode = security_mode + 1;
    iVar4 = &security_mode->field_0x0 + iVar4;
    pbVar5 = pbVar5 + (int)security_mode;
  }
  if ((*(ushort *)(param_1 + 0x46) & 0x10) == 0) {
    uStack45 = '\0';
    goto LAB_23009906;
  }
  __n = (uint)uVar3 - 0x24 & 0xffff;
  __src = (void *)mac_ie_find(pbVar6,__n,0x30);
  iVar4 = 0;
  if (__src != (void *)0x0) {
    wpa2_prefered = (_Bool)(uStack40._1_1_ | 0x20);
    uStack40 = uStack40 | 0x2000;
    memcpy(auStack120,__src,(uint)*(byte *)((int)__src + 1) + 2 & 0xff);
    uVar1 = process_rsn_ie(auStack120,(Cipher_t_conflict *)((int)&uStack44 + 3),
                           (Cipher_t_conflict *)&uStack40,&_Stack121,security_mode,wpa2_prefered);
    iVar4 = CONCAT31(extraout_var,uVar1);
  }
  __src = (void *)mac_vsie_find(pbVar6,__n,&DAT_23072740,4);
  if ((__src != (void *)0x0) && (uStack40 = uStack40 | 0x800, iVar4 == 0)) {
    memcpy(auStack120,__src,(uint)*(byte *)((int)__src + 1) + 2 & 0xff);
    process_wpa_ie(auStack120,(Cipher_t_conflict *)((int)&uStack44 + 1),
                   (Cipher_t_conflict *)((int)&uStack44 + 2));
  }
  if ((uStack40 & 0x2800) == 0x2800) {
    bVar2 = (byte)uStack40._0_1_ | (byte)uStack44._2_1_;
    __n = (uint)bVar2 & 8;
    if ((bVar2 & 4) == 0) {
      if ((bVar2 & 8) != 0) {
        if (((uStack44 & 0x8000800) == 0) && ((uStack44 & 0x4000400) != 0)) goto LAB_230098f0;
LAB_23009978:
        bVar2 = 2;
        goto next;
      }
    }
    else {
LAB_230098ec:
      bVar2 = 3;
      if (__n != 0) {
LAB_230098f0:
        bVar2 = 4;
      }
next:
      uStack44 = uStack44 & 0xffffff00 | (uint)bVar2;
      if ((uStack40 & 0x2800) != 0x2800) goto LAB_230099d2;
    }
    uStack45 = '\x04';
  }
  else {
    if ((uStack40 & 0x800) == 0) {
      if ((uStack40 & 0x2000) == 0) {
        uStack44 = CONCAT31(uStack44._1_3_,1);
      }
      else {
        __n = uStack40 & 8;
        if ((uStack40 & 4) != 0) goto LAB_230098ec;
        if ((uStack40 & 8) != 0) {
          uStack44._1_1_ = uStack44._3_1_;
          goto LAB_230099a6;
        }
      }
    }
    else {
      __n = (uint)(byte)uStack44._2_1_ & 8;
      if ((uStack44 & 0x40000) != 0) goto LAB_230098ec;
      if ((uStack44 & 0x80000) != 0) {
LAB_230099a6:
        if ((((byte)uStack44._1_1_ & 8) != 0) || (((byte)uStack44._1_1_ & 4) == 0))
        goto LAB_23009978;
        goto LAB_230098f0;
      }
    }
LAB_230099d2:
    if ((uStack40 & 0x2000) == 0) {
      if ((uStack40 & 0x800) == 0) {
        uStack45 = '\x01';
      }
      else {
        uStack45 = '\x02';
      }
    }
    else {
      uStack45 = '\x03';
    }
  }
LAB_23009906:
  iStack49 = *(int8_t *)(param_1 + 0x20);
  iStack48 = *(int8_t *)(param_1 + 0x21);
  iStack47 = *(int8_t *)(param_1 + 0x22);
  uStack88 = *(undefined2 *)(param_1 + 0x34);
  uStack86 = *(undefined2 *)(param_1 + 0x36);
  uStack84 = *(undefined2 *)(param_1 + 0x38);
  (*cb_beacon_ind)(cb_beacon_ind_env,(wifi_event_beacon_ind *)&uStack88);
  return 0;
}



undefined4 bl_rx_mesh_path_update_ind(void)

{
  return 0;
}



undefined4 bl_rx_mesh_proxy_update_ind(void)

{
  return 0;
}



undefined4 bl_rx_remain_on_channel_exp_ind(void)

{
  return 0;
}



undefined4 bl_rx_ps_change_ind(void)

{
  return 0;
}



undefined4 bl_rx_traffic_req_ind(void)

{
  return 0;
}



undefined4 bl_rx_csa_counter_ind(void)

{
  return 0;
}



undefined4 bl_rx_csa_finish_ind(void)

{
  return 0;
}



undefined4 bl_rx_csa_traffic_ind(void)

{
  return 0;
}



undefined4 bl_rx_channel_survey_ind(void)

{
  return 0;
}



undefined4 bl_rx_dbg_error_ind(void)

{
  return 0;
}



undefined4 bl_rx_tdls_chan_switch_cfm(void)

{
  return 0;
}



undefined4 bl_rx_tdls_chan_switch_ind(void)

{
  return 0;
}



undefined4 bl_rx_tdls_chan_switch_base_ind(void)

{
  return 0;
}



undefined4 bl_rx_tdls_peer_ps_ind(void)

{
  return 0;
}



undefined4 bl_rx_me_tkip_mic_failure_ind(void)

{
  return 0;
}



undefined4 bl_rx_me_tx_credits_update_ind(void)

{
  return 0;
}



undefined4 bl_rx_mesh_path_create_cfm(void)

{
  return 0;
}



undefined4 bl_rx_mesh_peer_update_ind(void)

{
  return 0;
}



int bl_rx_sm_connect_ind_cb_register(void *env,wifi_event_sm_connect_ind_cb_t *cb)

{
  cb_sm_connect_ind = cb;
  cb_sm_connect_ind_env = env;
  return 0;
}



int bl_rx_sm_disconnect_ind_cb_register(void *env,wifi_event_sm_disconnect_ind_cb_t *cb)

{
  cb_sm_disconnect_ind = cb;
  cb_sm_disconnect_ind_env = env;
  return 0;
}



int bl_rx_beacon_ind_cb_register(void *env,wifi_event_beacon_ind_cb_t *cb)

{
  cb_beacon_ind = cb;
  cb_beacon_ind_env = env;
  return 0;
}



int bl_rx_probe_resp_ind_cb_register(void *env,wifi_event_probe_resp_ind_cb_t *cb)

{
  cb_probe_resp_ind = cb;
  return 0;
}



int bl_rx_pkt_cb_register(void *env,wifi_event_pkt_cb_t *cb)

{
  cb_pkt = cb;
  cb_pkt_env = env;
  return 0;
}



int bl_rx_pkt_cb_unregister(void *env)

{
  cb_pkt = (wifi_event_pkt_cb_t *)0x0;
  cb_pkt_env = (void *)0x0;
  return 0;
}



int bl_rx_rssi_cb_register(void *env,wifi_event_rssi_cb_t *cb)

{
  cb_rssi = cb;
  cb_rssi_env = env;
  return 0;
}



int bl_rx_event_register(void *env,wifi_event_cb_t *cb)

{
  cb_event = cb;
  cb_event_env = env;
  return 0;
}



void bl_rx_e2a_handler(void *arg)

{
                    // WARNING: Could not recover jumptable at 0x23009b50. Too many branches
                    // WARNING: Treating indirect jump as call
  (*wifi_hw.cmd_mgr.msgind)
            ((bl_cmd_mgr *)0x42018774,(ipc_e2a_msg *)arg,
             (msg_cb_fct *)msg_hdlrs[*(ushort *)arg >> 10][(uint)*(ushort *)arg & 0x3ff]);
  return;
}



void bl_rx_pkt_cb(uint8_t *pkt,int len)

{
  if (cb_pkt != (wifi_event_pkt_cb_t *)0x0) {
                    // WARNING: Could not recover jumptable at 0x23009b6a. Too many branches
                    // WARNING: Treating indirect jump as call
    (*cb_pkt)(cb_pkt_env,pkt,len);
    return;
  }
  return;
}



void bl_tx_push(bl_hw *bl_hw,bl_txhdr *txhdr)

{
  hostdesc *phVar1;
  hostdesc *phVar2;
  txdesc_host *ptVar3;
  hostdesc *phVar4;
  uint32_t *host_id;
  
  host_id = txhdr->p;
  ptVar3 = ipc_host_txdesc_get(bl_hw->ipc_env);
  if (&ptVar3->host == (hostdesc *)0x0) {
    printf("%d:ASSERT_ERR(host)\n",0x37);
  }
  phVar1 = &ptVar3->host;
  phVar4 = &txhdr->host;
  do {
    phVar2 = (hostdesc *)((int)&phVar1->pbuf_addr + 1);
    *(undefined *)&phVar1->pbuf_addr = *(undefined *)&phVar4->pbuf_addr;
    phVar1 = phVar2;
    phVar4 = (hostdesc *)((int)&phVar4->pbuf_addr + 1);
  } while ((hostdesc *)ptVar3->pad_txdesc != phVar2);
  ipc_host_txdesc_push(bl_hw->ipc_env,host_id);
  (bl_hw->stats).cfm_balance = (bl_hw->stats).cfm_balance + 1;
  return;
}



void bl_tx_resend(void)

{
  bl_hw *bl_hw;
  txdesc_host *ptVar1;
  uint uVar2;
  
  vTaskEnterCritical();
  while ((txhdr_pos_r != txhdr_pos_w &&
         (ptVar1 = ipc_host_txdesc_get(bl_hw_static->ipc_env), bl_hw = bl_hw_static,
         ptVar1 != (txdesc_host *)0x0))) {
    uVar2 = txhdr_pos_r & 7;
    txhdr_hodler[uVar2]->status = 0;
    bl_tx_push(bl_hw,txhdr_hodler[uVar2]);
    txhdr_pos_r = txhdr_pos_r + 1;
  }
  vTaskExitCritical();
  return;
}



void bl_tx_try_flush(void)

{
  txdesc_host *ptVar1;
  bl_txhdr *txhdr;
  
  vTaskEnterCritical();
  while ((ptVar1 = ipc_host_txdesc_get(bl_hw_static->ipc_env), ptVar1 != (txdesc_host *)0x0 &&
         (txhdr = (bl_txhdr *)utils_list_pop_front(&tx_list_bl), txhdr != (bl_txhdr *)0x0))) {
    bl_tx_push(bl_hw_static,txhdr);
  }
  vTaskExitCritical();
  return;
}



int bl_txdatacfm(void *pthis,void *host_id)

{
  bl_txhdr *pbVar1;
  int iVar2;
  
  pbVar1 = (bl_txhdr *)((-*(int *)((int)host_id + 4) & 3U) + *(int *)((int)host_id + 4));
  iVar2 = pbVar1->status;
  if (iVar2 == 0) {
    return -1;
  }
  if (iVar2 << 0xf < 0) {
    if (((txhdr_pos_w + 1 ^ txhdr_pos_r) & 7) != 0) {
      puts(" push back\r\n");
      txhdr_hodler[txhdr_pos_w & 7] = pbVar1;
      txhdr_pos_w = txhdr_pos_w + 1;
      return 0;
    }
    puts(" NOT push back when no mem\r\n");
  }
  pbuf_free((pbuf *)host_id);
  return 0;
}



void bl_tx_notify(void)

{
  if (taskHandle_output != (TaskHandle_t)0x0) {
    xTaskGenericNotify(taskHandle_output,0,eIncrement,(uint32_t *)0x0);
    return;
  }
  return;
}



err_t bl_output(bl_hw *bl_hw,netif *netif,pbuf *p,int is_sta)

{
  u16_t uVar1;
  undefined2 uVar2;
  utils_list_hdr *list_hdr;
  err_t eVar3;
  u8_t uVar4;
  undefined3 extraout_var;
  undefined uVar5;
  pbuf *ppVar6;
  uint8_t *mac;
  int iVar7;
  utils_list_hdr *puVar8;
  
  if ((bl_hw == (bl_hw *)0x0) || ((netif->flags & 4) == 0)) {
    printf("[TX] wifi is down, return now\r\n");
    eVar3 = -0xb;
  }
  else {
    if (taskHandle_output == (TaskHandle_t)0x0) {
      taskHandle_output = xTaskGetCurrentTaskHandle();
    }
    mac = (uint8_t *)p->payload;
    uVar1 = p->tot_len;
    bl_hw_static = bl_hw;
    uVar4 = pbuf_header(p,0x80);
    if (CONCAT31(extraout_var,uVar4) == 0) {
      list_hdr = (utils_list_hdr *)((-(int)p->payload & 3U) + (int)p->payload);
      memset(list_hdr,0,0x5c);
      *(pbuf **)&list_hdr[2].next = p;
      memcpy(list_hdr + 7,mac,6);
      memcpy((void *)((int)&list_hdr[8].next + 2),mac + 6,6);
      *(pbuf **)&list_hdr[3].next = p;
      uVar2 = *(undefined2 *)(mac + 0xc);
      *(undefined *)((int)&list_hdr[0xd].next + 2) = 0;
      *(undefined2 *)&list_hdr[10].next = uVar2;
      if (is_sta == 0) {
        uVar5 = *(undefined *)&bl_hw->vif_index_ap;
      }
      else {
        uVar5 = *(undefined *)&bl_hw->vif_index_sta;
      }
      *(undefined *)((int)&list_hdr[0xd].next + 3) = uVar5;
      *(undefined2 *)((int)&list_hdr[0xe].next + 2) = 0;
      *(u16_t *)&list_hdr[5].next = uVar1 - 0xe;
      if (is_sta == 0) {
        iVar7 = bl_utils_idx_lookup(bl_hw,mac);
        *(char *)&list_hdr[0xe].next = (char)iVar7;
      }
      else {
        *(char *)&list_hdr[0xe].next = (char)bl_hw->sta_idx;
      }
      puVar8 = list_hdr + 0xf;
      iVar7 = 0;
      ppVar6 = p;
      do {
        if (iVar7 == 0) {
          list_hdr[0xf].next = (utils_list_hdr *)((int)ppVar6->payload + 0x8e);
          list_hdr[0x13].next = (utils_list_hdr *)((uint)ppVar6->len - 0x8e);
        }
        else {
          if (iVar7 == 4) {
            printf("[TX] [PBUF] Please fix for bigger chained pbuf, total_len %d\r\n",
                   (uint)p->tot_len);
          }
          puVar8->next = (utils_list_hdr *)ppVar6->payload;
          puVar8[4].next = (utils_list_hdr *)(uint)ppVar6->len;
        }
        ppVar6 = ppVar6->next;
        iVar7 = iVar7 + 1;
        puVar8 = puVar8 + 1;
      } while (ppVar6 != (pbuf *)0x0);
      if (2 < iVar7) {
        printf("[TX] [LOOP] Chain Used %d\r\n",iVar7);
      }
      list_hdr[4].next = (utils_list_hdr *)0x11111111;
      list_hdr[6].next = list_hdr + 1;
      list_hdr[1].next = (utils_list_hdr *)0x0;
      pbuf_ref(p);
      vTaskEnterCritical();
      utils_list_push_back(&tx_list_bl,list_hdr);
      vTaskExitCritical();
      bl_irq_handler();
      eVar3 = '\0';
    }
    else {
      printf("[TX] Reserve room failed for header\r\n");
      eVar3 = -0xc;
    }
  }
  return eVar3;
}



u8 bl_radarind(void *pthis,void *hostid)

{
  return '\0';
}



u8 bl_msgackind(void *pthis,void *hostid)

{
  (**(code **)((int)pthis + 0x24))((int)pthis + 4,*(code **)((int)pthis + 0x24));
  return '\0';
}



void bl_prim_tbtt_ind(void *pthis)

{
  return;
}



void my_pbuf_free_custom(pbuf *p)

{
  bl60x_firmwre_mpdu_free(p[1].payload);
  return;
}



undefined4 bl_dbgind(void)

{
  return 0;
}



void bl_sec_tbtt_ind(void)

{
  return;
}



void my_pbuf_free_custom_fake(void)

{
  return;
}



// WARNING: Control flow encountered bad instruction data

int tcpip_stack_input(void *swdesc,uint8_t status,void *hwhdr,uint msdu_offset,wifi_pkt *pkt)

{
  if ((status & 1) == 0) {
    return -1;
  }
                    // WARNING: Bad instruction - Truncating control flow here
  halt_baddata();
}



int bl_utils_idx_lookup(bl_hw *bl_hw,uint8_t *mac)

{
  bl_sta *__s1;
  int iVar1;
  int iVar2;
  
  __s1 = bl_hw->sta_table;
  iVar1 = 0;
  while ((__s1->is_used == '\0' || (iVar2 = memcmp(__s1,mac,6), iVar2 != 0))) {
    iVar1 = iVar1 + 1;
    __s1 = __s1 + 1;
    if (iVar1 == 0xc) {
      return wifi_hw.ap_bcmc_idx;
    }
  }
  return iVar1;
}



int bl_ipc_init(bl_hw *bl_hw,ipc_shared_env_tag *ipc_shared_mem)

{
  code *local_30;
  ipc_host_cb_tag cb;
  
  memset(&local_30,0,0x20);
  cb.recv_data_ind = bl_radarind;
  cb.recv_msg_ind = bl_msgackind;
  cb.recv_msgack_ind = bl_dbgind;
  local_30 = bl_txdatacfm;
  cb.recv_dbg_ind = bl_prim_tbtt_ind;
  cb.prim_tbtt_ind = bl_sec_tbtt_ind;
  cb.send_data_cfm = (anon_subr_int_void_ptr_void_ptr_for_send_data_cfm *)0x0;
  cb.recv_radar_ind = (anon_subr_uint8_t_void_ptr_void_ptr_for_recv_radar_ind *)0x0;
  ipc_env = (ipc_host_env_tag *)pvPortMalloc(0xe4);
  bl_hw->ipc_env = ipc_env;
  ipc_host_init(ipc_env,(ipc_host_cb_tag *)&local_30,ipc_shared_mem,bl_hw);
  bl_cmd_mgr_init(&bl_hw->cmd_mgr);
  return 0;
}



void bl_utils_dump(void)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  
  puts("---------- bl_utils_dump -----------\r\n");
  printf("txdesc_free_idx: %lu(%lu)\r\n",ipc_env->txdesc_free_idx,ipc_env->txdesc_free_idx & 3);
  printf("txdesc_used_idx: %lu(%lu)\r\n",ipc_env->txdesc_used_idx,ipc_env->txdesc_used_idx & 3);
  iVar1 = 0;
  printf("tx_host_id0 cnt: %d(used %ld)\r\n",4,ipc_env->txdesc_free_idx - ipc_env->txdesc_used_idx);
  puts("  list:   pbuf    status ptr  status\r\n");
  do {
    uVar2 = ipc_env->txdesc_used_idx + iVar1;
    if (uVar2 == ipc_env->txdesc_free_idx) break;
    iVar1 = iVar1 + 1;
    iVar3 = *(int *)((&(ipc_env->cb).recv_radar_ind)[(uVar2 & 3) + 0x10] + 4);
    iVar3 = (-iVar3 & 3U) + iVar3;
    printf("    [%lu]%p(%p:%08lX)\r\n",*(undefined4 *)(iVar3 + 0x18),*(undefined4 *)(iVar3 + 4));
  } while (iVar1 != 4);
  puts("========== bl_utils_dump End =======\r\n");
  return;
}



// WARNING: Exceeded maximum restarts with more pending

void goToErrorState(stateMachine *fsm,event *event)

{
  state *psVar1;
  
  fsm->previousState = fsm->currentState;
  psVar1 = fsm->errorState;
  fsm->currentState = psVar1;
  if ((psVar1 != (state *)0x0) &&
     (psVar1->entryAction != (anon_subr_void_void_ptr_event_ptr_for_entryAction *)0x0)) {
                    // WARNING: Could not recover jumptable at 0x2300a4a6. Too many branches
                    // WARNING: Treating indirect jump as call
    (*psVar1->entryAction)(psVar1->data);
    return;
  }
  return;
}



void stateM_init(stateMachine *fsm,state *initialState,state *errorState)

{
  if (fsm != (stateMachine *)0x0) {
    fsm->currentState = initialState;
    fsm->previousState = (state *)0x0;
    fsm->errorState = errorState;
  }
  return;
}



// WARNING: Type propagation algorithm not settling

int stateM_handleEvent(stateMachine *fsm,event *event)

{
  state *psVar1;
  state *psVar2;
  int iVar3;
  int *piVar4;
  uint uVar5;
  
  if (fsm == (stateMachine *)0x0) {
    return -2;
  }
  iVar3 = -2;
  if (event != (event *)0x0) {
    psVar1 = fsm->currentState;
    if (psVar1 == (state *)0x0) {
LAB_2300a4d4:
      goToErrorState(fsm,event);
      iVar3 = -1;
    }
    else {
      psVar2 = (state *)psVar1->numTransitions;
      while (psVar2 != (state *)0x0) {
        uVar5 = 0;
        while (uVar5 < psVar1->numTransitions) {
          piVar4 = &psVar1->transitions->eventType + uVar5 * 5;
          if ((*piVar4 == event->type) &&
             (((code *)piVar4[2] == (code *)0x0 ||
              (iVar3 = (*(code *)piVar4[2])(piVar4[1],event), iVar3 != 0)))) {
            psVar1 = (state *)piVar4[4];
            if ((state *)piVar4[4] != (state *)0x0) {
              do {
                psVar2 = psVar1;
                psVar1 = psVar2->entryState;
              } while (psVar2->entryState != (state *)0x0);
              psVar1 = fsm->currentState;
              if ((psVar1 != psVar2) &&
                 (psVar1->exitAction != (anon_subr_void_void_ptr_event_ptr_for_exitAction *)0x0)) {
                (*psVar1->exitAction)(psVar1->data,event);
              }
              if ((code *)piVar4[3] != (code *)0x0) {
                (*(code *)piVar4[3])(fsm->currentState->data,event,psVar2->data);
              }
              if ((fsm->currentState != psVar2) &&
                 (psVar2->entryAction != (anon_subr_void_void_ptr_event_ptr_for_entryAction *)0x0))
              {
                (*psVar2->entryAction)(psVar2->data,event);
              }
              psVar1 = fsm->currentState;
              fsm->currentState = psVar2;
              fsm->previousState = psVar1;
              if (psVar1 == psVar2) {
                return 1;
              }
              if (fsm->errorState == psVar2) {
                return -1;
              }
              if (psVar2->numTransitions == 0) {
                return 3;
              }
              return 0;
            }
            goto LAB_2300a4d4;
          }
          uVar5 = uVar5 + 1;
        }
        psVar1 = psVar1->parentState;
        psVar2 = psVar1;
      }
      iVar3 = 2;
    }
  }
  return iVar3;
}



void netif_status_callback(netif *netif)

{
  uint32_t ip;
  char *pcVar1;
  ip_addr_t *piVar2;
  uint32_t mask;
  uint32_t gw;
  uint32_t dns1;
  
  pcVar1 = ip4addr_ntoa((ip4_addr_t *)&netif->ip_addr);
  printf("[lwip] netif status callback\r\n  IP: %s\r\n",pcVar1);
  pcVar1 = ip4addr_ntoa((ip4_addr_t *)&netif->netmask);
  printf("  MK: %s\r\n",pcVar1);
  pcVar1 = ip4addr_ntoa((ip4_addr_t *)&netif->gw);
  printf("  GW: %s\r\n",pcVar1);
  if (((ip4_addr_t *)&netif->ip_addr != (ip4_addr_t *)0x0) && ((netif->ip_addr).addr != 0)) {
    wifi_mgmr_api_ip_update();
    mask = (netif->netmask).addr;
    gw = (netif->gw).addr;
    ip = (netif->ip_addr).addr;
    piVar2 = dns_getserver('\0');
    dns1 = piVar2->addr;
    piVar2 = dns_getserver('\x01');
    wifi_mgmr_api_ip_got(ip,mask,gw,dns1,piVar2->addr);
    return;
  }
  printf(" SKIP Notify for set Empty Address\r\n");
  return;
}



err_t wifi_tx(netif *netif,pbuf *p)

{
  err_t eVar1;
  TickType_t TVar2;
  pbuf *ppVar3;
  
  ppVar3 = p;
  if (p->tot_len < 0x5eb) {
    do {
      ppVar3 = ppVar3->next;
    } while (ppVar3 != (pbuf *)0x0);
    eVar1 = '\0';
    bl_output(bl606a0_sta,netif,p,(uint)(netif[-1].client_data[1] == (void *)0x0));
  }
  else {
    TVar2 = xTaskGetTickCount();
    eVar1 = -0xc;
    if (2000 < TVar2 - ticks_7281) {
      printf("[TX] %s, TX size too big: %u bytes\r\n",&__func___7282,(uint)p->tot_len);
      ticks_7281 = xTaskGetTickCount();
    }
  }
  return eVar1;
}



err_t bl606a0_wifi_netif_init(netif *netif)

{
  netif->hostname = "bl606a0";
  netif->mtu = 0x5dc;
  *(undefined2 *)&netif->hwaddr_len = 0xa06;
  netif->output = etharp_output;
  netif->linkoutput = wifi_tx;
  netif_set_status_callback(netif,netif_status_callback);
  return '\0';
}



int bl606a0_wifi_init(wifi_conf_t *conf)

{
  int iVar1;
  byte bStack24;
  byte bStack23;
  byte bStack22;
  byte bStack21;
  uint8_t mac [6];
  
  printf("\r\n\r\n[BL] Initi Wi-Fi");
  memset(&bStack24,0,6);
  bl_wifi_mac_addr_get(&bStack24);
  printf(" with MAC #### %02X:%02X:%02X:%02X:%02X:%02X ####\r\n",(uint)bStack24,(uint)bStack23,
         (uint)bStack22,(uint)bStack21,(uint)mac[0],(uint)mac[1]);
  bl_msg_update_channel_cfg((char *)conf);
  printf("-----------------------------------------------------\r\n");
  bl_wifi_clock_enable();
  memset(&bl606a0_sta,0,4);
  iVar1 = bl_main_rtthread_start((bl_hw **)&bl606a0_sta);
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

u32 ipc_emb2app_rawstatus_get(void)

{
  return _DAT_44800004;
}



void ipc_host_init(ipc_host_env_tag *env,ipc_host_cb_tag *cb,ipc_shared_env_tag *shared_env_ptr,
                  void *pthis)

{
  printf("[IPC] [TX] Low level size %d, driver size %d, total size %d\r\n",internel_cal_size_tx_desc
         ,internel_cal_size_tx_hdr,internel_cal_size_tx_desc + internel_cal_size_tx_hdr);
  utils_list_init(&tx_list_bl);
  memset(env,0,0xe4);
  env->shared = shared_env_ptr;
  memcpy(env,cb,0x20);
  env->rx_bufnb = 2;
  env->rxdesc_nb = '\x02';
  env->ipc_e2amsg_bufnb = 8;
  env->ipc_e2amsg_bufsz = 0x3e0;
  env->pthis = pthis;
  env->rx_bufsz = 0x800;
  env->tx_host_id = env->tx_host_id0;
  env->txdesc = shared_env_ptr->txdesc0;
  memset(shared_env_ptr->txdesc0,0,0xcc0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int ipc_host_msg_push(ipc_host_env_tag *env,void *msg_buf,uint16_t len)

{
  undefined2 in_register_00002032;
  int iVar1;
  ipc_shared_env_tag *piVar2;
  int iVar3;
  
  iVar1 = *(int *)((int)msg_buf + 0xc);
  piVar2 = env->shared;
  iVar3 = 0;
  while (iVar3 < CONCAT22(in_register_00002032,len)) {
    *(undefined4 *)((int)(piVar2->msg_a2e_buf).msg + iVar3) = *(undefined4 *)(iVar1 + iVar3);
    iVar3 = iVar3 + 4;
  }
  env->msga2e_hostid = msg_buf;
  _DAT_44800000 = 2;
  return 0;
}



uint32_t ipc_host_get_rawstatus(ipc_host_env_tag *env)

{
  u32 uVar1;
  
  uVar1 = ipc_emb2app_rawstatus_get();
  return uVar1;
}



txdesc_host * ipc_host_txdesc_get(ipc_host_env_tag *env)

{
  uint uVar1;
  uint uVar2;
  
  uVar1 = env->txdesc_used_idx;
  uVar2 = env->txdesc_free_idx;
  if (uVar2 < uVar1) {
    used_issue = used_issue + 1;
  }
  if (uVar1 + 4 != uVar2) {
    if (uVar2 - uVar1 < 5) {
      return env->txdesc + (uVar2 & 3);
    }
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  return (txdesc_host *)0x0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_host_txdesc_push(ipc_host_env_tag *env,void *host_id)

{
  uint uVar1;
  
  uVar1 = env->txdesc_free_idx & 3;
  env->txdesc[uVar1].ready = 0xffffffff;
  env->tx_host_id[uVar1] = host_id;
  env->txdesc_free_idx = env->txdesc_free_idx + 1;
  _DAT_44800000 = 0x100;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_host_irq(ipc_host_env_tag *env,uint32_t status)

{
  uint uVar1;
  uint8_t uVar2;
  int iVar3;
  undefined3 extraout_var;
  void *pvVar4;
  anon_subr_uint8_t_void_ptr_void_ptr_for_recv_msgack_ind *paVar5;
  uint uVar6;
  int *piVar7;
  uint uVar8;
  
  uVar1 = _DAT_4480001c | status;
  _DAT_44800008 = status;
  if ((uVar1 & 0x780) != 0) {
    piVar7 = nx_txdesc_cnt_msk;
    uVar8 = 7;
    do {
      if ((1 << (uVar8 & 0x1f) & uVar1) != 0) {
        while( true ) {
          uVar6 = env->txdesc_used_idx & *piVar7;
          if ((env->tx_host_id[uVar6] == (void *)0x0) ||
             (iVar3 = (*(env->cb).send_data_cfm)(env->pthis,env->tx_host_id[uVar6]), iVar3 != 0))
          break;
          env->tx_host_id[uVar6] = (void *)0x0;
          env->txdesc_used_idx = env->txdesc_used_idx + 1;
          bl_tx_notify();
        }
      }
      uVar8 = uVar8 + 1;
      piVar7 = (int *)((uint *)piVar7 + 1);
    } while (uVar8 != 0xb);
  }
  bl_tx_resend();
  if ((uVar1 & 4) != 0) {
    pvVar4 = env->msga2e_hostid;
    env->msga2e_cnt = env->msga2e_cnt + '\x01';
    paVar5 = (env->cb).recv_msgack_ind;
    env->msga2e_hostid = (void *)0x0;
    (*paVar5)(env->pthis,pvVar4);
  }
  if ((uVar1 & 1) != 0) {
    do {
      uVar2 = (*(env->cb).recv_dbg_ind)
                        (env->pthis,
                         (&(env->cb).recv_data_ind)[((uint)env->ipc_host_dbg_idx + 0x16) * 2]);
    } while (CONCAT31(extraout_var,uVar2) == 0);
  }
  if ((uVar1 & 0x10) != 0) {
    (*(env->cb).prim_tbtt_ind)(env->pthis);
  }
  if ((uVar1 & 0x20) != 0) {
                    // WARNING: Could not recover jumptable at 0x2300a99a. Too many branches
                    // WARNING: Treating indirect jump as call
    (*(env->cb).sec_tbtt_ind)(env->pthis);
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_host_enable_irq(ipc_host_env_tag *env,uint32_t value)

{
  _DAT_4480000c = value;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_host_disable_irq_e2a(void)

{
  _DAT_44800010 = 0x7ff;
  return;
}



void cmd_mgr_print(bl_cmd_mgr *cmd_mgr)

{
  list_head *plVar1;
  
  xQueueSemaphoreTake((QueueHandle_t)cmd_mgr->lock,0xffffffff);
  plVar1 = (cmd_mgr->cmds).next;
  while (plVar1 != &cmd_mgr->cmds) {
    plVar1 = plVar1->next;
  }
  xQueueGenericSend((QueueHandle_t)cmd_mgr->lock,(void *)0x0,0,0);
  return;
}



void cmd_complete(bl_cmd *cmd)

{
  ushort uVar1;
  int *in_a1;
  int iVar2;
  int *piVar3;
  
  (cmd->list).next = (list_head *)((int)&(cmd->list).next[-1].prev + 3);
  piVar3 = (int *)in_a1[1];
  iVar2 = *in_a1;
  *(int **)(iVar2 + 4) = piVar3;
  *piVar3 = iVar2;
  *in_a1 = 0x100100;
  in_a1[1] = 0x200200;
  uVar1 = *(ushort *)(in_a1 + 6);
  *(ushort *)(in_a1 + 6) = uVar1 | 0x20;
  if ((uVar1 & 1) != 0) {
    vPortFree(in_a1);
    return;
  }
  if ((uVar1 & 0x18) == 0) {
    in_a1[0xf] = 0;
    xEventGroupSetBits((EventGroupHandle_t)(in_a1 + 7),1);
    return;
  }
  return;
}



int cmd_mgr_msgind(bl_cmd_mgr *cmd_mgr,ipc_e2a_msg *msg,msg_cb_fct *cb)

{
  bool bVar1;
  bl_cmd *pbVar2;
  int iVar3;
  
  xQueueSemaphoreTake((QueueHandle_t)cmd_mgr->lock,0xffffffff);
  pbVar2 = (bl_cmd *)(cmd_mgr->cmds).next;
  do {
    if (pbVar2 == (bl_cmd *)&cmd_mgr->cmds) {
      bVar1 = false;
LAB_2300aaac:
      xQueueGenericSend((QueueHandle_t)cmd_mgr->lock,(void *)0x0,0,0);
      if ((!bVar1) && (cb != (msg_cb_fct *)0x0)) {
        (*cb)((bl_hw *)&cmd_mgr[-1].drain,(bl_cmd *)0x0,msg);
      }
      return 0;
    }
    if (((pbVar2->reqid == msg->id) && ((pbVar2->flags & 0x10) != 0)) &&
       ((cb == (msg_cb_fct *)0x0 ||
        (iVar3 = (*cb)((bl_hw *)&cmd_mgr[-1].drain,pbVar2,msg), iVar3 == 0)))) {
      pbVar2->flags = pbVar2->flags & 0xffef;
      if ((pbVar2->e2a_msg != (char *)0x0) && (msg->param_len != 0)) {
        memcpy(pbVar2->e2a_msg,msg->param,(uint)msg->param_len);
      }
      bVar1 = true;
      if ((pbVar2->flags & 0x18) == 0) {
        cmd_complete((bl_cmd *)&cmd_mgr->queue_sz);
      }
      goto LAB_2300aaac;
    }
    pbVar2 = (bl_cmd *)(pbVar2->list).next;
  } while( true );
}



int cmd_mgr_llind(bl_cmd_mgr *cmd_mgr,bl_cmd *cmd)

{
  ushort uVar1;
  char "cmd_mgr_llind" [14];
  bl_cmd *msg_buf;
  bl_cmd *pbVar2;
  _Bool __warned;
  
  xQueueSemaphoreTake((QueueHandle_t)cmd_mgr->lock,0xffffffff);
  msg_buf = (bl_cmd *)(cmd_mgr->cmds).next;
  pbVar2 = (bl_cmd *)0x0;
  do {
    if (msg_buf == (bl_cmd *)&cmd_mgr->cmds) {
      msg_buf = (bl_cmd *)0x0;
      if (pbVar2 != (bl_cmd *)0x0) {
LAB_2300ab7c:
        uVar1 = cmd->flags;
        cmd->flags = uVar1 & 0xfff7;
        if ((uVar1 & 0x10) == 0) {
          cmd_complete((bl_cmd *)&cmd_mgr->queue_sz);
        }
        if (msg_buf != (bl_cmd *)0x0) {
LAB_2300ab98:
          msg_buf->flags = msg_buf->flags & 0xfffb;
          ipc_host_msg_push(*(ipc_host_env_tag **)(cmd_mgr + 1),msg_buf,
                            (uint16_t)(((uint)msg_buf->a2e_msg->param_len + 8) * 0x10000 >> 0x10));
          vPortFree(msg_buf->a2e_msg);
        }
      }
      xQueueGenericSend((QueueHandle_t)cmd_mgr->lock,(void *)0x0,0,0);
      return 0;
    }
    if ((pbVar2 == (bl_cmd *)0x0) && ((list_head *)msg_buf->tkn == (list_head *)cmd->tkn)) {
      pbVar2 = msg_buf;
      if ((msg_buf != cmd) && (__warned == false)) {
        printf("%s:%d\r\n","cmd_mgr_llind",0xcf);
        __warned = true;
      }
    }
    else {
      if ((msg_buf->flags & 4) != 0) {
        if (pbVar2 == (bl_cmd *)0x0) goto LAB_2300ab98;
        goto LAB_2300ab7c;
      }
    }
    msg_buf = (bl_cmd *)(msg_buf->list).next;
  } while( true );
}



undefined4 cmd_mgr_queue(char *param_1,char **param_2)

{
  bool bVar1;
  ushort uVar2;
  undefined4 uVar3;
  EventBits_t EVar4;
  char *pcVar5;
  char **ppcVar6;
  int iVar7;
  
  xQueueSemaphoreTake(*(QueueHandle_t *)(param_1 + 0x18),0xffffffff);
  if (*param_1 == '\x02') {
    param_2[0xf] = &DAT_00000020;
    xQueueGenericSend(*(QueueHandle_t *)(param_1 + 0x18),(void *)0x0,0,0);
    uVar3 = 0xffffffe0;
  }
  else {
    if (param_1 + 0x10 == *(char **)(param_1 + 0x10)) {
      bVar1 = false;
    }
    else {
      if (*(int *)(param_1 + 8) == *(int *)(param_1 + 0xc)) {
        param_2[0xf] = &DAT_0000000c;
        xQueueGenericSend(*(QueueHandle_t *)(param_1 + 0x18),(void *)0x0,0,0);
        return 0xfffffff4;
      }
      bVar1 = false;
      if ((*(ushort *)(*(int *)(param_1 + 0x14) + 0x18) & 0xc) != 0) {
        bVar1 = true;
        *(ushort *)(param_2 + 6) = *(ushort *)(param_2 + 6) | 4;
      }
    }
    if ((*(ushort *)(param_2 + 6) & 2) == 0) {
      uVar2 = 8;
    }
    else {
      uVar2 = 0x18;
    }
    *(ushort *)(param_2 + 6) = *(ushort *)(param_2 + 6) | uVar2;
    pcVar5 = *(char **)(param_1 + 4);
    *(char **)(param_1 + 4) = pcVar5 + 1;
    param_2[5] = pcVar5;
    param_2[0xf] = &DAT_00000004;
    if ((*(ushort *)(param_2 + 6) & 1) == 0) {
      xEventGroupCreateStatic((StaticEventGroup_t *)(param_2 + 7));
    }
    ppcVar6 = *(char ***)(param_1 + 0x14);
    *(char ***)(param_1 + 0x14) = param_2;
    *param_2 = param_1 + 0x10;
    *(char ***)(param_2 + 1) = ppcVar6;
    *(char ***)ppcVar6 = param_2;
    iVar7 = *(int *)(param_1 + 8);
    *(int *)(param_1 + 8) = iVar7 + 1;
    xQueueGenericSend(*(QueueHandle_t *)(param_1 + 0x18),(void *)0x0,0,0);
    if (!bVar1) {
      ipc_host_msg_push(*(ipc_host_env_tag **)(param_1 + 0x30),param_2,
                        (uint16_t)(((uint)*(ushort *)(param_2[3] + 6) + 8) * 0x10000 >> 0x10));
      vPortFree(param_2[3]);
    }
    if ((*(ushort *)(param_2 + 6) & 1) == 0) {
      EVar4 = xEventGroupWaitBits((EventGroupHandle_t)(param_2 + 7),1,1,0,(iVar7 + 1) * 1000000);
      if ((EVar4 & 1) == 0) {
        xQueueSemaphoreTake(*(QueueHandle_t *)(param_1 + 0x18),0xffffffff);
        *param_1 = '\x02';
        if ((*(ushort *)(param_2 + 6) & 0x20) == 0) {
          param_2[0xf] = (char *)0x6e;
          cmd_complete((bl_cmd *)(param_1 + 8));
        }
        xQueueGenericSend(*(QueueHandle_t *)(param_1 + 0x18),(void *)0x0,0,0);
      }
      vEventGroupDelete((EventGroupHandle_t)(param_2 + 7));
    }
    else {
      param_2[0xf] = (char *)0x0;
    }
    uVar3 = 0;
  }
  return uVar3;
}



void cmd_mgr_drain(bl_cmd_mgr *cmd_mgr)

{
  list_head *plVar1;
  list_head *plVar2;
  list_head *plVar3;
  list_head *plVar4;
  
  xQueueSemaphoreTake((QueueHandle_t)cmd_mgr->lock,0xffffffff);
  plVar2 = (cmd_mgr->cmds).next;
  plVar3 = plVar2->next;
  while (plVar1 = plVar3, plVar2 != &cmd_mgr->cmds) {
    plVar4 = plVar2->prev;
    plVar3 = plVar2->next;
    plVar3->prev = plVar4;
    plVar4->next = plVar3;
    plVar2->next = (list_head *)0x100100;
    plVar2->prev = (list_head *)0x200200;
    cmd_mgr->queue_sz = cmd_mgr->queue_sz - 1;
    if ((*(ushort *)&plVar2[3].next & 1) == 0) {
      xEventGroupSetBits((EventGroupHandle_t)&plVar2[3].prev,1);
    }
    plVar3 = plVar1->next;
    plVar2 = plVar1;
  }
  xQueueGenericSend((QueueHandle_t)cmd_mgr->lock,(void *)0x0,0,0);
  return;
}



void bl_cmd_mgr_init(bl_cmd_mgr *cmd_mgr)

{
  QueueHandle_t pQVar1;
  
  (cmd_mgr->cmds).next = &cmd_mgr->cmds;
  (cmd_mgr->cmds).prev = &cmd_mgr->cmds;
  pQVar1 = xQueueCreateMutex('\x01');
  cmd_mgr->max_queue_sz = 8;
  cmd_mgr->queue = cmd_mgr_queue;
  cmd_mgr->print = cmd_mgr_print;
  cmd_mgr->drain = cmd_mgr_drain;
  cmd_mgr->llind = cmd_mgr_llind;
  *(QueueHandle_t *)&cmd_mgr->lock = pQVar1;
  cmd_mgr->msgind = cmd_mgr_msgind;
  return;
}



int bl_irqs_init(bl_hw *bl_hw)

{
  return 0;
}



void bl_irq_bottomhalf(bl_hw *bl_hw)

{
  uint uVar1;
  uint status;
  TickType_t TVar2;
  
  xTaskGetTickCount();
  uVar1 = 0;
  status = ipc_host_get_rawstatus(bl_hw->ipc_env);
  do {
    while (status != 0) {
      uVar1 = uVar1 | status;
      ipc_host_irq(bl_hw->ipc_env,status);
      status = ipc_host_get_rawstatus(bl_hw->ipc_env);
    }
    TVar2 = xTaskGetTickCount();
    if ((uVar1 & 8) != 0) {
      (bl_hw->stats).last_rx = TVar2;
    }
    if ((uVar1 & 0x780) != 0) {
      (bl_hw->stats).last_tx = TVar2;
    }
    ipc_host_enable_irq(bl_hw->ipc_env,0x7ff);
    status = ipc_host_get_rawstatus(bl_hw->ipc_env);
  } while (status != 0);
  return;
}



uint32_t BLE_ROM_patch(void *pRet,...)

{
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

void blecontroller_main(void *pvParameters)

{
  BaseType_t BVar1;
  char acStack24 [4];
  rw_task_msg_t msg;
  
  (*ble_memset_ptr)(acStack24,0,8);
  do {
    BVar1 = xQueueReceive(xRwmainQueue,acStack24,0xffffffff);
    if ((BVar1 == 1) && (acStack24[0] == '\x01')) {
      hci_send_2_controller(msg._0_4_);
    }
    rwip_schedule();
  } while( true );
}



void BLE_ROM_hook_init(void)

{
  _rom_patch_hook = BLE_ROM_patch;
  ble_memcmp_ptr = memcmp;
  ble_memcpy_ptr = memcpy;
  ble_memset_ptr = memset;
  ble_post_task_ptr = rw_main_task_post_from_fw;
  return;
}



_Bool rw_main_task_post(void *msg,uint32_t timeout)

{
  BaseType_t BVar1;
  
  if (msg != (void *)0x0) {
    BVar1 = xQueueGenericSend(xRwmainQueue,msg,timeout,0);
    return (_Bool)(BVar1 == 1);
  }
  return false;
}



// WARNING: Could not reconcile some variable overlaps

void rw_main_task_post_from_fw(void)

{
  BaseType_t BStack28;
  BaseType_t xHigherPriorityTaskWoken;
  rw_task_msg_t msg;
  
  xHigherPriorityTaskWoken._0_1_ = 2;
  if (TrapNetCounter == 0) {
    rw_main_task_post(&xHigherPriorityTaskWoken,0xffffffff);
  }
  else {
    BStack28 = 0;
    xQueueGenericSendFromISR(xRwmainQueue,&xHigherPriorityTaskWoken,&BStack28,0);
    if (BStack28 == 1) {
      vTaskSwitchContext();
    }
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

void bdaddr_init(void)

{
  uint8_t uVar1;
  uint8_t uVar2;
  byte bStack24;
  byte bStack23;
  undefined2 uStack22;
  uint8_t addr [6];
  
  bl_wifi_mac_addr_get(&bStack24);
  uVar2 = addr[1];
  uVar1 = addr[0];
  addr[1] = bStack24;
  addr[0] = bStack23;
  bStack23 = uVar1;
  uStack22 = uStack22 >> 8 | uStack22 << 8;
  if (uVar2 == -1) {
    bStack23 = uVar1 + 1;
    bStack24 = 0;
  }
  else {
    bStack24 = uVar2 + 1;
  }
  co_bdaddr_set(&bStack24);
  printf("BD_ADDR:%02x:%02x:%02x:%02x:%02x:%02x\r\n",(uint)addr[0],(uint)uStack22._1_1_,
         (uint)(byte)uStack22,(uint)bStack23,(uint)bStack24);
  return;
}



void ble_controller_init(uint8_t task_priority)

{
  undefined3 in_register_00002029;
  
  BLE_ROM_hook_init();
  rfc_init(40000000);
  Is_ext_scan_enable = '\0';
  Is_ready_to_rec_auxpacket = '\0';
  rwble_isr_clear();
  bl_irq_pending_clear(0x48);
  bl_irq_register(0x48,rwble_isr);
  bl_irq_enable(0x48);
  bdaddr_init();
  rwip_init(error);
  xRwmainQueue = xQueueGenericCreate(0x14,8,'\0');
  xTaskCreate(blecontroller_main,"blecontroller",0x200,(void *)0x0,
              CONCAT31(in_register_00002029,task_priority),(TaskHandle_t *)&rw_main_task_hdl);
  return;
}



void ble_controller_deinit(void)

{
  BaseType_t BVar1;
  undefined auStack24 [4];
  int iStack20;
  
  (*ble_memset_ptr)(auStack24,0,8);
  bl_irq_disable(0x48);
  vTaskDelete((TaskHandle_t)rw_main_task_hdl);
  rw_main_task_hdl = 0;
  while (BVar1 = xQueueReceive(xRwmainQueue,auStack24,0), BVar1 == 1) {
    if (iStack20 != 0) {
      ble_ke_msg_free((ke_msg *)(iStack20 + -0xc));
    }
  }
  vQueueDelete(xRwmainQueue);
  xRwmainQueue = (QueueHandle_t)0x0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rwble_init(void)

{
  em_buf_init();
  lld_init(false);
  llc_init();
  llm_init(false);
  _DAT_28000050 = 0;
  return;
}


/*
Unable to decompile 'rwble_reset'
Cause: Exception while decompiling 2300b132: Decompiler process died

*/


// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rwble_isr_clear(void)

{
  if (_DAT_28000010 != 0) {
    _DAT_28000018 = 0xffffffff;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rwble_isr(void)

{
  uint uVar1;
  
  while (uVar1 = _DAT_28000010, _DAT_28000010 != 0) {
    if ((_DAT_28000010 & 4) != 0) {
      _DAT_28000018 = 4;
      rwip_wakeup();
    }
    if ((uVar1 & 1) != 0) {
      _DAT_28000018 = 1;
      rwip_wakeup_end();
      ea_finetimer_isr();
    }
    if ((uVar1 & 0x80) != 0) {
      _DAT_28000018 = 0x80;
      ea_finetimer_isr();
    }
    if ((uVar1 & 8) != 0) {
      _DAT_28000018 = 8;
      if ((uVar1 & 2) != 0) {
        _DAT_28000018 = 2;
        uVar1 = uVar1 & 0xfffffffd;
      }
      if ((int)(uVar1 << 0xf) < 0) {
        if (Is_ready_to_rec_auxpacket == '\0') {
          Is_ready_to_rec_auxpacket = '\x01';
        }
        _DAT_28000018 = 0x10000;
      }
      lld_evt_end_isr(false);
    }
    if ((uVar1 & 0x10008) == 0x10000) {
      if (Is_ready_to_rec_auxpacket == '\0') {
        Is_ready_to_rec_auxpacket = '\x01';
        Rec_sync_basecnt = _DAT_280000a8;
        Rec_sync_fnt = _DAT_280000ac;
      }
      _DAT_28000018 = 0x10000;
      if ((uVar1 & 2) != 0) {
        _DAT_28000018 = 2;
        uVar1 = uVar1 & 0xfffffffd;
      }
      lld_evt_afs_isr((uint8_t)(Rec_sync_fnt >> 0x10));
    }
    if ((uVar1 & 0x100) != 0) {
      _DAT_28000018 = 0x100;
      if ((uVar1 & 2) != 0) {
        _DAT_28000018 = 2;
        uVar1 = uVar1 & 0xfffffffd;
      }
      lld_evt_end_isr(true);
    }
    if ((uVar1 & 2) != 0) {
      _DAT_28000018 = 2;
      lld_evt_rx_isr();
    }
    if ((uVar1 & 0x200) != 0) {
      _DAT_28000018 = 0x200;
      ea_sw_isr();
    }
    if ((uVar1 & 0x40) != 0) {
      _DAT_28000018 = 0x40;
      lld_evt_timer_isr();
    }
    if ((uVar1 & 0x10) != 0) {
      _DAT_28000018 = 0x10;
      lld_crypt_isr();
    }
    if ((uVar1 & 0x20) != 0) {
      _DAT_28000018 = 0x20;
    }
  }
  return;
}



uint8_t ea_conflict_check(ea_elt_tag *evt_a,ea_elt_tag *evt_b)

{
  uint8_t uVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  
  uVar2 = evt_b->timestamp - evt_a->timestamp & 0x7ffffff;
  uVar5 = (uint)evt_a->delay;
  uVar3 = (uint)evt_b->delay;
  if (uVar2 < 0x4000001) {
    if (uVar2 == 0) goto LAB_2300b31e;
LAB_2300b36a:
    iVar4 = (uVar5 + evt_a->duration_min) - uVar3;
    uVar1 = '\0';
    if ((0 < iVar4) && (uVar1 = '\0', (int)((iVar4 + -1) / -0x271 + uVar2) < 1)) {
      uVar1 = '\x01';
      iVar4 = iVar4 - (uint)evt_b->duration_min;
      if (0 < iVar4) {
        return ((int)((iVar4 + -1) / -0x271 + uVar2) < 1) + '\x01';
      }
    }
  }
  else {
    uVar2 = -(evt_a->timestamp - evt_b->timestamp & 0x7ffffff);
    if (uVar2 == 0) {
LAB_2300b31e:
      if (uVar5 < uVar3) goto LAB_2300b36a;
    }
    iVar4 = (uVar3 + (uint)evt_b->duration_min) - uVar5;
    uVar1 = '\x05';
    if ((0 < iVar4) && (-1 < (int)((iVar4 + -1) / 0x271 + uVar2))) {
      iVar4 = ((uVar5 + evt_a->duration_min) - uVar3) - (uint)evt_b->duration_min;
      uVar1 = '\x04';
      if (iVar4 < 1) {
        uVar1 = ((int)(iVar4 / -0x271 + uVar2) < 0) + '\x03';
      }
    }
  }
  return uVar1;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ea_elt_cancel(ea_elt_tag *param_1)

{
  ushort uVar1;
  ea_elt_tag *peVar2;
  uint8_t uVar3;
  undefined3 extraout_var;
  uint uVar4;
  uint uVar5;
  ea_elt_tag *evt_b;
  uint uVar6;
  uint uVar7;
  ea_elt_tag *peVar8;
  ea_elt_tag *evt_a;
  ea_elt_tag *elt_ref_hdr;
  ea_elt_tag *elt_ref_hdr_00;
  
  peVar8 = (ea_elt_tag *)ea_env.elt_canceled.first;
  evt_a = (ea_elt_tag *)0;
LAB_2300b3e6:
  do {
    do {
      elt_ref_hdr = evt_a;
      evt_a = peVar8;
      if (evt_a == (ea_elt_tag *)0x0) {
        if (ea_env.elt_canceled.first != (co_list_hdr *)0x0) {
          _DAT_28000000 = _DAT_28000000 & 0xefffffff | 0x10000000;
        }
        return;
      }
      uVar1 = evt_a->asap_settings;
      peVar8 = *(ea_elt_tag **)&evt_a->hdr;
    } while ((uVar1 >> 0xe == 0) || (uVar5 = (int)(uint)uVar1 >> 4 & 0x3f, uVar5 == 0));
    uVar4 = (uint)uVar1 & 0xfffffc0f;
    evt_a->current_prio = ((byte)uVar1 & 0xf) + evt_a->current_prio;
    uVar5 = (uVar5 - 1) * 0x10;
    uVar6 = uVar5 & 0xffff | uVar4;
    evt_a->asap_settings = (ushort)uVar5 | (ushort)uVar4;
    uVar5 = (int)uVar6 >> 0xc & 3;
    peVar2 = param_1;
    elt_ref_hdr_00 = (ea_elt_tag *)0x0;
    while (evt_b = peVar2, evt_b != (ea_elt_tag *)0x0) {
      uVar3 = ea_conflict_check(evt_a,evt_b);
      if (CONCAT31(extraout_var,uVar3) == 0) break;
      if (CONCAT31(extraout_var,uVar3) != 5) {
        uVar4 = (uint)evt_b->delay + (uint)evt_b->duration_min;
        uVar7 = uVar4 / 0x271 + evt_b->timestamp;
        if ((uint)evt_a->delay < uVar4 % 0x271) {
          uVar7 = uVar7 + 1;
        }
        if (uVar5 == 1) {
          uVar7 = uVar7 | 1;
        }
        else {
          if (uVar5 == 0) {
            uVar7 = uVar7 + 1 & 0xfffffffe;
          }
        }
        uVar7 = uVar7 & 0x7ffffff;
        evt_a->timestamp = uVar7;
        if (1 < uVar6 >> 0xe) {
          uVar4 = evt_a->asap_limit - uVar7 & 0x7ffffff;
          if (0x4000000 < uVar4) {
            uVar4 = -(uVar7 - evt_a->asap_limit & 0x7ffffff);
          }
          if ((int)uVar4 < (int)((uint)evt_a->duration_min / 0x271)) goto LAB_2300b3e6;
        }
      }
      peVar2 = *(ea_elt_tag **)&evt_b->hdr;
      elt_ref_hdr_00 = evt_b;
    }
    ble_co_list_extract_after(&ea_env.elt_canceled,(co_list_hdr *)elt_ref_hdr,(co_list_hdr *)evt_a);
    ble_co_list_insert_after((co_list *)&ea_env,(co_list_hdr *)elt_ref_hdr_00,(co_list_hdr *)evt_a);
    evt_a = elt_ref_hdr;
  } while( true );
}



void ea_init(_Bool reset)

{
  ble_co_list_init((co_list *)&ea_env);
  ble_co_list_init(&ea_env.elt_canceled);
  ble_co_list_init(&ea_env.interval_list);
  ea_env.elt_prog = (ea_elt_tag *)0x0;
  ea_env.finetarget_time = 0xffffffff;
  return;
}



ea_elt_tag * ea_elt_create(uint16_t size_of_env)

{
  undefined2 in_register_0000202a;
  ea_elt_tag *peVar1;
  uint32_t size;
  
  size = CONCAT22(in_register_0000202a,size_of_env) + 0x2c;
  peVar1 = (ea_elt_tag *)ble_ke_malloc(size,'\0');
  if (peVar1 != (ea_elt_tag *)0x0) {
    (*ble_memset_ptr)(peVar1,0,size);
  }
  return peVar1;
}



ea_interval_tag * ea_interval_create(void)

{
  ea_interval_tag *peVar1;
  
  peVar1 = (ea_interval_tag *)ble_ke_malloc(0x10,'\0');
  (*ble_memset_ptr)(peVar1,0,0x10);
  return peVar1;
}



void ea_interval_insert(ea_interval_tag *interval_to_add)

{
  ble_co_list_push_back(0x42010f18,interval_to_add);
  return;
}



void ea_interval_remove(ea_interval_tag *interval_to_remove)

{
  ble_co_list_extract(&ea_env.interval_list,(co_list_hdr *)interval_to_remove,'\0');
  return;
}



void ea_sw_isr(void)

{
  co_list_hdr *pcVar1;
  
  while (ea_env.elt_canceled.first != (co_list_hdr *)0x0) {
    pcVar1 = ble_co_list_pop_front(&ea_env.elt_canceled);
    if (pcVar1[9].next != (co_list_hdr *)0x0) {
      (*(code *)pcVar1[9].next)();
    }
  }
  return;
}



uint8_t ea_offset_req(ea_param_input *input_param,ea_param_output *output_param)

{
  uint16_t uVar1;
  ushort uVar2;
  uint uVar3;
  uint uVar4;
  co_list_hdr cVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint8_t uVar9;
  uint uVar10;
  int iVar11;
  uint uVar12;
  uint uVar13;
  uint uVar14;
  
  uVar13 = (uint)output_param->interval;
  if (output_param->interval != 0) {
    uVar14 = output_param->duration & 0xffff;
    if (uVar14 != 0) {
      if (input_param->action == '\x01') {
        uVar6 = (uint)input_param->offset;
      }
      else {
        uVar6 = (uint)input_param->odd_offset;
      }
      uVar3 = output_param->duration & 0xffff;
      cVar5 = (co_list_hdr)ea_env.interval_list.first;
LAB_2300b634:
      do {
        uVar7 = uVar6;
        if (cVar5 == (co_list_hdr)0x0) {
          uVar9 = '\x03';
          if (uVar7 < uVar13) {
LAB_2300b644:
            output_param->offset = (uint16_t)uVar7;
            uVar9 = '\0';
          }
          return uVar9;
        }
        if (uVar13 <= uVar7) {
          return '\x03';
        }
        uVar1 = input_param->role;
        if (uVar1 == 0xff) goto LAB_2300b644;
        uVar2 = *(ushort *)&((co_list_hdr *)((int)cVar5 + 4))->next;
        uVar6 = (uint)uVar2;
        if (((uVar2 != 0) &&
            (uVar2 = *(ushort *)&((co_list_hdr *)((int)cVar5 + 8))->next, uVar10 = (uint)uVar2,
            uVar2 != 0)) && (*(uint16_t *)((int)cVar5 + 10) != input_param->conhdl)) {
          uVar4 = uVar6;
          if (uVar13 < uVar6) {
            uVar4 = uVar13;
          }
          if ((*(uint16_t *)&((co_list_hdr *)((int)cVar5 + 0xc))->next == uVar1) &&
             ((uVar1 != 1 || (*(uint16_t *)((int)cVar5 + 0xe) == input_param->linkid)))) {
            if (uVar4 < uVar3 + uVar10) {
              return '\x03';
            }
            iVar11 = uVar10 - 1;
            uVar10 = (uint)*(ushort *)((int)cVar5 + 6) % uVar4;
          }
          else {
            if (uVar4 < uVar3 + uVar10) {
              return '\x03';
            }
            iVar11 = uVar10 + 1;
            uVar10 = (int)(*(ushort *)((int)cVar5 + 6) + uVar4 + -1) % uVar4 & 0xffff;
          }
          uVar12 = iVar11 + uVar10 & 0xffff;
          if ((uVar13 % uVar4 == 0) && (uVar6 % uVar4 == 0)) {
            uVar6 = uVar7 % uVar4;
            uVar8 = uVar6 + (uVar14 - 1) & 0xffff;
            if (uVar6 < uVar10) {
              if (uVar8 < uVar10) {
LAB_2300b716:
                if (uVar8 < uVar12) goto LAB_2300b71a;
              }
            }
            else {
              if (uVar12 < uVar6) {
                if (uVar8 < uVar10) {
                  if (uVar10 == uVar6) goto LAB_2300b716;
                }
                else {
                  if ((uVar8 <= uVar12) || (uVar6 <= uVar10)) goto LAB_2300b6f4;
                }
LAB_2300b71a:
                if (((uVar12 < uVar4) || (uVar12 % uVar4 < uVar6)) &&
                   ((uVar8 < uVar4 || (uVar8 % uVar4 < uVar10)))) goto LAB_2300b6bc;
              }
            }
LAB_2300b6f4:
            cVar5 = (co_list_hdr)ea_env.interval_list.first;
            uVar6 = uVar13;
            if (input_param->action != '\x01') {
              uVar6 = (int)(uVar12 + 1) % uVar4;
              while (uVar6 <= uVar7) {
                uVar6 = uVar6 + uVar4 & 0xffff;
              }
              if (input_param->odd_offset == false) {
                if ((uVar6 & 1) == 0) goto LAB_2300b634;
              }
              else {
                if ((uVar6 & 1) != 0) goto LAB_2300b634;
              }
              uVar6 = uVar6 + 1 & 0xffff;
            }
            goto LAB_2300b634;
          }
        }
LAB_2300b6bc:
        cVar5 = *(co_list_hdr *)cVar5;
        uVar6 = uVar7;
      } while( true );
    }
  }
  return '\x01';
}



// WARNING: Removing unreachable block (ram,0x2300b784)

uint32_t ea_time_get_halfslot_rounded(void)

{
                    // WARNING: Do nothing block with infinite loop
  do {
  } while( true );
}



// WARNING: Removing unreachable block (ram,0x2300b7a4)

uint32_t ea_time_get_slot_rounded(void)

{
                    // WARNING: Do nothing block with infinite loop
  do {
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ea_prog_timer(void)

{
  byte bVar1;
  _Bool time_msb;
  uint32_t uVar2;
  uint uVar3;
  co_list_hdr cVar4;
  
  ea_env.finetarget_time = 0xffffffff;
  uVar2 = ea_time_get_slot_rounded();
  if (ea_env.elt_wait.first == (co_list_hdr *)0x0) {
    if (ea_env.finetarget_time == 0xffffffff) {
      _DAT_2800000c = _DAT_2800000c & 0xffffff7f;
      _DAT_28000018 = 0x80;
      goto LAB_2300b898;
    }
  }
  else {
    ea_env.finetarget_time =
         (uint)((int)ea_env.elt_wait.first[2].next -
               (uint)*(byte *)((int)&ea_env.elt_wait.first[6].next + 1)) & 0x7ffffff;
    if (ea_env.elt_prog != (ea_elt_tag *)0x0) {
      if (((ea_env.elt_prog)->current_prio < *(byte *)((int)&ea_env.elt_wait.first[5].next + 2)) &&
         ((int)((uint)*(ushort *)&ea_env.elt_wait.first[4].next << 0x14) < 0)) {
        bVar1 = (ea_env.elt_prog)->stop_latency2;
      }
      else {
        bVar1 = (ea_env.elt_prog)->stop_latency1;
      }
      if ((uint)*(byte *)((int)&ea_env.elt_wait.first[6].next + 1) < (uint)bVar1) {
        ea_env.finetarget_time =
             (uint)((int)ea_env.elt_wait.first[2].next - (uint)bVar1) & 0x7ffffff;
        uVar3 = ea_env.finetarget_time - uVar2 & 0x7ffffff;
        if ((0x4000000 < uVar3) || (uVar3 == 0)) {
          ea_env.finetarget_time = uVar2 + 1 & 0x7ffffff;
        }
      }
    }
  }
  uVar2 = ea_time_get_slot_rounded();
  if (uVar2 - ea_env.finetarget_time < 0x3ffffff) {
    ea_env.finetarget_time = uVar2 + 1 & 0x7ffffff;
  }
  _DAT_280000f8 = ea_env.finetarget_time;
  if ((_DAT_2800000c >> 7 & 1) == 0) {
    _DAT_28000018 = 0x80;
    _DAT_2800000c = _DAT_2800000c | 0x80;
  }
LAB_2300b898:
  if ((time_msb != false) &&
     (cVar4 = (co_list_hdr)ea_env.interval_list.first, -1 < (int)(uVar2 << 5))) {
    while (cVar4 != (co_list_hdr)0x0) {
      uVar3 = (uint)*(ushort *)&((co_list_hdr *)((int)cVar4 + 4))->next;
      *(undefined2 *)((int)cVar4 + 6) =
           (short)((int)((uVar3 - 0x8000000 % uVar3) + (uint)*(ushort *)((int)cVar4 + 6)) % uVar3);
      cVar4 = *(co_list_hdr *)cVar4;
    }
  }
  return;
}


/*
Unable to decompile 'ea_elt_insert'
Cause: Exception while decompiling 2300b8e8: Decompiler process died

*/

/*
Unable to decompile 'ea_elt_remove'
Cause: Exception while decompiling 2300bb56: Decompiler process died

*/


// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ea_finetimer_isr(void)

{
  byte bVar1;
  ea_elt_tag *peVar2;
  uint32_t uVar3;
  co_list_hdr *pcVar4;
  ea_elt_tag *peVar5;
  uint uVar6;
  
  peVar2 = ea_env.elt_prog;
  pcVar4 = ea_env.elt_wait.first;
  uVar3 = ea_time_get_halfslot_rounded();
  if (peVar2 != (ea_elt_tag *)0x0) {
    if (pcVar4 == (co_list_hdr *)0x0) goto LAB_2300bc68;
    if ((peVar2->current_prio < *(byte *)((int)&pcVar4[5].next + 2)) &&
       ((int)((uint)*(ushort *)&pcVar4[4].next << 0x14) < 0)) {
      bVar1 = peVar2->stop_latency2;
    }
    else {
      bVar1 = peVar2->stop_latency1;
    }
    uVar6 = (uint)((int)pcVar4[2].next - uVar3) & 0x7ffffff;
    if ((0x4000000 < uVar6) || (uVar6 <= bVar1)) {
      if (peVar2->ea_cb_stop != (anon_subr_void_ea_elt_tag_ptr_for_ea_cb_stop *)0x0) {
        (*peVar2->ea_cb_stop)(peVar2);
      }
      ea_env.elt_prog = (ea_elt_tag *)0x0;
    }
  }
  if (pcVar4 != (co_list_hdr *)0x0) {
    do {
      uVar6 = (uint)((int)pcVar4[2].next - (uint)*(byte *)((int)&pcVar4[6].next + 1)) & 0x7ffffff;
      if ((uVar6 - uVar3 & 0x7ffffff) < 0x3ffffff) {
        if (uVar6 == uVar3) {
          peVar5 = (ea_elt_tag *)ble_co_list_pop_front((co_list *)&ea_env);
          if ((ea_env.elt_prog != (ea_elt_tag *)0x0) &&
             ((ea_env.elt_prog)->ea_cb_stop != (anon_subr_void_ea_elt_tag_ptr_for_ea_cb_stop *)0x0))
          {
            (*(ea_env.elt_prog)->ea_cb_stop)(peVar2);
          }
          ea_env.elt_prog = peVar5;
          if (peVar5->ea_cb_start != (anon_subr_void_ea_elt_tag_ptr_for_ea_cb_start *)0x0) {
            (*peVar5->ea_cb_start)(peVar5);
          }
        }
        break;
      }
      pcVar4 = ble_co_list_pop_front((co_list *)&ea_env);
      ble_co_list_push_back(0x42010f10,pcVar4);
      pcVar4 = ea_env.elt_wait.first;
    } while (ea_env.elt_wait.first != (co_list_hdr *)0x0);
  }
LAB_2300bc68:
  if (ea_env.elt_canceled.first != (co_list_hdr *)0x0) {
    _DAT_28000000 = _DAT_28000000 & 0xefffffff | 0x10000000;
  }
  ea_prog_timer();
  return;
}



void ea_interval_duration_req(ea_param_input *input_param,ea_param_output *output_param)

{
  bool bVar1;
  co_list_hdr cVar2;
  uint uVar3;
  uint uVar4;
  byte bVar5;
  uint uVar6;
  uint uVar7;
  uint32_t uVar8;
  uint uVar9;
  
  uVar3 = (uint)input_param->interval_max;
  output_param->interval = input_param->interval_max;
  uVar9 = (uint)input_param->interval_min;
  if (uVar3 <= uVar9) goto LAB_2300bd0e;
  bVar5 = 0;
  cVar2 = (co_list_hdr)ea_env.interval_list.first;
  uVar4 = 0xffff;
  while (cVar2 != (co_list_hdr)0x0) {
    bVar5 = bVar5 + 1;
    uVar6 = uVar4;
    if ((*(uint16_t *)((int)cVar2 + 10) != input_param->conhdl) &&
       (uVar6 = (uint)*(ushort *)&((co_list_hdr *)((int)cVar2 + 4))->next, uVar4 < uVar6)) {
      uVar6 = uVar4;
    }
    cVar2 = *(co_list_hdr *)cVar2;
    uVar4 = uVar6;
  }
  if (bVar5 < 2) {
    uVar4 = (uint)input_param->pref_period;
    if (input_param->pref_period != 0) {
      uVar6 = (int)uVar3 / (int)uVar4;
LAB_2300bcfa:
      uVar7 = uVar4 * uVar6 & 0xffff;
      goto LAB_2300bd02;
    }
    uVar7 = 0xffff;
  }
  else {
    if (uVar4 <= uVar3) {
      uVar6 = uVar3 / uVar4;
      goto LAB_2300bcfa;
    }
    uVar7 = 0xffff;
    uVar6 = uVar3;
    do {
      bVar1 = uVar4 % uVar6 != 0;
      if (!bVar1) {
        uVar7 = uVar6;
      }
      uVar6 = uVar6 - 2 & 0xffff;
    } while ((uVar9 <= uVar6) && (bVar1));
LAB_2300bd02:
    if (uVar7 < uVar9) goto LAB_2300bd0e;
  }
  if (uVar7 <= uVar3) {
    output_param->interval = (uint16_t)uVar7;
  }
LAB_2300bd0e:
  uVar8 = input_param->duration_min;
  if (uVar8 < 2) {
    uVar8 = 2;
  }
  output_param->duration = uVar8;
  return;
}



void hci_send_2_host(void *param)

{
  byte bVar1;
  ushort uVar2;
  ke_msg *msg;
  void *pvVar3;
  uint uVar4;
  uint uVar5;
  
  uVar2 = *(ushort *)((int)param + -8);
  msg = (ke_msg *)((int)param + -0xc);
  if (uVar2 == 0x803) {
    bVar1 = *(byte *)((int)param + -4);
    uVar4 = (uint)bVar1;
    if (bVar1 < 0x40) goto LAB_2300bdca;
    if ((bVar1 < 0x58) &&
       (uVar5 = uVar4 - 0x40 & 0xff,
       ((int)(uint)hci_env.evt_msk_page_2.mask[uVar5 >> 3] >> (uVar5 - (uVar4 - 0x40 & 0xf8) & 0x1f)
       & 1U) == 0)) goto switchD_2300bdbc_caseD_4;
switchD_2300bdbc_caseD_2:
    hci_build_evt(msg);
  }
  else {
    if (uVar2 == 0x804) {
      uVar4 = 0x3e;
LAB_2300bdca:
      uVar5 = uVar4 - 1 & 0xff;
      if (((int)(uint)hci_env.evt_msk.mask[uVar5 >> 3] >> (uVar5 - (uVar4 - 1 & 0xf8) & 0x1f) & 1U)
          == 0) goto switchD_2300bdbc_caseD_4;
    }
    switch((uint)uVar2 - 0x801 & 0xffff) {
    case 0:
    case 1:
      if (uVar2 == 0x801) {
        hci_build_cc_evt(msg,'\0');
      }
      break;
    case 2:
      goto switchD_2300bdbc_caseD_2;
    case 3:
      hci_build_le_evt(msg);
      break;
    default:
switchD_2300bdbc_caseD_4:
      ble_ke_msg_free(msg);
      return;
    case 5:
      pvVar3 = ble_ke_msg_alloc(0x806,*(ke_task_id_t *)((int)param + -6),
                                *(ke_task_id_t *)((int)param + -4),8);
      (*ble_memcpy_ptr)(pvVar3,param,8);
      ble_ke_msg_free(msg);
      msg = (ke_msg *)((int)pvVar3 + -0xc);
      param = pvVar3;
    }
  }
  msg->dest_id = 4;
  ble_ke_msg_send(param);
  return;
}



void hci_send_2_controller(int param_1)

{
  hci_cmd_desc_tag *phVar1;
  ushort uVar2;
  
  if (*(short *)(param_1 + -8) == 0x805) {
    phVar1 = hci_look_for_cmd_desc(*(uint16_t *)(param_1 + -4));
    if (phVar1 == (hci_cmd_desc_tag *)0x0) goto switchD_2300bef4_caseD_4;
    switch((uint)phVar1->dest_field & 0xf) {
    case 0:
    case 2:
      uVar2 = 0;
      break;
    case 1:
    case 3:
      goto switchD_2300bef4_caseD_1;
    default:
      goto switchD_2300bef4_caseD_4;
    case 8:
      uVar2 = 3;
    }
  }
  else {
    if (*(short *)(param_1 + -8) != 0x807) goto switchD_2300bef4_caseD_4;
switchD_2300bef4_caseD_1:
    if (1 < *(ushort *)(param_1 + -6)) {
switchD_2300bef4_caseD_4:
      ble_ke_msg_free((ke_msg *)(param_1 + -0xc));
      return;
    }
    uVar2 = (ushort)(((uint)*(ushort *)(param_1 + -6) & 0xff) << 8) | 1;
  }
  *(ushort *)(param_1 + -6) = uVar2;
  ble_ke_msg_send(param_1);
  return;
}



uint8_t hci_evt_mask_set(evt_mask *evt_msk,uint8_t page)

{
  undefined3 in_register_0000202d;
  byte *pbVar1;
  int iVar2;
  hci_env_tag *phVar3;
  
  if (CONCAT31(in_register_0000202d,page) == 2) {
    (*ble_memcpy_ptr)((void *)0x4201961c,evt_msk,8);
  }
  else {
    if (CONCAT31(in_register_0000202d,page) == 3) {
      (*ble_memcpy_ptr)(&hci_env,evt_msk,8);
      iVar2 = 0;
      phVar3 = &hci_env;
      do {
        pbVar1 = hci_rsvd_evt_msk.mask + iVar2;
        iVar2 = iVar2 + 1;
        (phVar3->evt_msk).mask[0] = *pbVar1 | (phVar3->evt_msk).mask[0];
        phVar3 = (hci_env_tag *)((phVar3->evt_msk).mask + 1);
      } while (iVar2 != 8);
    }
  }
  return '\0';
}



void hci_init(void)

{
  (*ble_memset_ptr)(&hci_env,0,0x10);
  hci_evt_mask_set(&hci_def_evt_msk,'\x03');
  hci_tl_init(false);
  hci_fc_init();
  return;
}



void hci_reset(void)

{
  (*ble_memset_ptr)(&hci_env,0,0x10);
  hci_evt_mask_set(&hci_def_evt_msk,'\x03');
  hci_tl_init(true);
  hci_fc_init();
  return;
}


/*
Unable to decompile 'rwip_reset'
Cause: Exception while decompiling 2300bffc: Decompiler process died

*/


void rwip_init(uint32_t error)

{
  (*ble_memset_ptr)(&rwip_env,0,0x10);
  ble_ke_init();
  ble_ke_mem_init('\0',(uint8_t *)rwip_heap_ram,0xaff);
  ble_ke_mem_init('\x01',rwip_heap_em,0x10b6);
  ble_rf_init((rwip_rf_api_conflict5 *)&rwip_rf);
  ecc_init(0);
  hci_init();
  rwble_init();
  ea_init(false);
  rwip_env._8_4_ = 200;
  rwip_env.sleep_acc_error = 0;
  rwip_env._12_2_ = 0x101;
  rwip_reset();
  return;
}



void rwip_schedule(void)

{
  if ((rwip_env.prevent_sleep & 1) == 0) {
    ble_ke_event_schedule();
    return;
  }
  return;
}



void rwip_wakeup_delay_set(uint16_t wakeup_delay)

{
  undefined2 in_register_0000202a;
  
  rwip_env.lp_cycle_wakeup_delay =
       (uint)(CONCAT22(in_register_0000202a,wakeup_delay) << 0xf) / 1000000;
  return;
}


/*
Unable to decompile 'rwip_prevent_sleep_set'
Cause: Exception while decompiling 2300c106: Decompiler process died

*/


void rwip_wakeup(void)

{
  rwip_prevent_sleep_set(1);
  lld_sleep_wakeup();
  return;
}


/*
Unable to decompile 'rwip_prevent_sleep_clear'
Cause: Exception while decompiling 2300c138: Decompiler process died

*/


void rwip_wakeup_end(void)

{
  if ((rwip_env.prevent_sleep & 1) != 0) {
    lld_sleep_wakeup_end();
    ble_ke_event_set('\x03');
    rwip_prevent_sleep_clear(1);
    return;
  }
  return;
}



uint32_t rwip_sleep_lpcycles_2_us(uint32_t lpcycles)

{
  uint uVar1;
  
  uVar1 = rwip_env.sleep_acc_error + lpcycles * 0x109;
  rwip_env.sleep_acc_error = uVar1 & 0x1ff;
  return lpcycles * 0x1e + (uVar1 >> 9);
}



uint32_t rwip_us_2_lpcycles(uint32_t us)

{
  return (us << 0xf) / 1000000;
}



void ble_co_list_init(co_list *list)

{
  uint32_t uVar1;
  
  uVar1 = (*_rom_patch_hook)((void *)0x0,list,_rom_patch_hook);
  if (uVar1 == 0) {
    list->first = (co_list_hdr *)0x0;
    list->last = (co_list_hdr *)0x0;
  }
  return;
}



void ble_co_list_push_back(int *param_1,undefined4 *param_2)

{
  uint32_t uVar1;
  
  uVar1 = (*_rom_patch_hook)((void *)0x0,param_2,_rom_patch_hook);
  if (uVar1 == 0) {
    if (*param_1 == 0) {
      *(undefined4 **)param_1 = param_2;
    }
    else {
      *(undefined4 **)param_1[1] = param_2;
    }
    *(undefined4 **)(param_1 + 1) = param_2;
    *param_2 = 0;
  }
  return;
}



void ble_co_list_push_front(co_list *list,co_list_hdr *list_hdr)

{
  uint32_t uVar1;
  
  uVar1 = (*_rom_patch_hook)((void *)0x0,list,list_hdr,_rom_patch_hook);
  if (uVar1 == 0) {
    if (list->first == (co_list_hdr *)0x0) {
      list->last = list_hdr;
    }
    list_hdr->next = list->first;
    list->first = list_hdr;
  }
  return;
}



co_list_hdr * ble_co_list_pop_front(co_list *list)

{
  uint32_t uVar1;
  co_list_hdr *pcVar2;
  co_list_hdr *pcStack20;
  co_list_hdr *element;
  
  uVar1 = (*_rom_patch_hook)(&pcStack20,list,_rom_patch_hook);
  if (((uVar1 == 0) && (pcStack20 = list->first, pcStack20 != (co_list_hdr *)0x0)) &&
     (pcVar2 = pcStack20->next, list->first = pcVar2, pcVar2 == (co_list_hdr *)0x0)) {
    list->last = (co_list_hdr *)0x0;
  }
  return pcStack20;
}



// WARNING: Variable defined which should be unmapped: found
// WARNING: Type propagation algorithm not settling

_Bool ble_co_list_extract(co_list *list,co_list_hdr *list_hdr,uint8_t nb_following)

{
  int iVar1;
  uint32_t uVar2;
  undefined3 in_register_00002031;
  co_list_hdr cVar3;
  co_list_hdr cVar4;
  co_list_hdr cVar5;
  char acStack17 [4];
  _Bool found;
  
  iVar1 = CONCAT31(in_register_00002031,nb_following);
  acStack17[0] = '\0';
  uVar2 = (*_rom_patch_hook)(acStack17,list,list_hdr,iVar1,_rom_patch_hook);
  if (uVar2 == 0) {
    cVar4 = (co_list_hdr)0x0;
    cVar5 = (co_list_hdr)list->first;
    while (cVar5 != (co_list_hdr)0x0) {
      if (cVar5 == (co_list_hdr)list_hdr) {
        acStack17[0] = '\x01';
        goto LAB_2300c2d8;
      }
      cVar4 = cVar5;
      cVar5 = *(co_list_hdr *)cVar5;
    }
    if (acStack17[0] != '\0') {
LAB_2300c2d8:
      while (cVar3 = *(co_list_hdr *)cVar5, iVar1 != 0) {
        iVar1 = iVar1 + -1;
        cVar5 = cVar3;
      }
      if (cVar4 == (co_list_hdr)0x0) {
        *(co_list_hdr *)&list->first = cVar3;
      }
      else {
        *(co_list_hdr *)cVar4 = cVar3;
      }
      if ((co_list_hdr)((co_list_hdr *)&list->last)->next == cVar5) {
        *(co_list_hdr *)&((co_list_hdr *)&list->last)->next = cVar4;
      }
    }
  }
  return (_Bool)acStack17[0];
}



void ble_co_list_extract_after(co_list *list,co_list_hdr *elt_ref_hdr,co_list_hdr *elt_to_rem_hdr)

{
  uint32_t uVar1;
  
  uVar1 = (*_rom_patch_hook)((void *)0x0,list,elt_ref_hdr,elt_to_rem_hdr,_rom_patch_hook);
  if (uVar1 == 0) {
    if (elt_ref_hdr == (co_list_hdr *)0x0) {
      list->first = list->first->next;
    }
    else {
      elt_ref_hdr->next = elt_to_rem_hdr->next;
    }
    if (list->last == elt_to_rem_hdr) {
      list->last = elt_ref_hdr;
    }
  }
  return;
}



// WARNING: Type propagation algorithm not settling

_Bool ble_co_list_find(co_list *list,co_list_hdr *list_hdr)

{
  uint32_t uVar1;
  co_list_hdr cVar2;
  bool abStack17 [4];
  _Bool ret;
  
  uVar1 = (*_rom_patch_hook)(abStack17,list,list_hdr,_rom_patch_hook);
  if (uVar1 == 0) {
    cVar2 = (co_list_hdr)list->first;
    while ((cVar2 != (co_list_hdr)list_hdr && (cVar2 != (co_list_hdr)0x0))) {
      cVar2 = *(co_list_hdr *)cVar2;
    }
    abStack17[0] = (co_list_hdr)list_hdr == cVar2;
  }
  return (_Bool)abStack17[0];
}



void ble_co_list_merge(int *param_1,int *param_2)

{
  uint32_t uVar1;
  
  uVar1 = (*_rom_patch_hook)((void *)0x0,param_2,_rom_patch_hook);
  if (uVar1 == 0) {
    if (*param_1 == 0) {
      *param_1 = *param_2;
    }
    else {
      *(int *)param_1[1] = *param_2;
    }
    param_1[1] = param_2[1];
    *param_2 = 0;
  }
  return;
}



// WARNING: Type propagation algorithm not settling

void ble_co_list_insert_after(co_list *list,co_list_hdr *elt_ref_hdr,co_list_hdr *elt_to_add_hdr)

{
  uint32_t uVar1;
  co_list_hdr cVar2;
  
  uVar1 = (*_rom_patch_hook)((void *)0x0,list,elt_ref_hdr,elt_to_add_hdr,_rom_patch_hook);
  if (uVar1 == 0) {
    if (elt_ref_hdr == (co_list_hdr *)0x0) {
LAB_2300c3ea:
      ble_co_list_push_back(list,elt_to_add_hdr);
      return;
    }
    cVar2 = (co_list_hdr)list->first;
    while (cVar2 != (co_list_hdr)elt_ref_hdr) {
      if (cVar2 == (co_list_hdr)0x0) goto LAB_2300c3ea;
      cVar2 = *(co_list_hdr *)cVar2;
    }
    if (elt_ref_hdr->next == (co_list_hdr *)0x0) {
      list->last = elt_to_add_hdr;
    }
    elt_to_add_hdr->next = elt_ref_hdr->next;
    elt_ref_hdr->next = elt_to_add_hdr;
  }
  return;
}



// WARNING: Type propagation algorithm not settling

uint16_t ble_co_list_size(co_list *list)

{
  uint32_t uVar1;
  int *piVar2;
  uint16_t auStack18 [2];
  uint16_t count;
  
  auStack18[0] = 0;
  uVar1 = (*_rom_patch_hook)(auStack18,list,_rom_patch_hook);
  if (uVar1 == 0) {
    piVar2 = (int *)list->first;
    while (piVar2 != (int *)0x0) {
      auStack18[0] = auStack18[0] + 1;
      piVar2 = (int *)*piVar2;
    }
  }
  return auStack18[0];
}



void co_bdaddr_set(uint8_t *bdaddr)

{
                    // WARNING: Could not recover jumptable at 0x2300c474. Too many branches
                    // WARNING: Treating indirect jump as call
  (*ble_memcpy_ptr)(&co_default_bdaddr,bdaddr,6);
  return;
}



_Bool co_bdaddr_compare(bd_addr *bd_address1,bd_addr *bd_address2)

{
  int iVar1;
  
  iVar1 = 0;
  do {
    if (bd_address1->addr[iVar1] != bd_address2->addr[iVar1]) {
      return false;
    }
    iVar1 = iVar1 + 1;
  } while (iVar1 != 6);
  return true;
}



void Mont2GF(uint8_t reg_idx)

{
  sec_eng_pka0_pld(8,Inv_r,'\r','\x03','9',false);
  sec_eng_pka0_clir('\x01','\x03','\x06','\0');
  sec_eng_pka0_clir('\x01','\x03','\a','\0');
  sec_eng_pka0_lmul('\0','\x04','\x03','\x03',reg_idx,'\x03','\r');
  sec_eng_pka0_mrem('\0','\x03',reg_idx,'\x04','\x03','\x03','\0');
  sec_eng_pka0_clir('\x01','\x04','\x03','\0');
  return;
}



void getFinalPoint(uint8_t reg_idx)

{
  sec_eng_pka0_clir('\x01','\x03','\x06','\0');
  sec_eng_pka0_clir('\x01','\x03','\a','\0');
  sec_eng_pka0_lmul('\0','\x04','\x03','\x03',reg_idx,'\x03','\x0e');
  sec_eng_pka0_mrem('\0','\x03',reg_idx,'\x04','\x03','\x03','\0');
  sec_eng_pka0_clir('\x01','\x04','\x03','\0');
  return;
}



void pka_point_addition(uint8_t x1_idx,uint8_t x2_idx,uint8_t ret_idx)

{
  uint8_t s0_reg_idx;
  uint8_t s1_reg_idx;
  uint8_t s1_reg_idx_00;
  
  s1_reg_idx = x1_idx + '\x02';
  s0_reg_idx = x1_idx + '\x01';
  sec_eng_pka0_mmul('\0','\x03','\r','\x03',x2_idx + '\x01','\x03',s1_reg_idx,'\x03',DAT_00000010);
  s1_reg_idx_00 = x2_idx + '\x02';
  sec_eng_pka0_mmul('\0','\x03','\x0e','\x03',s0_reg_idx,'\x03',s1_reg_idx_00,'\x03',DAT_00000010);
  sec_eng_pka0_mmul('\0','\x03','\x0f','\x03',x2_idx,'\x03',s1_reg_idx,'\x03',DAT_00000010);
  sec_eng_pka0_mmul('\0','\x03','\x10','\x03',x1_idx,'\x03',s1_reg_idx_00,'\x03',DAT_00000010);
  sec_eng_pka0_msub('\0','\x03','\r','\x03','\r','\x03','\x0e','\x03',DAT_00000010);
  sec_eng_pka0_msub('\0','\x03','\x0f','\x03','\x0f','\x03','\x10','\x03',DAT_00000010);
  sec_eng_pka0_mmul('\0','\x03',x1_idx,'\x03',s1_reg_idx,'\x03',s1_reg_idx_00,'\x03',DAT_00000010);
  sec_eng_pka0_mmul('\0','\x03',s0_reg_idx,'\x03','\x0f','\x03','\x0f','\x03',DAT_00000010);
  sec_eng_pka0_mmul('\0','\x03',s1_reg_idx,'\x03',s0_reg_idx,'\x03','\x0f','\x03',DAT_00000010);
  sec_eng_pka0_mmul('\0','\x03','\x11','\x03','\r','\x03','\r','\x03',DAT_00000010);
  sec_eng_pka0_mmul('\0','\x03','\x11','\x03','\x11','\x03',x1_idx,'\x03',DAT_00000010);
  sec_eng_pka0_msub('\0','\x03','\x11','\x03','\x11','\x03',s1_reg_idx,'\x03',DAT_00000010);
  sec_eng_pka0_mmul('\0','\x03','\x12','\x03','\t','\x03',s0_reg_idx,'\x03',DAT_00000010);
  sec_eng_pka0_mmul('\0','\x03','\x12','\x03','\x12','\x03','\x10','\x03',DAT_00000010);
  sec_eng_pka0_msub('\0','\x03','\x12','\x03','\x11','\x03','\x12','\x03',DAT_00000010);
  sec_eng_pka0_mmul('\0','\x03',s0_reg_idx,'\x03',s0_reg_idx,'\x03','\x10','\x03',DAT_00000010);
  sec_eng_pka0_mmul('\0','\x03','\x0e','\x03',s1_reg_idx,'\x03','\x0e','\x03',DAT_00000010);
  sec_eng_pka0_mmul('\0','\x03',ret_idx + '\x02','\x03',s1_reg_idx,'\x03',x1_idx,'\x03',DAT_00000010
                   );
  sec_eng_pka0_mmul('\0','\x03',ret_idx,'\x03','\x0f','\x03','\x12','\x03',DAT_00000010);
  sec_eng_pka0_msub('\0','\x03',s0_reg_idx,'\x03',s0_reg_idx,'\x03','\x12','\x03',DAT_00000010);
  sec_eng_pka0_mmul('\0','\x03',s0_reg_idx,'\x03','\r','\x03',s0_reg_idx,'\x03',DAT_00000010);
  sec_eng_pka0_msub('\x01','\x03',ret_idx + '\x01','\x03',s0_reg_idx,'\x03','\x0e','\x03',
                    DAT_00000010);
  sec_eng_pka0_wait_4_isr();
  sec_eng_pka0_clear_int();
  return;
}



void pka_read_result(ECC_Jacobian_Point256 *point,uint8_t idx)

{
  sec_eng_pka0_read_data('\x03',idx,(uint32_t *)point,'\b');
  sec_eng_pka0_read_data('\x03',idx + '\x01',(uint32_t *)&point->y,'\b');
  sec_eng_pka0_read_data('\x03',idx + '\x02',(uint32_t *)&point->z,'\b');
  return;
}



void pka_cp_x2_to_x1(uint8_t x1_idx,uint8_t x2_idx)

{
  sec_eng_pka0_movdat('\0','\x03',x1_idx,'\x03',x2_idx);
  sec_eng_pka0_movdat('\0','\x03',x1_idx + '\x01','\x03',x2_idx + '\x01');
  sec_eng_pka0_movdat('\0','\x03',x1_idx + '\x02','\x03',x2_idx + '\x02');
  return;
}



void pka_point_inf_check(uint8_t x1_idx,uint8_t *p1_eq_inf)

{
  byte bVar1;
  byte bVar2;
  uint uVar3;
  byte abStack33 [4];
  uint8_t bitval;
  
  sec_eng_pka0_lcmp(abStack33,'\x03',x1_idx,'\x03','\b');
  bVar1 = abStack33[0];
  sec_eng_pka0_lcmp(abStack33,'\x03',x1_idx + '\x01','\x03','\x13');
  uVar3 = (uint)abStack33[0];
  sec_eng_pka0_lcmp(abStack33,'\x03','\x14','\x03',x1_idx + '\x01');
  bVar2 = abStack33[0];
  sec_eng_pka0_lcmp(abStack33,'\x03',x1_idx + '\x02','\x03','\b');
  *(bool *)p1_eq_inf =
       (byte)(bVar2 << 2 | (byte)((uVar3 << 0x19) >> 0x18) | bVar1 | abStack33[0] << 3) == 0xf;
  return;
}



void GF2Mont(u_int32 *numA,u_int32 *result)

{
  sec_eng_pka0_pld(8,(uint32_t *)&bigHexP256,'\0','\x03','9',false);
  sec_eng_pka0_pld(8,numA,'\x01','\x03','9',false);
  sec_eng_pka0_lmul2n('\0','\x04','\x01','\x03','\x01',0x100);
  sec_eng_pka0_mrem('\0','\x03','\x04','\x04','\x01','\x03','\0');
  sec_eng_pka0_read_data('\x03','\x04',result,'\b');
  sec_eng_pka0_clir('\x01','\x04','\x01','\0');
  return;
}



// WARNING: Variable defined which should be unmapped: pka_p1_eq_inf

void pka_point_double(uint8_t x_idx)

{
  uint8_t s0_reg_idx;
  uint8_t s0_reg_idx_00;
  uint8_t auStack17 [4];
  uint8_t pka_p1_eq_inf;
  
  pka_point_inf_check(x_idx,auStack17);
  if (auStack17[0] == '\0') {
    s0_reg_idx = x_idx + '\x02';
    sec_eng_pka0_mmul('\0','\x03','\r','\x03',x_idx,'\x03',x_idx,'\x03',DAT_00000010);
    sec_eng_pka0_mmul('\0','\x03','\x0e','\x03',s0_reg_idx,'\x03',s0_reg_idx,'\x03',DAT_00000010);
    sec_eng_pka0_msub('\0','\x03','\r','\x03','\r','\x03','\x0e','\x03',DAT_00000010);
    s0_reg_idx_00 = x_idx + '\x01';
    sec_eng_pka0_mmul('\0','\x03','\r','\x03','\n','\x03','\r','\x03',DAT_00000010);
    sec_eng_pka0_mmul('\0','\x03','\x0e','\x03',s0_reg_idx_00,'\x03',s0_reg_idx,'\x03',DAT_00000010)
    ;
    sec_eng_pka0_mmul('\0','\x03','\x0f','\x03',x_idx,'\x03',s0_reg_idx_00,'\x03',DAT_00000010);
    sec_eng_pka0_mmul('\0','\x03',s0_reg_idx,'\x03','\r','\x03','\r','\x03',DAT_00000010);
    sec_eng_pka0_mmul('\0','\x03','\x0f','\x03','\x0f','\x03','\x0e','\x03',DAT_00000010);
    sec_eng_pka0_mmul('\0','\x03',x_idx,'\x03','\f','\x03','\x0f','\x03',DAT_00000010);
    sec_eng_pka0_msub('\0','\x03',s0_reg_idx,'\x03',s0_reg_idx,'\x03',x_idx,'\x03',DAT_00000010);
    sec_eng_pka0_mmul('\0','\x03',x_idx,'\x03','\t','\x03',s0_reg_idx,'\x03',DAT_00000010);
    sec_eng_pka0_mmul('\0','\x03',x_idx,'\x03',x_idx,'\x03','\x0e','\x03',DAT_00000010);
    sec_eng_pka0_mmul('\0','\x03','\x0f','\x03','\v','\x03','\x0f','\x03',DAT_00000010);
    sec_eng_pka0_mmul('\0','\x03','\x10','\x03','\x0e','\x03','\x0e','\x03',DAT_00000010);
    sec_eng_pka0_msub('\0','\x03','\x0f','\x03','\x0f','\x03',s0_reg_idx,'\x03',DAT_00000010);
    sec_eng_pka0_mmul('\0','\x03',s0_reg_idx_00,'\x03',s0_reg_idx_00,'\x03',s0_reg_idx_00,'\x03',
                      DAT_00000010);
    sec_eng_pka0_mmul('\0','\x03','\x0f','\x03','\x0f','\x03','\r','\x03',DAT_00000010);
    sec_eng_pka0_mmul('\0','\x03',s0_reg_idx_00,'\x03','\f','\x03',s0_reg_idx_00,'\x03',DAT_00000010
                     );
    sec_eng_pka0_mmul('\0','\x03',s0_reg_idx_00,'\x03',s0_reg_idx_00,'\x03','\x10','\x03',
                      DAT_00000010);
    sec_eng_pka0_msub('\0','\x03',s0_reg_idx_00,'\x03','\x0f','\x03',s0_reg_idx_00,'\x03',
                      DAT_00000010);
    sec_eng_pka0_mmul('\0','\x03',s0_reg_idx,'\x03','\x0e','\x03','\x10','\x03',DAT_00000010);
    sec_eng_pka0_mmul('\x01','\x03',s0_reg_idx,'\x03','\f','\x03',s0_reg_idx,'\x03',DAT_00000010);
    sec_eng_pka0_wait_4_isr();
    sec_eng_pka0_clear_int();
  }
  return;
}



// WARNING: Variable defined which should be unmapped: pka_p1_eq_inf

void pka_addition_win(ECC_Jacobian_Point256 *src1,ECC_Jacobian_Point256 *src2,
                     ECC_Jacobian_Point256 *ret)

{
  uint8_t x2_idx;
  byte bStack18;
  byte abStack17 [3];
  uint8_t pka_p1_eq_inf;
  uint8_t pka_p2_eq_inf;
  
  sec_eng_pka0_pld(8,(uint32_t *)src1,'\x15','\x03','9',false);
  sec_eng_pka0_pld(8,(uint32_t *)&src1->y,'\x16','\x03','9',false);
  sec_eng_pka0_pld(8,(uint32_t *)&src1->z,'\x17','\x03','9',false);
  sec_eng_pka0_pld(8,(uint32_t *)src2,'\x18','\x03','9',false);
  sec_eng_pka0_pld(8,(uint32_t *)&src2->y,'\x19','\x03','9',false);
  sec_eng_pka0_pld(8,(uint32_t *)&src2->z,'\x1a','\x03','9',false);
  pka_point_inf_check('\x15',&bStack18);
  pka_point_inf_check('\x18',abStack17);
  if (bStack18 == 1) {
    x2_idx = '\x18';
    if (abStack17[0] != 0) goto LAB_2300cc28;
  }
  else {
    if ((bStack18 | abStack17[0]) == 0) {
      pka_point_addition('\x15','\x18','\x1b');
      goto LAB_2300cc44;
    }
LAB_2300cc28:
    x2_idx = '\x02';
  }
  pka_cp_x2_to_x1('\x1b',x2_idx);
LAB_2300cc44:
  pka_read_result(ret,'\x1b');
  return;
}



void ecc_multiplication_event_handler(uint8_t param_1)

{
  bool bVar1;
  byte bVar2;
  ke_task_id_t dest_id;
  co_list_hdr *mem_ptr;
  co_list_hdr *pcVar3;
  undefined *puVar4;
  ECC_Jacobian_Point256 *src1;
  uint uVar5;
  co_list_hdr *pcVar6;
  undefined *puVar7;
  undefined *puVar8;
  int iVar9;
  undefined4 *puVar10;
  byte bStack113;
  byte bStack112;
  undefined2 uStack110;
  undefined4 uStack84;
  undefined4 uStack80;
  undefined4 uStack76;
  undefined4 uStack72;
  undefined4 uStack40;
  undefined4 uStack36;
  
  ble_ke_event_clear('\0');
  mem_ptr = ble_co_list_pop_front((co_list *)&ecc_env);
  if (mem_ptr == (co_list_hdr *)0x0) goto LAB_2300cdce;
  if (mem_ptr[1].next == (co_list_hdr *)0x0) {
    dest_id = *(ke_task_id_t *)((int)&mem_ptr[0x48].next + 2);
    if (dest_id != 0xff) {
      puVar4 = (undefined *)ble_ke_msg_alloc(*(ke_msg_id_t *)&mem_ptr[0x48].next,dest_id,0xff,0x40);
      Mont2GF('\x02');
      Mont2GF('\x03');
      (*ble_memset_ptr)(&bStack112,0,0x20);
      uStack84 = 2;
      sec_eng_pka0_pld(8,&bStack112,'\r','\x03','9',false);
      sec_eng_pka0_lsub('\0','\x03','\r','\x03','\0','\x03','\r');
      sec_eng_pka0_mexp('\x01','\x03','\x0e','\x03','\x04','\x03','\r','\x03',DAT_00000010);
      sec_eng_pka0_wait_4_isr();
      sec_eng_pka0_clear_int();
      Mont2GF('\x0e');
      getFinalPoint('\x02');
      getFinalPoint('\x03');
      (*ble_memset_ptr)(&bStack112,0,0x20);
      uStack80 = 0;
      uStack76 = 0;
      (*ble_memset_ptr)(&uStack72,0,0x20);
      uStack40 = 0;
      uStack36 = 0;
      sec_eng_pka0_read_data('\x03','\x02',&bStack112,'\b');
      sec_eng_pka0_read_data('\x03','\x03',&uStack72,'\b');
      if (*(char *)&mem_ptr[0x4b].next == '\x02') {
        ble_ke_free(mem_ptr[0x4c].next);
        mem_ptr[0x4c].next = (co_list_hdr *)0x0;
      }
      ble_ke_free(mem_ptr);
      puVar7 = puVar4 + 0x1c;
      puVar10 = &bStack112;
      do {
        puVar7[3] = *(undefined *)((int)puVar10 + 3);
        puVar7[2] = (char)*(undefined2 *)((int)puVar10 + 2);
        puVar7[1] = (char)((uint)*puVar10 >> 8);
        *puVar7 = (char)*puVar10;
        bVar1 = puVar4 != puVar7;
        puVar7 = puVar7 + -4;
        puVar10 = puVar10 + 1;
      } while (bVar1);
      puVar7 = puVar4 + 0x3c;
      puVar10 = &uStack72;
      do {
        puVar8 = puVar7 + -4;
        puVar7[3] = *(undefined *)((int)puVar10 + 3);
        puVar7[2] = (char)*(undefined2 *)((int)puVar10 + 2);
        puVar7[1] = (char)((uint)*puVar10 >> 8);
        *puVar7 = (char)*puVar10;
        puVar7 = puVar8;
        puVar10 = puVar10 + 1;
      } while (puVar8 != puVar4 + 0x1c);
      ble_ke_msg_send(puVar4);
    }
    goto LAB_2300cdce;
  }
  bVar2 = *(byte *)&mem_ptr[0x4b].next;
  pcVar6 = mem_ptr[0x4a].next;
  if (((int)&((co_list_hdr *)(uint)bVar2)[-1].next + 3U & 0xff) < 2) {
    if (bVar2 == 1) {
      src1 = ECC_4Win_Look_up_table;
    }
    else {
      src1 = (ECC_Jacobian_Point256 *)mem_ptr[0x4c].next;
    }
    uVar5 = (uint)pcVar6 & 0x1f;
    iVar9 = ((((uint)mem_ptr[(0x3fU - (int)pcVar6 >> 5) + 0x3e].next >> uVar5 & 1) * 2 +
             ((uint)mem_ptr[(0x7fU - (int)pcVar6 >> 5) + 0x3e].next >> uVar5 & 1)) * 2 +
            ((uint)mem_ptr[(0xbfU - (int)pcVar6 >> 5) + 0x3e].next >> uVar5 & 1)) * 2 +
            ((uint)mem_ptr[(0xffU - (int)pcVar6 >> 5) + 0x3e].next >> uVar5 & 1);
    if (iVar9 != 0) {
      src1 = src1 + iVar9 + -1;
      sec_eng_pka0_pld(8,(uint32_t *)src1,'\x15','\x03','9',false);
      sec_eng_pka0_pld(8,(uint32_t *)&src1->y,'\x16','\x03','9',false);
      sec_eng_pka0_pld(8,(uint32_t *)&src1->z,'\x17','\x03','9',false);
      pka_point_inf_check('\x02',&bStack113);
      pka_point_inf_check('\x15',(uint8_t *)&bStack112);
      if (bStack113 == 1) {
        if (bStack112 == 0) {
          pka_cp_x2_to_x1('\x02','\x15');
        }
      }
      else {
        if ((bStack113 | bStack112) == 0) {
          pka_point_addition('\x02','\x15','\x02');
        }
      }
    }
    if (mem_ptr[0x4a].next == (co_list_hdr *)0x0) {
      mem_ptr[1].next = (co_list_hdr *)0x0;
    }
    else {
      pka_point_double('\x02');
      pcVar6 = (co_list_hdr *)((int)&mem_ptr[0x4a].next[-1].next + 3);
LAB_2300cd9c:
      mem_ptr[0x4a].next = pcVar6;
    }
  }
  else {
    if (bVar2 == 3) {
      pka_point_double('\x05');
      pcVar6 = (co_list_hdr *)((int)&(mem_ptr[0x4a].next)->next + 1);
      mem_ptr[0x4a].next = pcVar6;
      if (pcVar6 == (co_list_hdr *)0x40) {
        src1 = (ECC_Jacobian_Point256 *)(mem_ptr[0x4c].next + 0x1e);
      }
      else {
        if (pcVar6 != (co_list_hdr *)0x80) {
          if (pcVar6 == (co_list_hdr *)0xc0) {
            pka_read_result((ECC_Jacobian_Point256 *)(mem_ptr[0x4c].next + 0xd2),'\x05');
            *(undefined *)&mem_ptr[0x4b].next = 4;
            mem_ptr[0x4a].next = (co_list_hdr *)(uint)bVar2;
          }
          goto LAB_2300cdc4;
        }
        src1 = (ECC_Jacobian_Point256 *)(mem_ptr[0x4c].next + 0x5a);
      }
      pka_read_result(src1,'\x05');
    }
    else {
      if (bVar2 == 4) {
        if (pcVar6 == (co_list_hdr *)0x3) {
          src1 = (ECC_Jacobian_Point256 *)mem_ptr[0x4c].next;
          pka_addition_win(src1,src1 + 1,src1 + 2);
          pcVar6 = (co_list_hdr *)0x5;
        }
        else {
          if (pcVar6 == (co_list_hdr *)0x5) {
            src1 = (ECC_Jacobian_Point256 *)mem_ptr[0x4c].next;
            pka_addition_win(src1,src1 + 3,src1 + 4);
            pcVar6 = (co_list_hdr *)0x6;
          }
          else {
            if (pcVar6 == (co_list_hdr *)0x6) {
              pcVar6 = mem_ptr[0x4c].next;
              pka_addition_win((ECC_Jacobian_Point256 *)(pcVar6 + 0x1e),
                               (ECC_Jacobian_Point256 *)(pcVar6 + 0x5a),
                               (ECC_Jacobian_Point256 *)(pcVar6 + 0x96));
              pcVar6 = (co_list_hdr *)0x7;
            }
            else {
              if (pcVar6 == (co_list_hdr *)0x7) {
                src1 = (ECC_Jacobian_Point256 *)mem_ptr[0x4c].next;
                pka_addition_win(src1,src1 + 5,src1 + 6);
                pcVar6 = (co_list_hdr *)0x9;
              }
              else {
                if (6 < (int)&pcVar6[-3].next + 3U) goto LAB_2300cdc4;
                pcVar3 = mem_ptr[0x4c].next;
                pka_addition_win((ECC_Jacobian_Point256 *)(pcVar3 + 0xd2),
                                 (ECC_Jacobian_Point256 *)(pcVar3 + (int)pcVar6 * 0x1e + -0x10e),
                                 (ECC_Jacobian_Point256 *)(pcVar3 + (int)pcVar6 * 0x1e + -0x1e));
                if (mem_ptr[0x4a].next == (co_list_hdr *)0xf) {
                  *(undefined *)&mem_ptr[0x4b].next = 2;
                  pcVar6 = (co_list_hdr *)0x3f;
                }
                else {
                  pcVar6 = (co_list_hdr *)((int)&(mem_ptr[0x4a].next)->next + 1);
                }
              }
            }
          }
        }
        goto LAB_2300cd9c;
      }
    }
  }
LAB_2300cdc4:
  ble_co_list_push_back(&ecc_env,mem_ptr);
LAB_2300cdce:
  if (ecc_env.ongoing_mul.first != (co_list_hdr *)0x0) {
    ble_ke_event_set('\0');
  }
  return;
}



void ecc_init(int param_1)

{
  co_list_hdr *mem_ptr;
  
  if (param_1 != 0) {
    while (ecc_env.ongoing_mul.first != (co_list_hdr *)0x0) {
      mem_ptr = ble_co_list_pop_front((co_list *)&ecc_env);
      ble_ke_free(mem_ptr);
    }
  }
  ble_co_list_init((co_list *)&ecc_env);
  ble_ke_event_callback_set('\0',ecc_multiplication_event_handler);
  return;
}



// WARNING: Variable defined which should be unmapped: PointP_Jacobian

uint8_t ecc_generate_key256(u_int8 key_type,u_int8 *secret_key,u_int8 *public_key_x,
                           u_int8 *public_key_y,ke_msg_id_t msg_id,ke_task_id_t task_id)

{
  bool bVar1;
  u_int32 *numA;
  void *pvVar2;
  ECC_Jacobian_Point256 *point;
  byte *pbVar3;
  byte *pbVar4;
  byte *pbVar5;
  int iVar6;
  u_int32 *numA_00;
  int *piVar7;
  int local_148;
  bigHex256 PrivateKey256;
  bigHex256 BigHex_1;
  ECC_Point256 PublicKey256;
  ECC_Jacobian_Point256 PointP_Jacobian;
  
  sec_eng_pka0_reset();
  numA_00 = &BigHex_1.sign;
  local_148 = 0;
  BigHex_1.sign = 0;
  PublicKey256.x.sign = 0;
  numA = numA_00;
  pbVar3 = public_key_x + 0x1c;
  pbVar4 = public_key_y + 0x1c;
  pbVar5 = secret_key + 0x1c;
  piVar7 = &local_148;
  do {
    *piVar7 = (uint)pbVar5[3] * 0x1000000 + (uint)pbVar5[2] * 0x10000 + (uint)*pbVar5 +
              (uint)pbVar5[1] * 0x100;
    *numA = (uint)pbVar3[3] * 0x1000000 + (uint)pbVar3[2] * 0x10000 + (uint)*pbVar3 +
            (uint)pbVar3[1] * 0x100;
    numA[10] = (uint)pbVar4[3] * 0x1000000 + (uint)pbVar4[2] * 0x10000 + (uint)*pbVar4 +
               (uint)pbVar4[1] * 0x100;
    bVar1 = secret_key != pbVar5;
    numA = numA + 1;
    pbVar3 = pbVar3 + -4;
    pbVar4 = pbVar4 + -4;
    pbVar5 = pbVar5 + -4;
    piVar7 = piVar7 + 1;
  } while (bVar1);
  iVar6 = 0;
  piVar7 = &local_148;
  do {
    if (*piVar7 != 0) break;
    iVar6 = iVar6 + 1;
    piVar7 = piVar7 + 1;
  } while (iVar6 != 8);
  PrivateKey256.num[7] = 8 - iVar6;
  iVar6 = 0;
  numA = numA_00;
  do {
    if (*numA != 0) break;
    iVar6 = iVar6 + 1;
    numA = numA + 1;
  } while (iVar6 != 8);
  PublicKey256.x.num[7] = 8 - iVar6;
  iVar6 = 0;
  numA = numA_00;
  do {
    if (numA[10] != 0) break;
    iVar6 = iVar6 + 1;
    numA = numA + 1;
  } while (iVar6 != 8);
  PublicKey256.y.num[7] = 8 - iVar6;
  PublicKey256.x.len = 0;
  PublicKey256.y.len = 0;
  pvVar2 = ble_ke_malloc(0x134,'\0');
  *(u_int8 *)((int)pvVar2 + 300) = key_type;
  *(ke_msg_id_t *)((int)pvVar2 + 0x120) = msg_id;
  *(ke_task_id_t *)((int)pvVar2 + 0x122) = task_id;
  GF2Mont(numA_00,numA_00);
  numA = &PublicKey256.x.sign;
  GF2Mont(numA,numA);
  BigHex_1.num[7] = 1;
  BigHex_1.len = 0;
  (*ble_memset_ptr)(&PrivateKey256.sign,0,0x20);
  (*ble_memcpy_ptr)(&PrivateKey256.sign,Bar_1,0x20);
  (*ble_memcpy_ptr)(&PublicKey256.y.sign,numA_00,0x20);
  PointP_Jacobian.x.num[7] = PublicKey256.x.num[7];
  PointP_Jacobian.x.len = PublicKey256.x.len;
  (*ble_memcpy_ptr)(&PointP_Jacobian.x.sign,&PublicKey256.x.sign,0x20);
  PointP_Jacobian.y.num[7] = PublicKey256.y.num[7];
  PointP_Jacobian.y.len = PublicKey256.y.len;
  (*ble_memcpy_ptr)(&PointP_Jacobian.y.sign,&PrivateKey256.sign,0x20);
  PointP_Jacobian.z.num[7] = BigHex_1.num[7];
  PointP_Jacobian.z.len = BigHex_1.len;
  (*ble_memcpy_ptr)((uint32_t *)((int)pvVar2 + 0x80),&PublicKey256.y.sign,0x20);
  *(u_int32 *)((int)pvVar2 + 0xa0) = PointP_Jacobian.x.num[7];
  *(u_int32 *)((int)pvVar2 + 0xa4) = PointP_Jacobian.x.len;
  (*ble_memcpy_ptr)((uint32_t *)((int)pvVar2 + 0xa8),&PointP_Jacobian.x.sign,0x20);
  *(u_int32 *)((int)pvVar2 + 200) = PointP_Jacobian.y.num[7];
  *(u_int32 *)((int)pvVar2 + 0xcc) = PointP_Jacobian.y.len;
  (*ble_memcpy_ptr)((uint32_t *)((int)pvVar2 + 0xd0),&PointP_Jacobian.y.sign,0x20);
  *(u_int32 *)((int)pvVar2 + 0xf0) = PointP_Jacobian.z.num[7];
  *(u_int32 *)((int)pvVar2 + 0xf4) = PointP_Jacobian.z.len;
  (*ble_memcpy_ptr)((void *)((int)pvVar2 + 0xf8),&local_148,0x20);
  *(u_int32 *)((int)pvVar2 + 0x118) = PrivateKey256.num[7];
  *(u_int32 *)((int)pvVar2 + 0x11c) = PrivateKey256.len;
  BigHex_1.num[7] = 1;
  BigHex_1.len = 0;
  (*ble_memset_ptr)(&PrivateKey256.sign,0,0x20);
  BigHex_1.num[6] = 0;
  (*ble_memcpy_ptr)((uint32_t *)((int)pvVar2 + 8),&PrivateKey256.sign,0x20);
  *(u_int32 *)((int)pvVar2 + 0x28) = BigHex_1.num[7];
  *(u_int32 *)((int)pvVar2 + 0x2c) = BigHex_1.len;
  (*ble_memcpy_ptr)(&PrivateKey256.sign,Bar_1,0x20);
  (*ble_memcpy_ptr)((uint32_t *)((int)pvVar2 + 0x30),&PrivateKey256.sign,0x20);
  *(u_int32 *)((int)pvVar2 + 0x50) = BigHex_1.num[7];
  *(u_int32 *)((int)pvVar2 + 0x54) = BigHex_1.len;
  (*ble_memset_ptr)(&PrivateKey256.sign,0,0x20);
  BigHex_1.num[6] = 0;
  (*ble_memcpy_ptr)((uint32_t *)((int)pvVar2 + 0x58),&PrivateKey256.sign,0x20);
  *(u_int32 *)((int)pvVar2 + 0x78) = BigHex_1.num[7];
  *(u_int32 *)((int)pvVar2 + 0x7c) = BigHex_1.len;
  (*ble_memset_ptr)(&PrivateKey256.sign,0,0x20);
  BigHex_1.num[6] = 1;
  sec_eng_pka0_pld(8,(uint32_t *)&bigHexP256,'\0','\x03','9',false);
  sec_eng_pka0_pld(8,Nprime,'\x01','\x03','9',false);
  sec_eng_pka0_pld(8,(uint32_t *)((int)pvVar2 + 8),'\x02','\x03','9',false);
  sec_eng_pka0_pld(8,(uint32_t *)((int)pvVar2 + 0x30),'\x03','\x03','9',false);
  sec_eng_pka0_pld(8,(uint32_t *)((int)pvVar2 + 0x58),'\x04','\x03','9',false);
  sec_eng_pka0_pld(8,(uint32_t *)((int)pvVar2 + 0x80),'\x05','\x03','9',false);
  sec_eng_pka0_pld(8,(uint32_t *)((int)pvVar2 + 0xa8),'\x06','\x03','9',false);
  sec_eng_pka0_pld(8,(uint32_t *)((int)pvVar2 + 0xd0),'\a','\x03','9',false);
  sec_eng_pka0_pld(8,&PrivateKey256.sign,'\b','\x03','9',false);
  sec_eng_pka0_pld(8,Bar_2,'\t','\x03','9',false);
  sec_eng_pka0_pld(8,Bar_3,'\n','\x03','9',false);
  sec_eng_pka0_pld(8,Bar_4,'\v','\x03','9',false);
  sec_eng_pka0_pld(8,Bar_8,'\f','\x03','9',false);
  sec_eng_pka0_pld(8,Bar_1p1,'\x13','\x03','9',false);
  sec_eng_pka0_pld(8,Bar_1m1,'\x14','\x03','9',false);
  *(undefined4 *)((int)pvVar2 + 0x128) = 0x3f;
  *(undefined4 *)((int)pvVar2 + 0x124) = 0;
  *(undefined4 *)((int)pvVar2 + 4) = 8;
  if (*(char *)((int)pvVar2 + 300) == '\x02') {
    point = (ECC_Jacobian_Point256 *)ble_ke_malloc(0x708,'\0');
    *(ECC_Jacobian_Point256 **)((int)pvVar2 + 0x130) = point;
    pka_read_result(point,'\x05');
    *(undefined *)((int)pvVar2 + 300) = 3;
    *(undefined4 *)((int)pvVar2 + 0x128) = 0;
  }
  ble_co_list_push_back(&ecc_env,pvVar2);
  ble_ke_event_set('\0');
  return '\0';
}



void ecc_gen_new_public_key(u_int8 *secret_key,ke_msg_id_t msg_id,ke_task_id_t task_id)

{
  ecc_generate_key256('\x01',secret_key,BasePoint_x_256,BasePoint_y_256,msg_id,task_id);
  return;
}



void ecc_gen_new_secret_key(uint8_t *secret_key256,_Bool forced)

{
  int iVar1;
  undefined3 in_register_0000202d;
  
  if (CONCAT31(in_register_0000202d,forced) != 0) {
    return;
  }
  do {
    iVar1 = bl_rand();
    *secret_key256 = (uint8_t)iVar1;
    secret_key256[1] = (uint8_t)((uint)iVar1 >> 8);
    secret_key256[2] = (uint8_t)((uint)iVar1 >> 0x10);
    secret_key256[3] = (uint8_t)((uint)iVar1 >> 0x18);
    iVar1 = bl_rand();
    secret_key256[4] = (uint8_t)iVar1;
    secret_key256[5] = (uint8_t)((uint)iVar1 >> 8);
    secret_key256[6] = (uint8_t)((uint)iVar1 >> 0x10);
    secret_key256[7] = (uint8_t)((uint)iVar1 >> 0x18);
    iVar1 = bl_rand();
    secret_key256[8] = (uint8_t)iVar1;
    secret_key256[9] = (uint8_t)((uint)iVar1 >> 8);
    secret_key256[10] = (uint8_t)((uint)iVar1 >> 0x10);
    secret_key256[0xb] = (uint8_t)((uint)iVar1 >> 0x18);
    iVar1 = bl_rand();
    secret_key256[0xc] = (uint8_t)iVar1;
    secret_key256[0xd] = (uint8_t)((uint)iVar1 >> 8);
    secret_key256[0xe] = (uint8_t)((uint)iVar1 >> 0x10);
    secret_key256[0xf] = (uint8_t)((uint)iVar1 >> 0x18);
    iVar1 = bl_rand();
    secret_key256[0x10] = (uint8_t)iVar1;
    secret_key256[0x11] = (uint8_t)((uint)iVar1 >> 8);
    secret_key256[0x12] = (uint8_t)((uint)iVar1 >> 0x10);
    secret_key256[0x13] = (uint8_t)((uint)iVar1 >> 0x18);
    iVar1 = bl_rand();
    secret_key256[0x14] = (uint8_t)iVar1;
    secret_key256[0x15] = (uint8_t)((uint)iVar1 >> 8);
    secret_key256[0x16] = (uint8_t)((uint)iVar1 >> 0x10);
    secret_key256[0x17] = (uint8_t)((uint)iVar1 >> 0x18);
    iVar1 = bl_rand();
    secret_key256[0x18] = (uint8_t)iVar1;
    secret_key256[0x19] = (uint8_t)((uint)iVar1 >> 8);
    secret_key256[0x1a] = (uint8_t)((uint)iVar1 >> 0x10);
    secret_key256[0x1b] = (uint8_t)((uint)iVar1 >> 0x18);
    iVar1 = bl_rand();
    secret_key256[0x1c] = (uint8_t)iVar1;
    secret_key256[0x1d] = (uint8_t)((uint)iVar1 >> 8);
    secret_key256[0x1e] = (uint8_t)((uint)iVar1 >> 0x10);
    secret_key256[0x1f] = (uint8_t)((uint)iVar1 >> 0x18);
    iVar1 = 0x1f;
    do {
      if (secret_key256[iVar1] != '\0') goto LAB_2300d670;
      iVar1 = iVar1 + -1;
    } while (iVar1 != -1);
    if (*secret_key256 != '\0') {
LAB_2300d670:
      iVar1 = 0x1f;
      while( true ) {
        if (maxSecretKey_256[iVar1] < secret_key256[iVar1]) break;
        if ((secret_key256[iVar1] < maxSecretKey_256[iVar1]) || (iVar1 = iVar1 + -1, iVar1 == -1)) {
          return;
        }
      }
    }
  } while( true );
}



void ble_ke_event_init(void)

{
  uint32_t uVar1;
  
  uVar1 = (*_rom_patch_hook)((void *)0x0,_rom_patch_hook);
  if (uVar1 == 0) {
                    // WARNING: Could not recover jumptable at 0x2300d6ca. Too many branches
                    // WARNING: Treating indirect jump as call
    (*ble_memset_ptr)(&ble_ke_event_env,0,0x30);
    return;
  }
  return;
}



uint8_t ble_ke_event_callback_set(uint8_t event_type,intCallback_Type *p_callback)

{
  undefined3 in_register_00002029;
  uint uVar1;
  uint32_t uVar2;
  uint8_t auStack17 [4];
  uint8_t status;
  
  uVar1 = CONCAT31(in_register_00002029,event_type);
  uVar2 = (*_rom_patch_hook)(auStack17,uVar1,p_callback,_rom_patch_hook);
  if ((uVar2 == 0) && (auStack17[0] = '\x03', uVar1 < 10)) {
    *(intCallback_Type **)(ble_ke_event_env.callback + uVar1) = p_callback;
    auStack17[0] = '\0';
  }
  return auStack17[0];
}


/*
Unable to decompile 'ble_ke_event_set'
Cause: 
Low-level Error: Assignment to constant at r0x2300d75a
*/

/*
Unable to decompile 'ble_ke_event_clear'
Cause: Exception while decompiling 2300d77c: Decompiler process died

*/


void ble_ke_event_flush(void)

{
  uint32_t uVar1;
  
  uVar1 = (*_rom_patch_hook)((void *)0x0,_rom_patch_hook);
  if (uVar1 == 0) {
    ble_ke_event_env.event_field = 0;
  }
  return;
}



void ble_ke_event_schedule(void)

{
  uint32_t uVar1;
  uint uVar2;
  
  uVar1 = (*_rom_patch_hook)((void *)0x0,_rom_patch_hook);
  if (uVar1 == 0) {
    while (ble_ke_event_env.event_field != 0) {
      ble_ke_event_env.state = '\x01';
      uVar2 = 0;
      do {
        if ((0x80000000U >> (uVar2 & 0x1f) & ble_ke_event_env.event_field) != 0) break;
        uVar2 = uVar2 + 1;
      } while (uVar2 != 0x20);
      if (ble_ke_event_env.callback[0x1f - uVar2 & 0xff] != (p_callback_t)0x0) {
        (*ble_ke_event_env.callback[0x1f - uVar2 & 0xff])();
      }
    }
    ble_ke_event_env.state = '\0';
  }
  return;
}



_Bool ble_ke_mem_is_in_heap(uint8_t type,void *mem_ptr)

{
  undefined3 in_register_00002029;
  int iVar1;
  uint32_t uVar2;
  co_list_hdr *pcVar3;
  undefined auStack17 [4];
  _Bool ret;
  
  iVar1 = CONCAT31(in_register_00002029,type);
  uVar2 = (*_rom_patch_hook)(auStack17,iVar1,mem_ptr,_rom_patch_hook);
  if (uVar2 == 0) {
    pcVar3 = (&ble_ke_env.queue_saved.first)[iVar1 + 4];
    auStack17[0] = 0;
    if ((pcVar3 <= mem_ptr) &&
       (mem_ptr <=
        (void *)((int)&pcVar3->next +
                (uint)*(ushort *)((int)&ble_ke_env.queue_sent.first + (iVar1 + 0x10) * 2)))) {
      auStack17[0] = 1;
    }
  }
  return (_Bool)auStack17[0];
}


/*
Unable to decompile 'ble_ke_mem_init'
Cause: Exception while decompiling 2300d8c2: Decompiler process died

*/

/*
Unable to decompile 'ble_ke_malloc'
Cause: Exception while decompiling 2300d942: Decompiler process died

*/

/*
Unable to decompile 'ble_ke_free'
Cause: Exception while decompiling 2300da32: Decompiler process died

*/


_Bool ble_ke_is_free(void *mem_ptr)

{
  uint32_t uVar1;
  bool abStack17 [4];
  _Bool ret;
  
  uVar1 = (*_rom_patch_hook)(abStack17,mem_ptr,_rom_patch_hook);
  if (uVar1 == 0) {
    abStack17[0] = *(short *)((int)mem_ptr + -4) != -0x7cc8;
  }
  return (_Bool)abStack17[0];
}



void * ble_ke_msg_alloc(ke_msg_id_t id,ke_task_id_t dest_id,ke_task_id_t src_id,uint16_t param_len)

{
  anon_subr_void_ptr_void_ptr_int_uint *paVar1;
  undefined2 in_register_0000202a;
  uint32_t uVar2;
  undefined2 in_register_0000202e;
  undefined2 in_register_00002032;
  undefined2 in_register_00002036;
  uint uVar3;
  undefined4 *puStack36;
  void *param_ptr;
  
  uVar3 = CONCAT22(in_register_00002036,param_len);
  puStack36 = (undefined4 *)0x0;
  uVar2 = (*_rom_patch_hook)(&puStack36,CONCAT22(in_register_0000202a,id),
                             CONCAT22(in_register_0000202e,dest_id),
                             CONCAT22(in_register_00002032,src_id),uVar3,_rom_patch_hook);
  if (uVar2 == 0) {
    puStack36 = (undefined4 *)ble_ke_malloc(uVar3 + 0xc,'\0');
    *puStack36 = 0xffffffff;
    paVar1 = ble_memset_ptr;
    *(ke_msg_id_t *)(puStack36 + 1) = id;
    *(ke_task_id_t *)((int)puStack36 + 6) = dest_id;
    *(ke_task_id_t *)(puStack36 + 2) = src_id;
    *(uint16_t *)((int)puStack36 + 10) = param_len;
    puStack36 = puStack36 + 3;
    (*paVar1)(puStack36,0,uVar3);
  }
  return puStack36;
}


/*
Unable to decompile 'ble_ke_msg_send'
Cause: Exception while decompiling 2300dbe2: Decompiler process died

*/

/*
Unable to decompile 'ble_ke_msg_get_sent_num'
Cause: Exception while decompiling 2300dc30: Decompiler process died

*/


void ble_ke_msg_send_basic(ke_msg_id_t id,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  undefined2 in_register_0000202a;
  uint32_t uVar1;
  undefined2 in_register_0000202e;
  undefined2 in_register_00002032;
  
  uVar1 = (*_rom_patch_hook)((void *)0x0,CONCAT22(in_register_0000202a,id),
                             CONCAT22(in_register_0000202e,dest_id),
                             CONCAT22(in_register_00002032,src_id),_rom_patch_hook);
  if (uVar1 == 0) {
    ble_ke_msg_alloc(id,dest_id,src_id,0);
    ble_ke_msg_send();
    return;
  }
  return;
}



void ble_ke_msg_free(ke_msg *msg)

{
  uint32_t uVar1;
  
  uVar1 = (*_rom_patch_hook)((void *)0x0,msg,_rom_patch_hook);
  if (uVar1 == 0) {
    ble_ke_free(msg);
    return;
  }
  return;
}



_Bool ble_cmp_abs_time(co_list_hdr *timerA,co_list_hdr *timerB)

{
  uint32_t uVar1;
  byte abStack17 [4];
  _Bool result;
  
  uVar1 = (*_rom_patch_hook)(abStack17,timerA,timerB,_rom_patch_hook);
  if (uVar1 == 0) {
    abStack17[0] = (byte)((uint)((int)timerA[2].next - (int)timerB[2].next) >> 0x16) & 1;
  }
  return (_Bool)abStack17[0];
}



_Bool ble_cmp_timer_id(co_list_hdr *timer,uint32_t timer_task)

{
  uint32_t uVar1;
  bool abStack17 [4];
  _Bool result;
  
  uVar1 = (*_rom_patch_hook)(abStack17,timer,timer_task,_rom_patch_hook);
  if ((uVar1 == 0) && (abStack17[0] = false, (uint)*(ushort *)&timer[1].next == timer_task >> 0x10))
  {
    abStack17[0] = (uint)*(ushort *)((int)&timer[1].next + 2) == (timer_task & 0xffff);
  }
  return (_Bool)abStack17[0];
}



// WARNING: Removing unreachable block (ram,0x2300dd92)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t ble_ke_time(void)

{
  uint32_t uVar1;
  uint32_t uStack20;
  uint32_t time;
  
  uVar1 = (*_rom_patch_hook)(&uStack20,_rom_patch_hook);
  if (uVar1 == 0) {
    do {
    } while( true );
  }
  return uStack20;
}



_Bool ble_ke_time_cmp(uint32_t newer,uint32_t older)

{
  uint32_t uVar1;
  byte abStack17 [4];
  _Bool result;
  
  uVar1 = (*_rom_patch_hook)(abStack17,newer,older,_rom_patch_hook);
  if (uVar1 == 0) {
    abStack17[0] = ((byte)(newer - older >> 0x16) ^ 1) & 1;
  }
  return (_Bool)abStack17[0];
}



_Bool ble_ke_time_past(uint32_t time)

{
  uint32_t newer;
  _Bool a_Stack17 [4];
  _Bool result;
  
  newer = (*_rom_patch_hook)(a_Stack17,time,_rom_patch_hook);
  if (newer == 0) {
    newer = ble_ke_time();
    a_Stack17[0] = ble_ke_time_cmp(newer,time);
  }
  return a_Stack17[0];
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ble_ke_timer_hw_set(ke_timer *timer)

{
  uint32_t uVar1;
  
  uVar1 = (*_rom_patch_hook)((void *)0x0,timer,_rom_patch_hook);
  if (uVar1 == 0) {
    if (timer == (ke_timer *)0x0) {
      _DAT_2800000c = _DAT_2800000c & 0xffffffbf;
    }
    else {
      _DAT_280000f4 = timer->time;
      if ((_DAT_2800000c >> 6 & 1) == 0) {
        _DAT_28000018 = 0x40;
        _DAT_2800000c = _DAT_2800000c | 0x40;
      }
    }
  }
  return;
}



void ble_ke_timer_schedule(void)

{
  _Bool _Var1;
  uint32_t uVar2;
  undefined3 extraout_var;
  co_list_hdr *mem_ptr;
  undefined3 extraout_var_00;
  
  uVar2 = (*_rom_patch_hook)((void *)0x0,_rom_patch_hook);
  if (uVar2 != 0) {
    return;
  }
  do {
    ble_ke_event_clear('\x03');
    mem_ptr = ble_ke_env.queue_timer.first;
    if (ble_ke_env.queue_timer.first == (co_list_hdr *)0x0) {
      ble_ke_timer_hw_set((ke_timer *)0x0);
      return;
    }
    _Var1 = ble_ke_time_past((int)&ble_ke_env.queue_timer.first[2].next[-1].next + 3);
    if (CONCAT31(extraout_var,_Var1) == 0) {
      ble_ke_timer_hw_set((ke_timer *)mem_ptr);
      _Var1 = ble_ke_time_past((uint32_t)mem_ptr[2].next);
      if (CONCAT31(extraout_var_00,_Var1) == 0) {
        return;
      }
    }
    mem_ptr = ble_co_list_pop_front(&ble_ke_env.queue_timer);
    ble_ke_msg_send_basic
              (*(ke_msg_id_t *)&mem_ptr[1].next,*(ke_task_id_t *)((int)&mem_ptr[1].next + 2),0xff);
    ble_ke_free(mem_ptr);
  } while( true );
}



void ble_ke_timer_init(void)

{
  uint32_t uVar1;
  
  uVar1 = (*_rom_patch_hook)((void *)0x0,_rom_patch_hook);
  if (uVar1 == 0) {
    ble_ke_event_callback_set('\x03',ble_ke_timer_schedule);
    return;
  }
  return;
}



void ble_ke_timer_set(ke_msg_id_t timer_id,ke_task_id_t task_id,uint32_t delay)

{
  bool bVar1;
  _Bool _Var2;
  undefined2 in_register_0000202a;
  uint uVar3;
  uint32_t uVar4;
  co_list_hdr *element;
  undefined3 extraout_var;
  undefined2 in_register_0000202e;
  uint uVar5;
  
  uVar5 = CONCAT22(in_register_0000202e,task_id);
  uVar3 = CONCAT22(in_register_0000202a,timer_id);
  uVar4 = (*_rom_patch_hook)((void *)0x0,uVar3,uVar5,delay,_rom_patch_hook);
  if (uVar4 == 0) {
    if (delay < 0x400000) {
      if (delay == 0) {
        delay = 1;
      }
    }
    else {
      delay = 0x3fffff;
    }
    bVar1 = false;
    if ((ble_ke_env.queue_timer.first != (co_list_hdr *)0x0) &&
       ((uint)*(ushort *)&ble_ke_env.queue_timer.first[1].next == uVar3)) {
      bVar1 = (uint)*(ushort *)((int)&ble_ke_env.queue_timer.first[1].next + 2) == uVar5;
    }
    element = ble_ke_queue_extract(&ble_ke_env.queue_timer,ble_cmp_timer_id,uVar3 << 0x10 | uVar5);
    if (element == (co_list_hdr *)0x0) {
      element = (co_list_hdr *)ble_ke_malloc(0xc,'\0');
      *(ke_msg_id_t *)&element[1].next = timer_id;
      *(ke_task_id_t *)((int)&element[1].next + 2) = task_id;
    }
    uVar4 = ble_ke_time();
    element[2].next = (co_list_hdr *)(delay + uVar4 & 0x7fffff);
    ble_ke_queue_insert(&ble_ke_env.queue_timer,element,ble_cmp_abs_time);
    if ((bVar1) || (ble_ke_env.queue_timer.first == element)) {
      ble_ke_timer_hw_set((ke_timer *)ble_ke_env.queue_timer.first);
    }
    _Var2 = ble_ke_time_past(delay + uVar4);
    if (CONCAT31(extraout_var,_Var2) != 0) {
      ble_ke_event_set('\x03');
      return;
    }
  }
  return;
}



void ble_ke_timer_clear(ke_msg_id_t timer_id,ke_task_id_t task_id)

{
  co_list_hdr *pcVar1;
  _Bool _Var2;
  undefined2 in_register_0000202a;
  uint uVar3;
  uint32_t uVar4;
  undefined3 extraout_var;
  co_list_hdr *mem_ptr;
  undefined2 in_register_0000202e;
  uint uVar5;
  
  uVar5 = CONCAT22(in_register_0000202e,task_id);
  uVar3 = CONCAT22(in_register_0000202a,timer_id);
  uVar4 = (*_rom_patch_hook)((void *)0x0,uVar3,uVar5,_rom_patch_hook);
  mem_ptr = ble_ke_env.queue_timer.first;
  if ((uVar4 == 0) && (ble_ke_env.queue_timer.first != (co_list_hdr *)0x0)) {
    if (((uint)*(ushort *)&ble_ke_env.queue_timer.first[1].next == uVar3) &&
       ((uint)*(ushort *)((int)&ble_ke_env.queue_timer.first[1].next + 2) == uVar5)) {
      ble_co_list_pop_front(&ble_ke_env.queue_timer);
      pcVar1 = ble_ke_env.queue_timer.first;
      ble_ke_timer_hw_set((ke_timer *)ble_ke_env.queue_timer.first);
      if ((pcVar1 != (co_list_hdr *)0x0) &&
         (_Var2 = ble_ke_time_past((uint32_t)pcVar1[2].next), CONCAT31(extraout_var,_Var2) != 0)) {
        ble_ke_event_set('\x03');
      }
    }
    else {
      mem_ptr = ble_ke_queue_extract(&ble_ke_env.queue_timer,ble_cmp_timer_id,uVar3 << 0x10 | uVar5)
      ;
      if (mem_ptr == (co_list_hdr *)0x0) {
        return;
      }
    }
    ble_ke_free(mem_ptr);
    return;
  }
  return;
}



_Bool ble_ke_timer_active(ke_msg_id_t timer_id,ke_task_id_t task_id)

{
  undefined2 in_register_0000202a;
  uint32_t uVar1;
  undefined2 in_register_0000202e;
  co_list_hdr cVar2;
  undefined auStack17 [4];
  _Bool result;
  
  uVar1 = (*_rom_patch_hook)(auStack17,CONCAT22(in_register_0000202a,timer_id),
                             CONCAT22(in_register_0000202e,task_id),_rom_patch_hook);
  cVar2 = (co_list_hdr)ble_ke_env.queue_timer.first;
  if (uVar1 == 0) {
    while (cVar2 != (co_list_hdr)0x0) {
      if (((uint)*(ushort *)&((co_list_hdr *)((int)cVar2 + 4))->next ==
           CONCAT22(in_register_0000202a,timer_id)) &&
         ((uint)*(ushort *)((int)cVar2 + 6) == CONCAT22(in_register_0000202e,task_id))) {
        return true;
      }
      cVar2 = *(co_list_hdr *)cVar2;
    }
    auStack17[0] = 0;
  }
  return (_Bool)auStack17[0];
}



void ble_ke_init(void)

{
  uint32_t uVar1;
  
  uVar1 = (*_rom_patch_hook)((void *)0x0,_rom_patch_hook);
  if (uVar1 == 0) {
    (*ble_memset_ptr)((void *)0x4201a1b4,0,8);
    (*ble_memset_ptr)((void *)0x4201a1bc,0,4);
    ble_ke_event_init();
    ble_ke_env.queue_saved.first = (co_list_hdr *)0x0;
    ble_ke_env.queue_saved.last = (co_list_hdr *)0x0;
    ble_ke_env.queue_sent.first = (co_list_hdr *)0x0;
    ble_ke_env.queue_sent.last = (co_list_hdr *)0x0;
    ble_ke_env.queue_timer.first = (co_list_hdr *)0x0;
    ble_ke_env.queue_timer.last = (co_list_hdr *)0x0;
    ble_ke_task_init();
    ble_ke_timer_init();
    return;
  }
  return;
}



void ble_ke_flush(void)

{
  uint32_t uVar1;
  ke_msg *msg;
  co_list_hdr *mem_ptr;
  
  uVar1 = (*_rom_patch_hook)((void *)0x0,_rom_patch_hook);
  if (uVar1 != 0) {
    return;
  }
  while (msg = (ke_msg *)ble_co_list_pop_front((co_list *)&ble_ke_env), msg != (ke_msg *)0x0) {
    ble_ke_msg_free(msg);
  }
  while (msg = (ke_msg *)ble_co_list_pop_front(&ble_ke_env.queue_saved), msg != (ke_msg *)0x0) {
    ble_ke_msg_free(msg);
  }
  while (mem_ptr = ble_co_list_pop_front(&ble_ke_env.queue_timer), mem_ptr != (co_list_hdr *)0x0) {
    ble_ke_free(mem_ptr);
  }
  ble_ke_event_flush();
  return;
}



void rf_force_agc_enable(_Bool en)

{
  return;
}



uint8_t rf_txpwr_dbm_get(uint8_t txpwr_idx,uint8_t modulation)

{
  return (uint8_t)g_txpower_dbm;
}



int8_t rf_rssi_convert(uint8_t rssi_reg)

{
  undefined3 in_register_00002029;
  
  return (int8_t)((uint)((2 - CONCAT31(in_register_00002029,rssi_reg)) * 0x1000000) >> 0x18);
}



uint32_t rf_reg_rd(uint16_t addr)

{
  return 0;
}



void rf_reg_wr(uint16_t addr,uint32_t value)

{
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_sleep(void)

{
  _DAT_28000030 = _DAT_28000030 | 7;
  return;
}



_Bool rf_txpwr_dec(uint8_t dec)

{
  _Bool _Var1;
  undefined3 in_register_00002029;
  undefined3 extraout_var;
  
  _Var1 = rfc_config_power_ble
                    ((int)g_txpower_offset +
                     ((int)g_txpower_dbm - CONCAT31(in_register_00002029,dec)));
  if (CONCAT31(extraout_var,_Var1) != 0) {
    g_txpower_dbm = g_txpower_dbm - dec;
  }
  return _Var1;
}



_Bool rf_txpwr_inc(uint8_t inc)

{
  _Bool _Var1;
  undefined3 in_register_00002029;
  undefined3 extraout_var;
  
  _Var1 = rfc_config_power_ble
                    ((int)g_txpower_offset + (int)g_txpower_dbm + CONCAT31(in_register_00002029,inc)
                    );
  if (CONCAT31(extraout_var,_Var1) != 0) {
    g_txpower_dbm = inc + g_txpower_dbm;
  }
  return _Var1;
}



void rf_txpwr_max_set(int8_t txpwr_dbm)

{
  _Bool _Var1;
  undefined3 in_register_00002029;
  int iVar2;
  undefined3 extraout_var;
  
  iVar2 = CONCAT31(in_register_00002029,txpwr_dbm);
  if (g_txpower_dbm == '\x7f') {
    iVar2 = 0xf;
  }
  g_txpower_dbm = (int8_t)iVar2;
  _Var1 = rfc_config_power_ble(iVar2 + g_txpower_offset);
  if (CONCAT31(extraout_var,_Var1) == 0) {
    rfc_config_power_ble((int)g_txpower_offset + 0xf);
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_reset(void)

{
  _DAT_28000080 = _DAT_28000080 & 0x80000000 | 0x3c0042;
  _DAT_280001a4 = 10;
  _DAT_280001a8 = 0x7d;
  _DAT_280001ac = _DAT_280001ac & 0xffffffc0 | 0x28;
  bz_phy_reset();
  rf_txpwr_max_set(g_txpower_dbm);
  return;
}



void ble_rf_set_pwr_offset(int8_t offset)

{
  g_txpower_offset = offset;
  return;
}



void ble_controller_set_tx_pwr(int ble_tx_power)

{
  _Bool _Var1;
  undefined3 extraout_var;
  
  g_txpower_dbm = (int8_t)ble_tx_power;
  _Var1 = rfc_config_power_ble((int)g_txpower_dbm + (int)g_txpower_offset);
  if (CONCAT31(extraout_var,_Var1) == 0) {
    rfc_config_power_ble((int)g_txpower_offset + 0xf);
    return;
  }
  return;
}



void ble_rf_init(rwip_rf_api_conflict5 *api)

{
  api->reg_rd = rf_reg_rd;
  api->reg_wr = rf_reg_wr;
  api->txpwr_dbm_get = rf_txpwr_dbm_get;
  api->txpwr_max = '\x0f';
  api->txpwr_max_set = rf_txpwr_max_set;
  api->txpwr_inc = rf_txpwr_inc;
  api->txpwr_dec = rf_txpwr_dec;
  api->sleep = rf_sleep;
  api->reset = rf_reset;
  api->force_agc_enable = rf_force_agc_enable;
  api->rssi_convert = rf_rssi_convert;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void pka0_write_common_op_first_cfg
               (uint8_t s0_reg_index,uint8_t s0_reg_type,uint8_t d_reg_index,uint8_t d_reg_type,
               uint8_t op,_Bool last_op)

{
  uint uVar1;
  undefined3 in_register_00002039;
  uint uStack36;
  pka0_common_op_first_cfg cfg;
  
  (*ble_memset_ptr)(&uStack36,0,4);
  uVar1 = ((uint)s0_reg_type & 0xf) << 8;
  uStack36 = uStack36 & 0xfffff000 | (uint)s0_reg_index | uVar1;
  if (CONCAT31(in_register_00002039,op) != 0x19) {
    uStack36 = (uint)s0_reg_index | uVar1 | (uint)d_reg_index << 0xc |
               ((uint)d_reg_type & 0xf) << 0x14;
  }
  _DAT_40004340 = uStack36 & 0xffffff | ((uint)op & 0x7f) << 0x18 | (uint)last_op << 0x1f;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void pka0_write_common_op_snd_cfg_S1(uint8_t s1_reg_index,uint8_t s1_reg_type)

{
  undefined3 in_register_00002029;
  uint uStack20;
  pka0_common_op_snd_cfg_S1_only cfg;
  
  (*ble_memset_ptr)(&uStack20,0,4);
  _DAT_40004340 =
       (uStack20 & 0xfff00fff | CONCAT31(in_register_00002029,s1_reg_index) << 0xc) & 0xff0fffff |
       ((uint)s1_reg_type & 0xf) << 0x14;
  return;
}



// WARNING: Variable defined which should be unmapped: cfg
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void pka0_write_common_op_snd_cfg_S1_S2
               (uint8_t s1_reg_index,uint8_t s1_reg_type,uint8_t s2_reg_index,uint8_t s2_reg_type)

{
  undefined3 in_register_00002029;
  uint uStack20;
  pka0_common_op_snd_cfg_S1_S2 cfg;
  
  (*ble_memset_ptr)(&uStack20,0,4);
  _DAT_40004340 =
       (uStack20 & 0xfff00fff | CONCAT31(in_register_00002029,s1_reg_index) << 0xc) & 0xff0ff000 |
       ((uint)s1_reg_type & 0xf) << 0x14 | (uint)s2_reg_index | ((uint)s2_reg_type & 0xf) << 8;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void sec_eng_pka0_reset(void)

{
  _DAT_40004300 = 8;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void sec_eng_pka0_clear_int(void)

{
  _DAT_40004300 = _DAT_40004300 & 0xfffffdff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void sec_eng_pka0_pld(uint16_t size,uint32_t *data,uint8_t reg_index,uint8_t reg_type,uint8_t op,
                     _Bool last_op)

{
  int iVar1;
  undefined2 in_register_0000202a;
  undefined3 in_register_00002031;
  uint uVar2;
  
  _DAT_40004340 =
       (uint)size & 0xfff | CONCAT31(in_register_00002031,reg_index) << 0xc |
       ((uint)reg_type & 0xf) << 0x14 | ((uint)op & 0x7f) << 0x18 | (uint)last_op << 0x1f;
  uVar2 = 0;
  while ((int)uVar2 < CONCAT22(in_register_0000202a,size)) {
    iVar1 = 0x340;
    if ((size & 7) == 0) {
      iVar1 = 0x360;
    }
    *(uint32_t *)(&DAT_40004000 + (uVar2 & 7) * 4 + iVar1) = data[uVar2];
    uVar2 = uVar2 + 1;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void sec_eng_pka0_wait_4_isr(void)

{
  do {
  } while ((_DAT_40004300 & 0x100) == 0);
  return;
}



// WARNING: Variable defined which should be unmapped: ret_data
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void sec_eng_pka0_read_data(uint8_t reg_ype,uint8_t reg_idx,uint32_t *result,uint8_t ret_size)

{
  int iVar1;
  undefined3 in_register_00002035;
  uint uVar2;
  uint uVar3;
  undefined4 uStack36;
  uint32_t ret_data;
  
  uVar3 = (uint)reg_ype - 1 & 0xff;
  uVar2 = 0;
  if (uVar3 < 10) {
    uVar2 = (uint)*(ushort *)(CSWTCH_9 + uVar3 * 2);
  }
  if (CONCAT31(in_register_00002035,ret_size) <= (uVar2 & 0xff)) {
    _DAT_40004340 = 0;
    sec_eng_pka0_wait_4_isr();
    uVar2 = 0;
    sec_eng_pka0_clear_int();
    while ((int)uVar2 < (int)CONCAT31(in_register_00002035,ret_size)) {
      uVar3 = uVar2 & 7;
      iVar1 = 0x360;
      if ((ret_size & 7) != 0) {
        iVar1 = 0x340;
      }
      uStack36 = *(undefined4 *)(&DAT_40004000 + uVar3 * 4 + iVar1);
      uVar2 = uVar2 + 1;
      (*ble_memcpy_ptr)(result + uVar3,&uStack36,4);
    }
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void sec_eng_pka0_clir(uint8_t last_op,uint8_t d_reg_type,uint8_t d_reg_idx,uint8_t size)

{
  _DAT_40004340 = 0;
  sec_eng_pka0_wait_4_isr();
  sec_eng_pka0_clear_int();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void sec_eng_pka0_movdat(uint8_t last_op,uint8_t d_reg_type,uint8_t d_reg_idx,uint8_t s0_reg_type,
                        uint8_t s0_reg_idx)

{
  undefined3 in_register_00002029;
  
  pka0_write_common_op_first_cfg
            (s0_reg_idx,s0_reg_type,d_reg_idx,d_reg_type,'2',
             (_Bool)(CONCAT31(in_register_00002029,last_op) != 0));
  _DAT_40004340 = 0;
  if (CONCAT31(in_register_00002029,last_op) != 0) {
    sec_eng_pka0_wait_4_isr();
    sec_eng_pka0_clear_int();
    return;
  }
  _DAT_40004340 = 0;
  return;
}



void sec_eng_pka0_msub(uint8_t last_op,uint8_t d_reg_type,uint8_t d_reg_idx,uint8_t s0_reg_type,
                      uint8_t s0_reg_idx,uint8_t s1_reg_type,uint8_t s1_reg_idx,uint8_t s2_reg_type,
                      uint8_t s2_reg_idx)

{
  undefined3 in_register_00002029;
  uint8_t in_stack_00000000;
  
  pka0_write_common_op_first_cfg
            (s0_reg_idx,s0_reg_type,d_reg_idx,d_reg_type,'\'',
             (_Bool)(CONCAT31(in_register_00002029,last_op) != 0));
  pka0_write_common_op_snd_cfg_S1_S2(s1_reg_idx,s1_reg_type,in_stack_00000000,s2_reg_type);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void sec_eng_pka0_mrem(uint8_t last_op,uint8_t d_reg_type,uint8_t d_reg_idx,uint8_t s0_reg_type,
                      uint8_t s0_reg_idx,uint8_t s2_reg_type,uint8_t s2_reg_idx)

{
  undefined3 in_register_00002029;
  uint uStack20;
  pka0_common_op_snd_cfg_S2_only cfg;
  
  pka0_write_common_op_first_cfg
            (s0_reg_idx,s0_reg_type,d_reg_idx,d_reg_type,'&',
             (_Bool)(CONCAT31(in_register_00002029,last_op) != 0));
  (*ble_memset_ptr)(&uStack20,0,4);
  _DAT_40004340 = uStack20 & 0xfffff000 | (uint)s2_reg_idx | ((uint)s2_reg_type & 0xf) << 8;
  return;
}



void sec_eng_pka0_mmul(uint8_t last_op,uint8_t d_reg_type,uint8_t d_reg_idx,uint8_t s0_reg_type,
                      uint8_t s0_reg_idx,uint8_t s1_reg_type,uint8_t s1_reg_idx,uint8_t s2_reg_type,
                      uint8_t s2_reg_idx)

{
  undefined3 in_register_00002029;
  uint8_t in_stack_00000000;
  
  pka0_write_common_op_first_cfg
            (s0_reg_idx,s0_reg_type,d_reg_idx,d_reg_type,'%',
             (_Bool)(CONCAT31(in_register_00002029,last_op) != 0));
  pka0_write_common_op_snd_cfg_S1_S2(s1_reg_idx,s1_reg_type,in_stack_00000000,s2_reg_type);
  return;
}



void sec_eng_pka0_mexp(uint8_t last_op,uint8_t d_reg_type,uint8_t d_reg_idx,uint8_t s0_reg_type,
                      uint8_t s0_reg_idx,uint8_t s1_reg_type,uint8_t s1_reg_idx,uint8_t s2_reg_type,
                      uint8_t s2_reg_idx)

{
  undefined3 in_register_00002029;
  uint8_t in_stack_00000000;
  
  pka0_write_common_op_first_cfg
            (s0_reg_idx,s0_reg_type,d_reg_idx,d_reg_type,'#',
             (_Bool)(CONCAT31(in_register_00002029,last_op) != 0));
  pka0_write_common_op_snd_cfg_S1_S2(s1_reg_idx,s1_reg_type,in_stack_00000000,s2_reg_type);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void sec_eng_pka0_lcmp(uint8_t *cout,uint8_t s0_reg_type,uint8_t s0_reg_idx,uint8_t s1_reg_type,
                      uint8_t s1_reg_idx)

{
  pka0_write_common_op_first_cfg(s0_reg_idx,s0_reg_type,'\0','\0','\x19',true);
  pka0_write_common_op_snd_cfg_S1(s1_reg_idx,s1_reg_type);
  sec_eng_pka0_wait_4_isr();
  sec_eng_pka0_clear_int();
  *cout = (byte)((uint)_DAT_40004300 >> 0x18) & 1;
  return;
}



void sec_eng_pka0_lsub(uint8_t last_op,uint8_t d_reg_type,uint8_t d_reg_idx,uint8_t s0_reg_type,
                      uint8_t s0_reg_idx,uint8_t s1_reg_type,uint8_t s1_reg_idx)

{
  undefined3 in_register_00002029;
  
  pka0_write_common_op_first_cfg
            (s0_reg_idx,s0_reg_type,d_reg_idx,d_reg_type,'\x17',
             (_Bool)(CONCAT31(in_register_00002029,last_op) != 0));
  pka0_write_common_op_snd_cfg_S1(s1_reg_idx,s1_reg_type);
  return;
}



void sec_eng_pka0_lmul(uint8_t last_op,uint8_t d_reg_type,uint8_t d_reg_idx,uint8_t s0_reg_type,
                      uint8_t s0_reg_idx,uint8_t s1_reg_type,uint8_t s1_reg_idx)

{
  undefined3 in_register_00002029;
  
  pka0_write_common_op_first_cfg
            (s0_reg_idx,s0_reg_type,d_reg_idx,d_reg_type,'\x16',
             (_Bool)(CONCAT31(in_register_00002029,last_op) != 0));
  pka0_write_common_op_snd_cfg_S1(s1_reg_idx,s1_reg_type);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void sec_eng_pka0_lmul2n(uint8_t last_op,uint8_t d_reg_type,uint8_t d_reg_idx,uint8_t s0_reg_type,
                        uint8_t s0_reg_idx,uint16_t bit_shift)

{
  uint uStack36;
  pka0_bit_shift_op_cfg cfg;
  
  (*ble_memset_ptr)(&uStack36,0,4);
  pka0_write_common_op_first_cfg(s0_reg_idx,s0_reg_type,d_reg_idx,d_reg_type,'\x13',false);
  _DAT_40004340 = uStack36 & 0xffff8000 | (uint)bit_shift & 0x7fff;
  return;
}



void em_buf_init(void)

{
  em_desc_node *peVar1;
  undefined2 *puVar2;
  uint uVar3;
  em_buf_env_tag *peVar4;
  int iVar5;
  uint uVar6;
  ushort *puVar7;
  ushort *puVar8;
  em_buf_env_tag *peVar9;
  
  em_buf_env.rx_current = '\0';
  ble_co_list_init((co_list *)&em_buf_env);
  ble_co_list_init(&em_buf_env.tx_buff_free);
  em_buf_env.tx_desc = (em_buf_tx_desc *)&DAT_280082ca;
  peVar9 = &em_buf_env;
  peVar4 = &em_buf_env;
  uVar3 = 0;
  puVar2 = (undefined2 *)&DAT_280082ce;
  do {
    uVar6 = uVar3 & 0xffff;
    peVar4->tx_desc_node[0].idx = (uint16_t)uVar3;
    uVar3 = uVar3 + 1;
    peVar4 = (em_buf_env_tag *)&(peVar4->tx_buff_free).last;
    *puVar2 = (short)((uVar6 * 0x26 + 0x43e) * 0x10000 >> 0x10);
    puVar2[2] = 0;
    puVar2[1] = 0;
    puVar2[-1] = puVar2[-1] & 0xffdf;
    puVar2[-1] = puVar2[-1] & 0xffdf;
    puVar2[-2] = 0x8000;
    puVar2 = puVar2 + 5;
  } while (uVar3 != 6);
  puVar2 = (undefined2 *)&DAT_2800830a;
  do {
    peVar9->tx_desc_node[6].idx = (uint16_t)uVar3;
    *puVar2 = 0;
    puVar2[2] = 0;
    puVar2[1] = 0;
    peVar1 = peVar9->tx_desc_node;
    puVar2[-1] = puVar2[-1] & 0xffdf;
    uVar3 = uVar3 + 1;
    peVar9 = (em_buf_env_tag *)&(peVar9->tx_buff_free).last;
    puVar2[-1] = puVar2[-1] & 0xffdf;
    puVar2[-2] = 0x8000;
    ble_co_list_push_back(&em_buf_env,peVar1 + 6);
    puVar2 = puVar2 + 5;
  } while (uVar3 != 0x1a);
  em_buf_env.tx_buff_node[0]._4_4_ = 0x5220000;
  ble_co_list_push_back(0x4201a1c8,0x4201a308);
  em_buf_env.tx_buff_node[1]._4_4_ = 0x6260001;
  ble_co_list_push_back(0x4201a1c8,0x4201a310);
  iVar5 = 0;
  puVar2 = (undefined2 *)&DAT_280083d6;
  do {
    iVar5 = iVar5 + 1;
    *puVar2 = (short)((uint)((iVar5 * 0x104 + 0x626) * 0x10000) >> 0x10);
    puVar2[-4] = ((ushort)iVar5 & 7) * 0xe + 0x3ce;
    puVar2[2] = 0;
    puVar2[-2] = puVar2[-2] & 0xffdf;
    puVar2[-2] = puVar2[-2] & 0xffdf;
    puVar2 = puVar2 + 7;
  } while (iVar5 != 8);
  puVar7 = (ushort *)&DAT_2800809e;
  do {
    puVar8 = puVar7 + 0x2e;
    *puVar7 = *puVar7 & 0xbfff;
    puVar7[9] = puVar7[9] & 0xfcff;
    puVar7[0x25] = 0;
    puVar7 = puVar8;
  } while (puVar8 != (ushort *)0x2800820e);
  return;
}



void em_buf_rx_free(uint8_t hdl)

{
  undefined3 in_register_00002029;
  
  *(ushort *)(&DAT_280083ce + CONCAT31(in_register_00002029,hdl) * 0xe) =
       (ushort)(((uint)*(ushort *)(&DAT_280083ce + CONCAT31(in_register_00002029,hdl) * 0xe) << 0x11
                ) >> 0x11);
  return;
}



uint8_t * em_buf_rx_buff_addr_get(uint16_t rx_hdl)

{
  undefined2 in_register_0000202a;
  
  return &DAT_28008000 + *(ushort *)(&DAT_280083d6 + CONCAT22(in_register_0000202a,rx_hdl) * 0xe);
}


/*
Unable to decompile 'em_buf_tx_free'
Cause: Exception while decompiling 2300eb66: Decompiler process died

*/


void llc_init(void)

{
  ble_ke_task_create('\x01',&TASK_DESC_LLC);
  ble_ke_state_set(1,'\x7f');
  ble_ke_state_set(0x101,'\x7f');
                    // WARNING: Could not recover jumptable at 0x2300ec60. Too many branches
                    // WARNING: Treating indirect jump as call
  (*ble_memset_ptr)(llc_env,0,8);
  return;
}



void llc_stop(int param_1)

{
  void *pvVar1;
  int iVar2;
  
  ble_ke_state_set((ushort)(param_1 << 8) | 1,'\x7f');
  if (llc_env[param_1] != (llc_env_tag *)0x0) {
    iVar2 = 0;
    do {
      pvVar1 = llc_env[param_1]->operation[iVar2];
      if (pvVar1 != (void *)0x0) {
        ble_ke_msg_free((ke_msg *)((int)pvVar1 + -0xc));
      }
      iVar2 = iVar2 + 1;
    } while (iVar2 != 4);
    ble_ke_free(llc_env[param_1]);
    llc_env[param_1] = (llc_env_tag *)0x0;
    llm_util_bl_rem((uint16_t)param_1);
    return;
  }
  return;
}



void llc_reset(void)

{
  ke_state_t kVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  
  kVar1 = ble_ke_state_get(1);
  if (CONCAT31(extraout_var,kVar1) != 0x7f) {
    llc_stop(0);
  }
  kVar1 = ble_ke_state_get(0x101);
  if (CONCAT31(extraout_var_00,kVar1) != 0x7f) {
    llc_stop(1);
    return;
  }
  return;
}



void llc_discon_event_complete_send
               (ke_task_id_t src_id,uint8_t status,uint8_t conhdl,uint8_t reason)

{
  uint8_t *param;
  ke_task_id_t dest_id;
  undefined3 in_register_00002031;
  
  dest_id = (ke_task_id_t)CONCAT31(in_register_00002031,conhdl);
  param = (uint8_t *)ble_ke_msg_alloc(0x803,dest_id,5,6);
  *param = status;
  param[4] = reason;
  *(ke_task_id_t *)(param + 2) = dest_id;
  hci_send_2_host(param);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void llc_le_con_cmp_evt_send(uint8_t status,uint16_t conhdl,llc_create_con_req_ind *param)

{
  ushort uVar1;
  undefined *param_00;
  _Bool _Var2;
  uint8_t uVar3;
  undefined3 in_register_00002029;
  int iVar4;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  bd_addr *pbVar5;
  undefined *puVar6;
  anon_subr_void_ptr_void_ptr_void_ptr_uint *paVar7;
  undefined *puVar8;
  ushort *puVar9;
  
  iVar4 = CONCAT31(in_register_00002029,status);
  _Var2 = llm_util_check_evt_mask('\0');
  if ((CONCAT31(extraout_var,_Var2) == 0) &&
     (_Var2 = llm_util_check_evt_mask('\t'), CONCAT31(extraout_var_02,_Var2) == 0)) {
    return;
  }
  _Var2 = llm_util_check_evt_mask('\t');
  if (CONCAT31(extraout_var_00,_Var2) != 0) {
    param_00 = (undefined *)ble_ke_msg_alloc(0x804,conhdl,0,0x20);
    *param_00 = 10;
    param_00[1] = status;
    *(uint16_t *)(param_00 + 2) = conhdl;
    if (iVar4 != 0) {
      if (iVar4 != 0x3c) goto LAB_2300ee44;
      param_00[4] = 1;
      uVar3 = param->peer_addr_type;
      *(undefined2 *)(param_00 + 2) = 0;
      param_00[5] = uVar3;
      paVar7 = ble_memcpy_ptr;
      *(undefined2 *)(param_00 + 0x18) = 0;
      *(undefined2 *)(param_00 + 0x1a) = 0;
      *(undefined2 *)(param_00 + 0x1c) = 0;
      (*paVar7)(param_00 + 6,&param->peer_addr,6);
      (*ble_memset_ptr)(param_00 + 0x12,0,6);
      pbVar5 = (bd_addr *)0x0;
      puVar8 = param_00 + 0xc;
      paVar7 = (anon_subr_void_ptr_void_ptr_void_ptr_uint *)ble_memset_ptr;
      goto LAB_2300eedc;
    }
    uVar3 = lld_get_mode(conhdl);
    *(bool *)(param_00 + 4) = CONCAT31(extraout_var_03,uVar3) != 3;
    uVar1 = param->ral_ptr;
    puVar8 = param_00 + 0xc;
    if (uVar1 == 0) {
      (*ble_memset_ptr)(puVar8,0,6);
      puVar8 = param_00 + 0x12;
LAB_2300efa6:
      (*ble_memset_ptr)(puVar8,0,6);
    }
    else {
      puVar9 = (ushort *)(&DAT_2800822e + (((uint)uVar1 - 0x22e) / 0x34 & 0xff) * 0x34);
      if (((*puVar9 >> 1 & 1) == 0) || ((param->filter_policy != '\0' && ((*puVar9 >> 3 & 1) == 0)))
         ) {
        puVar6 = (undefined *)0x0;
        paVar7 = (anon_subr_void_ptr_void_ptr_void_ptr_uint *)ble_memset_ptr;
      }
      else {
        puVar6 = &DAT_28008000 + ((uint)uVar1 + 0x12 & 0xffff);
        paVar7 = ble_memcpy_ptr;
      }
      (*paVar7)(param_00 + 0x12,puVar6,6);
      if (((*puVar9 >> 5 & 1) == 0) || ((param_00[4] == '\x01' && ((_DAT_28008154 >> 2 & 1) == 0))))
      goto LAB_2300efa6;
      (*ble_memcpy_ptr)(puVar8,&DAT_28008000 + ((uint)param->ral_ptr + 0x2e & 0xffff),6);
    }
    param_00[5] = param->peer_addr_type;
    (*ble_memcpy_ptr)(param_00 + 6,&param->peer_addr,6);
    *(uint16_t *)(param_00 + 0x18) = param->con_int;
    *(uint16_t *)(param_00 + 0x1a) = param->con_lat;
    *(uint16_t *)(param_00 + 0x1c) = param->sup_to;
    if (param_00[4] == '\0') {
      param_00[0x1e] = 0;
    }
    else {
      param_00[0x1e] = param->sleep_clk_acc;
    }
    goto LAB_2300ee44;
  }
  param_00 = (undefined *)ble_ke_msg_alloc(0x804,conhdl,0,0x14);
  *param_00 = 1;
  param_00[1] = status;
  *(uint16_t *)(param_00 + 2) = conhdl;
  if (iVar4 != 0) {
    if (iVar4 != 0x3c) goto LAB_2300ee44;
    param_00[4] = 1;
    uVar3 = param->peer_addr_type;
    *(undefined2 *)(param_00 + 2) = 0;
    *(undefined2 *)(param_00 + 0xc) = 0;
    param_00[5] = uVar3;
    paVar7 = ble_memcpy_ptr;
    *(undefined2 *)(param_00 + 0xe) = 0;
    *(undefined2 *)(param_00 + 0x10) = 0;
    pbVar5 = &param->peer_addr;
    puVar8 = param_00 + 6;
LAB_2300eedc:
    (*paVar7)(puVar8,pbVar5,6);
    goto LAB_2300ee44;
  }
  uVar3 = lld_get_mode(conhdl);
  *(bool *)(param_00 + 4) = CONCAT31(extraout_var_01,uVar3) != 3;
  puVar8 = param_00 + 6;
  if ((param->ral_ptr == 0) ||
     ((*(ushort *)(&DAT_2800822e + (((uint)param->ral_ptr - 0x22e) / 0x34 & 0xff) * 0x34) >> 1 & 1)
      == 0)) {
LAB_2300ee84:
    param_00[5] = param->peer_addr_type & 1;
    (*ble_memcpy_ptr)(puVar8,&param->peer_addr,6);
  }
  else {
    if ((param->filter_policy != '\0') &&
       ((*(ushort *)(&DAT_2800822e + (((uint)param->ral_ptr - 0x22e) / 0x34 & 0xff) * 0x34) >> 3 & 1
        ) == 0)) {
      (*ble_memset_ptr)(puVar8,0,6);
      goto LAB_2300ee84;
    }
    param_00[5] = 1;
    (*ble_memcpy_ptr)(puVar8,&DAT_28008000 + ((uint)param->ral_ptr + 0x12 & 0xffff),6);
  }
  *(uint16_t *)(param_00 + 0xc) = param->con_int;
  *(uint16_t *)(param_00 + 0xe) = param->con_lat;
  *(uint16_t *)(param_00 + 0x10) = param->sup_to;
  if (param_00[4] == '\0') {
    param_00[0x12] = 0;
  }
  else {
    param_00[0x12] = param->sleep_clk_acc;
  }
LAB_2300ee44:
  hci_send_2_host(param_00);
  return;
}



void llc_le_ch_sel_algo_evt_send(uint8_t chSel,uint16_t conhdl,llc_create_con_req_ind *param)

{
  _Bool _Var1;
  undefined3 extraout_var;
  undefined *param_00;
  
  _Var1 = llm_util_check_evt_mask('\x13');
  if (CONCAT31(extraout_var,_Var1) != 0) {
    param_00 = (undefined *)ble_ke_msg_alloc(0x804,conhdl,0,6);
    *param_00 = 0x14;
    param_00[4] = chSel;
    *(uint16_t *)(param_00 + 2) = conhdl;
    hci_send_2_host(param_00);
    return;
  }
  return;
}



void llc_start(llc_create_con_req_ind *param_1,ea_elt_tag *param_2)

{
  ushort conhdl;
  ushort uVar1;
  anon_subr_void_ptr_void_ptr_int_uint *paVar2;
  uint16_t uVar3;
  llc_env_tag *plVar4;
  llc_env_tag **pplVar5;
  ushort task_id;
  uint delay;
  llc_env_tag *plVar6;
  uint uVar7;
  
  conhdl = *(ushort *)&param_2[2].ea_cb_start;
  uVar7 = (uint)conhdl;
  task_id = conhdl << 8 | 1;
  if (llc_env[uVar7] == (llc_env_tag *)0x0) {
    plVar4 = (llc_env_tag *)ble_ke_malloc(0xa8,'\0');
    llc_env[uVar7] = plVar4;
  }
  paVar2 = ble_memset_ptr;
  plVar4 = llc_env[uVar7];
  plVar4->peer_sup_conn_param_req = true;
  (*paVar2)(&plVar4->peer_version,0,6);
  llm_util_get_channel_map(&plVar4->ch_map);
  llm_util_get_channel_map(&plVar4->n_ch_map);
  if (*(char *)((int)&param_2[2].ea_cb_stop + 3) == '\x03') {
    (*ble_memset_ptr)(&plVar4->chnl_assess,0,0x28);
    delay = (uint)llm_le_env.ch_map_assess.assess_timer;
    (plVar4->chnl_assess).reassess_count = llm_le_env.ch_map_assess.reassess_count;
    ble_ke_timer_set(0x105,task_id,delay);
    if (*(ushort *)((int)&param_2[2].linked_element + 2) < 2) {
      (plVar4->chnl_assess).latency_en = false;
    }
    else {
      (plVar4->chnl_assess).latency_en = true;
    }
  }
  plVar4->elt = param_2;
  uVar1 = param_1->sup_to;
  plVar4->sup_to = uVar1;
  ble_ke_timer_set(0x101,task_id,(uint)uVar1);
  plVar4->disc_reason = '\b';
  plVar4->llc_status = 0;
  plVar4->disc_event_sent = false;
  llm_util_get_supp_features(&plVar4->feats_used);
  plVar4->operation[0] = (void *)0x0;
  plVar4->operation[1] = (void *)0x0;
  plVar4->operation[2] = (void *)0x0;
  plVar4->operation[3] = (void *)0x0;
  ble_ke_state_set(task_id,'\0');
  pplVar5 = llc_env + uVar7;
  plVar6 = *pplVar5;
  plVar6->auth_payl_to = 3000;
  plVar6->loc_proc_state = '\0';
  plVar6->rem_proc_state = '\0';
  llc_util_set_auth_payl_to_margin((lld_evt_tag *)&param_2->env);
  uVar3 = llm_le_env.data_len_val.conn_initial_max_tx_octets;
  (plVar4->data_len_ext_info).send_req_not_allowed = false;
  (plVar4->data_len_ext_info).conn_max_tx_octets = uVar3;
  (plVar4->data_len_ext_info).conn_max_tx_time = llm_le_env.data_len_val.conn_initial_max_tx_time;
  *(undefined4 *)&(plVar4->data_len_ext_info).conn_max_rx_octets = 0x1b00fb;
  (plVar4->data_len_ext_info).conn_eff_max_rx_octets = 0x1b;
  *(undefined4 *)&(plVar4->data_len_ext_info).conn_max_rx_time = 0x1480848;
  (plVar4->data_len_ext_info).conn_eff_max_rx_time = 0x148;
  (plVar4->data_len_ext_info).data_len_ext_flag =
       (plVar4->data_len_ext_info).data_len_ext_flag & 0xfe | 2;
  (*pplVar5)->operation[0] = (void *)0x0;
  (*pplVar5)->operation[1] = (void *)0x0;
  plVar4 = *pplVar5;
  plVar4->operation[2] = (void *)0x0;
  plVar4->operation[3] = (void *)0x0;
  plVar4->encryption_state = '\0';
  llc_le_con_cmp_evt_send('\0',conhdl,param_1);
  llc_le_ch_sel_algo_evt_send
            ((byte)((ushort)*(undefined2 *)(&DAT_2800809e + uVar7 * 0x5c) >> 0xe) & 1,conhdl,param_1
            );
  return;
}



void llc_con_update_complete_send(uint8_t status,uint16_t conhdl,lld_evt_tag *evt)

{
  undefined *param;
  undefined2 in_register_0000202e;
  uint16_t uVar1;
  void *pvVar2;
  
  param = (undefined *)ble_ke_msg_alloc(0x804,conhdl,0,10);
  *param = 3;
  *(uint16_t *)(param + 2) = conhdl;
  param[1] = status;
  if (evt == (lld_evt_tag *)0x0) {
    pvVar2 = llc_env[CONCAT22(in_register_0000202e,conhdl)]->operation[0];
    if (pvVar2 == (void *)0x0) {
      *(undefined2 *)(param + 4) = 0;
      *(undefined2 *)(param + 6) = 0;
      *(undefined2 *)(param + 8) = 0;
      goto LAB_2300f300;
    }
    *(undefined2 *)(param + 4) = *(undefined2 *)((int)pvVar2 + 0xe);
    *(undefined2 *)(param + 6) = *(undefined2 *)((int)pvVar2 + 6);
    uVar1 = *(uint16_t *)((int)pvVar2 + 8);
  }
  else {
    *(uint16_t *)(param + 4) = evt->interval >> 1;
    *(short *)(param + 6) = *(short *)(evt->evt + 10) + -1;
    uVar1 = llc_env[CONCAT22(in_register_0000202e,conhdl)]->sup_to;
  }
  *(uint16_t *)(param + 8) = uVar1;
LAB_2300f300:
  hci_send_2_host(param);
  return;
}



void llc_ltk_req_send(uint16_t conhdl,llcp_enc_req *param)

{
  undefined *param_00;
  
  param_00 = (undefined *)ble_ke_msg_alloc(0x804,conhdl,0,0xe);
  *(uint16_t *)(param_00 + 2) = conhdl;
  *param_00 = 5;
  *(undefined2 *)(param_00 + 0xc) = *(undefined2 *)param->ediv;
  (*ble_memcpy_ptr)(param_00 + 4,&param->rand,8);
  hci_send_2_host(param_00);
  return;
}



void llc_feats_rd_event_send(uint8_t status,uint16_t conhdl,le_features *feats)

{
  _Bool _Var1;
  undefined3 extraout_var;
  undefined *param;
  
  _Var1 = llm_util_check_evt_mask('\x03');
  if (CONCAT31(extraout_var,_Var1) != 0) {
    param = (undefined *)ble_ke_msg_alloc(0x804,conhdl,0,0xc);
    *param = 4;
    param[1] = status;
    *(uint16_t *)(param + 2) = conhdl;
    (*ble_memcpy_ptr)(param + 4,feats,8);
    hci_send_2_host(param);
    return;
  }
  return;
}



void llc_version_rd_event_send(uint8_t status,uint16_t conhdl)

{
  uint8_t *param;
  undefined2 in_register_0000202e;
  llc_env_tag *plVar1;
  
  param = (uint8_t *)ble_ke_msg_alloc(0x803,conhdl,0xc,10);
  *(uint16_t *)(param + 2) = conhdl;
  *param = status;
  *(uint16_t *)(param + 6) = (llc_env[CONCAT22(in_register_0000202e,conhdl)]->peer_version).compid;
  plVar1 = llc_env[CONCAT22(in_register_0000202e,conhdl)];
  *(uint16_t *)(param + 8) = (plVar1->peer_version).subvers;
  param[4] = (plVar1->peer_version).vers;
  hci_send_2_host(param);
  return;
}



void llc_common_cmd_complete_send(uint16_t opcode,uint8_t status,uint16_t conhdl)

{
  uint8_t *param;
  
  param = (uint8_t *)ble_ke_msg_alloc(0x801,conhdl,opcode,4);
  *param = status;
  *(uint16_t *)(param + 2) = conhdl;
  hci_send_2_host(param);
  return;
}



void llc_common_cmd_status_send(uint16_t opcode,uint8_t status,uint16_t conhdl)

{
  uint8_t *param;
  
  param = (uint8_t *)ble_ke_msg_alloc(0x802,conhdl,opcode,1);
  *param = status;
  hci_send_2_host(param);
  return;
}



void llc_common_flush_occurred_send(uint16_t conhdl)

{
  uint16_t *param;
  
  param = (uint16_t *)ble_ke_msg_alloc(0x803,conhdl,0x11,2);
  *param = conhdl;
  hci_send_2_host(param);
  return;
}



void llc_common_enc_key_ref_comp_evt_send(uint16_t conhdl,uint8_t status)

{
  uint8_t *param;
  
  param = (uint8_t *)ble_ke_msg_alloc(0x803,conhdl,0x30,4);
  *(uint16_t *)(param + 2) = conhdl;
  *param = status;
  hci_send_2_host(param);
  return;
}



void llc_common_enc_change_evt_send(uint16_t conhdl,uint8_t enc_status,uint8_t status)

{
  undefined2 in_register_0000202a;
  uint8_t *param;
  ushort task_id;
  undefined3 in_register_0000202d;
  llc_env_tag *plVar1;
  
  task_id = conhdl << 8 | 1;
  if (CONCAT31(in_register_0000202d,enc_status) == 0) {
    ble_ke_timer_clear(0x103,task_id);
    ble_ke_timer_clear(0x104,task_id);
  }
  else {
    plVar1 = llc_env[CONCAT22(in_register_0000202a,conhdl)];
    ble_ke_timer_set(0x103,task_id,(uint)plVar1->auth_payl_to - (uint)plVar1->auth_payl_to_margin);
    ble_ke_timer_set(0x104,task_id,
                     (uint)llc_env[CONCAT22(in_register_0000202a,conhdl)]->auth_payl_to);
  }
  param = (uint8_t *)ble_ke_msg_alloc(0x803,conhdl,8,6);
  *(uint16_t *)(param + 2) = conhdl;
  param[4] = enc_status;
  *param = status;
  hci_send_2_host(param);
  return;
}



void llc_common_nb_of_pkt_comp_evt_send(uint16_t conhdl,uint8_t nb_of_pkt)

{
  undefined *param;
  undefined3 in_register_0000202d;
  
  param = (undefined *)ble_ke_msg_alloc(0x803,conhdl,0x13,6);
  *(uint16_t *)(param + 2) = conhdl;
  *(short *)(param + 4) = (short)CONCAT31(in_register_0000202d,nb_of_pkt);
  *param = 1;
  hci_send_2_host(param);
  return;
}



void llc_con_update_ind(uint16_t conhdl,ea_elt_tag *elt_new)

{
  ushort uVar1;
  _Bool _Var2;
  undefined2 in_register_0000202a;
  undefined3 extraout_var;
  
  uVar1 = llc_env[CONCAT22(in_register_0000202a,conhdl)]->llc_status;
  if ((uVar1 & 0xc0) != 0) {
    llc_env[CONCAT22(in_register_0000202a,conhdl)]->llc_status = uVar1 & 0xff3f;
    _Var2 = llm_util_check_evt_mask('\x02');
    if (CONCAT31(extraout_var,_Var2) != 0) {
      llc_con_update_complete_send('\0',conhdl,(lld_evt_tag *)&elt_new->env);
    }
  }
  if (*(ushort *)((int)&elt_new[2].linked_element + 2) < 2) {
    (llc_env[CONCAT22(in_register_0000202a,conhdl)]->chnl_assess).latency_en = false;
  }
  else {
    (llc_env[CONCAT22(in_register_0000202a,conhdl)]->chnl_assess).latency_en = true;
  }
  return;
}



void llc_lsto_con_update(uint16_t conhdl)

{
  llc_env_tag *plVar1;
  undefined2 in_register_0000202a;
  uint uVar2;
  
  plVar1 = llc_env[CONCAT22(in_register_0000202a,conhdl)];
  uVar2 = (uint)plVar1->sup_to;
  if ((uint)plVar1->sup_to < (uint)plVar1->n_sup_to) {
    uVar2 = (uint)plVar1->n_sup_to;
  }
  plVar1->sup_to = (uint16_t)((uVar2 << 0x11) >> 0x10);
  ble_ke_timer_set(0x101,conhdl << 8 | 1,(uVar2 << 0x11) >> 0x10);
  plVar1->llc_status = plVar1->llc_status | 0x20;
  return;
}



void llc_map_update_ind(uint16_t conhdl)

{
  llc_env_tag *plVar1;
  uint8_t uVar2;
  undefined2 in_register_0000202a;
  int iVar3;
  
  plVar1 = llc_env[CONCAT22(in_register_0000202a,conhdl)];
  uVar2 = llm_util_check_map_validity((uint8_t *)&plVar1->n_ch_map,'\x05');
  iVar3 = CONCAT22(in_register_0000202a,conhdl) * 0x5c;
  *(undefined2 *)(iVar3 + 0x280080aa) = *(undefined2 *)(plVar1->n_ch_map).map;
  *(undefined2 *)(iVar3 + 0x280080ac) = *(undefined2 *)((plVar1->n_ch_map).map + 2);
  *(undefined2 *)(iVar3 + 0x280080ae) = CONCAT11(uVar2,(plVar1->n_ch_map).map[4]);
  memcpy(&plVar1->ch_map,&plVar1->n_ch_map,5);
  return;
}



void llc_con_update_finished(int param_1)

{
  ushort uVar1;
  byte bVar2;
  uint8_t uVar3;
  ushort id;
  undefined3 extraout_var;
  llc_env_tag *plVar4;
  
  id = (ushort)(param_1 << 8) | 1;
  bVar2 = ble_ke_state_get(id);
  if ((bVar2 & 0xf) != 0xf) {
    uVar3 = lld_get_mode((uint16_t)param_1);
    if (CONCAT31(extraout_var,uVar3) == 3) {
      llc_util_clear_operation_ptr(param_1,0);
      ble_ke_state_set(id,bVar2 & 0xfe);
      llc_env[param_1]->loc_proc_state = '\0';
    }
    else {
      plVar4 = llc_env[param_1];
      uVar1 = plVar4->llc_status;
      if ((uVar1 & 0x400) == 0) {
        plVar4->llc_status = uVar1 | 0x800;
      }
      else {
        ble_ke_state_set(id,bVar2 & 0xfd);
        plVar4 = llc_env[param_1];
        plVar4->rem_proc_state = '\0';
        plVar4->llc_status = plVar4->llc_status & 0xfbff;
      }
    }
  }
  return;
}



void llc_map_update_finished(int param_1)

{
  ushort uVar1;
  byte bVar2;
  uint8_t uVar3;
  ushort id;
  undefined3 extraout_var;
  llc_env_tag *plVar4;
  
  id = (ushort)(param_1 << 8) | 1;
  bVar2 = ble_ke_state_get(id);
  if ((bVar2 & 0xf) != 0xf) {
    uVar3 = lld_get_mode((uint16_t)param_1);
    if (CONCAT31(extraout_var,uVar3) == 3) {
      ble_ke_state_set(id,bVar2 & 0xfe);
      llc_env[param_1]->loc_proc_state = '\0';
    }
    else {
      plVar4 = llc_env[param_1];
      uVar1 = plVar4->llc_status;
      if ((uVar1 & 0x400) == 0) {
        plVar4->llc_status = uVar1 | 0x800;
      }
      else {
        ble_ke_state_set(id,bVar2 & 0xfd);
        plVar4 = llc_env[param_1];
        plVar4->rem_proc_state = '\0';
        plVar4->llc_status = plVar4->llc_status & 0xfbff;
      }
    }
  }
  return;
}



void lld_evt_winsize_change(lld_evt_tag *evt,_Bool instant)

{
  undefined3 in_register_0000202d;
  uint uVar1;
  uint uVar2;
  
  uVar1 = *(uint *)evt->evt;
  if ((int)(uVar1 << 0x10) < 0) {
    uVar1 = (uVar1 & 0x7fff) * 0x271;
  }
  uVar1 = uVar1 + *(int *)(evt->evt + 4) * 2;
  uVar2 = uVar1;
  if (uVar1 < 0xe) {
    uVar2 = 0xe;
  }
  if (((uint)(evt->interval >> 1) * (uint)*(ushort *)(evt->evt + 10) * 0x271 - 0x96 <= uVar2) &&
     (CONCAT31(in_register_0000202d,instant) == 0)) {
    evt->evt_flag = evt->evt_flag | 0x10;
    return;
  }
  if (0x3fff < uVar1) {
    uVar2 = ((uVar2 + 0x270) / 0x271 | 0xffff8000) & 0xffff;
    if ((evt->anchor_point).finetime_cnt == 0) goto LAB_2300f8f2;
    uVar2 = uVar2 + 1;
  }
  uVar2 = uVar2 & 0xffff;
LAB_2300f8f2:
  *(undefined2 *)((uint)evt->conhdl * 0x5c + 0x280080a2) = (short)uVar2;
  *(uint *)evt->evt = uVar2;
  return;
}



void lld_evt_slave_time_compute(ea_elt_tag *elt,uint16_t slot_offset)

{
  ushort uVar1;
  int iVar2;
  undefined2 in_register_0000202e;
  uint uVar3;
  uint uVar4;
  int iVar5;
  anon_subr_void_ea_elt_tag_ptr_for_ea_cb_cancel *paVar6;
  uint16_t uVar7;
  void *pvVar8;
  
  pvVar8 = elt->env;
  uVar3 = CONCAT22(in_register_0000202e,slot_offset) * 0x271 + (uint)*(ushort *)&elt[1].hdr.next;
  iVar5 = (uint)*(ushort *)&elt[2].ea_cb_start * 0x5c;
  uVar1 = *(ushort *)(iVar5 + 0x280080a2);
  if ((short)uVar1 < 0) {
    iVar2 = (((uint)uVar1 << 0x11) >> 0x12) * -0x271;
  }
  else {
    iVar2 = -(uint)(uVar1 >> 1);
  }
  uVar4 = (uVar3 + iVar2) - 0x21;
  elt->env = (void *)(uVar3 / 0x271 + (int)pvVar8 & 0x7ffffff);
  *(short *)&elt[1].hdr.next = (short)(uVar3 % 0x271);
  elt->timestamp = uVar4 / 0x271 + (int)pvVar8 & 0x7ffffff;
  if ((short)uVar1 < 0) {
    uVar7 = uVar1 & 0x7fff;
  }
  else {
    uVar7 = (uint16_t)(((uint)uVar1 / 0x271 + 1) * 0x10000 >> 0x10);
  }
  paVar6 = elt[1].ea_cb_cancel;
  elt->duration_min = uVar7;
  elt->duration_min = (uVar7 + *(short *)(paVar6 + 8)) * 0x271;
  uVar7 = (uint16_t)(uVar4 % 0x271);
  *(uint16_t *)(iVar5 + 0x28008090) = uVar7;
  elt->delay = uVar7;
  return;
}



void lld_evt_prevent_stop(ea_elt_tag *elt)

{
  return;
}



void lld_evt_deferred_elt_push(ea_elt_tag *elt,uint8_t type,uint8_t rx_desc_cnt)

{
  void *pvVar1;
  
  pvVar1 = ble_ke_malloc(0xc,'\0');
  *(ea_elt_tag **)((int)pvVar1 + 4) = elt;
  *(uint8_t *)((int)pvVar1 + 8) = type;
  *(uint8_t *)((int)pvVar1 + 9) = rx_desc_cnt;
  ble_co_list_push_back(0x4201a338,pvVar1);
  return;
}



void lld_evt_elt_wait_insert(ea_elt_tag *elt)

{
  void *pvVar1;
  
  pvVar1 = ble_ke_malloc(8,'\0');
  *(ea_elt_tag **)((int)pvVar1 + 4) = elt;
  ble_co_list_push_back(0x4201a330,pvVar1);
  return;
}


/*
Unable to decompile 'lld_evt_deferred_elt_pop'
Cause: Exception while decompiling 2300fa36: Decompiler process died

*/


// WARNING: Removing unreachable block (ram,0x2300fab8)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t lld_evt_get_next_free_slot(void)

{
  if (lld_evt_env.elt_prog.first != (co_list_hdr *)0x0) {
    return (int)&(lld_evt_env.elt_prog.last[2].next)->next +
           (uint)*(ushort *)((int)&lld_evt_env.elt_prog.last[4].next + 2) / 0x271 & 0x7ffffff;
  }
  do {
  } while( true );
}



lld_evt_wait_tag * lld_evt_elt_wait_get(ea_elt_tag *elt)

{
  co_list_hdr list_hdr;
  lld_evt_wait_tag *plVar1;
  
  list_hdr = (co_list_hdr)lld_evt_env.elt_wait.first;
  if (elt == (ea_elt_tag *)0x0) {
    plVar1 = (lld_evt_wait_tag *)ble_co_list_pop_front(&lld_evt_env.elt_wait);
    return plVar1;
  }
  while( true ) {
    if (list_hdr == (co_list_hdr)0x0) {
      return (lld_evt_wait_tag *)0x0;
    }
    if ((ea_elt_tag *)((co_list_hdr *)((int)list_hdr + 4))->next == elt) break;
    list_hdr = *(co_list_hdr *)list_hdr;
  }
  ble_co_list_extract(&lld_evt_env.elt_wait,(co_list_hdr *)list_hdr,'\0');
  return (lld_evt_wait_tag *)list_hdr;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void lld_evt_schedule(ea_elt_tag *elt)

{
  char cVar1;
  uint uVar2;
  ushort *puVar3;
  lld_evt_wait_tag *mem_ptr;
  uint uVar4;
  int iVar5;
  ea_elt_tag *peVar6;
  uint uVar7;
  
  if (elt == (ea_elt_tag *)0x0) {
    return;
  }
  uVar2 = elt->timestamp;
  mem_ptr = lld_evt_elt_wait_get(elt);
  if (mem_ptr != (lld_evt_wait_tag *)0x0) {
    ble_ke_free(mem_ptr);
  }
  cVar1 = *(char *)((int)&elt[2].ea_cb_stop + 3);
  if ((cVar1 == '\0') || (cVar1 == '\x05')) {
    if ((*(byte *)((int)&elt[2].ea_cb_cancel + 2) & 0x10) != 0) goto LAB_2300fb2c;
    llm_util_adv_data_update();
    if (((llm_le_env.advertising_params)->adv_ldc_flag == false) &&
       (peVar6 = (ea_elt_tag *)((int)elt[2].linked_element - elt->timestamp),
       _DAT_28008160 = SUB42(peVar6,0), (int)peVar6 * 0x10000 >> 0x10 < 1)) {
      _DAT_28008160 = 1;
    }
  }
  if (*(char *)((int)&elt[2].ea_cb_stop + 3) == '\x01') {
    if ((*(byte *)((int)&elt[2].ea_cb_cancel + 2) & 0x10) != 0) {
LAB_2300fb2c:
      lld_evt_deferred_elt_push(elt,'\x01','\0');
      return;
    }
    iVar5 = (int)((int)elt[2].linked_element - elt->timestamp) * 0x10000;
    _DAT_280081bc = (ushort)((uint)iVar5 >> 0x10);
    if (iVar5 >> 0x10 < 1) {
      _DAT_280081bc = 1;
    }
    _DAT_280081b6 = _DAT_280081bc | 0x8000;
    peVar6 = elt->linked_element;
    if (peVar6 != (ea_elt_tag *)0x0) {
      uVar4 = (uint)*(ushort *)&peVar6[2].ea_cb_stop;
      uVar7 = uVar4 - (elt->timestamp - peVar6->timestamp & 0x7ffffff) % uVar4 & 0xffff;
      if (uVar7 < 6) {
        uVar7 = uVar7 + uVar4 & 0xffff;
      }
      _DAT_280081ba = (undefined2)(((uVar7 >> 1) - 1) * 0x10000 >> 0x10);
    }
  }
  puVar3 = (ushort *)(((uVar2 & 0xf) + 0xa002000) * 4);
  *puVar3 = 0;
  if ((byte)(*(char *)((int)&elt[2].ea_cb_stop + 3) - 3U) < 2) {
    lld_util_dle_set_cs_fields(*(uint16_t *)&elt[2].ea_cb_start);
  }
  *(undefined2 *)((uint)*(ushort *)&elt[2].ea_cb_start * 0x5c + 0x280080d8) =
       *(undefined2 *)&elt[2].timestamp;
  *puVar3 = *puVar3 & 0xffcf;
  *puVar3 = *puVar3 & 0xfff0 | 2;
  puVar3[1] = *(ushort *)((int)&elt[2].ea_cb_start + 2);
  lld_pdu_tx_prog(&elt->env);
  ble_co_list_push_back(&lld_evt_env,elt);
  return;
}


/*
Unable to decompile 'lld_evt_delete_elt_push'
Cause: Exception while decompiling 2300fc74: Decompiler process died

*/

/*
Unable to decompile 'lld_evt_deffered_elt_handler'
Cause: Exception while decompiling 2300fcd6: Decompiler process died

*/


void lld_evt_channel_next(uint16_t conhdl,int16_t nb_inc)

{
  undefined2 in_register_0000202a;
  ushort *puVar1;
  ushort uVar2;
  undefined2 in_register_0000202e;
  int iVar3;
  
  puVar1 = (ushort *)(&DAT_2800809e + CONCAT22(in_register_0000202a,conhdl) * 0x5c);
  iVar3 = (int)(((int)(uint)*puVar1 >> 8 & 0x1fU) * CONCAT22(in_register_0000202e,nb_inc) +
               ((uint)*puVar1 & 0x3f)) % 0x25;
  uVar2 = (ushort)iVar3;
  if (iVar3 < 0) {
    uVar2 = uVar2 + 0x25;
  }
  *puVar1 = uVar2 | *puVar1 & 0xffc0;
  return;
}


/*
Unable to decompile 'lld_evt_init'
Cause: Exception while decompiling 2300fe2c: Decompiler process died

*/

/*
Unable to decompile 'lld_evt_init_evt'
Cause: Exception while decompiling 2300ff3e: Decompiler process died

*/

/*
Unable to decompile 'lld_evt_elt_delete'
Cause: Exception while decompiling 2300ff90: Decompiler process died

*/

/*
Unable to decompile 'lld_evt_delete_elt_handler'
Cause: Exception while decompiling 2301007e: Decompiler process died

*/


uint16_t lld_evt_drift_compute(uint16_t delay,uint8_t master_sca)

{
  undefined2 in_register_0000202a;
  undefined3 in_register_0000202d;
  
  return (uint16_t)
         (((uint)co_sca2ppm[lld_evt_env.sca] +
          (uint)co_sca2ppm[CONCAT31(in_register_0000202d,master_sca)]) *
          CONCAT22(in_register_0000202a,delay) * 0x29 >> 0x10);
}



void lld_evt_rxwin_compute(ea_elt_tag *elt)

{
  _Bool instant;
  ushort uVar1;
  uint16_t uVar2;
  undefined2 extraout_var;
  
  uVar2 = lld_evt_drift_compute
                    ((uint16_t)
                     (((uint)*(ushort *)((int)&elt[2].timestamp + 2) + 1) *
                      (uint)*(ushort *)&elt[2].ea_cb_stop * 0x10000 >> 0x10),elt[2].current_prio);
  uVar1 = *(ushort *)&elt[2].ea_cb_start;
  elt[2].hdr.next = (co_list_hdr *)CONCAT22(extraout_var,uVar2);
  instant = (_Bool)elt[2].start_latency;
  elt[1].env = (void *)(uint)*(ushort *)((uint)uVar1 * 0x5c + 0x280080a2);
  lld_evt_winsize_change((lld_evt_tag *)&elt->env,instant);
  return;
}


/*
Unable to decompile 'lld_evt_restart'
Cause: Exception while decompiling 230101ae: Decompiler process died

*/

/*
Unable to decompile 'lld_evt_elt_insert'
Cause: Exception while decompiling 23010988: Decompiler process died

*/


void lld_evt_canceled(ea_elt_tag *elt)

{
  lld_evt_wait_tag *mem_ptr;
  int iVar1;
  
  mem_ptr = lld_evt_elt_wait_get(elt);
  if (mem_ptr != (lld_evt_wait_tag *)0x0) {
    ble_ke_free(mem_ptr);
  }
  if (elt->current_prio < 0x1f) {
    elt->current_prio = elt->current_prio + 1;
  }
  iVar1 = lld_evt_restart(elt,1);
  if (iVar1 != 0) {
    lld_evt_elt_insert(elt,true);
    return;
  }
  lld_evt_deferred_elt_push(elt,'\x01','\0');
  ble_ke_event_set('\b');
  return;
}


/*
Unable to decompile 'lld_evt_schedule_next'
Cause: Exception while decompiling 23010a4e: Decompiler process died

*/


ea_elt_tag * lld_evt_scan_create(uint16_t handle,uint16_t latency)

{
  ea_elt_tag *elt;
  uint32_t uVar1;
  
  elt = ea_elt_create(0x58);
  lld_evt_init_evt((lld_evt_tag *)&elt->env);
  *(undefined *)((int)&elt[2].ea_cb_stop + 3) = 1;
  *(uint16_t *)&elt[2].ea_cb_start = handle;
  *(short *)((int)&elt[2].linked_element + 2) = latency + 1;
  *(short *)((int)&elt[2].ea_cb_start + 2) = handle * 0x5c + 0x8e;
  lld_util_priority_set(elt,'\0');
  elt->ea_cb_start = lld_evt_schedule;
  elt->ea_cb_cancel = lld_evt_canceled;
  elt->ea_cb_stop = lld_evt_prevent_stop;
  elt->duration_min = 0x9c4;
  elt->asap_settings = 0x6051;
  elt->stop_latency1 = '\0';
  *(undefined2 *)&elt->stop_latency2 = 0x200;
  uVar1 = ea_time_get_halfslot_rounded();
  elt->timestamp = uVar1;
  return elt;
}



ea_elt_tag *
lld_evt_move_to_master
          (ea_elt_tag *elt_scan,uint16_t conhdl,llc_create_con_req_ind *pdu_tx,uint8_t rx_hdl)

{
  ushort uVar1;
  uint16_t uVar2;
  uint uVar3;
  uint uVar4;
  ea_interval_tag *interval_to_add;
  uint32_t uVar5;
  undefined3 in_register_00002035;
  uint uVar6;
  uint uVar7;
  ea_elt_tag *elt;
  uint uVar8;
  
  elt = elt_scan->linked_element;
  interval_to_add = ea_interval_create();
  uVar8 = (uint)*(ushort *)&elt[2].ea_cb_stop;
  uVar4 = elt->timestamp;
  uVar1 = *(ushort *)((uint)*(ushort *)&elt_scan[2].ea_cb_start * 0x5c + 0x280080cc);
  elt_scan->linked_element = (ea_elt_tag *)0x0;
  lld_scan_stop(elt_scan);
  uVar5 = ea_time_get_halfslot_rounded();
  uVar4 = uVar4 % uVar8;
  uVar7 = (int)elt_scan->env +
          (((uint)*(ushort *)&elt_scan[1].hdr.next +
            (uint)(*(ushort *)(&DAT_280083d2 + CONCAT31(in_register_00002035,rx_hdl) * 0xe) >> 8) *
            8 + 0x48e) / 0x271 - 1) & 0x7ffffff;
  uVar3 = (uVar8 + uVar7) - (uVar7 - uVar4 & 0x7ffffff) % uVar8 & 0x7ffffff;
  uVar6 = uVar3 - uVar7 & 0x7ffffff;
  if (0x4000000 < uVar6) {
    uVar6 = -(uVar7 - uVar3 & 0x7ffffff);
  }
  if ((int)uVar6 < (int)(((uint)uVar1 << 0x11) >> 0x10)) {
    uVar3 = uVar3 + uVar8 & 0x7ffffff;
  }
  uVar6 = uVar5 - uVar3 & 0x7ffffff;
  if (0x4000000 < uVar6) {
    if ((uVar3 - uVar5 & 0x7ffffff) != 0) goto LAB_23010e16;
    uVar6 = 0;
  }
  uVar6 = (int)uVar6 / (int)uVar8 + 1;
  uVar7 = uVar6 & 0xffff;
  lld_evt_channel_next(conhdl,(int16_t)uVar7);
  *(short *)&elt[2].timestamp = (short)(uVar6 * 0x10000 >> 0x10) + *(short *)&elt[2].timestamp;
  uVar3 = uVar3 + uVar7 * uVar8 & 0x7ffffff;
LAB_23010e16:
  uVar2 = *(uint16_t *)&elt[2].ea_cb_stop;
  elt->timestamp = uVar3;
  interval_to_add->interval_used = uVar2;
  interval_to_add->bandwidth_used = elt->duration_min / 0x271;
  uVar2 = *(uint16_t *)&elt[2].ea_cb_start;
  interval_to_add->offset_used = (uint16_t)uVar4;
  interval_to_add->role_used = 0;
  interval_to_add->conhdl_used = uVar2;
  interval_to_add->linkid = *(short *)&elt[2].ea_cb_start * 0x5c + 0x8e;
  ea_interval_insert(interval_to_add);
  *(ea_interval_tag **)&elt[1].ea_cb_cancel = interval_to_add;
  lld_util_priority_set(elt,'\x02');
  *(byte *)((int)&elt[2].ea_cb_cancel + 2) = *(byte *)((int)&elt[2].ea_cb_cancel + 2) | 2;
  return elt;
}



// WARNING: Could not reconcile some variable overlaps

ea_elt_tag *
lld_evt_update_create
          (ea_elt_tag *elt_old,uint16_t ce_len,uint16_t mininterval,uint16_t maxinterval,
          uint16_t latency,uint8_t pref_period,lld_evt_update_tag *upd_par)

{
  uint8_t uVar1;
  ea_elt_tag *elt;
  undefined3 extraout_var;
  ea_elt_tag *peVar2;
  uint uVar3;
  uint16_t uVar4;
  undefined2 in_register_00002036;
  uint uVar5;
  uint uVar6;
  uint32_t uVar7;
  uint16_t uStack84;
  ea_param_output set_param;
  ea_param_input input_param;
  
  uVar5 = CONCAT22(in_register_00002036,maxinterval);
  elt = ea_elt_create(0x58);
  if (elt == (ea_elt_tag *)0x0) {
    return (ea_elt_tag *)0x0;
  }
  (*ble_memcpy_ptr)(elt,elt_old,0x2c);
  lld_evt_init_evt((lld_evt_tag *)&elt->env);
  *(short *)((int)&elt[2].linked_element + 2) = latency + 1;
  *(undefined *)((int)&elt[2].ea_cb_stop + 3) = 3;
  set_param.offset = mininterval;
  set_param._10_2_ = maxinterval;
  ea_interval_duration_req((ea_param_input *)&set_param.offset,(ea_param_output *)&uStack84);
  uVar1 = ea_offset_req((ea_param_input *)&set_param.offset,(ea_param_output *)&uStack84);
  if (CONCAT31(extraout_var,uVar1) == 0) {
    *(uint16_t *)&elt[2].ea_cb_stop = uStack84;
    lld_util_connection_param_set(elt,(ea_param_output *)&uStack84);
    peVar2 = (ea_elt_tag *)elt->timestamp;
    uVar5 = (uint)*(ushort *)((int)&elt_old[2].linked_element + 2) * 0x60000;
    uVar4 = *(short *)&elt_old[2].timestamp + (short)(uVar5 >> 0x10);
    uVar3 = 0x7ffffff;
    uVar5 = (uint)*(ushort *)&elt_old[2].ea_cb_stop * (uVar5 >> 0x10) + elt_old->timestamp &
            0x7ffffff;
    uVar6 = uVar5 - (int)peVar2 & 0x7ffffff;
    if (uVar6 < 0x4000001) goto LAB_23010fa2;
  }
  else {
    uVar4 = 0;
    uVar3 = 1;
    peVar2 = elt;
    lld_evt_delete_elt_push(elt,true,false);
    ebreak();
  }
  uVar6 = -((uint)((int)peVar2 - uVar5) & uVar3);
LAB_23010fa2:
  uVar3 = (uint)*(ushort *)&elt[2].ea_cb_stop;
  elt->timestamp =
       (uint)((int)&(peVar2->hdr).next + ((int)((uVar3 - 1) + uVar6) / (int)uVar3) * uVar3) &
       0x7ffffff;
  upd_par->win_size = '\x01';
  *(uint16_t *)&elt_old[2].linked_element = uVar4;
  uVar7 = elt->timestamp;
  upd_par->instant = uVar4;
  upd_par->win_offset = (uint16_t)((uVar7 - uVar5) * 0x20 >> 6);
  elt_old->linked_element = elt;
  *(undefined *)((int)&elt_old[2].delay + 1) = 1;
  return elt;
}



// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

ea_elt_tag *
lld_evt_move_to_slave
          (llc_create_con_req_ind *con_par,llm_pdu_con_req_rx *con_req_pdu,ea_elt_tag *elt_adv,
          uint16_t conhdl)

{
  byte master_sca;
  byte bVar1;
  byte bVar2;
  short sVar3;
  undefined2 uVar4;
  ushort uVar5;
  undefined2 uVar6;
  uint8_t uVar7;
  uint16_t delay;
  ea_elt_tag *elt;
  ea_interval_tag *interval_to_add;
  undefined2 extraout_var_01;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined *puVar8;
  undefined2 extraout_var_02;
  ushort uVar9;
  void *pvVar10;
  uint uVar11;
  ushort uStack100;
  ea_param_output set_param;
  ea_param_input input_param;
  
  elt = ea_elt_create(0x58);
  interval_to_add = ea_interval_create();
  uVar5 = _DAT_28008198;
  uVar6 = _DAT_28008196;
  uVar4 = _DAT_28008194;
  uVar11 = (uint)con_req_pdu->winoffset;
  master_sca = con_req_pdu->hop_sca;
  bVar1 = con_req_pdu->winsize;
  con_par->filter_policy = (uint8_t)((ushort)_DAT_28008154 >> 8);
  if (elt == (ea_elt_tag *)0x0) {
    lld_evt_delete_elt_push(elt_adv,true,false);
  }
  else {
    lld_evt_init_evt((lld_evt_tag *)&elt->env);
    lld_evt_delete_elt_push(elt_adv,true,false);
    *(uint16_t *)&elt[2].ea_cb_start = conhdl;
    master_sca = master_sca >> 5;
    *(uint16_t *)&elt[2].ea_cb_stop = con_par->con_int << 1;
    delay = con_par->con_lat;
    elt[2].current_prio = master_sca;
    elt[2].start_latency = '\0';
    *(short *)((int)&elt[2].linked_element + 2) = delay + 1;
    *(undefined *)((int)&elt[2].ea_cb_stop + 3) = 4;
    *(undefined2 *)&elt[2].asap_limit = 2;
    bVar2 = elt_adv->start_latency;
    elt->duration_min = 0x4e2;
    elt->start_latency = bVar2;
    if (uVar11 << 1 <= (uint)bVar2) {
      uVar9 = con_par->con_int;
      lld_evt_channel_next(conhdl,1);
      uVar11 = uVar11 + uVar9 & 0xffff;
      *(undefined2 *)&elt[2].timestamp = 1;
    }
    delay = (uint16_t)((uVar11 * 2 + (uint)bVar1 + 2) * 0x10000 >> 0x10);
    delay = lld_evt_drift_compute(delay,master_sca);
    elt[2].hdr.next = (co_list_hdr *)CONCAT22(extraout_var_01,delay);
    pvVar10 = (void *)CONCAT22(uVar6,uVar4);
    elt[1].env = (void *)((uint)bVar1 * 0x4e2 + -0x21);
    lld_evt_winsize_change((lld_evt_tag *)&elt->env,true);
    uVar9 = 0x3a8 - (uVar5 & 0x3ff);
    if (0x270 < uVar9) {
      uVar9 = 0x137 - (uVar5 & 0x3ff);
      pvVar10 = (void *)((int)pvVar10 + 1);
    }
    sVar3 = *(short *)&elt[2].ea_cb_start;
    *(ushort *)&elt[1].hdr.next = uVar9;
    elt->env = pvVar10;
    elt->asap_settings = 0x6000;
    *(short *)((int)&elt[2].ea_cb_start + 2) = sVar3 * 0x5c + 0x8e;
    elt->ea_cb_start = lld_evt_schedule;
    elt->ea_cb_cancel = lld_evt_canceled;
    elt->ea_cb_stop = lld_evt_prevent_stop;
    lld_util_priority_set(elt,'\x02');
    set_param.offset = *(uint16_t *)&elt[2].ea_cb_stop;
    *(byte *)((int)&elt[2].ea_cb_cancel + 2) = *(byte *)((int)&elt[2].ea_cb_cancel + 2) | 2;
    uStack100 = 0;
    set_param._0_4_ = 0;
    set_param.duration._0_2_ = 0;
    set_param._10_2_ = set_param.offset;
    ea_interval_duration_req((ea_param_input *)&set_param.offset,(ea_param_output *)&uStack100);
    uVar7 = ea_offset_req((ea_param_input *)&set_param.offset,(ea_param_output *)&uStack100);
    if (CONCAT31(extraout_var,uVar7) != 0) {
      uVar7 = ea_offset_req((ea_param_input *)&set_param.offset,(ea_param_output *)&uStack100);
      if (CONCAT31(extraout_var_00,uVar7) == 0) {
        puVar8 = (undefined *)ble_ke_msg_alloc(0x109,conhdl << 8 | 1,2,0x22);
        *puVar8 = 1;
        uVar5 = uStack100 >> 1;
        *(ushort *)(puVar8 + 2) = uVar5;
        *(ushort *)(puVar8 + 4) = uVar5;
        *(ushort *)(puVar8 + 0xe) = uVar5;
        *(ushort *)(puVar8 + 0x10) = uVar5;
        sVar3 = *(short *)((int)&elt[2].linked_element + 2);
        puVar8[0x12] = 0;
        *(short *)(puVar8 + 6) = sVar3 + -1;
        *(undefined2 *)(puVar8 + 8) = 3000;
        uVar4 = *(undefined2 *)&elt[2].timestamp;
        *(undefined2 *)(puVar8 + 0x14) = uVar4;
        *(undefined2 *)(puVar8 + 10) = uVar4;
        *(undefined2 *)(puVar8 + 0xc) = *(undefined2 *)&elt[2].timestamp;
        delay = lld_util_get_peer_offset((uint16_t)set_param.duration,uStack100,elt->timestamp);
        *(short *)(puVar8 + 0x16) = (short)(CONCAT22(extraout_var_02,delay) >> 1);
        *(undefined2 *)(puVar8 + 0x18) = 0xffff;
        *(undefined2 *)(puVar8 + 0x1a) = 0xffff;
        *(undefined2 *)(puVar8 + 0x1c) = 0xffff;
        *(undefined2 *)(puVar8 + 0x1e) = 0xffff;
        *(undefined2 *)(puVar8 + 0x20) = 0xffff;
        ble_ke_msg_send(puVar8);
      }
    }
    interval_to_add->offset_used = (uint16_t)(elt->timestamp % (uint)*(ushort *)&elt[2].ea_cb_stop);
    interval_to_add->interval_used = *(uint16_t *)&elt[2].ea_cb_stop;
    interval_to_add->bandwidth_used = 2;
    interval_to_add->conhdl_used = *(uint16_t *)&elt[2].ea_cb_start;
    interval_to_add->role_used = 1;
    interval_to_add->linkid = *(short *)&elt[2].ea_cb_start * 0x5c + 0x8e;
    ea_interval_insert(interval_to_add);
    *(ea_interval_tag **)&elt[1].ea_cb_cancel = interval_to_add;
    lld_evt_slave_time_compute(elt,delay);
    *(byte *)((int)&elt[2].ea_cb_cancel + 2) = *(byte *)((int)&elt[2].ea_cb_cancel + 2) | 1;
  }
  return elt;
}



void lld_evt_slave_update(llcp_con_upd_ind *param_pdu,ea_elt_tag *elt_old)

{
  uint8_t master_sca;
  byte bVar1;
  short sVar2;
  uint16_t uVar3;
  ea_elt_tag *peVar4;
  undefined2 extraout_var;
  llc_env_tag *plVar5;
  
  if (*(uint16_t *)&elt_old[2].timestamp == param_pdu->instant) {
    plVar5 = llc_env[*(ushort *)&elt_old[2].ea_cb_start];
    if ((((uint)*(ushort *)&elt_old[2].ea_cb_stop != (uint)param_pdu->interv << 1) ||
        ((uint)*(ushort *)((int)&elt_old[2].linked_element + 2) != (uint)param_pdu->latency + 1)) ||
       (plVar5->sup_to != plVar5->n_sup_to)) {
      plVar5->llc_status = plVar5->llc_status | 0x80;
    }
    *(uint16_t *)&elt_old[2].ea_cb_stop = param_pdu->interv << 1;
    *(short *)((int)&elt_old[2].linked_element + 2) = param_pdu->latency + 1;
    *(uint16_t *)&elt_old[2].linked_element = param_pdu->instant;
    *(undefined *)((int)&elt_old[2].delay + 1) = 1;
    *(byte *)((int)&elt_old[2].ea_cb_cancel + 2) = *(byte *)((int)&elt_old[2].ea_cb_cancel + 2) | 9;
    return;
  }
  peVar4 = ea_elt_create(0x58);
  if (peVar4 != (ea_elt_tag *)0x0) {
    (*ble_memcpy_ptr)(peVar4,elt_old,0x2c);
    lld_evt_init_evt((lld_evt_tag *)&peVar4->env);
    *(undefined2 *)&peVar4[2].ea_cb_start = *(undefined2 *)&elt_old[2].ea_cb_start;
    *(uint16_t *)&peVar4[2].ea_cb_stop = param_pdu->interv << 1;
    *(short *)((int)&peVar4[2].linked_element + 2) = param_pdu->latency + 1;
    *(undefined *)((int)&peVar4[2].ea_cb_stop + 3) = 4;
    master_sca = elt_old[2].current_prio;
    peVar4[2].current_prio = master_sca;
    *(undefined2 *)&peVar4[2].asap_limit = *(undefined2 *)&elt_old[2].asap_limit;
    *(byte *)((int)&peVar4[2].ea_cb_cancel + 2) = *(byte *)((int)&peVar4[2].ea_cb_cancel + 2) | 1;
    peVar4->duration_min = 0xffff;
    uVar3 = lld_evt_drift_compute
                      ((uint16_t)
                       ((((uint)param_pdu->win_off + (uint)param_pdu->win_size) * 2 +
                        (uint)*(ushort *)&elt_old[2].ea_cb_stop) * 0x10000 >> 0x10),master_sca);
    peVar4[2].hdr.next = (co_list_hdr *)CONCAT22(extraout_var,uVar3);
    peVar4[1].env = (void *)((uint)param_pdu->win_size * 0x4e2 + -0x21);
    elt_old->linked_element = peVar4;
    bVar1 = *(byte *)((int)&elt_old[2].ea_cb_cancel + 2);
    sVar2 = *(short *)&elt_old[2].timestamp;
    *(uint16_t *)&elt_old[2].linked_element = param_pdu->instant;
    *(undefined *)((int)&elt_old[2].delay + 1) = 1;
    *(uint16_t *)((int)&elt_old[2].asap_limit + 2) = param_pdu->win_off;
    *(uint8_t *)&elt_old[2].delay = param_pdu->win_size;
    *(byte *)((int)&elt_old[2].ea_cb_cancel + 2) = bVar1 | 1;
    if (sVar2 == (uint16_t)(param_pdu->instant - 1)) {
      *(byte *)((int)&elt_old[2].ea_cb_cancel + 2) = bVar1 | 9;
    }
  }
  return;
}



ea_elt_tag *
lld_evt_adv_create(uint16_t handle,uint16_t mininterval,uint16_t maxinterval,_Bool restart_pol)

{
  ea_elt_tag *elt;
  uint32_t uVar1;
  undefined3 in_register_00002035;
  
  elt = ea_elt_create(0x58);
  lld_evt_init_evt((lld_evt_tag *)&elt->env);
  elt->duration_min = 0x9c4;
  *(uint16_t *)&elt[2].ea_cb_start = handle;
  *(undefined2 *)((int)&elt[2].ea_cb_stop + 2) = 0;
  *(uint16_t *)&elt[2].ea_cb_stop = maxinterval;
  *(short *)((int)&elt[2].ea_cb_start + 2) = handle * 0x5c + 0x8e;
  lld_util_priority_set(elt,'\x05');
  *(undefined2 *)&elt->stop_latency2 = 0x200;
  elt->ea_cb_start = lld_evt_schedule;
  elt->ea_cb_cancel = lld_evt_canceled;
  elt->ea_cb_stop = lld_evt_prevent_stop;
  elt->stop_latency1 = '\0';
  elt->asap_settings = 0x6000;
  if (CONCAT31(in_register_00002035,restart_pol) == 0) {
    *(byte *)((int)&elt[2].ea_cb_cancel + 2) = *(byte *)((int)&elt[2].ea_cb_cancel + 2) | 0x20;
  }
  uVar1 = ea_time_get_halfslot_rounded();
  elt->timestamp = uVar1;
  return elt;
}



void lld_evt_end(ea_elt_tag *elt)

{
  byte bVar1;
  ushort uVar2;
  byte bVar3;
  bool bVar4;
  char "lld_evt_end" [12];
  uint uVar5;
  uint32_t uVar6;
  uint8_t rx_desc_cnt;
  char cVar7;
  bool bVar8;
  char cVar9;
  int iVar10;
  ea_elt_tag *peVar11;
  
  iVar10 = (uint)*(ushort *)&elt[2].ea_cb_start * 0x5c;
  uVar2 = *(ushort *)(iVar10 + 0x280080e2);
  uVar5 = (uint)(*(ushort *)(iVar10 + 0x280080e4) >> 8) +
          (uint)(*(ushort *)(iVar10 + 0x280080e2) >> 8) & 0xff;
  if (((*(ushort *)(iVar10 + 0x280080e6) >> 7 & 1) != 0) && (uVar5 == 0)) {
    bVar4 = true;
LAB_23011628:
    bVar8 = false;
    goto LAB_230116d0;
  }
  bVar1 = *(byte *)((int)&elt[2].ea_cb_cancel + 2);
  if ((bVar1 & 0x10) == 0) {
    if ((bVar1 & 0x40) == 0) {
      elt->current_prio = *(uint8_t *)((int)&elt[2].ea_cb_cancel + 1);
      if (uVar5 == 0) goto LAB_230115ea;
      goto LAB_230115a2;
    }
    *(byte *)((int)&elt[2].ea_cb_cancel + 2) = bVar1 & 0xbf;
    cVar7 = *(char *)((int)&elt[2].ea_cb_stop + 3);
    cVar9 = '\x01';
    if (uVar5 == 0) {
LAB_230115ea:
      cVar9 = *(char *)((int)&elt[2].ea_cb_stop + 3);
      if (cVar9 != '\0') {
        cVar7 = '\x01';
        goto LAB_230115f2;
      }
      if ((llm_le_env.advertising_params)->adv_ldc_flag != false) goto LAB_230115a2;
    }
    else {
LAB_230115f2:
      if (cVar9 != cVar7) goto LAB_230115a2;
    }
    uVar6 = lld_evt_get_next_free_slot();
    elt->asap_settings = 0xa051;
    peVar11 = elt[2].linked_element;
    elt->timestamp = uVar6;
    *(ea_elt_tag **)&elt->asap_limit = peVar11;
    iVar10 = ea_elt_insert(elt);
    if (iVar10 != 0) goto LAB_230115a2;
    lld_evt_elt_wait_insert(elt);
    bVar4 = false;
    bVar8 = false;
    if (uVar5 == 0) goto LAB_23011628;
  }
  else {
LAB_230115a2:
    bVar8 = true;
  }
  bVar4 = bVar8;
  bVar1 = *(byte *)((int)&elt[2].ea_cb_stop + 2);
  if (uVar5 < bVar1) {
    printf("%s:rx_desc_cnt is less than evt->rx_cnt,assert!!!\r\n","lld_evt_end");
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  bVar3 = (byte)uVar5;
  lld_pdu_rx_handler((lld_evt_tag *)&elt->env,bVar3 - bVar1);
  if (*(char *)((int)&elt[2].ea_cb_stop + 3) == '\x02') {
    lld_evt_deferred_elt_push(elt,'\x02',bVar3 & 1);
  }
  else {
    bVar1 = *(byte *)((int)&elt[2].ea_cb_stop + 2);
    if (uVar5 < bVar1) {
      rx_desc_cnt = '\0';
    }
    else {
      rx_desc_cnt = bVar3 - bVar1;
    }
    lld_evt_deferred_elt_push(elt,'\x01',rx_desc_cnt);
    elt[2].stop_latency1 =
         (byte)(*(ushort *)
                 (&DAT_280083d2 +
                 ((int)((uint)em_buf_env.rx_current + (uVar5 - 1)) % 8 & 0xffU) * 0xe) >> 4) & 1;
  }
  if (((*(char *)((int)&elt[2].ea_cb_stop + 3) == '\x01') && (*(char *)&elt[2].timestamp != '\0'))
     && ((uVar2 & 0xff) != 0)) {
    *(undefined *)((int)&elt[2].timestamp + 1) = 1;
  }
  *(undefined *)((int)&elt[2].ea_cb_stop + 2) = 0;
  ble_ke_event_set('\b');
  bVar8 = true;
LAB_230116d0:
  bVar1 = *(byte *)((int)&elt[2].ea_cb_cancel + 2);
  if (((bVar1 & 0x30) == 0) && (bVar4)) {
    iVar10 = lld_evt_restart(elt,0);
    if (iVar10 != 0) {
      lld_evt_elt_insert(elt,false);
      return;
    }
  }
  else {
    if (((bVar1 & 0x10) != 0) && (!bVar8)) {
      lld_evt_delete_elt_push(elt,true,true);
      return;
    }
  }
  return;
}



void lld_evt_rx(ea_elt_tag *elt)

{
  byte rx_desc_cnt;
  
  rx_desc_cnt = (byte)((ushort)*(undefined2 *)
                                ((uint)*(ushort *)&elt[2].ea_cb_start * 0x5c + 0x28008092) >> 8);
  lld_pdu_rx_handler((lld_evt_tag *)&elt->env,rx_desc_cnt >> 4);
  rx_desc_cnt = rx_desc_cnt >> 4;
  *(char *)((int)&elt[2].ea_cb_stop + 2) = *(char *)((int)&elt[2].ea_cb_stop + 2) + rx_desc_cnt;
  lld_evt_deferred_elt_push(elt,'\0',rx_desc_cnt);
  ble_ke_event_set('\b');
  return;
}



void lld_evt_rx_afs(ea_elt_tag *elt,uint8_t num)

{
  byte bVar1;
  undefined3 in_register_0000202d;
  
  bVar1 = *(byte *)((int)&elt[2].ea_cb_stop + 2);
  if ((uint)bVar1 < CONCAT31(in_register_0000202d,num)) {
    lld_pdu_rx_handler((lld_evt_tag *)&elt->env,num - bVar1);
    *(uint8_t *)((int)&elt[2].ea_cb_stop + 2) = num;
    lld_evt_deferred_elt_push(elt,'\0','\0');
    ble_ke_event_set('\b');
    return;
  }
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void lld_evt_timer_isr(void)

{
  ble_ke_event_set('\x03');
  return;
}



void lld_evt_end_isr(_Bool apfm)

{
  undefined3 in_register_00002029;
  ea_elt_tag *elt;
  
  elt = (ea_elt_tag *)ble_co_list_pop_front((co_list *)&lld_evt_env);
  ea_elt_remove();
  if (CONCAT31(in_register_00002029,apfm) == 0) {
    if (elt->asap_settings >> 0xe != 0) {
      elt->asap_settings = 0;
    }
  }
  else {
    *(byte *)((int)&elt[2].ea_cb_cancel + 2) = *(byte *)((int)&elt[2].ea_cb_cancel + 2) | 0x40;
  }
  lld_evt_end(elt);
  return;
}



void lld_evt_rx_isr(void)

{
  if (lld_evt_env.elt_prog.first != (co_list_hdr *)0x0) {
    lld_evt_rx((ea_elt_tag *)lld_evt_env.elt_prog.first);
    return;
  }
  return;
}



void lld_evt_afs_isr(uint8_t num)

{
  if (lld_evt_env.elt_prog.first != (co_list_hdr *)0x0) {
    lld_evt_rx_afs((ea_elt_tag *)lld_evt_env.elt_prog.first,num);
    return;
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

void lld_pdu_llcp_con_param_req_unpk(uint16_t pdu_ptr,uint8_t parlen,uint8_t *param)

{
  undefined2 in_register_0000202a;
  int iVar1;
  undefined2 auStack34 [2];
  uint16_t res;
  
  iVar1 = CONCAT22(in_register_0000202a,pdu_ptr);
  (*ble_memcpy_ptr)(auStack34,&DAT_28008000 + iVar1,2);
  *(undefined2 *)(param + 2) = auStack34[0];
  (*ble_memcpy_ptr)(auStack34,&DAT_28008000 + (iVar1 + 2U & 0xffff),2);
  *(undefined2 *)(param + 4) = auStack34[0];
  (*ble_memcpy_ptr)(auStack34,&DAT_28008000 + (iVar1 + 4U & 0xffff),2);
  *(undefined2 *)(param + 6) = auStack34[0];
  (*ble_memcpy_ptr)(auStack34,&DAT_28008000 + (iVar1 + 6U & 0xffff),2);
  *(undefined2 *)(param + 8) = auStack34[0];
  (*ble_memcpy_ptr)(auStack34,&DAT_28008000 + (iVar1 + 8U & 0xffff),1);
  param[10] = (uint8_t)auStack34[0];
  (*ble_memcpy_ptr)(auStack34,&DAT_28008000 + (iVar1 + 9U & 0xffff),2);
  *(undefined2 *)(param + 0xc) = auStack34[0];
  (*ble_memcpy_ptr)(auStack34,&DAT_28008000 + (iVar1 + 0xbU & 0xffff),2);
  *(undefined2 *)(param + 0xe) = auStack34[0];
  (*ble_memcpy_ptr)(auStack34,&DAT_28008000 + (iVar1 + 0xdU & 0xffff),2);
  *(undefined2 *)(param + 0x10) = auStack34[0];
  (*ble_memcpy_ptr)(auStack34,&DAT_28008000 + (iVar1 + 0xfU & 0xffff),2);
  *(undefined2 *)(param + 0x12) = auStack34[0];
  (*ble_memcpy_ptr)(auStack34,&DAT_28008000 + (iVar1 + 0x11U & 0xffff),2);
  *(undefined2 *)(param + 0x14) = auStack34[0];
  (*ble_memcpy_ptr)(auStack34,&DAT_28008000 + (iVar1 + 0x13U & 0xffff),2);
  *(undefined2 *)(param + 0x16) = auStack34[0];
  (*ble_memcpy_ptr)(auStack34,&DAT_28008000 + (iVar1 + 0x15U & 0xffff),2);
  *(undefined2 *)(param + 0x18) = auStack34[0];
  return;
}



// WARNING: Could not reconcile some variable overlaps

void lld_pdu_llcp_con_param_rsp_unpk(uint16_t pdu_ptr,uint8_t parlen,uint8_t *param)

{
  undefined2 in_register_0000202a;
  int iVar1;
  undefined2 auStack34 [2];
  uint16_t res;
  
  iVar1 = CONCAT22(in_register_0000202a,pdu_ptr);
  (*ble_memcpy_ptr)(auStack34,&DAT_28008000 + iVar1,2);
  *(undefined2 *)(param + 2) = auStack34[0];
  (*ble_memcpy_ptr)(auStack34,&DAT_28008000 + (iVar1 + 2U & 0xffff),2);
  *(undefined2 *)(param + 4) = auStack34[0];
  (*ble_memcpy_ptr)(auStack34,&DAT_28008000 + (iVar1 + 4U & 0xffff),2);
  *(undefined2 *)(param + 6) = auStack34[0];
  (*ble_memcpy_ptr)(auStack34,&DAT_28008000 + (iVar1 + 6U & 0xffff),2);
  *(undefined2 *)(param + 8) = auStack34[0];
  (*ble_memcpy_ptr)(auStack34,&DAT_28008000 + (iVar1 + 8U & 0xffff),1);
  param[10] = (uint8_t)auStack34[0];
  (*ble_memcpy_ptr)(auStack34,&DAT_28008000 + (iVar1 + 9U & 0xffff),2);
  *(undefined2 *)(param + 0xc) = auStack34[0];
  (*ble_memcpy_ptr)(auStack34,&DAT_28008000 + (iVar1 + 0xbU & 0xffff),2);
  *(undefined2 *)(param + 0xe) = auStack34[0];
  (*ble_memcpy_ptr)(auStack34,&DAT_28008000 + (iVar1 + 0xdU & 0xffff),2);
  *(undefined2 *)(param + 0x10) = auStack34[0];
  (*ble_memcpy_ptr)(auStack34,&DAT_28008000 + (iVar1 + 0xfU & 0xffff),2);
  *(undefined2 *)(param + 0x12) = auStack34[0];
  (*ble_memcpy_ptr)(auStack34,&DAT_28008000 + (iVar1 + 0x11U & 0xffff),2);
  *(undefined2 *)(param + 0x14) = auStack34[0];
  (*ble_memcpy_ptr)(auStack34,&DAT_28008000 + (iVar1 + 0x13U & 0xffff),2);
  *(undefined2 *)(param + 0x16) = auStack34[0];
  (*ble_memcpy_ptr)(auStack34,&DAT_28008000 + (iVar1 + 0x15U & 0xffff),2);
  *(undefined2 *)(param + 0x18) = auStack34[0];
  return;
}



void lld_pdu_llcp_length_req_unpk(uint16_t pdu_ptr,uint8_t parlen,uint8_t *param)

{
  undefined2 in_register_0000202a;
  int iVar1;
  undefined2 auStack34 [2];
  uint16_t res;
  
  iVar1 = CONCAT22(in_register_0000202a,pdu_ptr);
  (*ble_memcpy_ptr)(auStack34,&DAT_28008000 + iVar1,2);
  *(undefined2 *)(param + 2) = auStack34[0];
  (*ble_memcpy_ptr)(auStack34,&DAT_28008000 + (iVar1 + 2U & 0xffff),2);
  *(undefined2 *)(param + 4) = auStack34[0];
  (*ble_memcpy_ptr)(auStack34,&DAT_28008000 + (iVar1 + 4U & 0xffff),2);
  *(undefined2 *)(param + 6) = auStack34[0];
  (*ble_memcpy_ptr)(auStack34,&DAT_28008000 + (iVar1 + 6U & 0xffff),2);
  *(undefined2 *)(param + 8) = auStack34[0];
  return;
}



void lld_pdu_llcp_length_rsp_unpk(uint16_t pdu_ptr,uint8_t parlen,uint8_t *param)

{
  undefined2 in_register_0000202a;
  int iVar1;
  undefined2 auStack34 [2];
  uint16_t res;
  
  iVar1 = CONCAT22(in_register_0000202a,pdu_ptr);
  (*ble_memcpy_ptr)(auStack34,&DAT_28008000 + iVar1,2);
  *(undefined2 *)(param + 2) = auStack34[0];
  (*ble_memcpy_ptr)(auStack34,&DAT_28008000 + (iVar1 + 2U & 0xffff),2);
  *(undefined2 *)(param + 4) = auStack34[0];
  (*ble_memcpy_ptr)(auStack34,&DAT_28008000 + (iVar1 + 4U & 0xffff),2);
  *(undefined2 *)(param + 6) = auStack34[0];
  (*ble_memcpy_ptr)(auStack34,&DAT_28008000 + (iVar1 + 6U & 0xffff),2);
  *(undefined2 *)(param + 8) = auStack34[0];
  return;
}



uint8_t lld_pdu_pack(uint8_t *p_data,uint8_t *p_length,char *format)

{
  byte bVar1;
  undefined2 uVar2;
  uint8_t *puVar3;
  uint8_t *puVar4;
  uint uVar5;
  uint uVar6;
  undefined2 *puVar7;
  undefined4 *puVar8;
  undefined4 uVar9;
  undefined4 *puVar10;
  
  puVar3 = p_data;
  puVar8 = (undefined4 *)p_data;
  while( true ) {
    while( true ) {
      while( true ) {
        puVar10 = puVar8;
        puVar4 = puVar3;
        if (*format == 0) {
          *p_length = (char)puVar4 - (char)p_data;
          return '\0';
        }
        uVar6 = (uint)(byte)*format - 0x30;
        uVar5 = 0;
        if ((uVar6 & 0xff) < 10) {
          while( true ) {
            uVar5 = uVar6 & 0xffff;
            format = (char *)((byte *)format + 1);
            if (9 < ((uint)(byte)*format - 0x30 & 0xff)) break;
            uVar6 = uVar5 * 10 + -0x30 + (uint)(byte)*format;
          }
        }
        bVar1 = *format;
        format = (char *)((byte *)format + 1);
        if (bVar1 != 0x48) break;
        puVar7 = (undefined2 *)((uint)((int)puVar10 + 1) & 0xfffffffe);
        uVar2 = *puVar7;
        *puVar4 = (uint8_t)uVar2;
        puVar4[1] = (uint8_t)((ushort)uVar2 >> 8);
        puVar3 = puVar4 + 2;
        puVar8 = (undefined4 *)(puVar7 + 1);
      }
      if (bVar1 != 0x4c) break;
      puVar8 = (undefined4 *)((uint)((int)puVar10 + 3) & 0xfffffffc);
      uVar9 = *puVar8;
      *puVar4 = (uint8_t)uVar9;
      puVar4[1] = (uint8_t)((uint)uVar9 >> 8);
      puVar4[2] = (uint8_t)((uint)uVar9 >> 0x10);
      puVar4[3] = (uint8_t)((uint)uVar9 >> 0x18);
      puVar3 = puVar4 + 4;
      puVar8 = puVar8 + 1;
    }
    if (bVar1 != 0x42) break;
    *puVar4 = *(uint8_t *)puVar10;
    puVar3 = puVar4 + 1;
    puVar8 = (undefined4 *)((int)puVar10 + 1);
    if (1 < uVar5) {
      (*ble_memcpy_ptr)(puVar4 + 1,(undefined4 *)((int)puVar10 + 1),uVar5 - 1);
      puVar3 = puVar4 + uVar5;
      puVar8 = (undefined4 *)((int)puVar10 + uVar5);
    }
  }
  return '\x01';
}


/*
Unable to decompile 'lld_pdu_tx_flush_list'
Cause: Exception while decompiling 23011d9a: Decompiler process died

*/


void lld_pdu_cntl_aligned_unpk(uint16_t pdu_ptr,uint8_t parlen,uint8_t *param)

{
  undefined2 in_register_0000202a;
  undefined3 in_register_0000202d;
  
  if (CONCAT31(in_register_0000202d,parlen) != 0) {
                    // WARNING: Could not recover jumptable at 0x23011e28. Too many branches
                    // WARNING: Treating indirect jump as call
    (*ble_memcpy_ptr)(param + 1,&DAT_28008000 + CONCAT22(in_register_0000202a,pdu_ptr),
                      CONCAT31(in_register_0000202d,parlen));
    return;
  }
  return;
}


/*
Unable to decompile 'lld_pdu_check'
Cause: Exception while decompiling 23011e2c: Decompiler process died

*/

/*
Unable to decompile 'lld_pdu_tx_loop'
Cause: Exception while decompiling 23012008: Decompiler process died

*/


void lld_pdu_data_tx_push(lld_evt_tag *evt,em_desc_node *txnode,_Bool can_be_freed,_Bool encrypted)

{
  undefined3 in_register_00002031;
  undefined3 in_register_00002035;
  int iVar1;
  
  iVar1 = (uint)*(byte *)&txnode->idx * 10;
  *(undefined2 *)(&DAT_280082ca + iVar1) = 0;
  if (CONCAT31(in_register_00002035,encrypted) != 0) {
    txnode->length = txnode->length + '\x04';
  }
  *(undefined2 *)(&DAT_280082cc + iVar1) = *(undefined2 *)&txnode->llid;
  *(uint16_t *)(&DAT_280082ce + iVar1) = txnode->buffer_ptr;
  if (CONCAT31(in_register_00002031,can_be_freed) != 0) {
    *(uint16_t *)(&DAT_280082d2 + iVar1) = txnode->buffer_idx | 0x8000;
    evt->evt[0x1c] = evt->evt[0x1c] + 1;
  }
  if (((evt->tx_prog).first == (co_list_hdr *)0x0) ||
     (*(uint16_t *)(&DAT_280082ca + (uint)*(ushort *)&(evt->tx_prog).last[1].next * 10) =
           txnode->idx * 10 + 0x2ca |
           *(ushort *)(&DAT_280082ca + (uint)*(ushort *)&(evt->tx_prog).last[1].next * 10) & 0x8000,
     (evt->tx_prog).first == (co_list_hdr *)0x0)) {
    *(em_desc_node **)&(evt->tx_prog).first = txnode;
  }
  else {
    *(em_desc_node **)&((evt->tx_prog).last)->next = txnode;
  }
  *(em_desc_node **)&(evt->tx_prog).last = txnode;
  (txnode->hdr).next = (co_list_hdr *)0x0;
  return;
}


/*
Unable to decompile 'lld_pdu_data_send'
Cause: Exception while decompiling 23012106: Decompiler process died

*/

/*
Unable to decompile 'lld_pdu_tx_push'
Cause: Exception while decompiling 23012172: Decompiler process died

*/


// WARNING: Type propagation algorithm not settling

void lld_pdu_tx_prog(lld_evt_tag *param_1)

{
  uint uVar1;
  byte bVar2;
  co_list_hdr list_hdr;
  byte bVar3;
  uint8_t opcode;
  uint16_t uVar4;
  undefined2 extraout_var_00;
  em_desc_node *txnode;
  undefined3 extraout_var;
  _Bool encrypted;
  co_list_hdr *pcVar5;
  uint uVar6;
  short sVar7;
  ushort *puVar8;
  int *piVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  co_list_hdr *p_data;
  int iVar13;
  uint uVar14;
  uint uVar15;
  byte abStack65 [13];
  
  list_hdr = (co_list_hdr)(param_1->tx_llcp_pdu_rdy).first;
  uVar12 = (uint)param_1->conhdl;
  if ((list_hdr != (co_list_hdr)0x0) && (*(short *)(&DAT_280082ca + uVar12 * 10) < 0)) {
    bVar2 = llc_env[uVar12]->encryption_state;
    if ((bVar2 & 4) == 0) {
LAB_2301240a:
      ble_co_list_extract(&param_1->tx_llcp_pdu_rdy,(co_list_hdr *)list_hdr,'\0');
      p_data = ((co_list_hdr *)list_hdr)[2].next;
      if (((char *)lld_pdu_llcp_pk_desc_tab[*(byte *)&p_data->next].pack_fmt != (char *)0x0) &&
         (opcode = lld_pdu_pack((uint8_t *)p_data,abStack65,
                                (char *)lld_pdu_llcp_pk_desc_tab[*(byte *)&p_data->next].pack_fmt),
         CONCAT31(extraout_var,opcode) == 0)) {
        (*ble_memcpy_ptr)(&DAT_28008000 +
                          *(ushort *)
                           (&DAT_280082ce + (uint)*(ushort *)&((co_list_hdr *)list_hdr)[1].next * 10
                           ),p_data,(uint)abStack65[0]);
        ble_ke_free(((co_list_hdr *)list_hdr)[2].next);
        if ((llc_env[uVar12]->encryption_state & 1) != 0) {
          abStack65[0] = abStack65[0] + 4;
        }
        puVar8 = (ushort *)(&DAT_280082cc + uVar12 * 10);
        *puVar8 = (ushort)abStack65[0] << 8 | *puVar8 & 0xff;
        *puVar8 = *puVar8 & 0xfffc | 3;
        *(undefined2 *)(&DAT_280082ca + (uint)param_1->conhdl * 10) = 0;
        if ((param_1->tx_prog).first != (co_list_hdr *)0x0) {
          *(ushort *)(&DAT_280082ca + (uint)*(ushort *)&(param_1->tx_prog).last[1].next * 10) =
               *(short *)&((co_list_hdr *)list_hdr)[1].next * 10 + 0x2caU |
               *(ushort *)(&DAT_280082ca + (uint)*(ushort *)&(param_1->tx_prog).last[1].next * 10) &
               0x8000;
        }
        ble_co_list_push_back(&param_1->tx_prog,list_hdr);
        param_1->evt[0x1c] = param_1->evt[0x1c] + 1;
      }
    }
    else {
      do {
        opcode = *(uint8_t *)&((co_list_hdr *)((int)list_hdr + 0xc))->next;
        if ((bVar2 & 0x20) == 0) {
          bVar3 = llc_llcp_get_autorize(opcode);
          bVar3 = bVar3 & 1;
        }
        else {
          bVar3 = llc_llcp_get_autorize(opcode);
          bVar3 = bVar3 & 2;
        }
        if (bVar3 != 0) goto LAB_2301240a;
        list_hdr = *(co_list_hdr *)list_hdr;
      } while (list_hdr != (co_list_hdr)0x0);
    }
  }
  bVar2 = 1;
  if (param_1->conhdl < 2) {
    bVar2 = (llc_env[uVar12]->encryption_state >> 2 ^ 1) & 1;
  }
  if (((param_1->tx_acl_rdy).first != (co_list_hdr *)0x0) && (bVar2 != 0)) {
    if (param_1->conhdl < 2) {
      uVar4 = ble_co_list_size((co_list *)&em_buf_env);
      uVar11 = CONCAT22(extraout_var_00,uVar4);
      p_data = (param_1->tx_acl_rdy).first;
      if (p_data != (co_list_hdr *)0x0) {
        bVar3 = llc_env[param_1->conhdl]->encryption_state;
        pcVar5 = p_data->next;
        (param_1->tx_acl_rdy).first = pcVar5;
        if (pcVar5 == (co_list_hdr *)0x0) {
          (param_1->tx_acl_rdy).last = (co_list_hdr *)0x0;
        }
        encrypted = (_Bool)(bVar3 & 1);
        uVar1 = (uint)bVar3 & 1;
        uVar10 = 0;
        while( true ) {
          iVar13 = (int)*(short *)&p_data[2].next;
          uVar14 = (uint)*(ushort *)(param_1->evt + 0x16) & 0xff;
          if ((uint)*(ushort *)(param_1->evt + 0x14) <
              (iVar13 + 10 + ((uVar1 << 0x12) >> 0x10)) * 0x80000 >> 0x10) {
            uVar6 = (int)((uint)*(ushort *)(param_1->evt + 0x14) + uVar1 * -0x20 + -0x50) >> 3;
            if ((int)((uint)*(ushort *)(param_1->evt + 0x16) + uVar1 * -4) < (int)(uVar6 & 0xff)) {
              uVar14 = uVar14 + uVar1 * -4 & 0xff;
            }
            else {
              uVar14 = uVar6 & 0xff;
            }
          }
          if ((int)uVar14 < iVar13) {
            uVar14 = uVar14 & 0xfe;
          }
          uVar6 = (iVar13 + -1) / (int)uVar14 + 1U & 0xff;
          if (uVar11 < uVar6) {
            pcVar5 = (param_1->tx_acl_rdy).first;
            if (pcVar5 == (co_list_hdr *)0x0) {
              (param_1->tx_acl_rdy).last = p_data;
            }
            p_data->next = pcVar5;
            (param_1->tx_acl_rdy).first = p_data;
            goto LAB_23012556;
          }
          uVar4 = 0;
          uVar15 = 0;
          bVar3 = bVar2;
          while( true ) {
            txnode = (em_desc_node *)ble_co_list_pop_front((co_list *)&em_buf_env);
            if (bVar3 == 0) {
              txnode->llid = '\x01';
              uVar15 = uVar14 + uVar15 & 0xffff;
            }
            else {
              bVar3 = *(byte *)((int)&p_data[2].next + 2) & 3;
              if (bVar3 != 1) {
                bVar3 = 2;
              }
              txnode->llid = bVar3;
              uVar15 = (uint)*(ushort *)((int)&p_data[3].next[1].next + 2);
              uVar4 = *(uint16_t *)&p_data[3].next[1].next;
            }
            opcode = (uint8_t)uVar14;
            if (iVar13 <= (int)uVar14) {
              opcode = (uint8_t)iVar13;
            }
            txnode->length = opcode;
            txnode->buffer_idx = uVar4;
            txnode->buffer_ptr = (uint16_t)uVar15;
            iVar13 = (int)((iVar13 - uVar14) * 0x10000) >> 0x10;
            if (iVar13 < 1) break;
            lld_pdu_data_tx_push(param_1,txnode,false,encrypted);
            bVar3 = 0;
          }
          lld_pdu_data_tx_push(param_1,txnode,true,encrypted);
          uVar10 = uVar10 + uVar6 & 0xff;
          uVar11 = uVar11 - uVar6 & 0xffff;
          if ((param_1->tx_acl_tofree).first == (co_list_hdr *)0x0) {
            (param_1->tx_acl_tofree).first = p_data;
          }
          else {
            ((param_1->tx_acl_tofree).last)->next = p_data;
          }
          (param_1->tx_acl_tofree).last = p_data;
          p_data->next = (co_list_hdr *)0x0;
          if (10 < uVar10) goto LAB_23012556;
          p_data = (param_1->tx_acl_rdy).first;
          if (p_data == (co_list_hdr *)0x0) break;
          pcVar5 = p_data->next;
          (param_1->tx_acl_rdy).first = pcVar5;
          if (pcVar5 == (co_list_hdr *)0x0) {
            (param_1->tx_acl_rdy).last = (co_list_hdr *)0x0;
          }
        }
      }
    }
    else {
      ble_co_list_merge(&param_1->tx_prog,&param_1->tx_acl_rdy);
    }
    ble_co_list_init(&param_1->tx_acl_rdy);
  }
LAB_23012556:
  piVar9 = (int *)(param_1->tx_prog).first;
  puVar8 = (ushort *)(uVar12 * 0x5c + 0x2800808e);
  if (piVar9 == (int *)0x0) {
    *puVar8 = *puVar8 & 0x1f | 0xf000;
    sVar7 = 0;
  }
  else {
    do {
      if (-1 < *(short *)(&DAT_280082ca + (uint)*(ushort *)(piVar9 + 1) * 10)) {
        sVar7 = *(ushort *)(piVar9 + 1) * 10 + 0x2ca;
        goto LAB_23012594;
      }
      piVar9 = (int *)*piVar9;
    } while (piVar9 != (int *)0x0);
    sVar7 = 0;
LAB_23012594:
    *puVar8 = *puVar8 & 0x1f | 0xf600;
  }
  *(short *)(uVar12 * 0x5c + 0x280080a4) = sVar7;
  return;
}


/*
Unable to decompile 'lld_pdu_tx_flush'
Cause: Exception while decompiling 23012648: Decompiler process died

*/


uint8_t lld_pdu_adv_pack(uint8_t code,uint8_t *buf,uint8_t *p_len)

{
  uint8_t uVar1;
  undefined3 in_register_00002029;
  
  if ((char *)lld_pdu_adv_pk_desc_tab[CONCAT31(in_register_00002029,code)].pack_fmt != (char *)0x0)
  {
    uVar1 = lld_pdu_pack(buf,p_len,
                         (char *)lld_pdu_adv_pk_desc_tab[CONCAT31(in_register_00002029,code)].
                                 pack_fmt);
    return uVar1;
  }
  return '\x02';
}



void lld_pdu_rx_handler(lld_evt_tag *evt,uint8_t nb_rx_desc)

{
  uint8_t uVar1;
  ushort uVar2;
  ushort uVar3;
  void *pvVar4;
  byte *pbVar5;
  undefined2 *puVar6;
  ushort dest_id;
  uint uVar7;
  byte bVar8;
  int iVar9;
  llcp_pdu_unpk_func_t *plVar10;
  uint8_t hdl;
  uint uVar11;
  byte *pbVar12;
  
  uVar11 = (uint)em_buf_env.rx_current;
  do {
    nb_rx_desc = nb_rx_desc + -1;
    hdl = (uint8_t)uVar11;
    if (nb_rx_desc == -1) {
      em_buf_env.rx_current = hdl;
      return;
    }
    if ((evt->evt_flag & 0x10) == 0) {
      pvVar4 = ble_ke_malloc(0x10,'\0');
      iVar9 = uVar11 * 0xe;
      dest_id = *(ushort *)(&DAT_280083d2 + iVar9);
      *(uint8_t *)((int)pvVar4 + 4) = hdl;
      *(uint16_t *)((int)pvVar4 + 6) = evt->conhdl;
      uVar2 = *(ushort *)(iVar9 + 0x280083d0);
      *(ushort *)((int)pvVar4 + 8) = uVar2;
      uVar3 = *(ushort *)(iVar9 + 0x280083d4);
      *(undefined *)((int)pvVar4 + 5) = 0;
      *(byte *)((int)pvVar4 + 0xd) = (byte)(uVar3 >> 0xf);
      *(byte *)((int)pvVar4 + 0xb) = (byte)((uint)uVar3 >> 8) & 0x3f;
      *(undefined *)((int)pvVar4 + 0xc) = (char)uVar3;
      if (((evt->evt_flag & 1) != 0) && ((uVar2 & 0x40) == 0)) {
        evt->evt_flag = evt->evt_flag & 0xfe;
      }
      if (1 < (ushort)(*(short *)((int)pvVar4 + 6) - 2U)) {
        *(undefined *)((int)pvVar4 + 10) = (char)((uint)dest_id >> 8);
        if (((evt->evt_flag & 2) != 0) && ((*(ushort *)((int)pvVar4 + 8) & 1) == 0)) {
          evt->evt_flag = evt->evt_flag & 0xfd;
          llc_env[*(ushort *)((int)pvVar4 + 6)]->llc_status =
               llc_env[*(ushort *)((int)pvVar4 + 6)]->llc_status | 0x100;
        }
        if (((*(ushort *)((int)pvVar4 + 8) & 0x13f) == 0) && (*(char *)((int)pvVar4 + 10) != '\0'))
        {
          uVar2 = *(ushort *)((int)pvVar4 + 6);
          uVar7 = (uint)dest_id & 3;
          if ((llc_env[(uint)uVar2]->encryption_state & 2) != 0) {
            *(char *)((int)pvVar4 + 10) = *(char *)((int)pvVar4 + 10) + -4;
          }
          if ((dest_id & 3) != 0) {
            if (uVar7 < 3) {
              dest_id = uVar2 << 8 | 1;
              puVar6 = (undefined2 *)ble_ke_msg_alloc(0x100,dest_id,dest_id,8);
              *puVar6 = *(undefined2 *)((int)pvVar4 + 6);
              bVar8 = *(byte *)((int)pvVar4 + 10);
              *(char *)(puVar6 + 1) = (char)uVar7;
              puVar6[2] = (ushort)bVar8;
              *(undefined *)(puVar6 + 3) = *(undefined *)((int)pvVar4 + 4);
              ble_ke_msg_send();
              goto LAB_23012960;
            }
            if (uVar7 != 3) goto LAB_230128e6;
            uVar7 = (uint)uVar2 << 8;
            dest_id = (ushort)uVar7 | 1;
            hdl = *(uint8_t *)((int)pvVar4 + 10);
            pbVar5 = (byte *)ble_ke_msg_alloc(0x10a,dest_id,dest_id,0x1c);
            pbVar12 = pbVar5 + 2;
            dest_id = *(ushort *)(&DAT_280083d6 + (uint)*(byte *)((int)pvVar4 + 4) * 0xe);
            (*ble_memcpy_ptr)(pbVar12,&DAT_28008000 + dest_id,1);
            bVar8 = pbVar5[2];
            if (bVar8 < 0x16) {
              uVar1 = lld_pdu_llcp_pk_desc_tab[bVar8].pdu_len;
              if (uVar1 != hdl) {
                bVar8 = 0x1e;
                goto LAB_230128ce;
              }
              plVar10 = lld_pdu_llcp_pk_desc_tab[bVar8].unpack_func;
              *pbVar5 = 0;
              (*plVar10)(dest_id + 1,uVar1 + -1,pbVar12);
            }
            else {
              bVar8 = 0x19;
LAB_230128ce:
              *pbVar5 = bVar8;
            }
            llc_llcp_recv_handler(uVar7 & 0xffff | 1,(uint)*pbVar5,pbVar12,1);
            ble_ke_msg_send(pbVar5);
          }
        }
LAB_230128e6:
        em_buf_rx_free(*(uint8_t *)((int)pvVar4 + 4));
        *(undefined *)((int)pvVar4 + 5) = 1;
      }
LAB_23012960:
      ble_co_list_push_back(0x4201a340,pvVar4);
    }
    else {
      em_buf_rx_free(hdl);
    }
    uVar11 = uVar11 + 1 & 7;
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void lld_sleep_init(void)

{
  uint32_t uVar1;
  uint32_t uVar2;
  uint32_t uVar3;
  
  (*ble_memset_ptr)(&lld_sleep_env,0,0x14);
  uVar1 = rwip_us_2_lpcycles(5000);
  uVar2 = rwip_us_2_lpcycles(5000);
  uVar3 = rwip_us_2_lpcycles(0x271);
  _DAT_2800003c = uVar3 & 0xffff | uVar1 << 0x15 | (uVar2 & 0xffff) << 10;
  rwip_wakeup_delay_set(5000);
  _DAT_28000030 = _DAT_28000030 & 0x7fffffff;
  lld_sleep_env.last_sleep_dur = 0;
  lld_sleep_env._8_2_ = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void lld_sleep_wakeup(void)

{
  uint32_t uVar1;
  uint32_t lpcycles;
  
  _DAT_28000030 = _DAT_28000030 & 0x7fffffff;
  if (lld_sleep_env.pds_reset == false) {
    lpcycles = _DAT_28000038;
    uVar1 = _DAT_28000038;
    if (lld_sleep_env.sw_wakeup != false) {
      lld_sleep_env._8_2_ = 0;
      lpcycles = _DAT_28000038 - lld_sleep_env.last_sleep_dur;
      uVar1 = lld_sleep_env.last_sleep_dur;
    }
    lld_sleep_env.last_sleep_dur = uVar1;
    lpcycles = rwip_sleep_lpcycles_2_us(lpcycles);
    _DAT_28000044 = (lpcycles + lld_evt_env.hw_wa_sleep_compensation) / 0x271;
    _DAT_28000040 =
         (_DAT_28000044 * 0x271 - (lpcycles + lld_evt_env.hw_wa_sleep_compensation)) + 0x270 &
         0xffff;
    lld_evt_env.hw_wa_sleep_compensation = _DAT_28000040 == 0;
    if ((bool)lld_evt_env.hw_wa_sleep_compensation) {
      _DAT_28000044 = _DAT_28000044 + 1;
      _DAT_28000040 = 0x270;
    }
    _DAT_2800000c = 1;
    _DAT_28000018 = 1;
    _DAT_28000030 = _DAT_28000030 | 8;
    return;
  }
  _DAT_2800000c = 1;
  _DAT_28000018 = 1;
  _DAT_28000030 = _DAT_28000030 | 8;
  _DAT_28000040 = lld_sleep_env.finetimecnt;
  _DAT_28000044 = lld_sleep_env.basetimecnt;
  lld_sleep_env._8_2_ = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void lld_sleep_wakeup_end(void)

{
  _DAT_2800000c = lld_sleep_env.irq_mask;
  return;
}



uint16_t lld_util_instant_get(void *event,uint8_t action)

{
  uint16_t uVar1;
  
  *(uint8_t *)((int)event + 0x45) = action;
  uVar1 = (uint16_t)
          (((uint)*(ushort *)((int)event + 0x36) * 6 + (uint)*(ushort *)((int)event + 0x38)) *
           0x10000 >> 0x10);
  *(uint16_t *)((int)event + 0x34) = uVar1;
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void lld_util_set_bd_address(bd_addr *bd_addr,uint8_t type)

{
  undefined3 in_register_0000202d;
  
  _DAT_28000024 = *(undefined4 *)bd_addr->addr;
  _DAT_28000028 =
       (uint)*(ushort *)(bd_addr->addr + 4) | _DAT_28000028 & 0xfffe0000 |
       CONCAT31(in_register_0000202d,type) << 0x10;
  return;
}



uint8_t lld_util_freq2chnl(uint8_t freq)

{
  char cVar1;
  undefined3 in_register_00002029;
  uint uVar2;
  
  uVar2 = CONCAT31(in_register_00002029,freq);
  if (uVar2 == 0xc) {
    return '&';
  }
  if (uVar2 != 0x27) {
    if (uVar2 != 0) {
      if (uVar2 < 0xc) {
        cVar1 = -1;
      }
      else {
        cVar1 = -2;
      }
      return freq + cVar1;
    }
    freq = '%';
  }
  return freq;
}



uint16_t lld_util_get_local_offset(uint16_t PeerOffset,uint16_t Interval,uint32_t AnchorPoint)

{
  undefined2 in_register_0000202a;
  undefined2 in_register_0000202e;
  
  return (uint16_t)
         ((int)(CONCAT22(in_register_0000202a,PeerOffset) +
               AnchorPoint % CONCAT22(in_register_0000202e,Interval)) %
         CONCAT22(in_register_0000202e,Interval));
}



uint16_t lld_util_get_peer_offset(uint16_t LocalOffset,uint16_t Interval,uint32_t AnchorPoint)

{
  undefined2 in_register_0000202a;
  undefined2 in_register_0000202e;
  uint uVar1;
  
  uVar1 = CONCAT22(in_register_0000202e,Interval);
  return (uint16_t)
         ((int)((CONCAT22(in_register_0000202a,LocalOffset) + uVar1) - AnchorPoint % uVar1) % uVar1)
  ;
}



void lld_util_connection_param_set(ea_elt_tag *elt,ea_param_output *param)

{
  ushort uVar1;
  uint uVar2;
  ushort uVar3;
  
  uVar3 = param->interval;
  uVar2 = (uint)uVar3 - (uint)elt->start_latency;
  if (uVar2 < param->duration) {
    param->duration = uVar2;
  }
  if (param->duration == 0) {
    param->duration = 2;
  }
  uVar1 = param->offset;
  param->duration = param->duration * 0x271;
  uVar2 = elt->timestamp % (uint)uVar3;
  if (uVar1 < uVar2) {
    uVar3 = (uVar3 + uVar1) - (short)uVar2;
  }
  else {
    if ((uVar2 != 0) || (uVar1 != 0)) {
      uVar3 = uVar1 - (short)uVar2;
    }
  }
  param->offset = uVar3;
  return;
}



void lld_util_dle_set_cs_fields(uint16_t conhdl)

{
  undefined2 in_register_0000202a;
  int iVar1;
  
  iVar1 = CONCAT22(in_register_0000202a,conhdl) * 0x5c;
  *(ushort *)(&DAT_280080b0 + iVar1) =
       *(ushort *)(&DAT_280080b0 + iVar1) & 0xff00 |
       (ushort)*(byte *)&(llc_env[CONCAT22(in_register_0000202a,conhdl)]->data_len_ext_info).
                         conn_eff_max_rx_octets;
  *(uint16_t *)(iVar1 + 0x280080b2) =
       (llc_env[CONCAT22(in_register_0000202a,conhdl)]->data_len_ext_info).conn_eff_max_rx_time;
  return;
}



// WARNING: Could not reconcile some variable overlaps

void lld_util_anchor_point_move(ea_elt_tag *elt_connect)

{
  short sVar1;
  undefined2 uVar2;
  ushort uVar3;
  uint8_t uVar4;
  undefined3 extraout_var;
  undefined *puVar5;
  uint uVar6;
  ushort uStack52;
  ea_param_output set_param;
  ea_param_input input_param;
  
  set_param.duration._0_2_ = 0;
  uStack52 = *(ushort *)&elt_connect[2].ea_cb_stop;
  set_param._0_4_ = (int)((uint)elt_connect->duration_min + 0x270) / 0x271;
  uVar4 = ea_offset_req((ea_param_input *)&set_param.offset,(ea_param_output *)&uStack52);
  if (CONCAT31(extraout_var,uVar4) == 0) {
    puVar5 = (undefined *)
             ble_ke_msg_alloc(0x109,*(short *)&elt_connect[2].ea_cb_start << 8 | 1,2,0x22);
    *puVar5 = 1;
    uVar6 = (uint)uStack52;
    uVar3 = uStack52 >> 1;
    *(ushort *)(puVar5 + 2) = uVar3;
    *(ushort *)(puVar5 + 4) = uVar3;
    *(ushort *)(puVar5 + 0xe) = uVar3;
    *(ushort *)(puVar5 + 0x10) = uVar3;
    sVar1 = *(short *)((int)&elt_connect[2].linked_element + 2);
    puVar5[0x12] = 0;
    *(short *)(puVar5 + 6) = sVar1 + -1;
    *(undefined2 *)(puVar5 + 8) = 3000;
    uVar2 = *(undefined2 *)&elt_connect[2].timestamp;
    *(undefined2 *)(puVar5 + 0x14) = uVar2;
    *(undefined2 *)(puVar5 + 10) = uVar2;
    *(undefined2 *)(puVar5 + 0xc) = *(undefined2 *)&elt_connect[2].timestamp;
    *(short *)(puVar5 + 0x16) =
         (short)(((int)(((ushort)set_param.duration + uVar6) - elt_connect->timestamp % uVar6) %
                  uVar6 & 0xffffU) >> 1);
    *(undefined2 *)(puVar5 + 0x18) = 0xffff;
    *(undefined2 *)(puVar5 + 0x1a) = 0xffff;
    *(undefined2 *)(puVar5 + 0x1c) = 0xffff;
    *(undefined2 *)(puVar5 + 0x1e) = 0xffff;
    *(undefined2 *)(puVar5 + 0x20) = 0xffff;
    ble_ke_msg_send();
  }
  return;
}



void lld_util_flush_list(co_list *list)

{
  co_list_hdr *mem_ptr;
  
  while (mem_ptr = ble_co_list_pop_front(list), mem_ptr != (co_list_hdr *)0x0) {
    ble_ke_free(mem_ptr);
  }
  return;
}



_Bool lld_util_instant_ongoing(ea_elt_tag *elt)

{
  return (_Bool)(*(char *)((int)&elt[2].delay + 1) != '\0');
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void lld_util_compute_ce_max(ea_elt_tag *elt,uint16_t tx_time,uint16_t rx_time)

{
  undefined2 in_register_0000202e;
  int iVar1;
  uint uVar2;
  int iVar3;
  ushort *puVar4;
  uint uVar5;
  
  iVar1 = (uint)*(ushort *)&elt[2].ea_cb_start * 0x5c;
  if (*(char *)((int)&elt[2].ea_cb_stop + 3) == '\x03') {
    uVar2 = _DAT_28000000 >> 4 & 0xf;
  }
  else {
    uVar2 = (uint)*(ushort *)(iVar1 + 0x280080a2);
    if ((short)*(ushort *)(iVar1 + 0x280080a2) < 0) {
      iVar3 = ((uVar2 << 0x11) >> 0x12) * 0x271;
      goto LAB_23012da6;
    }
  }
  iVar3 = (int)uVar2 >> 1;
LAB_23012da6:
  uVar2 = CONCAT22(in_register_0000202e,tx_time) + 0x15c;
  if ((*(ushort *)(iVar1 + 0x28008092) & 0x200) != 0) {
    uVar2 = CONCAT22(in_register_0000202e,tx_time) + 0x17c;
  }
  uVar5 = ((((((uint)*(ushort *)&elt[2].ea_cb_stop - (uint)elt->start_latency) + -1) * 0x271 - iVar3
            ) / uVar2) * uVar2 - (uVar2 >> 1)) / 0x271;
  if (0x96 < (int)((uVar2 - 0x271) * uVar5)) {
    uVar5 = uVar5 - 1;
  }
  *(ushort *)(iVar1 + 0x280080a8) = (ushort)uVar5;
  puVar4 = (ushort *)((uint)*(ushort *)&elt[2].ea_cb_start * 0x5c + 0x280080a6);
  if (uVar5 < *puVar4) {
    *puVar4 = (ushort)uVar5;
  }
  return;
}



void lld_util_priority_set(ea_elt_tag *elt,uint8_t priority_index)

{
  undefined3 in_register_0000202d;
  uint8_t uVar1;
  
  switch(CONCAT31(in_register_0000202d,priority_index)) {
  case 0:
    uVar1 = '\x05';
    break;
  case 1:
    uVar1 = '\x05';
    break;
  case 2:
    uVar1 = '\x14';
    break;
  case 3:
    uVar1 = '\n';
    break;
  case 4:
    uVar1 = '\x0f';
    break;
  case 5:
    if ((llm_le_env.advertising_params)->adv_ldc_flag != false) goto switchD_23012e2e_caseD_7;
  case 6:
    uVar1 = '\n';
    break;
  default:
switchD_23012e2e_caseD_7:
    uVar1 = '\x05';
  }
  elt->current_prio = uVar1;
  *(uint8_t *)((int)&elt[2].ea_cb_cancel + 1) = uVar1;
  return;
}



uint8_t lld_util_get_tx_pkt_cnt(ea_elt_tag *elt)

{
  return elt[2].stop_latency2;
}



void lld_util_eff_tx_time_set(ea_elt_tag *elt,uint16_t max_tx_time,uint16_t max_tx_size)

{
  elt[2].asap_settings = max_tx_time;
  elt[2].duration_min = max_tx_size;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void lld_wlcoex_set(int param_1)

{
  if (param_1 == 0) {
    _DAT_28000100 = _DAT_28000100 & 0xffddff0c;
  }
  else {
    _DAT_28000100 = _DAT_28000100 | 0x2200f3;
  }
  _DAT_28000074 = _DAT_28000074 & 0xffe0ffff;
  return;
}



// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void lld_init(_Bool reset)

{
  _Bool _Var1;
  undefined3 in_register_00002029;
  undefined3 extraout_var;
  bd_addr *pbVar2;
  anon_subr_void_ptr_void_ptr_void_ptr_uint *paVar3;
  undefined2 *puVar4;
  undefined4 uStack24;
  bd_addr bd_addr;
  
  if (CONCAT31(in_register_00002029,reset) == 0) {
    ble_ke_task_create('\x02',&TASK_DESC_LLD);
  }
  _DAT_280000f0 = _DAT_280000f0 & 0xfc00fe00 | 0x1b800d2;
  _DAT_2800000c = 0x1033a;
  _DAT_28000000 = _DAT_28000000 & 0xffcfff0f | 0xe0;
  _Var1 = co_bdaddr_compare(&co_null_bdaddr,&co_default_bdaddr);
  if (CONCAT31(extraout_var,_Var1) == 0) {
    pbVar2 = &co_default_bdaddr;
    paVar3 = ble_memcpy_ptr;
  }
  else {
    pbVar2 = (bd_addr *)0x7;
    paVar3 = (anon_subr_void_ptr_void_ptr_void_ptr_uint *)ble_memset_ptr;
  }
  (*paVar3)(&uStack24,pbVar2,6);
  ecc_gen_new_secret_key(llm_le_env.secret_key256,false);
  _DAT_28000024 = uStack24;
  _DAT_28000028 = (uint)bd_addr.addr._0_2_;
  _DAT_28000000 = _DAT_28000000 | 0x200;
  _DAT_28000090 = 7;
  _DAT_280000b0 = 0x1fe;
  _DAT_280000b4 = 0x216;
  _DAT_280000b8 = 0x404;
  _DAT_28000120 = 0x22e;
  _DAT_28000124 = 3;
  puVar4 = (undefined2 *)&DAT_28008000;
  _DAT_2800814c = 0xbed6;
  _DAT_2800814e = 0x8e89;
  _DAT_28008150 = 0x5555;
  _DAT_28008152 = 0x55;
  _DAT_28008162 = 0;
  _DAT_28008164 = 0;
  _DAT_28008166 = 0;
  _DAT_280081a8 = 0xbed6;
  _DAT_280081aa = 0x8e89;
  _DAT_280081ac = 0x5555;
  _DAT_280081ae = 0x55;
  _DAT_280081be = 0;
  _DAT_280081c0 = 0;
  _DAT_280081c2 = 0;
  _DAT_28008168 = 0;
  _DAT_2800816a = 0;
  _DAT_280081c4 = 0;
  _DAT_280081c6 = 0;
  _DAT_2800002c = 0x3ce;
  _DAT_28008158 = (ushort)rwip_rf.txpwr_max;
  _DAT_2800814a = _DAT_2800814a & 0xfff | 0x2000;
  _DAT_2800819e = _DAT_2800819e & 0xff7f;
  _DAT_28008154 = 0;
  _DAT_280081b4 = (ushort)rwip_rf.txpwr_max;
  _DAT_280081a6 = _DAT_280081a6 & 0xfff | 0x2000;
  _DAT_280081fa = _DAT_280081fa & 0xff7f;
  _DAT_280081b0 = 0;
  _DAT_28008194 = 0;
  _DAT_28008196 = 0;
  _DAT_28008198 = 0;
  _DAT_2800819a = 0;
  _DAT_2800819c = 0;
  _DAT_280081f0 = 0;
  _DAT_280081f2 = 0;
  _DAT_280081f4 = 0;
  _DAT_280081f6 = 0;
  _DAT_280081f8 = 0;
  do {
    *puVar4 = 0;
    puVar4[1] = 0;
    puVar4 = puVar4 + 2;
  } while (puVar4 != (undefined2 *)0x28008040);
  lld_evt_init(CONCAT31(in_register_00002029,reset));
  lld_sleep_init();
  _DAT_28008146 = _DAT_28008146 & 0xf8ff;
  _DAT_280081a2 = _DAT_280081a2 & 0xf8ff;
  lld_wlcoex_set(1);
  _DAT_28000000 = _DAT_28000000 | 0x100;
  _DAT_280000e0 = _DAT_280000e0 & 0xffffefff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void lld_core_reset(void)

{
  undefined2 *puVar1;
  
  do {
  } while ((int)(_DAT_28000000 & 0xfffffeff | 0x80000000) < 0);
  _DAT_28000000 = _DAT_28000000 & 0xbffffeff | 0xc0000000;
  do {
  } while ((int)(_DAT_28000000 << 1) < 0);
  puVar1 = (undefined2 *)&DAT_28008000;
  do {
    *puVar1 = 0;
    puVar1[1] = 0;
    puVar1 = puVar1 + 2;
  } while (puVar1 != (undefined2 *)0x28008040);
  _DAT_28008146 = _DAT_28008146 & 0xf8ff;
  _DAT_280081a2 = _DAT_280081a2 & 0xf8ff;
  lld_wlcoex_set(1);
  _DAT_2800000c = 0;
  _DAT_28000018 = 0xffffffff;
  return;
}


/*
Unable to decompile 'lld_adv_start'
Cause: Exception while decompiling 23013272: Decompiler process died

*/


// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void lld_adv_stop(ea_elt_tag *elt)

{
  _Bool _Var1;
  undefined3 extraout_var;
  
  _Var1 = lld_evt_elt_delete(elt,true,true);
  if (CONCAT31(extraout_var,_Var1) == 0) {
    *(byte *)((int)&elt[2].ea_cb_cancel + 2) = *(byte *)((int)&elt[2].ea_cb_cancel + 2) | 0x10;
    _DAT_28000000 = _DAT_28000000 | 0x2000000;
  }
  return;
}


/*
Unable to decompile 'lld_scan_start'
Cause: Exception while decompiling 23013462: Decompiler process died

*/


// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void lld_scan_stop(ea_elt_tag *elt)

{
  _Bool _Var1;
  undefined3 extraout_var;
  
  _Var1 = lld_evt_elt_delete(elt,true,true);
  if (CONCAT31(extraout_var,_Var1) == 0) {
    *(byte *)((int)&elt[2].ea_cb_cancel + 2) = *(byte *)((int)&elt[2].ea_cb_cancel + 2) | 0x10;
    _DAT_28000000 = _DAT_28000000 | 0x1000000;
  }
  return;
}


/*
Unable to decompile 'lld_con_start'
Cause: Exception while decompiling 2301360e: Decompiler process died

*/


ea_elt_tag *
lld_move_to_master(ea_elt_tag *elt,uint16_t conhdl,llc_create_con_req_ind *param,uint8_t rx_hdl)

{
  int iVar1;
  ea_elt_tag *elt_00;
  undefined2 in_register_0000202e;
  undefined3 in_register_00002035;
  ushort *puVar2;
  
  elt_00 = lld_evt_move_to_master(elt,conhdl,param,rx_hdl);
  iVar1 = CONCAT22(in_register_0000202e,conhdl) * 0x5c;
  *(ushort *)(&DAT_2800809e + iVar1) =
       (ushort)(((uint)(*(ushort *)(&DAT_280083d2 + CONCAT31(in_register_00002035,rx_hdl) * 0xe) >>
                       5) & 1) << 0xe) | *(ushort *)(&DAT_2800809e + iVar1) & 0xbfff;
  lld_util_eff_tx_time_set(elt_00,0x148,0x1b);
  lld_util_compute_ce_max(elt_00,0x148,0x148);
  *(undefined2 *)(iVar1 + 0x280080a6) = *(undefined2 *)(iVar1 + 0x280080a8);
  *(ushort *)(&DAT_280082ca + CONCAT22(in_register_0000202e,conhdl) * 10) =
       (ushort)(((uint)*(ushort *)(&DAT_280082ca + CONCAT22(in_register_0000202e,conhdl) * 10) <<
                0x11) >> 0x11) | 0x8000;
  puVar2 = (ushort *)(iVar1 + 0x28008092);
  *puVar2 = *puVar2 & 0xfeff;
  *puVar2 = *puVar2 & 0xfdff;
  *puVar2 = *puVar2 & 0xfbff;
  *(undefined2 *)(iVar1 + 0x2800809c) = 0;
  *(undefined2 *)(iVar1 + 0x280080cc) = 0;
  *(undefined2 *)(iVar1 + 0x280080ce) = 0;
  *(undefined2 *)(iVar1 + 0x280080d0) = 0;
  *(undefined2 *)(iVar1 + 0x280080d2) = 0;
  *(undefined2 *)(iVar1 + 0x280080d4) = 0;
  *(undefined2 *)(iVar1 + 0x280080d6) = 0;
  *(undefined2 *)(iVar1 + 0x280080d8) = 0;
  *(undefined2 *)(iVar1 + 0x280080a4) = 0;
  *puVar2 = *puVar2 & 0xf7ff;
  lld_evt_elt_insert(elt_00,true);
  return elt_00;
}



// WARNING: Could not reconcile some variable overlaps

void lld_con_update_req(ea_elt_tag *elt_old,llc_con_upd_req_ind *param,llcp_con_upd_ind *param_pdu)

{
  ea_elt_tag *peVar1;
  uint16_t ce_len;
  uint16_t uStack24;
  uint16_t uStack22;
  lld_evt_update_tag upd_par;
  
  _ce_len = (uint)param->ce_len_min + 1 & 0xfffffffe;
  ce_len = (uint16_t)_ce_len;
  if (_ce_len < 2) {
    ce_len = 2;
  }
  peVar1 = lld_evt_update_create
                     (elt_old,ce_len,(uint16_t)(((uint)param->interval_min << 0x11) >> 0x10),
                      (uint16_t)(((uint)param->interval_max << 0x11) >> 0x10),param->con_latency,
                      param->pref_period,(lld_evt_update_tag *)&uStack24);
  param_pdu->timeout = param->superv_to;
  param_pdu->interv = *(ushort *)&peVar1[2].ea_cb_stop >> 1;
  param_pdu->latency = param->con_latency;
  param_pdu->win_size = (uint8_t)upd_par.win_offset;
  param_pdu->win_off = uStack24;
  param_pdu->instant = uStack22;
  return;
}



// WARNING: Could not reconcile some variable overlaps

uint8_t lld_con_update_after_param_req
                  (uint16_t conhdl,ea_elt_tag *elt_old,llc_con_upd_req_ind *param,
                  llcp_con_upd_ind *param_pdu,_Bool bypass_offchk)

{
  ushort uVar1;
  int iVar2;
  uint8_t uVar3;
  uint16_t uVar4;
  undefined2 in_register_0000202a;
  ea_elt_tag *elt;
  undefined2 extraout_var_01;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  uint uVar5;
  undefined3 in_register_00002039;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  llc_env_tag *plVar10;
  uint16_t uVar11;
  uint uVar12;
  uint uVar13;
  uint16_t local_54;
  ea_param_output set_param;
  ea_param_input input_param;
  
  set_param.offset = param->interval_min << 1;
  set_param._10_2_ = param->interval_max << 1;
  uVar4 = param->offset0;
  ea_interval_duration_req((ea_param_input *)&set_param.offset,(ea_param_output *)&local_54);
  if (param->offset0 != 0xffff) {
    uVar6 = (uint)*(ushort *)&elt_old[2].timestamp;
    uVar8 = (uint)param->ref_con_event_count;
    if (uVar8 < uVar6) {
      iVar2 = -((uVar6 - uVar8) * (uint)*(ushort *)&elt_old[2].ea_cb_stop);
    }
    else {
      iVar2 = (uVar8 - uVar6) * (uint)*(ushort *)&elt_old[2].ea_cb_stop;
    }
    lld_util_get_local_offset
              ((uint16_t)(((uint)param->offset0 << 0x11) >> 0x10),local_54,
               elt_old->timestamp + iVar2);
  }
  if (((uVar4 == 0xffff) ||
      (uVar3 = ea_offset_req((ea_param_input *)&set_param.offset,(ea_param_output *)&local_54),
      CONCAT31(extraout_var,uVar3) == 0)) ||
     (uVar3 = ea_offset_req((ea_param_input *)&set_param.offset,(ea_param_output *)&local_54),
     CONCAT31(extraout_var_00,uVar3) == 0)) {
    uVar3 = '\0';
  }
  else {
    uVar3 = '\x1f';
    if (CONCAT31(in_register_00002039,bypass_offchk) == 0) {
      return '\x1f';
    }
  }
  elt = ea_elt_create(0x58);
  if (elt != (ea_elt_tag *)0x0) {
    (*ble_memcpy_ptr)(elt,elt_old,0x2c);
    lld_evt_init_evt((lld_evt_tag *)&elt->env);
    *(short *)((int)&elt[2].linked_element + 2) = param->con_latency + 1;
    *(undefined *)((int)&elt[2].ea_cb_stop + 3) = 3;
    *(uint16_t *)&elt[2].ea_cb_stop = local_54;
    uVar6 = (uint)param->offset0;
    if (param->offset0 == 0xffff) {
      uVar4 = lld_util_get_peer_offset((uint16_t)set_param.duration,local_54,elt_old->timestamp);
      uVar1 = *(ushort *)&elt_old[2].timestamp;
      uVar6 = CONCAT22(extraout_var_01,uVar4) >> 1 & 0xffff;
    }
    else {
      uVar1 = param->ref_con_event_count;
    }
    uVar9 = (uint)uVar1;
    uVar8 = (uint)*(ushort *)&elt_old[2].ea_cb_stop;
    uVar7 = (uint)*(ushort *)((int)&elt_old[2].linked_element + 2) * 0x70000 >> 0x10;
    uVar12 = ((uint)*(ushort *)&elt_old[2].timestamp - 1) + uVar7;
    uVar13 = uVar12 & 0xffff;
    uVar5 = (uint)*(ushort *)&elt[2].ea_cb_stop;
    if (uVar13 < uVar9) {
      iVar2 = (uVar9 - uVar13) * uVar8 + uVar6 * 2;
    }
    else {
      iVar2 = uVar5 - (int)((uVar13 - uVar9) * uVar8 + uVar6 * -2) % uVar5;
    }
    uVar6 = iVar2 % uVar5 & 0xffff;
    elt->timestamp = uVar6 + ((uVar7 - 1) * uVar8 + elt_old->timestamp & 0x7ffffff) & 0x7ffffff;
    elt_old->linked_element = elt;
    plVar10 = llc_env[CONCAT22(in_register_0000202a,conhdl)];
    uVar11 = (uint16_t)(uVar12 * 0x10000 >> 0x10);
    *(uint16_t *)&elt_old[2].linked_element = uVar11;
    *(undefined *)((int)&elt_old[2].delay + 1) = 1;
    lld_util_compute_ce_max
              (elt,(plVar10->data_len_ext_info).conn_eff_max_tx_time,
               (plVar10->data_len_ext_info).conn_eff_max_rx_time);
    iVar2 = (uint)*(ushort *)&elt_old[2].ea_cb_start * 0x5c;
    *(undefined2 *)(iVar2 + 0x280080a6) = *(undefined2 *)(iVar2 + 0x280080a8);
    param_pdu->timeout = param->superv_to;
    param_pdu->interv = *(ushort *)&elt[2].ea_cb_stop >> 1;
    uVar4 = param->con_latency;
    param_pdu->win_size = '\x01';
    param_pdu->win_off = (uint16_t)(uVar6 >> 1);
    param_pdu->latency = uVar4;
    param_pdu->instant = uVar11;
  }
  return uVar3;
}



// WARNING: Variable defined which should be unmapped: input_param
// WARNING: Could not reconcile some variable overlaps

uint8_t lld_con_param_rsp(uint16_t conhdl,ea_elt_tag *elt,llc_con_upd_req_ind *param)

{
  uint8_t uVar1;
  uint16_t uVar2;
  undefined3 extraout_var;
  undefined2 extraout_var_00;
  uint uVar3;
  uint uVar4;
  int iVar5;
  uint16_t local_34;
  ea_param_output set_param;
  ea_param_input input_param;
  
  set_param.offset = param->interval_min << 1;
  set_param._10_2_ = param->interval_max << 1;
  ea_interval_duration_req((ea_param_input *)&set_param.offset,(ea_param_output *)&local_34);
  if (param->offset0 != 0xffff) {
    uVar3 = (uint)*(ushort *)&elt[2].timestamp;
    uVar4 = (uint)param->ref_con_event_count;
    if (uVar4 < uVar3) {
      iVar5 = -((uVar3 - uVar4) * (uint)*(ushort *)&elt[2].ea_cb_stop);
    }
    else {
      iVar5 = (uVar4 - uVar3) * (uint)*(ushort *)&elt[2].ea_cb_stop;
    }
    lld_util_get_local_offset
              ((uint16_t)(((uint)param->offset0 << 0x11) >> 0x10),local_34,elt->timestamp + iVar5);
  }
  uVar1 = ea_offset_req((ea_param_input *)&set_param.offset,(ea_param_output *)&local_34);
  if (CONCAT31(extraout_var,uVar1) == 0) {
    param->pref_period = '\0';
    param->interval_min = local_34 >> 1;
    param->interval_max = local_34 >> 1;
    if (param->offset0 == 0xffff) {
      uVar2 = lld_util_get_peer_offset((uint16_t)set_param.duration,local_34,elt->timestamp);
      param->offset0 = (uint16_t)(CONCAT22(extraout_var_00,uVar2) >> 1);
      param->ref_con_event_count = *(uint16_t *)&elt[2].timestamp;
    }
    param->offset1 = 0xffff;
    param->offset2 = 0xffff;
    param->offset3 = 0xffff;
    param->offset4 = 0xffff;
    param->offset5 = 0xffff;
  }
  else {
    uVar1 = '\x1f';
  }
  return uVar1;
}



// WARNING: Could not reconcile some variable overlaps

void lld_con_param_req(uint16_t conhdl,ea_elt_tag *elt,llc_con_upd_req_ind *param)

{
  ushort Interval;
  uint8_t uVar1;
  uint16_t uVar2;
  undefined3 extraout_var;
  undefined2 extraout_var_00;
  uint uVar3;
  uint uVar4;
  ushort local_34;
  ea_param_output set_param;
  ea_param_input input_param;
  
  set_param.offset = param->con_intv_min << 1;
  set_param._10_2_ = param->con_intv_max << 1;
  ea_interval_duration_req((ea_param_input *)&set_param.offset,(ea_param_output *)&local_34);
  uVar3 = (uint)local_34;
  uVar4 = elt->timestamp;
  uVar1 = ea_offset_req((ea_param_input *)&set_param.offset,(ea_param_output *)&local_34);
  Interval = set_param._10_2_;
  if (CONCAT31(extraout_var,uVar1) == 0) {
    Interval = local_34;
  }
  param->interval_min = Interval >> 1;
  param->interval_max = Interval >> 1;
  uVar2 = lld_util_get_peer_offset((uint16_t)(uVar4 % uVar3),Interval,elt->timestamp);
  param->offset0 = (uint16_t)(CONCAT22(extraout_var_00,uVar2) >> 1);
  param->pref_period = '\0';
  param->ref_con_event_count = *(short *)&elt[2].timestamp + 2;
  param->offset1 = 0xffff;
  param->offset2 = 0xffff;
  param->offset3 = 0xffff;
  param->offset4 = 0xffff;
  param->offset5 = 0xffff;
  return;
}



void lld_con_stop(ea_elt_tag *elt)

{
  lld_evt_delete_elt_push(elt,true,true);
  return;
}



uint8_t lld_get_mode(uint16_t conhdl)

{
  uint8_t uVar1;
  undefined2 in_register_0000202a;
  int iVar2;
  ea_elt_tag *peVar3;
  
  iVar2 = CONCAT22(in_register_0000202a,conhdl);
  peVar3 = llm_le_env.elt;
  if ((iVar2 != 2) && (peVar3 = llm_le_env.elt_coext_scan, iVar2 != 3)) {
    if (llc_env[iVar2] == (llc_env_tag *)0x0) {
      return '\b';
    }
    peVar3 = llc_env[iVar2]->elt;
  }
  uVar1 = '\b';
  if (peVar3 != (ea_elt_tag *)0x0) {
    uVar1 = *(uint8_t *)((int)&peVar3[2].ea_cb_stop + 3);
  }
  return uVar1;
}



ea_elt_tag *
lld_move_to_slave(llc_create_con_req_ind *con_par,llm_pdu_con_req_rx *con_req_pdu,
                 ea_elt_tag *elt_adv,uint16_t conhdl,uint8_t rx_hdl)

{
  int iVar1;
  uint8_t uVar2;
  ea_elt_tag *elt;
  undefined2 in_register_00002036;
  undefined3 in_register_00002039;
  ushort *puVar3;
  
  iVar1 = CONCAT22(in_register_00002036,conhdl) * 0x5c;
  *(undefined2 *)(iVar1 + 0x2800808e) = 3;
  puVar3 = (ushort *)(iVar1 + 0x28008092);
  *(ushort *)(&DAT_280082ca + CONCAT22(in_register_00002036,conhdl) * 10) =
       *(ushort *)(&DAT_280082ca + CONCAT22(in_register_00002036,conhdl) * 10) & 0x7fff | 0x8000;
  *(ushort *)(&DAT_2800809e + iVar1) =
       (ushort)(((uint)(*(ushort *)(&DAT_280083d2 + CONCAT31(in_register_00002039,rx_hdl) * 0xe) >>
                       5) & 1) << 0xe) | ((ushort)con_req_pdu->hop_sca & 0x1f) << 8 | 0x8000;
  *(undefined2 *)(iVar1 + 0x28008094) = *(undefined2 *)(con_req_pdu->aa).addr;
  *(undefined2 *)(iVar1 + 0x28008096) = *(undefined2 *)((con_req_pdu->aa).addr + 2);
  *(undefined2 *)(iVar1 + 0x28008098) = *(undefined2 *)(con_req_pdu->crcinit).crc;
  *(ushort *)(iVar1 + 0x2800809a) = (ushort)(con_req_pdu->crcinit).crc[2];
  *(ushort *)(iVar1 + 0x280080a0) = (ushort)rwip_rf.txpwr_max;
  *puVar3 = (ushort)(((uint)*puVar3 << 0x14) >> 0x14) | 0x2000;
  *puVar3 = *puVar3 & 0xffe0 | conhdl & 0x1f;
  *(undefined2 *)(iVar1 + 0x280080aa) = *(undefined2 *)(con_req_pdu->chm).map;
  *(undefined2 *)(iVar1 + 0x280080ac) = *(undefined2 *)((con_req_pdu->chm).map + 2);
  uVar2 = llm_util_check_map_validity((uint8_t *)&con_req_pdu->chm,'\x05');
  *(undefined2 *)(iVar1 + 0x280080ae) = CONCAT11(uVar2,(con_req_pdu->chm).map[4]);
  *puVar3 = *puVar3 & 0xfeff;
  *puVar3 = *puVar3 & 0xfdff;
  *puVar3 = *puVar3 & 0xfbff;
  *(undefined2 *)(iVar1 + 0x2800809c) = 0;
  *(ushort *)(iVar1 + 0x280080e6) = *(ushort *)(iVar1 + 0x280080e6) & 0xff7f;
  *(undefined2 *)(iVar1 + 0x280080dc) = 0;
  *(undefined2 *)(iVar1 + 0x280080de) = 0;
  *(undefined2 *)(iVar1 + 0x280080e0) = 0;
  *(undefined2 *)(iVar1 + 0x280080e2) = 0;
  *(undefined2 *)(iVar1 + 0x280080e4) = 0;
  elt = lld_evt_move_to_slave(con_par,con_req_pdu,elt_adv,conhdl);
  lld_util_eff_tx_time_set(elt,0x148,0x1b);
  lld_util_compute_ce_max(elt,0x148,0x148);
  *(undefined2 *)(iVar1 + 0x280080a6) = *(undefined2 *)(iVar1 + 0x280080a8);
  *(undefined2 *)(&DAT_280080b0 + iVar1) = 0;
  *(undefined2 *)(iVar1 + 0x280080b2) = 0;
  *(undefined2 *)(iVar1 + 0x280080cc) = 0;
  *(undefined2 *)(iVar1 + 0x280080ce) = 0;
  *(undefined2 *)(iVar1 + 0x280080d0) = 0;
  *(undefined2 *)(iVar1 + 0x280080d2) = 0;
  *(undefined2 *)(iVar1 + 0x280080d4) = 0;
  *(undefined2 *)(iVar1 + 0x280080d6) = 0;
  *(undefined2 *)(iVar1 + 0x280080d8) = 0;
  *(undefined2 *)(iVar1 + 0x280080a4) = 0;
  *puVar3 = *puVar3 & 0xf7ff;
  lld_evt_elt_insert(elt,true);
  return elt;
}



void lld_ch_map_ind(ea_elt_tag *elt,uint16_t instant)

{
  byte bVar1;
  ushort uVar2;
  undefined2 in_register_0000202e;
  
  *(undefined *)((int)&elt[2].delay + 1) = 2;
  bVar1 = *(byte *)((int)&elt[2].ea_cb_cancel + 2);
  uVar2 = *(ushort *)&elt[2].timestamp;
  *(uint16_t *)&elt[2].linked_element = instant;
  *(byte *)((int)&elt[2].ea_cb_cancel + 2) = bVar1 | 1;
  if ((uint)uVar2 == (CONCAT22(in_register_0000202e,instant) - 1 & 0xffff)) {
    *(byte *)((int)&elt[2].ea_cb_cancel + 2) = bVar1 | 9;
    return;
  }
  if ((uint)uVar2 == CONCAT22(in_register_0000202e,instant)) {
    llc_map_update_ind(*(uint16_t *)&elt[2].ea_cb_start);
    *(byte *)((int)&elt[2].ea_cb_cancel + 2) = *(byte *)((int)&elt[2].ea_cb_cancel + 2) | 8;
    return;
  }
  return;
}



void lld_con_update_ind(ea_elt_tag *elt_old,llcp_con_upd_ind *param_pdu)

{
  lld_evt_slave_update(param_pdu,elt_old);
  return;
}



void lld_crypt_isr(void)

{
  ble_ke_event_set('\x01');
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

ea_elt_tag * lld_test_mode_tx(em_desc_node *txdesc,uint8_t tx_freq,uint8_t tx_phy)

{
  short sVar1;
  uint8_t uVar2;
  ea_elt_tag *elt;
  undefined3 extraout_var;
  undefined3 in_register_00002031;
  int iVar3;
  
  iVar3 = CONCAT31(in_register_00002031,tx_phy);
  sVar1 = (short)iVar3;
  elt = lld_evt_adv_create(2,0,1,false);
  *(undefined *)((int)&elt[2].ea_cb_stop + 3) = 2;
  _DAT_280000e0 = _DAT_280000e0 & 0xfffff7ff | 0x800;
  _DAT_28008184 = 0;
  _DAT_28008186 = 0;
  _DAT_28008188 = 0;
  _DAT_28008146 = 0x1c;
  _DAT_2800814c = 0x4129;
  _DAT_2800814e = 0x7176;
  _DAT_28008158 = _DAT_28008158 & 0xff00 | 0xf;
  _DAT_28008148 = 0;
  _DAT_2800819e = _DAT_2800819e & 0xff7f;
  _DAT_2800814a = _DAT_2800814a & 0xffe0 | 2;
  _DAT_28008194 = 0;
  _DAT_28008196 = 0;
  _DAT_28008198 = 0;
  _DAT_2800819a = 0;
  _DAT_2800819c = 0;
  uVar2 = lld_util_freq2chnl(tx_freq);
  _DAT_28008156 = (ushort)CONCAT31(extraout_var,uVar2) | _DAT_28008156 & 0xffc0;
  if (iVar3 != 0) {
    if (iVar3 == 4) {
      sVar1 = 3;
      _DAT_280081a0 = _DAT_280081a0 & 0xffcf | 0x10;
    }
    else {
      if (iVar3 == 3) {
        _DAT_280081a0 = _DAT_280081a0 & 0xffcf;
      }
    }
    _DAT_280081a0 = sVar1 - 1U & 0xff | _DAT_280081a0 & 0xfffc;
  }
  lld_pdu_tx_push(elt,txdesc);
  lld_pdu_tx_loop((lld_evt_tag *)&elt->env);
  lld_evt_elt_insert(elt,true);
  return elt;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

ea_elt_tag * lld_test_mode_rx(uint8_t rx_freq)

{
  uint8_t uVar1;
  ea_elt_tag *elt;
  undefined3 extraout_var;
  
  elt = lld_evt_adv_create(2,0,1,false);
  *(undefined *)((int)&elt[2].ea_cb_stop + 3) = 2;
  _DAT_280000e0 = _DAT_280000e0 & 0xf7ffffff | 0x8000000;
  _DAT_2800818a = 0;
  _DAT_2800818c = 0;
  _DAT_2800818e = 0;
  _DAT_28008146 = 0x1d;
  _DAT_2800815a = 0x804b;
  orig_rxsyncwinszdef = (byte)_DAT_280001ac & 0x3f;
  _DAT_280001ac = _DAT_280001ac & 0xffffffc0 | 0xf;
  orig_rfrxtmda = (uint8_t)(_DAT_28000078 >> 0x1c);
  _DAT_28000078 = _DAT_28000078 & 0xfffffff | 0xf0000000;
  _DAT_40002850 = _DAT_40002850 & 0xcfffffff | 0x10000000;
  _DAT_28000000 = _DAT_28000000 & 0xffff7fff;
  _DAT_2800814c = 0x4129;
  _DAT_2800814e = 0x7176;
  _DAT_28008148 = 0;
  _DAT_28008168 = 0xff;
  _DAT_2800816a = 0;
  _DAT_2800819e = _DAT_2800819e & 0xff7f;
  _DAT_2800814a = _DAT_2800814a & 0xffe0 | 2;
  _DAT_28008194 = 0;
  _DAT_28008196 = 0;
  _DAT_28008198 = 0;
  _DAT_2800819a = 0;
  _DAT_2800819c = 0;
  uVar1 = lld_util_freq2chnl(rx_freq);
  _DAT_28008156 = (ushort)CONCAT31(extraout_var,uVar1) | _DAT_28008156 & 0xffc0;
  (*rwip_rf.force_agc_enable)(false);
  lld_evt_elt_insert(elt,true);
  return elt;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void lld_test_stop(ea_elt_tag *elt)

{
  _DAT_28000000 = _DAT_28000000 | 0x4000000;
  (*rwip_rf.force_agc_enable)(true);
  _DAT_280000e0 = 0;
  return;
}



// WARNING: Variable defined which should be unmapped: tmp_addr

uint16_t llm_util_bd_addr_wl_position(bd_addr *bd_address,uint8_t bd_addr_type)

{
  int iVar1;
  _Bool _Var2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined auStack40 [4];
  bd_addr tmp_addr;
  
  iVar1 = 0;
  if ((bd_addr_type & 1) == 0) {
    do {
      (*ble_memcpy_ptr)(auStack40,(void *)(iVar1 * 6 + 0x280081fe),6);
      _Var2 = co_bdaddr_compare((bd_addr *)auStack40,bd_address);
      if (CONCAT31(extraout_var,_Var2) != 0) {
        return (uint16_t)iVar1;
      }
      iVar1 = iVar1 + 1;
    } while (iVar1 != 4);
  }
  else {
    do {
      (*ble_memcpy_ptr)(auStack40,(void *)(iVar1 * 6 + 0x28008216),6);
      _Var2 = co_bdaddr_compare((bd_addr *)auStack40,bd_address);
      if (CONCAT31(extraout_var_00,_Var2) != 0) {
        return (uint16_t)iVar1;
      }
      iVar1 = iVar1 + 1;
    } while (iVar1 != 4);
  }
  return 4;
}



uint8_t llm_util_check_address_validity(bd_addr *bd_address,uint8_t addr_type)

{
  _Bool _Var1;
  uint8_t uVar2;
  undefined3 extraout_var;
  
  _Var1 = co_bdaddr_compare(bd_address,&co_null_bdaddr);
  if (CONCAT31(extraout_var,_Var1) == 0) {
    uVar2 = '\0';
  }
  else {
    uVar2 = '\x12';
  }
  return uVar2;
}



uint8_t llm_util_check_map_validity(uint8_t *channel_map,uint8_t nb_octet)

{
  uint uVar1;
  undefined3 in_register_0000202d;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  
  uVar4 = (uint)*channel_map & 0xf8;
  if (((*channel_map & 0xf8) != 0) && (uVar4 = 0, CONCAT31(in_register_0000202d,nb_octet) == 1)) {
    return '\0';
  }
  uVar3 = 0;
  while( true ) {
    if (CONCAT31(in_register_0000202d,nb_octet) <= (uVar3 & 0xff)) {
      return (uint8_t)uVar4;
    }
    if (((uVar3 & 0xff) == 4) && ((channel_map[uVar3] & 0xe0) != 0)) break;
    uVar2 = 0;
    do {
      uVar1 = uVar2 & 0x1f;
      uVar2 = uVar2 + 1;
      uVar4 = uVar4 + ((int)(uint)channel_map[uVar3] >> uVar1 & 1U) & 0xff;
    } while (uVar2 != 8);
    uVar3 = uVar3 + 1;
  }
  return '&';
}



void llm_util_apply_bd_addr(uint8_t addr_type)

{
  undefined3 in_register_00002029;
  bd_addr *bd_addr;
  uint8_t type;
  
  if ((CONCAT31(in_register_00002029,addr_type) == 1) ||
     (CONCAT31(in_register_00002029,addr_type) == 3)) {
    type = '\x01';
    bd_addr = &llm_le_env.rand_add;
  }
  else {
    type = '\0';
    bd_addr = &llm_le_env.public_add;
  }
  lld_util_set_bd_address(bd_addr,type);
  return;
}



_Bool llm_util_check_evt_mask(uint8_t event_id)

{
  undefined3 in_register_00002029;
  uint uVar1;
  
  uVar1 = CONCAT31(in_register_00002029,event_id);
  return (_Bool)((byte)((int)(uint)llm_le_env.eventmask.mask[uVar1 >> 3] >>
                       (uVar1 - (uVar1 & 0xfffffff8) & 0x1f)) & 1);
}



// WARNING: Exceeded maximum restarts with more pending

void llm_util_get_channel_map(le_chnl_map *map)

{
                    // WARNING: Could not recover jumptable at 0x23014a18. Too many branches
                    // WARNING: Treating indirect jump as call
  (*ble_memcpy_ptr)((void *)0x4201a38a,(void *)0x5);
  return;
}



// WARNING: Exceeded maximum restarts with more pending

void llm_util_get_supp_features(le_features *feats)

{
                    // WARNING: Could not recover jumptable at 0x23014a2c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*ble_memcpy_ptr)(&llm_local_le_feats,(void *)0x8);
  return;
}



void llm_util_adv_data_update(void)

{
  if ((llm_le_env.advertising_params)->adv_data_req != (ke_msg *)0x0) {
    llm_set_adv_data((hci_le_set_adv_data_cmd *)(llm_le_env.advertising_params)->adv_data_req->param
                    );
    ble_ke_msg_free((llm_le_env.advertising_params)->adv_data_req);
    (llm_le_env.advertising_params)->adv_data_req = (ke_msg *)0x0;
  }
  if ((llm_le_env.advertising_params)->scan_rsp_req != (ke_msg *)0x0) {
    llm_set_scan_rsp_data
              ((hci_le_set_scan_rsp_data_cmd *)(llm_le_env.advertising_params)->scan_rsp_req->param)
    ;
    ble_ke_msg_free((llm_le_env.advertising_params)->scan_rsp_req);
    (llm_le_env.advertising_params)->scan_rsp_req = (ke_msg *)0x0;
  }
  return;
}



uint8_t llm_util_bl_check(bd_addr *bd_addr_to_add,uint8_t bd_addr_type,uint16_t *conhdl,
                         uint8_t wl_flag_action,_Bool *in_wl)

{
  co_list_hdr cVar1;
  _Bool _Var2;
  undefined3 extraout_var;
  undefined3 in_register_00002035;
  int iVar3;
  
  iVar3 = CONCAT31(in_register_00002035,wl_flag_action);
  cVar1 = (co_list_hdr)llm_le_env.cnx_list.first;
  do {
    if (cVar1 == (co_list_hdr)0x0) {
      return '\0';
    }
    if ((bd_addr_to_add == (bd_addr *)0x0) && (iVar3 == 1)) {
      *(undefined *)((int)cVar1 + 0xd) = 0;
    }
    else {
      _Var2 = co_bdaddr_compare(bd_addr_to_add,(bd_addr *)((int)cVar1 + 4));
      if ((CONCAT31(extraout_var,_Var2) != 0) &&
         (*(byte *)&((co_list_hdr *)((int)cVar1 + 0xc))->next == (bd_addr_type & 1))) {
        if (conhdl != (uint16_t *)0x0) {
          *conhdl = *(uint16_t *)((int)cVar1 + 10);
        }
        if (iVar3 == 1) {
          *(undefined *)((int)cVar1 + 0xd) = 0;
        }
        else {
          if (iVar3 == 2) {
            *(undefined *)((int)cVar1 + 0xd) = 1;
          }
        }
        if (in_wl == (_Bool *)0x0) {
          return '\v';
        }
        *in_wl = *(_Bool *)((int)cVar1 + 0xd);
        return '\v';
      }
    }
    cVar1 = *(co_list_hdr *)cVar1;
  } while( true );
}



// WARNING: Variable defined which should be unmapped: found

_Bool llm_util_bd_addr_in_wl(bd_addr *bd_address,uint8_t bd_addr_type,_Bool *in_black_list)

{
  uint8_t uVar1;
  uint16_t uVar2;
  undefined3 extraout_var;
  undefined2 extraout_var_00;
  _Bool a_Stack17 [4];
  _Bool found;
  
  a_Stack17[0] = false;
  if (in_black_list != (_Bool *)0x0) {
    *in_black_list = false;
  }
  uVar1 = llm_util_bl_check(bd_address,bd_addr_type,(uint16_t *)0x0,'\0',a_Stack17);
  if ((CONCAT31(extraout_var,uVar1) == 0xb) && (in_black_list != (_Bool *)0x0)) {
    *in_black_list = true;
  }
  if ((a_Stack17[0] == false) &&
     (uVar2 = llm_util_bd_addr_wl_position(bd_address,bd_addr_type),
     CONCAT22(extraout_var_00,uVar2) < 4)) {
    a_Stack17[0] = true;
  }
  return a_Stack17[0];
}



uint8_t llm_util_bl_add(bd_addr *bd_addr_to_add,uint8_t bd_addr_type,uint16_t conhdl)

{
  uint8_t uVar1;
  uint16_t uVar2;
  void *pvVar3;
  undefined2 extraout_var;
  
  pvVar3 = ble_ke_malloc(0x10,'\0');
  uVar1 = '\a';
  if (pvVar3 != (void *)0x0) {
    (*ble_memcpy_ptr)((bd_addr *)((int)pvVar3 + 4),bd_addr_to_add,6);
    *(uint16_t *)((int)pvVar3 + 10) = conhdl;
    *(byte *)((int)pvVar3 + 0xc) = bd_addr_type & 1;
    uVar2 = llm_util_bd_addr_wl_position(bd_addr_to_add,bd_addr_type);
    *(bool *)((int)pvVar3 + 0xd) = CONCAT22(extraout_var,uVar2) < 4;
    ble_co_list_push_back(0x4201a370,pvVar3);
    uVar1 = '\0';
    if (*(char *)((int)pvVar3 + 0xd) != '\0') {
      llm_wl_dev_rem((bd_addr *)((int)pvVar3 + 4),bd_addr_type & 1);
    }
  }
  return uVar1;
}



uint8_t llm_util_bl_rem(uint16_t conhdl)

{
  co_list_hdr list_hdr;
  undefined2 in_register_0000202a;
  
  list_hdr = (co_list_hdr)llm_le_env.cnx_list.first;
  while( true ) {
    if (list_hdr == (co_list_hdr)0x0) {
      return '\x02';
    }
    if ((uint)*(ushort *)((int)list_hdr + 10) == CONCAT22(in_register_0000202a,conhdl)) break;
    list_hdr = *(co_list_hdr *)list_hdr;
  }
  ble_co_list_extract(&llm_le_env.cnx_list,(co_list_hdr *)list_hdr,'\0');
  if (*(char *)((int)list_hdr + 0xd) != '\0') {
    llm_wl_dev_add((bd_addr *)((int)list_hdr + 4),
                   *(uint8_t *)&((co_list_hdr *)((int)list_hdr + 0xc))->next);
  }
  ble_ke_free((void *)list_hdr);
  return '\0';
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void llm_end_evt_defer(void)

{
  byte bVar1;
  undefined *param;
  undefined2 uVar2;
  undefined auStack36 [4];
  llc_create_con_req_ind msg_param;
  
  bVar1 = ble_ke_state_get(0);
  if ((bVar1 & 0xf0) == 0x10) {
    if (((llm_le_env.advertising_params)->type == '\x01') &&
       ((llm_le_env.advertising_params)->adv_ldc_flag == false)) {
      (*ble_memcpy_ptr)(&msg_param.sup_to,&(llm_le_env.advertising_params)->peer_addr,6);
      msg_param.peer_addr.addr[2] = (llm_le_env.advertising_params)->peer_addr_type;
      llc_le_con_cmp_evt_send('<',0,(llc_create_con_req_ind *)auStack36);
      lld_evt_delete_elt_push(llm_le_env.elt,true,false);
      bVar1 = ble_ke_state_get(0);
      ble_ke_state_set(0,bVar1 & 0xf);
    }
  }
  if ((llm_le_env.test_mode.directtesttype != '\x03') && (llm_le_env.test_mode.end_of_tst != false))
  {
    param = (undefined *)ble_ke_msg_alloc(0x801,0,0x201f,4);
    llm_le_env.test_mode.end_of_tst = false;
    if (llm_le_env.test_mode.directtesttype == '\x01') {
      _DAT_280001ac = _DAT_280001ac & 0xffffffc0 | (uint)orig_rxsyncwinszdef;
      _DAT_28000078 = (uint)orig_rfrxtmda << 0x1c | _DAT_28000078 & 0xfffffff;
      _DAT_40002850 = _DAT_40002850 & 0xcfffffff | 0x20000000;
    }
    _DAT_28000000 = _DAT_28000000 & 0xfffb7fff | 0x8000;
    uVar2 = 0;
    if (llm_le_env.test_mode.directtesttype != '\0') {
      uVar2 = _DAT_2800818a;
    }
    *(undefined2 *)(param + 2) = uVar2;
    llm_le_env.test_mode.directtesttype = '\x03';
    *param = 0;
    hci_send_2_host(param);
    ble_ke_msg_send_basic(1,0,0);
  }
  return;
}



_Bool llm_pdu_defer(uint16_t status,uint8_t rx_hdl,uint8_t tx_cnt)

{
  undefined uVar1;
  byte bVar2;
  undefined3 extraout_var;
  undefined3 in_register_0000202d;
  undefined3 in_register_00002031;
  uint uVar3;
  
  bVar2 = ble_ke_state_get(0);
  _bVar2 = CONCAT31(extraout_var,bVar2);
  if ((bVar2 & 0xf) == 2) {
    if ((status & 3) == 0) {
      uVar1 = 0;
      if (CONCAT31(in_register_00002031,tx_cnt) != 0) {
        llm_con_req_tx_cfm(rx_hdl);
        uVar1 = 1;
      }
      goto LAB_23014dac;
    }
    if (_bVar2 == 0x23) {
      uVar1 = 0;
      goto LAB_23014dac;
    }
  }
  else {
    uVar1 = 0;
    if ((_bVar2 == 0x23) || (_bVar2 == 0)) goto LAB_23014dac;
  }
  uVar1 = 0;
  if (((_bVar2 != 0x24) && ((status & 0x1f) == 0)) &&
     (((uint)*(ushort *)(&DAT_280083d2 + CONCAT31(in_register_0000202d,rx_hdl) * 0xe) & 0xf) < 7)) {
    uVar3 = 1 << ((uint)*(ushort *)(&DAT_280083d2 + CONCAT31(in_register_0000202d,rx_hdl) * 0xe) &
                 0xf);
    if ((uVar3 & 0x57) == 0) {
      if (((uVar3 & 0x20) != 0) && ((bVar2 & 0xf0) == 0x10)) {
        llm_con_req_ind(rx_hdl,status);
      }
    }
    else {
      if ((bVar2 & 0xf) == 1) {
        llm_le_adv_report_ind(rx_hdl);
      }
    }
  }
LAB_23014dac:
  em_buf_rx_free(rx_hdl);
  return (_Bool)uVar1;
}



void llm_wlpub_addr_set(uint16_t elem_index,bd_addr *bdaddr)

{
  undefined2 *puVar1;
  undefined2 in_register_0000202a;
  undefined2 *puVar2;
  bd_addr *pbVar3;
  
  pbVar3 = bdaddr + 1;
  puVar2 = (undefined2 *)(CONCAT22(in_register_0000202a,elem_index) * 6 + 0x280081fe);
  do {
    puVar1 = (undefined2 *)bdaddr->addr;
    bdaddr = (bd_addr *)(bdaddr->addr + 2);
    *puVar2 = *puVar1;
    puVar2 = puVar2 + 1;
  } while (pbVar3 != bdaddr);
  return;
}



void llm_wlpriv_addr_set(uint16_t elem_index,bd_addr *bdaddr)

{
  undefined2 *puVar1;
  undefined2 in_register_0000202a;
  undefined2 *puVar2;
  bd_addr *pbVar3;
  
  pbVar3 = bdaddr + 1;
  puVar2 = (undefined2 *)(CONCAT22(in_register_0000202a,elem_index) * 6 + 0x28008216);
  do {
    puVar1 = (undefined2 *)bdaddr->addr;
    bdaddr = (bd_addr *)(bdaddr->addr + 2);
    *puVar2 = *puVar1;
    puVar2 = puVar2 + 1;
  } while (pbVar3 != bdaddr);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void llm_con_req_ind(uint8_t rx_hdl,uint16_t status)

{
  ushort uVar1;
  int iVar2;
  uint8_t uVar3;
  byte bVar4;
  undefined3 in_register_00002029;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  uint16_t local_5a;
  ushort uStack88;
  uint16_t conhdl;
  llc_create_con_req_ind param;
  llm_pdu_con_req_rx data;
  
  iVar2 = CONCAT31(in_register_00002029,rx_hdl) * 0xe;
  (*ble_memcpy_ptr)(&param.sleep_clk_acc,&DAT_28008000 + *(ushort *)(&DAT_280083d6 + iVar2),0x22);
  if (0xc76 < ((uint)data.interval - 10 & 0xffff)) {
    return;
  }
  if (0xc7a < ((uint)data._18_2_ - 6 & 0xffff)) {
    return;
  }
  if (499 < data.winoffset) {
    return;
  }
  if ((uint)data.interval << 2 <= ((uint)data.winoffset + 1) * (uint)data._18_2_) {
    return;
  }
  uVar3 = llc_util_get_free_conhdl(&local_5a);
  if (CONCAT31(extraout_var,uVar3) != 0) {
    return;
  }
  if ((status & 0x200) == 0) {
    uVar1 = *(ushort *)(iVar2 + 0x280083d8);
    if (uVar1 != 0) {
      (*ble_memcpy_ptr)(&param.sleep_clk_acc,&DAT_28008000 + ((uint)uVar1 + 0x18 & 0xffff),6);
      param.peer_addr.addr[2] =
           (byte)*(undefined2 *)(&DAT_2800822e + (((uint)uVar1 - 0x22e) / 0x34 & 0xff) * 0x34) & 2 |
           (byte)*(undefined2 *)(&DAT_2800822e + (((uint)uVar1 - 0x22e) / 0x34 & 0xff) * 0x34) & 1;
      goto LAB_23014f6e;
    }
  }
  uVar1 = 0;
  param.peer_addr.addr[2] = (byte)(*(ushort *)(&DAT_280083d2 + iVar2) >> 6) & 1;
LAB_23014f6e:
  uVar3 = llm_util_bl_check((bd_addr *)&param.sleep_clk_acc,param.peer_addr.addr[2],&local_5a,'\0',
                            (_Bool *)0x0);
  if (CONCAT31(extraout_var_00,uVar3) == 0) {
    uVar3 = llm_util_bl_add((bd_addr *)&param.sleep_clk_acc,param.peer_addr.addr[2],local_5a);
    if (CONCAT31(extraout_var_01,uVar3) == 0) {
      uStack88 = data._18_2_;
      conhdl = data.winoffset;
      param.con_int = data.interval;
      param.peer_addr.addr[4] = data.chm.map[1] >> 5;
      param.peer_addr.addr[3] = data.chm.map[1] & 0x1f;
      param.con_lat = uVar1;
      (*ble_memcpy_ptr)(&param.sup_to,&param.sleep_clk_acc,6);
      llm_le_env.elt =
           lld_move_to_slave((llc_create_con_req_ind *)&uStack88,
                             (llm_pdu_con_req_rx *)&param.sleep_clk_acc,llm_le_env.elt,local_5a,
                             rx_hdl);
      llc_start(&uStack88,llm_le_env.elt);
      llm_le_env.elt = (ea_elt_tag *)0x0;
      llc_util_update_channel_map(local_5a,(le_chnl_map *)&data.latency);
    }
    bVar4 = ble_ke_state_get(0);
    ble_ke_state_set(0,bVar4 & 0xf);
  }
  return;
}



// WARNING: Exceeded maximum restarts with more pending

void llm_le_adv_report_ind(uint8_t rx_hdl)

{
  ushort uVar1;
  ushort uVar2;
  co_list_hdr cVar3;
  uint uVar4;
  uint uVar5;
  undefined *param;
  _Bool _Var6;
  int8_t iVar7;
  uint16_t uVar8;
  undefined3 in_register_00002029;
  undefined2 extraout_var_02;
  void *pvVar9;
  undefined2 extraout_var_03;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  byte bVar10;
  undefined uVar11;
  ushort *puVar12;
  ushort *puVar13;
  int iVar14;
  undefined auStack72 [4];
  bd_addr adv_addr;
  bd_addr inita;
  bd_addr adva;
  
  iVar14 = CONCAT31(in_register_00002029,rx_hdl) * 0xe;
  puVar12 = (ushort *)(&DAT_280083d2 + iVar14);
  puVar13 = (ushort *)(&DAT_280083d6 + iVar14);
  uVar1 = *puVar12;
  (*ble_memcpy_ptr)(auStack72,&DAT_28008000 + *puVar13,6);
  uVar5 = (uint)uVar1 & 0xf;
  cVar3 = (co_list_hdr)llm_le_env.adv_list.first;
  if (((llm_le_env.scanning_params)->filter_duplicate == '\x01') || (uVar5 == 1)) {
    while (cVar3 != (co_list_hdr)0x0) {
      _Var6 = co_bdaddr_compare((bd_addr *)auStack72,(bd_addr *)((int)cVar3 + 5));
      if ((CONCAT31(extraout_var_00,_Var6) != 0) &&
         ((uint)*(byte *)&((co_list_hdr *)((int)cVar3 + 4))->next == uVar5)) {
        return;
      }
      cVar3 = *(co_list_hdr *)cVar3;
    }
    uVar8 = ble_co_list_size(&llm_le_env.adv_list);
    if (CONCAT22(extraout_var_02,uVar8) == 10) {
      return;
    }
    pvVar9 = ble_ke_malloc(0xc,'\0');
    (*ble_memcpy_ptr)((void *)((int)pvVar9 + 5),auStack72,6);
    *(undefined *)((int)pvVar9 + 4) = (char)uVar5;
    ble_co_list_push_back(0x4201a360,pvVar9);
  }
  if (Is_ext_scan_enable != '\0') {
    return;
  }
  uVar8 = ble_ke_msg_get_sent_num();
  if (0x14 < CONCAT22(extraout_var_03,uVar8)) {
    return;
  }
  uVar1 = *(ushort *)(iVar14 + 0x280083d8);
  uVar4 = (uint)uVar1;
  uVar2 = *(ushort *)(iVar14 + 0x280083d0);
  (*ble_memcpy_ptr)(adv_addr.addr + 4,&DAT_28008000 + ((uint)*puVar13 + 6 & 0xffff),6);
  (*ble_memcpy_ptr)(inita.addr + 4,&DAT_28008000 + *puVar13,6);
  if (((((uVar5 == 1) && (1 < (llm_le_env.scanning_params)->filterpolicy)) &&
       ((*puVar12 >> 7 & 1) != 0)) && ((inita.addr[1] & 0xc0) == 0x40)) &&
     ((uVar1 == 0 || ((uVar2 & 0x600) == 0x600)))) {
    _Var6 = llm_util_check_evt_mask('\n');
    if (CONCAT31(extraout_var,_Var6) == 0) {
      return;
    }
    param = (undefined *)ble_ke_msg_alloc(0x804,0,0,0x12);
    *param = 0xb;
    param[1] = 1;
    iVar7 = (*rwip_rf.rssi_convert)((uint8_t)*(undefined2 *)(iVar14 + 0x280083d4));
    param[0x11] = iVar7;
    param[2] = (byte)*puVar12 & 0xf;
    if (uVar1 == 0) {
      (*ble_memcpy_ptr)(&DAT_28008000 + *puVar13,(void *)0x6,(uint)ble_memcpy_ptr);
      param[3] = (byte)(*puVar12 >> 6) & 1;
      (*ble_memcpy_ptr)(param + 0xb,adv_addr.addr + 4,6);
      param[10] = 1;
    }
    else {
      (*ble_memcpy_ptr)(param + 4,&DAT_28008000 + (uVar4 + 0x18 & 0xffff),6);
      bVar10 = (byte)*(undefined2 *)(&DAT_2800822e + ((uVar4 - 0x22e) / 0x34 & 0xff) * 0x34) & 1;
      param[3] = bVar10;
      if ((adva.addr[1] & 0xc0) == 0x40) {
        param[3] = bVar10 | 2;
      }
      (*ble_memcpy_ptr)(param + 0xb,adv_addr.addr + 4,6);
      param[10] = 1;
    }
    goto LAB_2301522e;
  }
  _Var6 = llm_util_check_evt_mask('\x01');
  if (CONCAT31(extraout_var_01,_Var6) == 0) {
    return;
  }
  param = (undefined *)ble_ke_msg_alloc(0x804,0,0,0x2b);
  param[1] = 1;
  *param = 2;
  iVar7 = (*rwip_rf.rssi_convert)((uint8_t)*(undefined2 *)(iVar14 + 0x280083d4));
  param[0x2a] = iVar7;
  uVar5 = (uint)*puVar12 & 0xf;
  uVar11 = (undefined)uVar5;
  if (uVar5 == 2) {
    uVar11 = 3;
LAB_230152e8:
    param[2] = uVar11;
  }
  else {
    if (uVar5 != 6) goto LAB_230152e8;
    param[2] = 2;
  }
  if (param[2] == '\x01') {
    param[10] = 0;
  }
  else {
    uVar5 = (uint)(*puVar12 >> 8) - 6 & 0xff;
    if (uVar5 < 0x20) {
      param[10] = (char)uVar5;
    }
    else {
      param[10] = 0x1f;
    }
    (*ble_memcpy_ptr)(param + 0xb,&DAT_28008000 + ((uint)*puVar13 + 6 & 0xffff),
                      (uint)(byte)param[10]);
  }
  if ((uVar1 == 0) || ((uVar2 & 0x600) == 0x200)) {
    (*ble_memcpy_ptr)(param + 4,&DAT_28008000 + *puVar13,6);
    bVar10 = (byte)(*puVar12 >> 6) & 1;
  }
  else {
    (*ble_memcpy_ptr)(param + 4,&DAT_28008000 + (uVar4 + 0x18 & 0xffff),6);
    bVar10 = (byte)*(undefined2 *)(&DAT_2800822e + ((uVar4 - 0x22e) / 0x34 & 0xff) * 0x34) & 1;
    param[3] = bVar10;
    if ((adva.addr[1] & 0xc0) != 0x40) goto LAB_2301522e;
    bVar10 = bVar10 | 2;
  }
  param[3] = bVar10;
LAB_2301522e:
  hci_send_2_host(param);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void llm_con_req_tx_cfm(uint8_t rx_hdl)

{
  int iVar1;
  uint8_t uVar2;
  byte bVar3;
  undefined3 in_register_00002029;
  undefined3 extraout_var;
  undefined auStack88 [4];
  llm_pdu_adv rxdata;
  llc_create_con_req_ind param;
  llm_pdu_con_req_tx txdata;
  
  iVar1 = CONCAT31(in_register_00002029,rx_hdl) * 0xe;
  (*ble_memcpy_ptr)(auStack88,&DAT_28008000 + *(ushort *)(&DAT_280083d6 + iVar1),6);
  (*ble_memcpy_ptr)(&param.sleep_clk_acc,&DAT_28008000 + _DAT_280082ec,0x16);
  param.con_lat = *(ushort *)(iVar1 + 0x280083d8);
  if (param.con_lat == 0) {
    param.peer_addr.addr[2] = (byte)(*(ushort *)(&DAT_280083d2 + iVar1) >> 6) & 1;
    (*ble_memcpy_ptr)(&param.sup_to,auStack88,6);
  }
  else {
    (*ble_memcpy_ptr)(&param.sup_to,&DAT_28008000 + ((uint)param.con_lat + 0x18 & 0xffff),6);
    param.peer_addr.addr[2] =
         (byte)*(undefined2 *)(&DAT_2800822e + (((uint)param.con_lat - 0x22e) / 0x34 & 0xff) * 0x34)
         & 2 | (byte)*(undefined2 *)
                      (&DAT_2800822e + (((uint)param.con_lat - 0x22e) / 0x34 & 0xff) * 0x34) & 1;
  }
  param.peer_addr.addr[4] = txdata.chm.map[1] >> 5;
  param.peer_addr.addr[3] = txdata.chm.map[1] & 0x1f;
  if ((llm_le_env.elt_coext_scan != (ea_elt_tag *)0x0) &&
     (uVar2 = llm_util_bl_add((bd_addr *)&param.sup_to,param.peer_addr.addr[2],
                              llm_le_env.conhdl_alloc), CONCAT31(extraout_var,uVar2) == 0)) {
    llm_le_env.elt_coext_scan =
         lld_move_to_master(llm_le_env.elt_coext_scan,llm_le_env.conhdl_alloc,
                            (llc_create_con_req_ind *)&rxdata.adva_data,rx_hdl);
    llc_start(&rxdata.adva_data,llm_le_env.elt_coext_scan);
    llm_le_env.elt_coext_scan = (ea_elt_tag *)0x0;
  }
  bVar3 = ble_ke_state_get(0);
  ble_ke_state_set(0,bVar3 & 0xf0);
  return;
}



void llm_common_cmd_complete_send(uint16_t opcode,uint8_t status)

{
  uint8_t *param;
  
  param = (uint8_t *)ble_ke_msg_alloc(0x801,0,opcode,1);
  *param = status;
  hci_send_2_host(param);
  return;
}



void llm_common_cmd_status_send(uint16_t opcode,uint8_t status)

{
  uint8_t *param;
  
  param = (uint8_t *)ble_ke_msg_alloc(0x802,0,opcode,1);
  *param = status;
  hci_send_2_host(param);
  return;
}


/*
Unable to decompile 'llm_test_mode_start_tx'
Cause: Exception while decompiling 23015548: Decompiler process died

*/


// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t llm_test_mode_start_rx(hci_le_rx_test_cmd *param)

{
  advertising_pdu_params *paVar1;
  uint8_t uVar2;
  
  if (param->rx_freq < 0x28) {
    if (llm_le_env.advertising_params == (advertising_pdu_params *)0x0) {
      llm_le_env.advertising_params = (advertising_pdu_params *)ble_ke_malloc(0x24,'\0');
      (*ble_memset_ptr)(llm_le_env.advertising_params,0,0x24);
      paVar1 = llm_le_env.advertising_params;
      (llm_le_env.advertising_params)->intervalmin = 0x800;
      paVar1->type = '\0';
      paVar1->intervalmax = 0x800;
      paVar1->filterpolicy = '\0';
      paVar1 = llm_le_env.advertising_params;
      (llm_le_env.advertising_params)->channelmap = '\a';
      paVar1->adv_ldc_flag = true;
      _DAT_280082fe = (ushort)paVar1->type | 0x600;
      _DAT_280082f4 = 0x604;
    }
    _DAT_28000000 = _DAT_28000000 & 0xfffbffff | 0x40000;
    ble_ke_state_set(0,'$');
    llm_le_env.elt = lld_test_mode_rx(param->rx_freq);
    uVar2 = '\x1f';
    if (llm_le_env.elt != (ea_elt_tag *)0x0) {
      llm_le_env.test_mode.directtesttype = '\x01';
      uVar2 = '\0';
    }
    return uVar2;
  }
  return '\x12';
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t llm_set_adv_param(hci_le_set_adv_param_cmd *param)

{
  uint8_t uVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  advertising_pdu_params *paVar2;
  bd_addr *bd_address;
  
  if ((((((param->adv_intv_max < param->adv_intv_min) || (7 < param->adv_chnl_map)) ||
        (3 < param->adv_filt_policy)) ||
       (((param->adv_type & 0xfb) == 0 && (param->adv_intv_min < 0x20)))) ||
      ((3 < param->own_addr_type || (1 < param->peer_addr_type)))) ||
     ((param->adv_type != 1 && (0x4000 < param->adv_intv_max)))) {
    return '\x12';
  }
  if (llm_le_env.advertising_params == (advertising_pdu_params *)0x0) {
    llm_le_env.advertising_params = (advertising_pdu_params *)ble_ke_malloc(0x24,'\0');
    (*ble_memset_ptr)(llm_le_env.advertising_params,0,0x24);
    paVar2 = llm_le_env.advertising_params;
    (llm_le_env.advertising_params)->intervalmin = 0x800;
    paVar2->type = '\0';
    paVar2->intervalmax = 0x800;
    paVar2->filterpolicy = '\0';
    paVar2 = llm_le_env.advertising_params;
    (llm_le_env.advertising_params)->channelmap = '\a';
    paVar2->adv_ldc_flag = true;
    _DAT_280082fe = (ushort)paVar2->type | 0x600;
    _DAT_280082f4 = 0x604;
  }
  paVar2 = llm_le_env.advertising_params;
  (llm_le_env.advertising_params)->type = '\b';
  paVar2->adv_ldc_flag = true;
  if (4 < param->adv_type) {
    return '\x12';
  }
  bd_address = &param->peer_addr;
  switch(param->adv_type) {
  default:
    paVar2->type = '\x01';
    _DAT_280082e0 = 0xc21;
    uVar1 = llm_util_check_address_validity(bd_address,param->peer_addr_type);
    if (CONCAT31(extraout_var,uVar1) == 0) {
      _DAT_280082e0 = (ushort)param->peer_addr_type << 7 | _DAT_280082e0 & 0xff7f;
      (*ble_memcpy_ptr)(&DAT_28008000 + _DAT_280082e2,bd_address,6);
    }
    paVar2 = llm_le_env.advertising_params;
    if (param->adv_type != '\x04') {
      (llm_le_env.advertising_params)->adv_ldc_flag = false;
      goto LAB_230159c6;
    }
    break;
  case '\x02':
    paVar2->type = '\x06';
  case '\0':
    if (paVar2->type != '\x06') {
      paVar2->type = '\0';
    }
  case '\x03':
    if ((paVar2->type != '\x06') && (paVar2->type != '\0')) {
      paVar2->type = '\x02';
    }
    paVar2->filterpolicy = param->adv_filt_policy;
  }
  paVar2->intervalmax = param->adv_intv_max;
  paVar2->intervalmin = param->adv_intv_min;
LAB_230159c6:
  paVar2 = llm_le_env.advertising_params;
  (llm_le_env.advertising_params)->peer_addr_type = param->peer_addr_type;
  (*ble_memcpy_ptr)(&paVar2->peer_addr,bd_address,6);
  (llm_le_env.advertising_params)->own_addr_type = param->own_addr_type;
  uVar1 = llm_util_check_map_validity(&param->adv_chnl_map,'\x01');
  if (CONCAT31(extraout_var_00,uVar1) == 0) {
    uVar1 = '\x12';
  }
  else {
    uVar1 = '\0';
    (llm_le_env.advertising_params)->channelmap = param->adv_chnl_map;
  }
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t llm_set_adv_en(hci_le_set_adv_en_cmd *param)

{
  advertising_pdu_params *paVar1;
  uint8_t uVar2;
  _Bool _Var3;
  byte bVar4;
  undefined3 extraout_var;
  em_desc_node *adv_pdu;
  
  if (param->adv_en == '\0') {
    bVar4 = ble_ke_state_get(0);
    ble_ke_state_set(0,bVar4 & 0xf | 0x20);
    lld_adv_stop(llm_le_env.elt);
    return '\0';
  }
  if (llm_le_env.advertising_params == (advertising_pdu_params *)0x0) {
    llm_le_env.advertising_params = (advertising_pdu_params *)ble_ke_malloc(0x24,'\0');
    (*ble_memset_ptr)(llm_le_env.advertising_params,0,0x24);
    paVar1 = llm_le_env.advertising_params;
    (llm_le_env.advertising_params)->intervalmin = 0x800;
    paVar1->type = '\0';
    paVar1->intervalmax = 0x800;
    paVar1->filterpolicy = '\0';
    paVar1 = llm_le_env.advertising_params;
    (llm_le_env.advertising_params)->channelmap = '\a';
    paVar1->adv_ldc_flag = true;
    _DAT_280082fe = (ushort)paVar1->type | 0x600;
    _DAT_280082f4 = 0x604;
  }
  _Var3 = co_bdaddr_compare(&llm_le_env.rand_add,&co_null_bdaddr);
  if ((CONCAT31(extraout_var,_Var3) == 0) ||
     (((llm_le_env.advertising_params)->own_addr_type & 1) == 0)) {
    llm_util_apply_bd_addr((llm_le_env.advertising_params)->own_addr_type);
    bVar4 = (llm_le_env.advertising_params)->type;
    if (bVar4 == 1) {
      adv_pdu = em_buf_env.tx_desc_node + 2;
LAB_23015b38:
      llm_le_env.elt =
           lld_adv_start(llm_le_env.advertising_params,adv_pdu,(em_desc_node *)0x0,rwip_rf.txpwr_max
                        );
      if (llm_le_env.elt == (ea_elt_tag *)0x0) goto LAB_23015ac8;
    }
    else {
      if (((bVar4 != 0) && (bVar4 != 2)) && (bVar4 != 6)) {
        return '\x12';
      }
      _DAT_280082fe =
           (ushort)(((uint)(llm_le_env.advertising_params)->datalen + 6 & 0xff) << 8) |
           (ushort)bVar4 | 0x20;
      if ((llm_le_env.advertising_params)->type == '\x02') {
        adv_pdu = em_buf_env.tx_desc_node + 5;
        goto LAB_23015b38;
      }
      _DAT_280082f4 =
           (ushort)(((uint)(llm_le_env.advertising_params)->scanrsplen + 6 & 0xff) << 8) | 0x24;
      llm_le_env.elt =
           lld_adv_start(llm_le_env.advertising_params,em_buf_env.tx_desc_node + 5,
                         em_buf_env.tx_desc_node + 4,rwip_rf.txpwr_max);
      if (llm_le_env.elt == (ea_elt_tag *)0x0) {
        return '\x1f';
      }
    }
    bVar4 = ble_ke_state_get(0);
    ble_ke_state_set(0,bVar4 & 0xf | 0x10);
    uVar2 = '\0';
  }
  else {
LAB_23015ac8:
    uVar2 = '\x12';
  }
  return uVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t llm_set_adv_data(hci_le_set_adv_data_cmd *param)

{
  byte bVar1;
  advertising_pdu_params *paVar2;
  
  if (param->adv_data_len < 0x20) {
    if (llm_le_env.advertising_params == (advertising_pdu_params *)0x0) {
      llm_le_env.advertising_params = (advertising_pdu_params *)ble_ke_malloc(0x24,'\0');
      (*ble_memset_ptr)(llm_le_env.advertising_params,0,0x24);
      paVar2 = llm_le_env.advertising_params;
      (llm_le_env.advertising_params)->intervalmin = 0x800;
      paVar2->type = '\0';
      paVar2->intervalmax = 0x800;
      paVar2->filterpolicy = '\0';
      paVar2 = llm_le_env.advertising_params;
      (llm_le_env.advertising_params)->channelmap = '\a';
      paVar2->adv_ldc_flag = true;
      _DAT_280082fe = (ushort)paVar2->type | 0x600;
      _DAT_280082f4 = 0x604;
    }
    bVar1 = param->adv_data_len;
    (llm_le_env.advertising_params)->datalen = bVar1;
    if (bVar1 != 0) {
      (*ble_memcpy_ptr)(&DAT_28008000 + _DAT_28008300,&param->data,(uint)bVar1);
    }
    _DAT_280082fe =
         (ushort)(((uint)(llm_le_env.advertising_params)->datalen + 6 & 0xff) << 8) |
         _DAT_280082fe & 0xff;
    return '\0';
  }
  return '\x12';
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t llm_set_scan_rsp_data(hci_le_set_scan_rsp_data_cmd *param)

{
  byte bVar1;
  advertising_pdu_params *paVar2;
  
  if (param->scan_rsp_data_len < 0x20) {
    if (llm_le_env.advertising_params == (advertising_pdu_params *)0x0) {
      llm_le_env.advertising_params = (advertising_pdu_params *)ble_ke_malloc(0x24,'\0');
      (*ble_memset_ptr)(llm_le_env.advertising_params,0,0x24);
      paVar2 = llm_le_env.advertising_params;
      (llm_le_env.advertising_params)->intervalmin = 0x800;
      paVar2->type = '\0';
      paVar2->intervalmax = 0x800;
      paVar2->filterpolicy = '\0';
      paVar2 = llm_le_env.advertising_params;
      (llm_le_env.advertising_params)->channelmap = '\a';
      paVar2->adv_ldc_flag = true;
      _DAT_280082fe = (ushort)paVar2->type | 0x600;
      _DAT_280082f4 = 0x604;
    }
    bVar1 = param->scan_rsp_data_len;
    (llm_le_env.advertising_params)->scanrsplen = bVar1;
    if (bVar1 != 0) {
      (*ble_memcpy_ptr)(&DAT_28008000 + _DAT_280082f6,&param->data,(uint)bVar1);
    }
    _DAT_280082f4 =
         (ushort)(((uint)(llm_le_env.advertising_params)->scanrsplen + 6 & 0xff) << 8) |
         _DAT_280082f4 & 0xff;
    return '\0';
  }
  return '\x12';
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t llm_set_scan_param(hci_le_set_scan_param_cmd *param)

{
  uint8_t uVar1;
  
  if (param->scan_window <= param->scan_intv) {
    uVar1 = '\x12';
    if ((((param->scan_type < 2) && ((ushort)(param->scan_window - 4) < 0x3ffd)) &&
        ((ushort)(param->scan_intv - 4) < 0x3ffd)) && (param->scan_filt_policy < 4)) {
      if (llm_le_env.scanning_params == (scanning_pdu_params *)0x0) {
        llm_le_env.scanning_params = (scanning_pdu_params *)ble_ke_malloc(0xc,'\0');
        (*ble_memset_ptr)(llm_le_env.scanning_params,0,0xc);
      }
      uVar1 = '\0';
      (llm_le_env.scanning_params)->filterpolicy = param->scan_filt_policy;
      (llm_le_env.scanning_params)->interval = param->scan_intv;
      (llm_le_env.scanning_params)->window = param->scan_window;
      (llm_le_env.scanning_params)->type = param->scan_type;
      (llm_le_env.scanning_params)->own_addr_type = param->own_addr_type;
      if (param->scan_type == '\x01') {
        _DAT_280082ea = 0xc03;
      }
    }
    return uVar1;
  }
  return '\x12';
}



uint8_t llm_set_scan_en(hci_le_set_scan_en_cmd *param)

{
  byte bVar1;
  _Bool _Var2;
  undefined3 extraout_var;
  em_desc_node *scan_req_pdu;
  
  if (param->scan_en == '\0') {
    bVar1 = ble_ke_state_get(0);
    ble_ke_state_set(0,bVar1 & 0xf0 | 3);
    lld_scan_stop(llm_le_env.elt_coext_scan);
    lld_util_flush_list(&llm_le_env.adv_list);
    return '\0';
  }
  if (llm_le_env.scanning_params == (scanning_pdu_params *)0x0) {
    llm_le_env.scanning_params = (scanning_pdu_params *)ble_ke_malloc(0xc,'\0');
    (llm_le_env.scanning_params)->filterpolicy = '\0';
    (llm_le_env.scanning_params)->interval = 0x10;
    (llm_le_env.scanning_params)->window = 8;
    (llm_le_env.scanning_params)->type = '\0';
    (llm_le_env.scanning_params)->filter_duplicate = '\0';
  }
  _Var2 = co_bdaddr_compare(&llm_le_env.rand_add,&co_null_bdaddr);
  if (((CONCAT31(extraout_var,_Var2) != 0) &&
      (((llm_le_env.scanning_params)->own_addr_type & 1) != 0)) &&
     ((llm_le_env.scanning_params)->type == '\x01')) {
    return '\x12';
  }
  (llm_le_env.scanning_params)->filter_duplicate = param->filter_duplic_en;
  llm_util_apply_bd_addr((llm_le_env.scanning_params)->own_addr_type);
  if ((llm_le_env.scanning_params)->type == '\0') {
    scan_req_pdu = (em_desc_node *)0x0;
  }
  else {
    if ((llm_le_env.scanning_params)->type != '\x01') goto LAB_23015eec;
    scan_req_pdu = em_buf_env.tx_desc_node + 3;
  }
  llm_le_env.elt_coext_scan = lld_scan_start(llm_le_env.scanning_params,scan_req_pdu);
  if (llm_le_env.elt_coext_scan == (ea_elt_tag *)0x0) {
    return '\x1f';
  }
LAB_23015eec:
  bVar1 = ble_ke_state_get(0);
  ble_ke_state_set(0,bVar1 & 0xf0 | 1);
  return '\0';
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void llm_wl_clr(void)

{
  uint16_t elem_index;
  uint16_t uVar1;
  
  elem_index = 0;
  do {
    uVar1 = elem_index + 1;
    llm_wlpriv_addr_set(elem_index,&llm_dflt_bdaddr);
    elem_index = uVar1;
  } while (uVar1 != 4);
  elem_index = 0;
  do {
    uVar1 = elem_index + 1;
    llm_wlpub_addr_set(elem_index,&llm_dflt_bdaddr);
    elem_index = uVar1;
  } while (uVar1 != 4);
  _DAT_2800822e = _DAT_2800822e & 0xdfff;
  _DAT_28008262 = _DAT_28008262 & 0xdfff;
  _DAT_28008296 = _DAT_28008296 & 0xdfff;
  llm_le_env.nb_dev_in_wl = '\0';
  llm_le_env.nb_dev_in_hw_wl = '\0';
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void llm_init(_Bool reset)

{
  undefined3 in_register_00002029;
  int iVar1;
  ke_msg *msg;
  
  if (CONCAT31(in_register_00002029,reset) == 0) {
    ble_ke_task_create(reset,&TASK_DESC_LLM);
    ble_ke_event_callback_set('\x01',llm_encryption_done);
  }
  else {
    if (llm_le_env.advertising_params != (advertising_pdu_params *)0x0) {
      if ((llm_le_env.advertising_params)->adv_data_req != (ke_msg *)0x0) {
        ble_ke_msg_free((llm_le_env.advertising_params)->adv_data_req);
      }
      if ((llm_le_env.advertising_params)->scan_rsp_req != (ke_msg *)0x0) {
        ble_ke_msg_free((llm_le_env.advertising_params)->scan_rsp_req);
      }
      ble_ke_free(llm_le_env.advertising_params);
    }
    if (llm_le_env.scanning_params != (scanning_pdu_params *)0x0) {
      ble_ke_free(llm_le_env.scanning_params);
    }
    lld_util_flush_list(&llm_le_env.adv_list);
    lld_util_flush_list(&llm_le_env.cnx_list);
  }
  ble_ke_state_set(0,'\0');
  llm_le_env.test_mode.directtesttype = '\x03';
  llm_le_env.last_opcode = false;
  llm_le_env.elt_coext_scan = (ea_elt_tag *)0x0;
  llm_le_env.test_mode.end_of_tst = false;
  iVar1 = bl_rand();
  llm_le_env.aa.intrand = (uint8_t)iVar1;
  llm_le_env.aa.ct1_idx = '\0';
  llm_le_env.aa.ct2_idx = '\0';
  (*ble_memset_ptr)((void *)0x4201a38a,0xff,4);
  llm_le_env.ch_map_assess.ch_map.map[4] = '\x1f';
  llm_le_env.elt = (ea_elt_tag *)0x0;
  llm_wl_clr();
  llm_le_env.p256_byte_process_timeout = 0x10;
  llm_le_env.cur_ecc_multiplication = LLM_ECC_IDLE;
  llm_le_env.eventmask.mask[0] = '\x1f';
  (*ble_memset_ptr)((void *)0x4201a391,0,7);
  llm_le_env.enc_pend = false;
  llm_le_env.scanning_params = (scanning_pdu_params *)0x0;
  ble_co_list_init(&llm_le_env.adv_list);
  llm_le_env.advertising_params = (advertising_pdu_params *)0x0;
  (*ble_memset_ptr)((void *)0x4201a3b3,0,6);
  llm_le_env.public_add.addr[0] = (uint8_t)_DAT_28000024;
  llm_le_env.public_add.addr[1] = (uint8_t)((uint)_DAT_28000024 >> 8);
  llm_le_env.public_add.addr[2] = (uint8_t)((uint)_DAT_28000024 >> 0x10);
  llm_le_env.public_add.addr[3] = (uint8_t)((uint)_DAT_28000024 >> 0x18);
  llm_le_env.public_add.addr[4] = (uint8_t)_DAT_28000028;
  llm_le_env.public_add.addr[5] = (uint8_t)((uint)_DAT_28000028 >> 8);
  while (msg = (ke_msg *)ble_co_list_pop_front((co_list *)&llm_le_env), msg != (ke_msg *)0x0) {
    ble_ke_msg_free(msg);
  }
  ble_co_list_init((co_list *)&llm_le_env);
  ble_co_list_init(&llm_le_env.cnx_list);
  memcpy(&llm_le_env.data_len_val,&llm_local_data_len_values,0xc);
  llm_le_env.ch_map_assess._0_4_ = 0xaf60064;
  llm_le_env.ch_map_assess._4_2_ = 0x8c4;
  llm_le_env.ch_map_assess.llm_le_set_host_ch_class_cmd_sto = true;
  llm_le_env.opcode2 = 0;
  llm_le_env.state2 = '\0';
  llm_le_env.opcode = 0;
  llm_le_env.state = '\0';
  return;
}



void llm_wl_dev_add(bd_addr *bd_addr,uint8_t bd_addr_type)

{
  uint16_t elem_index;
  undefined3 in_register_0000202d;
  
  elem_index = llm_util_bd_addr_wl_position(&llm_dflt_bdaddr,bd_addr_type);
  if (CONCAT31(in_register_0000202d,bd_addr_type) == 0) {
    llm_wlpub_addr_set(elem_index,bd_addr);
  }
  else {
    if (CONCAT31(in_register_0000202d,bd_addr_type) == 1) {
      llm_wlpriv_addr_set(elem_index,bd_addr);
    }
  }
  llm_le_env.nb_dev_in_hw_wl = llm_le_env.nb_dev_in_hw_wl + '\x01';
  return;
}



void llm_wl_dev_rem(bd_addr *bd_addr,uint8_t bd_addr_type)

{
  uint16_t elem_index;
  undefined2 extraout_var;
  undefined3 in_register_0000202d;
  
  elem_index = llm_util_bd_addr_wl_position(bd_addr,bd_addr_type);
  if (CONCAT22(extraout_var,elem_index) < 4) {
    if (CONCAT31(in_register_0000202d,bd_addr_type) == 1) {
      llm_wlpriv_addr_set(elem_index,&llm_dflt_bdaddr);
    }
    else {
      llm_wlpub_addr_set(elem_index,&llm_dflt_bdaddr);
    }
    llm_le_env.nb_dev_in_hw_wl = llm_le_env.nb_dev_in_hw_wl + -1;
  }
  return;
}



uint8_t llm_wl_dev_add_hdl(bd_addr *bd_addr,uint8_t bd_addr_type)

{
  _Bool _Var1;
  uint8_t uVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 in_register_0000202d;
  
  if (1 < CONCAT31(in_register_0000202d,bd_addr_type)) {
    return '\x12';
  }
  _Var1 = llm_util_bd_addr_in_wl(bd_addr,bd_addr_type,(_Bool *)0x0);
  if (CONCAT31(extraout_var,_Var1) == 0) {
    uVar2 = '\a';
    if (llm_le_env.nb_dev_in_wl < 4) {
      uVar2 = llm_util_bl_check(bd_addr,bd_addr_type,(uint16_t *)0x0,'\x02',(_Bool *)0x0);
      if (CONCAT31(extraout_var_00,uVar2) != 0xb) {
        llm_wl_dev_add(bd_addr,bd_addr_type);
      }
      uVar2 = '\0';
      llm_le_env.nb_dev_in_wl = llm_le_env.nb_dev_in_wl + '\x01';
    }
  }
  else {
    uVar2 = '\x12';
  }
  return uVar2;
}



uint8_t llm_wl_dev_rem_hdl(bd_addr *bd_addr,uint8_t bd_addr_type)

{
  uint8_t uVar1;
  _Bool _Var2;
  undefined3 extraout_var;
  undefined3 in_register_0000202d;
  _Bool a_Stack17 [4];
  _Bool in_black_list;
  
  if (1 < CONCAT31(in_register_0000202d,bd_addr_type)) {
    return '\x12';
  }
  _Var2 = llm_util_bd_addr_in_wl(bd_addr,bd_addr_type,a_Stack17);
  if (CONCAT31(extraout_var,_Var2) == 0) {
    uVar1 = '\x12';
  }
  else {
    if (a_Stack17[0] == false) {
      llm_wl_dev_rem(bd_addr,bd_addr_type);
    }
    else {
      llm_util_bl_check(bd_addr,bd_addr_type,(uint16_t *)0x0,'\x01',(_Bool *)0x0);
    }
    uVar1 = '\0';
    llm_le_env.nb_dev_in_wl = llm_le_env.nb_dev_in_wl + -1;
  }
  return uVar1;
}



uint8_t llm_create_con(hci_le_create_con_cmd *param)

{
  ushort uVar1;
  uint8_t uVar2;
  uint8_t uVar3;
  _Bool _Var4;
  byte bVar5;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  
  uVar2 = llc_util_get_free_conhdl(&llm_le_env.conhdl_alloc);
  if (CONCAT31(extraout_var,uVar2) != 0) {
    return '\t';
  }
  if (param->init_filt_policy == '\x01') {
    if (llm_le_env.nb_dev_in_hw_wl == '\0') {
      return (llm_le_env.nb_dev_in_wl == '\0') + '\v';
    }
  }
  else {
    uVar3 = llm_util_bl_check(&param->peer_addr,param->peer_addr_type,&llm_le_env.conhdl_alloc,'\0',
                              (_Bool *)0x0);
    if (CONCAT31(extraout_var_00,uVar3) != 0) {
      return uVar3;
    }
  }
  if (param->scan_window <= param->scan_intv) {
    uVar1 = param->con_intv_max;
    if ((uint)uVar1 < (uint)param->con_intv_min) {
      return '\x12';
    }
    if (0x3ffc < (ushort)(param->scan_window - 4)) {
      return '\x12';
    }
    if (0x3ffc < (ushort)(param->scan_intv - 4)) {
      return '\x12';
    }
    if (param->ce_len_max < param->ce_len_min) {
      return '\x12';
    }
    if (param->con_intv_min < 6) {
      return '\x12';
    }
    if (0xc80 < uVar1) {
      return '\x12';
    }
    if (0xc76 < ((uint)param->superv_to - 10 & 0xffff)) {
      return '\x12';
    }
    if (499 < param->con_latency) {
      return '\x12';
    }
    if ((uint)param->superv_to << 2 <= ((uint)param->con_latency + 1) * (uint)uVar1) {
      return '\x12';
    }
    _Var4 = co_bdaddr_compare(&llm_le_env.rand_add,&co_null_bdaddr);
    bVar5 = param->own_addr_type;
    if ((CONCAT31(extraout_var_01,_Var4) != 0) && ((bVar5 & 1) != 0)) {
      return '\x12';
    }
    if ((llm_le_env.enh_priv_info & 1) == 0) {
      if ((bVar5 & 2) != 0) {
        return '\x12';
      }
    }
    else {
      if ((bVar5 & 2) != 0) goto LAB_230163d2;
    }
    if ((param->peer_addr_type & 2) == 0) {
LAB_230163d2:
      bVar5 = ble_ke_state_get(0);
      ble_ke_state_set(0,bVar5 & 0xf0 | 2);
      llm_le_env.elt_coext_scan =
           (ea_elt_tag *)lld_con_start(param,0x4201a1f4,(uint)llm_le_env.conhdl_alloc);
      if (llm_le_env.elt_coext_scan == (ea_elt_tag *)0x0) {
        return '\x1f';
      }
      return uVar2;
    }
  }
  return '\x12';
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void llm_encryption_start(llm_enc_req *param)

{
  _DAT_280000c4 = *(undefined4 *)(param->key).ltk;
  _DAT_280000c8 = *(undefined4 *)((param->key).ltk + 4);
  _DAT_280000cc = *(undefined4 *)((param->key).ltk + 8);
  _DAT_280000d0 = *(undefined4 *)((param->key).ltk + 0xc);
  (*ble_memcpy_ptr)((void *)0x2800806e,param->plain_data,0x10);
  _DAT_280000d4 = 0x6e;
  _DAT_280000c0 = 1;
  llm_le_env.enc_pend = true;
  rwip_prevent_sleep_set(0x10);
  return;
}



void llm_encryption_done(void)

{
  ke_msg *msg;
  undefined *param;
  
  msg = (ke_msg *)ble_co_list_pop_front((co_list *)&llm_le_env);
  ble_ke_event_clear('\x01');
  if (msg != (ke_msg *)0x0) {
    if ((msg->src_id & 0xff) == 1) {
      param = (undefined *)ble_ke_msg_alloc(5,msg->src_id,0,0x11);
      (*ble_memcpy_ptr)(param + 1,(void *)0x2800807e,0x10);
      *param = 0;
      ble_ke_msg_send(param);
    }
    else {
      param = (undefined *)ble_ke_msg_alloc(0x801,0,0x2017,0x11);
      (*ble_memcpy_ptr)(param + 1,(void *)0x2800807e,0x10);
      *param = 0;
      hci_send_2_host(param);
    }
    ble_ke_msg_free(msg);
    if (llm_le_env.enc_req.first != (co_list_hdr *)0x0) {
      llm_encryption_start((llm_enc_req *)(llm_le_env.enc_req.first + 3));
      return;
    }
    rwip_prevent_sleep_clear(0x10);
    llm_le_env.enc_pend = false;
  }
  return;
}



void hci_fc_init(void)

{
                    // WARNING: Could not recover jumptable at 0x230165a2. Too many branches
                    // WARNING: Treating indirect jump as call
  (*ble_memset_ptr)(&hci_fc_env,0,10);
  return;
}



uint8_t hci_fc_acl_buf_size_set(uint16_t acl_pkt_len,uint16_t nb_acl_pkts)

{
  undefined2 in_register_0000202a;
  undefined2 in_register_0000202e;
  uint8_t uVar1;
  
  uVar1 = '\x12';
  if (((CONCAT22(in_register_0000202a,acl_pkt_len) != 0) &&
      (CONCAT22(in_register_0000202e,nb_acl_pkts) != 0)) &&
     (uVar1 = '\x11', 0x3fc < CONCAT22(in_register_0000202a,acl_pkt_len))) {
    uVar1 = '\0';
    hci_fc_env.host_set.acl_pkt_len = acl_pkt_len;
    hci_fc_env.host_set.acl_pkt_nb = nb_acl_pkts;
  }
  return uVar1;
}



uint8_t hci_fc_acl_en(_Bool flow_enable)

{
  ke_state_t kVar1;
  uint8_t uVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  
  kVar1 = ble_ke_state_get(1);
  if ((CONCAT31(extraout_var,kVar1) == 0x7f) &&
     (kVar1 = ble_ke_state_get(0x101), CONCAT31(extraout_var_00,kVar1) == 0x7f)) {
    uVar2 = '\0';
    hci_fc_env.host_set.acl_flow_cntl_en = flow_enable;
  }
  else {
    uVar2 = '\f';
  }
  return uVar2;
}



void hci_fc_host_nb_acl_pkts_complete(uint16_t acl_pkt_nb)

{
  undefined2 in_register_0000202a;
  uint16_t uVar1;
  
  uVar1 = 0;
  if (CONCAT22(in_register_0000202a,acl_pkt_nb) < (uint)hci_fc_env.cntr) {
    uVar1 = hci_fc_env.cntr - acl_pkt_nb;
  }
  hci_fc_env.cntr = uVar1;
  return;
}



uint8_t hci_pack_bytes(uint8_t **pp_in,uint8_t **pp_out,uint8_t *p_in_end,uint8_t *p_out_end,
                      uint8_t len)

{
  uint8_t uVar1;
  undefined3 in_register_00002039;
  uint uVar2;
  
  uVar2 = CONCAT31(in_register_00002039,len);
  uVar1 = '\x01';
  if (*pp_in + uVar2 <= p_in_end) {
    uVar1 = '\0';
    if (p_out_end != (uint8_t *)0x0) {
      uVar1 = (p_out_end < *pp_out + uVar2) << 1;
      (*ble_memcpy_ptr)(*pp_out,*pp_in,uVar2);
    }
    *pp_in = *pp_in + uVar2;
    *pp_out = *pp_out + uVar2;
  }
  return uVar1;
}



// WARNING: Could not reconcile some variable overlaps

uint8_t hci_host_nb_cmp_pkts_cmd_pkupk(uint8_t *out,uint8_t *in,uint16_t *out_len,uint16_t in_len)

{
  uint8_t *p_in_end;
  uint8_t uVar1;
  uint8_t uVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined2 in_register_00002036;
  uint uVar3;
  int iVar4;
  uint8_t *p_out_end;
  uint8_t *puStack56;
  uint8_t *p_in;
  uint8_t *p_out;
  
  if (in == (uint8_t *)0x0) {
    *out_len = 0xe;
    uVar2 = '\0';
  }
  else {
    p_in_end = in + CONCAT22(in_register_00002036,in_len);
    p_out_end = out + *out_len;
    puStack56 = in;
    p_in = out;
    uVar1 = hci_pack_bytes(&puStack56,&p_in,p_in_end,p_out_end,'\x01');
    uVar2 = uVar1;
    if (CONCAT31(extraout_var,uVar1) == 0) {
      uVar3 = 0;
      while( true ) {
        uVar2 = uVar1;
        if ((*in <= uVar3) || (&DAT_0000000e < p_in + -(int)out)) break;
        iVar4 = (uVar3 + 1) * 2;
        p_in = out + iVar4;
        uVar2 = hci_pack_bytes(&puStack56,&p_in,p_in_end,p_out_end,'\x02');
        if (CONCAT31(extraout_var_00,uVar2) != 0) break;
        p_in = out + iVar4 + 6;
        uVar2 = hci_pack_bytes(&puStack56,&p_in,p_in_end,p_out_end,'\x02');
        if (CONCAT31(extraout_var_01,uVar2) != 0) break;
        uVar3 = uVar3 + 1 & 0xff;
      }
    }
    *out_len = (short)p_in - (short)out;
  }
  return uVar2;
}



// WARNING: Variable defined which should be unmapped: temp_out
// WARNING: Could not reconcile some variable overlaps

uint8_t hci_le_adv_report_evt_pkupk(uint8_t *out,uint8_t *in,uint16_t *out_len,uint16_t in_len)

{
  uint8_t *p_out_end;
  uint8_t uVar1;
  uint8_t uVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  undefined3 extraout_var_05;
  undefined3 extraout_var_06;
  undefined2 in_register_00002036;
  uint8_t **ppuVar3;
  int iVar4;
  uint8_t **ppuStack84;
  uint8_t *p_in;
  uint8_t *p_out;
  hci_le_adv_report_evt temp_out;
  
  if (in == (uint8_t *)0x0) {
    *out_len = 0;
    uVar1 = '\0';
  }
  else {
    if (out == (uint8_t *)0x0) {
      p_out_end = temp_out.adv_rep[0].data + 0x1c;
      out = (uint8_t *)&p_out;
    }
    else {
      p_out_end = out + *out_len;
    }
    in = in + CONCAT22(in_register_00002036,in_len);
    ppuStack84 = (uint8_t **)out;
    p_in = out;
    uVar1 = hci_pack_bytes((uint8_t **)&ppuStack84,&p_in,in,p_out_end,'\x01');
    if (CONCAT31(extraout_var,uVar1) == 0) {
      ppuStack84 = (uint8_t **)((int)out + 1);
      uVar2 = hci_pack_bytes((uint8_t **)&ppuStack84,&p_in,in,p_out_end,'\x01');
      uVar1 = uVar2;
      if (CONCAT31(extraout_var_00,uVar2) == 0) {
        ppuVar3 = (uint8_t **)((int)out + 10);
        iVar4 = 0;
        while (uVar1 = uVar2, iVar4 < (int)(uint)*(byte *)((int)out + 1)) {
          ppuStack84 = ppuVar3 + -2;
          uVar1 = hci_pack_bytes((uint8_t **)&ppuStack84,&p_in,in,p_out_end,'\x01');
          if (CONCAT31(extraout_var_01,uVar1) != 0) break;
          ppuStack84 = (uint8_t **)((int)ppuVar3 + -7);
          uVar1 = hci_pack_bytes((uint8_t **)&ppuStack84,&p_in,in,p_out_end,'\x01');
          if (CONCAT31(extraout_var_02,uVar1) != 0) break;
          ppuStack84 = (uint8_t **)((int)ppuVar3 + -6);
          uVar1 = hci_pack_bytes((uint8_t **)&ppuStack84,&p_in,in,p_out_end,'\x06');
          if (CONCAT31(extraout_var_03,uVar1) != 0) break;
          ppuStack84 = ppuVar3;
          uVar1 = hci_pack_bytes((uint8_t **)&ppuStack84,&p_in,in,p_out_end,'\x01');
          if (CONCAT31(extraout_var_04,uVar1) != 0) break;
          ppuStack84 = (uint8_t **)((int)ppuVar3 + 1);
          uVar1 = hci_pack_bytes((uint8_t **)&ppuStack84,&p_in,in,p_out_end,*(uint8_t *)ppuVar3);
          if (CONCAT31(extraout_var_05,uVar1) != 0) break;
          ppuStack84 = ppuVar3 + 8;
          uVar1 = hci_pack_bytes((uint8_t **)&ppuStack84,&p_in,in,p_out_end,'\x01');
          ppuVar3 = (uint8_t **)((int)ppuVar3 + 0x29);
          if (CONCAT31(extraout_var_06,uVar1) != 0) break;
          iVar4 = iVar4 + 1;
        }
      }
    }
    *out_len = (short)p_in - (short)out;
  }
  return uVar1;
}



// WARNING: Variable defined which should be unmapped: temp_out
// WARNING: Could not reconcile some variable overlaps

uint8_t hci_le_dir_adv_report_evt_pkupk(uint8_t *out,uint8_t *in,uint16_t *out_len,uint16_t in_len)

{
  uint8_t *p_out_end;
  uint8_t uVar1;
  uint8_t uVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  undefined3 extraout_var_05;
  undefined3 extraout_var_06;
  undefined2 in_register_00002036;
  uint8_t **ppuVar3;
  int iVar4;
  uint8_t **ppuStack60;
  uint8_t *p_in;
  uint8_t *p_out;
  hci_le_dir_adv_rep_evt temp_out;
  
  if (in == (uint8_t *)0x0) {
    *out_len = 0;
    uVar1 = '\0';
  }
  else {
    if (out == (uint8_t *)0x0) {
      p_out_end = temp_out.adv_rep[0].dir_addr.addr + 3;
      out = (uint8_t *)&p_out;
    }
    else {
      p_out_end = out + *out_len;
    }
    in = in + CONCAT22(in_register_00002036,in_len);
    ppuStack60 = (uint8_t **)out;
    p_in = out;
    uVar1 = hci_pack_bytes((uint8_t **)&ppuStack60,&p_in,in,p_out_end,'\x01');
    if (CONCAT31(extraout_var,uVar1) == 0) {
      ppuStack60 = (uint8_t **)((int)out + 1);
      uVar2 = hci_pack_bytes((uint8_t **)&ppuStack60,&p_in,in,p_out_end,'\x01');
      uVar1 = uVar2;
      if (CONCAT31(extraout_var_00,uVar2) == 0) {
        ppuVar3 = (uint8_t **)((int)out + 0x11);
        iVar4 = 0;
        while (uVar1 = uVar2, iVar4 < (int)(uint)*(byte *)((int)out + 1)) {
          ppuStack60 = (uint8_t **)((int)ppuVar3 + -0xf);
          uVar1 = hci_pack_bytes((uint8_t **)&ppuStack60,&p_in,in,p_out_end,'\x01');
          if (CONCAT31(extraout_var_01,uVar1) != 0) break;
          ppuStack60 = (uint8_t **)((int)ppuVar3 + -0xe);
          uVar1 = hci_pack_bytes((uint8_t **)&ppuStack60,&p_in,in,p_out_end,'\x01');
          if (CONCAT31(extraout_var_02,uVar1) != 0) break;
          ppuStack60 = (uint8_t **)((int)ppuVar3 + -0xd);
          uVar1 = hci_pack_bytes((uint8_t **)&ppuStack60,&p_in,in,p_out_end,'\x06');
          if (CONCAT31(extraout_var_03,uVar1) != 0) break;
          ppuStack60 = (uint8_t **)((int)ppuVar3 + -7);
          uVar1 = hci_pack_bytes((uint8_t **)&ppuStack60,&p_in,in,p_out_end,'\x01');
          if (CONCAT31(extraout_var_04,uVar1) != 0) break;
          ppuStack60 = (uint8_t **)((int)ppuVar3 + -6);
          uVar1 = hci_pack_bytes((uint8_t **)&ppuStack60,&p_in,in,p_out_end,'\x06');
          if (CONCAT31(extraout_var_05,uVar1) != 0) break;
          ppuStack60 = ppuVar3;
          uVar1 = hci_pack_bytes((uint8_t **)&ppuStack60,&p_in,in,p_out_end,'\x01');
          ppuVar3 = ppuVar3 + 4;
          if (CONCAT31(extraout_var_06,uVar1) != 0) break;
          iVar4 = iVar4 + 1;
        }
      }
    }
    *out_len = (short)p_in - (short)out;
  }
  return uVar1;
}



hci_cmd_desc_tag * hci_look_for_cmd_desc(uint16_t opcode)

{
  undefined2 in_register_0000202a;
  hci_cmd_desc_tag *phVar1;
  uint16_t uVar2;
  uint uVar3;
  int iVar4;
  
  uVar3 = CONCAT22(in_register_0000202a,opcode) >> 10;
  if (uVar3 == 1) {
    iVar4 = 0;
  }
  else {
    if (uVar3 == 3) {
      iVar4 = 1;
    }
    else {
      if (uVar3 == 4) {
        iVar4 = 2;
      }
      else {
        if (uVar3 == 5) {
          iVar4 = 3;
        }
        else {
          if (uVar3 == 8) {
            iVar4 = 4;
          }
          else {
            if (uVar3 != 0x3f) {
              return (hci_cmd_desc_tag *)0x0;
            }
            iVar4 = 5;
          }
        }
      }
    }
  }
  phVar1 = hci_cmd_desc_root_tab[iVar4].cmd_desc_tab;
  uVar2 = 0;
  if (phVar1 != (hci_cmd_desc_tag *)0x0) {
    while( true ) {
      if (uVar2 == hci_cmd_desc_root_tab[iVar4].nb_cmds) {
        return (hci_cmd_desc_tag *)0x0;
      }
      if ((phVar1->opcode & 0x3ff) == (opcode & 0x3ff)) break;
      uVar2 = uVar2 + 1;
      phVar1 = phVar1 + 1;
    }
    return phVar1;
  }
  return (hci_cmd_desc_tag *)0x0;
}



hci_evt_desc_tag * hci_look_for_evt_desc(uint8_t code)

{
  undefined3 in_register_00002029;
  hci_evt_desc_tag *phVar1;
  int iVar2;
  
  phVar1 = hci_evt_desc_tab;
  iVar2 = 0;
  do {
    if ((uint)phVar1->code == CONCAT31(in_register_00002029,code)) {
      return hci_evt_desc_tab + iVar2;
    }
    iVar2 = iVar2 + 1;
    phVar1 = phVar1 + 1;
  } while (iVar2 != 9);
  return (hci_evt_desc_tag *)0x0;
}



hci_evt_desc_tag * hci_look_for_le_evt_desc(uint8_t subcode)

{
  undefined3 in_register_00002029;
  hci_evt_desc_tag *phVar1;
  int iVar2;
  
  phVar1 = hci_evt_le_desc_tab;
  iVar2 = 0;
  do {
    if ((uint)phVar1->code == CONCAT31(in_register_00002029,subcode)) {
      return hci_evt_le_desc_tab + iVar2;
    }
    iVar2 = iVar2 + 1;
    phVar1 = phVar1 + 1;
  } while (iVar2 != 0xc);
  return (hci_evt_desc_tag *)0x0;
}



void hci_tl_init(_Bool reset)

{
  undefined3 in_register_00002029;
  
  if (CONCAT31(in_register_00002029,reset) == 0) {
    (*ble_memset_ptr)(&hci_tl_env,0,0x1c);
    ble_co_list_init((co_list *)&hci_tl_env);
    ble_co_list_init(&hci_tl_env.acl_queue);
    hci_tl_env.tx_state = '\x01';
  }
  hci_tl_env.nb_h2c_cmd_pkts = '\x05';
  return;
}



uint16_t hci_util_read_array_size(char **fmt_cursor)

{
  byte *pbVar1;
  uint uVar2;
  
  pbVar1 = (byte *)*fmt_cursor;
  *(byte **)fmt_cursor = pbVar1 + 1;
  uVar2 = (uint)*pbVar1 - 0x30;
  while( true ) {
    pbVar1 = (byte *)*fmt_cursor;
    if (9 < (byte)(*pbVar1 - 0x30)) break;
    *(byte **)fmt_cursor = pbVar1 + 1;
    uVar2 = (uVar2 & 0xffff) * 10 + ((uint)*pbVar1 - 0x30);
  }
  return (uint16_t)(uVar2 & 0xffff);
}



HCI_PACK_STATUS hci_util_pack(uint8_t *inout,uint16_t *inout_len,char *format)

{
  char cVar1;
  undefined2 uVar2;
  uint8_t *puVar3;
  undefined4 *puVar4;
  uint16_t uVar5;
  undefined2 extraout_var;
  uint8_t *puVar6;
  char *pcVar7;
  uint uVar8;
  undefined4 *puVar9;
  undefined2 *puVar10;
  undefined4 *puVar11;
  undefined4 uVar12;
  HCI_PACK_STATUS HVar13;
  undefined4 *puVar14;
  char *pcStack68;
  char *cursor;
  
  puVar14 = (undefined4 *)(inout + *inout_len);
  HVar13 = HCI_PACK_OK;
  puVar6 = inout;
  puVar9 = (undefined4 *)inout;
  pcStack68 = format;
LAB_23016b30:
  do {
    do {
      while( true ) {
        while( true ) {
          while( true ) {
            puVar4 = puVar9;
            puVar3 = puVar6;
            if (*pcStack68 == '\0') {
              if (HVar13 == HCI_PACK_OK) {
                *inout_len = (short)puVar3 - (short)inout;
              }
              return HVar13;
            }
            if (HVar13 != HCI_PACK_OK) {
              return HVar13;
            }
            uVar8 = 0;
            if ((byte)(*pcStack68 - 0x30U) < 10) {
              uVar5 = hci_util_read_array_size(&pcStack68);
              uVar8 = CONCAT22(extraout_var,uVar5);
            }
            pcVar7 = pcStack68 + 1;
            cVar1 = *pcStack68;
            puVar6 = puVar3;
            pcStack68 = pcVar7;
            if (cVar1 != 'H') break;
            puVar10 = (undefined2 *)((uint)((int)puVar4 + 1) & 0xfffffffe);
            puVar9 = (undefined4 *)(puVar10 + 1);
            if (inout != (uint8_t *)0x0) {
              if (puVar14 < puVar9) goto LAB_23016c28;
              uVar2 = *puVar10;
              *puVar3 = (uint8_t)uVar2;
              puVar3[1] = (uint8_t)((ushort)uVar2 >> 8);
            }
            puVar6 = puVar3 + 2;
          }
          if (cVar1 != 'L') break;
          puVar11 = (undefined4 *)((uint)((int)puVar4 + 3) & 0xfffffffc);
          puVar9 = puVar11 + 1;
          if (inout != (uint8_t *)0x0) {
            if (puVar14 < puVar9) goto LAB_23016c28;
            uVar12 = *puVar11;
            *puVar3 = (uint8_t)uVar12;
            puVar3[1] = (uint8_t)((uint)uVar12 >> 8);
            puVar3[2] = (uint8_t)((uint)uVar12 >> 0x10);
            puVar3[3] = (uint8_t)((uint)uVar12 >> 0x18);
          }
          puVar6 = puVar3 + 4;
        }
        if (cVar1 == 'B') break;
        HVar13 = HCI_PACK_WRONG_FORMAT;
        puVar9 = puVar4;
      }
      puVar9 = (undefined4 *)((int)puVar4 + 1);
      if (inout != (uint8_t *)0x0) {
        if (puVar14 < puVar9) goto LAB_23016c28;
        *puVar3 = *(uint8_t *)puVar4;
      }
      puVar6 = puVar3 + 1;
    } while (uVar8 < 2);
    if (inout != (uint8_t *)0x0) {
      puVar4 = puVar9;
      if (puVar14 < (undefined4 *)((int)puVar4 + uVar8)) {
LAB_23016c28:
        HVar13 = HCI_PACK_IN_BUF_OVFLW;
        puVar9 = puVar4;
        goto LAB_23016b30;
      }
      (*ble_memcpy_ptr)(puVar6,puVar9,uVar8 - 1);
    }
    puVar6 = puVar3 + uVar8;
    puVar9 = (undefined4 *)((int)puVar4 + uVar8);
  } while( true );
}



HCI_PACK_STATUS
hci_util_unpack(uint8_t *out,uint8_t *in,uint16_t *out_len,uint16_t in_len,char *format)

{
  char cVar1;
  bool bVar2;
  bool bVar3;
  undefined4 *puVar4;
  undefined4 *puVar5;
  undefined4 *puVar6;
  uint16_t uVar7;
  undefined2 extraout_var;
  undefined2 in_register_00002036;
  char *pcVar8;
  undefined2 *puVar9;
  HCI_PACK_STATUS HVar10;
  undefined4 *puVar11;
  uint uVar12;
  undefined4 *puVar13;
  char *pcStack68;
  char *cursor;
  
  puVar13 = (undefined4 *)(in + CONCAT22(in_register_00002036,in_len));
  puVar11 = (undefined4 *)(out + *out_len);
  bVar2 = in != (uint8_t *)0x0;
  bVar3 = out != (uint8_t *)0x0;
  HVar10 = 0;
  puVar6 = (undefined4 *)out;
  pcStack68 = format;
LAB_23016c7e:
  do {
    puVar5 = puVar6;
    puVar4 = (undefined4 *)in;
    if ((*pcStack68 == '\0') || (HVar10 != HCI_PACK_OK)) {
      if (puVar13 < puVar4) {
        HVar10 = HCI_PACK_IN_BUF_OVFLW;
      }
      *out_len = (short)puVar5 - (short)out;
      return HVar10;
    }
    uVar12 = 0;
    if ((byte)(*pcStack68 - 0x30U) < 10) {
      uVar7 = hci_util_read_array_size(&pcStack68);
      uVar12 = CONCAT22(extraout_var,uVar7);
    }
    pcVar8 = pcStack68 + 1;
    cVar1 = *pcStack68;
    puVar6 = puVar5;
    pcStack68 = pcVar8;
    if (cVar1 != 'H') {
      if (cVar1 == 'L') {
        puVar5 = (undefined4 *)((uint)((int)puVar5 + 3) & 0xfffffffc);
        if (bVar3 && bVar2) {
          if (puVar13 < puVar4 + 1) {
LAB_23016db2:
            HVar10 = 1;
            in = (uint8_t *)puVar4;
            goto LAB_23016c7e;
          }
          if (puVar11 < puVar5 + 1) goto LAB_23016dba;
          *puVar5 = *puVar4;
        }
        in = (uint8_t *)(puVar4 + 1);
        puVar6 = puVar5 + 1;
        goto LAB_23016c7e;
      }
      if (cVar1 == 'B') {
        in = (uint8_t *)((int)puVar4 + 1);
        if (bVar3 && bVar2) {
          if (puVar13 < in) goto LAB_23016db2;
          if (puVar11 < (undefined4 *)((int)puVar5 + 1)) goto LAB_23016dba;
          *(undefined *)puVar5 = *(undefined *)puVar4;
        }
        puVar6 = (undefined4 *)((int)puVar5 + 1);
        if (1 < uVar12) {
          if (bVar3 && bVar2) {
            puVar4 = (undefined4 *)in;
            if (puVar13 < (undefined4 *)((int)puVar4 + uVar12)) goto LAB_23016db2;
            if (puVar11 < (undefined4 *)((int)puVar5 + uVar12)) goto LAB_23016dba;
            (*ble_memcpy_ptr)(puVar6,in,uVar12 - 1);
          }
          in = (uint8_t *)(undefined4 *)((int)puVar4 + uVar12);
          puVar6 = (undefined4 *)((int)puVar5 + uVar12);
        }
      }
      else {
        HVar10 = 3;
        in = (uint8_t *)puVar4;
      }
      goto LAB_23016c7e;
    }
    puVar9 = (undefined2 *)((uint)((int)puVar5 + 1) & 0xfffffffe);
    if (bVar3 && bVar2) {
      if (puVar13 < (undefined4 *)((int)puVar4 + 2)) goto LAB_23016db2;
      if (puVar11 < puVar9 + 1) {
LAB_23016dba:
        HVar10 = 2;
        in = (uint8_t *)puVar4;
        goto LAB_23016c7e;
      }
      *puVar9 = *(undefined2 *)puVar4;
    }
    in = (uint8_t *)(undefined4 *)((int)puVar4 + 2);
    puVar6 = (undefined4 *)(puVar9 + 1);
  } while( true );
}



// WARNING: Variable defined which should be unmapped: ret_par_len

uint8_t * hci_build_cc_evt(ke_msg *msg,int8_t nb_h2c_cmd_pkts)

{
  uint16_t opcode;
  hci_cmd_desc_tag *phVar1;
  code *format;
  uint16_t auStack18 [2];
  uint16_t ret_par_len;
  
  opcode = msg->src_id;
  auStack18[0] = msg->param_len;
  phVar1 = hci_look_for_cmd_desc(opcode);
  if ((phVar1 == (hci_cmd_desc_tag *)0x0) || (auStack18[0] == 0)) {
    if (opcode != 0) {
      *(undefined *)msg->param = 1;
    }
  }
  else {
    format = (code *)phVar1->ret_par_fmt;
    if (format != (code *)0x0) {
      if ((char)phVar1->dest_field < '\0') {
        (*format)(msg->param,auStack18);
      }
      else {
        hci_util_pack((uint8_t *)msg->param,auStack18,(char *)format);
      }
    }
  }
  msg->param_len = auStack18[0];
  return (uint8_t *)((int)&msg->dest_id + 1);
}



uint8_t * hci_build_evt(ke_msg *msg)

{
  hci_evt_desc_tag *phVar1;
  code *format;
  uint16_t auStack18 [2];
  uint16_t par_len;
  
  auStack18[0] = msg->param_len;
  phVar1 = hci_look_for_evt_desc(*(uint8_t *)&msg->src_id);
  if (phVar1 != (hci_evt_desc_tag *)0x0) {
    format = (code *)phVar1->par_fmt;
    if (format != (code *)0x0) {
      if (phVar1->special_pack == '\0') {
        hci_util_pack((uint8_t *)msg->param,auStack18,(char *)format);
      }
      else {
        (*format)(msg->param,auStack18,(uint)auStack18[0]);
      }
    }
    msg->param_len = auStack18[0];
  }
  return (uint8_t *)&msg->param_len;
}



uint8_t * hci_build_le_evt(ke_msg *msg)

{
  HCI_PACK_STATUS HVar1;
  hci_evt_desc_tag *phVar2;
  undefined3 extraout_var;
  uint uVar3;
  code *format;
  uint16_t auStack18 [2];
  uint16_t par_len;
  
  auStack18[0] = msg->param_len;
  phVar2 = hci_look_for_le_evt_desc(*(uint8_t *)msg->param);
  if ((phVar2 != (hci_evt_desc_tag *)0x0) &&
     (format = (code *)phVar2->par_fmt, format != (code *)0x0)) {
    if (phVar2->special_pack == '\0') {
      HVar1 = hci_util_pack((uint8_t *)msg->param,auStack18,(char *)format);
      uVar3 = CONCAT31(extraout_var,HVar1);
    }
    else {
      uVar3 = (*format)(msg->param,auStack18,(uint)auStack18[0]);
      uVar3 = uVar3 & 0xff;
    }
    if (uVar3 == 0) {
      msg->param_len = auStack18[0];
    }
  }
  return (uint8_t *)&msg->param_len;
}



uint8_t * hci_build_acl_rx_data(ke_msg *msg)

{
  byte bVar1;
  undefined2 uVar2;
  uint8_t *puVar3;
  uint uVar4;
  
  puVar3 = em_buf_rx_buff_addr_get((ushort)*(byte *)((int)&msg[1].hdr.next + 2));
  bVar1 = *(byte *)((int)msg->param + 2);
  uVar4 = (uint)*(ushort *)msg->param & 0xfff;
  puVar3[-4] = (uint8_t)uVar4;
  puVar3[-3] = (uint8_t)((((uint)bVar1 << 0xc | uVar4) << 0x10) >> 0x18);
  uVar2 = *(undefined2 *)&msg[1].hdr.next;
  puVar3[-2] = (uint8_t)uVar2;
  puVar3[-1] = (uint8_t)((ushort)uVar2 >> 8);
  return puVar3 + -4;
}



// WARNING: Type propagation algorithm not settling

co_list_hdr *
ble_ke_queue_extract
          (co_list *queue,anon_subr__Bool_co_list_hdr_ptr_uint32_t_conflict *func,uint32_t arg)

{
  co_list_hdr cVar1;
  _Bool _Var2;
  uint32_t uVar3;
  undefined3 extraout_var;
  co_list_hdr cStack36;
  co_list_hdr *element;
  
  uVar3 = (*_rom_patch_hook)(&cStack36,queue,func,arg,_rom_patch_hook);
  if (uVar3 == 0) {
    cVar1 = (co_list_hdr)0x0;
    cStack36 = (co_list_hdr)queue->first;
    while (cStack36 != (co_list_hdr)0x0) {
      _Var2 = (*func)((co_list_hdr *)cStack36,arg);
      if (CONCAT31(extraout_var,_Var2) != 0) {
        if (cVar1 == (co_list_hdr)0x0) {
          *(co_list_hdr *)&queue->first = *(co_list_hdr *)cStack36;
        }
        else {
          *(co_list_hdr *)cVar1 = *(co_list_hdr *)cStack36;
        }
        if (*(co_list_hdr *)cStack36 != (co_list_hdr)0x0) {
          *(co_list_hdr *)cStack36 = (co_list_hdr)0x0;
          return (co_list_hdr *)cStack36;
        }
        *(co_list_hdr *)&((co_list_hdr *)&queue->last)->next = cVar1;
        return (co_list_hdr *)cStack36;
      }
      cVar1 = cStack36;
      cStack36 = *(co_list_hdr *)cStack36;
    }
  }
  return (co_list_hdr *)cStack36;
}



// WARNING: Type propagation algorithm not settling

void ble_ke_queue_insert(co_list *queue,co_list_hdr *element,
                        anon_subr__Bool_co_list_hdr_ptr_co_list_hdr_ptr *cmp)

{
  co_list_hdr cVar1;
  co_list_hdr cVar2;
  _Bool _Var3;
  uint32_t uVar4;
  undefined3 extraout_var;
  co_list_hdr cVar5;
  
  uVar4 = (*_rom_patch_hook)((void *)0x0,queue,element,cmp,_rom_patch_hook);
  if (uVar4 == 0) {
    cVar1 = (co_list_hdr)queue->first;
    cVar5 = (co_list_hdr)(co_list_hdr *)0x0;
    while (cVar2 = cVar1, cVar2 != (co_list_hdr)0x0) {
      _Var3 = (*cmp)(element,(co_list_hdr *)cVar2);
      if (CONCAT31(extraout_var,_Var3) != 0) goto LAB_23016fe2;
      cVar1 = *(co_list_hdr *)cVar2;
      cVar5 = cVar2;
    }
    queue->last = element;
LAB_23016fe2:
    *(co_list_hdr *)&element->next = cVar2;
    if (cVar5 == (co_list_hdr)0x0) {
      queue->first = element;
    }
    else {
      ((co_list_hdr *)cVar5)->next = element;
    }
  }
  return;
}



_Bool ble_cmp_dest_id(co_list_hdr *msg,uint32_t dest_id)

{
  uint32_t uVar1;
  bool abStack17 [4];
  _Bool result;
  
  uVar1 = (*_rom_patch_hook)(abStack17,msg,dest_id,_rom_patch_hook);
  if (uVar1 == 0) {
    abStack17[0] = (uint)*(ushort *)((int)&msg[1].next + 2) == dest_id;
  }
  return (_Bool)abStack17[0];
}


/*
Unable to decompile 'ble_ke_task_saved_update'
Cause: Exception while decompiling 2301703c: Decompiler process died

*/


ke_msg_func_t * ble_ke_handler_search(ke_msg_id_t msg_id,ke_state_handler *state_handler)

{
  ushort uVar1;
  undefined2 in_register_0000202a;
  uint32_t uVar2;
  uint uVar3;
  ke_msg_func_t *pkStack20;
  ke_msg_func_t *func;
  
  uVar2 = (*_rom_patch_hook)(&pkStack20,CONCAT22(in_register_0000202a,msg_id),state_handler,
                             _rom_patch_hook);
  if (uVar2 == 0) {
    uVar3 = (uint)state_handler->msg_cnt;
    do {
      uVar3 = uVar3 - 1;
      if (uVar3 == 0xffffffff) {
        return (ke_msg_func_t *)0x0;
      }
      uVar1 = state_handler->msg_table[uVar3].id;
    } while ((CONCAT22(in_register_0000202a,msg_id) != (uint)uVar1) && (uVar1 != 0xffff));
    pkStack20 = state_handler->msg_table[uVar3].func;
  }
  return pkStack20;
}



// WARNING: Variable defined which should be unmapped: func

ke_msg_func_t * ble_ke_task_handler_get(ke_msg_id_t msg_id,ke_task_id_t task_id)

{
  uint uVar1;
  ke_task_desc *pkVar2;
  undefined2 in_register_0000202a;
  uint32_t uVar3;
  undefined2 in_register_0000202e;
  ke_msg_func_t *pkStack20;
  ke_msg_func_t *func;
  
  pkStack20 = (ke_msg_func_t *)0x0;
  uVar3 = (*_rom_patch_hook)(&pkStack20,CONCAT22(in_register_0000202a,msg_id),
                             CONCAT22(in_register_0000202e,task_id),_rom_patch_hook);
  if (uVar3 == 0) {
    pkVar2 = ble_ke_task_env.task_list[(uint)task_id & 0xff].p_desc;
    if ((pkVar2->idx_max != 0) &&
       (uVar1 = CONCAT22(in_register_0000202e,task_id) >> 8, uVar1 < pkVar2->idx_max)) {
      if (pkVar2->state_handler != (ke_state_handler *)0x0) {
        pkStack20 = ble_ke_handler_search(msg_id,pkVar2->state_handler + pkVar2->state[uVar1]);
      }
      if ((pkStack20 == (ke_msg_func_t *)0x0) &&
         (pkVar2->default_handler != (ke_state_handler *)0x0)) {
        pkStack20 = ble_ke_handler_search(msg_id,pkVar2->default_handler);
      }
    }
  }
  return pkStack20;
}


/*
Unable to decompile 'ble_ke_task_schedule'
Cause: Exception while decompiling 23017178: Decompiler process died

*/


void ble_ke_task_init(void)

{
  uint32_t uVar1;
  
  uVar1 = (*_rom_patch_hook)((void *)0x0,_rom_patch_hook);
  if (uVar1 == 0) {
    (*ble_memset_ptr)(&ble_ke_task_env,0,0x14);
    ble_ke_event_callback_set('\x02',ble_ke_task_schedule);
    return;
  }
  return;
}


/*
Unable to decompile 'ble_ke_task_create'
Cause: Exception while decompiling 2301725c: Decompiler process died

*/


void ble_ke_state_set(ke_task_id_t id,ke_state_t state_id)

{
  undefined2 in_register_0000202a;
  uint32_t uVar1;
  undefined3 in_register_0000202d;
  uint uVar2;
  ke_task_desc *pkVar3;
  byte *pbVar4;
  
  uVar1 = (*_rom_patch_hook)((void *)0x0,CONCAT22(in_register_0000202a,id),
                             CONCAT31(in_register_0000202d,state_id),_rom_patch_hook);
  if (uVar1 == 0) {
    if (((uint)id & 0xff) < 5) {
      pkVar3 = ble_ke_task_env.task_list[(uint)id & 0xff].p_desc;
      uVar2 = CONCAT22(in_register_0000202a,id) >> 8;
      if ((uVar2 < pkVar3->idx_max) &&
         (pbVar4 = pkVar3->state + uVar2, (uint)*pbVar4 != CONCAT31(in_register_0000202d,state_id)))
      {
        *pbVar4 = state_id;
        ble_ke_task_saved_update(id);
        return;
      }
    }
    else {
      ebreak();
    }
  }
  return;
}


/*
Unable to decompile 'ble_ke_state_get'
Cause: Exception while decompiling 2301732c: Decompiler process died

*/

/*
Unable to decompile 'llc_llcp_send'
Cause: Exception while decompiling 2301738e: Decompiler process died

*/


undefined4 llcp_ping_rsp_handler(int param_1,ke_task_id_t param_2)

{
  llc_env_tag *plVar1;
  byte bVar2;
  
  bVar2 = ble_ke_state_get(param_2);
  plVar1 = llc_env[param_1];
  if ((plVar1->encryption_state & 8) == 0) {
    if (((bVar2 & 1) != 0) && (plVar1->loc_proc_state == '\x05')) {
      ble_ke_state_set(param_2,bVar2 & 0xfe);
      plVar1->loc_proc_state = '\0';
      ble_ke_timer_clear(0x102,param_2);
    }
  }
  else {
    llc_util_dicon_procedure((uint16_t)param_1,'=');
  }
  return 0;
}



int llcp_terminate_ind_handler
              (uint16_t conhdl,ke_task_id_t dest_id,_Bool int_ctx,llcp_terminate_ind *param)

{
  uint8_t uVar1;
  undefined2 in_register_0000202a;
  undefined3 extraout_var;
  llc_env_tag *plVar2;
  
  ble_ke_timer_clear(0x102,dest_id);
  plVar2 = llc_env[CONCAT22(in_register_0000202a,conhdl)];
  plVar2->disc_reason = param->err_code;
  plVar2->llc_status = plVar2->llc_status | 0x200;
  ble_ke_state_set(dest_id,'\x0f');
  uVar1 = lld_get_mode(conhdl);
  if (CONCAT31(extraout_var,uVar1) == 4) {
    llc_util_dicon_procedure(conhdl,param->err_code);
  }
  return 0;
}


/*
Unable to decompile 'llcp_enc_rsp_handler'
Cause: Exception while decompiling 2301750c: Decompiler process died

*/


void llc_llcp_reject_ind(int param_1,ke_task_id_t param_2,int param_3,int param_4)

{
  byte bVar1;
  uint8_t uVar2;
  _Bool _Var3;
  uint16_t conhdl;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  llc_env_tag *plVar4;
  
  bVar1 = ble_ke_state_get(param_2);
  plVar4 = llc_env[param_1];
  ble_ke_timer_clear(0x102,param_2);
  conhdl = (uint16_t)param_1;
  if ((bVar1 & 1) == 0) {
    if ((((bVar1 & 2) != 0) && (param_4 != 0)) && ((llc_env[param_1]->encryption_state & 8) == 0)) {
      if (plVar4->rem_proc_state != '\x03') {
        return;
      }
      ble_ke_state_set(param_2,bVar1 & 0xfd);
      plVar4->rem_proc_state = '\0';
      return;
    }
LAB_23017802:
    if ((llc_env[param_1]->encryption_state & 8) == 0) {
      return;
    }
    llc_util_dicon_procedure(conhdl,'=');
    return;
  }
  switch((uint)plVar4->loc_proc_state - 4 & 0xff) {
  case 0:
    if ((llc_env[param_1]->encryption_state & 8) != 0) goto LAB_23017802;
    ble_ke_timer_clear(0x102,param_2);
    break;
  case 1:
    break;
  case 2:
  case 5:
    goto LAB_230177a4;
  case 3:
    if ((param_4 == 0) || ((llc_env[param_1]->encryption_state & 8) != 0)) goto LAB_23017802;
    ble_ke_timer_clear(0x102,param_2);
    if ((param_3 == 0x1a) && (uVar2 = lld_get_mode(conhdl), CONCAT31(extraout_var_00,uVar2) == 3)) {
      *(undefined *)llc_env[param_1]->operation[0] = 2;
      ble_ke_msg_send();
      return;
    }
    if ((plVar4->llc_status & 0x40) != 0) {
      plVar4->llc_status = plVar4->llc_status & 0xffbf;
      _Var3 = llm_util_check_evt_mask('\x02');
      if (CONCAT31(extraout_var_01,_Var3) != 0) {
        llc_con_update_complete_send((uint8_t)param_3,conhdl,(lld_evt_tag *)&plVar4->elt->env);
      }
    }
    llc_util_clear_operation_ptr(param_1,0);
    break;
  default:
    goto LAB_23017802;
  case 9:
  case 10:
  case 0xb:
  case 0xc:
    ble_ke_timer_clear(0x102,param_2);
    uVar2 = lld_get_mode(conhdl);
    if (CONCAT31(extraout_var,uVar2) != 3) {
      return;
    }
    if ((llc_env[param_1]->encryption_state & 0x10) != 0) {
      return;
    }
    llc_env[param_1]->encryption_state = '\0';
    llc_common_enc_change_evt_send(conhdl,'\0',(uint8_t)param_3);
    ble_ke_state_set(param_2,bVar1 & 0xfe);
    plVar4->loc_proc_state = '\0';
    ble_ke_state_set(param_2,bVar1 & 0xfa);
    return;
  }
  ble_ke_state_set(param_2,bVar1 & 0xfe);
  plVar4->loc_proc_state = '\0';
LAB_230177a4:
  return;
}



int llcp_reject_ind_ext_handler
              (uint16_t conhdl,ke_task_id_t dest_id,_Bool int_ctx,llcp_reject_ind_ext *param)

{
  undefined2 in_register_0000202a;
  
  llc_llcp_reject_ind(CONCAT22(in_register_0000202a,conhdl),(uint)param->err_code,1);
  return 0;
}



int llcp_reject_ind_handler
              (uint16_t conhdl,ke_task_id_t dest_id,_Bool int_ctx,llcp_reject_ind *param)

{
  undefined2 in_register_0000202a;
  
  llc_llcp_reject_ind(CONCAT22(in_register_0000202a,conhdl),(uint)param->err_code,0);
  return 0;
}


/*
Unable to decompile 'llcp_pause_enc_req_handler'
Cause: Exception while decompiling 23017858: Decompiler process died

*/


undefined4 llcp_start_enc_req_handler(int param_1,ke_task_id_t param_2)

{
  uint8_t uVar1;
  llc_env_tag *plVar2;
  byte bVar3;
  
  bVar3 = ble_ke_state_get(param_2);
  plVar2 = llc_env[param_1];
  if (((plVar2->encryption_state & 8) != 0) && ((plVar2->loc_proc_state - 0xe & 0xfd) != 0)) {
    llc_util_dicon_procedure((uint16_t)param_1,'=');
  }
  uVar1 = plVar2->loc_proc_state;
  if ((bVar3 & 1) == 0) {
    if (uVar1 == '\x0e') goto LAB_230179b4;
  }
  else {
    if (uVar1 == '\x0e') {
LAB_230179b4:
      plVar2->loc_proc_state = '\x0f';
      return 0;
    }
    if (uVar1 != '\x10') {
      return 0;
    }
  }
  plVar2->loc_proc_state = '\x11';
  ble_ke_msg_send_basic(0x106,param_2,param_2);
  return 0;
}


/*
Unable to decompile 'llcp_enc_req_handler'
Cause: Exception while decompiling 230179ca: Decompiler process died

*/


undefined4 llcp_unknown_rsp_handler(int param_1,ke_task_id_t param_2,int param_3)

{
  llc_env_tag *plVar1;
  byte bVar2;
  uint8_t uVar3;
  _Bool _Var4;
  uint16_t conhdl;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined *param;
  
  bVar2 = ble_ke_state_get(param_2);
  plVar1 = llc_env[param_1];
  conhdl = (uint16_t)param_1;
  if (((plVar1->encryption_state & 8) != 0) && (plVar1->loc_proc_state != '\r')) {
    llc_util_dicon_procedure(conhdl,'=');
    return 0;
  }
  if ((bVar2 & 1) == 0) {
    return 0;
  }
  switch((uint)plVar1->loc_proc_state - 1 & 0xff) {
  case 0:
    if (*(char *)(param_3 + 1) != '\x0e') {
      return 0;
    }
    ble_ke_timer_clear(0x102,param_2);
    llc_feats_rd_event_send('\x1a',conhdl,&plVar1->feats_used);
    break;
  default:
    goto switchD_23017b54_caseD_1;
  case 3:
    if (*(char *)(param_3 + 1) != '\x14') {
      return 0;
    }
    ble_ke_timer_clear(0x102,param_2);
    (plVar1->data_len_ext_info).send_req_not_allowed = true;
    _Var4 = llm_util_check_evt_mask('\x06');
    if ((CONCAT31(extraout_var_01,_Var4) != 0) &&
       (((plVar1->data_len_ext_info).data_len_ext_flag & 2) == 0)) {
      param = (undefined *)ble_ke_msg_alloc(0x804,conhdl,0x3e,0xc);
      *param = 7;
      *(uint16_t *)(param + 2) = conhdl;
      *(uint16_t *)(param + 8) = (plVar1->data_len_ext_info).conn_eff_max_rx_octets;
      *(uint16_t *)(param + 10) = (plVar1->data_len_ext_info).conn_eff_max_rx_time;
      *(uint16_t *)(param + 4) = (plVar1->data_len_ext_info).conn_eff_max_tx_octets;
      *(uint16_t *)(param + 6) = (plVar1->data_len_ext_info).conn_eff_max_tx_time;
      hci_send_2_host(param);
      (plVar1->data_len_ext_info).data_len_ext_flag =
           (plVar1->data_len_ext_info).data_len_ext_flag | 2;
    }
    break;
  case 4:
    if (*(char *)(param_3 + 1) != '\x12') {
      return 0;
    }
    ble_ke_state_set(param_2,bVar2 & 0xfe);
    plVar1->loc_proc_state = '\0';
    ble_ke_timer_clear(0x102,param_2);
    return 0;
  case 6:
    if (*(char *)(param_3 + 1) != '\x0f') {
      return 0;
    }
    ble_ke_timer_clear(0x102,param_2);
    plVar1->peer_sup_conn_param_req = false;
    uVar3 = lld_get_mode(conhdl);
    if (CONCAT31(extraout_var,uVar3) == 3) {
      *(undefined *)llc_env[param_1]->operation[0] = 2;
      ble_ke_msg_send();
      return 0;
    }
    if ((plVar1->llc_status & 0x40) != 0) {
      plVar1->llc_status = plVar1->llc_status & 0xffbf;
      _Var4 = llm_util_check_evt_mask('\x02');
      if (CONCAT31(extraout_var_00,_Var4) != 0) {
        llc_con_update_complete_send('\x1a',conhdl,(lld_evt_tag *)&plVar1->elt->env);
      }
    }
    llc_util_clear_operation_ptr(param_1,0);
    break;
  case 0xc:
    if ((plVar1->encryption_state & 0x10) != 0) {
      return 0;
    }
    plVar1->encryption_state = '\0';
    llc_common_enc_change_evt_send(conhdl,'\0','\x1a');
  }
  ble_ke_state_set(param_2,bVar2 & 0xfe);
  plVar1->loc_proc_state = '\0';
switchD_23017b54_caseD_1:
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

void llc_llcp_version_ind_pdu_send(uint16_t conhdl)

{
  undefined4 uStack24;
  llcp_vers_ind pdu;
  
  uStack24 = 0x7af090c;
  pdu._0_2_ = 0x321;
  llc_llcp_send((uint8_t)conhdl,&uStack24,'\f');
  return;
}



undefined4 llcp_vers_ind_handler(int param_1,ke_task_id_t param_2,int param_3)

{
  ushort uVar1;
  uint16_t uVar2;
  llc_env_tag *plVar3;
  byte bVar4;
  uint16_t conhdl;
  
  bVar4 = ble_ke_state_get(param_2);
  plVar3 = llc_env[param_1];
  conhdl = (uint16_t)param_1;
  if ((plVar3->encryption_state & 8) == 0) {
    uVar1 = plVar3->llc_status;
    (plVar3->peer_version).vers = *(uint8_t *)(param_3 + 1);
    (plVar3->peer_version).compid = *(uint16_t *)(param_3 + 2);
    uVar2 = *(uint16_t *)(param_3 + 4);
    plVar3->llc_status = uVar1 | 2;
    (plVar3->peer_version).subvers = uVar2;
    if (((bVar4 & 1) == 0) || (plVar3->loc_proc_state != '\x02')) {
      if (((int)(uint)uVar1 >> 1 & 1U) == 0) {
        llc_llcp_version_ind_pdu_send(conhdl);
      }
    }
    else {
      ble_ke_timer_clear(0x102,param_2);
      llc_version_rd_event_send('\0',conhdl);
      plVar3->loc_proc_state = '\0';
      ble_ke_state_set(param_2,bVar4 & 0xfe);
    }
  }
  else {
    llc_util_dicon_procedure(conhdl,'=');
  }
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

void llc_llcp_ch_map_update_pdu_send(uint16_t conhdl)

{
  llc_env_tag *plVar1;
  undefined2 in_register_0000202a;
  uint8_t uStack24;
  undefined auStack23 [3];
  llcp_channel_map_ind pdu;
  
  plVar1 = llc_env[CONCAT22(in_register_0000202a,conhdl)];
  uStack24 = '\x01';
  pdu.ch_map.map._1_2_ = lld_util_instant_get(&plVar1->elt->env,'\x02');
  (*ble_memcpy_ptr)(auStack23,&plVar1->n_ch_map,5);
  llc_llcp_send((uint8_t)conhdl,&uStack24,uStack24);
  return;
}



void llc_llcp_pause_enc_req_pdu_send(uint16_t conhdl)

{
  uint8_t auStack20 [4];
  llcp_pause_enc_req pdu;
  
  auStack20[0] = '\n';
  ble_ke_timer_set(0x102,conhdl << 8 | 1,4000);
  llc_llcp_send((uint8_t)conhdl,auStack20,auStack20[0]);
  return;
}



void llc_llcp_pause_enc_rsp_pdu_send(uint16_t conhdl)

{
  undefined2 in_register_0000202a;
  ushort *puVar1;
  undefined auStack20 [4];
  llcp_pause_enc_rsp pdu;
  
  auStack20[0] = 0xb;
  puVar1 = (ushort *)(CONCAT22(in_register_0000202a,conhdl) * 0x5c + 0x28008092);
  *puVar1 = *puVar1 & 0xfeff;
  llc_env[CONCAT22(in_register_0000202a,conhdl)]->encryption_state =
       llc_env[CONCAT22(in_register_0000202a,conhdl)]->encryption_state & 0xfd;
  llc_llcp_send((uint8_t)conhdl,auStack20,'\v');
  return;
}


/*
Unable to decompile 'llcp_pause_enc_rsp_handler'
Cause: Exception while decompiling 23017e72: Decompiler process died

*/


// WARNING: Variable defined which should be unmapped: pdu
// WARNING: Could not reconcile some variable overlaps

void llc_llcp_enc_req_pdu_send(uint16_t conhdl,hci_le_start_enc_cmd *param)

{
  int iVar1;
  undefined2 in_register_0000202a;
  llc_env_tag *plVar2;
  uint8_t uStack56;
  undefined auStack55 [3];
  llcp_enc_req pdu;
  
  uStack56 = '\x03';
  pdu.rand.nb[4] = (uint8_t)param->enc_div;
  pdu.rand.nb[5] = (uint8_t)(param->enc_div >> 8);
  plVar2 = llc_env[CONCAT22(in_register_0000202a,conhdl)];
  (*ble_memcpy_ptr)(auStack55,&param->nb,8);
  (*ble_memcpy_ptr)(pdu.skdm.skdiv + 4,(plVar2->encrypt).randn,4);
  iVar1 = CONCAT22(in_register_0000202a,conhdl) * 0x5c;
  (*ble_memcpy_ptr)(pdu.rand.nb + 6,(plVar2->encrypt).randn + 4,8);
  *(undefined2 *)(iVar1 + 0x280080c4) = pdu.skdm.skdiv._4_2_;
  *(undefined2 *)(iVar1 + 0x280080c6) = pdu.skdm.skdiv._6_2_;
  (*ble_memcpy_ptr)(&(plVar2->encrypt).ltk,&param->ltk,0x10);
  (*ble_memcpy_ptr)(&plVar2->encrypt,pdu.rand.nb + 6,8);
  *(ushort *)(iVar1 + 0x28008092) = *(ushort *)(iVar1 + 0x28008092) & 0xfeff;
  plVar2 = llc_env[CONCAT22(in_register_0000202a,conhdl)];
  plVar2->encryption_state = plVar2->encryption_state & 0xfd;
  ble_ke_timer_set(0x102,conhdl << 8 | 1,4000);
  llc_llcp_send((uint8_t)conhdl,&uStack56,uStack56);
  return;
}



// WARNING: Variable defined which should be unmapped: pdu
// WARNING: Could not reconcile some variable overlaps

void llc_llcp_enc_rsp_pdu_send(uint16_t conhdl,llcp_enc_req *param)

{
  llc_env_tag *plVar1;
  undefined2 in_register_0000202a;
  int iVar2;
  uint8_t local_20;
  undefined auStack31 [3];
  llcp_enc_rsp pdu;
  
  plVar1 = llc_env[CONCAT22(in_register_0000202a,conhdl)];
  local_20 = '\x04';
  (*ble_memcpy_ptr)(pdu.skds.skdiv + 4,(plVar1->encrypt).randn,4);
  (*ble_memcpy_ptr)(auStack31,(plVar1->encrypt).randn + 4,8);
  iVar2 = CONCAT22(in_register_0000202a,conhdl) * 0x5c;
  *(undefined2 *)(iVar2 + 0x280080c8) = pdu.skds.skdiv._4_2_;
  *(undefined2 *)(iVar2 + 0x280080ca) = pdu.skds.skdiv._6_2_;
  (*ble_memcpy_ptr)((plVar1->encrypt).skd.skd + 8,auStack31,8);
  llc_llcp_send((uint8_t)conhdl,&local_20,local_20);
  return;
}



void llc_llcp_start_enc_rsp_pdu_send(uint16_t conhdl)

{
  uint16_t rx_time;
  uint16_t tx_time;
  undefined2 in_register_0000202a;
  ushort *puVar1;
  llc_env_tag *plVar2;
  uint8_t auStack20 [4];
  llcp_start_enc_rsp pdu;
  
  auStack20[0] = '\x06';
  puVar1 = (ushort *)(CONCAT22(in_register_0000202a,conhdl) * 0x5c + 0x28008092);
  *puVar1 = *puVar1 | 0x300;
  plVar2 = llc_env[CONCAT22(in_register_0000202a,conhdl)];
  rx_time = (plVar2->data_len_ext_info).conn_eff_max_rx_time;
  tx_time = (plVar2->data_len_ext_info).conn_eff_max_tx_time;
  plVar2->encryption_state = plVar2->encryption_state | 3;
  lld_util_compute_ce_max(plVar2->elt,tx_time,rx_time);
  llc_llcp_send((uint8_t)conhdl,auStack20,auStack20[0]);
  return;
}


/*
Unable to decompile 'llcp_start_enc_rsp_handler'
Cause: Exception while decompiling 230181d8: Decompiler process died

*/


void llc_llcp_reject_ind_pdu_send(uint16_t conhdl,uint8_t rej_opcode,uint8_t reason)

{
  undefined2 in_register_0000202a;
  undefined3 in_register_0000202d;
  uint8_t opcode;
  llc_env_tag *plVar1;
  undefined uStack20;
  uint8_t uStack19;
  uint8_t uStack18;
  llcp_reject_ind_ext pdu;
  
  plVar1 = llc_env[CONCAT22(in_register_0000202a,conhdl)];
  if ((((plVar1->llc_status & 1) == 0) || (((plVar1->feats_used).feats[0] & 4) == 0)) &&
     (CONCAT31(in_register_0000202d,rej_opcode) < 0xe)) {
    uStack20 = 0xd;
    if ((CONCAT31(in_register_0000202d,rej_opcode) - 3 & 0xfd) == 0) {
      plVar1->encryption_state = '\0';
    }
    opcode = '\r';
    uStack19 = reason;
  }
  else {
    uStack20 = 0x11;
    opcode = '\x11';
    uStack19 = rej_opcode;
    uStack18 = reason;
  }
  llc_llcp_send((uint8_t)conhdl,&uStack20,opcode);
  return;
}


/*
Unable to decompile 'llcp_length_rsp_handler'
Cause: Exception while decompiling 230183ae: Decompiler process died

*/


int llcp_con_param_rsp_handler
              (uint16_t conhdl,ke_task_id_t dest_id,_Bool int_ctx,llcp_con_param_rsp *param)

{
  byte bVar1;
  uint8_t uVar2;
  _Bool _Var3;
  undefined2 in_register_0000202a;
  undefined3 extraout_var;
  undefined *puVar4;
  undefined3 extraout_var_00;
  llc_env_tag *plVar5;
  ushort uVar6;
  ea_elt_tag *peVar7;
  
  bVar1 = ble_ke_state_get(dest_id);
  plVar5 = llc_env[CONCAT22(in_register_0000202a,conhdl)];
  if ((plVar5->encryption_state & 8) == 0) {
    if (plVar5->loc_proc_state == '\a') {
      ble_ke_timer_clear(0x102,dest_id);
      uVar2 = lld_get_mode(conhdl);
      if (CONCAT31(extraout_var,uVar2) == 3) {
        plVar5 = llc_env[CONCAT22(in_register_0000202a,conhdl)];
        puVar4 = (undefined *)plVar5->operation[0];
        if ((*(ushort *)(puVar4 + 4) < param->interval_min) ||
           (param->interval_max < *(ushort *)(puVar4 + 2))) {
          peVar7 = plVar5->elt;
          llc_llcp_reject_ind_pdu_send(conhdl,'\x10',' ');
          if ((plVar5->llc_status & 0x40) != 0) {
            plVar5->llc_status = plVar5->llc_status & 0xffbf;
            _Var3 = llm_util_check_evt_mask('\x02');
            if (CONCAT31(extraout_var_00,_Var3) != 0) {
              llc_con_update_complete_send(' ',conhdl,(lld_evt_tag *)&peVar7->env);
            }
          }
          ble_ke_state_set(dest_id,bVar1 & 0xfe);
          plVar5->loc_proc_state = '\0';
          llc_util_clear_operation_ptr(CONCAT22(in_register_0000202a,conhdl),0);
        }
        else {
          *puVar4 = 4;
          *(uint16_t *)(puVar4 + 2) = param->interval_min;
          *(uint16_t *)(puVar4 + 4) = param->interval_max;
          uVar6 = param->latency;
          if (param->latency < *(ushort *)(puVar4 + 6)) {
            uVar6 = *(ushort *)(puVar4 + 6);
          }
          *(ushort *)(puVar4 + 6) = uVar6;
          uVar6 = param->timeout;
          if (param->timeout < *(ushort *)(puVar4 + 8)) {
            uVar6 = *(ushort *)(puVar4 + 8);
          }
          *(ushort *)(puVar4 + 8) = uVar6;
          *(ushort *)(puVar4 + 10) = plVar5->elt->duration_min / 0x271;
          *(ushort *)(puVar4 + 0xc) = plVar5->elt->duration_min / 0x271;
          ble_ke_msg_send();
        }
      }
    }
    else {
      llc_llcp_reject_ind_pdu_send(conhdl,param->opcode,'\x1f');
    }
  }
  else {
    llc_util_dicon_procedure(conhdl,'=');
  }
  return 0;
}



undefined4 llcp_feats_rsp_handler(int param_1,ke_task_id_t param_2,uint8_t *param_3)

{
  byte *pbVar1;
  llc_env_tag *plVar2;
  byte bVar3;
  uint16_t conhdl;
  le_features *plVar4;
  encrypt_conflict1 *peVar5;
  encrypt_conflict1 *peVar6;
  
  bVar3 = ble_ke_state_get(param_2);
  plVar2 = llc_env[param_1];
  conhdl = (uint16_t)param_1;
  if ((plVar2->encryption_state & 8) == 0) {
    if (((bVar3 & 1) == 0) || (plVar2->loc_proc_state != '\x01')) {
      llc_llcp_reject_ind_pdu_send(conhdl,*param_3,'\x11');
    }
    else {
      ble_ke_timer_clear(0x102,(ushort)(param_1 << 8) | 1);
      plVar4 = (le_features *)(param_3 + 1);
      peVar5 = (encrypt_conflict1 *)&plVar2->feats_used;
      do {
        pbVar1 = plVar4->feats;
        peVar6 = (encrypt_conflict1 *)((peVar5->skd).skd + 1);
        plVar4 = (le_features *)(plVar4->feats + 1);
        (peVar5->skd).skd[0] = (peVar5->skd).skd[0] & *pbVar1;
        peVar5 = peVar6;
      } while (peVar6 != &plVar2->encrypt);
      plVar2->llc_status = plVar2->llc_status | 1;
      llc_feats_rd_event_send('\0',conhdl,(le_features *)(param_3 + 1));
      plVar2->loc_proc_state = '\0';
      ble_ke_state_set(param_2,bVar3 & 0xfe);
    }
  }
  else {
    llc_util_dicon_procedure(conhdl,'=');
  }
  return 0;
}



int llcp_channel_map_ind_handler(int param_1,ke_task_id_t param_2,int param_3,uint8_t *param_4)

{
  uint16_t instant;
  ushort uVar1;
  llc_env_tag *plVar2;
  byte bVar3;
  _Bool _Var4;
  uint8_t reason;
  uint16_t conhdl;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  int iVar5;
  ea_elt_tag *elt;
  
  bVar3 = ble_ke_state_get(param_2);
  plVar2 = llc_env[param_1];
  iVar5 = (uint)(param_3 != 0) << 1;
  conhdl = (uint16_t)param_1;
  if (param_3 == 0) {
    if (param_4[-1] == 0) goto LAB_230187c6;
    switch((uint)param_4[-1] - 1 & 0xff) {
    case 0:
      goto switchD_23018802_caseD_0;
    case 1:
      goto switchD_23018802_caseD_1;
    case 2:
switchD_23018802_caseD_2:
      reason = '(';
      goto LAB_230188ae;
    case 3:
      goto switchD_23018802_caseD_3;
    case 4:
      goto switchD_23018802_caseD_4;
    default:
      return iVar5;
    }
  }
  param_4[-1] = '\0';
LAB_230187c6:
  if ((llc_env[param_1]->encryption_state & 8) != 0) {
    param_4[-1] = '\x04';
    if (param_3 != 0) {
      return iVar5;
    }
switchD_23018802_caseD_3:
    reason = '=';
LAB_230188ae:
    llc_util_dicon_procedure(conhdl,reason);
    return iVar5;
  }
  _Var4 = lld_util_instant_ongoing(plVar2->elt);
  if (CONCAT31(extraout_var,_Var4) == 0) {
    reason = lld_get_mode(conhdl);
    if ((CONCAT31(extraout_var_00,reason) == 4) && ((bVar3 & 2) == 0)) {
      elt = plVar2->elt;
      instant = *(uint16_t *)(param_4 + 6);
      if ((ushort)(instant - *(short *)&elt[2].timestamp) < 0x7fff) {
        memcpy(&plVar2->n_ch_map,param_4 + 1,5);
        lld_ch_map_ind(elt,instant);
        param_4[-1] = '\x01';
        if (param_3 != 0) {
          return iVar5;
        }
switchD_23018802_caseD_0:
        uVar1 = plVar2->llc_status;
        if (-1 < (int)((uint)uVar1 << 0x14)) {
          plVar2->llc_status = uVar1 | 0x400;
          plVar2->rem_proc_state = '\x01';
          ble_ke_state_set(param_2,bVar3 | 2);
          return iVar5;
        }
        plVar2->llc_status = uVar1 & 0xf7ff;
        return iVar5;
      }
      param_4[-1] = '\x03';
      if (param_3 != 0) {
        return iVar5;
      }
      goto switchD_23018802_caseD_2;
    }
    param_4[-1] = '\x05';
    if (param_3 != 0) {
      return iVar5;
    }
switchD_23018802_caseD_4:
    reason = '\x11';
    goto LAB_230188ba;
  }
  param_4[-1] = '\x02';
  if (param_3 != 0) {
    return iVar5;
  }
switchD_23018802_caseD_1:
  reason = '#';
LAB_230188ba:
  llc_llcp_reject_ind_pdu_send(conhdl,*param_4,reason);
  return iVar5;
}



int llcp_con_upd_ind_handler(int param_1,ke_task_id_t param_2,int param_3,llcp_con_upd_ind *param_4)

{
  byte bVar1;
  ushort uVar2;
  llc_env_tag *plVar3;
  byte state_id;
  _Bool _Var4;
  uint8_t reason;
  uint16_t conhdl;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  int iVar5;
  
  plVar3 = llc_env[param_1];
  state_id = ble_ke_state_get(param_2);
  iVar5 = (uint)(param_3 != 0) << 1;
  conhdl = (uint16_t)param_1;
  if (param_3 == 0) {
    bVar1 = *(byte *)((int)&param_4[-1].instant + 1);
    if (bVar1 == 0) goto LAB_23018932;
    switch((uint)bVar1 - 1 & 0xff) {
    case 0:
      goto switchD_23018970_caseD_0;
    case 1:
      goto switchD_23018970_caseD_1;
    case 2:
switchD_23018970_caseD_2:
      reason = '(';
      goto LAB_23018a84;
    case 3:
      goto switchD_23018970_caseD_3;
    case 4:
      goto switchD_23018970_caseD_4;
    default:
      return iVar5;
    }
  }
  *(undefined *)((int)&param_4[-1].instant + 1) = 0;
LAB_23018932:
  if ((llc_env[param_1]->encryption_state & 8) != 0) {
    *(undefined *)((int)&param_4[-1].instant + 1) = 4;
    if (param_3 != 0) {
      return iVar5;
    }
switchD_23018970_caseD_3:
    reason = '=';
LAB_23018a84:
    llc_util_dicon_procedure(conhdl,reason);
    return iVar5;
  }
  _Var4 = lld_util_instant_ongoing(plVar3->elt);
  if (CONCAT31(extraout_var,_Var4) == 0) {
    reason = lld_get_mode(conhdl);
    if (CONCAT31(extraout_var_00,reason) == 4) {
      if ((ushort)(param_4->instant - *(short *)&plVar3->elt[2].timestamp) < 0x7fff) {
        uVar2 = *(ushort *)&plVar3->elt[2].ea_cb_stop >> 1;
        if ((uint)uVar2 <= (uint)param_4->win_size) {
          param_4->win_size = (char)uVar2 + -1;
        }
        plVar3->n_sup_to = param_4->timeout;
        lld_con_update_ind(plVar3->elt,param_4);
        *(undefined *)((int)&param_4[-1].instant + 1) = 1;
        if (param_3 != 0) {
          return iVar5;
        }
switchD_23018970_caseD_0:
        if (((state_id & 1) != 0) && ((byte)(plVar3->loc_proc_state - 7) < 2)) {
          ble_ke_timer_clear(0x102,param_2);
          state_id = state_id & 0xfe;
          plVar3->loc_proc_state = '\0';
          ble_ke_state_set(param_2,state_id);
          llc_util_clear_operation_ptr(param_1,0);
        }
        if (plVar3->rem_proc_state == '\x03') {
          ble_ke_timer_clear(0x102,param_2);
        }
        uVar2 = plVar3->llc_status;
        if (-1 < (int)((uint)uVar2 << 0x14)) {
          plVar3->llc_status = uVar2 | 0x400;
          plVar3->rem_proc_state = '\x04';
          ble_ke_state_set(param_2,state_id | 2);
          return iVar5;
        }
        plVar3->llc_status = uVar2 & 0xf7ff;
        return iVar5;
      }
      *(undefined *)((int)&param_4[-1].instant + 1) = 3;
      if (param_3 != 0) {
        return iVar5;
      }
      goto switchD_23018970_caseD_2;
    }
    *(undefined *)((int)&param_4[-1].instant + 1) = 5;
    if (param_3 != 0) {
      return iVar5;
    }
switchD_23018970_caseD_4:
    reason = '\x11';
    goto LAB_23018988;
  }
  *(undefined *)((int)&param_4[-1].instant + 1) = 2;
  if (param_3 != 0) {
    return iVar5;
  }
switchD_23018970_caseD_1:
  reason = '#';
LAB_23018988:
  llc_llcp_reject_ind_pdu_send(conhdl,param_4->opcode,reason);
  return iVar5;
}



// WARNING: Could not reconcile some variable overlaps

void llc_llcp_con_update_pdu_send(uint16_t conhdl,llcp_con_upd_ind *param)

{
  undefined uStack28;
  uint8_t uStack27;
  uint16_t uStack26;
  llcp_con_upd_ind pdu;
  
  uStack27 = param->win_size;
  uStack26 = param->win_off;
  uStack28 = 0;
  pdu._0_2_ = param->interv;
  pdu.win_off = param->latency;
  pdu.interv = param->timeout;
  pdu.latency = param->instant;
  llc_llcp_send((uint8_t)conhdl,&uStack28,'\0');
  return;
}



// WARNING: Could not reconcile some variable overlaps

void llc_llcp_con_param_req_pdu_send(uint16_t conhdl,llc_con_upd_req_ind *param)

{
  undefined auStack44 [2];
  uint16_t uStack42;
  llcp_con_param_req pdu;
  
  auStack44[0] = 0xf;
  uStack42 = param->interval_min;
  pdu._0_2_ = param->interval_max;
  pdu.interval_min = param->con_latency;
  pdu.interval_max = param->superv_to;
  pdu.latency._0_1_ = param->pref_period;
  pdu.timeout = param->ref_con_event_count;
  pdu._10_2_ = param->offset0;
  pdu.ref_con_event_count = param->offset1;
  pdu.offset0 = param->offset2;
  pdu.offset1 = param->offset3;
  pdu.offset2 = param->offset4;
  pdu.offset3 = param->offset5;
  llc_llcp_send((uint8_t)conhdl,auStack44,'\x0f');
  return;
}



// WARNING: Could not reconcile some variable overlaps

void llc_llcp_con_param_rsp_pdu_send(uint16_t conhdl,llc_con_upd_req_ind *param)

{
  undefined auStack44 [2];
  uint16_t uStack42;
  llcp_con_param_rsp pdu;
  
  auStack44[0] = 0x10;
  uStack42 = param->interval_min;
  pdu._0_2_ = param->interval_max;
  pdu.interval_min = param->con_latency;
  pdu.interval_max = param->superv_to;
  pdu.latency._0_1_ = param->pref_period;
  pdu.timeout = param->ref_con_event_count;
  pdu._10_2_ = param->offset0;
  pdu.ref_con_event_count = param->offset1;
  pdu.offset0 = param->offset2;
  pdu.offset1 = param->offset3;
  pdu.offset2 = param->offset4;
  pdu.offset3 = param->offset5;
  llc_llcp_send((uint8_t)conhdl,auStack44,'\x10');
  return;
}



undefined4 llcp_con_param_req_handler(int param_1,ke_task_id_t param_2,uint8_t *param_3)

{
  ushort uVar1;
  ushort uVar2;
  byte bVar3;
  uint8_t reason;
  _Bool _Var4;
  uint16_t conhdl;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined *puVar5;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  uint8_t rej_opcode;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  llc_env_tag *plVar9;
  llc_con_upd_req_ind lStack68;
  
  bVar3 = ble_ke_state_get(param_2);
  plVar9 = llc_env[param_1];
  conhdl = (uint16_t)param_1;
  if ((plVar9->encryption_state & 8) != 0) {
    llc_util_dicon_procedure(conhdl,'=');
    return 0;
  }
  if ((bVar3 & 2) == 0) {
    reason = lld_get_mode(conhdl);
    if ((CONCAT31(extraout_var,reason) != 3) || ((bVar3 & 1) == 0)) {
LAB_23018c86:
      uVar1 = *(ushort *)(param_3 + 2);
      uVar7 = (uint)*(ushort *)(param_3 + 4);
      if (((((uVar7 < uVar1) || (uVar2 = *(ushort *)(param_3 + 6), 499 < uVar2)) ||
           (0xc80 < *(ushort *)(param_3 + 4))) ||
          ((uVar1 < 6 || (uVar6 = (uint)*(ushort *)(param_3 + 8), 0xc76 < (uVar6 - 10 & 0xffff)))))
         || (uVar6 << 2 <= ((uint)uVar2 + 1) * uVar7)) {
        reason = '\x1e';
      }
      else {
        uVar8 = (uint)(*(ushort *)&plVar9->elt[2].ea_cb_stop >> 1);
        if (((uVar8 < uVar1) || (uVar7 < uVar8)) ||
           (((uint)uVar2 != (uint)*(ushort *)((int)&plVar9->elt[2].linked_element + 2) - 1 ||
            ((uint)plVar9->sup_to != uVar6)))) {
          _Var4 = llm_util_check_evt_mask('\x05');
          if (CONCAT31(extraout_var_00,_Var4) != 0) {
            puVar5 = (undefined *)ble_ke_msg_alloc(0x109,param_2,param_2,0x22);
            *puVar5 = 3;
            goto LAB_23018d1c;
          }
          reason = '\x1a';
        }
        else {
          reason = lld_get_mode(conhdl);
          if (CONCAT31(extraout_var_01,reason) == 3) {
            puVar5 = (undefined *)ble_ke_msg_alloc(0x109,param_2,param_2,0x22);
            *puVar5 = 2;
            *(undefined2 *)(puVar5 + 2) = *(undefined2 *)(param_3 + 2);
            *(undefined2 *)(puVar5 + 4) = *(undefined2 *)(param_3 + 4);
            *(uint16_t *)(puVar5 + 8) = plVar9->sup_to;
            *(ushort *)(puVar5 + 10) = plVar9->elt->duration_min / 0x271;
            *(ushort *)(puVar5 + 0xc) = plVar9->elt->duration_min / 0x271;
LAB_23018d1c:
            *(undefined2 *)(puVar5 + 0xe) = *(undefined2 *)(param_3 + 2);
            *(undefined2 *)(puVar5 + 0x10) = *(undefined2 *)(param_3 + 4);
            *(undefined2 *)(puVar5 + 6) = *(undefined2 *)(param_3 + 6);
            *(undefined2 *)(puVar5 + 8) = *(undefined2 *)(param_3 + 8);
            puVar5[0x12] = param_3[10];
            *(undefined2 *)(puVar5 + 0x14) = *(undefined2 *)(param_3 + 0xc);
            *(undefined2 *)(puVar5 + 0x16) = *(undefined2 *)(param_3 + 0xe);
            *(undefined2 *)(puVar5 + 0x18) = *(undefined2 *)(param_3 + 0x10);
            *(undefined2 *)(puVar5 + 0x1a) = *(undefined2 *)(param_3 + 0x12);
            *(undefined2 *)(puVar5 + 0x1c) = *(undefined2 *)(param_3 + 0x14);
            *(undefined2 *)(puVar5 + 0x1e) = *(undefined2 *)(param_3 + 0x16);
            *(undefined2 *)(puVar5 + 0x20) = *(undefined2 *)(param_3 + 0x18);
            ble_ke_msg_send();
            return 0;
          }
          reason = lld_get_mode(conhdl);
          if (CONCAT31(extraout_var_02,reason) != 4) {
            return 0;
          }
          lStack68.interval_min = *(uint16_t *)(param_3 + 2);
          lStack68.interval_max = *(uint16_t *)(param_3 + 4);
          lStack68.con_latency = *(uint16_t *)(param_3 + 6);
          lStack68.superv_to = *(uint16_t *)(param_3 + 8);
          lStack68.pref_period = param_3[10];
          lStack68.ref_con_event_count = *(uint16_t *)(param_3 + 0xc);
          lStack68.offset0 = *(uint16_t *)(param_3 + 0xe);
          lStack68.offset1 = *(uint16_t *)(param_3 + 0x10);
          lStack68.offset2 = *(uint16_t *)(param_3 + 0x12);
          lStack68.offset3 = *(uint16_t *)(param_3 + 0x14);
          lStack68.offset4 = *(uint16_t *)(param_3 + 0x16);
          lStack68.offset5 = *(uint16_t *)(param_3 + 0x18);
          reason = lld_con_param_rsp(conhdl,plVar9->elt,&lStack68);
          if (CONCAT31(extraout_var_03,reason) == 0) {
            plVar9->rem_proc_state = '\x03';
            ble_ke_state_set(param_2,bVar3 | 2);
            llc_llcp_con_param_rsp_pdu_send(conhdl,&lStack68);
            ble_ke_timer_set(0x102,param_2,4000);
            return 0;
          }
          reason = ' ';
        }
      }
      rej_opcode = '\x0f';
      goto LAB_23018c50;
    }
    reason = plVar9->loc_proc_state;
    if ((reason == '\a') || (reason == '\t')) goto LAB_23018c48;
    if (reason != '\x06') goto LAB_23018c86;
    reason = '*';
  }
  else {
LAB_23018c48:
    reason = '#';
  }
  rej_opcode = *param_3;
LAB_23018c50:
  llc_llcp_reject_ind_pdu_send(conhdl,rej_opcode,reason);
  return 0;
}



void llc_llcp_feats_req_pdu_send(uint16_t conhdl)

{
  uint8_t uVar1;
  undefined3 extraout_var;
  uint8_t uStack28;
  undefined auStack27 [3];
  llcp_feats_req pdu;
  
  uVar1 = lld_get_mode(conhdl);
  uStack28 = '\x0e';
  if (CONCAT31(extraout_var,uVar1) == 3) {
    uStack28 = '\b';
  }
  llm_util_get_supp_features((le_features *)auStack27);
  llc_llcp_send((uint8_t)conhdl,&uStack28,uStack28);
  return;
}



void llc_llcp_feats_rsp_pdu_send(uint16_t conhdl)

{
  undefined2 in_register_0000202a;
  uint8_t uStack28;
  uint8_t auStack27 [3];
  llcp_feats_rsp pdu;
  
  uStack28 = '\t';
  llm_util_get_supp_features((le_features *)auStack27);
  auStack27[0] = (llc_env[CONCAT22(in_register_0000202a,conhdl)]->feats_used).feats[0];
  llc_llcp_send((uint8_t)conhdl,&uStack28,uStack28);
  return;
}



void llc_llcp_start_enc_req_pdu_send(uint16_t conhdl)

{
  undefined2 in_register_0000202a;
  int iVar1;
  undefined auStack20 [4];
  llcp_start_enc_req pdu;
  
  iVar1 = CONCAT22(in_register_0000202a,conhdl) * 0x5c;
  *(ushort *)(iVar1 + 0x28008092) = *(ushort *)(iVar1 + 0x28008092) | 0x100;
  llc_env[CONCAT22(in_register_0000202a,conhdl)]->encryption_state =
       llc_env[CONCAT22(in_register_0000202a,conhdl)]->encryption_state | 2;
  *(undefined2 *)(iVar1 + 0x280080cc) = 0;
  *(undefined2 *)(iVar1 + 0x280080ce) = 0;
  *(undefined2 *)(iVar1 + 0x280080d0) = 0;
  *(undefined2 *)(iVar1 + 0x280080d2) = 0;
  *(undefined2 *)(iVar1 + 0x280080d4) = 0;
  *(undefined2 *)(iVar1 + 0x280080d6) = 0;
  auStack20[0] = 5;
  llc_llcp_send((uint8_t)conhdl,auStack20,'\x05');
  return;
}



// WARNING: Variable defined which should be unmapped: pdu

void llc_llcp_terminate_ind_pdu_send(uint16_t conhdl,uint8_t err_code)

{
  byte bVar1;
  ushort id;
  undefined2 in_register_0000202a;
  undefined3 in_register_0000202d;
  uint8_t uVar2;
  llc_env_tag *plVar3;
  uint8_t uStack20;
  uint8_t uStack19;
  llcp_terminate_ind pdu;
  
  id = conhdl << 8 | 1;
  plVar3 = llc_env[CONCAT22(in_register_0000202a,conhdl)];
  bVar1 = ble_ke_state_get(id);
  uVar2 = '\x16';
  if (CONCAT31(in_register_0000202d,err_code) != 0x13) {
    uVar2 = err_code;
  }
  plVar3->disc_reason = uVar2;
  uStack20 = '\x02';
  uStack19 = err_code;
  ble_ke_state_set(id,bVar1 | 0xf);
  llc_llcp_send((uint8_t)conhdl,&uStack20,uStack20);
  ble_ke_timer_set(0x102,id,(uint)plVar3->sup_to);
  return;
}



void llc_llcp_unknown_rsp_send_pdu(uint16_t conhdl,uint8_t unk_type)

{
  undefined uStack20;
  uint8_t uStack19;
  llcp_unknown_rsp pdu;
  
  uStack20 = 7;
  uStack19 = unk_type;
  llc_llcp_send((uint8_t)conhdl,&uStack20,'\a');
  return;
}



int llc_llcp_unknown_ind_handler(uint16_t conhdl,uint8_t opcode)

{
  undefined2 in_register_0000202a;
  
  if ((llc_env[CONCAT22(in_register_0000202a,conhdl)]->encryption_state & 8) == 0) {
    llc_llcp_unknown_rsp_send_pdu(conhdl,opcode);
  }
  else {
    llc_util_dicon_procedure(conhdl,'=');
  }
  return 0;
}



int llcp_feats_req_handler(uint16_t conhdl,ke_task_id_t dest_id,_Bool int_ctx,llcp_feats_req *param)

{
  uint8_t uVar1;
  undefined2 in_register_0000202a;
  undefined3 extraout_var;
  encrypt_conflict1 *peVar2;
  encrypt_conflict1 *peVar3;
  llc_env_tag *plVar4;
  
  plVar4 = llc_env[CONCAT22(in_register_0000202a,conhdl)];
  uVar1 = lld_get_mode(conhdl);
  if ((CONCAT31(extraout_var,uVar1) == 4) || (param->opcode != '\b')) {
    if ((llc_env[CONCAT22(in_register_0000202a,conhdl)]->encryption_state & 8) == 0) {
      peVar2 = (encrypt_conflict1 *)&plVar4->feats_used;
      do {
        param = (llcp_feats_req *)&param->feats;
        peVar3 = (encrypt_conflict1 *)((peVar2->skd).skd + 1);
        (peVar2->skd).skd[0] = (peVar2->skd).skd[0] & param->opcode;
        peVar2 = peVar3;
      } while (peVar3 != &plVar4->encrypt);
      plVar4->llc_status = plVar4->llc_status | 1;
      llc_llcp_feats_rsp_pdu_send(conhdl);
    }
    else {
      llc_util_dicon_procedure(conhdl,'=');
    }
  }
  else {
    llc_llcp_unknown_ind_handler(conhdl,'\b');
  }
  return 0;
}



int llcp_slave_feature_req_handler
              (uint16_t conhdl,ke_task_id_t dest_id,_Bool int_ctx,llcp_slave_feature_req *param)

{
  uint8_t uVar1;
  undefined3 extraout_var;
  int iVar2;
  
  uVar1 = lld_get_mode(conhdl);
  if (CONCAT31(extraout_var,uVar1) == 3) {
    iVar2 = llcp_feats_req_handler(conhdl,dest_id,int_ctx,(llcp_feats_req *)param);
    return iVar2;
  }
  llc_llcp_unknown_ind_handler(conhdl,'\x0e');
  return 0;
}



void llc_llcp_ping_req_pdu_send(uint16_t conhdl)

{
  undefined auStack20 [4];
  llcp_ping_req pdu;
  
  auStack20[0] = 0x12;
  llc_llcp_send((uint8_t)conhdl,auStack20,'\x12');
  return;
}



void llc_llcp_ping_rsp_pdu_send(uint16_t conhdl)

{
  undefined auStack20 [4];
  llcp_ping_rsp pdu;
  
  auStack20[0] = 0x13;
  llc_llcp_send((uint8_t)conhdl,auStack20,'\x13');
  return;
}



int llcp_ping_req_handler(uint16_t conhdl,ke_task_id_t dest_id,_Bool int_ctx,void *param)

{
  undefined2 in_register_0000202a;
  
  if ((llc_env[CONCAT22(in_register_0000202a,conhdl)]->encryption_state & 8) == 0) {
    llc_llcp_ping_rsp_pdu_send(conhdl);
  }
  else {
    llc_util_dicon_procedure(conhdl,'=');
  }
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

void llc_llcp_length_req_pdu_send(uint16_t conhdl)

{
  undefined2 in_register_0000202a;
  llc_env_tag *plVar1;
  undefined auStack28 [2];
  uint16_t uStack26;
  llcp_length_req pdu;
  
  plVar1 = llc_env[CONCAT22(in_register_0000202a,conhdl)];
  auStack28[0] = 0x14;
  uStack26 = (plVar1->data_len_ext_info).conn_max_rx_octets;
  pdu._0_2_ = (plVar1->data_len_ext_info).conn_max_rx_time;
  pdu.max_rx_octets = (plVar1->data_len_ext_info).conn_max_tx_octets;
  pdu.max_rx_time = (plVar1->data_len_ext_info).conn_max_tx_time;
  llc_llcp_send((uint8_t)conhdl,auStack28,'\x14');
  return;
}



// WARNING: Could not reconcile some variable overlaps

void llc_llcp_length_rsp_pdu_send(uint16_t conhdl)

{
  undefined2 in_register_0000202a;
  llc_env_tag *plVar1;
  undefined auStack28 [2];
  uint16_t uStack26;
  llcp_length_rsp pdu;
  
  plVar1 = llc_env[CONCAT22(in_register_0000202a,conhdl)];
  auStack28[0] = 0x15;
  uStack26 = (plVar1->data_len_ext_info).conn_max_rx_octets;
  pdu._0_2_ = (plVar1->data_len_ext_info).conn_max_rx_time;
  pdu.max_rx_octets = (plVar1->data_len_ext_info).conn_max_tx_octets;
  pdu.max_rx_time = (plVar1->data_len_ext_info).conn_max_tx_time;
  llc_llcp_send((uint8_t)conhdl,auStack28,'\x15');
  return;
}


/*
Unable to decompile 'llcp_length_req_handler'
Cause: Exception while decompiling 23019254: Decompiler process died

*/


// WARNING: Exceeded maximum restarts with more pending

int llc_llcp_recv_handler(uint param_1,int param_2,byte *param_3,int param_4)

{
  byte bVar1;
  int iVar2;
  
  bVar1 = ble_ke_state_get((ke_task_id_t)param_1);
  if ((bVar1 & 0x7f) != 0x7f) {
    if ((((bVar1 & 0xf) != 0xf) || ((*param_3 & 0xfb) == 2)) &&
       ((llc_env[param_1 >> 8]->llc_status & 8) == 0)) {
      if (param_2 == 0) {
        if ((param_4 == 0) || (llcp_pdu_handler[*param_3].int_ctx_allowed != false)) {
                    // WARNING: Could not recover jumptable at 0x23019450. Too many branches
                    // WARNING: Treating indirect jump as call
          iVar2 = (*llcp_pdu_handler[*param_3].handler)((uint16_t)param_1,(ke_task_id_t)param_3);
          return iVar2;
        }
      }
      else {
        if ((param_2 == 0x19) && (param_4 == 0)) {
          iVar2 = llc_llcp_unknown_ind_handler((uint16_t)(param_1 >> 8),*param_3);
          return iVar2;
        }
      }
    }
  }
  return (uint)(param_4 != 0) << 1;
}



uint8_t llc_llcp_get_autorize(uint8_t opcode)

{
  undefined3 in_register_00002029;
  
  if (CONCAT31(in_register_00002029,opcode) < 0x16) {
    return llcp_pdu_handler[CONCAT31(in_register_00002029,opcode)].enc_auth;
  }
  return '\0';
}



int llc_dft_handler(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  return 0;
}



undefined4 llm_enc_ind_handler(int param_1,uint param_2)

{
  byte id;
  uint8_t uVar1;
  uint16_t conhdl;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined2 *puVar2;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  uint uVar3;
  llc_env_tag *plVar4;
  
  _id = (ke_task_id_t)param_2;
  id = ble_ke_state_get(_id);
  if ((id & 0xf) != 0xf) {
    plVar4 = llc_env[param_2 >> 8];
    conhdl = (uint16_t)(param_2 >> 8);
    if (((plVar4->loc_proc_state == '\x13') &&
        (uVar1 = lld_get_mode(conhdl), CONCAT31(extraout_var_01,uVar1) == 3)) ||
       ((plVar4->rem_proc_state == '\x0e' &&
        (uVar1 = lld_get_mode(conhdl), CONCAT31(extraout_var,uVar1) == 4)))) {
      (*ble_memcpy_ptr)((plVar4->encrypt).randn,(void *)(param_1 + 1),0x10);
    }
    else {
      uVar1 = lld_get_mode(conhdl);
      if (((CONCAT31(extraout_var_00,uVar1) != 4) || ((id & 2) == 0)) ||
         (plVar4->rem_proc_state != '\n')) {
        uVar1 = lld_get_mode(conhdl);
        if (CONCAT31(extraout_var_02,uVar1) != 3) {
          return 0;
        }
        if ((id & 1) == 0) {
          return 0;
        }
        if (1 < (byte)(plVar4->loc_proc_state - 0xe)) {
          return 0;
        }
      }
      puVar2 = (undefined2 *)((param_2 >> 8) * 0x5c + 0x280080b4);
      uVar3 = 0xf;
      do {
        *puVar2 = CONCAT11(*(undefined *)(param_1 + uVar3),((undefined *)(param_1 + uVar3))[1]);
        uVar3 = uVar3 - 2 & 0xff;
        puVar2 = puVar2 + 1;
      } while (uVar3 != 0xff);
    }
    ble_ke_msg_send_basic(0x106,_id,_id);
  }
  return 0;
}



int llc_llcp_recv_ind_handler
              (ke_msg_id_t msgid,llc_llcp_recv_ind *ind,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  int iVar1;
  undefined2 in_register_00002032;
  
  iVar1 = llc_llcp_recv_handler(CONCAT22(in_register_00002032,dest_id),(uint)ind->status,ind->pdu,0)
  ;
  return iVar1;
}



undefined4 llc_chmap_update_req_ind_handler(uint param_1)

{
  byte bVar1;
  uint16_t conhdl;
  int iVar2;
  llc_env_tag *plVar3;
  
  bVar1 = ble_ke_state_get((ke_task_id_t)param_1);
  if (((bVar1 & 0xf) != 0xf) && ((bVar1 & 4) == 0)) {
    if ((bVar1 & 1) != 0) {
      return 2;
    }
    plVar3 = llc_env[param_1 >> 8];
    conhdl = (uint16_t)(param_1 >> 8);
    _conhdl = llc_ch_assess_get_current_ch_map(conhdl);
    iVar2 = (*ble_memcmp_ptr)(_conhdl,&plVar3->n_ch_map,5);
    if (iVar2 != 0) {
      ble_ke_state_set((ke_task_id_t)param_1,bVar1 | 1);
      plVar3->loc_proc_state = '\x06';
      llc_llcp_ch_map_update_pdu_send(conhdl);
    }
  }
  return 0;
}



undefined4 llc_auth_payl_real_to_ind_handler(uint param_1)

{
  byte id;
  ke_task_id_t *param;
  llc_env_tag *plVar1;
  
  _id = (ke_task_id_t)param_1;
  id = ble_ke_state_get(_id);
  if ((id & 0xf) != 0xf) {
    plVar1 = llc_env[param_1 >> 8];
    ble_ke_timer_set(0x103,_id,(uint)plVar1->auth_payl_to - (uint)plVar1->auth_payl_to_margin);
    ble_ke_timer_set(0x104,_id,(uint)llc_env[param_1 >> 8]->auth_payl_to);
    _id = (ke_task_id_t)(param_1 >> 8);
    param = (ke_task_id_t *)ble_ke_msg_alloc(0x803,_id,0x57,2);
    *param = _id;
    hci_send_2_host(param);
  }
  return 0;
}



undefined4 llc_con_upd_req_ind_handler(llc_con_upd_req_ind *param_1,uint param_2)

{
  byte id;
  _Bool _Var1;
  uint8_t uVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined *param;
  undefined3 extraout_var_01;
  uint16_t dest_id;
  uint uVar3;
  llc_env_tag *plVar4;
  llcp_con_upd_ind lStack44;
  
  _id = (ke_task_id_t)param_2;
  id = ble_ke_state_get(_id);
  if ((id & 0xf) == 0xf) {
    return 0;
  }
  uVar3 = param_2 >> 8;
  if (((id & 1) != 0) && (llc_env[uVar3]->operation[0] == (void *)0x0)) {
    return 2;
  }
  if (((id & 2) != 0) && (llc_env[uVar3]->rem_proc_state == '\x04')) {
    return 2;
  }
  if ((id & 4) != 0) {
    return 2;
  }
  plVar4 = llc_env[uVar3];
  if (4 < param_1->operation) {
    return 0;
  }
  dest_id = (uint16_t)(param_2 >> 8);
  switch(param_1->operation) {
  case '\x01':
    param_1->superv_to = plVar4->sup_to;
    break;
  case '\x02':
    uVar2 = lld_get_mode(dest_id);
    if (CONCAT31(extraout_var_01,uVar2) != 3) {
      return 0;
    }
  case '\x04':
    lld_con_update_after_param_req(dest_id,plVar4->elt,param_1,&lStack44,true);
    goto LAB_23019826;
  case '\x03':
    param = (undefined *)ble_ke_msg_alloc(0x804,dest_id,0x3e,0xc);
    *param = 6;
    *(uint16_t *)(param + 2) = dest_id;
    *(uint16_t *)(param + 4) = param_1->interval_min;
    *(uint16_t *)(param + 6) = param_1->interval_max;
    *(uint16_t *)(param + 8) = param_1->con_latency;
    *(uint16_t *)(param + 10) = param_1->superv_to;
    hci_send_2_host(param);
    *(llc_con_upd_req_ind **)(llc_env[uVar3]->operation + 1) = param_1;
    plVar4->rem_proc_state = '\x02';
    ble_ke_state_set(_id,id | 2);
    return 1;
  }
  param_1->pref_period = '\0';
  if ((plVar4->peer_sup_conn_param_req == false) ||
     ((((plVar4->llc_status & 1) != 0 && (((plVar4->feats_used).feats[0] & 2) == 0)) &&
      (_Var1 = llm_util_check_evt_mask('\x05'), CONCAT31(extraout_var,_Var1) != 0)))) {
    param_1->interval_min = param_1->con_intv_min;
    param_1->interval_max = param_1->con_intv_max;
    uVar2 = lld_get_mode(dest_id);
    if (CONCAT31(extraout_var_00,uVar2) != 3) {
      return 0;
    }
    lld_con_update_req(plVar4->elt,param_1,&lStack44);
LAB_23019826:
    plVar4->n_sup_to = param_1->superv_to;
    llc_llcp_con_update_pdu_send(dest_id,&lStack44);
    param_1->interval_min = lStack44.interv;
    param_1->con_latency = lStack44.latency;
    ble_ke_state_set(_id,id | 1);
    plVar4->loc_proc_state = '\t';
  }
  else {
    if (param_1->operation != '\x01') {
      plVar4->llc_status = plVar4->llc_status | 0x40;
      lld_con_param_req(dest_id,plVar4->elt,param_1);
    }
    llc_llcp_con_param_req_pdu_send(dest_id,param_1);
    ble_ke_state_set(_id,id | 1);
    plVar4->loc_proc_state = '\a';
    ble_ke_timer_set(0x102,_id,4000);
  }
  *(llc_con_upd_req_ind **)llc_env[uVar3]->operation = param_1;
  return 1;
}



undefined4 llc_length_req_ind_handler(uint param_1)

{
  llc_env_tag *plVar1;
  byte id;
  void *pvVar2;
  
  _id = (ke_task_id_t)param_1;
  id = ble_ke_state_get(_id);
  if ((id & 0xf) != 0xf) {
    if ((id & 5) != 0) {
      return 2;
    }
    plVar1 = llc_env[param_1 >> 8];
    pvVar2 = plVar1->operation[3];
    if (pvVar2 != (void *)0x0) {
      (plVar1->data_len_ext_info).conn_max_tx_octets = *(uint16_t *)((int)pvVar2 + 2);
      (plVar1->data_len_ext_info).conn_max_tx_time = *(uint16_t *)((int)pvVar2 + 4);
    }
    llc_util_clear_operation_ptr(param_1 >> 8,3);
    if (((plVar1->data_len_ext_info).data_len_ext_flag & 1) == 0) {
      ble_ke_state_set(_id,id | 1);
      plVar1->loc_proc_state = '\x04';
      llc_llcp_length_req_pdu_send((uint16_t)(param_1 >> 8));
      ble_ke_timer_set(0x102,_id,4000);
    }
  }
  return 0;
}



void llc_task_random_gen_request(ke_task_id_t dest_id)

{
  void *pvVar1;
  void *pvVar2;
  void *pvVar3;
  int iStack36;
  uint32_t randn;
  
  pvVar2 = ble_ke_msg_alloc(4,0,dest_id,0x20);
  iStack36 = 0;
  pvVar1 = pvVar2;
  do {
    iStack36 = bl_rand();
    (*ble_memcpy_ptr)(pvVar1,&iStack36,4);
    iStack36 = bl_rand();
    pvVar3 = (void *)((int)pvVar1 + 0x10);
    pvVar1 = (void *)((int)pvVar1 + 4);
    (*ble_memcpy_ptr)(pvVar3,&iStack36,4);
  } while (pvVar1 != (void *)((int)pvVar2 + 0x10));
  ble_ke_msg_send(pvVar2);
  return;
}



undefined4 llc_enc_mgt_ind_handler(uint param_1)

{
  byte bVar1;
  uint uVar2;
  void *pvVar3;
  byte id;
  uint8_t conhdl;
  _Bool _Var4;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  hci_le_start_enc_cmd *param;
  llc_env_tag *plVar5;
  int iVar6;
  llc_env_tag **pplVar7;
  
  _id = (ke_task_id_t)param_1;
  id = ble_ke_state_get(_id);
  if ((id & 0xf) == 0xf) {
    return 0;
  }
  uVar2 = param_1 >> 8;
  _conhdl = (uint16_t)(param_1 >> 8);
  conhdl = lld_get_mode(_conhdl);
  if (CONCAT31(extraout_var,conhdl) == 3) {
    if ((id & 1) == 0) {
      return 0;
    }
    plVar5 = llc_env[uVar2];
    switch((uint)plVar5->loc_proc_state - 10 & 0xff) {
    case 0:
      if ((plVar5->encryption_state & 3) == 3) {
        plVar5->encryption_state = plVar5->encryption_state | 0x30;
        llc_env[uVar2]->loc_proc_state = '\v';
        llc_llcp_pause_enc_req_pdu_send(_conhdl);
        return 0;
      }
    case 2:
      llc_task_random_gen_request(_id);
      llc_env[uVar2]->loc_proc_state = '\x13';
      break;
    case 4:
      plVar5->loc_proc_state = '\x10';
      break;
    case 5:
    case 7:
      iVar6 = uVar2 * 0x5c;
      *(undefined2 *)(iVar6 + 0x280080cc) = 0;
      *(undefined2 *)(iVar6 + 0x280080ce) = 0;
      *(undefined2 *)(iVar6 + 0x280080d0) = 0;
      *(undefined2 *)(iVar6 + 0x280080d2) = 0;
      *(undefined2 *)(iVar6 + 0x280080d4) = 0;
      *(undefined2 *)(iVar6 + 0x280080d6) = 0;
      llc_env[uVar2]->loc_proc_state = '\x12';
      llc_llcp_start_enc_rsp_pdu_send(_conhdl);
      goto LAB_23019b1c;
    case 9:
      plVar5->loc_proc_state = '\r';
      param = (hci_le_start_enc_cmd *)plVar5->operation[2];
      llc_env[uVar2]->encryption_state = llc_env[uVar2]->encryption_state & 0xdf;
      llc_llcp_enc_req_pdu_send(_conhdl,param);
      goto LAB_23019ab4;
    }
  }
  else {
    if ((id & 2) == 0) {
      return 0;
    }
    pplVar7 = llc_env + uVar2;
    plVar5 = *pplVar7;
    bVar1 = plVar5->rem_proc_state;
    if (bVar1 == 8) {
      _Var4 = llm_util_check_evt_mask('\x04');
      if (CONCAT31(extraout_var_00,_Var4) != 0) {
        llc_task_random_gen_request(_id);
        (*pplVar7)->rem_proc_state = '\x0e';
        return 0;
      }
      if (((*pplVar7)->encryption_state & 0x10) == 0) {
        if ((id & 1) != 0) {
          ble_ke_timer_set(0x102,_id,4000);
        }
        llc_llcp_reject_ind_pdu_send(_conhdl,'\x03','\x06');
        ble_ke_state_set(_id,id & 0xfd);
        ble_ke_state_set(_id,id & 0xf9);
        llc_env[uVar2]->rem_proc_state = '\0';
      }
      else {
        llc_llcp_terminate_ind_pdu_send(_conhdl,'\x06');
      }
    }
    else {
      if (bVar1 < 9) {
        if (bVar1 != 5) {
          return 0;
        }
        plVar5->encryption_state = plVar5->encryption_state | 0x30;
        plVar5->rem_proc_state = '\x06';
        llc_llcp_pause_enc_rsp_pdu_send(_conhdl);
LAB_23019b1c:
        ble_ke_timer_set(0x102,_id,4000);
        return 0;
      }
      if (bVar1 == 10) {
        llc_llcp_start_enc_req_pdu_send(_conhdl);
        (*pplVar7)->rem_proc_state = '\v';
        goto LAB_23019b1c;
      }
      if (bVar1 != 0xe) {
        return 0;
      }
      pvVar3 = plVar5->operation[2];
      plVar5->rem_proc_state = '\t';
      (*ble_memcpy_ptr)(&plVar5->encrypt,(void *)((int)pvVar3 + 0xd),8);
      *(undefined2 *)(uVar2 * 0x5c + 0x280080c4) = *(undefined2 *)((int)pvVar3 + 0x15);
      *(undefined2 *)(uVar2 * 0x5c + 0x280080c6) = *(undefined2 *)((int)pvVar3 + 0x17);
      llc_llcp_enc_rsp_pdu_send(_conhdl,(llcp_enc_req *)((int)pvVar3 + 2));
      llc_ltk_req_send(_conhdl,(llcp_enc_req *)((int)pvVar3 + 2));
    }
LAB_23019ab4:
    llc_util_clear_operation_ptr(uVar2,2);
  }
  return 0;
}



undefined4 llc_chnl_assess_timer_handler(uint param_1)

{
  byte id;
  uint8_t conhdl;
  undefined3 extraout_var;
  uint8_t uVar1;
  llc_env_tag *plVar2;
  le_chnl_map lStack48;
  le_chnl_map alStack40 [4];
  
  plVar2 = llc_env[param_1 >> 8];
  _id = (ke_task_id_t)param_1;
  id = ble_ke_state_get(_id);
  if ((id & 0xf) != 0xf) {
    if (plVar2->loc_proc_state != '\x06') {
      llm_util_get_channel_map(alStack40);
      _conhdl = (uint16_t)(param_1 >> 8);
      conhdl = llc_ch_assess_get_local_ch_map(_conhdl,&lStack48,alStack40);
      uVar1 = (plVar2->chnl_assess).reassess_count + -1;
      (plVar2->chnl_assess).reassess_count = uVar1;
      if ((uVar1 == '\0') || (CONCAT31(extraout_var,conhdl) < 2)) {
        llc_ch_assess_reass_ch(_conhdl,&lStack48,alStack40,conhdl);
      }
      (*ble_memcpy_ptr)(&plVar2->n_ch_map,&lStack48,5);
      ble_ke_msg_send_basic(0x108,_id,_id);
    }
    ble_ke_timer_set(0x105,_id,(uint)llm_le_env.ch_map_assess.assess_timer);
  }
  return 0;
}



int llc_llcp_rsp_to_ind_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  undefined2 in_register_00002032;
  
  llc_util_dicon_procedure((uint16_t)(CONCAT22(in_register_00002032,dest_id) >> 8),'\"');
  return 0;
}



undefined4 llc_link_sup_to_ind_handler(uint param_1)

{
  byte bVar1;
  
  bVar1 = ble_ke_state_get((ke_task_id_t)param_1);
  if ((bVar1 & 0x7f) != 0x7f) {
    if ((*(byte *)((int)&llc_env[param_1 >> 8]->elt[2].ea_cb_cancel + 2) & 2) == 0) {
      llc_util_dicon_procedure((uint16_t)(param_1 >> 8),'\b');
    }
    else {
      ble_ke_timer_set(0x101,(ke_task_id_t)param_1 & 0xff00 | 1,(uint)llc_env[param_1 >> 8]->sup_to)
      ;
    }
  }
  return 0;
}



undefined4 llc_auth_payl_nearly_to_ind_handler(uint param_1)

{
  byte id;
  _Bool _Var1;
  undefined3 extraout_var;
  
  _id = (ke_task_id_t)param_1;
  id = ble_ke_state_get(_id);
  if ((id & 0xf) != 0xf) {
    if ((id & 1) == 0) {
      if ((id & 4) != 0) {
        return 2;
      }
      _Var1 = ble_ke_timer_active(0x102,_id);
      if (CONCAT31(extraout_var,_Var1) == 0) {
        ble_ke_state_set(_id,id | 1);
        llc_env[param_1 >> 8]->loc_proc_state = '\x05';
        llc_llcp_ping_req_pdu_send((uint16_t)(param_1 >> 8));
        ble_ke_timer_set(0x102,_id,4000);
      }
    }
    else {
      if (llc_env[param_1 >> 8]->loc_proc_state != '\x05') {
        return 2;
      }
    }
  }
  return 0;
}



undefined4 llc_data_ind_handler(void *param_1,uint param_2)

{
  byte bVar1;
  uint16_t conhdl;
  
  bVar1 = ble_ke_state_get((ke_task_id_t)param_2);
  if ((bVar1 & 0xf) == 0xf) {
    em_buf_rx_free(*(uint8_t *)((int)param_1 + 6));
  }
  else {
    conhdl = (uint16_t)(param_2 >> 8);
    if ((llc_env[param_2 >> 8]->encryption_state & 8) == 0) {
      *(undefined2 *)((int)param_1 + -8) = 0x806;
      *(uint16_t *)((int)param_1 + -6) = conhdl;
      hci_send_2_host(param_1);
      return 1;
    }
    em_buf_rx_free(*(uint8_t *)((int)param_1 + 6));
    llc_util_dicon_procedure(conhdl,'=');
  }
  return 0;
}



undefined4 lld_stop_ind_handler(uint param_1)

{
  uint uVar1;
  ke_state_t id;
  byte bVar2;
  _Bool _Var3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  uint16_t conhdl;
  ushort *puVar4;
  uint8_t status;
  llc_env_tag *plVar5;
  
  _id = (ke_task_id_t)param_1;
  id = ble_ke_state_get(_id);
  if (CONCAT31(extraout_var,id) != 0x7f) {
    uVar1 = param_1 >> 8;
    puVar4 = (ushort *)(uVar1 * 0x5c + 0x28008092);
    *puVar4 = *puVar4 & 0xfcff;
    plVar5 = llc_env[uVar1];
    status = plVar5->disc_reason;
    bVar2 = ble_ke_state_get(_id);
    if ((CONCAT31(extraout_var_00,bVar2) != 0xf) &&
       (status = '\b', (llc_env[uVar1]->llc_status & 0x100) == 0)) {
      status = '>';
    }
    if ((bVar2 & 1) != 0) {
      conhdl = (uint16_t)(param_1 >> 8);
      switch((uint)plVar5->loc_proc_state - 1 & 0xff) {
      case 0:
        llc_feats_rd_event_send(status,conhdl,&plVar5->feats_used);
        break;
      case 1:
        llc_version_rd_event_send(status,conhdl);
        break;
      case 6:
      case 7:
      case 8:
        _Var3 = llm_util_check_evt_mask('\x02');
        if ((CONCAT31(extraout_var_01,_Var3) != 0) && ((plVar5->llc_status & 0x40) != 0)) {
          llc_con_update_complete_send(status,conhdl,(lld_evt_tag *)0x0);
        }
        break;
      case 9:
      case 10:
      case 0xb:
      case 0xc:
      case 0xd:
      case 0xe:
      case 0xf:
      case 0x10:
      case 0x11:
      case 0x12:
        if ((llc_env[uVar1]->encryption_state & 0x10) == 0) {
          llc_common_enc_change_evt_send(conhdl,'\0',status);
        }
        else {
          llc_common_enc_key_ref_comp_evt_send(conhdl,status);
        }
      }
    }
    llc_discon_event_complete_send(_id,'\0',(uint8_t)(param_1 >> 8),status);
    ble_ke_timer_clear(0x101,_id);
    ble_ke_timer_clear(0x102,_id);
    ble_ke_timer_clear(0x103,_id);
    ble_ke_timer_clear(0x104,_id);
    llc_stop(uVar1);
  }
  return 0;
}


/*
Unable to decompile 'llc_check_trafic_paused'
Cause: Exception while decompiling 23019ffe: Decompiler process died

*/


uint8_t llc_util_get_free_conhdl(uint16_t *conhdl)

{
  ke_state_t kVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  uint16_t uVar2;
  
  kVar1 = ble_ke_state_get(1);
  if (CONCAT31(extraout_var,kVar1) == 0x7f) {
    uVar2 = 0;
  }
  else {
    kVar1 = ble_ke_state_get(0x101);
    if (CONCAT31(extraout_var_00,kVar1) != 0x7f) {
      return '\t';
    }
    uVar2 = 1;
  }
  *conhdl = uVar2;
  return '\0';
}



uint8_t llc_util_get_nb_active_link(void)

{
  bool bVar1;
  ke_state_t kVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  
  kVar2 = ble_ke_state_get(1);
  bVar1 = CONCAT31(extraout_var,kVar2) != 0x7f;
  kVar2 = ble_ke_state_get(0x101);
  if (CONCAT31(extraout_var_00,kVar2) != 0x7f) {
    bVar1 = (bool)(bVar1 + '\x01');
  }
  return (uint8_t)bVar1;
}


/*
Unable to decompile 'llc_util_dicon_procedure'
Cause: Exception while decompiling 2301a0d8: Decompiler process died

*/


// WARNING: Exceeded maximum restarts with more pending

void llc_util_update_channel_map(uint16_t conhdl,le_chnl_map *map)

{
  undefined2 in_register_0000202a;
  
                    // WARNING: Could not recover jumptable at 0x2301a14c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*ble_memcpy_ptr)(&llc_env[CONCAT22(in_register_0000202a,conhdl)]->ch_map,(void *)0x5);
  return;
}



void llc_util_set_auth_payl_to_margin(lld_evt_tag *evt)

{
  int iVar1;
  uint16_t uVar2;
  uint uVar3;
  
  iVar1 = (uint)evt->interval * (uint)*(ushort *)(evt->evt + 10);
  uVar3 = iVar1 * 8;
  while ((uint)llc_env[evt->conhdl]->auth_payl_to << 4 < uVar3) {
    uVar3 = uVar3 - iVar1;
  }
  uVar2 = (uint16_t)(uVar3 >> 4);
  if (uVar3 >> 4 == 0) {
    uVar2 = 1;
  }
  llc_env[evt->conhdl]->auth_payl_to_margin = uVar2;
  return;
}



void llc_util_clear_operation_ptr(int param_1,int param_2)

{
  void *pvVar1;
  
  pvVar1 = llc_env[param_1]->operation[param_2];
  if (pvVar1 != (void *)0x0) {
    llc_env[param_1]->operation[param_2] = (void *)0x0;
    ble_ke_msg_free((ke_msg *)((int)pvVar1 + -0xc));
    return;
  }
  return;
}



void llc_util_bw_mgt(uint16_t conhdl)

{
  uint uVar1;
  uint uVar2;
  ea_elt_tag *elt_connect;
  uint8_t uVar3;
  undefined2 in_register_0000202a;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  llc_env_tag *plVar4;
  
  plVar4 = llc_env[CONCAT22(in_register_0000202a,conhdl)];
  if (plVar4 == (llc_env_tag *)0x0) {
    return;
  }
  elt_connect = plVar4->elt;
  uVar1 = (uint)(plVar4->data_len_ext_info).conn_eff_max_rx_time +
          (uint)(plVar4->data_len_ext_info).conn_eff_max_tx_time + 0x96;
  uVar2 = uVar1 & 0xffff;
  if ((uint)*(ushort *)(elt_connect[1].ea_cb_cancel + 8) * 0x2710000 >> 0x10 < uVar2) {
    *(short *)(elt_connect[1].ea_cb_cancel + 8) = (short)((int)(uVar2 + 0x270) / 0x271);
    uVar3 = lld_get_mode(conhdl);
    if (CONCAT31(extraout_var,uVar3) == 3) {
      elt_connect->duration_min = (uint16_t)(uVar1 * 0x10000 >> 0x10);
    }
    uVar3 = llc_util_get_nb_active_link();
    if (CONCAT31(extraout_var_00,uVar3) != 1) {
      lld_util_anchor_point_move(elt_connect);
      return;
    }
  }
  return;
}



void llc_end_evt_defer(int param_1)

{
  byte bVar1;
  llc_env_tag *plVar2;
  
  if (llc_env[param_1] != (llc_env_tag *)0x0) {
    bVar1 = ble_ke_state_get((ushort)(param_1 << 8) | 1);
    if ((bVar1 & 0xf) == 0xf) {
      plVar2 = llc_env[param_1];
      if ((plVar2->llc_status & 0x200) != 0) {
        plVar2->llc_status = plVar2->llc_status & 0xfdff;
        llc_util_dicon_procedure((uint16_t)param_1,plVar2->disc_reason);
      }
    }
    llc_util_bw_mgt((uint16_t)param_1);
    return;
  }
  return;
}


/*
Unable to decompile 'llc_pdu_llcp_tx_ack_defer'
Cause: Exception while decompiling 2301a29a: Decompiler process died

*/


void llc_pdu_acl_tx_ack_defer(uint16_t conhdl,uint8_t tx_cnt)

{
  undefined2 in_register_0000202a;
  undefined3 in_register_0000202d;
  
  if (llc_env[CONCAT22(in_register_0000202a,conhdl)] != (llc_env_tag *)0x0) {
    if (CONCAT31(in_register_0000202d,tx_cnt) != 0) {
      llc_common_nb_of_pkt_comp_evt_send(conhdl,tx_cnt);
    }
    llc_check_trafic_paused((uint8_t)conhdl);
    return;
  }
  return;
}



void llc_pdu_defer(uint16_t conhdl,uint16_t status,uint8_t rssi,uint8_t channel,uint8_t length)

{
  int8_t iVar1;
  undefined2 in_register_0000202a;
  int iVar2;
  ushort task_id;
  undefined2 in_register_0000202e;
  undefined3 in_register_00002035;
  undefined3 in_register_00002039;
  llc_env_tag *plVar3;
  llc_env_tag **pplVar4;
  llc_env_tag *plVar5;
  
  iVar2 = CONCAT22(in_register_0000202a,conhdl);
  pplVar4 = llc_env + iVar2;
  plVar5 = *pplVar4;
  if (plVar5 != (llc_env_tag *)0x0) {
    iVar1 = (*rwip_rf.rssi_convert)(rssi);
    plVar3 = *pplVar4;
    plVar5->rssi = iVar1;
    llc_ch_assess_local(iVar2,CONCAT22(in_register_0000202e,status),(int)plVar3->rssi,
                        CONCAT31(in_register_00002035,channel));
    if ((status & 0x1d) == 0) {
      task_id = conhdl << 8 | 1;
      ble_ke_timer_set(0x101,task_id,(uint)(*pplVar4)->sup_to);
      if (((((status & 0x120) == 0) && (CONCAT31(in_register_00002039,length) != 0)) &&
          (plVar5 = *pplVar4, (plVar5->encryption_state & 3) == 3)) &&
         ((plVar5->llc_status & 8) == 0)) {
        ble_ke_timer_set(0x103,task_id,
                         (uint)plVar5->auth_payl_to - (uint)plVar5->auth_payl_to_margin);
        ble_ke_timer_set(0x104,task_id,(uint)(*pplVar4)->auth_payl_to);
      }
    }
    else {
      if ((status & 0x10) != 0) {
        llc_util_dicon_procedure(conhdl,'=');
      }
    }
    plVar5 = llc_env[iVar2];
    if ((plVar5->llc_status & 0x20) != 0) {
      plVar5->llc_status = plVar5->llc_status & 0xffdf;
      plVar5->sup_to = plVar5->n_sup_to;
    }
  }
  return;
}



int llm_dft_handler(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  return 0;
}



int llm_le_set_host_ch_class_cmd_sto_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  llm_le_env.ch_map_assess.llm_le_set_host_ch_class_cmd_sto = true;
  return 0;
}



int llm_ecc_result_ind_handler
              (ke_msg_id_t msgid,ecc_result_ind *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  undefined *param_00;
  _Bool _Var1;
  undefined3 extraout_var;
  undefined *puVar2;
  undefined3 extraout_var_00;
  
  if (llm_le_env.cur_ecc_multiplication == LLM_DHKEY_GENERATION) {
    _Var1 = llm_util_check_evt_mask('\b');
    if (CONCAT31(extraout_var,_Var1) == 0) {
      llm_le_env.cur_ecc_multiplication = LLM_ECC_IDLE;
      return 0;
    }
    param_00 = (undefined *)ble_ke_msg_alloc(0x804,0,0x3e,0x22);
    *param_00 = 9;
    param_00[1] = 0;
    puVar2 = param_00 + 2;
  }
  else {
    if (llm_le_env.cur_ecc_multiplication != LLM_PUBLIC_KEY_GENERATION) {
      llm_le_env.cur_ecc_multiplication = LLM_ECC_IDLE;
      return 0;
    }
    _Var1 = llm_util_check_evt_mask('\a');
    if (CONCAT31(extraout_var_00,_Var1) == 0) {
      llm_le_env.cur_ecc_multiplication = LLM_ECC_IDLE;
      return 0;
    }
    param_00 = (undefined *)ble_ke_msg_alloc(0x804,0,0x3e,0x42);
    *param_00 = 8;
    param_00[1] = 0;
    (*ble_memcpy_ptr)(param_00 + 2,param,0x20);
    param = (ecc_result_ind *)param->key_res_y;
    puVar2 = param_00 + 0x22;
  }
  (*ble_memcpy_ptr)(puVar2,param,0x20);
  hci_send_2_host(param_00);
  llm_le_env.cur_ecc_multiplication = LLM_ECC_IDLE;
  return 0;
}



int llm_enc_req_handler(ke_msg_id_t msgid,llm_enc_req *param,ke_task_id_t dest_id,
                       ke_task_id_t src_id)

{
  ble_co_list_push_back(&llm_le_env,param[-1].plain_data + 4);
  if (llm_le_env.enc_pend == false) {
    llm_encryption_start(param);
  }
  return 1;
}



int lld_stop_ind_handler(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  byte bVar1;
  ke_state_t kVar2;
  undefined3 extraout_var;
  byte state_id;
  
  bVar1 = ble_ke_state_get(0);
  if (((bVar1 & 0xf0) != 0x20) && (bVar1 = ble_ke_state_get(0), (bVar1 & 0xf) != 3)) {
    return 0;
  }
  kVar2 = ble_ke_state_get(0);
  if (CONCAT31(extraout_var,kVar2) == 0x23) {
    if ((llm_le_env.state & 0xf0) == 0x10) {
      llm_common_cmd_complete_send(llm_le_env.opcode,'\0');
      llm_le_env.state = llm_le_env.state & 0xf;
    }
    llm_le_env.elt = (ea_elt_tag *)0x0;
    if ((byte)(llm_le_env.state2 - 1) < 2) {
LAB_2301a6d0:
      llm_common_cmd_complete_send(llm_le_env.opcode2,'\0');
      if (llm_le_env.state2 == '\x02') {
        llc_le_con_cmp_evt_send('\x02',0xffff,(llc_create_con_req_ind *)0x0);
      }
      llm_le_env.state2 = llm_le_env.state2 & 0xf0;
    }
  }
  else {
    bVar1 = ble_ke_state_get(0);
    if (((bVar1 & 0xf0) == 0x20) && (llm_le_env.last_opcode == false)) {
      if ((llm_le_env.state & 0xf0) == 0x10) {
        llm_common_cmd_complete_send(llm_le_env.opcode,'\0');
        llm_le_env.state = llm_le_env.state & 0xf;
      }
      llm_le_env.elt = (ea_elt_tag *)0x0;
      goto LAB_2301a702;
    }
    bVar1 = ble_ke_state_get(0);
    if (((bVar1 & 0xf) != 3) || (llm_le_env.last_opcode == false)) {
      do {
                    // WARNING: Do nothing block with infinite loop
      } while( true );
    }
    if (((byte)(llm_le_env.state2 - 1) < 2) || (llm_le_env.state2 == '\x11')) goto LAB_2301a6d0;
  }
  llm_le_env.elt_coext_scan = (ea_elt_tag *)0x0;
LAB_2301a702:
  bVar1 = ble_ke_state_get(0);
  if (llm_le_env.elt == (ea_elt_tag *)0x0) {
    state_id = 0;
    if (llm_le_env.elt_coext_scan != (ea_elt_tag *)0x0) {
      state_id = bVar1 & 0xf;
    }
  }
  else {
    if (llm_le_env.elt_coext_scan != (ea_elt_tag *)0x0) {
      do {
                    // WARNING: Do nothing block with infinite loop
      } while( true );
    }
    state_id = bVar1 & 0xf0;
  }
  ble_ke_state_set(0,state_id);
  llm_le_env.conhdl_alloc = 0xffff;
  return 0;
}



void llc_ch_assess_local(int param_1,uint param_2,int param_3,int param_4)

{
  char cVar1;
  int8_t iVar2;
  
  param_4 = (int)llc_env[param_1]->operation + param_4;
  cVar1 = *(char *)(param_4 + 0x14);
  if ((param_2 & 1) == 0) {
    if ((param_2 & 8) != 0) goto LAB_2301a7a4;
    cVar1 = cVar1 + '\x03';
  }
  else {
    if (llm_le_env.ch_map_assess.rssi_noise_limit < param_3) {
LAB_2301a7a4:
      cVar1 = cVar1 + -3;
    }
    else {
      cVar1 = cVar1 + -1;
      if ((llc_env[param_1]->chnl_assess).latency_en != false) goto LAB_2301a7b4;
    }
  }
  *(char *)(param_4 + 0x14) = cVar1;
LAB_2301a7b4:
  iVar2 = llm_le_env.ch_map_assess.lower_limit;
  if ((*(char *)(param_4 + 0x14) < llm_le_env.ch_map_assess.lower_limit) ||
     (iVar2 = llm_le_env.ch_map_assess.upper_limit,
     llm_le_env.ch_map_assess.upper_limit < *(char *)(param_4 + 0x14))) {
    *(int8_t *)(param_4 + 0x14) = iVar2;
  }
  return;
}



uint8_t llc_ch_assess_get_local_ch_map(uint16_t conhdl,le_chnl_map *map,le_chnl_map *hostmap)

{
  llc_env_tag *plVar1;
  uint8_t uVar2;
  undefined2 in_register_0000202a;
  uint uVar3;
  int iVar4;
  uint uVar5;
  
  plVar1 = llc_env[CONCAT22(in_register_0000202a,conhdl)];
  (*ble_memset_ptr)(map,0,5);
  uVar3 = 0x24;
  uVar2 = '\0';
  do {
    iVar4 = (int)(char)uVar3 >> 3;
    uVar5 = 1 << (uVar3 & 7) & 0xff;
    if (((hostmap->map[iVar4] & uVar5) != 0) &&
       (llm_le_env.ch_map_assess.lower_limit < (plVar1->chnl_assess).rcvd_quality[uVar3])) {
      uVar2 = uVar2 + '\x01';
      map->map[iVar4] = (byte)uVar5 | map->map[iVar4];
    }
    uVar3 = uVar3 - 1;
  } while (uVar3 != 0xffffffff);
  return uVar2;
}



le_chnl_map * llc_ch_assess_get_current_ch_map(uint16_t conhdl)

{
  undefined2 in_register_0000202a;
  
  return &llc_env[CONCAT22(in_register_0000202a,conhdl)]->ch_map;
}



void llc_ch_assess_reass_ch(uint16_t conhdl,le_chnl_map *map,le_chnl_map *hostmap,uint8_t nb_chgood)

{
  undefined2 in_register_0000202a;
  uint uVar1;
  undefined3 in_register_00002035;
  uint uVar2;
  uint uVar3;
  char cVar4;
  byte *pbVar5;
  llc_env_tag *plVar6;
  
  plVar6 = llc_env[CONCAT22(in_register_0000202a,conhdl)];
  uVar1 = 10;
  if (2 < CONCAT31(in_register_00002035,nb_chgood)) {
    uVar1 = CONCAT31(in_register_00002035,nb_chgood) * 0x20 + 0x7f >> 7;
  }
  cVar4 = '%';
  (plVar6->chnl_assess).reassess_count = llm_le_env.ch_map_assess.reassess_count;
  uVar3 = (uint)(plVar6->chnl_assess).reassess_cursor;
  do {
    uVar2 = uVar3 + 0xb & 0xff;
    if (0x24 < uVar2) {
      uVar2 = uVar3 - 0x1a & 0xff;
    }
    pbVar5 = map->map + (uVar2 >> 3);
    uVar3 = 1 << (uVar2 & 7) & 0xff;
    if (((uVar3 & *pbVar5) == 0) && ((hostmap->map[uVar2 >> 3] & uVar3) != 0)) {
      (plVar6->chnl_assess).rcvd_quality[uVar2] = '\0';
      *pbVar5 = (byte)uVar3 | *pbVar5;
      uVar1 = uVar1 - 1 & 0xffff;
    }
    cVar4 = cVar4 + -1;
  } while ((cVar4 != '\0') && (uVar3 = uVar2, uVar1 != 0));
  (plVar6->chnl_assess).reassess_cursor = (uint8_t)uVar2;
  return;
}



undefined4 hci_le_set_data_len_cmd_handler(ushort *param_1,ke_task_id_t param_2,uint16_t param_3)

{
  undefined4 uVar1;
  byte bVar2;
  uint8_t status;
  llc_env_tag *plVar3;
  
  bVar2 = ble_ke_state_get(param_2);
  if ((bVar2 & 0xf) == 0xf) {
    status = '\f';
  }
  else {
    plVar3 = llc_env[*param_1];
    if ((plVar3->data_len_ext_info).send_req_not_allowed == false) {
      if ((((ushort)(param_1[1] - 0x1b) < 0xe1) && ((ushort)(param_1[2] - 0x148) < 0x701)) &&
         (*param_1 < 3)) {
        if (((plVar3->data_len_ext_info).conn_eff_max_tx_octets != param_1[1]) ||
           ((plVar3->data_len_ext_info).conn_eff_max_tx_time != param_1[2])) {
          *(ushort **)(plVar3->operation + 3) = param_1;
          ble_ke_msg_send_basic(0x107,param_2,param_2);
          status = '\0';
          uVar1 = 1;
          goto LAB_2301a9b0;
        }
        status = '\0';
      }
      else {
        status = '\x12';
      }
    }
    else {
      status = '\x1a';
    }
  }
  uVar1 = 0;
LAB_2301a9b0:
  llc_common_cmd_complete_send(param_3,status,*param_1);
  return uVar1;
}



undefined4
hci_le_rem_con_param_req_neg_reply_cmd_handler
          (ushort *param_1,ke_task_id_t param_2,uint16_t param_3)

{
  byte bVar1;
  uint8_t status;
  
  bVar1 = ble_ke_state_get(param_2);
  status = '\f';
  if ((((bVar1 & 0xf) != 0xf) && ((bVar1 & 2) != 0)) &&
     (llc_env[*param_1]->rem_proc_state == '\x02')) {
    status = '\x12';
    if (*(char *)(param_1 + 1) == ';') {
      llc_util_clear_operation_ptr(1);
      ble_ke_state_set(param_2,bVar1 & 0xfd);
      llc_env[*param_1]->rem_proc_state = '\0';
      llc_llcp_reject_ind_pdu_send(*param_1,'\x0f',*(uint8_t *)(param_1 + 1));
      status = '\0';
    }
  }
  llc_common_cmd_complete_send(param_3,status,*param_1);
  return 0;
}



undefined4
hci_le_rem_con_param_req_reply_cmd_handler(ushort *param_1,ke_task_id_t param_2,uint16_t param_3)

{
  llc_con_upd_req_ind *param;
  byte bVar1;
  uint8_t status;
  uint8_t uVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  ushort uVar3;
  llc_env_tag *plVar4;
  
  bVar1 = ble_ke_state_get(param_2);
  status = '\f';
  if (((bVar1 & 0xf) != 0xf) && ((bVar1 & 2) != 0)) {
    plVar4 = llc_env[*param_1];
    if (plVar4->rem_proc_state == '\x02') {
      param = (llc_con_upd_req_ind *)plVar4->operation[1];
      status = lld_get_mode(*param_1);
      if (CONCAT31(extraout_var,status) == 3) {
        param->operation = '\x02';
        uVar3 = param->interval_min;
        if (param_1[1] < param->interval_min) {
          uVar3 = param_1[1];
        }
        param->interval_min = uVar3;
        uVar3 = param->interval_max;
        if (param->interval_max < param_1[2]) {
          uVar3 = param_1[2];
        }
        param->interval_max = uVar3;
        param->con_latency = param_1[3];
        uVar3 = param->superv_to;
        if (param->superv_to < param_1[4]) {
          uVar3 = param_1[4];
        }
        param->superv_to = uVar3;
        ble_ke_msg_send(param);
        ble_ke_state_set(param_2,bVar1 & 0xfd);
        plVar4->rem_proc_state = '\0';
        llc_env[*param_1]->operation[1] = (void *)0x0;
        status = '\0';
      }
      else {
        uVar2 = lld_get_mode(*param_1);
        status = '\0';
        if (CONCAT31(extraout_var_00,uVar2) == 4) {
          param->interval_min = param_1[1];
          param->interval_max = param_1[2];
          param->con_latency = param_1[3];
          param->superv_to = param_1[4];
          lld_con_param_rsp(*param_1,plVar4->elt,param);
          plVar4->rem_proc_state = '\x03';
          llc_llcp_con_param_rsp_pdu_send(*param_1,param);
          ble_ke_timer_set(0x102,param_2,4000);
          llc_util_clear_operation_ptr((uint)*param_1,1);
          status = '\0';
        }
      }
    }
  }
  llc_common_cmd_complete_send(param_3,status,*param_1);
  return 0;
}


/*
Unable to decompile 'hci_le_ltk_req_neg_reply_cmd_handler'
Cause: Exception while decompiling 2301abe0: Decompiler process died

*/


undefined4 hci_le_ltk_req_reply_cmd_handler(ushort *param_1,ke_task_id_t param_2,uint16_t param_3)

{
  byte bVar1;
  void *pvVar2;
  uint8_t status;
  
  bVar1 = ble_ke_state_get(param_2);
  status = '\f';
  if ((((bVar1 & 0xf) != 0xf) && ((bVar1 & 2) != 0)) && (llc_env[*param_1]->rem_proc_state == '\t'))
  {
    pvVar2 = ble_ke_msg_alloc(4,0,param_2,0x20);
    (*ble_memcpy_ptr)(pvVar2,param_1 + 1,0x10);
    (*ble_memcpy_ptr)((void *)((int)pvVar2 + 0x10),&llc_env[*param_1]->encrypt,0x10);
    ble_ke_msg_send(pvVar2);
    status = '\0';
    llc_env[*param_1]->rem_proc_state = '\n';
  }
  llc_common_cmd_complete_send(param_3,status,*param_1);
  return 0;
}



undefined4 hci_disconnect_cmd_handler(uint16_t *param_1,ke_task_id_t param_2,uint16_t param_3)

{
  byte bVar1;
  uint8_t status;
  int iVar2;
  undefined4 local_18;
  undefined2 uStack20;
  undefined uStack18;
  
  bVar1 = ble_ke_state_get(param_2);
  status = '\f';
  if ((bVar1 & 0xf) != 0xf) {
    local_18 = 0x15141305;
    uStack20 = 0x291a;
    uStack18 = 0x3b;
    iVar2 = 0;
    do {
      if (*(uint8_t *)((int)&local_18 + iVar2) == *(uint8_t *)(param_1 + 1)) {
        llc_llcp_terminate_ind_pdu_send(*param_1,*(uint8_t *)(param_1 + 1));
        status = '\0';
        goto LAB_2301adc2;
      }
      iVar2 = iVar2 + 1;
    } while (iVar2 != 7);
    status = '\x12';
  }
LAB_2301adc2:
  if (llc_env[*param_1]->disc_event_sent == false) {
    llc_common_cmd_status_send(param_3,status,*param_1);
    llc_env[*param_1]->disc_event_sent = true;
  }
  llc_env[*param_1]->disc_event_sent = false;
  return 0;
}


/*
Unable to decompile 'hci_le_start_enc_cmd_handler'
Cause: Exception while decompiling 2301ae12: Decompiler process died

*/


int hci_le_rd_rem_used_feats_cmd_handler
              (ke_msg_id_t msgid,hci_le_rd_rem_used_feats_cmd *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  byte bVar1;
  byte status;
  
  bVar1 = ble_ke_state_get(dest_id);
  if ((bVar1 & 0xf) == 0xf) {
    status = 0xc;
  }
  else {
    if ((llc_env[param->conhdl]->llc_status & 1) == 0) {
      status = bVar1 & 5;
      if ((bVar1 & 5) != 0) {
        return 2;
      }
      ble_ke_state_set(dest_id,bVar1 | 1);
      llc_env[param->conhdl]->loc_proc_state = '\x01';
      llc_llcp_feats_req_pdu_send(param->conhdl);
      ble_ke_timer_set(0x102,dest_id,4000);
    }
    else {
      status = 0;
    }
  }
  llc_common_cmd_status_send(src_id,status,param->conhdl);
  if ((llc_env[param->conhdl]->llc_status & 1) != 0) {
    llc_feats_rd_event_send('\0',param->conhdl,&llc_env[param->conhdl]->feats_used);
  }
  return 0;
}



undefined4 hci_le_rd_chnl_map_cmd_handler(ke_task_id_t *param_1,ke_task_id_t param_2)

{
  byte bVar1;
  undefined *param;
  undefined uVar2;
  
  param = (undefined *)ble_ke_msg_alloc(0x801,*param_1,0x2015,10);
  bVar1 = ble_ke_state_get(param_2);
  uVar2 = 0xc;
  if ((bVar1 & 0xf) != 0xf) {
    (*ble_memcpy_ptr)(param + 4,&llc_env[*param_1]->ch_map,5);
    uVar2 = 0;
  }
  *param = uVar2;
  *(ke_task_id_t *)(param + 2) = *param_1;
  hci_send_2_host(param);
  return 0;
}



undefined4 hci_rd_auth_payl_to_cmd_handler(ke_task_id_t *param_1,uint param_2)

{
  byte bVar1;
  undefined *param;
  
  bVar1 = ble_ke_state_get((ke_task_id_t)param_2);
  param = (undefined *)ble_ke_msg_alloc(0x801,*param_1,0xc7b,6);
  if ((bVar1 & 0xf) == 0xf) {
    *param = 0xc;
  }
  else {
    *param = 0;
    *(uint16_t *)(param + 4) = llc_env[param_2 >> 8]->auth_payl_to;
  }
  *(ke_task_id_t *)(param + 2) = *param_1;
  hci_send_2_host(param);
  return 0;
}



undefined4 hci_rd_rssi_cmd_handler(ke_task_id_t *param_1,ke_task_id_t param_2)

{
  byte bVar1;
  undefined *param;
  
  param = (undefined *)ble_ke_msg_alloc(0x801,*param_1,0x1405,6);
  bVar1 = ble_ke_state_get(param_2);
  if ((bVar1 & 0xf) == 0xf) {
    *param = 0xc;
    param[4] = 0;
  }
  else {
    *param = 0;
    param[4] = llc_env[*param_1]->rssi;
  }
  *(ke_task_id_t *)(param + 2) = *param_1;
  hci_send_2_host(param);
  return 0;
}



undefined4 hci_rd_tx_pwr_lvl_cmd_handler(ke_task_id_t *param_1,ke_task_id_t param_2)

{
  byte bVar1;
  uint8_t uVar2;
  undefined *param;
  undefined uVar3;
  
  param = (undefined *)ble_ke_msg_alloc(0x801,*param_1,0xc2d,6);
  bVar1 = ble_ke_state_get(param_2);
  if ((bVar1 & 0xf) == 0xf) {
    uVar3 = 0xc;
LAB_2301b180:
    *param = uVar3;
    param[4] = 0;
  }
  else {
    *param = 0;
    if (*(char *)(param_1 + 1) == '\0') {
      uVar2 = (*rwip_rf.txpwr_dbm_get)
                        ((uint8_t)*(undefined2 *)((uint)*param_1 * 0x5c + 0x280080a0),'\x01');
    }
    else {
      if (*(char *)(param_1 + 1) != '\x01') {
        uVar3 = 0x12;
        goto LAB_2301b180;
      }
      uVar2 = (*rwip_rf.txpwr_dbm_get)(rwip_rf.txpwr_max,'\x01');
    }
    param[4] = uVar2;
  }
  *(ke_task_id_t *)(param + 2) = *param_1;
  hci_send_2_host(param);
  return 0;
}



undefined4 hci_le_con_update_cmd_handler(ushort *param_1,ke_task_id_t param_2,uint16_t param_3)

{
  byte bVar1;
  ushort uVar2;
  ushort uVar3;
  byte status;
  uint8_t status_00;
  _Bool _Var4;
  undefined3 extraout_var;
  undefined *puVar5;
  undefined3 extraout_var_00;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  llc_env_tag *plVar9;
  lld_evt_tag *evt;
  ea_elt_tag *peVar10;
  
  status = ble_ke_state_get(param_2);
  if ((status & 0xf) == 0xf) {
    evt = (lld_evt_tag *)0x0;
    status_00 = -1;
    status = 0xc;
    goto LAB_2301b34e;
  }
  plVar9 = llc_env[*param_1];
  peVar10 = plVar9->elt;
  status_00 = lld_get_mode(*param_1);
  evt = (lld_evt_tag *)&peVar10->env;
  if (CONCAT31(extraout_var,status_00) == 4) {
    if ((plVar9->llc_status & 1) != 0) {
      bVar1 = (plVar9->feats_used).feats[0];
      status_00 = '\x1a';
      status = bVar1 & 2;
      if ((bVar1 & 2) == 0) goto LAB_2301b34e;
    }
    if (plVar9->peer_sup_conn_param_req != false) goto LAB_2301b264;
    status_00 = '\x1a';
LAB_2301b342:
    status = 0;
  }
  else {
LAB_2301b264:
    uVar2 = param_1[1];
    uVar7 = (uint)param_1[2];
    if (uVar2 <= uVar7) {
      if (((((uint)param_1[5] <= (uint)param_1[6]) && (param_1[2] < 0xc81)) && (5 < uVar2)) &&
         (((uVar3 = param_1[3], uVar3 < 500 &&
           (uVar6 = (uint)param_1[4], (uVar6 - 10 & 0xffff) < 0xc77)) &&
          (((uint)uVar3 + 1) * uVar7 < uVar6 << 2)))) {
        uVar8 = (uint)(*(ushort *)&peVar10[2].ea_cb_stop >> 1);
        if (((uVar8 < uVar2) || (uVar7 < uVar8)) ||
           ((uVar7 = (uint)plVar9->elt->duration_min / 0x4e2, uVar7 < (uint)param_1[5] ||
            ((((uint)param_1[6] < uVar7 || ((uint)plVar9->sup_to != uVar6)) ||
             (status_00 = '\0',
             (uint)*(ushort *)((int)&peVar10[2].linked_element + 2) - 1 != (uint)uVar3)))))) {
          puVar5 = (undefined *)ble_ke_msg_alloc(0x109,param_2,param_2,0x22);
          *puVar5 = 0;
          status_00 = -1;
          *(ushort *)(puVar5 + 2) = param_1[1];
          *(ushort *)(puVar5 + 4) = param_1[2];
          *(ushort *)(puVar5 + 6) = param_1[3];
          *(ushort *)(puVar5 + 8) = param_1[4];
          *(ushort *)(puVar5 + 10) = param_1[5];
          *(ushort *)(puVar5 + 0xc) = param_1[6];
          ble_ke_msg_send();
        }
        goto LAB_2301b342;
      }
    }
    status_00 = -1;
    status = 0x12;
  }
LAB_2301b34e:
  llc_common_cmd_status_send(param_3,status,*param_1);
  _Var4 = llm_util_check_evt_mask('\x02');
  if ((CONCAT31(extraout_var_00,_Var4) != 0) && (status_00 != -1)) {
    llc_con_update_complete_send(status_00,*param_1,evt);
  }
  return 0;
}



undefined4 hci_wr_auth_payl_to_cmd_handler(ke_task_id_t *param_1,uint param_2)

{
  llc_env_tag **pplVar1;
  byte id;
  undefined *param;
  undefined uVar2;
  llc_env_tag *plVar3;
  
  _id = (ke_task_id_t)param_2;
  id = ble_ke_state_get(_id);
  param = (undefined *)ble_ke_msg_alloc(0x801,*param_1,0xc7c,4);
  if ((id & 0xf) == 0xf) {
    uVar2 = 0xc;
  }
  else {
    pplVar1 = llc_env + (param_2 >> 8);
    if ((uint)*(ushort *)&(*pplVar1)->elt[2].ea_cb_stop *
        (uint)*(ushort *)((int)&(*pplVar1)->elt[2].linked_element + 2) <= (uint)param_1[1] << 4) {
      *param = 0;
      plVar3 = *pplVar1;
      plVar3->auth_payl_to = param_1[1];
      llc_util_set_auth_payl_to_margin((lld_evt_tag *)&plVar3->elt->env);
      plVar3 = *pplVar1;
      if ((plVar3->encryption_state & 3) == 3) {
        ble_ke_timer_set(0x103,_id,(uint)plVar3->auth_payl_to - (uint)plVar3->auth_payl_to_margin);
        ble_ke_timer_set(0x104,_id,(uint)(*pplVar1)->auth_payl_to);
      }
      goto LAB_2301b446;
    }
    uVar2 = 0x12;
  }
  *param = uVar2;
LAB_2301b446:
  *(ke_task_id_t *)(param + 2) = *param_1;
  hci_send_2_host(param);
  return 0;
}



int hci_flush_cmd_handler
              (ke_msg_id_t msgid,hci_basic_conhdl_cmd *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  ushort dest_id_00;
  undefined *param_00;
  
  dest_id_00 = param->conhdl;
  param_00 = (undefined *)ble_ke_msg_alloc(0x801,dest_id_00,0xc08,4);
  llc_common_flush_occurred_send(dest_id_00);
  lld_pdu_tx_flush(&llc_env[dest_id_00]->elt->env);
  *(ushort *)(param_00 + 2) = dest_id_00;
  *param_00 = 0;
  hci_send_2_host(param_00);
  return 0;
}



undefined4 hci_rd_rem_ver_info_cmd_handler(uint16_t *param_1,uint param_2,uint16_t param_3)

{
  byte id;
  uint8_t status;
  uint16_t conhdl;
  
  _id = (ke_task_id_t)param_2;
  id = ble_ke_state_get(_id);
  if ((id & 0xf) == 0xf) {
    conhdl = *param_1;
    status = '\f';
  }
  else {
    if ((llc_env[param_2 >> 8]->llc_status & 2) != 0) {
      llc_common_cmd_status_send(param_3,'\0',*param_1);
      llc_version_rd_event_send('\0',(uint16_t)(param_2 >> 8));
      return 0;
    }
    if ((id & 5) != 0) {
      return 2;
    }
    ble_ke_state_set(_id,id | 1);
    llc_env[param_2 >> 8]->loc_proc_state = '\x02';
    llc_llcp_version_ind_pdu_send(*param_1);
    ble_ke_timer_set(0x102,_id,4000);
    conhdl = *param_1;
    status = '\0';
  }
  llc_common_cmd_status_send(param_3,status,conhdl);
  return 0;
}



// WARNING: Exceeded maximum restarts with more pending

int llc_hci_command_handler(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_msg_handler_conflict110 *pkVar1;
  undefined2 in_register_00002036;
  int iVar2;
  
  pkVar1 = llc_hci_command_handler_tab;
  iVar2 = 0;
  do {
    if ((uint)pkVar1->id == CONCAT22(in_register_00002036,src_id)) {
      if (llc_hci_command_handler_tab[iVar2].func == (ke_msg_func_t *)0x0) {
        return 0;
      }
                    // WARNING: Could not recover jumptable at 0x2301b59a. Too many branches
                    // WARNING: Treating indirect jump as call
      iVar2 = (*llc_hci_command_handler_tab[iVar2].func)
                        ((ke_msg_id_t)CONCAT22(in_register_00002036,src_id));
      return iVar2;
    }
    iVar2 = iVar2 + 1;
    pkVar1 = pkVar1 + 1;
  } while (iVar2 != 0x10);
  return 0;
}


/*
Unable to decompile 'llc_hci_acl_data_tx_handler'
Cause: Exception while decompiling 2301b5a8: Decompiler process died

*/


int hci_vsc_set_tx_pwr(ke_msg_id_t msgid,hci_vsc_set_tx_pwr_cmd *param,ke_task_id_t dest_id,
                      ke_task_id_t src_id)

{
  uint8_t status;
  
  status = '\x12';
  if ((byte)param->power < 0x15) {
    (*rwip_rf.txpwr_max_set)(param->power);
    status = '\0';
  }
  llm_common_cmd_complete_send(src_id,status);
  return 0;
}



int hci_le_wr_rfpath_compensation_cmd_handler
              (ke_msg_id_t msgid,hci_le_wr_rfpath_cps_cmd *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  g_rf_txpath_compensation_value = param->rf_txpath_compensation_value;
  g_rf_rxpath_compensation_value = param->rf_rxpath_compensation_value;
  llm_common_cmd_complete_send(src_id,'\0');
  return 0;
}



int hci_wr_le_host_supp_cmd_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  llm_local_supp_feats[1][0] = *(char *)param << 1 | llm_local_supp_feats[1][0];
  llm_common_cmd_complete_send(src_id,'\0');
  return 0;
}



int hci_le_wr_suggted_dft_data_len_cmd_handler
              (ke_msg_id_t msgid,hci_le_wr_suggted_dft_data_len_cmd *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  uint8_t status;
  
  status = '\x12';
  if (((ushort)(param->suggted_max_tx_octets - 0x1b) < 0xe1) &&
     ((ushort)(param->suggted_max_tx_time - 0x148) < 0x701)) {
    llm_le_env.data_len_val.conn_initial_max_tx_time = param->suggted_max_tx_time;
    status = '\0';
    llm_le_env.data_len_val.conn_initial_max_tx_octets = param->suggted_max_tx_octets;
  }
  llm_common_cmd_complete_send(src_id,status);
  return 0;
}



int hci_le_set_evt_mask_cmd_handler
              (ke_msg_id_t msgid,hci_le_set_evt_mask_cmd *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  (*ble_memcpy_ptr)(&llm_le_env.eventmask,param,8);
  llm_common_cmd_complete_send(src_id,'\0');
  return 0;
}



int hci_le_rd_rfpath_compensation_cmd_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint16_t uVar1;
  undefined *param_00;
  
  param_00 = (undefined *)ble_ke_msg_alloc(0x801,0,0x204c,6);
  *(uint16_t *)(param_00 + 2) = g_rf_txpath_compensation_value;
  uVar1 = g_rf_rxpath_compensation_value;
  *param_00 = 0;
  *(uint16_t *)(param_00 + 4) = uVar1;
  hci_send_2_host(param_00);
  return 0;
}



int hci_le_rd_trans_pwr_cmd_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint8_t uVar1;
  undefined *param_00;
  
  param_00 = (undefined *)ble_ke_msg_alloc(0x801,0,0x204b,3);
  param_00[1] = 0;
  uVar1 = rwip_rf.txpwr_max;
  *param_00 = 0;
  param_00[2] = uVar1;
  hci_send_2_host(param_00);
  return 0;
}



int hci_rd_buff_size_cmd_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  undefined *param_00;
  
  param_00 = (undefined *)ble_ke_msg_alloc(0x801,0,0x1005,10);
  *(undefined2 *)(param_00 + 6) = 0;
  *(undefined2 *)(param_00 + 2) = 0;
  param_00[4] = 0;
  *(undefined2 *)(param_00 + 8) = 0;
  *param_00 = 0;
  hci_send_2_host(param_00);
  return 0;
}



int hci_rd_local_supp_feats_cmd_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  undefined *param_00;
  
  param_00 = (undefined *)ble_ke_msg_alloc(0x801,0,src_id,9);
  (*ble_memcpy_ptr)(param_00 + 1,llm_local_supp_feats,8);
  *param_00 = 0;
  hci_send_2_host(param_00);
  return 0;
}



int hci_rd_local_supp_cmds_cmd_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  undefined *param_00;
  
  param_00 = (undefined *)ble_ke_msg_alloc(0x801,0,0x1002,0x41);
  (*ble_memcpy_ptr)(param_00 + 1,&llm_local_cmds,0x40);
  *param_00 = 0;
  hci_send_2_host(param_00);
  return 0;
}



int hci_rd_local_ver_info_cmd_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  undefined2 *param_00;
  
  param_00 = (undefined2 *)ble_ke_msg_alloc(0x801,0,0x1001,10);
  param_00[4] = 0x321;
  param_00[1] = 0x321;
  *param_00 = 0x900;
  param_00[3] = 0x7af;
  *(undefined *)(param_00 + 2) = 9;
  hci_send_2_host(param_00);
  return 0;
}



int hci_rd_bd_addr_cmd_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  undefined *param_00;
  
  param_00 = (undefined *)ble_ke_msg_alloc(0x801,0,0x1009,7);
  (*ble_memcpy_ptr)(param_00 + 1,(void *)0x4201a3b9,6);
  *param_00 = 0;
  hci_send_2_host(param_00);
  return 0;
}



int hci_le_rd_max_data_len_cmd_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint16_t uVar1;
  undefined *param_00;
  
  param_00 = (undefined *)ble_ke_msg_alloc(0x801,0,0x202f,10);
  *(uint16_t *)(param_00 + 6) = llm_le_env.data_len_val.suppted_max_rx_octets;
  *(uint16_t *)(param_00 + 8) = llm_le_env.data_len_val.suppted_max_rx_time;
  *(uint16_t *)(param_00 + 2) = llm_le_env.data_len_val.suppted_max_tx_octets;
  uVar1 = llm_le_env.data_len_val.suppted_max_tx_time;
  *param_00 = 0;
  *(uint16_t *)(param_00 + 4) = uVar1;
  hci_send_2_host(param_00);
  return 0;
}



int hci_le_rd_suggted_dft_data_len_cmd_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint16_t uVar1;
  undefined *param_00;
  
  param_00 = (undefined *)ble_ke_msg_alloc(0x801,0,0x2023,6);
  *(uint16_t *)(param_00 + 2) = llm_le_env.data_len_val.conn_initial_max_tx_octets;
  uVar1 = llm_le_env.data_len_val.conn_initial_max_tx_time;
  *param_00 = 0;
  *(uint16_t *)(param_00 + 4) = uVar1;
  hci_send_2_host(param_00);
  return 0;
}



int hci_le_rd_supp_states_cmd_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  undefined *param_00;
  
  param_00 = (undefined *)ble_ke_msg_alloc(0x801,0,0x201c,9);
  (*ble_memcpy_ptr)(param_00 + 1,&llm_local_le_states,8);
  *param_00 = 0;
  hci_send_2_host(param_00);
  return 0;
}



int hci_le_rd_wl_size_cmd_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  undefined *param_00;
  
  param_00 = (undefined *)ble_ke_msg_alloc(0x801,0,0x200f,2);
  *param_00 = 0;
  param_00[1] = 4;
  hci_send_2_host(param_00);
  return 0;
}



int hci_le_rd_adv_ch_tx_pw_cmd_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint8_t uVar1;
  undefined *param_00;
  
  param_00 = (undefined *)ble_ke_msg_alloc(0x801,0,0x2007,2);
  uVar1 = (*rwip_rf.txpwr_dbm_get)(rwip_rf.txpwr_max,'\x01');
  param_00[1] = uVar1;
  *param_00 = 0;
  hci_send_2_host(param_00);
  return 0;
}



int hci_le_rd_local_supp_feats_cmd_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  undefined *param_00;
  
  param_00 = (undefined *)ble_ke_msg_alloc(0x801,0,0x2003,9);
  (*ble_memcpy_ptr)(param_00 + 1,&llm_local_le_feats,8);
  *param_00 = 0;
  hci_send_2_host(param_00);
  return 0;
}



int hci_le_rd_buff_size_cmd_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint16_t uVar1;
  undefined *param_00;
  
  param_00 = (undefined *)ble_ke_msg_alloc(0x801,0,0x2002,6);
  param_00[4] = 2;
  uVar1 = llm_le_env.data_len_val.suppted_max_tx_octets;
  *param_00 = 0;
  *(uint16_t *)(param_00 + 2) = uVar1;
  hci_send_2_host(param_00);
  return 0;
}



int hci_le_generate_dhkey_cmd_handler
              (ke_msg_id_t msgid,hci_le_generate_dh_key_cmd *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  uint8_t status;
  int iVar1;
  hci_le_generate_dh_key_cmd *phVar2;
  
  iVar1 = 0;
  do {
    if (param->public_key[iVar1] != '\0') {
      status = '\0';
      goto LAB_2301bae6;
    }
    iVar1 = iVar1 + 1;
  } while (iVar1 != 0x20);
  status = '\x12';
LAB_2301bae6:
  phVar2 = (hci_le_generate_dh_key_cmd *)(param->public_key + 0x20);
  do {
    if (phVar2->public_key[0] != '\0') goto LAB_2301bafe;
    phVar2 = (hci_le_generate_dh_key_cmd *)(phVar2->public_key + 1);
  } while (param + 1 != phVar2);
  status = '\x12';
LAB_2301bafe:
  if (llm_le_env.cur_ecc_multiplication == LLM_ECC_IDLE) {
    if (status == '\0') {
      llm_le_env.cur_ecc_multiplication = LLM_DHKEY_GENERATION;
      status = ecc_generate_key256('\x02',llm_le_env.secret_key256,(u_int8 *)param,
                                   (u_int8 *)
                                   (hci_le_generate_dh_key_cmd *)(param->public_key + 0x20),6,0);
    }
  }
  else {
    status = '\f';
  }
  llm_common_cmd_status_send(src_id,status);
  return 0;
}



int hci_host_nb_cmp_pkts_cmd_handler
              (ke_msg_id_t msgid,hci_host_nb_cmp_pkts_cmd *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  uint16_t acl_pkt_nb;
  uint8_t status;
  uint8_t uVar1;
  ushort *puVar2;
  
  puVar2 = param->con_hdl;
  acl_pkt_nb = 0;
  uVar1 = '\0';
  status = '\0';
  while (param->nb_of_hdl != uVar1) {
    if (*puVar2 < 2) {
      acl_pkt_nb = acl_pkt_nb + puVar2[3];
    }
    else {
      status = '\x12';
    }
    uVar1 = uVar1 + '\x01';
    puVar2 = puVar2 + 1;
  }
  hci_fc_host_nb_acl_pkts_complete(acl_pkt_nb);
  if (status != '\0') {
    llm_common_cmd_complete_send(src_id,status);
  }
  return 0;
}



int hci_host_buf_size_cmd_handler
              (ke_msg_id_t msgid,hci_host_buf_size_cmd *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  uint8_t status;
  
  status = hci_fc_acl_buf_size_set(param->acl_pkt_len,param->nb_acl_pkts);
  llm_common_cmd_complete_send(src_id,status);
  return 0;
}



int hci_set_evt_mask_page_2_cmd_handler
              (ke_msg_id_t msgid,hci_set_evt_mask_cmd *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  uint8_t status;
  
  status = hci_evt_mask_set((evt_mask *)param,'\x02');
  llm_common_cmd_complete_send(src_id,status);
  return 0;
}



int hci_set_evt_mask_cmd_handler
              (ke_msg_id_t msgid,hci_set_evt_mask_cmd *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  uint8_t status;
  
  status = hci_evt_mask_set((evt_mask *)param,'\x03');
  llm_common_cmd_complete_send(src_id,status);
  return 0;
}



int hci_set_ctrl_to_host_flow_ctrl_cmd_handler
              (ke_msg_id_t msgid,hci_set_ctrl_to_host_flow_ctrl_cmd *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  byte bVar1;
  uint8_t status;
  
  bVar1 = param->flow_cntl;
  status = '\x12';
  if (bVar1 < 4) {
    status = hci_fc_acl_en((_Bool)(bVar1 == 1 || bVar1 == 3));
  }
  llm_common_cmd_complete_send(src_id,status);
  return 0;
}



int hci_reset_cmd_handler(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  undefined2 in_register_0000202a;
  
  rwip_reset(CONCAT22(in_register_0000202a,msgid));
  llm_common_cmd_complete_send(src_id,'\0');
  return 0;
}



int hci_le_tx_test_cmd_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint8_t status;
  undefined3 extraout_var;
  undefined2 in_register_00002036;
  
  status = ble_ke_state_get(0);
  if (CONCAT31(extraout_var,status) == 0) {
    if (CONCAT22(in_register_00002036,src_id) == 0x201e) {
      status = llm_test_mode_start_tx((hci_le_tx_test_cmd *)param);
    }
  }
  else {
    status = '\f';
  }
  llm_common_cmd_complete_send(src_id,status);
  return 0;
}



int hci_le_rx_test_cmd_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint8_t status;
  undefined3 extraout_var;
  undefined2 in_register_00002036;
  
  status = ble_ke_state_get(0);
  if (CONCAT31(extraout_var,status) == 0) {
    if (CONCAT22(in_register_00002036,src_id) == 0x201d) {
      status = llm_test_mode_start_rx((hci_le_rx_test_cmd *)param);
    }
  }
  else {
    status = '\f';
  }
  llm_common_cmd_complete_send(src_id,status);
  return 0;
}



int hci_le_rand_cmd_handler(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  undefined *param_00;
  int iVar1;
  
  param_00 = (undefined *)ble_ke_msg_alloc(0x801,0,0x2018,9);
  iVar1 = bl_rand();
  param_00[1] = (char)iVar1;
  param_00[2] = (char)((uint)iVar1 >> 8);
  param_00[3] = (char)((uint)iVar1 >> 0x10);
  param_00[4] = (char)((uint)iVar1 >> 0x18);
  iVar1 = bl_rand();
  param_00[5] = (char)iVar1;
  param_00[6] = (char)((uint)iVar1 >> 8);
  param_00[8] = (char)((uint)iVar1 >> 0x18);
  param_00[7] = (char)((uint)iVar1 >> 0x10);
  *param_00 = 0;
  hci_send_2_host(param_00);
  return 0;
}



int hci_le_enc_cmd_handler
              (ke_msg_id_t msgid,hci_le_enc_cmd *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  *(undefined2 *)(param[-1].plain_data + 8) = 4;
  *(undefined2 *)(param[-1].plain_data + 0xc) = 8;
  ble_co_list_push_back(&llm_le_env,param[-1].plain_data + 4);
  if (llm_le_env.enc_pend == false) {
    llm_encryption_start((llm_enc_req *)param);
  }
  return 1;
}



int hci_le_wl_mngt_cmd_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  byte bVar1;
  uint8_t status;
  undefined2 in_register_0000202a;
  int iVar2;
  uint16_t auStack34 [2];
  uint16_t conhdl;
  
  iVar2 = CONCAT22(in_register_0000202a,msgid);
  bVar1 = ble_ke_state_get(0);
  if ((((bVar1 & 0xf0) != 0x10) ||
      (status = '\f', (llm_le_env.advertising_params)->filterpolicy == '\0')) &&
     ((1 < ((uint)bVar1 & 0xf) - 1 ||
      (status = '\f', (llm_le_env.scanning_params)->filterpolicy == '\0')))) {
    if (iVar2 == 0x2011) {
      status = llm_wl_dev_add_hdl((bd_addr *)((int)param + 1),*(uint8_t *)param);
    }
    else {
      if (iVar2 == 0x2012) {
        status = llm_wl_dev_rem_hdl((bd_addr *)((int)param + 1),*(uint8_t *)param);
      }
      else {
        status = '\0';
        if (iVar2 == 0x2010) {
          llm_wl_clr();
          llm_util_bl_check((bd_addr *)0x0,'\0',auStack34,'\x01',(_Bool *)0x0);
        }
      }
    }
  }
  llm_common_cmd_complete_send(src_id,status);
  return 0;
}



int hci_le_set_host_ch_class_cmd_handler
              (ke_msg_id_t msgid,hci_le_set_host_ch_class_cmd *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  uint8_t uVar1;
  uint8_t status;
  
  status = '\f';
  if (llm_le_env.ch_map_assess.llm_le_set_host_ch_class_cmd_sto != false) {
    uVar1 = llm_util_check_map_validity((uint8_t *)param,'\x05');
    ble_ke_timer_set(0,0,100);
    llm_le_env.ch_map_assess.llm_le_set_host_ch_class_cmd_sto = false;
    status = '\x12';
    if ((byte)(uVar1 - 2) < 0x24) {
      memcpy(&llm_le_env.ch_map_assess.ch_map,param,5);
      status = '\0';
    }
  }
  llm_common_cmd_complete_send(src_id,status);
  return 0;
}



int hci_le_create_con_cmd_handler
              (ke_msg_id_t msgid,hci_le_create_con_cmd *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  ke_state_t kVar1;
  uint8_t status;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  uint uVar2;
  
  kVar1 = ble_ke_state_get(0);
  _kVar1 = CONCAT31(extraout_var,kVar1);
  if (_kVar1 == 0x10) {
LAB_2301bed0:
    status = llm_create_con(param);
    if (CONCAT31(extraout_var_00,status) == 0) {
      llm_le_env.opcode2 = src_id;
      llm_le_env.state2 = ble_ke_state_get(0);
      llm_le_env.last_opcode = true;
    }
  }
  else {
    if (_kVar1 < 0x11) {
      if (_kVar1 == 0) goto LAB_2301bed0;
      uVar2 = 3;
    }
    else {
      if (_kVar1 == 0x20) goto LAB_2301bed0;
      if (_kVar1 == 0x23) {
        return 2;
      }
      uVar2 = 0x13;
    }
    status = '\f';
    if (_kVar1 == uVar2) {
      return 2;
    }
  }
  llm_common_cmd_status_send(src_id,status);
  return 0;
}



int hci_le_set_scan_en_cmd_handler
              (ke_msg_id_t msgid,hci_le_set_scan_en_cmd *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  ke_state_t kVar1;
  uint8_t status;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  uint uVar2;
  
  kVar1 = ble_ke_state_get(0);
  _kVar1 = CONCAT31(extraout_var,kVar1);
  if (_kVar1 == 0x12) {
LAB_2301bfd0:
    status = '\f';
    goto LAB_2301bf6e;
  }
  if (_kVar1 < 0x13) {
    if (_kVar1 == 2) goto LAB_2301bfd0;
    if (_kVar1 < 3) {
      uVar2 = 1;
    }
    else {
      if (_kVar1 == 3) {
        return 2;
      }
      uVar2 = 0x11;
    }
    if (_kVar1 == uVar2) goto LAB_2301bfca;
LAB_2301bf32:
    status = '\f';
    if (param->scan_en != '\x01') goto LAB_2301bf6e;
  }
  else {
    if (_kVar1 != 0x21) {
      if (_kVar1 < 0x22) {
        uVar2 = 0x13;
      }
      else {
        if (_kVar1 == 0x22) goto LAB_2301bfd0;
        uVar2 = 0x23;
      }
      if (_kVar1 == uVar2) {
        return 2;
      }
      goto LAB_2301bf32;
    }
LAB_2301bfca:
    if (param->scan_en != '\0') goto LAB_2301bfd0;
  }
  llm_le_env.state2 = ble_ke_state_get(0);
  llm_le_env.last_opcode = true;
  llm_le_env.opcode2 = src_id;
  status = llm_set_scan_en(param);
  if ((CONCAT31(extraout_var_00,status) == 0) && (param->scan_en != '\x01')) {
    return 0;
  }
LAB_2301bf6e:
  llm_common_cmd_complete_send(src_id,status);
  llm_le_env.last_opcode = true;
  llm_le_env.state2 = llm_le_env.state2 & 0xf0;
  return 0;
}



int hci_le_set_scan_param_cmd_handler
              (ke_msg_id_t msgid,hci_le_set_scan_param_cmd *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  ke_state_t kVar1;
  uint8_t status;
  undefined3 extraout_var;
  
  kVar1 = ble_ke_state_get(0);
  _kVar1 = CONCAT31(extraout_var,kVar1);
  status = '\f';
  if (((_kVar1 != 0x11) && (_kVar1 != 0x21)) && (_kVar1 != 1)) {
    status = llm_set_scan_param(param);
  }
  llm_common_cmd_complete_send(src_id,status);
  return 0;
}


/*
Unable to decompile 'hci_le_set_scan_rsp_data_cmd_handler'
Cause: Exception while decompiling 2301c016: Decompiler process died

*/


int hci_le_set_adv_en_cmd_handler
              (ke_msg_id_t msgid,hci_le_set_adv_en_cmd *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  ke_state_t kVar1;
  uint8_t status;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  
  kVar1 = ble_ke_state_get(0);
  _kVar1 = CONCAT31(extraout_var,kVar1);
  if (_kVar1 < 0x10) {
LAB_2301c108:
    status = '\f';
    if (param->adv_en != '\x01') goto LAB_2301c114;
  }
  else {
    if (0x13 < _kVar1) {
      if ((_kVar1 - 0x20 & 0xff) < 4) {
        return 2;
      }
      goto LAB_2301c108;
    }
    status = '\f';
    if (param->adv_en != '\0') goto LAB_2301c114;
  }
  llm_le_env.state = ble_ke_state_get(0);
  llm_le_env.opcode = src_id;
  status = llm_set_adv_en(param);
  if ((CONCAT31(extraout_var_00,status) == 0) && (param->adv_en != '\x01')) {
    llm_le_env.last_opcode = false;
    return 0;
  }
LAB_2301c114:
  llm_common_cmd_complete_send(src_id,status);
  llm_le_env.last_opcode = false;
  return 0;
}


/*
Unable to decompile 'hci_le_set_adv_data_cmd_handler'
Cause: Exception while decompiling 2301c11e: Decompiler process died

*/


int hci_le_set_adv_param_cmd_handler
              (ke_msg_id_t msgid,hci_le_set_adv_param_cmd *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  ke_state_t kVar1;
  uint8_t status;
  undefined3 extraout_var;
  
  kVar1 = ble_ke_state_get(0);
  status = '\f';
  if (3 < CONCAT31(extraout_var,kVar1) - 0x10U) {
    status = llm_set_adv_param(param);
  }
  llm_common_cmd_complete_send(src_id,status);
  return 0;
}



int hci_le_set_rand_add_cmd_handler
              (ke_msg_id_t msgid,hci_le_set_rand_addr_cmd *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  uint8_t status;
  ke_state_t kVar1;
  _Bool _Var2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  
  kVar1 = ble_ke_state_get(0);
  status = '\f';
  if (CONCAT31(extraout_var,kVar1) == 0) {
    _Var2 = co_bdaddr_compare((bd_addr *)param,&co_null_bdaddr);
    if (CONCAT31(extraout_var_00,_Var2) == 0) {
      (*ble_memcpy_ptr)((void *)0x4201a3b3,param,6);
      status = kVar1;
    }
    else {
      status = '\x12';
    }
  }
  llm_common_cmd_complete_send(src_id,status);
  return 0;
}



int hci_le_rd_local_p256_public_key_cmd_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  t_key_multi_type status;
  
  status = llm_le_env.cur_ecc_multiplication;
  if (llm_le_env.cur_ecc_multiplication != LLM_ECC_IDLE) {
    status = 0xc;
  }
  llm_common_cmd_status_send(src_id,status);
  if (status == LLM_ECC_IDLE) {
    ecc_gen_new_secret_key(llm_le_env.secret_key256,false);
    llm_le_env.cur_ecc_multiplication = LLM_PUBLIC_KEY_GENERATION;
    ecc_gen_new_public_key(llm_le_env.secret_key256,6,0);
  }
  return 0;
}



int hci_le_test_end_cmd_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined3 extraout_var;
  undefined *param_00;
  
  kVar1 = ble_ke_state_get(0);
  if (CONCAT31(extraout_var,kVar1) == 0x24) {
    llm_le_env.test_mode.end_of_tst = true;
    lld_test_stop(llm_le_env.elt);
    ble_ke_state_set(0,'#');
  }
  else {
    param_00 = (undefined *)ble_ke_msg_alloc(0x801,0,0x201f,4);
    *(undefined2 *)(param_00 + 2) = 0;
    *param_00 = 0xc;
    hci_send_2_host(param_00);
  }
  return 0;
}



int hci_le_create_con_cancel_cmd_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  byte bVar2;
  undefined3 extraout_var;
  
  kVar1 = ble_ke_state_get(0);
  _kVar1 = CONCAT31(extraout_var,kVar1);
  if (((_kVar1 == 0x12) || (_kVar1 == 0x22)) || (_kVar1 == 2)) {
    lld_scan_stop(llm_le_env.elt_coext_scan);
    llm_le_env.state2 = llm_le_env.state2 & 0xf0 | 2;
    llm_le_env.last_opcode = true;
    llm_le_env.opcode2 = src_id;
    bVar2 = ble_ke_state_get(0);
    ble_ke_state_set(0,bVar2 & 0xf0 | 3);
  }
  else {
    llm_common_cmd_complete_send(src_id,'\f');
  }
  return 0;
}



// WARNING: Exceeded maximum restarts with more pending

int hci_command_handler(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_msg_handler_conflict117 *pkVar1;
  undefined2 in_register_00002036;
  uint uVar2;
  int iVar3;
  
  uVar2 = CONCAT22(in_register_00002036,src_id);
  pkVar1 = llm_hci_command_handler_tab;
  iVar3 = 0;
  do {
    if ((uint)pkVar1->id == uVar2) {
      if (llm_hci_command_handler_tab[iVar3].func == (ke_msg_func_t *)0x0) {
        return 0;
      }
                    // WARNING: Could not recover jumptable at 0x2301c378. Too many branches
                    // WARNING: Treating indirect jump as call
      iVar3 = (*llm_hci_command_handler_tab[iVar3].func)((ke_msg_id_t)uVar2,(void *)uVar2);
      return iVar3;
    }
    iVar3 = iVar3 + 1;
    pkVar1 = pkVar1 + 1;
  } while (iVar3 != 0x2d);
  return 0;
}



int hci_driver_send(net_buf *buf)

{
  int iVar1;
  
  if (*(short *)((int)&buf->field_4 + 4) == 0) {
    printf("Empty HCI packet\r\n");
    iVar1 = -0x16;
  }
  else {
    iVar1 = bl_onchiphci_send_2_controller(buf);
    net_buf_unref(buf);
  }
  return iVar1;
}



int hci_driver_open(void)

{
  k_queue_init((k_queue *)&recv_fifo,0x14);
  k_thread_create(&recv_thread_data,"recv_thread",0x800,recv_thread,0x1c);
  return 0;
}



void recv_thread(void *p1)

{
  net_buf *buf;
  
  do {
    buf = net_buf_get(&recv_fifo,-1);
    if (buf != (net_buf *)0x0) {
      bt_recv(buf);
    }
    k_yield();
  } while( true );
}



void hci_driver_enque_recvq(net_buf *buf)

{
  net_buf_put(&recv_fifo,buf);
  return;
}



int hci_driver_init(void)

{
  bt_hci_driver_register(&drv);
  return 0;
}



void le_dhkey_complete(net_buf *buf)

{
  u8_t *puVar1;
  
  if (dh_key_cb != (bt_dh_key_cb_t *)0x0) {
    puVar1 = (u8_t *)0x0;
    if (**(char **)&buf->field_4 == '\0') {
      puVar1 = (u8_t *)(*(char **)&buf->field_4 + 1);
    }
    (*dh_key_cb)(puVar1);
    dh_key_cb = (bt_dh_key_cb_t *)0x0;
    return;
  }
  return;
}



void hci_data_buf_overflow(net_buf *buf)

{
  printf("Data buffer overflow (link type 0x%02x)\r\n",(uint)**(byte **)&buf->field_4);
  return;
}



int atomic_test_bit(atomic_t *target,int bit)

{
  atomic_val_t aVar1;
  
  aVar1 = atomic_get(target);
  return aVar1 >> (bit & 0x1fU) & 1;
}



void bt_addr_le_copy(bt_addr_le_t *dst,bt_addr_le_t *src)

{
  memcpy(dst,src,7);
  return;
}



void le_pkey_complete(net_buf *buf)

{
  bt_pub_key_cb *pbVar1;
  u8_t *puVar2;
  char *pcVar3;
  
  pcVar3 = *(char **)&buf->field_4;
  atomic_and(bt_dev.flags,-0x21);
  if (*pcVar3 == '\0') {
    memcpy(pub_key,pcVar3 + 1,0x40);
    atomic_or(bt_dev.flags,0x10);
  }
  pbVar1 = pub_key_cb;
  while (pbVar1 != (bt_pub_key_cb *)0x0) {
    puVar2 = pub_key;
    if (*pcVar3 != '\0') {
      puVar2 = (u8_t *)0x0;
    }
    (*pbVar1->func)(puVar2);
    pbVar1 = pbVar1->_next;
  }
  pub_key_cb = (bt_pub_key_cb *)0x0;
  return;
}



void atomic_set_bit_to(atomic_t *target,int bit,_Bool val)

{
  uint value;
  undefined3 in_register_00002031;
  
  value = 1 << (bit & 0x1fU);
  if (CONCAT31(in_register_00002031,val) != 0) {
    atomic_or(target + ((uint)bit >> 5),value);
    return;
  }
  atomic_and(target + ((uint)bit >> 5),~value);
  return;
}



void slave_update_conn_param(bt_conn *conn)

{
  int iVar1;
  
  iVar1 = atomic_test_bit(conn->flags,8);
  if (iVar1 == 0) {
    k_delayed_work_submit(&conn->update_work,5000);
    return;
  }
  return;
}



void le_remote_feat_complete(net_buf *buf)

{
  ushort handle;
  bt_conn *conn;
  char *pcVar1;
  
  pcVar1 = *(char **)&buf->field_4;
  handle = *(ushort *)(pcVar1 + 1);
  conn = bt_conn_lookup_handle(handle);
  if (conn == (bt_conn *)0x0) {
    printf("Unable to lookup conn for handle %u\r\n",(uint)handle);
    return;
  }
  if (*pcVar1 == '\0') {
    memcpy(conn->field_20 + 0x24,pcVar1 + 3,8);
  }
  if (conn->role == '\x01') {
    slave_update_conn_param(conn);
  }
  bt_conn_unref(conn);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void le_conn_update_complete(net_buf *buf)

{
  ushort handle;
  char *pcVar1;
  bt_conn *conn;
  uint uVar2;
  undefined4 uStack24;
  bt_le_conn_param param;
  
  pcVar1 = *(char **)&buf->field_4;
  handle = *(ushort *)(pcVar1 + 1);
  conn = bt_conn_lookup_handle(handle);
  if (conn == (bt_conn *)0x0) {
    printf("Unable to lookup conn for handle %u\r\n",(uint)handle);
  }
  else {
    if (*pcVar1 == '\0') {
      *(undefined2 *)(conn->field_20 + 0x16) = *(undefined2 *)(pcVar1 + 3);
      *(undefined2 *)(conn->field_20 + 0x1c) = *(undefined2 *)(pcVar1 + 5);
      *(undefined2 *)(conn->field_20 + 0x1e) = *(undefined2 *)(pcVar1 + 7);
      notify_le_param_updated(conn);
    }
    else {
      if (((*pcVar1 == '\x1a') && (conn->role == '\x01')) &&
         (uVar2 = atomic_or(conn->flags,0x400), (uVar2 & 0x400) == 0)) {
        uStack24 = *(undefined4 *)(conn->field_20 + 0x18);
        param._0_4_ = *(undefined4 *)(conn->field_20 + 0x20);
        bt_l2cap_update_conn_param(conn,(bt_le_conn_param *)&uStack24);
      }
    }
    bt_conn_unref(conn);
  }
  return;
}



void hci_num_completed_packets(net_buf *buf)

{
  ushort handle;
  sys_snode_t *psVar1;
  uint uVar2;
  bt_conn *conn;
  k_sem *sem;
  byte *pbVar3;
  _snode *p_Var4;
  sys_snode_t *psVar5;
  short sVar6;
  int iVar7;
  byte *pbVar8;
  
  pbVar8 = *(byte **)&buf->field_4;
  iVar7 = 0;
  do {
    if ((int)(uint)*pbVar8 <= iVar7) {
      return;
    }
    pbVar3 = pbVar8 + iVar7 * 4;
    handle = *(ushort *)(pbVar3 + 1);
    sVar6 = *(short *)(pbVar3 + 3);
    uVar2 = irq_lock();
    conn = bt_conn_lookup_handle(handle);
    if (conn == (bt_conn *)0x0) {
      irq_unlock(uVar2);
      printf("No connection for handle %u\r\n",(uint)handle);
    }
    else {
      irq_unlock(uVar2);
      while (sVar6 != 0) {
        uVar2 = irq_lock();
        if (conn->pending_no_cb == 0) {
          psVar1 = (conn->tx_pending).head;
          if (psVar1 != (sys_snode_t *)0x0) {
            p_Var4 = psVar1->next;
            *(_snode **)&(conn->tx_pending).head = p_Var4;
            if (psVar1 == (conn->tx_pending).tail) {
              *(_snode **)&(conn->tx_pending).tail = p_Var4;
            }
          }
          irq_unlock(uVar2);
          if (psVar1 == (sys_snode_t *)0x0) {
            printf("packets count mismatch\r\n");
            break;
          }
          irq_lock();
          *(_snode **)&conn->pending_no_cb = psVar1[3].next;
          psVar1[3].next = (_snode *)0x0;
          psVar1->next = (_snode *)0x0;
          psVar5 = (conn->tx_complete).tail;
          if (psVar5 == (sys_snode_t *)0x0) {
            (conn->tx_complete).tail = psVar1;
            (conn->tx_complete).head = psVar1;
          }
          else {
            *(sys_snode_t **)&psVar5->next = psVar1;
            (conn->tx_complete).tail = psVar1;
          }
          irq_unlock();
          k_work_submit(&conn->tx_complete_work);
          sem = bt_conn_get_pkts(conn);
          k_sem_give(sem);
          sem = &g_poll_sem;
        }
        else {
          conn->pending_no_cb = conn->pending_no_cb - 1;
          irq_unlock();
          sem = bt_conn_get_pkts(conn);
        }
        sVar6 = sVar6 + -1;
        k_sem_give(sem);
      }
      bt_conn_unref(conn);
    }
    iVar7 = iVar7 + 1;
  } while( true );
}



void update_sec_level(bt_conn *conn)

{
  int iVar1;
  bt_security_t bVar2;
  
  if (conn->encrypt == '\0') {
    conn->sec_level = BT_SECURITY_LOW;
    return;
  }
  iVar1 = *(int *)(conn->field_20 + 0x2c);
  if ((iVar1 == 0) || ((*(byte *)(iVar1 + 9) & 1) == 0)) {
    bVar2 = BT_SECURITY_MEDIUM;
  }
  else {
    if (((*(byte *)(iVar1 + 9) & 0x10) == 0) || (*(char *)(iVar1 + 8) != '\x10')) {
      bVar2 = BT_SECURITY_L3;
    }
    else {
      bVar2 = BT_SECURITY_L4;
    }
  }
  conn->sec_level = bVar2;
  if ((byte)conn->sec_level < (byte)conn->required_sec_level) {
    printf("Failed to set required security level\r\n");
    bt_conn_disconnect(conn,'\x05');
    return;
  }
  return;
}



void hci_encrypt_key_refresh_complete(net_buf *buf)

{
  ushort handle;
  byte *pbVar1;
  bt_conn *conn;
  uint uVar2;
  
  pbVar1 = *(byte **)&buf->field_4;
  handle = *(ushort *)(pbVar1 + 1);
  conn = bt_conn_lookup_handle(handle);
  if (conn == (bt_conn *)0x0) {
    printf("Unable to look up conn with handle %u\r\n",(uint)handle);
    return;
  }
  if (*pbVar1 == 0) {
    if (conn->type == '\x01') {
      bt_smp_update_keys(conn);
      update_sec_level(conn);
    }
    conn->required_sec_level = conn->sec_level;
    bt_l2cap_encrypt_change(conn,*pbVar1);
    uVar2 = 0;
  }
  else {
    conn->required_sec_level = conn->sec_level;
    bt_l2cap_encrypt_change(conn,*pbVar1);
    uVar2 = 8;
    if (*pbVar1 < 0x2a) {
      uVar2 = (uint)(byte)CSWTCH_71[*pbVar1];
    }
  }
  bt_conn_security_changed(conn,uVar2);
  bt_conn_unref(conn);
  return;
}



void hci_encrypt_change(net_buf *buf)

{
  byte bVar1;
  ushort handle;
  byte *pbVar2;
  bt_conn *conn;
  uint uVar3;
  
  pbVar2 = *(byte **)&buf->field_4;
  handle = *(ushort *)(pbVar2 + 1);
  conn = bt_conn_lookup_handle(handle);
  if (conn == (bt_conn *)0x0) {
    printf("Unable to look up conn with handle %u\r\n",(uint)handle);
    return;
  }
  if (*pbVar2 == 0) {
    bVar1 = pbVar2[3];
    conn->encrypt = bVar1;
    if (conn->type == '\x01') {
      if (bVar1 != 0) {
        bt_smp_update_keys(conn);
      }
      update_sec_level(conn);
    }
    conn->required_sec_level = conn->sec_level;
    bt_l2cap_encrypt_change(conn,*pbVar2);
    uVar3 = 0;
  }
  else {
    conn->required_sec_level = conn->sec_level;
    bt_l2cap_encrypt_change(conn,*pbVar2);
    uVar3 = 8;
    if (*pbVar2 < 0x2a) {
      uVar3 = (uint)(byte)CSWTCH_71[*pbVar2];
    }
  }
  bt_conn_security_changed(conn,uVar3);
  bt_conn_unref(conn);
  return;
}



bt_conn * find_pending_connect(bt_addr_le_t *peer_addr)

{
  bt_conn *pbVar1;
  
  pbVar1 = bt_conn_lookup_state_le(peer_addr,BT_CONN_CONNECT);
  if (pbVar1 == (bt_conn *)0x0) {
    pbVar1 = bt_conn_lookup_state_le(peer_addr,BT_CONN_CONNECT_DIR_ADV);
    return pbVar1;
  }
  return pbVar1;
}



void hci_vendor_event(net_buf *buf)

{
  undefined2 uVar1;
  size_t sVar2;
  
  if (hci_vnd_evt_cb != (bt_hci_vnd_evt_cb_t *)0x0) {
    sVar2 = net_buf_simple_headroom((net_buf_simple *)&buf->field_4);
    uVar1 = *(undefined2 *)((int)&buf->field_4 + 4);
    (*hci_vnd_evt_cb)((net_buf_simple *)&buf->field_4);
    *(size_t *)&buf->field_4 = *(int *)((int)&buf->field_4 + 8) + (sVar2 & 0xffff);
    *(undefined2 *)((int)&buf->field_4 + 4) = uVar1;
  }
  return;
}



// WARNING: Exceeded maximum restarts with more pending

void handle_event(u8_t event,net_buf *buf,event_handler *handlers,size_t num_handlers)

{
  undefined3 in_register_00002029;
  uint uVar1;
  char *pcVar2;
  uint len;
  event_handler *peVar3;
  
  uVar1 = CONCAT31(in_register_00002029,event);
  peVar3 = handlers + num_handlers;
  do {
    if ((uint)handlers->event == uVar1) {
      if ((uint)*(ushort *)((int)&buf->field_4 + 4) < (uint)handlers->min_len) {
        printf("Too small (%u bytes) event 0x%02x\r\n",uVar1);
        return;
      }
                    // WARNING: Could not recover jumptable at 0x2301ca54. Too many branches
                    // WARNING: Treating indirect jump as call
      (*handlers->handler)();
      return;
    }
    handlers = handlers + 1;
  } while (handlers != peVar3);
  len = (uint)*(ushort *)((int)&buf->field_4 + 4);
  pcVar2 = bt_hex_real(*(void **)&buf->field_4,len);
  printf("Unhandled event 0x%02x len %u: %s\r\n",uVar1,len,pcVar2);
  return;
}



void hci_le_meta_event(net_buf *buf)

{
  u8_t *puVar1;
  
  puVar1 = (u8_t *)net_buf_simple_pull_mem((net_buf_simple *)&buf->field_4,1);
  handle_event(*puVar1,buf,meta_events,9);
  return;
}



void hci_cmd_done(u16_t opcode,u8_t status,net_buf *buf)

{
  byte bVar1;
  undefined2 in_register_0000202a;
  uint uVar2;
  net_buf_pool *pnVar3;
  int iVar4;
  undefined3 in_register_0000202d;
  cmd_state_set *pcVar5;
  
  uVar2 = CONCAT22(in_register_0000202a,opcode);
  pnVar3 = net_buf_pool_get((uint)buf->pool_id);
  if (pnVar3 != &hci_cmd_pool) {
    bVar1 = buf->pool_id;
    pnVar3 = net_buf_pool_get((uint)bVar1);
    printf("opcode 0x%04x pool id %u pool %p != &hci_cmd_pool %p\r\n",uVar2,(uint)bVar1,pnVar3,
           &hci_cmd_pool);
    return;
  }
  iVar4 = net_buf_id(buf);
  if ((uint)cmd_data[iVar4].opcode != uVar2) {
    iVar4 = net_buf_id(buf);
    printf("OpCode 0x%04x completed instead of expected 0x%04x\r\n",uVar2,
           (uint)cmd_data[iVar4].opcode);
  }
  iVar4 = net_buf_id(buf);
  if ((cmd_data[iVar4].state != (cmd_state_set *)0x0) &&
     (CONCAT31(in_register_0000202d,status) == 0)) {
    iVar4 = net_buf_id(buf);
    pcVar5 = cmd_data[iVar4].state;
    atomic_set_bit_to(pcVar5->target,pcVar5->bit,pcVar5->val);
  }
  iVar4 = net_buf_id(buf);
  if (cmd_data[iVar4].sync != (k_sem *)0x0) {
    iVar4 = net_buf_id(buf);
    cmd_data[iVar4].status = status;
    iVar4 = net_buf_id(buf);
    k_sem_give(cmd_data[iVar4].sync);
    return;
  }
  return;
}



void hci_cmd_status(net_buf *buf)

{
  u8_t uVar1;
  u8_t *puVar2;
  
  puVar2 = (u8_t *)net_buf_simple_pull_mem((net_buf_simple *)&buf->field_4,4);
  uVar1 = puVar2[1];
  hci_cmd_done(*(u16_t *)(puVar2 + 2),*puVar2,buf);
  if (uVar1 != '\0') {
    k_sem_give(&bt_dev.ncmd_sem);
    return;
  }
  return;
}



void hci_cmd_complete(net_buf *buf)

{
  char cVar1;
  char *pcVar2;
  
  pcVar2 = (char *)net_buf_simple_pull_mem((net_buf_simple *)&buf->field_4,3);
  cVar1 = *pcVar2;
  hci_cmd_done(*(u16_t *)(pcVar2 + 1),**(u8_t **)&buf->field_4,buf);
  if (cVar1 != '\0') {
    k_sem_give(&bt_dev.ncmd_sem);
    return;
  }
  return;
}



int id_find(bt_addr_le_t *addr)

{
  uint uVar1;
  int iVar2;
  
  uVar1 = 0;
  while( true ) {
    if (bt_dev.id_count <= uVar1) {
      return -2;
    }
    iVar2 = memcmp(addr,bt_dev.id_addr + uVar1,7);
    if (iVar2 == 0) break;
    uVar1 = uVar1 + 1 & 0xff;
  }
  return uVar1;
}



void sys_put_le64(u8_t *dst)

{
  undefined4 in_a1;
  undefined *in_a2;
  
  in_a2[1] = (char)((uint)dst >> 8);
  *in_a2 = (char)dst;
  in_a2[2] = 0;
  in_a2[3] = (char)((uint)dst >> 0x18);
  in_a2[4] = 0;
  in_a2[5] = (char)((uint)in_a1 >> 8);
  in_a2[6] = 0;
  in_a2[7] = (char)((uint)in_a1 >> 0x18);
  return;
}



net_buf * bt_hci_cmd_create(u16_t opcode,u8_t param_len)

{
  net_buf *buf;
  int iVar1;
  undefined *puVar2;
  
  buf = net_buf_alloc_fixed(&hci_cmd_pool,-1);
  net_buf_simple_reserve((net_buf_simple *)&buf->field_4,1);
  buf->user_data[0] = '\0';
  iVar1 = net_buf_id(buf);
  cmd_data[iVar1].opcode = opcode;
  iVar1 = net_buf_id(buf);
  cmd_data[iVar1].sync = (k_sem *)0x0;
  iVar1 = net_buf_id(buf);
  cmd_data[iVar1].state = (cmd_state_set *)0x0;
  puVar2 = (undefined *)net_buf_simple_add((net_buf_simple *)&buf->field_4,3);
  *puVar2 = (char)opcode;
  puVar2[1] = (char)(opcode >> 8);
  puVar2[2] = param_len;
  return buf;
}



int bt_hci_cmd_send_sync(u16_t opcode,net_buf *buf,net_buf **rsp)

{
  undefined2 in_register_0000202a;
  int iVar1;
  int iVar2;
  undefined auStack44 [4];
  k_sem sync_sem;
  
  if ((buf == (net_buf *)0x0) && (buf = bt_hci_cmd_create(opcode,'\0'), buf == (net_buf *)0x0)) {
    return -0x37;
  }
  k_sem_init((k_sem *)auStack44,0,1);
  iVar1 = net_buf_id(buf);
  cmd_data[iVar1].sync = (k_sem *)auStack44;
  iVar1 = net_buf_id(buf);
  cmd_data[iVar1].status = -1;
  net_buf_ref(buf);
  net_buf_put(&bt_dev.cmd_tx_queue,buf);
  k_sem_give(&g_poll_sem);
  k_sem_take((k_sem *)auStack44,10000);
  k_sem_delete((k_sem *)auStack44);
  iVar1 = net_buf_id(buf);
  if (cmd_data[iVar1].status == '\0') {
    if (rsp == (net_buf **)0x0) {
      net_buf_unref(buf);
    }
    else {
      *rsp = buf;
    }
    iVar1 = 0;
  }
  else {
    iVar2 = net_buf_id(buf);
    iVar1 = -0x3d;
    if ((cmd_data[iVar2].status != '\t') && (iVar1 = -5, cmd_data[iVar2].status == -1)) {
      printf("k_sem_take timeout with opcode 0x%04x\r\n",CONCAT22(in_register_0000202a,opcode));
      vAssertCalled();
      iVar1 = -0x4f;
    }
    net_buf_unref(buf);
  }
  return iVar1;
}



// WARNING: Could not reconcile some variable overlaps

int set_le_scan_enable(u8_t enable)

{
  undefined3 in_register_00002029;
  net_buf *buf;
  u8_t *puVar1;
  int iVar2;
  atomic_t *paStack44;
  cmd_state_set state;
  
  buf = bt_hci_cmd_create(0x200c,'\x02');
  if (buf == (net_buf *)0x0) {
    iVar2 = -0x37;
  }
  else {
    puVar1 = (u8_t *)net_buf_simple_add((net_buf_simple *)&buf->field_4,2);
    if (CONCAT31(in_register_00002029,enable) == 1) {
      iVar2 = atomic_test_bit(bt_dev.flags,0xd);
      puVar1[1] = (u8_t)iVar2;
    }
    else {
      puVar1[1] = '\0';
    }
    *puVar1 = enable;
    state.bit._0_1_ = (_Bool)(enable & 1);
    state.target = (atomic_t *)&DAT_0000000a;
    paStack44 = (atomic_t *)0x4200d3c4;
    iVar2 = net_buf_id(buf);
    cmd_data[iVar2].state = (cmd_state_set *)&paStack44;
    iVar2 = bt_hci_cmd_send_sync(0x200c,buf,(net_buf **)0x0);
  }
  return iVar2;
}



int set_random_address(bt_addr_t *addr)

{
  int iVar1;
  net_buf *buf;
  
  iVar1 = memcmp(addr,&bt_dev.random_addr.a,6);
  if (iVar1 != 0) {
    buf = bt_hci_cmd_create(0x2005,'\x06');
    iVar1 = -0x37;
    if (buf != (net_buf *)0x0) {
      net_buf_simple_add_mem((net_buf_simple *)&buf->field_4,addr,6);
      iVar1 = bt_hci_cmd_send_sync(0x2005,buf,(net_buf **)0x0);
      if (iVar1 == 0) {
        memcpy(&bt_dev.random_addr.a,addr,6);
        bt_dev.random_addr.type = '\x01';
      }
    }
  }
  return iVar1;
}



int le_set_private_addr(void)

{
  int iVar1;
  undefined auStack24 [4];
  bt_addr_t nrpa;
  
  iVar1 = bt_rand(auStack24,6);
  if (iVar1 == 0) {
    nrpa.val[1] = nrpa.val[1] & 0x3f;
    iVar1 = set_random_address((bt_addr_t *)auStack24);
  }
  return iVar1;
}



int hci_id_add(bt_addr_le_t *addr,u8_t *val)

{
  net_buf *buf;
  bt_addr_le_t *dst;
  int iVar1;
  
  buf = bt_hci_cmd_create(0x2027,'\'');
  if (buf != (net_buf *)0x0) {
    dst = (bt_addr_le_t *)net_buf_simple_add((net_buf_simple *)&buf->field_4,0x27);
    bt_addr_le_copy(dst,addr);
    memcpy(dst + 1,val,0x10);
    memset(dst[3].a.val + 1,0,0x10);
    iVar1 = bt_hci_cmd_send_sync(0x2027,buf,(net_buf **)0x0);
    return iVar1;
  }
  return -0x37;
}



void keys_add_id(bt_keys *keys,void *data)

{
  hci_id_add(&keys->addr,(u8_t *)&keys->irk);
  return;
}



int addr_res_enable(u8_t enable)

{
  net_buf *buf;
  int iVar1;
  
  buf = bt_hci_cmd_create(0x202d,'\x01');
  if (buf != (net_buf *)0x0) {
    net_buf_simple_add_u8((net_buf_simple *)&buf->field_4,enable);
    iVar1 = bt_hci_cmd_send_sync(0x202d,buf,(net_buf **)0x0);
    return iVar1;
  }
  return -0x37;
}



// WARNING: Could not reconcile some variable overlaps

int set_advertise_enable(_Bool enable)

{
  undefined3 in_register_00002029;
  net_buf *buf;
  int iVar1;
  atomic_t *paStack28;
  cmd_state_set state;
  
  buf = bt_hci_cmd_create(0x200a,'\x01');
  if (buf == (net_buf *)0x0) {
    iVar1 = -0x37;
  }
  else {
    net_buf_simple_add_u8
              ((net_buf_simple *)&buf->field_4,CONCAT31(in_register_00002029,enable) != 0);
    paStack28 = (atomic_t *)0x4200d3c4;
    state.target = (atomic_t *)0x6;
    state.bit._0_1_ = enable;
    iVar1 = net_buf_id(buf);
    cmd_data[iVar1].state = (cmd_state_set *)&paStack28;
    iVar1 = bt_hci_cmd_send_sync(0x200a,buf,(net_buf **)0x0);
  }
  return iVar1;
}



void hci_disconn_complete(net_buf *buf)

{
  ushort handle;
  char *pcVar1;
  bt_conn *conn;
  int iVar2;
  
  pcVar1 = *(char **)&buf->field_4;
  if (*pcVar1 == '\0') {
    handle = *(ushort *)(pcVar1 + 1);
    conn = bt_conn_lookup_handle(handle);
    if (conn == (bt_conn *)0x0) {
      printf("Unable to look up conn with handle %u\r\n",(uint)handle);
    }
    else {
      conn->err = pcVar1[3];
      bt_conn_set_state(conn,BT_CONN_DISCONNECTED);
      conn->handle = 0;
      if (conn->type != '\x01') {
        bt_conn_unref(conn);
        return;
      }
      bt_conn_unref(conn);
      atomic_clear(&conn->ref);
    }
    iVar2 = atomic_test_bit(bt_dev.flags,9);
    if ((iVar2 != 0) && (iVar2 = atomic_test_bit(bt_dev.flags,6), iVar2 == 0)) {
      set_advertise_enable(true);
      return;
    }
  }
  return;
}



int set_ad(u16_t hci_op,bt_ad *ad,size_t ad_len)

{
  net_buf *buf;
  byte *__s;
  int iVar1;
  uint uVar2;
  size_t __n;
  byte bVar3;
  uint uVar4;
  bt_ad *pbVar5;
  bt_data *pbVar6;
  uint uVar7;
  
  buf = bt_hci_cmd_create(hci_op,' ');
  if (buf == (net_buf *)0x0) {
    return -0x37;
  }
  __s = (byte *)net_buf_simple_add((net_buf_simple *)&buf->field_4,0x20);
  pbVar5 = ad + ad_len;
  memset(__s,0,0x20);
  do {
    if (ad == pbVar5) {
      iVar1 = bt_hci_cmd_send_sync(hci_op,buf,(net_buf **)0x0);
      return iVar1;
    }
    pbVar6 = ad->data;
    uVar7 = 0;
    while (uVar7 < ad->len) {
      __n = (size_t)pbVar6->data_len;
      uVar4 = (uint)*__s;
      bVar3 = pbVar6->type;
      if (0x1d < uVar4 + __n) {
        __n = 0x1d - uVar4;
        if ((bVar3 != 9) || (__n == 0)) {
          net_buf_unref(buf);
          printf("Too big advertising data\r\n");
          return -0x16;
        }
        bVar3 = 8;
      }
      __s[uVar4 + 1] = (char)__n + 1;
      uVar2 = uVar4 + 2 & 0xff;
      *__s = (byte)uVar2;
      __s[(uVar4 + 1 & 0xff) + 1] = bVar3;
      memcpy(__s + uVar2 + 1,pbVar6->data,__n);
      uVar7 = uVar7 + 1;
      pbVar6 = pbVar6 + 1;
      *__s = (char)__n + *__s;
    }
    ad = ad + 1;
  } while( true );
}



// WARNING: Variable defined which should be unmapped: d
// WARNING: Could not reconcile some variable overlaps

int le_adv_update(bt_data *ad,size_t ad_len,bt_data *sd,size_t sd_len,_Bool connectable,
                 _Bool use_name)

{
  int iVar1;
  size_t sVar2;
  size_t sVar3;
  undefined3 in_register_00002039;
  undefined3 in_register_0000203d;
  undefined uStack40;
  undefined uStack39;
  bt_data data;
  bt_ad d [2];
  
  d[0].len = 0;
  data.data = (u8_t *)ad;
  iVar1 = set_ad(0x2008,(bt_ad *)&data.data,1);
  if (iVar1 == 0) {
    data.data = (u8_t *)sd;
    if (CONCAT31(in_register_0000203d,use_name) != 0) {
      if (sd != (bt_data *)0x0) {
        sVar3 = 0;
        while (sVar3 != sd_len) {
          if ((byte)(sd[sVar3].type - 8) < 2) {
            return -0x16;
          }
          sVar3 = sVar3 + 1;
        }
      }
      sVar2 = strlen(bt_dev.name);
      uStack40 = 9;
      d[0].len = (size_t)&uStack40;
      uStack39 = (undefined)sVar2;
      data._0_4_ = 0x4200d410;
    }
    if (((data.data != (u8_t *)0x0) || (d[0].len != 0)) ||
       (CONCAT31(in_register_00002039,connectable) != 0)) {
      iVar1 = set_ad(0x2009,(bt_ad *)&data.data,2);
    }
  }
  return iVar1;
}



bt_addr_le_t * bt_lookup_id_addr(u8_t id,bt_addr_le_t *addr)

{
  bt_keys *pbVar1;
  
  pbVar1 = bt_keys_find_irk(id,addr);
  if (pbVar1 != (bt_keys *)0x0) {
    addr = &pbVar1->addr;
  }
  return addr;
}



_Bool bt_le_conn_params_valid(bt_le_conn_param *param)

{
  ushort uVar1;
  bool bVar2;
  
  uVar1 = param->interval_max;
  bVar2 = false;
  if (((((uint)param->interval_min <= (uint)uVar1) && (bVar2 = false, 5 < param->interval_min)) &&
      (uVar1 < 0xc81)) && ((param->latency < 500 && (((uint)param->timeout - 10 & 0xffff) < 0xc77)))
     ) {
    bVar2 = ((uint)param->latency + 1) * (uint)uVar1 < (uint)param->timeout << 2;
  }
  return (_Bool)bVar2;
}



int bt_unpair(u8_t id,bt_addr_le_t *addr)

{
  undefined3 in_register_00002029;
  int iVar1;
  bt_conn *conn;
  bt_keys *keys;
  undefined4 uStack24;
  undefined2 uStack20;
  undefined uStack18;
  
  if (CONCAT31(in_register_00002029,id) != 0) {
    return -0x16;
  }
  if (addr == (bt_addr_le_t *)0x0) {
LAB_2301d3aa:
    bt_conn_disconnect_all('\0');
    bt_keys_clear_all('\0');
    return 0;
  }
  uStack24 = 0;
  uStack20 = 0;
  uStack18 = 0;
  iVar1 = memcmp(addr,&uStack24,7);
  if (iVar1 == 0) goto LAB_2301d3aa;
  conn = bt_conn_lookup_addr_le('\0',addr);
  if (conn != (bt_conn *)0x0) {
    keys = (bt_keys *)0x0;
    if (conn->type == '\x01') {
      keys = *(bt_keys **)(conn->field_20 + 0x2c);
      *(undefined4 *)(conn->field_20 + 0x2c) = 0;
    }
    bt_conn_disconnect(conn,'\x13');
    bt_conn_unref(conn);
    if (keys != (bt_keys *)0x0) goto LAB_2301d3f2;
  }
  keys = bt_keys_find_addr('\0',addr);
  if (keys == (bt_keys *)0x0) {
    return 0;
  }
LAB_2301d3f2:
  bt_keys_clear(keys);
  return 0;
}



void bt_id_add(bt_keys *keys)

{
  bt_conn *conn;
  int iVar1;
  int iVar2;
  int iVar3;
  char *fmt;
  net_buf *buf;
  undefined auStack40 [4];
  bt_hci_cp_le_set_privacy_mode cp;
  
  if ((bt_dev.le.rl_size == '\0') || (bt_dev.le.rl_size < bt_dev.le.rl_entries)) {
    bt_dev.le.rl_entries = bt_dev.le.rl_entries + '\x01';
    return;
  }
  conn = bt_conn_lookup_state_le((bt_addr_le_t *)0x0,BT_CONN_CONNECT);
  if (conn != (bt_conn *)0x0) {
    atomic_or(bt_dev.flags,0x20000);
    keys->flags = keys->flags | 4;
    bt_conn_unref(conn);
    return;
  }
  iVar1 = atomic_test_bit(bt_dev.flags,6);
  if (iVar1 != 0) {
    set_advertise_enable(false);
  }
  iVar2 = atomic_test_bit(bt_dev.flags,10);
  if (iVar2 != 0) {
    set_le_scan_enable('\0');
  }
  if ((bt_dev.le.rl_entries == '\0') || (iVar3 = addr_res_enable('\0'), iVar3 == 0)) {
    if (bt_dev.le.rl_entries == bt_dev.le.rl_size) {
      printf("Resolving list size exceeded. Switching to host.\r\n");
      iVar3 = bt_hci_cmd_send_sync(0x2029,(net_buf *)0x0,(net_buf **)0x0);
      if (iVar3 == 0) {
        bt_dev.le.rl_entries = bt_dev.le.rl_entries + '\x01';
        goto done;
      }
      fmt = "Failed to clear resolution list\r\n";
    }
    else {
      iVar3 = hci_id_add(&keys->addr,(u8_t *)&keys->irk);
      if (iVar3 == 0) {
        bt_dev.le.rl_entries = bt_dev.le.rl_entries + '\x01';
        if ((bt_dev.supported_commands[39] & 4) == 0) {
          fmt = "Set privacy mode command is not supported\r\n";
        }
        else {
          bt_addr_le_copy((bt_addr_le_t *)auStack40,&keys->addr);
          cp.id_addr.a.val[2] = '\x01';
          buf = bt_hci_cmd_create(0x204e,'\b');
          if (buf != (net_buf *)0x0) {
            net_buf_simple_add_mem((net_buf_simple *)&buf->field_4,auStack40,8);
            iVar3 = bt_hci_cmd_send_sync(0x204e,buf,(net_buf **)0x0);
            if (iVar3 == 0) goto done;
          }
          fmt = "Failed to set privacy mode\r\n";
        }
      }
      else {
        fmt = "Failed to add IRK to controller\r\n";
      }
    }
  }
  else {
    fmt = "Failed to disable address resolution\r\n";
  }
  printf(fmt);
done:
  addr_res_enable('\x01');
  if (iVar2 != 0) {
    set_le_scan_enable('\x01');
  }
  if (iVar1 != 0) {
    set_advertise_enable(true);
  }
  return;
}



void bt_id_del(bt_keys *keys)

{
  bt_conn *conn;
  int iVar1;
  int iVar2;
  int iVar3;
  net_buf *buf;
  bt_addr_le_t *dst;
  
  if ((bt_dev.le.rl_size == '\0') || ((uint)bt_dev.le.rl_size + 1 < (uint)bt_dev.le.rl_entries)) {
    bt_dev.le.rl_entries = bt_dev.le.rl_entries + -1;
  }
  else {
    conn = bt_conn_lookup_state_le((bt_addr_le_t *)0x0,BT_CONN_CONNECT);
    if (conn != (bt_conn *)0x0) {
      atomic_or(bt_dev.flags,0x20000);
      keys->flags = keys->flags | 8;
      bt_conn_unref(conn);
      return;
    }
    iVar1 = atomic_test_bit(bt_dev.flags,6);
    if (iVar1 != 0) {
      set_advertise_enable(false);
    }
    iVar2 = atomic_test_bit(bt_dev.flags,10);
    if (iVar2 != 0) {
      set_le_scan_enable('\0');
    }
    iVar3 = addr_res_enable('\0');
    if (iVar3 == 0) {
      if (bt_dev.le.rl_size < bt_dev.le.rl_entries) {
        bt_dev.le.rl_entries = bt_dev.le.rl_entries + -1;
        keys->keys = keys->keys & 0xfffd;
        bt_keys_foreach(2,keys_add_id,(void *)0x0);
      }
      else {
        buf = bt_hci_cmd_create(0x2028,'\a');
        if (buf != (net_buf *)0x0) {
          dst = (bt_addr_le_t *)net_buf_simple_add((net_buf_simple *)&buf->field_4,7);
          bt_addr_le_copy(dst,&keys->addr);
          iVar3 = bt_hci_cmd_send_sync(0x2028,buf,(net_buf **)0x0);
          if (iVar3 == 0) {
            bt_dev.le.rl_entries = bt_dev.le.rl_entries + -1;
          }
          else {
            printf("Failed to remove IRK from controller\r\n");
          }
        }
      }
    }
    else {
      printf("Disabling address resolution failed (err %d)\r\n",iVar3);
    }
    if (bt_dev.le.rl_entries != '\0') {
      addr_res_enable('\x01');
    }
    if (iVar2 != 0) {
      set_le_scan_enable('\x01');
    }
    if (iVar1 != 0) {
      set_advertise_enable(true);
      return;
    }
  }
  return;
}



void update_pending_id(bt_keys *keys,void *data)

{
  byte bVar1;
  
  bVar1 = keys->flags;
  if ((bVar1 & 4) != 0) {
    keys->flags = bVar1 & 0xfb;
    bt_id_add(keys);
    return;
  }
  if ((bVar1 & 8) != 0) {
    keys->flags = bVar1 & 0xf7;
    bt_id_del(keys);
    return;
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

void bt_data_parse(net_buf_simple *ad,anon_subr__Bool_bt_data_ptr_void_ptr *func,void *user_data)

{
  u8_t uVar1;
  _Bool _Var2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  u8_t uStack40;
  u8_t uStack39;
  bt_data data;
  
  while( true ) {
    if (ad->len < 2) {
      return;
    }
    uVar1 = net_buf_simple_pull_u8(ad);
    _uVar1 = CONCAT31(extraout_var,uVar1);
    if (_uVar1 == 0) {
      return;
    }
    if ((uint)ad->len < (_uVar1 & 0xffff)) {
      printf("Malformed data\r\n");
      return;
    }
    uStack40 = net_buf_simple_pull_u8(ad);
    data._0_4_ = ad->data;
    uStack39 = (u8_t)(_uVar1 - 1);
    _Var2 = (*func)((bt_data *)&uStack40,user_data);
    if (CONCAT31(extraout_var_00,_Var2) == 0) break;
    net_buf_simple_pull(ad,_uVar1 - 1);
  }
  return;
}



int bt_addr_le_create_static(bt_addr_le_t *addr)

{
  int iVar1;
  
  addr->type = '\x01';
  iVar1 = bt_rand(&addr->a,6);
  if (iVar1 == 0) {
    (addr->a).val[5] = (addr->a).val[5] | 0xc0;
  }
  return iVar1;
}



void id_create(u8_t id,bt_addr_le_t *addr)

{
  bool bVar1;
  bt_addr_le_t *dst;
  undefined3 in_register_00002029;
  int iVar2;
  bt_addr_le_t *dst_00;
  undefined4 local_20;
  undefined2 uStack28;
  undefined uStack26;
  undefined auStack24 [4];
  bt_addr_le_t new_addr;
  
  dst = bt_dev.id_addr + CONCAT31(in_register_00002029,id);
  if (addr != (bt_addr_le_t *)0x0) {
    local_20 = 0;
    uStack28 = 0;
    uStack26 = 0;
    iVar2 = memcmp(addr,&local_20,7);
    dst_00 = dst;
    if (iVar2 != 0) goto LAB_2301d81a;
  }
  do {
    bt_addr_le_create_static((bt_addr_le_t *)auStack24);
    iVar2 = id_find((bt_addr_le_t *)auStack24);
  } while (-1 < iVar2);
  bt_addr_le_copy(dst,(bt_addr_le_t *)auStack24);
  bVar1 = addr == (bt_addr_le_t *)0x0;
  dst_00 = addr;
  addr = dst;
  if (bVar1) {
    return;
  }
LAB_2301d81a:
  bt_addr_le_copy(dst_00,addr);
  return;
}



// WARNING: Exceeded maximum restarts with more pending

int bt_send(net_buf *buf)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x2301d854. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(bt_dev.drv)->send)();
  return iVar1;
}



int bt_hci_cmd_send(u16_t opcode,net_buf *buf)

{
  undefined2 in_register_0000202a;
  int iVar1;
  
  if ((buf == (net_buf *)0x0) && (buf = bt_hci_cmd_create(opcode,'\0'), buf == (net_buf *)0x0)) {
    return -0x37;
  }
  if (CONCAT22(in_register_0000202a,opcode) == 0xc35) {
    iVar1 = bt_send(buf);
    if (iVar1 != 0) {
      printf("Unable to send to driver (err %d)\r\n",iVar1);
      net_buf_unref(buf);
    }
  }
  else {
    net_buf_put(&bt_dev.cmd_tx_queue,buf);
    k_sem_give(&g_poll_sem);
    iVar1 = 0;
  }
  return iVar1;
}



int bt_le_set_data_len(bt_conn *conn,u16_t tx_octets,u16_t tx_time)

{
  u16_t uVar1;
  net_buf *buf;
  undefined *puVar2;
  int iVar3;
  
  buf = bt_hci_cmd_create(0x2022,'\x06');
  if (buf != (net_buf *)0x0) {
    puVar2 = (undefined *)net_buf_simple_add((net_buf_simple *)&buf->field_4,6);
    uVar1 = conn->handle;
    puVar2[2] = (char)tx_octets;
    puVar2[4] = (char)tx_time;
    *puVar2 = (char)uVar1;
    puVar2[1] = (char)(uVar1 >> 8);
    puVar2[3] = (char)(tx_octets >> 8);
    puVar2[5] = (char)(tx_time >> 8);
    iVar3 = bt_hci_cmd_send(0x2022,buf);
    return iVar3;
  }
  printf("bt_le_set_data_len, Failed to create LE Set Data Length Command\r\n");
  return -0x37;
}



// WARNING: Could not reconcile some variable overlaps

int start_le_scan(u8_t scan_type,u16_t interval,u16_t window)

{
  undefined3 in_register_00002029;
  int iVar1;
  net_buf *buf;
  u8_t uStack40;
  undefined uStack39;
  undefined uStack38;
  undefined uStack37;
  bt_hci_cp_le_set_scan_param set_param;
  
  memset(&uStack40,0,7);
  uStack37 = (undefined)window;
  uStack39 = (undefined)interval;
  set_param.scan_type = (u8_t)(window >> 8);
  uStack38 = (undefined)(interval >> 8);
  uStack40 = scan_type;
  iVar1 = atomic_test_bit(bt_dev.flags,0xe);
  set_param.interval._1_1_ = iVar1 != 0;
  set_param.interval._0_1_ = bt_dev.id_addr[0].type;
  if ((CONCAT31(in_register_00002029,scan_type) == 1) &&
     (iVar1 = atomic_test_bit(bt_dev.flags,6), iVar1 == 0)) {
    iVar1 = le_set_private_addr();
    set_param.interval._0_1_ = scan_type;
  }
  else {
    if ((u8_t)set_param.interval != '\x01') goto LAB_2301d9ce;
    iVar1 = set_random_address(&bt_dev.id_addr[0].a);
  }
  if (iVar1 != 0) {
    return iVar1;
  }
LAB_2301d9ce:
  buf = bt_hci_cmd_create(0x200b,'\a');
  iVar1 = -0x37;
  if (buf != (net_buf *)0x0) {
    net_buf_simple_add_mem((net_buf_simple *)&buf->field_4,&uStack40,7);
    bt_hci_cmd_send(0x200b,buf);
    iVar1 = set_le_scan_enable('\x01');
    if (iVar1 == 0) {
      atomic_set_bit_to(bt_dev.flags,0xc,(_Bool)(CONCAT31(in_register_00002029,scan_type) == 1));
    }
  }
  return iVar1;
}



int bt_le_scan_update(_Bool fast_scan)

{
  undefined3 in_register_00002029;
  int iVar1;
  bt_conn *conn;
  u16_t interval;
  u16_t window;
  
  iVar1 = atomic_test_bit(bt_dev.flags,0xb);
  if (iVar1 == 0) {
    iVar1 = atomic_test_bit(bt_dev.flags,10);
    if ((iVar1 != 0) && (iVar1 = set_le_scan_enable('\0'), iVar1 != 0)) {
      return iVar1;
    }
    conn = bt_conn_lookup_state_le((bt_addr_le_t *)0x0,BT_CONN_CONNECT);
    if (conn == (bt_conn *)0x0) {
      conn = bt_conn_lookup_state_le((bt_addr_le_t *)0x0,BT_CONN_CONNECT_SCAN);
      if (conn != (bt_conn *)0x0) {
        atomic_and(bt_dev.flags,-0x2001);
        bt_conn_unref(conn);
        if (CONCAT31(in_register_00002029,fast_scan) == 0) {
          window = 0x12;
          interval = 0x800;
        }
        else {
          window = 0x30;
          interval = 0x60;
        }
        iVar1 = start_le_scan('\0',interval,window);
        return iVar1;
      }
    }
    else {
      bt_conn_unref(conn);
    }
  }
  return 0;
}



void le_adv_report(net_buf *buf)

{
  byte bVar1;
  undefined2 uVar2;
  bt_le_scan_cb_t_conflict1 *pbVar3;
  u8_t uVar4;
  undefined3 extraout_var;
  byte *pbVar5;
  size_t sVar6;
  int iVar7;
  bt_conn *conn;
  net_buf *buf_00;
  undefined *__s;
  bt_addr_le_t *src;
  uint uVar8;
  net_buf_simple *buf_01;
  bt_addr_le_t *addr;
  uint uVar9;
  u8_t auStack72 [4];
  bt_addr_le_t id_addr;
  
  buf_01 = (net_buf_simple *)&buf->field_4;
  uVar4 = net_buf_simple_pull_u8(buf_01);
  uVar8 = CONCAT31(extraout_var,uVar4);
  do {
    if (uVar8 == 0) {
      return;
    }
    if (*(ushort *)((int)&buf->field_4 + 4) < 9) {
      printf("Unexpected end of buffer\r\n");
      return;
    }
    pbVar5 = (byte *)net_buf_simple_pull_mem(buf_01,9);
    addr = (bt_addr_le_t *)(pbVar5 + 1);
    bVar1 = pbVar5[(uint)pbVar5[8] + 9];
    if ((byte)(pbVar5[1] - 2) < 2) {
      bt_addr_le_copy((bt_addr_le_t *)auStack72,addr);
      auStack72[0] = auStack72[0] + -2;
    }
    else {
      src = bt_lookup_id_addr(bt_dev.adv_id,addr);
      bt_addr_le_copy((bt_addr_le_t *)auStack72,src);
    }
    if (scan_dev_found_cb != (bt_le_scan_cb_t_conflict1 *)0x0) {
      sVar6 = net_buf_simple_headroom(buf_01);
      pbVar3 = scan_dev_found_cb;
      uVar2 = *(undefined2 *)((int)&buf->field_4 + 4);
      *(ushort *)((int)&buf->field_4 + 4) = (ushort)pbVar5[8];
      (*pbVar3)((bt_addr_le_t *)auStack72,bVar1,*pbVar5,buf_01);
      *(undefined2 *)((int)&buf->field_4 + 4) = uVar2;
      *(size_t *)&buf->field_4 = *(int *)((int)&buf->field_4 + 8) + (sVar6 & 0xffff);
    }
    bVar1 = *pbVar5;
    iVar7 = atomic_test_bit(bt_dev.flags,0xb);
    if (((iVar7 == 0) && (bVar1 < 2)) &&
       (conn = bt_conn_lookup_state_le((bt_addr_le_t *)auStack72,BT_CONN_CONNECT_SCAN),
       conn != (bt_conn *)0x0)) {
      iVar7 = atomic_test_bit(bt_dev.flags,10);
      if ((iVar7 == 0) || (iVar7 = set_le_scan_enable('\0'), iVar7 == 0)) {
        src = (bt_addr_le_t *)(conn->field_20 + 0xe);
        bt_addr_le_copy(src,addr);
        uVar9 = (uint)conn->id;
        if ((bt_dev.id_addr[uVar9].type != '\x01') ||
           (iVar7 = set_random_address(&bt_dev.id_addr[uVar9].a), iVar7 == 0)) {
          uVar4 = bt_dev.id_addr[uVar9].type;
          buf_00 = bt_hci_cmd_create(0x200d,'\x19');
          if (buf_00 != (net_buf *)0x0) {
            __s = (undefined *)net_buf_simple_add((net_buf_simple *)&buf_00->field_4,0x19);
            memset(__s,0,0x19);
            *__s = 0x60;
            __s[1] = 0;
            __s[2] = 0x60;
            __s[3] = 0;
            if ((bt_dev.le.rl_size != '\0') && (bt_dev.le.rl_entries <= bt_dev.le.rl_size)) {
              src = (bt_addr_le_t *)conn->field_20;
            }
            bt_addr_le_copy((bt_addr_le_t *)(__s + 5),src);
            __s[0xc] = uVar4;
            uVar2 = *(undefined2 *)(conn->field_20 + 0x18);
            __s[0xd] = (char)uVar2;
            __s[0xe] = (char)((ushort)uVar2 >> 8);
            uVar2 = *(undefined2 *)(conn->field_20 + 0x1a);
            __s[0xf] = (char)uVar2;
            __s[0x10] = (char)((ushort)uVar2 >> 8);
            uVar2 = *(undefined2 *)(conn->field_20 + 0x1c);
            __s[0x11] = (char)uVar2;
            __s[0x12] = (char)((ushort)uVar2 >> 8);
            uVar2 = *(undefined2 *)(conn->field_20 + 0x1e);
            __s[0x13] = (char)uVar2;
            __s[0x14] = (char)((ushort)uVar2 >> 8);
            iVar7 = bt_hci_cmd_send_sync(0x200d,buf_00,(net_buf **)0x0);
            if (iVar7 == 0) {
              bt_conn_set_state(conn,BT_CONN_CONNECT);
              bt_conn_unref(conn);
              goto LAB_2301dcd8;
            }
          }
        }
      }
      conn->err = '\x1f';
      bt_conn_set_state(conn,BT_CONN_DISCONNECTED);
      bt_conn_unref(conn);
      bt_le_scan_update(false);
    }
LAB_2301dcd8:
    net_buf_simple_pull(buf_01,(uint)pbVar5[8] + 1);
    uVar8 = uVar8 - 1 & 0xff;
  } while( true );
}



void le_ltk_request(net_buf *buf)

{
  ushort handle;
  undefined uVar1;
  ushort *puVar2;
  _Bool _Var3;
  u16_t opcode;
  bt_conn *conn;
  undefined3 extraout_var;
  net_buf *buf_00;
  undefined *puVar4;
  undefined auStack48 [4];
  u8_t ltk [16];
  
  puVar2 = *(ushort **)&buf->field_4;
  handle = *puVar2;
  conn = bt_conn_lookup_handle(handle);
  if (conn == (bt_conn *)0x0) {
    printf("Unable to lookup conn for handle %u\r\n",(uint)handle);
    return;
  }
  _Var3 = bt_smp_request_ltk(conn,(u16_t)*(undefined4 *)(puVar2 + 1),*(u8_t **)(puVar2 + 3));
  uVar1 = (undefined)(handle >> 8);
  if (CONCAT31(extraout_var,_Var3) == 0) {
    buf_00 = bt_hci_cmd_create(0x201b,'\x02');
    if (buf_00 == (net_buf *)0x0) goto LAB_2301ddc8;
    puVar4 = (undefined *)net_buf_simple_add((net_buf_simple *)&buf_00->field_4,2);
    *puVar4 = (char)handle;
    puVar4[1] = uVar1;
    opcode = 0x201b;
  }
  else {
    buf_00 = bt_hci_cmd_create(0x201a,'\x12');
    if (buf_00 == (net_buf *)0x0) {
LAB_2301ddc8:
      printf("Out of command buffers\r\n");
      goto LAB_2301ddd4;
    }
    puVar4 = (undefined *)net_buf_simple_add((net_buf_simple *)&buf_00->field_4,0x12);
    *puVar4 = (char)handle;
    puVar4[1] = uVar1;
    memcpy(puVar4 + 2,auStack48,0x10);
    opcode = 0x201a;
  }
  bt_hci_cmd_send(opcode,buf_00);
LAB_2301ddd4:
  bt_conn_unref(conn);
  return;
}



void le_conn_param_neg_reply(u16_t handle,u8_t reason)

{
  net_buf *buf;
  undefined *puVar1;
  
  buf = bt_hci_cmd_create(0x2021,'\x03');
  if (buf == (net_buf *)0x0) {
    printf("Unable to allocate buffer\r\n");
    return;
  }
  puVar1 = (undefined *)net_buf_simple_add((net_buf_simple *)&buf->field_4,3);
  *puVar1 = (char)handle;
  puVar1[1] = (char)(handle >> 8);
  puVar1[2] = reason;
  bt_hci_cmd_send(0x2021,buf);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void le_conn_param_req(net_buf *buf)

{
  ushort handle;
  _Bool _Var1;
  bt_conn *conn;
  undefined3 extraout_var;
  net_buf *buf_00;
  undefined *__s;
  ushort *puVar2;
  undefined2 uStack40;
  ushort uStack38;
  bt_le_conn_param param;
  
  puVar2 = *(ushort **)&buf->field_4;
  handle = *puVar2;
  uStack40 = puVar2[1];
  uStack38 = puVar2[2];
  param.interval_min = puVar2[3];
  param.interval_max = puVar2[4];
  conn = bt_conn_lookup_handle(handle);
  if (conn == (bt_conn *)0x0) {
    printf("Unable to lookup conn for handle %u\r\n",(uint)handle);
    le_conn_param_neg_reply(handle,'\x02');
  }
  else {
    _Var1 = le_param_req(conn,(bt_le_conn_param *)&uStack40);
    if (CONCAT31(extraout_var,_Var1) == 0) {
      le_conn_param_neg_reply(handle,'\x1e');
    }
    else {
      buf_00 = bt_hci_cmd_create(0x2020,'\x0e');
      if (buf_00 != (net_buf *)0x0) {
        __s = (undefined *)net_buf_simple_add((net_buf_simple *)&buf_00->field_4,0xe);
        memset(__s,0,0xe);
        *__s = (char)handle;
        __s[1] = (char)(handle >> 8);
        __s[2] = (undefined)uStack40;
        __s[3] = uStack40._1_1_;
        __s[4] = (char)uStack38;
        __s[5] = (char)(uStack38 >> 8);
        __s[6] = (undefined)param.interval_min;
        __s[7] = param.interval_min._1_1_;
        __s[8] = (char)param.interval_max;
        __s[9] = (char)(param.interval_max >> 8);
        bt_hci_cmd_send(0x2020,buf_00);
      }
    }
    bt_conn_unref(conn);
  }
  return;
}



void enh_conn_complete(bt_hci_evt_le_enh_conn_complete *evt)

{
  u8_t uVar1;
  u16_t uVar2;
  ushort uVar3;
  atomic_val_t aVar4;
  bt_conn *conn;
  int iVar5;
  net_buf *buf;
  undefined *puVar6;
  u8_t local_30;
  undefined auStack47 [3];
  bt_addr_le_t peer_addr;
  bt_addr_le_t id_addr;
  
  uVar3 = evt->handle;
  aVar4 = atomic_and(bt_dev.flags,-0x20001);
  if (aVar4 << 0xe < 0) {
    bt_keys_foreach(2,update_pending_id,(void *)0x0);
  }
  if (evt->status != '\0') {
    conn = find_pending_connect((bt_addr_le_t *)0x0);
    if (conn == (bt_conn *)0x0) {
      return;
    }
    uVar1 = evt->status;
    conn->err = uVar1;
    if (uVar1 == '<') {
      atomic_and(bt_dev.flags,-0x41);
    }
    else {
      if (uVar1 != '\x02') {
        printf("Unexpected status 0x%02x\r\n");
        bt_conn_unref(conn);
        return;
      }
    }
    bt_conn_set_state(conn,BT_CONN_DISCONNECTED);
    goto done;
  }
  bt_addr_le_copy((bt_addr_le_t *)(peer_addr.a.val + 3),&evt->peer_addr);
  if ((byte)(peer_addr.a.val[3] - 2) < 2) {
    peer_addr.a.val[3] = peer_addr.a.val[3] - 2;
    memcpy(&local_30 + 1,&evt->peer_rpa,6);
    local_30 = '\x01';
  }
  else {
    bt_addr_le_copy((bt_addr_le_t *)&local_30,&evt->peer_addr);
  }
  conn = find_pending_connect((bt_addr_le_t *)(peer_addr.a.val + 3));
  if ((evt->role == '\x01') && (atomic_and(bt_dev.flags,-0x41), conn == (bt_conn *)0x0)) {
    conn = bt_conn_add_le(bt_dev.adv_id,(bt_addr_le_t *)(peer_addr.a.val + 3));
  }
  if (evt->role == '\0') {
    if (conn == (bt_conn *)0x0) {
      conn = bt_conn_add_le('\0',(bt_addr_le_t *)(peer_addr.a.val + 3));
      goto LAB_2301e0de;
    }
  }
  else {
LAB_2301e0de:
    if (conn == (bt_conn *)0x0) {
      printf("Unable to add new conn for handle %u\r\n",(uint)uVar3);
      return;
    }
  }
  conn->handle = uVar3;
  bt_addr_le_copy((bt_addr_le_t *)conn->field_20,(bt_addr_le_t *)(peer_addr.a.val + 3));
  *(u16_t *)(conn->field_20 + 0x16) = evt->interval;
  *(u16_t *)(conn->field_20 + 0x1c) = evt->latency;
  *(u16_t *)(conn->field_20 + 0x1e) = evt->supv_timeout;
  uVar1 = evt->role;
  conn->err = '\0';
  conn->role = uVar1;
  if (uVar1 == '\x01') {
    bt_addr_le_copy((bt_addr_le_t *)(conn->field_20 + 7),(bt_addr_le_t *)&local_30);
    bt_addr_le_copy((bt_addr_le_t *)(conn->field_20 + 0xe),bt_dev.id_addr + conn->id);
    iVar5 = atomic_test_bit(bt_dev.flags,9);
    if ((iVar5 != 0) && ((bt_dev.le.states._4_4_ & 0x40) != 0)) {
      set_advertise_enable(true);
    }
  }
  if (conn->role == '\0') {
    iVar5 = atomic_test_bit(bt_dev.flags,0xf);
    if (iVar5 != 0) {
      conn->id = '\0';
      atomic_and(bt_dev.flags,-0x8001);
    }
    bt_addr_le_copy((bt_addr_le_t *)(conn->field_20 + 0xe),(bt_addr_le_t *)&local_30);
    bt_addr_le_copy((bt_addr_le_t *)(conn->field_20 + 7),bt_dev.id_addr + conn->id);
  }
  bt_conn_set_state(conn,BT_CONN_CONNECTED);
  if (conn->state == BT_CONN_CONNECTED) {
    if (((evt->role == '\0') || ((bt_dev.le.features[0] & 8) != 0)) &&
       (buf = bt_hci_cmd_create(0x2016,'\x02'), buf != (net_buf *)0x0)) {
      puVar6 = (undefined *)net_buf_simple_add((net_buf_simple *)&buf->field_4,2);
      uVar2 = conn->handle;
      *puVar6 = (char)uVar2;
      puVar6[1] = (char)(uVar2 >> 8);
      bt_hci_cmd_send(0x2016,buf);
    }
    else {
      if (conn->role == '\x01') {
        slave_update_conn_param(conn);
      }
    }
  }
done:
  bt_conn_unref(conn);
  bt_le_scan_update(false);
  return;
}



void le_enh_conn_complete(net_buf *buf)

{
  enh_conn_complete(*(bt_hci_evt_le_enh_conn_complete **)&buf->field_4);
  return;
}



void le_legacy_conn_complete(net_buf *buf)

{
  u8_t *puVar1;
  u8_t src;
  undefined4 local_40;
  undefined2 uStack60;
  undefined4 uStack56;
  undefined2 uStack52;
  u8_t uStack48;
  u8_t uStack47;
  u8_t uStack46;
  u8_t uStack45;
  bt_hci_evt_le_enh_conn_complete enh;
  
  puVar1 = *(u8_t **)&buf->field_4;
  uStack48 = *puVar1;
  uStack47 = puVar1[1];
  uStack46 = puVar1[2];
  uStack45 = puVar1[3];
  enh.peer_rpa.val[2] = (u8_t)*(undefined2 *)(puVar1 + 0xb);
  enh.peer_rpa.val[3] = (u8_t)((ushort)*(undefined2 *)(puVar1 + 0xb) >> 8);
  enh.peer_rpa.val[4] = (u8_t)*(undefined2 *)(puVar1 + 0xd);
  enh.peer_rpa.val[5] = (u8_t)((ushort)*(undefined2 *)(puVar1 + 0xd) >> 8);
  enh.interval._0_1_ = (undefined)*(undefined2 *)(puVar1 + 0xf);
  enh.interval._1_1_ = (undefined)((ushort)*(undefined2 *)(puVar1 + 0xf) >> 8);
  enh.latency._0_1_ = puVar1[0x11];
  bt_addr_le_copy((bt_addr_le_t *)&enh,(bt_addr_le_t *)(puVar1 + 4));
  local_40 = 0;
  uStack60 = 0;
  memcpy(enh.peer_addr.a.val + 2,&local_40,6);
  src = '\0';
  if (puVar1[3] == '\x01') {
    src = bt_dev.adv_id;
  }
  _src = (bt_hci_evt_le_enh_conn_complete *)bt_lookup_id_addr(src,(bt_addr_le_t *)&enh);
  if (_src == &enh) {
    uStack56 = 0;
    uStack52 = 0;
    memcpy(enh.local_rpa.val + 2,&uStack56,6);
  }
  else {
    memcpy(enh.local_rpa.val + 2,&enh.handle,6);
    bt_addr_le_copy((bt_addr_le_t *)&enh,(bt_addr_le_t *)_src);
    enh.status = enh.status + '\x02';
  }
  enh_conn_complete((bt_hci_evt_le_enh_conn_complete *)&uStack48);
  return;
}



void hci_tx_thread(void *p1)

{
  k_poll_event events [4];
  int num_events;
  int iVar1;
  net_buf *buf;
  uint uVar2;
  int iVar3;
  
  do {
    events[0]._12_4_ = events[0]._12_4_ & 0xffff0fff;
    num_events = bt_conn_prepare_events((k_poll_event *)0x4200d444);
    num_events = num_events + 1;
    iVar1 = k_poll((k_poll_event *)0x4200d430,num_events,-1);
    iVar3 = 0x4200d430;
    if (iVar1 != 0) {
      vAssertCalled();
    }
    while (num_events != 0) {
      uVar2 = *(uint *)(iVar3 + 0xc) >> 0xc & 0xf;
      if (uVar2 != 2) {
        if (uVar2 == 4) {
          if (*(char *)(iVar3 + 0xc) == '\0') {
            buf = net_buf_get(&bt_dev.cmd_tx_queue,0);
            if (buf == (net_buf *)0x0) {
              vAssertCalled();
            }
            k_sem_take(&bt_dev.ncmd_sem,0xffffffff);
            if (bt_dev.sent_cmd != (net_buf *)0x0) {
              printf("Uncleared pending sent_cmd\r\n");
              net_buf_unref(bt_dev.sent_cmd);
              bt_dev.sent_cmd = (net_buf *)0x0;
            }
            bt_dev.sent_cmd = net_buf_ref(buf);
            iVar1 = bt_send(buf);
            if (iVar1 != 0) {
              printf("Unable to send to driver (err %d)\r\n",iVar1);
              k_sem_give(&bt_dev.ncmd_sem);
              iVar1 = net_buf_id(buf);
              hci_cmd_done(cmd_data[iVar1].opcode,'\x1f',(net_buf *)0x0);
              net_buf_unref(bt_dev.sent_cmd);
              bt_dev.sent_cmd = (net_buf *)0x0;
              net_buf_unref(buf);
            }
          }
          else {
            if (*(char *)(iVar3 + 0xc) == '\x01') {
              bt_conn_process_tx(*(int *)(iVar3 + 0x10) + -0x34);
            }
          }
        }
        else {
          if (uVar2 != 0) {
            printf("Unexpected k_poll event state %u\r\n");
          }
        }
      }
      num_events = num_events + -1;
      iVar3 = iVar3 + 0x14;
    }
    k_yield();
  } while( true );
}



int bt_recv(net_buf *buf)

{
  byte bVar1;
  ushort uVar2;
  ushort uVar3;
  ushort uVar4;
  u8_t uVar5;
  ushort handle;
  ushort *puVar6;
  bt_conn *conn;
  byte *pbVar7;
  
  bVar1 = buf->user_data[0];
  if (bVar1 == 1) {
    if ((uint)*(ushort *)((int)&buf->field_4 + 4) <= (uint)bVar1) {
      vAssertCalled();
    }
    pbVar7 = (byte *)net_buf_simple_pull_mem((net_buf_simple *)&buf->field_4,2);
    if ((*pbVar7 < 0x1b) && ((1 << ((uint)*pbVar7 & 0x1f) & 0x408c000U) != 0)) {
      vAssertCalled();
    }
    handle_event(*pbVar7,buf,normal_events,5);
  }
  else {
    if (bVar1 != 3) {
      printf("Invalid buf type %u\r\n");
      net_buf_unref(buf);
      return -0x16;
    }
    if ((uint)*(ushort *)((int)&buf->field_4 + 4) <= (uint)bVar1) {
      vAssertCalled();
    }
    puVar6 = (ushort *)net_buf_simple_pull_mem((net_buf_simple *)&buf->field_4,4);
    uVar3 = puVar6[1];
    uVar4 = *puVar6;
    uVar2 = *(ushort *)((int)&buf->field_4 + 4);
    handle = (ushort)(((uint)uVar4 << 0x14) >> 0x14);
    *(ushort *)(buf->user_data + 2) = handle;
    buf->user_data[1] = -1;
    if (uVar3 == uVar2) {
      conn = bt_conn_lookup_handle(handle);
      if (conn != (bt_conn *)0x0) {
        uVar5 = bt_conn_index(conn);
        buf->user_data[1] = uVar5;
        bt_conn_recv(conn,buf,(byte)(uVar4 >> 0xc));
        bt_conn_unref(conn);
        return 0;
      }
      printf("Unable to find conn for handle %u\r\n",(uint)*(ushort *)(buf->user_data + 2));
    }
    else {
      printf("ACL data length mismatch (%u != %u)\r\n");
    }
  }
  net_buf_unref(buf);
  return 0;
}



undefined4 bt_recv_prio(net_buf *param_1)

{
  byte *pbVar1;
  
  if (param_1->user_data[0] != '\x01') {
    vAssertCalled();
  }
  if (*(ushort *)((int)&param_1->field_4 + 4) < 2) {
    vAssertCalled();
  }
  pbVar1 = (byte *)net_buf_simple_pull_mem((net_buf_simple *)&param_1->field_4,2);
  if (*pbVar1 < 0x1b) {
    if ((1 << ((uint)*pbVar1 & 0x1f) & 0x408c000U) != 0) goto LAB_2301e5d0;
  }
  vAssertCalled();
LAB_2301e5d0:
  handle_event(*pbVar1,param_1,prio_events,4);
  net_buf_unref(param_1);
  return 0;
}



int bt_hci_driver_register(bt_hci_driver *drv)

{
  int iVar1;
  
  if (bt_dev.drv == (bt_hci_driver *)0x0) {
    iVar1 = -0x16;
    if ((drv->open != (anon_subr_int_for_open *)0x0) &&
       (drv->send != (anon_subr_int_net_buf_ptr_for_send *)0x0)) {
      iVar1 = 0;
      bt_dev.drv = drv;
    }
  }
  else {
    iVar1 = -0x45;
  }
  return iVar1;
}



void bt_finalize_init(void)

{
  atomic_or(bt_dev.flags,2);
  bt_le_scan_update(false);
  return;
}



void bt_delete_queue(k_fifo *queue_to_del)

{
  net_buf *buf;
  
  while (buf = net_buf_get(queue_to_del,0), buf != (net_buf *)0x0) {
    net_buf_unref(buf);
  }
  k_queue_free((k_queue *)queue_to_del);
  return;
}



int bt_disable_action(void)

{
  bt_gatt_deinit();
  k_thread_delete(&tx_thread_data);
  k_thread_delete(&recv_thread_data);
  k_thread_delete(&work_q_thread);
  bt_delete_queue(&recv_fifo);
  bt_delete_queue((k_fifo *)&g_work_queue_main);
  bt_delete_queue(&bt_dev.cmd_tx_queue);
  k_queue_free((k_queue *)&free_tx);
  k_sem_delete(&bt_dev.ncmd_sem);
  k_sem_delete(&g_poll_sem);
  k_sem_delete(&sc_local_pkey_ready);
  k_sem_delete(&bt_dev.le.pkts);
  queue_inited = true;
  atomic_and(bt_dev.flags,-2);
  bl_onchiphci_interface_deinit();
  ble_controller_deinit();
  return 0;
}



int bt_disable(void)

{
  _Bool _Var1;
  undefined3 extraout_var;
  int iVar2;
  
  _Var1 = le_check_valid_conn();
  if (((CONCAT31(extraout_var,_Var1) == 0) &&
      (iVar2 = atomic_test_bit(bt_dev.flags,0xb), iVar2 == 0)) &&
     (iVar2 = atomic_test_bit(bt_dev.flags,6), iVar2 == 0)) {
    iVar2 = bt_disable_action();
    return iVar2;
  }
  return -1;
}



// WARNING: Variable defined which should be unmapped: sd
// WARNING: Could not reconcile some variable overlaps

int bt_set_name(char *name)

{
  size_t sVar1;
  int iVar2;
  u8_t local_20;
  undefined uStack31;
  bt_data data [1];
  bt_ad sd;
  
  data[0].data = &local_20;
  sVar1 = strlen(name);
  if (sVar1 < 0x1e) {
    iVar2 = strcmp(bt_dev.name,name);
    if (iVar2 != 0) {
      strncpy(bt_dev.name,name,0x1e);
      iVar2 = atomic_test_bit(bt_dev.flags,7);
      if (iVar2 != 0) {
        local_20 = '\t';
        sVar1 = strlen(name);
        uStack31 = (undefined)sVar1;
        data[0]._0_4_ = name;
        set_ad(0x2009,(bt_ad *)&data[0].data,1);
        iVar2 = atomic_test_bit(bt_dev.flags,6);
        if (iVar2 != 0) {
          set_advertise_enable(false);
          set_advertise_enable(true);
        }
      }
    }
    iVar2 = 0;
  }
  else {
    iVar2 = -0xc;
  }
  return iVar2;
}



int bt_enable(bt_ready_cb_t *cb)

{
  int iVar1;
  uint uVar2;
  
  if (bt_dev.drv == (bt_hci_driver *)0x0) {
    printf("No HCI driver registered\r\n");
    iVar1 = -0x13;
  }
  else {
    uVar2 = atomic_or(bt_dev.flags,1);
    iVar1 = -0x45;
    if ((uVar2 & 1) == 0) {
      k_work_init(&bt_dev.init,init_work);
      k_work_q_start();
      k_sem_init(&bt_dev.ncmd_sem,1,1);
      k_queue_init((k_queue *)&bt_dev.cmd_tx_queue,0x14);
      if (queue_inited == false) {
        k_queue_init((k_queue *)&hci_cmd_pool,2);
        k_queue_init((k_queue *)&hci_rx_pool,5);
      }
      k_sem_init(&g_poll_sem,0,1);
      bt_set_name("BL602-BLE-DEV");
      ready_cb = cb;
      k_thread_create(&tx_thread_data,"hci_tx_thread",0x600,hci_tx_thread,0x1d);
      iVar1 = (*(bt_dev.drv)->open)((bt_dev.drv)->open);
      if (iVar1 == 0) {
        k_work_submit(&bt_dev.init);
      }
      else {
        printf("HCI driver open failed (%d)\r\n",iVar1);
      }
    }
  }
  return iVar1;
}



char * bt_get_name(void)

{
  return bt_dev.name;
}



int bt_id_create(bt_addr_le_t *addr,u8_t *irk)

{
  bool bVar1;
  u8_t id;
  uint uVar2;
  int iVar3;
  u8_t uVar4;
  uint uVar5;
  undefined4 uStack40;
  undefined2 uStack36;
  undefined uStack34;
  
  if (addr != (bt_addr_le_t *)0x0) {
    uStack40 = 0;
    uStack36 = 0;
    uStack34 = 0;
    iVar3 = memcmp(addr,&uStack40,7);
    if (iVar3 != 0) {
      if ((addr->type != '\x01') || (((addr->a).val[5] & 0xc0) != 0xc0)) {
        printf("Only static random identity address supported\r\n");
        return -0x16;
      }
      iVar3 = id_find(addr);
      if (-1 < iVar3) {
        return -0x45;
      }
    }
  }
  id = bt_dev.id_count;
  uVar2 = 0xffffffea;
  if (irk == (u8_t *)0x0) {
    uVar5 = (uint)bt_dev.id_count;
    uVar2 = 0xfffffff4;
    if (bt_dev.id_count != '\x01') {
      uVar4 = bt_dev.id_count + '\x01';
      bVar1 = bt_dev.id_count == '\0';
      bt_dev.id_count = uVar4;
      if ((bVar1) && (iVar3 = atomic_test_bit(bt_dev.flags,1), iVar3 == 0)) {
        atomic_or(bt_dev.flags,8);
      }
      id_create(id,addr);
      uVar2 = uVar5;
    }
  }
  return uVar2;
}



int bt_setup_id_addr(void)

{
  int iVar1;
  
  iVar1 = bt_id_create((bt_addr_le_t *)0x0,(u8_t *)0x0);
  return iVar1;
}



void init_work(k_work *work)

{
  void *__s1;
  uint8_t uVar1;
  undefined3 extraout_var;
  int iVar2;
  uint initial_count;
  net_buf *buf;
  u8_t *dst;
  undefined *puVar3;
  net_buf *pnStack36;
  net_buf *rsp;
  undefined4 uStack24;
  undefined2 uStack20;
  
  uVar1 = bl_onchiphci_interface_init();
  iVar2 = CONCAT31(extraout_var,uVar1);
  if (iVar2 != 0) goto LAB_2301eb52;
  if (((bt_dev.drv)->quirks & 1) == 0) {
    iVar2 = bt_hci_cmd_send_sync(0xc03,(net_buf *)0x0,&pnStack36);
    if (iVar2 != 0) goto LAB_2301eb52;
    if (**(char **)&pnStack36->field_4 == '\0') {
      scan_dev_found_cb = (bt_le_scan_cb_t_conflict1 *)0x0;
      initial_count = atomic_get(bt_dev.flags);
      atomic_set(bt_dev.flags,initial_count & 0xd);
    }
    net_buf_unref(pnStack36);
  }
  iVar2 = bt_hci_cmd_send_sync(0x1003,(net_buf *)0x0,&pnStack36);
  if (iVar2 != 0) goto LAB_2301eb52;
  memcpy(bt_dev.features,(void *)(*(int *)&pnStack36->field_4 + 1),8);
  net_buf_unref(pnStack36);
  iVar2 = bt_hci_cmd_send_sync(0x1001,(net_buf *)0x0,&pnStack36);
  if (iVar2 != 0) goto LAB_2301eb52;
  iVar2 = *(int *)&pnStack36->field_4;
  bt_dev.hci_version = *(u8_t *)(iVar2 + 1);
  bt_dev.hci_revision = *(u16_t *)(iVar2 + 2);
  bt_dev.lmp_version = *(u8_t *)(iVar2 + 4);
  bt_dev.lmp_subversion = *(u16_t *)(iVar2 + 7);
  bt_dev.manufacturer = *(u16_t *)(iVar2 + 5);
  net_buf_unref(pnStack36);
  iVar2 = atomic_test_bit(bt_dev.flags,3);
  if (iVar2 == 0) {
    iVar2 = bt_hci_cmd_send_sync(0x1009,(net_buf *)0x0,&pnStack36);
    if (iVar2 != 0) goto LAB_2301eb52;
    rsp = (net_buf *)0x0;
    __s1 = (void *)(*(int *)&pnStack36->field_4 + 1);
    iVar2 = memcmp(__s1,&rsp,6);
    if (iVar2 != 0) {
      uStack24 = DAT_4200dcf8;
      uStack20 = DAT_4200dcfc;
      iVar2 = memcmp(__s1,&uStack24,6);
      if (iVar2 != 0) {
        memcpy(&bt_dev.id_addr[0].a,__s1,6);
        bt_dev.id_addr[0].type = '\0';
        bt_dev.id_count = '\x01';
      }
    }
    net_buf_unref(pnStack36);
  }
  iVar2 = bt_hci_cmd_send_sync(0x1002,(net_buf *)0x0,&pnStack36);
  if (iVar2 != 0) goto LAB_2301eb52;
  memcpy(bt_dev.supported_commands,(void *)(*(int *)&pnStack36->field_4 + 1),0x40);
  net_buf_unref(pnStack36);
  if ((bt_dev.features[0][4] & 0x40) == 0) {
    printf("Non-LE capable controller detected!\r\n");
    iVar2 = -0x13;
    goto LAB_2301eb52;
  }
  iVar2 = bt_hci_cmd_send_sync(0x2003,(net_buf *)0x0,&pnStack36);
  if (iVar2 != 0) goto LAB_2301eb52;
  memcpy(&bt_dev.le,(void *)(*(int *)&pnStack36->field_4 + 1),8);
  net_buf_unref(pnStack36);
  iVar2 = bt_hci_cmd_send_sync(0x2002,(net_buf *)0x0,&pnStack36);
  if (iVar2 != 0) goto LAB_2301eb52;
  bt_dev.le.mtu = *(u16_t *)(*(int *)&pnStack36->field_4 + 1);
  if (bt_dev.le.mtu != 0) {
    initial_count = (uint)*(byte *)(*(int *)&pnStack36->field_4 + 3);
    k_sem_init(&bt_dev.le.pkts,initial_count,initial_count);
  }
  net_buf_unref(pnStack36);
  if ((bt_dev.features[0][4] & 0x20) == 0) {
    buf = bt_hci_cmd_create(0xc6d,'\x02');
    if (buf != (net_buf *)0x0) {
      puVar3 = (undefined *)net_buf_simple_add((net_buf_simple *)&buf->field_4,2);
      *puVar3 = 1;
      puVar3[1] = 0;
      iVar2 = bt_hci_cmd_send_sync(0xc6d,buf,(net_buf **)0x0);
      if (iVar2 != 0) goto LAB_2301eb52;
      goto LAB_2301ebda;
    }
  }
  else {
LAB_2301ebda:
    if ((bt_dev.supported_commands[28] & 8) != 0) {
      iVar2 = bt_hci_cmd_send_sync(0x201c,(net_buf *)0x0,&pnStack36);
      if (iVar2 != 0) goto LAB_2301eb52;
      bt_dev.le.states._0_4_ = *(undefined4 *)(*(int *)&pnStack36->field_4 + 1);
      bt_dev.le.states._4_4_ = *(undefined4 *)(*(int *)&pnStack36->field_4 + 5);
      net_buf_unref(pnStack36);
    }
    if ((bt_dev.le.features[0] & 0x40) != 0) {
      iVar2 = bt_hci_cmd_send_sync(0x202a,(net_buf *)0x0,&pnStack36);
      if (iVar2 != 0) goto LAB_2301eb52;
      bt_dev.le.rl_size = *(u8_t *)(*(int *)&pnStack36->field_4 + 1);
      net_buf_unref(pnStack36);
    }
    iVar2 = bt_hci_cmd_send_sync(0x200f,(net_buf *)0x0,&pnStack36);
    if (iVar2 != 0) goto LAB_2301eb52;
    bt_dev.le.wl_size = *(u8_t *)(*(int *)&pnStack36->field_4 + 1);
    net_buf_unref(pnStack36);
    buf = bt_hci_cmd_create(0x2001,'\b');
    if (buf != (net_buf *)0x0) {
      net_buf_simple_add((net_buf_simple *)&buf->field_4,8);
      initial_count = 0x202;
      if ((bt_dev.le.features[0] & 0x40) == 0) {
        initial_count = 3;
      }
      dst = (u8_t *)(initial_count | 0x2c);
      if ((bt_dev.le.features[0] & 2) == 0) {
        dst = (u8_t *)(initial_count | 0xc);
      }
      if ((bt_dev.le.features[0] & 1) != 0) {
        dst = (u8_t *)((uint)dst | 0x10);
      }
      if ((bt_dev.supported_commands[34] & 6) == 6) {
        dst = (u8_t *)((uint)dst | 0x180);
      }
      sys_put_le64(dst);
      iVar2 = bt_hci_cmd_send_sync(0x2001,buf,(net_buf **)0x0);
      if (iVar2 == 0) {
        if (((bt_dev.features[0][4] & 0x20) == 0) && (bt_dev.le.mtu == 0)) {
          iVar2 = bt_hci_cmd_send_sync(0x1005,(net_buf *)0x0,&pnStack36);
          if (iVar2 != 0) goto LAB_2301eb52;
          if (bt_dev.le.mtu == 0) {
            bt_dev.le.mtu = *(u16_t *)(*(int *)&pnStack36->field_4 + 1);
            initial_count = (uint)*(ushort *)(*(int *)&pnStack36->field_4 + 4);
            k_sem_init(&bt_dev.le.pkts,initial_count,initial_count);
          }
          net_buf_unref(pnStack36);
        }
        buf = bt_hci_cmd_create(0xc01,'\b');
        iVar2 = -0x37;
        if (buf != (net_buf *)0x0) {
          net_buf_simple_add((net_buf_simple *)&buf->field_4,8);
          if ((bt_dev.le.features[0] & 1) == 0) {
            dst = (u8_t *)0x2008810;
          }
          else {
            dst = (u8_t *)0x2008890;
          }
          sys_put_le64(dst);
          iVar2 = bt_hci_cmd_send_sync(0xc01,buf,(net_buf **)0x0);
          if (iVar2 == 0) {
            if ((bt_dev.id_count == '\0') && (iVar2 = bt_setup_id_addr(), iVar2 != 0)) {
              printf("Unable to set identity address\r\n");
            }
            else {
              iVar2 = bt_conn_init();
              if (iVar2 == 0) {
                bt_finalize_init();
              }
            }
          }
        }
      }
      goto LAB_2301eb52;
    }
  }
  iVar2 = -0x37;
LAB_2301eb52:
  if (ready_cb != (bt_ready_cb_t *)0x0) {
    (*ready_cb)(iVar2);
  }
  return;
}



_Bool bt_addr_le_is_bonded(u8_t id,bt_addr_le_t *addr)

{
  bool bVar1;
  bt_keys *pbVar2;
  
  pbVar2 = bt_keys_find_addr(id,addr);
  if (pbVar2 == (bt_keys *)0x0) {
    bVar1 = false;
  }
  else {
    bVar1 = pbVar2->keys != 0;
  }
  return (_Bool)bVar1;
}



int bt_le_adv_start_internal
              (byte *param_1,bt_data *param_2,size_t param_3,bt_data *param_4,size_t param_5,
              bt_addr_le_t *param_6)

{
  byte bVar1;
  int iVar2;
  net_buf *buf;
  uint uVar3;
  undefined4 uStack72;
  undefined2 uStack68;
  undefined uStack66;
  undefined2 uStack64;
  undefined2 uStack62;
  byte bStack60;
  byte bStack59;
  bt_addr_le_t bStack58;
  u8_t uStack51;
  undefined uStack50;
  
  iVar2 = atomic_test_bit(bt_dev.flags,1);
  if (iVar2 == 0) {
    return 0xfffffff5;
  }
  if ((uint)*param_1 < (uint)bt_dev.id_count) {
    uStack72 = 0;
    uStack68 = 0;
    uStack66 = 0;
    iVar2 = memcmp(bt_dev.id_addr + (uint)*param_1,&uStack72,7);
    if (((iVar2 != 0) &&
        (((bVar1 = param_1[1], (bVar1 & 1) != 0 || (8 < bt_dev.hci_version)) ||
         (0x9f < *(ushort *)(param_1 + 2))))) &&
       ((bt_dev.le.wl_entries != '\0' || (((bVar1 & 0x40) == 0 && (-1 < (char)bVar1)))))) {
      if (((bVar1 & 0x10) != 0) || (param_6 == (bt_addr_le_t *)0x0)) {
        if (*(ushort *)(param_1 + 4) < *(ushort *)(param_1 + 2)) {
          return 0xffffffea;
        }
        if (*(ushort *)(param_1 + 2) < 0x20) {
          return 0xffffffea;
        }
        if (0x4000 < *(ushort *)(param_1 + 4)) {
          return 0xffffffea;
        }
      }
      iVar2 = atomic_test_bit(bt_dev.flags,6);
      if (iVar2 != 0) {
        return 0xffffffbb;
      }
      memset(&uStack64,0,0xf);
      uStack64 = *(undefined2 *)(param_1 + 2);
      uStack62 = *(undefined2 *)(param_1 + 4);
      uStack51 = adv_ch_map;
      if (bt_dev.adv_id != *param_1) {
        atomic_and(bt_dev.flags,-0x10001);
      }
      bVar1 = param_1[1];
      if ((bVar1 & 0x40) == 0) {
        uStack50 = 2;
        if (-1 < (char)bVar1) {
          uStack50 = 0;
        }
      }
      else {
        uStack50 = 3;
        if (-1 < (char)bVar1) {
          uStack50 = 1;
        }
      }
      bt_dev.adv_id = *param_1;
      uVar3 = (uint)bt_dev.adv_id;
      bVar1 = param_1[1];
      bStack60 = bVar1 & 1;
      if ((bVar1 & 1) == 0) {
        if ((bVar1 & 4) == 0) {
          iVar2 = le_set_private_addr();
          bStack59 = 1;
        }
        else {
          if (bt_dev.id_addr[uVar3].type == '\x01') {
            iVar2 = set_random_address(&bt_dev.id_addr[uVar3].a);
          }
          bStack59 = bt_dev.id_addr[uVar3].type;
        }
        if (iVar2 != 0) {
          return iVar2;
        }
        bStack60 = 2;
        if (param_4 == (bt_data *)0x0) {
          bStack60 = 3;
        }
      }
      else {
        if ((bt_dev.id_addr[uVar3].type == '\x01') &&
           (iVar2 = set_random_address(&bt_dev.id_addr[uVar3].a), iVar2 != 0)) {
          return iVar2;
        }
        bStack59 = bt_dev.id_addr[uVar3].type;
        if (param_6 == (bt_addr_le_t *)0x0) {
          bStack60 = 0;
        }
        else {
          if ((param_1[1] & 0x10) != 0) {
            bStack60 = 4;
          }
          bt_addr_le_copy(&bStack58,param_6);
          if (((bt_dev.le.features[0] & 0x40) != 0) && ((param_1[1] & 0x20) != 0)) {
            bStack59 = bStack59 | 2;
          }
        }
      }
      buf = bt_hci_cmd_create(0x2006,'\x0f');
      if (buf == (net_buf *)0x0) {
        return 0xffffffc9;
      }
      net_buf_simple_add_mem((net_buf_simple *)&buf->field_4,&uStack64,0xf);
      iVar2 = bt_hci_cmd_send_sync(0x2006,buf,(net_buf **)0x0);
      if (iVar2 == 0) {
        if ((param_6 == (bt_addr_le_t *)0x0) &&
           (iVar2 = le_adv_update(param_2,param_3,param_4,param_5,(_Bool)(param_1[1] & 1),
                                  (_Bool)(param_1[1] >> 3 & 1)), iVar2 != 0)) {
          return iVar2;
        }
        iVar2 = set_advertise_enable(true);
        if (iVar2 == 0) {
          atomic_set_bit_to(bt_dev.flags,9,(_Bool)((param_1[1] >> 1 ^ 1) & 1));
          atomic_set_bit_to(bt_dev.flags,7,(_Bool)(param_1[1] >> 3 & 1));
          atomic_set_bit_to(bt_dev.flags,8,(_Bool)(param_1[1] & 1));
          return 0;
        }
        return iVar2;
      }
      return iVar2;
    }
  }
  return 0xffffffea;
}



int set_adv_channel_map(u8_t channel)

{
  if ((byte)(channel - 1) < 7) {
    adv_ch_map = channel;
    return 0;
  }
  return -1;
}



int bt_get_local_public_address(bt_addr_le_t *adv_addr)

{
  bt_addr_le_copy(adv_addr,(bt_addr_le_t *)&bt_dev);
  return 0;
}



int bt_get_local_ramdon_address(bt_addr_le_t *adv_addr)

{
  bt_addr_le_copy(adv_addr,&bt_dev.random_addr);
  return 0;
}



int bt_le_adv_start(bt_le_adv_param *param,bt_data *ad,size_t ad_len,bt_data *sd,size_t sd_len)

{
  int iVar1;
  
  if ((param->options & 0x10) == 0) {
    iVar1 = bt_le_adv_start_internal();
    return iVar1;
  }
  return -0x16;
}



int bt_le_adv_stop(void)

{
  int iVar1;
  
  atomic_and(bt_dev.flags,-0x201);
  iVar1 = atomic_test_bit(bt_dev.flags,6);
  if (iVar1 != 0) {
    iVar1 = set_advertise_enable(false);
    if (iVar1 != 0) {
      return iVar1;
    }
    iVar1 = atomic_test_bit(bt_dev.flags,10);
    if ((iVar1 != 0) && (iVar1 = atomic_test_bit(bt_dev.flags,0xc), iVar1 != 0)) {
      le_set_private_addr();
      return 0;
    }
  }
  return 0;
}



int bt_le_scan_start(byte *param_1,bt_le_scan_cb_t_conflict1 *param_2)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  
  iVar2 = atomic_test_bit(bt_dev.flags,1);
  iVar1 = -0xb;
  if ((((iVar2 != 0) && (iVar1 = -0x16, *param_1 < 2)) && ((param_1[1] & 0xfc) == 0)) &&
     ((bt_dev.le.wl_entries != '\0' || ((param_1[1] & 2) == 0)))) {
    iVar1 = -0x16;
    if (((ushort)(*(ushort *)(param_1 + 2) - 4) < 0x3ffd) &&
       (((ushort)(*(ushort *)(param_1 + 4) - 4) < 0x3ffd &&
        (*(ushort *)(param_1 + 4) <= *(ushort *)(param_1 + 2))))) {
      uVar3 = atomic_or(bt_dev.flags,0x800);
      iVar1 = -0x45;
      if ((uVar3 & 0x800) == 0) {
        iVar1 = atomic_test_bit(bt_dev.flags,10);
        if ((iVar1 == 0) || (iVar1 = set_le_scan_enable('\0'), iVar1 == 0)) {
          atomic_set_bit_to(bt_dev.flags,0xd,(_Bool)(param_1[1] & 1));
          atomic_set_bit_to(bt_dev.flags,0xe,(_Bool)(param_1[1] >> 1 & 1));
          iVar1 = start_le_scan(*param_1,*(u16_t *)(param_1 + 2),*(u16_t *)(param_1 + 4));
          if (iVar1 == 0) {
            scan_dev_found_cb = param_2;
            return 0;
          }
        }
        atomic_and(bt_dev.flags,-0x801);
      }
    }
  }
  return iVar1;
}



int bt_le_scan_stop(void)

{
  atomic_val_t aVar1;
  int iVar2;
  
  aVar1 = atomic_and(bt_dev.flags,-0x801);
  if (aVar1 << 0x14 < 0) {
    scan_dev_found_cb = (bt_le_scan_cb_t_conflict1 *)0x0;
    iVar2 = bt_le_scan_update(false);
    return iVar2;
  }
  return -0x45;
}



int bt_set_tx_pwr(int8_t power)

{
  net_buf *buf;
  int iVar1;
  int8_t aiStack20 [4];
  bt_hci_cp_vs_set_tx_pwr set_param;
  
  if ((byte)power < 0x15) {
    memset(aiStack20,0,1);
    aiStack20[0] = power;
    buf = bt_hci_cmd_create(0xfc61,'\x01');
    iVar1 = -0x37;
    if (buf != (net_buf *)0x0) {
      net_buf_simple_add_mem((net_buf_simple *)&buf->field_4,aiStack20,1);
      iVar1 = bt_hci_cmd_send_sync(0xfc61,buf,(net_buf **)0x0);
    }
    return iVar1;
  }
  return 0x12;
}



int bt_buf_get_rx_avail_cnt(void)

{
  int iVar1;
  
  iVar1 = k_queue_get_cnt((k_queue *)&hci_rx_pool);
  return iVar1 + (uint)hci_rx_pool.uninit_count;
}



net_buf * bt_buf_get_rx(bt_buf_type type,s32_t timeout)

{
  net_buf *pnVar1;
  
  pnVar1 = net_buf_alloc_fixed(&hci_rx_pool,timeout);
  if (pnVar1 != (net_buf *)0x0) {
    net_buf_simple_reserve((net_buf_simple *)&pnVar1->field_4,1);
    pnVar1->user_data[0] = type;
  }
  return pnVar1;
}



net_buf * bt_buf_get_cmd_complete(s32_t timeout)

{
  net_buf *pnVar1;
  
  irq_lock();
  pnVar1 = bt_dev.sent_cmd;
  bt_dev.sent_cmd = (net_buf *)0x0;
  irq_unlock();
  if (pnVar1 == (net_buf *)0x0) {
    pnVar1 = bt_buf_get_rx(BT_BUF_EVT,timeout);
    return pnVar1;
  }
  pnVar1->user_data[0] = '\x01';
  *(undefined2 *)((int)&pnVar1->field_4 + 4) = 0;
  net_buf_simple_reserve((net_buf_simple *)&pnVar1->field_4,1);
  return pnVar1;
}



int bt_pub_key_gen(bt_pub_key_cb *new_cb)

{
  bt_pub_key_cb *pbVar1;
  uint uVar2;
  bt_pub_key_cb *pbVar3;
  int iVar4;
  
  if ((bt_dev.supported_commands[34] & 6) == 6) {
    pbVar1 = new_cb;
    if (pub_key_cb != (bt_pub_key_cb *)0x0) {
      pbVar1 = pub_key_cb;
      do {
        pbVar3 = pbVar1;
        pbVar1 = pub_key_cb;
        if (new_cb->func == pbVar3->func) goto LAB_2301f440;
        pbVar1 = pbVar3->_next;
      } while (pbVar3->_next != (bt_pub_key_cb *)0x0);
      pbVar3->_next = new_cb;
      pbVar1 = pub_key_cb;
    }
LAB_2301f440:
    pub_key_cb = pbVar1;
    uVar2 = atomic_or(bt_dev.flags,0x20);
    iVar4 = 0;
    if ((uVar2 & 0x20) == 0) {
      atomic_and(bt_dev.flags,-0x11);
      iVar4 = bt_hci_cmd_send_sync(0x2025,(net_buf *)0x0,(net_buf **)0x0);
      if (iVar4 != 0) {
        printf("Sending LE P256 Public Key command failed\r\n");
        atomic_and(bt_dev.flags,-0x21);
        pub_key_cb = (bt_pub_key_cb *)0x0;
      }
    }
  }
  else {
    printf("ECC HCI commands not available\r\n");
    iVar4 = -0x23;
  }
  return iVar4;
}



u8_t * bt_pub_key_get(void)

{
  int iVar1;
  u8_t *puVar2;
  
  iVar1 = atomic_test_bit(bt_dev.flags,4);
  puVar2 = (u8_t *)0x0;
  if (iVar1 != 0) {
    puVar2 = pub_key;
  }
  return puVar2;
}



int bt_dh_key_gen(u8_t *remote_pk,bt_dh_key_cb_t *cb)

{
  int iVar1;
  net_buf *buf;
  void *__dest;
  int iVar2;
  
  if ((dh_key_cb == (bt_dh_key_cb_t *)0x0) && (iVar2 = atomic_test_bit(bt_dev.flags,5), iVar2 == 0))
  {
    iVar1 = atomic_test_bit(bt_dev.flags,4);
    iVar2 = -0x31;
    if (iVar1 != 0) {
      dh_key_cb = cb;
      buf = bt_hci_cmd_create(0x2026,'@');
      if (buf == (net_buf *)0x0) {
        dh_key_cb = (bt_dh_key_cb_t *)0x0;
        iVar2 = -0x37;
      }
      else {
        __dest = net_buf_simple_add((net_buf_simple *)&buf->field_4,0x40);
        memcpy(__dest,remote_pk,0x40);
        iVar2 = bt_hci_cmd_send_sync(0x2026,buf,(net_buf **)0x0);
        if (iVar2 != 0) {
          dh_key_cb = (bt_dh_key_cb_t *)0x0;
        }
      }
    }
  }
  else {
    iVar2 = -0x10;
  }
  return iVar2;
}



void sys_slist_remove(sys_slist_t *list,sys_snode_t *prev_node,sys_snode_t *node)

{
  sys_snode_t *psVar1;
  
  psVar1 = (sys_snode_t *)node->next;
  if (prev_node == (sys_snode_t *)0x0) {
    list->head = psVar1;
    if (list->tail == node) {
      list->tail = psVar1;
    }
  }
  else {
    *(sys_snode_t **)&prev_node->next = psVar1;
    if (list->tail == node) {
      list->tail = prev_node;
    }
  }
  node->next = (_snode *)0x0;
  return;
}



size_t net_buf_frags_len(net_buf *buf)

{
  anon_union_for_field_4 *paVar1;
  size_t sVar2;
  
  sVar2 = 0;
  while (buf != (net_buf *)0x0) {
    paVar1 = &buf->field_4;
    buf = (net_buf *)buf->field_0;
    sVar2 = sVar2 + *(ushort *)((int)paVar1 + 4);
  }
  return sVar2;
}



u8_t get_ident(void)

{
  u8_t ident;
  u8_t uVar1;
  
  uVar1 = ident + '\x01';
  if (uVar1 == '\0') {
    uVar1 = '\x01';
  }
  return uVar1;
}



// WARNING: Type propagation algorithm not settling

bt_l2cap_le_chan * __l2cap_lookup_ident(bt_conn *conn,u16_t ident,_Bool remove)

{
  sys_snode_t node;
  undefined2 in_register_0000202e;
  undefined3 in_register_00002031;
  sys_snode_t sVar1;
  sys_snode_t prev_node;
  
  node = (sys_snode_t)(conn->channels).head;
  if (node != (sys_snode_t)0x0) {
    prev_node = (sys_snode_t)0x0;
    do {
      sVar1 = (sys_snode_t)((int)node + -8);
      if (sVar1 == (sys_snode_t)0x0) {
        return (bt_l2cap_le_chan *)0;
      }
      if ((uint)*(byte *)&((sys_snode_t *)((int)node + 0x34))->next ==
          CONCAT22(in_register_0000202e,ident)) {
        if (CONCAT31(in_register_00002031,remove) == 0) {
          return (bt_l2cap_le_chan *)sVar1;
        }
        sys_slist_remove(&conn->channels,(sys_snode_t *)prev_node,(sys_snode_t *)node);
        return (bt_l2cap_le_chan *)sVar1;
      }
      sVar1 = *(sys_snode_t *)node;
      prev_node = node;
      node = sVar1;
    } while (sVar1 != (sys_snode_t)0x0);
    node = (sys_snode_t)0x0;
  }
  return (bt_l2cap_le_chan *)node;
}



bt_l2cap_server * l2cap_server_lookup_psm(u16_t psm)

{
  undefined2 in_register_0000202a;
  sys_snode_t sVar1;
  sys_snode_t sVar2;
  
  sVar2 = (sys_snode_t)servers.head;
  while (((sVar1 = sVar2, sVar2 != (sys_snode_t)0x0 &&
          (sVar1 = (sys_snode_t)((int)sVar2 + -8), sVar1 != (sys_snode_t)0x0)) &&
         ((uint)*(ushort *)sVar1 != CONCAT22(in_register_0000202a,psm)))) {
    sVar2 = *(sys_snode_t *)sVar2;
  }
  return (bt_l2cap_server *)sVar1;
}



// WARNING: Type propagation algorithm not settling

bt_l2cap_le_chan * l2cap_remove_rx_cid(bt_conn *conn,u16_t cid)

{
  sys_snode_t sVar1;
  sys_snode_t node;
  undefined2 in_register_0000202e;
  sys_snode_t prev_node;
  
  sVar1 = (sys_snode_t)0x0;
  if (((CONCAT22(in_register_0000202e,cid) - 0x40 & 0xffff) < 0x40) &&
     (sVar1 = (sys_snode_t)(conn->channels).head, sVar1 != (sys_snode_t)0x0)) {
    prev_node = (sys_snode_t)0x0;
    node = sVar1;
    do {
      if ((sys_snode_t)((int)node + -8) == (sys_snode_t)0x0) {
        return (bt_l2cap_le_chan *)0;
      }
      if ((uint)*(ushort *)&((sys_snode_t *)((int)node + 0x38))->next ==
          CONCAT22(in_register_0000202e,cid)) {
        sys_slist_remove(&conn->channels,(sys_snode_t *)prev_node,(sys_snode_t *)node);
        return (bt_l2cap_le_chan *)((int)node + -8);
      }
      sVar1 = *(sys_snode_t *)node;
      prev_node = node;
      node = sVar1;
    } while (sVar1 != (sys_snode_t)0x0);
  }
  return (bt_l2cap_le_chan *)sVar1;
}



void l2cap_chan_sdu_sent(bt_conn *conn,void *user_data)

{
  code *UNRECOVERED_JUMPTABLE;
  
  UNRECOVERED_JUMPTABLE = *(code **)(*(int *)((int)user_data + 4) + 0x14);
  if (UNRECOVERED_JUMPTABLE != (code *)0x0) {
                    // WARNING: Could not recover jumptable at 0x2301f658. Too many branches
                    // WARNING: Treating indirect jump as call
    (*UNRECOVERED_JUMPTABLE)(user_data);
    return;
  }
  return;
}



net_buf * l2cap_alloc_frag(s32_t timeout,void *user_data)

{
  net_buf *pnVar1;
  
                    // WARNING: Could not recover jumptable at 0x2301f664. Too many branches
                    // WARNING: Treating indirect jump as call
  pnVar1 = (net_buf *)(**(code **)(*(int *)((int)user_data + 4) + 0xc))(user_data);
  return pnVar1;
}



void l2cap_connected(bt_l2cap_chan *chan)

{
  return;
}



void l2cap_chan_destroy(bt_l2cap_chan *chan)

{
  net_buf *buf;
  
  k_delayed_work_cancel(&chan->rtx_work);
  if ((net_buf *)chan[1].status[0] != (net_buf *)0x0) {
    net_buf_unref((net_buf *)chan[1].status[0]);
    chan[1].status[0] = 0;
  }
  while (buf = net_buf_get((k_fifo *)&chan[1].rtx_work.timer.args,0), buf != (net_buf *)0x0) {
    net_buf_unref(buf);
  }
  while (buf = net_buf_get((k_fifo *)&chan[2].destroy,0), buf != (net_buf *)0x0) {
    net_buf_unref(buf);
  }
  if (*(net_buf **)&chan[1].state != (net_buf *)0x0) {
    net_buf_unref(*(net_buf **)&chan[1].state);
    *(undefined4 *)&chan[1].state = 0;
    *(undefined2 *)&chan[1].ident = 0;
  }
  return;
}



void l2cap_chan_tx_init(bt_l2cap_le_chan *chan)

{
  memset(&chan->tx,0,0x14);
  k_sem_init(&(chan->tx).credits,0,0xffffffff);
  k_queue_init((k_queue *)&chan->tx_queue,0x14);
  return;
}



void l2cap_chan_rx_init(bt_l2cap_le_chan *chan)

{
  u16_t uVar1;
  ushort uVar2;
  
  if ((chan->rx).mtu == 0) {
    (chan->rx).mtu = 0xf5;
  }
  uVar2 = (chan->rx).mtu;
  if ((chan->rx).init_credits == 0) {
    if (((chan->chan).ops)->alloc_buf ==
        (anon_subr_net_buf_ptr_bt_l2cap_chan_ptr_for_alloc_buf *)0x0) {
      uVar1 = 4;
    }
    else {
      uVar1 = (u16_t)((int)((uint)uVar2 + 0xf6) / 0xf7);
    }
    (chan->rx).init_credits = uVar1;
  }
  if (0xf5 < uVar2) {
    uVar2 = 0xf5;
  }
  (chan->rx).mps = uVar2 + 2;
  k_sem_init(&(chan->rx).credits,0,0xffffffff);
  return;
}



int l2cap_accept(bt_conn *conn,bt_l2cap_chan **chan)

{
  int iVar1;
  
  if (bt_l2cap_pool[0].chan.chan.conn == (bt_conn *)0x0) {
    iVar1 = 0;
  }
  else {
    if (bt_l2cap_pool[1].chan.chan.conn != (bt_conn *)0x0) {
      printf("No available L2CAP context for conn %p\r\n",conn);
      return -0xc;
    }
    iVar1 = 1;
  }
  bt_l2cap_pool[iVar1].chan.chan.ops = (bt_l2cap_chan_ops *)0x4200d480;
  *(bt_l2cap **)chan = bt_l2cap_pool + iVar1;
  return 0;
}



net_buf * l2cap_create_le_sig_pdu(u8_t code,u8_t ident,u16_t len)

{
  undefined3 in_register_00002029;
  net_buf *pnVar1;
  u8_t *puVar2;
  
  pnVar1 = bt_conn_create_pdu_timeout((net_buf_pool *)0x0,4,2000);
  if (pnVar1 == (net_buf *)0x0) {
    printf("Unable to allocate buffer for op 0x%02x\r\n",CONCAT31(in_register_00002029,code));
  }
  else {
    puVar2 = (u8_t *)net_buf_simple_add((net_buf_simple *)&pnVar1->field_4,4);
    puVar2[2] = (u8_t)len;
    *puVar2 = code;
    puVar2[1] = ident;
    puVar2[3] = (u8_t)(len >> 8);
  }
  return pnVar1;
}



void l2cap_chan_tx_give_credits(bt_l2cap_le_chan *chan,u16_t credits)

{
  anon_subr_void_bt_l2cap_chan_ptr_atomic_t_ptr_for_status *UNRECOVERED_JUMPTABLE;
  atomic_t *target;
  uint uVar1;
  
  while (credits = credits - 1, credits != 0xffff) {
    k_sem_give(&(chan->tx).credits);
  }
  target = (chan->chan).status;
  uVar1 = atomic_or(target,1);
  if ((uVar1 & 1) != 0) {
    UNRECOVERED_JUMPTABLE = ((chan->chan).ops)->status;
    if (UNRECOVERED_JUMPTABLE != (anon_subr_void_bt_l2cap_chan_ptr_atomic_t_ptr_for_status *)0x0) {
                    // WARNING: Could not recover jumptable at 0x2301f83a. Too many branches
                    // WARNING: Treating indirect jump as call
      (*UNRECOVERED_JUMPTABLE)((bt_l2cap_chan *)chan,target);
      return;
    }
  }
  return;
}



void l2cap_disconnected(void)

{
  return;
}



// WARNING: Type propagation algorithm not settling

void bt_l2cap_chan_remove(bt_conn *conn,bt_l2cap_chan *ch)

{
  sys_snode_t prev_node;
  sys_snode_t node;
  sys_snode_t sVar1;
  
  node = (sys_snode_t)(conn->channels).head;
  if (node != (sys_snode_t)0x0) {
    prev_node = (sys_snode_t)0x0;
    do {
      if (node == (sys_snode_t)&DAT_00000008) {
        return;
      }
      if ((bt_l2cap_chan *)((int)node + -8) == ch) {
        sys_slist_remove(&conn->channels,(sys_snode_t *)prev_node,(sys_snode_t *)node);
        return;
      }
      sVar1 = *(sys_snode_t *)node;
      prev_node = node;
      node = sVar1;
    } while (sVar1 != (sys_snode_t)0x0);
  }
  return;
}



void bt_l2cap_chan_del(bt_l2cap_chan *chan)

{
  anon_subr_void_bt_l2cap_chan_ptr_for_disconnected *paVar1;
  
  if (chan->conn != (bt_conn *)0x0) {
    paVar1 = chan->ops->disconnected;
    if (paVar1 != (anon_subr_void_bt_l2cap_chan_ptr_for_disconnected *)0x0) {
      (*paVar1)(chan);
    }
    chan->conn = (bt_conn *)0x0;
  }
  chan->state = BT_L2CAP_DISCONNECTED;
  chan->psm = 0;
  if (chan->destroy != (bt_l2cap_chan_destroy_t *)0x0) {
    (*chan->destroy)(chan);
  }
  if ((chan->rtx_work).timer.timer.hdl != (void *)0x0) {
    k_delayed_work_del_timer(&chan->rtx_work);
    return;
  }
  return;
}



void l2cap_rtx_timeout(k_work *work)

{
  bt_l2cap_chan *ch;
  
  ch = (bt_l2cap_chan *)work[-2].flags;
  printf("chan %p timeout\r\n",ch);
  bt_l2cap_chan_remove((bt_conn *)work[-2].flags[0],ch);
  bt_l2cap_chan_del(ch);
  return;
}



void bt_l2cap_disconnected(bt_conn *conn)

{
  bt_l2cap_chan *pbVar1;
  bt_l2cap_chan *pbVar2;
  bt_l2cap_chan *chan;
  sys_snode_t *psVar3;
  
  psVar3 = (conn->channels).head;
  if ((psVar3 != (sys_snode_t *)0x0) &&
     (chan = (bt_l2cap_chan *)(psVar3 + -2), chan != (bt_l2cap_chan *)0x0)) {
    pbVar1 = (bt_l2cap_chan *)psVar3->next;
    if (pbVar1 != (bt_l2cap_chan *)0x0) {
      pbVar1 = (bt_l2cap_chan *)&pbVar1[-1].state;
    }
    while (pbVar2 = pbVar1, bt_l2cap_chan_del(chan), pbVar2 != (bt_l2cap_chan *)0x0) {
      pbVar1 = (bt_l2cap_chan *)(pbVar2->node).next;
      chan = pbVar2;
      if (pbVar1 != (bt_l2cap_chan *)0x0) {
        pbVar1 = (bt_l2cap_chan *)&pbVar1[-1].state;
      }
    }
    return;
  }
  return;
}



net_buf * bt_l2cap_create_pdu_timeout(net_buf_pool *pool,size_t reserve,s32_t timeout)

{
  net_buf *pnVar1;
  
  pnVar1 = bt_conn_create_pdu_timeout(pool,reserve + 4,timeout);
  return pnVar1;
}



int bt_l2cap_send_cb(bt_conn *conn,u16_t cid,net_buf *buf,bt_conn_tx_cb_t *cb,void *user_data)

{
  ushort uVar1;
  undefined *puVar2;
  int iVar3;
  
  puVar2 = (undefined *)net_buf_simple_push((net_buf_simple *)&buf->field_4,4);
  uVar1 = *(ushort *)((int)&buf->field_4 + 4);
  puVar2[2] = (char)cid;
  iVar3 = (uint)uVar1 - 4;
  *puVar2 = (char)((uint)(iVar3 * 0x10000) >> 0x10);
  puVar2[1] = (char)((uint)iVar3 >> 8);
  puVar2[3] = (char)(cid >> 8);
  iVar3 = bt_conn_send_cb(conn,buf,cb,user_data);
  return iVar3;
}



void bt_l2cap_send(bt_conn *conn,u16_t cid,net_buf *buf)

{
  bt_l2cap_send_cb(conn,cid,buf,(bt_conn_tx_cb_t *)0x0,(void *)0x0);
  return;
}



void l2cap_chan_send_credits(bt_l2cap_le_chan *chan,u16_t credits)

{
  u16_t uVar1;
  uint uVar2;
  uint uVar3;
  u8_t ident;
  net_buf *buf;
  undefined *puVar4;
  undefined2 in_register_0000202e;
  
  uVar2 = (uint)(chan->rx).init_credits;
  if (CONCAT22(in_register_0000202e,credits) < uVar2) {
    uVar2 = CONCAT22(in_register_0000202e,credits);
  }
  uVar3 = uVar2 & 0xffff;
  while (uVar3 = uVar3 - 1 & 0xffff, uVar3 != 0xffff) {
    k_sem_give(&(chan->rx).credits);
  }
  ident = get_ident();
  buf = l2cap_create_le_sig_pdu('\x16',ident,4);
  if (buf != (net_buf *)0x0) {
    puVar4 = (undefined *)net_buf_simple_add((net_buf_simple *)&buf->field_4,4);
    uVar1 = (chan->rx).cid;
    puVar4[2] = (char)uVar2;
    *puVar4 = (char)uVar1;
    puVar4[1] = (char)(uVar1 >> 8);
    puVar4[3] = (char)((uVar2 & 0xffff) >> 8);
    bt_l2cap_send((chan->chan).conn,5,buf);
    return;
  }
  return;
}



int l2cap_le_conn_req(bt_l2cap_le_chan *ch)

{
  u16_t uVar1;
  u8_t ident;
  net_buf *buf;
  undefined *puVar2;
  int iVar3;
  
  ident = get_ident();
  (ch->chan).ident = ident;
  buf = l2cap_create_le_sig_pdu('\x14',ident,10);
  if (buf == (net_buf *)0x0) {
    iVar3 = -0xc;
  }
  else {
    puVar2 = (undefined *)net_buf_simple_add((net_buf_simple *)&buf->field_4,10);
    uVar1 = (ch->chan).psm;
    *puVar2 = (char)uVar1;
    puVar2[1] = (char)(uVar1 >> 8);
    uVar1 = (ch->rx).cid;
    puVar2[2] = (char)uVar1;
    puVar2[3] = (char)(uVar1 >> 8);
    uVar1 = (ch->rx).mtu;
    puVar2[4] = (char)uVar1;
    puVar2[5] = (char)(uVar1 >> 8);
    uVar1 = (ch->rx).mps;
    puVar2[6] = (char)uVar1;
    puVar2[7] = (char)(uVar1 >> 8);
    uVar1 = (ch->rx).init_credits;
    puVar2[8] = (char)uVar1;
    puVar2[9] = (char)(uVar1 >> 8);
    k_delayed_work_submit(&(ch->chan).rtx_work,40000);
    bt_l2cap_send((ch->chan).conn,5,buf);
    iVar3 = 0;
  }
  return iVar3;
}



// WARNING: Type propagation algorithm not settling

void bt_l2cap_encrypt_change(bt_conn *conn,u8_t hci_status)

{
  bt_l2cap_le_chan *ch;
  undefined3 in_register_0000202d;
  int *piVar1;
  
  piVar1 = (int *)(conn->channels).head;
  if (piVar1 == (int *)0x0) {
    return;
  }
  do {
    ch = (bt_l2cap_le_chan *)(piVar1 + 0xfffffffe);
    if (ch == (bt_l2cap_le_chan *)0x0) {
      return;
    }
    if ((*(char *)(piVar1 + 0xc) == '\x01') && (*(char *)(piVar1 + 0xd) == '\0')) {
      if (CONCAT31(in_register_0000202d,hci_status) == 0) {
        l2cap_le_conn_req(ch);
      }
      else {
        bt_l2cap_chan_remove((ch->chan).conn,(bt_l2cap_chan *)ch);
        bt_l2cap_chan_del((bt_l2cap_chan *)ch);
      }
    }
    if (*(code **)(piVar1[0xffffffff] + 8) != (code *)0x0) {
      (**(code **)(piVar1[0xffffffff] + 8))(ch,CONCAT31(in_register_0000202d,hci_status));
    }
    piVar1 = (int *)*piVar1;
  } while (piVar1 != (int *)0x0);
  return;
}



void l2cap_send_reject(bt_conn *conn,u8_t ident,u16_t reason,void *data,u8_t data_len)

{
  net_buf *buf;
  undefined *puVar1;
  undefined3 in_register_00002039;
  
  buf = l2cap_create_le_sig_pdu('\x01',ident,(short)CONCAT31(in_register_00002039,data_len) + 2);
  if (buf != (net_buf *)0x0) {
    puVar1 = (undefined *)net_buf_simple_add((net_buf_simple *)&buf->field_4,2);
    *puVar1 = (char)reason;
    puVar1[1] = (char)(reason >> 8);
    if (data != (void *)0x0) {
      net_buf_simple_add_mem
                ((net_buf_simple *)&buf->field_4,data,CONCAT31(in_register_00002039,data_len));
    }
    bt_l2cap_send(conn,5,buf);
    return;
  }
  return;
}



int l2cap_chan_le_send(bt_l2cap_le_chan *ch,net_buf *buf,u16_t sdu_hdr_len)

{
  u16_t cid;
  atomic_t *target;
  int iVar1;
  size_t sVar2;
  net_buf *buf_00;
  net_buf_pool *pool;
  bt_conn *conn;
  uint uVar3;
  uint len;
  undefined2 in_register_00002032;
  anon_subr_void_bt_l2cap_chan_ptr_atomic_t_ptr_for_status *paVar4;
  int iVar5;
  net_buf_simple *buf_01;
  k_sem *sem;
  
  iVar5 = CONCAT22(in_register_00002032,sdu_hdr_len);
  sem = &(ch->tx).credits;
  iVar1 = k_sem_take(sem,0);
  if (iVar1 != 0) {
    return -0xb;
  }
  if ((uint)*(ushort *)((int)&buf->field_4 + 4) + iVar5 <= (uint)(ch->tx).mps) {
    sVar2 = net_buf_simple_headroom((net_buf_simple *)&buf->field_4);
    if (((iVar5 + 9U & 0xffff) <= sVar2) && (buf->field_0 == 0)) {
      if (iVar5 != 0) {
        sVar2 = net_buf_frags_len(buf);
        net_buf_simple_push_le16((net_buf_simple *)&buf->field_4,(u16_t)sVar2);
      }
      buf_00 = net_buf_ref(buf);
      if (buf_00 == (net_buf *)0x0) {
        return -0xc;
      }
      goto LAB_2301fc88;
    }
  }
  pool = net_buf_pool_get((uint)buf->pool_id);
  buf_00 = net_buf_alloc_fixed(pool,0);
  if (buf_00 == (net_buf *)0x0) {
    buf_00 = bt_conn_create_pdu_timeout((net_buf_pool *)0x0,4,-1);
    if (buf_00 == (net_buf *)0x0) {
      return -0xc;
    }
  }
  else {
    net_buf_simple_reserve((net_buf_simple *)&buf_00->field_4,9);
  }
  buf_01 = (net_buf_simple *)&buf_00->field_4;
  if (iVar5 != 0) {
    sVar2 = net_buf_frags_len(buf);
    net_buf_simple_add_le16(buf_01,(u16_t)sVar2);
  }
  sVar2 = net_buf_simple_tailroom(buf_01);
  uVar3 = (uint)(ch->tx).mps - iVar5;
  if (sVar2 < uVar3) {
    uVar3 = net_buf_simple_tailroom(buf_01);
  }
  len = (uint)*(ushort *)((int)&buf->field_4 + 4);
  if ((uVar3 & 0xffff) < len) {
    len = uVar3 & 0xffff;
  }
  net_buf_simple_add_mem(buf_01,*(void **)&buf->field_4,len);
  net_buf_simple_pull((net_buf_simple *)&buf->field_4,len);
LAB_2301fc88:
  conn = (ch->chan).conn;
  if (conn == (bt_conn *)0x0) {
    net_buf_unref(buf);
    iVar5 = -0x36;
  }
  else {
    cid = (ch->tx).cid;
    iVar5 = (uint)*(ushort *)((int)&buf_00->field_4 + 4) - iVar5;
    if (((buf == buf_00) || (*(short *)((int)&buf->field_4 + 4) == 0)) &&
       (((ch->chan).ops)->sent != (anon_subr_void_bt_l2cap_chan_ptr_for_sent *)0x0)) {
      bt_l2cap_send_cb(conn,cid,buf_00,l2cap_chan_sdu_sent,ch);
    }
    else {
      bt_l2cap_send(conn,cid,buf_00);
    }
    uVar3 = k_sem_count_get(sem);
    if (uVar3 == 0) {
      target = (ch->chan).status;
      atomic_and(target,-2);
      paVar4 = ((ch->chan).ops)->status;
      if (paVar4 != (anon_subr_void_bt_l2cap_chan_ptr_atomic_t_ptr_for_status *)0x0) {
        (*paVar4)((bt_l2cap_chan *)ch,target);
      }
    }
  }
  return iVar5;
}



int l2cap_chan_le_send_sdu(bt_l2cap_le_chan *param_1,net_buf **param_2,ushort param_3)

{
  net_buf *buf;
  int iVar1;
  size_t sVar2;
  uint uVar3;
  ushort auStack34 [5];
  
  buf = *param_2;
  auStack34[0] = param_3;
  sVar2 = net_buf_frags_len(buf);
  uVar3 = (uint)auStack34[0];
  iVar1 = -0x24;
  if ((int)(uVar3 + sVar2) <= (int)(uint)(param_1->tx).mtu) {
    if ((*(short *)((int)&buf->field_4 + 4) == 0) && ((net_buf *)buf->field_0 != (net_buf *)0x0)) {
      buf = (net_buf *)buf->field_0;
    }
    if (auStack34[0] == 0) {
      iVar1 = l2cap_chan_le_send(param_1,buf,2);
      if (iVar1 < 0) {
LAB_2301fd60:
        if (iVar1 == -0xb) {
          memcpy(buf->user_data,auStack34,2);
        }
        *param_2 = buf;
        return iVar1;
      }
      auStack34[0] = (ushort)iVar1;
    }
    iVar1 = 0;
    while ((int)(uint)auStack34[0] < (int)(uVar3 + sVar2)) {
      if (*(short *)((int)&buf->field_4 + 4) == 0) {
        buf = net_buf_frag_del((net_buf *)0x0,buf);
      }
      iVar1 = l2cap_chan_le_send(param_1,buf,0);
      if (iVar1 < 0) goto LAB_2301fd60;
      auStack34[0] = auStack34[0] + (short)iVar1;
    }
    net_buf_unref(buf);
  }
  return iVar1;
}



bt_l2cap_chan * bt_l2cap_le_lookup_tx_cid(bt_conn *conn,u16_t cid)

{
  bt_conn *pbVar1;
  bt_conn *pbVar2;
  undefined2 in_register_0000202e;
  
  pbVar2 = (bt_conn *)(conn->channels).head;
  while (((pbVar1 = pbVar2, pbVar2 != (bt_conn *)0x0 &&
          (pbVar1 = (bt_conn *)&(&pbVar2[-1].update_work)[2].work.handler, pbVar1 != (bt_conn *)0x0)
          ) && ((uint)*(ushort *)&(&pbVar2->channels)[1].tail != CONCAT22(in_register_0000202e,cid))
         )) {
    pbVar2 = *(bt_conn **)&pbVar2->handle;
  }
  return (bt_l2cap_chan *)pbVar1;
}



bt_l2cap_chan * bt_l2cap_le_lookup_rx_cid(bt_conn *conn,u16_t cid)

{
  bt_conn *pbVar1;
  bt_conn *pbVar2;
  undefined2 in_register_0000202e;
  
  pbVar2 = (bt_conn *)(conn->channels).head;
  while (((pbVar1 = pbVar2, pbVar2 != (bt_conn *)0x0 &&
          (pbVar1 = (bt_conn *)&(&pbVar2[-1].update_work)[2].work.handler, pbVar1 != (bt_conn *)0x0)
          ) && ((uint)*(ushort *)&pbVar2->tx_queue != CONCAT22(in_register_0000202e,cid)))) {
    pbVar2 = *(bt_conn **)&pbVar2->handle;
  }
  return (bt_l2cap_chan *)pbVar1;
}



_Bool l2cap_chan_add(bt_conn *conn,bt_l2cap_chan *chan,bt_l2cap_chan_destroy_t *destroy)

{
  short sVar1;
  undefined uVar2;
  u16_t cid;
  bt_l2cap_chan *pbVar3;
  sys_snode_t *psVar4;
  _snode *p_Var5;
  
  if ((chan == (bt_l2cap_chan *)0x0) || (*(short *)&chan[1].conn == 0)) {
    cid = 0x40;
    do {
      if (chan != (bt_l2cap_chan *)0x0) {
        pbVar3 = bt_l2cap_le_lookup_rx_cid(conn,cid);
        if (pbVar3 == (bt_l2cap_chan *)0x0) {
          *(u16_t *)&chan[1].conn = cid;
          goto LAB_2301fe2c;
        }
      }
      cid = cid + 1;
    } while (cid != 0x80);
    printf("Unable to allocate L2CAP CID\r\n");
    uVar2 = 0;
  }
  else {
LAB_2301fe2c:
    k_delayed_work_init(&chan->rtx_work,l2cap_rtx_timeout);
    (chan->node).next = (_snode *)0x0;
    psVar4 = (conn->channels).tail;
    p_Var5 = (_snode *)&chan->node;
    if (psVar4 == (sys_snode_t *)0x0) {
      *(_snode **)&(conn->channels).tail = p_Var5;
      *(_snode **)&(conn->channels).head = p_Var5;
    }
    else {
      psVar4->next = p_Var5;
      *(_snode **)&(conn->channels).tail = p_Var5;
    }
    sVar1 = *(short *)&chan[1].conn;
    chan->conn = conn;
    *(bt_l2cap_chan_destroy_t **)&chan->destroy = destroy;
    uVar2 = 1;
    if ((ushort)(sVar1 - 0x40U) < 0x40) {
      k_work_init((k_work *)(chan + 2),l2cap_rx_process);
      k_queue_init((k_queue *)&chan[2].destroy,0x14);
      chan->state = BT_L2CAP_CONNECT;
    }
  }
  return (_Bool)uVar2;
}



// WARNING: Variable defined which should be unmapped: chan

void bt_l2cap_connected(bt_conn *conn)

{
  undefined2 uVar1;
  bt_l2cap_fixed_chan *pbVar2;
  _Bool _Var3;
  int iVar4;
  undefined3 extraout_var;
  code *pcVar5;
  anon_subr_void_bt_l2cap_chan_ptr_for_connected *paVar6;
  anon_subr_void_bt_l2cap_chan_ptr_atomic_t_ptr_for_status *paVar7;
  bt_l2cap_chan *local_14;
  bt_l2cap_chan *chan;
  
  pbVar2 = &att_fixed_chan;
  do {
    if (&boot2_partition_table <= pbVar2) {
      return;
    }
    pcVar5 = (code *)(((anon_struct_conflict1 *)pbVar2)->table).ptTable.magicCode;
    iVar4 = (*pcVar5)(conn,&local_14,pcVar5);
    if (-1 < iVar4) {
      uVar1 = *(undefined2 *)pbVar2;
      *(undefined2 *)&local_14[1].conn = uVar1;
      *(undefined2 *)&local_14[1].rtx_work.work.handler = uVar1;
      _Var3 = l2cap_chan_add(conn,local_14,(bt_l2cap_chan_destroy_t *)0x0);
      if (CONCAT31(extraout_var,_Var3) == 0) {
        return;
      }
      paVar6 = local_14->ops->connected;
      if (paVar6 != (anon_subr_void_bt_l2cap_chan_ptr_for_connected *)0x0) {
        (*paVar6)(local_14);
      }
      atomic_or(local_14->status,1);
      paVar7 = local_14->ops->status;
      if (paVar7 != (anon_subr_void_bt_l2cap_chan_ptr_atomic_t_ptr_for_status *)0x0) {
        (*paVar7)(local_14,local_14->status);
      }
    }
    pbVar2 = (bt_l2cap_fixed_chan *)&(((anon_struct_conflict1 *)pbVar2)->table).ptTable.age;
  } while( true );
}



void bt_l2cap_recv(bt_conn *conn,net_buf *buf)

{
  ushort cid;
  void *pvVar1;
  bt_l2cap_chan *pbVar2;
  net_buf *buf_00;
  
  if (*(ushort *)((int)&buf->field_4 + 4) < 4) {
    printf("Too small L2CAP PDU received\r\n");
  }
  else {
    pvVar1 = net_buf_simple_pull_mem((net_buf_simple *)&buf->field_4,4);
    cid = *(ushort *)((int)pvVar1 + 2);
    pbVar2 = bt_l2cap_le_lookup_rx_cid(conn,cid);
    if (pbVar2 == (bt_l2cap_chan *)0x0) {
      printf("Ignoring data for unknown CID 0x%04x\r\n",(uint)cid);
    }
    else {
      if ((ushort)(*(short *)&pbVar2[1].conn - 0x40U) < 0x40) {
        buf_00 = net_buf_ref(buf);
        net_buf_put((k_fifo *)&pbVar2[2].destroy,buf_00);
        k_work_submit((k_work *)(pbVar2 + 2));
        return;
      }
      (*pbVar2->ops->recv)(pbVar2,buf);
    }
  }
  net_buf_unref(buf);
  return;
}



int bt_l2cap_update_conn_param(bt_conn *conn,bt_le_conn_param *param)

{
  u16_t uVar1;
  u8_t ident;
  net_buf *buf;
  undefined *puVar2;
  int iVar3;
  
  ident = get_ident();
  buf = l2cap_create_le_sig_pdu('\x12',ident,8);
  if (buf == (net_buf *)0x0) {
    iVar3 = -0xc;
  }
  else {
    puVar2 = (undefined *)net_buf_simple_add((net_buf_simple *)&buf->field_4,8);
    uVar1 = param->interval_min;
    *puVar2 = (char)uVar1;
    puVar2[1] = (char)(uVar1 >> 8);
    uVar1 = param->interval_max;
    puVar2[2] = (char)uVar1;
    puVar2[3] = (char)(uVar1 >> 8);
    uVar1 = param->latency;
    puVar2[4] = (char)uVar1;
    puVar2[5] = (char)(uVar1 >> 8);
    uVar1 = param->timeout;
    puVar2[6] = (char)uVar1;
    puVar2[7] = (char)(uVar1 >> 8);
    bt_l2cap_send(conn,5,buf);
    iVar3 = 0;
  }
  return iVar3;
}



void bt_l2cap_init(void)

{
  return;
}



int bt_l2cap_chan_disconnect(bt_l2cap_chan *chan)

{
  undefined2 uVar1;
  u8_t ident;
  net_buf *buf;
  int iVar2;
  undefined *puVar3;
  
  if (chan->conn != (bt_conn *)0x0) {
    ident = get_ident();
    chan->ident = ident;
    buf = l2cap_create_le_sig_pdu('\x06',ident,4);
    iVar2 = -0xc;
    if (buf != (net_buf *)0x0) {
      puVar3 = (undefined *)net_buf_simple_add((net_buf_simple *)&buf->field_4,4);
      uVar1 = *(undefined2 *)&chan[1].conn;
      *puVar3 = (char)uVar1;
      puVar3[1] = (char)((ushort)uVar1 >> 8);
      uVar1 = *(undefined2 *)&chan[1].rtx_work.work.handler;
      puVar3[2] = (char)uVar1;
      puVar3[3] = (char)((ushort)uVar1 >> 8);
      k_delayed_work_submit(&chan->rtx_work,2000);
      bt_l2cap_send(chan->conn,5,buf);
      chan->state = BT_L2CAP_DISCONNECT;
      iVar2 = 0;
    }
    return iVar2;
  }
  return -0x39;
}



void l2cap_chan_le_recv_seg(bt_l2cap_le_chan *param_1,net_buf *param_2)

{
  ushort uVar1;
  u16_t credits;
  size_t sVar2;
  char *fmt;
  uint uVar3;
  int iVar4;
  uint uVar5;
  bt_l2cap_chan_ops *pbVar6;
  net_buf *buf;
  k_sem *sem;
  u16_t auStack34 [7];
  
  buf = param_1->_sdu;
  auStack34[0] = 0;
  sVar2 = net_buf_frags_len(buf);
  if ((sVar2 & 0xffff) != 0) {
    memcpy(auStack34,buf->user_data,2);
  }
  if ((uint)param_1->_sdu_len < (sVar2 & 0xffff) + (uint)*(ushort *)((int)&param_2->field_4 + 4)) {
    fmt = "SDU length mismatch\r\n";
  }
  else {
    auStack34[0] = auStack34[0] + 1;
    memcpy(param_1->_sdu->user_data,auStack34,2);
    sVar2 = net_buf_append_bytes
                      (param_1->_sdu,(uint)*(ushort *)((int)&param_2->field_4 + 4),
                       *(void **)&param_2->field_4,0,l2cap_alloc_frag,param_1);
    if ((uint)*(ushort *)((int)&param_2->field_4 + 4) == (sVar2 & 0xffff)) {
      buf = param_1->_sdu;
      sVar2 = net_buf_frags_len(buf);
      credits = auStack34[0];
      if (param_1->_sdu_len <= sVar2) {
        pbVar6 = (param_1->chan).ops;
        param_1->_sdu = (net_buf *)0x0;
        param_1->_sdu_len = 0;
        iVar4 = (*pbVar6->recv)((bt_l2cap_chan *)param_1,buf);
        if (iVar4 < 0) {
          if (iVar4 == -0x44) {
            return;
          }
          printf("err %d\r\n");
          bt_l2cap_chan_disconnect((bt_l2cap_chan *)param_1);
        }
        else {
          l2cap_chan_send_credits(param_1,credits);
        }
        net_buf_unref(buf);
        return;
      }
      sem = &(param_1->rx).credits;
      uVar3 = k_sem_count_get(sem);
      if (uVar3 != 0) {
        return;
      }
      if ((param_1->rx).init_credits != auStack34[0]) {
        return;
      }
      sVar2 = net_buf_frags_len(param_2);
      uVar5 = (uint)(param_1->rx).mps;
      uVar1 = param_1->_sdu_len;
      uVar3 = k_sem_count_get(sem);
      iVar4 = ((uVar1 + uVar5 + -1) - sVar2) / uVar5 - uVar3;
      if ((short)iVar4 < 1) {
        return;
      }
      l2cap_chan_send_credits(param_1,(u16_t)((uint)(iVar4 * 0x10000) >> 0x10));
      return;
    }
    fmt = "Unable to store SDU\r\n";
  }
  printf(fmt);
  bt_l2cap_chan_disconnect((bt_l2cap_chan *)param_1);
  return;
}



void l2cap_rx_process(k_work *work)

{
  bt_l2cap_le_chan *chan;
  u16_t uVar1;
  net_buf *buf;
  int iVar2;
  char *fmt;
  undefined2 extraout_var;
  k_work_handler_t *pkVar3;
  code *pcVar4;
  
  chan = (bt_l2cap_le_chan *)&work[-0xb].handler;
  do {
    buf = net_buf_get((k_fifo *)(work + 1),0);
    if (buf == (net_buf *)0x0) {
      return;
    }
    iVar2 = k_sem_take((k_sem *)&work[-5].handler,0);
    if (iVar2 != 0) {
      fmt = "No credits to receive packet\r\n";
      goto LAB_230202a0;
    }
    if (work[-1].handler != (k_work_handler_t *)0x0) {
LAB_230202b8:
      l2cap_chan_le_recv_seg(chan,buf);
      goto LAB_230202aa;
    }
    uVar1 = net_buf_simple_pull_le16((net_buf_simple *)&buf->field_4);
    fmt = "Invalid SDU length\r\n";
    if ((uint)*(ushort *)((int)work[-6].flags + 2) < CONCAT22(extraout_var,uVar1)) {
LAB_230202a0:
      printf(fmt);
LAB_230202a4:
      bt_l2cap_chan_disconnect((bt_l2cap_chan *)chan);
    }
    else {
      pcVar4 = *(code **)(work[-0xb].flags[0] + 0xc);
      if (pcVar4 != (code *)0x0) {
        pkVar3 = (k_work_handler_t *)(*pcVar4)(chan);
        work[-1].handler = pkVar3;
        if (pkVar3 != (k_work_handler_t *)0x0) {
          *(u16_t *)work[-1].flags = uVar1;
          goto LAB_230202b8;
        }
        fmt = "Unable to allocate buffer for SDU\r\n";
        goto LAB_230202a0;
      }
      pcVar4 = *(code **)(work[-0xb].flags[0] + 0x10);
      iVar2 = (*pcVar4)(chan,buf,pcVar4);
      if (iVar2 != 0) {
        if (iVar2 == -0x44) goto LAB_230202aa;
        printf("err %d\r\n",iVar2);
        goto LAB_230202a4;
      }
      l2cap_chan_send_credits(chan,1);
    }
LAB_230202aa:
    net_buf_unref(buf);
  } while( true );
}



// WARNING: Could not reconcile some variable overlaps

int l2cap_recv(bt_l2cap_chan *chan_1,net_buf *buf)

{
  ushort credits;
  u16_t cid;
  u16_t credits_00;
  u16_t credits_01;
  ushort uVar1;
  u16_t *__s;
  _Bool remove;
  char *fmt;
  byte *pbVar2;
  net_buf *buf_00;
  bt_l2cap_server *pbVar3;
  undefined3 extraout_var;
  bt_l2cap_le_chan *chan_00;
  uint uVar4;
  bt_l2cap_le_chan *pbVar5;
  int iVar6;
  undefined3 extraout_var_00;
  bt_conn *conn;
  byte ident;
  undefined *data;
  u8_t data_len;
  int iVar7;
  bt_security_t bVar8;
  u16_t psm;
  bt_l2cap_chan_ops *pbVar9;
  anon_subr_void_bt_l2cap_chan_ptr_for_connected *paVar10;
  bt_l2cap_chan **ppbVar11;
  bt_l2cap_le_chan *local_38;
  bt_l2cap_chan *chan;
  
  if (*(ushort *)((int)&buf->field_4 + 4) < 4) {
    fmt = "Too small L2CAP signaling PDU\r\n";
    goto LAB_23020344;
  }
  pbVar2 = (byte *)net_buf_simple_pull_mem((net_buf_simple *)&buf->field_4,4);
  credits = *(ushort *)((int)&buf->field_4 + 4);
  if ((uint)*(ushort *)(pbVar2 + 2) != (uint)credits) {
    printf("L2CAP length mismatch (%u != %u)\r\n",(uint)credits);
    return 0;
  }
  ident = pbVar2[1];
  if (ident == 0) {
    fmt = "Invalid ident value in L2CAP PDU\r\n";
    goto LAB_23020344;
  }
  switch((uint)*pbVar2 - 1 & 0xff) {
  case 0:
    chan_00 = __l2cap_lookup_ident(chan_1->conn,(ushort)ident,true);
    break;
  default:
    printf("Unknown L2CAP PDU code 0x%02x\r\n");
    data_len = '\0';
    data = (undefined *)0x0;
    psm = 0;
    ident = pbVar2[1];
    conn = chan_1->conn;
    goto LAB_230206e8;
  case 5:
    if (3 < credits) {
      __s = *(u16_t **)&buf->field_4;
      conn = chan_1->conn;
      chan_00 = l2cap_remove_rx_cid(conn,*__s);
      if (chan_00 != (bt_l2cap_le_chan *)0x0) {
        buf_00 = l2cap_create_le_sig_pdu('\a',ident,4);
        if (buf_00 == (net_buf *)0x0) {
          return 0;
        }
        data = (undefined *)net_buf_simple_add((net_buf_simple *)&buf_00->field_4,4);
        psm = (chan_00->rx).cid;
        *data = (char)psm;
        data[1] = (char)(psm >> 8);
        psm = (chan_00->tx).cid;
        data[2] = (char)psm;
        data[3] = (char)(psm >> 8);
        bt_l2cap_chan_del((bt_l2cap_chan *)chan_00);
        goto LAB_230204a2;
      }
      data = &local_38;
      psm = 2;
      local_38 = (bt_l2cap_le_chan *)CONCAT22(*__s,__s[1]);
      data_len = '\x04';
      goto LAB_230206e8;
    }
    goto LAB_230203e0;
  case 6:
    if (credits < 4) {
      fmt = "Too small LE disconn rsp packet size\r\n";
      goto LAB_23020344;
    }
    chan_00 = l2cap_remove_rx_cid(chan_1->conn,*(u16_t *)(*(int *)&buf->field_4 + 2));
    break;
  case 0x11:
    if (credits < 8) {
      fmt = "Too small LE conn update param req\r\n";
      goto LAB_23020344;
    }
    conn = chan_1->conn;
    if (conn->role == '\0') {
      ppbVar11 = *(bt_l2cap_chan ***)&buf->field_4;
      local_38 = (bt_l2cap_le_chan *)*ppbVar11;
      chan._0_2_ = *(u16_t *)(ppbVar11 + 1);
      chan._2_2_ = *(u16_t *)((int)ppbVar11 + 6);
      buf_00 = l2cap_create_le_sig_pdu('\x13',ident,2);
      if (buf_00 == (net_buf *)0x0) {
        return 0;
      }
      remove = le_param_req(conn,(bt_le_conn_param *)&local_38);
      pbVar2 = (byte *)net_buf_simple_add((net_buf_simple *)&buf_00->field_4,2);
      *pbVar2 = remove ^ 1;
      pbVar2[1] = 0;
      bt_l2cap_send(conn,5,buf_00);
      if (CONCAT31(extraout_var_00,remove) == 0) {
        return 0;
      }
      bt_conn_le_conn_update(conn,(bt_le_conn_param *)&local_38);
      return 0;
    }
    data_len = '\0';
    data = (undefined *)0x0;
    psm = 0;
LAB_230206e8:
    l2cap_send_reject(conn,ident,psm,data,data_len);
    return 0;
  case 0x12:
    if (1 < credits) {
      return 0;
    }
    fmt = "Too small LE conn param rsp\r\n";
    goto LAB_23020344;
  case 0x13:
    if (9 < credits) {
      __s = *(u16_t **)&buf->field_4;
      credits = __s[2];
      if ((credits < 0x17) || (uVar1 = __s[3], uVar1 < 0x17)) {
        fmt = "Invalid LE-Conn Req params\r\n";
        goto LAB_23020344;
      }
      psm = *__s;
      conn = chan_1->conn;
      cid = __s[1];
      credits_00 = __s[4];
      buf_00 = l2cap_create_le_sig_pdu('\x15',ident,10);
      if (buf_00 == (net_buf *)0x0) {
        return 0;
      }
      __s = (u16_t *)net_buf_simple_add((net_buf_simple *)&buf_00->field_4,10);
      memset(__s,0,10);
      pbVar3 = l2cap_server_lookup_psm(psm);
      psm = 2;
      if (pbVar3 != (bt_l2cap_server *)0x0) {
        if ((byte)conn->sec_level < (byte)pbVar3->sec_level) {
          psm = 5;
        }
        else {
          if (0x3f < (ushort)(cid - 0x40)) {
            __s[4] = 9;
            goto LAB_230204a2;
          }
          local_38 = (bt_l2cap_le_chan *)bt_l2cap_le_lookup_tx_cid(conn,cid);
          psm = 10;
          if (local_38 == (bt_l2cap_le_chan *)0x0) {
            iVar6 = (*pbVar3->accept)(conn,(bt_l2cap_chan **)&local_38);
            if (iVar6 < 0) {
              psm = 6;
              if (iVar6 != -0xd) {
                if (iVar6 < -0xc) {
                  iVar7 = -0x23;
                  psm = 2;
                }
                else {
                  psm = 4;
                  if (iVar6 == -0xc) goto LAB_23020482;
                  iVar7 = -1;
                  psm = 7;
                }
                if (iVar6 != iVar7) {
                  psm = 0xb;
                }
              }
            }
            else {
              (local_38->chan).required_sec_level = pbVar3->sec_level;
              remove = l2cap_chan_add(conn,(bt_l2cap_chan *)local_38,l2cap_chan_destroy);
              chan_00 = local_38;
              psm = 4;
              if (CONCAT31(extraout_var,remove) != 0) {
                l2cap_chan_tx_init(local_38);
                (chan_00->tx).cid = cid;
                (chan_00->tx).mtu = credits;
                (chan_00->tx).init_credits = credits_00;
                (chan_00->tx).mps = uVar1;
                l2cap_chan_tx_give_credits(chan_00,credits_00);
                l2cap_chan_rx_init(chan_00);
                psm = (chan_00->rx).init_credits;
                while (psm = psm - 1, psm != 0xffff) {
                  k_sem_give(&(chan_00->rx).credits);
                }
                (local_38->chan).psm = pbVar3->psm;
                (local_38->chan).state = BT_L2CAP_CONNECTED;
                paVar10 = ((local_38->chan).ops)->connected;
                if (paVar10 != (anon_subr_void_bt_l2cap_chan_ptr_for_connected *)0x0) {
                  (*paVar10)((bt_l2cap_chan *)local_38);
                }
                *__s = (chan_00->rx).cid;
                __s[2] = (chan_00->rx).mps;
                __s[1] = (chan_00->rx).mtu;
                psm = (chan_00->rx).init_credits;
                __s[4] = 0;
                __s[3] = psm;
                goto LAB_230204a2;
              }
            }
          }
        }
      }
LAB_23020482:
      __s[4] = psm;
LAB_230204a2:
      bt_l2cap_send(conn,5,buf_00);
      return 0;
    }
LAB_230203e0:
    fmt = "Too small LE conn req packet size\r\n";
LAB_23020344:
    printf(fmt);
    return 0;
  case 0x14:
    if (credits < 10) {
      fmt = "Too small LE conn rsp packet size\r\n";
      goto LAB_23020344;
    }
    __s = *(u16_t **)&buf->field_4;
    conn = chan_1->conn;
    credits = __s[4];
    psm = *__s;
    cid = __s[1];
    credits_00 = __s[2];
    credits_01 = __s[3];
    if (((credits & 0xfff7) == 0) || (remove = true, credits == 5)) {
      remove = false;
    }
    chan_00 = __l2cap_lookup_ident(conn,(ushort)ident,remove);
    if (chan_00 == (bt_l2cap_le_chan *)0x0) {
      printf("Cannot find channel for ident %u\r\n",(uint)ident);
      return 0;
    }
    k_delayed_work_cancel(&(chan_00->chan).rtx_work);
    (chan_00->chan).ident = '\0';
    if ((credits != 5) && (credits != 8)) {
      if (credits == 0) {
        (chan_00->chan).state = BT_L2CAP_CONNECTED;
        pbVar9 = (chan_00->chan).ops;
        (chan_00->tx).cid = psm;
        (chan_00->tx).mtu = cid;
        (chan_00->tx).mps = credits_00;
        paVar10 = pbVar9->connected;
        if (paVar10 != (anon_subr_void_bt_l2cap_chan_ptr_for_connected *)0x0) {
          (*paVar10)((bt_l2cap_chan *)chan_00);
        }
        l2cap_chan_tx_give_credits(chan_00,credits_01);
        psm = (chan_00->rx).init_credits;
        while (psm = psm - 1, psm != 0xffff) {
          k_sem_give(&(chan_00->rx).credits);
        }
        return 0;
      }
      goto LAB_23020678;
    }
    if (credits == 5) {
      ident = (chan_00->chan).required_sec_level;
      if (ident < 2) goto LAB_2302065a;
      if (ident == 2) {
        bVar8 = BT_SECURITY_L3;
      }
      else {
        if (ident != 3) goto LAB_2302066e;
        bVar8 = BT_SECURITY_L4;
      }
LAB_2302065c:
      (chan_00->chan).required_sec_level = bVar8;
      iVar6 = bt_conn_set_security((chan_00->chan).conn,(chan_00->chan).required_sec_level);
      if (iVar6 == 0) {
        return 0;
      }
    }
    else {
      if ((credits == 8) && ((byte)(chan_00->chan).required_sec_level < 2)) {
LAB_2302065a:
        bVar8 = BT_SECURITY_MEDIUM;
        goto LAB_2302065c;
      }
    }
LAB_2302066e:
    bt_l2cap_chan_remove(conn,(bt_l2cap_chan *)chan_00);
    goto LAB_23020678;
  case 0x15:
    if (credits < 4) {
      fmt = "Too small LE Credits packet size\r\n";
    }
    else {
      __s = *(u16_t **)&buf->field_4;
      chan_00 = (bt_l2cap_le_chan *)bt_l2cap_le_lookup_tx_cid(chan_1->conn,*__s);
      if (chan_00 != (bt_l2cap_le_chan *)0x0) {
        credits = __s[1];
        uVar4 = k_sem_count_get(&(chan_00->tx).credits);
        if (0xffff < uVar4 + credits) {
          printf("Credits overflow\r\n");
          bt_l2cap_chan_disconnect((bt_l2cap_chan *)chan_00);
          return 0;
        }
        l2cap_chan_tx_give_credits(chan_00,credits);
        while( true ) {
          pbVar5 = (bt_l2cap_le_chan *)chan_00->tx_buf;
          if (pbVar5 == (bt_l2cap_le_chan *)0x0) {
            pbVar5 = (bt_l2cap_le_chan *)net_buf_get(&chan_00->tx_queue,0);
          }
          else {
            chan_00->tx_buf = (net_buf *)0x0;
          }
          if (pbVar5 == (bt_l2cap_le_chan *)0x0) break;
          local_38 = pbVar5;
          iVar6 = l2cap_chan_le_send_sdu
                            (chan_00,&local_38,
                             (uint)*(ushort *)&(pbVar5->chan).rtx_work.work.handler);
          if (iVar6 < 0) {
            if (iVar6 != -0xb) {
              return 0;
            }
            *(bt_l2cap_le_chan **)&chan_00->tx_buf = local_38;
            return 0;
          }
        }
        return 0;
      }
      fmt = "Unable to find channel of LE Credits packet\r\n";
    }
    goto LAB_23020344;
  }
  if (chan_00 == (bt_l2cap_le_chan *)0x0) {
    return 0;
  }
LAB_23020678:
  bt_l2cap_chan_del((bt_l2cap_chan *)chan_00);
  return 0;
}



void sys_memcpy_swap(void *dst,void *src,size_t length)

{
  undefined *puVar1;
  undefined *puVar2;
  undefined *puVar3;
  
  puVar1 = (undefined *)dst;
  puVar3 = (undefined *)((int)src + (length - 1));
  do {
    puVar2 = puVar1 + 1;
    *puVar1 = *puVar3;
    puVar1 = puVar2;
    puVar3 = puVar3 + -1;
  } while ((undefined *)(length + (int)dst) != puVar2);
  return;
}



void sys_mem_swap(void *buf,size_t length)

{
  undefined uVar1;
  undefined *puVar2;
  undefined *puVar3;
  int iVar4;
  
  iVar4 = (int)buf + length;
  puVar2 = (undefined *)buf;
  do {
    uVar1 = *puVar2;
    puVar3 = puVar2 + 1;
    *puVar2 = *(undefined *)(iVar4 + -1);
    *(undefined *)(iVar4 + -1) = uVar1;
    iVar4 = iVar4 + -1;
    puVar2 = puVar3;
  } while (puVar3 != (undefined *)((length >> 1) + (int)buf));
  return;
}



u8_t get_io_capa(void)

{
  u8_t uVar1;
  anon_subr_void_bt_conn_ptr_uint_for_passkey_display *paVar2;
  
  uVar1 = '\x03';
  if (bt_auth != (bt_conn_auth_cb *)0x0) {
    paVar2 = bt_auth->passkey_display;
    if ((paVar2 == (anon_subr_void_bt_conn_ptr_uint_for_passkey_display *)0x0) ||
       (bt_auth->passkey_entry == (anon_subr_void_bt_conn_ptr_for_passkey_entry *)0x0)) {
      if ((sc_supported != false) &&
         ((paVar2 != (anon_subr_void_bt_conn_ptr_uint_for_passkey_display *)0x0 &&
          (bt_auth->passkey_confirm != (anon_subr_void_bt_conn_ptr_uint_for_passkey_confirm *)0x0)))
         ) {
        return '\x01';
      }
    }
    else {
      if (bt_auth->passkey_confirm != (anon_subr_void_bt_conn_ptr_uint_for_passkey_confirm *)0x0) {
        return '\x04';
      }
      if (sc_supported == false) {
        return '\x04';
      }
    }
    uVar1 = '\x02';
    if ((bt_auth->passkey_entry == (anon_subr_void_bt_conn_ptr_for_passkey_entry *)0x0) &&
       (uVar1 = '\x03', paVar2 != (anon_subr_void_bt_conn_ptr_uint_for_passkey_display *)0x0)) {
      uVar1 = '\0';
    }
  }
  return uVar1;
}



bt_smp * smp_chan_get(bt_conn *conn)

{
  bt_smp *pbVar1;
  
  pbVar1 = (bt_smp *)bt_l2cap_le_lookup_rx_cid(conn,6);
  if (pbVar1 == (bt_smp *)0x0) {
    printf("Unable to find SMP channel\r\n");
  }
  return pbVar1;
}



void atomic_set_bit(atomic_t *target,int bit)

{
  atomic_or(target,1 << (bit & 0x1fU));
  return;
}



int atomic_test_bit(atomic_t *target,int bit)

{
  atomic_val_t aVar1;
  
  aVar1 = atomic_get(target);
  return aVar1 >> (bit & 0x1fU) & 1;
}



void smp_reset(bt_smp *smp)

{
  bt_conn *pbVar1;
  int bit;
  
  pbVar1 = (smp->chan).chan.conn;
  k_delayed_work_cancel(&smp->work);
  smp->method = '\0';
  atomic_set(&smp->allowed_cmds,0);
  atomic_set(smp->flags,0);
  if (pbVar1->required_sec_level != pbVar1->sec_level) {
    pbVar1->required_sec_level = pbVar1->sec_level;
  }
  bit = 0xb;
  if (pbVar1->role != '\0') {
    bit = 1;
  }
  atomic_set_bit(&smp->allowed_cmds,bit);
  return;
}



void smp_pairing_complete(bt_smp *smp,u8_t status)

{
  bool bVar1;
  uint uVar2;
  int iVar3;
  undefined3 in_register_0000202d;
  uint uVar4;
  anon_subr_void_bt_conn_ptr__Bool_for_pairing_complete *paVar5;
  
  if (CONCAT31(in_register_0000202d,status) == 0) {
    iVar3 = atomic_test_bit(smp->flags,0xc);
    if (bt_auth == (bt_conn_auth_cb *)0x0) goto LAB_23020a2a;
    paVar5 = bt_auth->pairing_complete;
    bVar1 = iVar3 != 0;
  }
  else {
    uVar4 = CONCAT31(in_register_0000202d,status) - 1U & 0xff;
    uVar2 = 8;
    if (uVar4 < 0xe) {
      uVar2 = (uint)(byte)CSWTCH_108[uVar4];
    }
    bVar1 = (bool)SUB41(uVar2,0);
    iVar3 = atomic_test_bit(smp->flags,2);
    if (iVar3 == 0) {
      bt_conn_security_changed((smp->chan).chan.conn,uVar2);
    }
    if (bt_auth == (bt_conn_auth_cb *)0x0) goto LAB_23020a2a;
    paVar5 = (anon_subr_void_bt_conn_ptr__Bool_for_pairing_complete *)bt_auth->pairing_failed;
  }
  if (paVar5 != (anon_subr_void_bt_conn_ptr__Bool_for_pairing_complete *)0x0) {
    (*paVar5)((smp->chan).chan.conn,(_Bool)bVar1);
  }
LAB_23020a2a:
  smp_reset(smp);
  return;
}



// WARNING: Variable defined which should be unmapped: sched

int bt_smp_aes_cmac(u8_t *key,u8_t *in,size_t len,u8_t *out)

{
  int iVar1;
  undefined auStack280 [4];
  tc_cmac_struct state;
  tc_aes_key_sched_struct sched;
  
  iVar1 = tc_cmac_setup((TCCmacState_t)auStack280,key,(TCAesKeySched_t)((int)&state.countdown + 4));
  if (((iVar1 != 0) && (iVar1 = tc_cmac_update((TCCmacState_t)auStack280,in,len), iVar1 != 0)) &&
     (iVar1 = tc_cmac_final(out,(TCCmacState_t)auStack280), iVar1 != 0)) {
    return 0;
  }
  return -5;
}



int smp_sign_buf(u8_t *key,u8_t *msg,u16_t len)

{
  size_t length;
  int iVar1;
  undefined2 in_register_00002032;
  undefined4 uStack68;
  u32_t_conflict cnt;
  u8_t key_s [16];
  u8_t tmp [16];
  
  length = CONCAT22(in_register_00002032,len) + 4;
  uStack68 = *(undefined4 *)(msg + CONCAT22(in_register_00002032,len));
  sys_mem_swap(msg,length);
  sys_memcpy_swap(&cnt,key,0x10);
  iVar1 = bt_smp_aes_cmac((u8_t *)&cnt,msg,length,key_s + 0xc);
  if (iVar1 == 0) {
    sys_mem_swap(key_s + 0xc,0x10);
    memcpy(tmp,&uStack68,4);
    sys_mem_swap(msg,length);
    memcpy(msg + CONCAT22(in_register_00002032,len),tmp,0xc);
  }
  else {
    printf("Data signing failed\r\n");
  }
  return iVar1;
}



// WARNING: Variable defined which should be unmapped: m

int smp_f4(u8_t *u,u8_t *v,u8_t *x,u8_t z,u8_t *res)

{
  int iVar1;
  u8_t auStack100 [4];
  u8_t xs [16];
  u8_t m [65];
  
  sys_memcpy_swap(xs + 0xc,u,0x20);
  sys_memcpy_swap(m + 0x1c,v,0x20);
  m[60] = z;
  sys_memcpy_swap(auStack100,x,0x10);
  iVar1 = bt_smp_aes_cmac(auStack100,xs + 0xc,0x41,res);
  if (iVar1 == 0) {
    sys_mem_swap(res,0x10);
  }
  return iVar1;
}



u8_t sc_smp_check_confirm(bt_smp *smp)

{
  int iVar1;
  byte z;
  u8_t uVar2;
  u8_t auStack32 [4];
  u8_t cfm [16];
  
  switch(smp->method) {
  case '\0':
  case '\x03':
    z = 0;
    break;
  case '\x01':
  case '\x02':
    z = (byte)(smp->passkey >> ((uint)smp->passkey_round & 0x1f)) & 1 | 0x80;
    break;
  default:
    return '\b';
  case '\x05':
    return '\0';
  }
  iVar1 = smp_f4(smp->pkey,sc_public_key,smp->rrnd,z,auStack32);
  uVar2 = '\b';
  if (iVar1 == 0) {
    iVar1 = memcmp(smp->pcnf,auStack32,0x10);
    uVar2 = (iVar1 != 0) << 2;
  }
  return uVar2;
}



// WARNING: Could not reconcile some variable overlaps

int smp_f5(u8_t *w,u8_t *n1,u8_t *n2,bt_addr_le_t *a1,bt_addr_le_t *a2,u8_t *mackey,u8_t *ltk)

{
  u8_t salt [16];
  int iVar1;
  u8_t auStack152 [4];
  u8_t t [16];
  u8_t ws [32];
  u8_t m [53];
  
  memset(ws + 0x1c,0,0x35);
  ws[29] = 'b';
  ws._30_2_ = 0x6c74;
  m[0] = 'e';
  m[47] = '\x01';
  sys_memcpy_swap(t + 0xc,w,0x20);
  iVar1 = bt_smp_aes_cmac((u8_t *)&ram0x230757f0,t + 0xc,0x20,auStack152);
  if (iVar1 == 0) {
    sys_memcpy_swap(m + 1,n1,0x10);
    sys_memcpy_swap(m + 0x11,n2,0x10);
    m[33] = a1->type;
    sys_memcpy_swap(m + 0x22,&a1->a,6);
    m[40] = a2->type;
    sys_memcpy_swap(m + 0x29,&a2->a,6);
    iVar1 = bt_smp_aes_cmac(auStack152,ws + 0x1c,0x35,mackey);
    if (iVar1 == 0) {
      sys_mem_swap(mackey,0x10);
      ws[28] = '\x01';
      iVar1 = bt_smp_aes_cmac(auStack152,ws + 0x1c,0x35,ltk);
      if (iVar1 == 0) {
        sys_mem_swap(ltk,0x10);
      }
    }
  }
  return iVar1;
}



// WARNING: Variable defined which should be unmapped: m

int smp_f6(u8_t *w,u8_t *n1,u8_t *n2,u8_t *r,u8_t *iocap,bt_addr_le_t *a1,bt_addr_le_t *a2,
          u8_t *check)

{
  int iVar1;
  u8_t auStack100 [4];
  u8_t ws [16];
  u8_t m [65];
  
  sys_memcpy_swap(ws + 0xc,n1,0x10);
  sys_memcpy_swap(m + 0xc,n2,0x10);
  sys_memcpy_swap(m + 0x1c,r,0x10);
  sys_memcpy_swap(m + 0x2c,iocap,3);
  m[47] = a1->type;
  memcpy(m + 0x30,&a1->a,6);
  sys_memcpy_swap(m + 0x30,&a1->a,6);
  m[54] = a2->type;
  memcpy(m + 0x37,&a2->a,6);
  sys_memcpy_swap(m + 0x37,&a2->a,6);
  sys_memcpy_swap(auStack100,w,0x10);
  iVar1 = bt_smp_aes_cmac(auStack100,ws + 0xc,0x41,check);
  if (iVar1 == 0) {
    sys_mem_swap(check,0x10);
  }
  return iVar1;
}



// WARNING: Variable defined which should be unmapped: m

int smp_g2(u8_t *u,u8_t *v,u8_t *x,u8_t *y,u32_t_conflict *passkey)

{
  int iVar1;
  uint uVar2;
  u8_t auStack112 [4];
  u8_t xs [16];
  u8_t m [80];
  
  sys_memcpy_swap(xs + 0xc,u,0x20);
  sys_memcpy_swap(m + 0x1c,v,0x20);
  sys_memcpy_swap(m + 0x3c,y,0x10);
  sys_memcpy_swap(auStack112,x,0x10);
  iVar1 = bt_smp_aes_cmac(auStack112,xs + 0xc,0x50,auStack112);
  if (iVar1 == 0) {
    memcpy(passkey,xs + 8,4);
    uVar2 = *passkey;
    *passkey = (uVar2 >> 0x18 | uVar2 << 0x18 | uVar2 >> 8 & 0xff00 | (uVar2 & 0xff00) << 8) %
               1000000;
  }
  return iVar1;
}



int atomic_test_and_clear_bit(atomic_t *target,int bit)

{
  uint uVar1;
  uint uVar2;
  
  uVar1 = 1 << (bit & 0x1fU);
  uVar2 = atomic_and(target + ((uint)bit >> 5),~uVar1);
  return (uint)((uVar2 & uVar1) != 0);
}



u8_t display_passkey(bt_smp *smp)

{
  u8_t uVar1;
  int iVar2;
  
  iVar2 = bt_rand(&smp->passkey,4);
  uVar1 = '\b';
  if (iVar2 == 0) {
    smp->passkey_round = '\0';
    uVar1 = '\0';
    smp->passkey = smp->passkey % 1000000;
    if ((bt_auth != (bt_conn_auth_cb *)0x0) &&
       (bt_auth->passkey_display != (anon_subr_void_bt_conn_ptr_uint_for_passkey_display *)0x0)) {
      atomic_set_bit(smp->flags,10);
      (*bt_auth->passkey_display)((smp->chan).chan.conn,smp->passkey);
    }
  }
  return uVar1;
}



// WARNING: Type propagation algorithm not settling

_Bool update_keys_check(bt_smp *smp)

{
  bt_conn *pbVar1;
  bt_keys *pbVar2;
  int iVar3;
  byte bVar4;
  
  pbVar1 = (smp->chan).chan.conn;
  if (*(int *)(pbVar1->field_20 + 0x2c) == 0) {
    pbVar2 = bt_keys_get_addr(pbVar1->id,(bt_addr_le_t *)pbVar1->field_20);
    *(bt_keys **)(pbVar1->field_20 + 0x2c) = pbVar2;
  }
  iVar3 = *(int *)(pbVar1->field_20 + 0x2c);
  if ((iVar3 != 0) && ((*(ushort *)(iVar3 + 10) & 0x24) != 0)) {
    bVar4 = smp->prsp[4];
    if (smp->preq[4] < smp->prsp[4]) {
      bVar4 = smp->preq[4];
    }
    if ((bVar4 < *(byte *)(iVar3 + 8)) ||
       (((*(ushort *)(iVar3 + 10) & 0x20) != 0 &&
        (iVar3 = atomic_test_bit(smp->flags,5), iVar3 == 0)))) {
      return false;
    }
    if ((*(byte *)(*(int *)(pbVar1->field_20 + 0x2c) + 9) & 1) != 0) {
      return (_Bool)(smp->method != '\0');
    }
  }
  return true;
}



u8_t smp_pairing_failed(bt_smp *smp,net_buf *buf)

{
  atomic_t *target;
  int iVar1;
  bt_keys *keys;
  byte *pbVar2;
  bt_conn *pbVar3;
  
  pbVar2 = *(byte **)&buf->field_4;
  pbVar3 = (smp->chan).chan.conn;
  printf("reason 0x%x\r\n",(uint)*pbVar2);
  target = smp->flags;
  iVar1 = atomic_test_and_clear_bit(target,9);
  if ((((iVar1 != 0) || (iVar1 = atomic_test_and_clear_bit(target,10), iVar1 != 0)) &&
      (bt_auth != (bt_conn_auth_cb *)0x0)) &&
     (bt_auth->cancel != (anon_subr_void_bt_conn_ptr_for_cancel *)0x0)) {
    (*bt_auth->cancel)(pbVar3);
  }
  iVar1 = atomic_test_bit(target,2);
  if ((iVar1 != 0) &&
     (keys = *(bt_keys **)(((smp->chan).chan.conn)->field_20 + 0x2c), keys != (bt_keys *)0x0)) {
    bt_keys_clear(keys);
  }
  smp_pairing_complete(smp,*pbVar2);
  return '\0';
}



void smp_timeout(k_work *work)

{
  int iVar1;
  bt_keys *keys;
  
  printf("SMP Timeout\r\n");
  iVar1 = atomic_test_bit(work[-0x14].flags,2);
  if ((iVar1 != 0) && (keys = *(bt_keys **)(work[-0x21].flags[0] + 0x9c), keys != (bt_keys *)0x0)) {
    bt_keys_clear(keys);
  }
  atomic_set_bit(work[-0x14].flags,4);
  smp_pairing_complete((bt_smp *)work[-0x21].flags,'\b');
  return;
}



u8_t smp_ident_info(bt_smp *smp,net_buf *buf)

{
  bt_addr_le_t *addr;
  int iVar1;
  bt_keys *pbVar2;
  char *pcVar3;
  bt_conn *pbVar4;
  void *__src;
  
  iVar1 = atomic_test_bit(smp->flags,0xc);
  if (iVar1 != 0) {
    pbVar4 = (smp->chan).chan.conn;
    __src = *(void **)&buf->field_4;
    addr = (bt_addr_le_t *)pbVar4->field_20;
    pbVar2 = bt_keys_get_type(2,pbVar4->id,addr);
    if (pbVar2 == (bt_keys *)0x0) {
      pcVar3 = bt_addr_le_str_real(addr);
      printf("Unable to get keys for %s\r\n",pcVar3);
      return '\b';
    }
    memcpy(&pbVar2->irk,__src,0x10);
  }
  atomic_set_bit(&smp->allowed_cmds,9);
  return '\0';
}



u8_t smp_encrypt_info(bt_smp *smp,net_buf *buf)

{
  bt_addr_le_t *addr;
  int iVar1;
  bt_keys *pbVar2;
  char *pcVar3;
  bt_conn *pbVar4;
  void *__src;
  
  iVar1 = atomic_test_bit(smp->flags,0xc);
  if (iVar1 != 0) {
    pbVar4 = (smp->chan).chan.conn;
    __src = *(void **)&buf->field_4;
    addr = (bt_addr_le_t *)pbVar4->field_20;
    pbVar2 = bt_keys_get_type(4,pbVar4->id,addr);
    if (pbVar2 == (bt_keys *)0x0) {
      pcVar3 = bt_addr_le_str_real(addr);
      printf("Unable to get keys for %s\r\n",pcVar3);
      return '\b';
    }
    memcpy((pbVar2->ltk).val,__src,0x10);
  }
  atomic_set_bit(&smp->allowed_cmds,7);
  return '\0';
}



// WARNING: Variable defined which should be unmapped: passkey

u8_t legacy_request_tk(bt_smp *smp)

{
  bt_conn *pbVar1;
  bt_keys *pbVar2;
  int iVar3;
  u8_t uVar4;
  uint uStack20;
  u32_t_conflict passkey;
  
  pbVar1 = (smp->chan).chan.conn;
  pbVar2 = bt_keys_find_addr(pbVar1->id,(bt_addr_le_t *)pbVar1->field_20);
  uVar4 = smp->method;
  if (((pbVar2 == (bt_keys *)0x0) || ((pbVar2->flags & 1) == 0)) || (uVar4 != '\0')) {
    if (uVar4 == '\x01') {
      atomic_set_bit(smp->flags,9);
      (*bt_auth->passkey_entry)(pbVar1);
    }
    else {
      if (uVar4 == '\0') {
        return '\0';
      }
      if (uVar4 != '\x02') {
        printf("Unknown pairing method (%u)\r\n");
        goto LAB_230211a0;
      }
      iVar3 = bt_rand(&uStack20,4);
      if (iVar3 != 0) {
        return '\b';
      }
      uStack20 = uStack20 % 1000000;
      if ((bt_auth != (bt_conn_auth_cb *)0x0) &&
         (bt_auth->passkey_display != (anon_subr_void_bt_conn_ptr_uint_for_passkey_display *)0x0)) {
        atomic_set_bit(smp->flags,10);
        (*bt_auth->passkey_display)(pbVar1,uStack20);
      }
      smp->tk[0] = (u8_t)uStack20;
      smp->tk[2] = (u8_t)(uStack20 >> 0x10);
      smp->tk[1] = (u8_t)(uStack20 >> 8);
      smp->tk[3] = (u8_t)(uStack20 >> 0x18);
    }
    uVar4 = '\0';
  }
  else {
    printf("JustWorks failed, authenticated keys present\r\n");
LAB_230211a0:
    uVar4 = '\b';
  }
  return uVar4;
}



void bt_smp_disconnected(bt_l2cap_chan *chan)

{
  bt_keys *keys;
  
  keys = *(bt_keys **)(chan->conn->field_20 + 0x2c);
  k_delayed_work_cancel((k_delayed_work *)&chan[6].ops);
  if (chan[6].rtx_work.work.handler != (k_work_handler_t *)0x0) {
    k_delayed_work_del_timer((k_delayed_work *)&chan[6].ops);
  }
  if ((chan->rtx_work).timer.timer.hdl != (void *)0x0) {
    k_delayed_work_del_timer(&chan->rtx_work);
  }
  if ((keys != (bt_keys *)0x0) && ((keys->keys == 0 || ((keys->flags & 2) != 0)))) {
    bt_keys_clear(keys);
  }
  memset(chan,0,0x1a8);
  return;
}



void bt_smp_connected(bt_l2cap_chan *chan)

{
  k_delayed_work_init((k_delayed_work *)&chan[6].ops,smp_timeout);
  smp_reset((bt_smp *)chan);
  return;
}



u8_t get_auth(u8_t auth)

{
  u8_t uVar1;
  byte bVar2;
  undefined3 in_register_00002029;
  undefined3 extraout_var;
  byte in_a1;
  byte bVar3;
  
  bVar2 = in_a1 & 0xf;
  if (sc_supported == false) {
    bVar2 = in_a1 & 7;
  }
  uVar1 = get_io_capa();
  if ((CONCAT31(extraout_var,uVar1) == 3) ||
     (bVar3 = bVar2 | 4, *(byte *)CONCAT31(in_register_00002029,auth) < 3)) {
    bVar3 = bVar2 & 0xb;
  }
  bVar2 = bVar3 & 0xfe;
  if (bondable != false) {
    bVar2 = bVar3 | 1;
  }
  return (u8_t)bVar2;
}



_Bool sec_level_reachable(void)

{
  u8_t uVar1;
  uint in_a0;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  _Bool _Var2;
  
  if (in_a0 == 3) {
    uVar1 = get_io_capa();
    _Var2 = true;
    if (((CONCAT31(extraout_var_00,uVar1) == 3) &&
        (_Var2 = false, bt_auth != (bt_conn_auth_cb *)0x0)) &&
       (bt_auth->oob_data_request !=
        (anon_subr_void_bt_conn_ptr_bt_conn_oob_info_ptr_for_oob_data_request *)0x0)) {
      _Var2 = oobd_present;
    }
    return (_Bool)(_Var2 & 1);
  }
  if (3 < in_a0) {
    if (in_a0 == 4) {
      uVar1 = get_io_capa();
      if ((CONCAT31(extraout_var,uVar1) != 3) ||
         (((_Var2 = false, bt_auth != (bt_conn_auth_cb *)0x0 &&
           (bt_auth->oob_data_request !=
            (anon_subr_void_bt_conn_ptr_bt_conn_oob_info_ptr_for_oob_data_request *)0x0)) &&
          (oobd_present != false)))) {
        _Var2 = sc_supported;
      }
      return (_Bool)(_Var2 & 1);
    }
    return false;
  }
  return (_Bool)(in_a0 != 0);
}



int bt_smp_accept(bt_conn *conn,bt_l2cap_chan **chan)

{
  int iVar1;
  
  if (bt_smp_pool[0].chan.chan.conn == (bt_conn *)0x0) {
    iVar1 = 0;
  }
  else {
    if (bt_smp_pool[1].chan.chan.conn != (bt_conn *)0x0) {
      printf("No available SMP context for conn %p\r\n",conn);
      return -0xc;
    }
    iVar1 = 1;
  }
  bt_smp_pool[iVar1].chan.chan.ops = (bt_l2cap_chan_ops *)0x4200d49c;
  *(bt_smp **)chan = bt_smp_pool + iVar1;
  return 0;
}



_Bool smp_keys_check(bt_conn *conn)

{
  byte bVar1;
  bt_keys *pbVar2;
  int iVar3;
  
  if (*(int *)(conn->field_20 + 0x2c) == 0) {
    pbVar2 = bt_keys_find(0x20,conn->id,(bt_addr_le_t *)conn->field_20);
    *(bt_keys **)(conn->field_20 + 0x2c) = pbVar2;
    if (pbVar2 == (bt_keys *)0x0) {
      pbVar2 = bt_keys_find(4,conn->id,(bt_addr_le_t *)conn->field_20);
      *(bt_keys **)(conn->field_20 + 0x2c) = pbVar2;
    }
  }
  iVar3 = *(int *)(conn->field_20 + 0x2c);
  bVar1 = 0;
  if (((iVar3 != 0) && ((*(ushort *)(iVar3 + 10) & 0x24) != 0)) &&
     (bVar1 = 1, 2 < (byte)conn->required_sec_level)) {
    bVar1 = *(byte *)(iVar3 + 9) & 1;
  }
  return (_Bool)bVar1;
}



u8_t get_pair_method(bt_smp *smp,u8_t remote_io)

{
  byte bVar1;
  byte bVar2;
  u8_t uVar3;
  int iVar4;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 in_register_0000202d;
  uint uVar5;
  
  uVar5 = CONCAT31(in_register_0000202d,remote_io);
  iVar4 = atomic_test_bit(smp->flags,5);
  bVar2 = (byte)iVar4;
  if (iVar4 == 0) {
    if ((uVar5 < 5) && (bVar1 = smp->preq[3] | smp->prsp[3], bVar2 = bVar1 & 4, (bVar1 & 4) != 0)) {
      uVar3 = get_io_capa();
      bVar2 = ""[CONCAT31(extraout_var,uVar3) + uVar5 * 5];
      if (bVar2 == 4) {
        bVar2 = (((smp->chan).chan.conn)->role == '\0') + 1;
      }
    }
  }
  else {
    if (((((smp->preq[3] & smp->prsp[3] & 8) == 0) ||
         (bVar2 = 5, ((smp->preq[2] | smp->prsp[2]) & 1) == 0)) && (bVar2 = 0, uVar5 < 5)) &&
       (bVar1 = smp->preq[3] | smp->prsp[3], bVar2 = bVar1 & 4, (bVar1 & 4) != 0)) {
      uVar3 = get_io_capa();
      bVar2 = ""[CONCAT31(extraout_var_00,uVar3) + uVar5 * 5];
    }
  }
  return (u8_t)bVar2;
}



net_buf * smp_create_pdu(bt_smp *smp,u8_t op)

{
  int iVar1;
  net_buf *pnVar2;
  u8_t *puVar3;
  s32_t timeout;
  
  iVar1 = atomic_test_bit(smp->flags,4);
  timeout = 0;
  if (iVar1 == 0) {
    timeout = 30000;
  }
  pnVar2 = bt_l2cap_create_pdu_timeout((net_buf_pool *)0x0,0,timeout);
  if (pnVar2 == (net_buf *)0x0) {
    atomic_set_bit(smp->flags,4);
  }
  else {
    puVar3 = (u8_t *)net_buf_simple_add((net_buf_simple *)&pnVar2->field_4,1);
    *puVar3 = op;
  }
  return pnVar2;
}



void smp_send(bt_smp *smp,net_buf *buf,bt_conn_tx_cb_t *cb)

{
  bt_l2cap_send_cb((smp->chan).chan.conn,6,buf,cb,(void *)0x0);
  k_delayed_work_submit(&smp->work,30000);
  return;
}



u8_t sc_smp_send_dhkey_check(bt_smp *smp,u8_t *e)

{
  u8_t uVar1;
  net_buf *buf;
  void *__dest;
  
  buf = smp_create_pdu(smp,'\r');
  if (buf == (net_buf *)0x0) {
    uVar1 = '\b';
  }
  else {
    __dest = net_buf_simple_add((net_buf_simple *)&buf->field_4,0x10);
    memcpy(__dest,e,0x10);
    smp_send(smp,buf,(bt_conn_tx_cb_t *)0x0);
    uVar1 = '\0';
  }
  return uVar1;
}



u8_t compute_and_send_master_dhcheck(bt_smp *smp)

{
  u8_t uVar1;
  int iVar2;
  bt_le_oob_sc_data *__src;
  size_t __n;
  bt_conn *pbVar3;
  u8_t auStack64 [4];
  u8_t e [16];
  u8_t r [16];
  
  memset(e + 0xc,0,0x10);
  switch(smp->method) {
  case '\0':
  case '\x03':
    break;
  case '\x01':
  case '\x02':
    __n = 4;
    __src = (bt_le_oob_sc_data *)&smp->passkey;
LAB_230215fe:
    memcpy(e + 0xc,__src,__n);
    break;
  default:
    goto switchD_230215f6_caseD_4;
  case '\x05':
    __src = smp->oobd_remote;
    if (__src != (bt_le_oob_sc_data *)0x0) {
      __n = 0x10;
      goto LAB_230215fe;
    }
  }
  pbVar3 = (smp->chan).chan.conn;
  iVar2 = smp_f5(smp->dhkey,smp->prnd,smp->rrnd,(bt_addr_le_t *)(pbVar3->field_20 + 7),
                 (bt_addr_le_t *)(pbVar3->field_20 + 0xe),smp->mackey,smp->tk);
  if ((iVar2 == 0) &&
     (pbVar3 = (smp->chan).chan.conn,
     iVar2 = smp_f6(smp->mackey,smp->prnd,smp->rrnd,e + 0xc,smp->preq + 1,
                    (bt_addr_le_t *)(pbVar3->field_20 + 7),(bt_addr_le_t *)(pbVar3->field_20 + 0xe),
                    auStack64), iVar2 == 0)) {
    atomic_set_bit(&smp->allowed_cmds,0xd);
    uVar1 = sc_smp_send_dhkey_check(smp,auStack64);
  }
  else {
switchD_230215f6_caseD_4:
    uVar1 = '\b';
  }
  return uVar1;
}



// WARNING: Type propagation algorithm not settling

u8_t compute_and_check_and_send_slave_dhcheck(bt_smp *smp)

{
  u8_t *mackey;
  u8_t uVar1;
  int iVar2;
  undefined3 extraout_var;
  bt_le_oob_sc_data *__src;
  size_t __n;
  bt_conn *pbVar3;
  u8_t *n1;
  u8_t *n2;
  u8_t auStack80 [4];
  u8_t re [16];
  u8_t e [16];
  u8_t r [16];
  
  memset(e + 0xc,0,0x10);
  switch(smp->method) {
  case '\0':
  case '\x03':
    break;
  case '\x01':
  case '\x02':
    __n = 4;
    __src = (bt_le_oob_sc_data *)&smp->passkey;
LAB_230216b2:
    memcpy(e + 0xc,__src,__n);
    break;
  default:
    goto LAB_2302176c;
  case '\x05':
    __src = smp->oobd_remote;
    if (__src != (bt_le_oob_sc_data *)0x0) {
      __n = 0x10;
      goto LAB_230216b2;
    }
  }
  pbVar3 = (smp->chan).chan.conn;
  n1 = smp->rrnd;
  n2 = smp->prnd;
  mackey = smp->mackey;
  iVar2 = smp_f5(smp->dhkey,n1,n2,(bt_addr_le_t *)(pbVar3->field_20 + 7),
                 (bt_addr_le_t *)(pbVar3->field_20 + 0xe),mackey,smp->tk);
  if ((iVar2 == 0) &&
     (pbVar3 = (smp->chan).chan.conn,
     iVar2 = smp_f6(mackey,n2,n1,e + 0xc,smp->prsp + 1,(bt_addr_le_t *)(pbVar3->field_20 + 0xe),
                    (bt_addr_le_t *)(pbVar3->field_20 + 7),re + 0xc), iVar2 == 0)) {
    if (smp->method == '\x05') {
      if (smp->oobd_local == (bt_le_oob_sc_data *)0x0) {
        memset(e + 0xc,0,0x10);
      }
      else {
        memcpy(e + 0xc,smp->oobd_local,0x10);
      }
    }
    pbVar3 = (smp->chan).chan.conn;
    iVar2 = smp_f6(mackey,n1,n2,e + 0xc,smp->preq + 1,(bt_addr_le_t *)(pbVar3->field_20 + 7),
                   (bt_addr_le_t *)(pbVar3->field_20 + 0xe),auStack80);
    if (iVar2 == 0) {
      iVar2 = memcmp(smp->e,auStack80,0x10);
      if (iVar2 != 0) {
        return '\v';
      }
      uVar1 = sc_smp_send_dhkey_check(smp,re + 0xc);
      if (CONCAT31(extraout_var,uVar1) != 0) {
        return uVar1;
      }
      atomic_set_bit(smp->flags,1);
      return uVar1;
    }
  }
LAB_2302176c:
  return '\b';
}



// WARNING: Variable defined which should be unmapped: r
// WARNING: Type propagation algorithm not settling

u8_t smp_dhkey_check(bt_smp *smp,net_buf *buf)

{
  atomic_t *target;
  u8_t uVar1;
  int iVar2;
  bt_le_oob_sc_data *__src;
  size_t __n;
  uint len;
  bt_conn *pbVar3;
  void *__src_00;
  u8_t auStack60 [4];
  u8_t ediv [2];
  u8_t rand [8];
  u8_t e [16];
  u8_t r [16];
  
  __src_00 = *(void **)&buf->field_4;
  uVar1 = ((smp->chan).chan.conn)->role;
  if (uVar1 != '\0') {
    if (uVar1 == '\x01') {
      target = smp->flags;
      atomic_and(target,-0x8001);
      memcpy(smp->e,__src_00,0x10);
      iVar2 = atomic_test_bit(target,7);
      if ((iVar2 == 0) && (iVar2 = atomic_test_bit(target,9), iVar2 == 0)) {
        uVar1 = compute_and_check_and_send_slave_dhcheck(smp);
        return uVar1;
      }
      atomic_set_bit(target,8);
    }
    return '\0';
  }
  memset(e + 0xc,0,0x10);
  switch(smp->method) {
  case '\0':
  case '\x03':
    break;
  case '\x01':
  case '\x02':
    __n = 4;
    __src = (bt_le_oob_sc_data *)&smp->passkey;
LAB_230217c8:
    memcpy(e + 0xc,__src,__n);
    break;
  default:
    goto LAB_23021854;
  case '\x05':
    __src = smp->oobd_local;
    if (__src != (bt_le_oob_sc_data *)0x0) {
      __n = 0x10;
      goto LAB_230217c8;
    }
  }
  pbVar3 = (smp->chan).chan.conn;
  iVar2 = smp_f6(smp->mackey,smp->rrnd,smp->prnd,e + 0xc,smp->prsp + 1,
                 (bt_addr_le_t *)(pbVar3->field_20 + 0xe),(bt_addr_le_t *)(pbVar3->field_20 + 7),
                 rand + 4);
  if (iVar2 == 0) {
    iVar2 = memcmp(rand + 4,__src_00,0x10);
    if (iVar2 != 0) {
      return '\v';
    }
    len = (uint)smp->prsp[4];
    if ((uint)smp->preq[4] < (uint)smp->prsp[4]) {
      len = (uint)smp->preq[4];
    }
    memset(auStack60,0,2);
    memset(ediv,0,8);
    iVar2 = bt_conn_le_start_encryption((smp->chan).chan.conn,ediv,auStack60,smp->tk,len);
    if (-1 < iVar2) {
      atomic_set_bit(smp->flags,1);
      return 0;
    }
  }
LAB_23021854:
  return '\b';
}



u8_t smp_send_pairing_random(bt_smp *smp)

{
  u8_t uVar1;
  net_buf *buf;
  void *__dest;
  
  buf = smp_create_pdu(smp,'\x04');
  if (buf == (net_buf *)0x0) {
    uVar1 = '\b';
  }
  else {
    __dest = net_buf_simple_add((net_buf_simple *)&buf->field_4,0x10);
    memcpy(__dest,smp->prnd,0x10);
    smp_send(smp,buf,(bt_conn_tx_cb_t *)0x0);
    uVar1 = '\0';
  }
  return uVar1;
}



u8_t sc_send_public_key(bt_smp *smp)

{
  u8_t uVar1;
  net_buf *buf;
  void *__dest;
  
  buf = smp_create_pdu(smp,'\f');
  if (buf == (net_buf *)0x0) {
    uVar1 = '\b';
  }
  else {
    __dest = net_buf_simple_add((net_buf_simple *)&buf->field_4,0x40);
    memcpy(__dest,sc_public_key,0x20);
    memcpy((void *)((int)__dest + 0x20),sc_public_key + 0x20,0x20);
    smp_send(smp,buf,(bt_conn_tx_cb_t *)0x0);
    uVar1 = '\0';
  }
  return uVar1;
}



u8_t send_pairing_rsp(bt_smp *smp)

{
  u8_t uVar1;
  net_buf *buf;
  void *__dest;
  
  buf = smp_create_pdu(smp,'\x02');
  if (buf == (net_buf *)0x0) {
    uVar1 = '\b';
  }
  else {
    __dest = net_buf_simple_add((net_buf_simple *)&buf->field_4,6);
    memcpy(__dest,smp->prsp + 1,6);
    smp_send(smp,buf,(bt_conn_tx_cb_t *)0x0);
    uVar1 = '\0';
  }
  return uVar1;
}



// WARNING: Type propagation algorithm not settling

u8_t bt_smp_distribute_keys(bt_smp *smp)

{
  byte bVar1;
  bt_keys *keys;
  bt_conn *pbVar2;
  char *fmt;
  int iVar3;
  net_buf *buf;
  void *__dest;
  bt_keys *keys_00;
  atomic_t *target;
  undefined auStack60 [4];
  anon_struct_for_rand rand;
  
  pbVar2 = (smp->chan).chan.conn;
  keys_00 = *(bt_keys **)(pbVar2->field_20 + 0x2c);
  if (keys_00 == (bt_keys *)0x0) {
    fmt = bt_addr_le_str_real((bt_addr_le_t *)pbVar2->field_20);
    printf("No keys space for %s\r\n",fmt);
    return '\b';
  }
  target = smp->flags;
  iVar3 = atomic_test_bit(target,5);
  if ((iVar3 == 0) && ((smp->local_dist & 1) != 0)) {
    keys = *(bt_keys **)(((smp->chan).chan.conn)->field_20 + 0x2c);
    bt_rand(auStack60,0x1a);
    buf = smp_create_pdu(smp,'\x06');
    if (buf == (net_buf *)0x0) {
      fmt = "Unable to allocate Encrypt Info buffer\r\n";
    }
    else {
      __dest = net_buf_simple_add((net_buf_simple *)&buf->field_4,0x10);
      memcpy(__dest,auStack60,(uint)keys->enc_size);
      bVar1 = keys->enc_size;
      if (bVar1 < 0x10) {
        memset((void *)((uint)bVar1 + (int)__dest),0,0x10 - (uint)bVar1);
      }
      smp_send(smp,buf,(bt_conn_tx_cb_t *)0x0);
      buf = smp_create_pdu(smp,'\a');
      if (buf != (net_buf *)0x0) {
        __dest = net_buf_simple_add((net_buf_simple *)&buf->field_4,10);
        memcpy((void *)((int)__dest + 2),rand.key + 0xc,8);
        memcpy(__dest,rand.rand + 4,2);
        smp_send(smp,buf,smp_ident_sent);
        iVar3 = atomic_test_bit(target,0xc);
        if (iVar3 != 0) {
          bt_keys_add_type(keys,1);
          memcpy((keys->slave_ltk).val,auStack60,0x10);
          memcpy(&keys->slave_ltk,rand.key + 0xc,8);
          memcpy((keys->slave_ltk).ediv,rand.rand + 4,2);
        }
        goto LAB_23021a18;
      }
      fmt = "Unable to allocate Master Ident buffer\r\n";
    }
    printf(fmt);
  }
LAB_23021a18:
  if ((smp->local_dist & 4) == 0) {
    return smp->local_dist & 4;
  }
  buf = smp_create_pdu(smp,'\n');
  if (buf == (net_buf *)0x0) {
    printf("Unable to allocate Signing Info buffer\r\n");
    return '\b';
  }
  __dest = net_buf_simple_add((net_buf_simple *)&buf->field_4,0x10);
  bt_rand(__dest,0x10);
  iVar3 = atomic_test_bit(target,0xc);
  if (iVar3 != 0) {
    bt_keys_add_type(keys_00,8);
    memcpy(&keys_00->local_csrk,__dest,0x10);
    (keys_00->local_csrk).cnt = 0;
  }
  smp_send(smp,buf,smp_sign_info_sent);
  return '\0';
}



u8_t smp_signing_info(bt_smp *smp,net_buf *buf)

{
  bt_conn *pbVar1;
  u8_t uVar2;
  int iVar3;
  bt_keys *pbVar4;
  char *pcVar5;
  undefined3 extraout_var;
  byte bVar6;
  void *__src;
  
  pbVar1 = (smp->chan).chan.conn;
  iVar3 = atomic_test_bit(smp->flags,0xc);
  if (iVar3 != 0) {
    __src = *(void **)&buf->field_4;
    pbVar4 = bt_keys_get_type(0x10,pbVar1->id,(bt_addr_le_t *)pbVar1->field_20);
    if (pbVar4 == (bt_keys *)0x0) {
      pcVar5 = bt_addr_le_str_real((bt_addr_le_t *)pbVar1->field_20);
      printf("Unable to get keys for %s\r\n",pcVar5);
      return '\b';
    }
    memcpy(&pbVar4->remote_csrk,__src,0x10);
  }
  bVar6 = smp->remote_dist & 0xfb;
  smp->remote_dist = bVar6;
  if (((bVar6 | pbVar1->role) != 0) ||
     (uVar2 = bt_smp_distribute_keys(smp), CONCAT31(extraout_var,uVar2) == 0)) {
    if (*(short *)&smp->local_dist == 0) {
      smp_pairing_complete(smp,'\0');
    }
    uVar2 = '\0';
  }
  return uVar2;
}



u8_t smp_master_ident(bt_smp *smp,net_buf *buf)

{
  bt_conn *pbVar1;
  u8_t uVar2;
  int bit;
  bt_keys *pbVar3;
  char *pcVar4;
  undefined3 extraout_var;
  void *__src;
  
  pbVar1 = (smp->chan).chan.conn;
  bit = atomic_test_bit(smp->flags,0xc);
  if (bit != 0) {
    __src = *(void **)&buf->field_4;
    pbVar3 = bt_keys_get_type(4,pbVar1->id,(bt_addr_le_t *)pbVar1->field_20);
    if (pbVar3 == (bt_keys *)0x0) {
      pcVar4 = bt_addr_le_str_real((bt_addr_le_t *)pbVar1->field_20);
      printf("Unable to get keys for %s\r\n",pcVar4);
      return '\b';
    }
    memcpy((pbVar3->ltk).ediv,__src,2);
    memcpy(&pbVar3->ltk,(void *)((int)__src + 2),8);
    smp->remote_dist = smp->remote_dist & 0xfe;
  }
  bit = 8;
  if ((smp->remote_dist & 2) == 0) {
    if ((smp->remote_dist & 4) == 0) goto LAB_23021c60;
    bit = 10;
  }
  atomic_set_bit(&smp->allowed_cmds,bit);
LAB_23021c60:
  if (((pbVar1->role != '\0') || (smp->remote_dist != '\0')) ||
     (uVar2 = bt_smp_distribute_keys(smp), CONCAT31(extraout_var,uVar2) == 0)) {
    if (*(short *)&smp->local_dist == 0) {
      smp_pairing_complete(smp,'\0');
    }
    uVar2 = '\0';
  }
  return uVar2;
}



int smp_init(bt_smp *smp)

{
  int iVar1;
  int iVar2;
  
  memset(&smp->allowed_cmds,0,0xec);
  iVar2 = bt_rand(smp->prnd,0x10);
  iVar1 = 8;
  if (iVar2 == 0) {
    atomic_set_bit(&smp->allowed_cmds,5);
    sc_public_key = bt_pub_key_get();
    k_sem_init(&sc_local_pkey_ready,0,1);
    iVar1 = iVar2;
  }
  return iVar1;
}



int smp_send_pairing_req(bt_conn *conn)

{
  int iVar1;
  _Bool _Var2;
  u8_t uVar3;
  bt_smp *smp;
  int iVar4;
  undefined3 extraout_var;
  bt_keys *pbVar5;
  net_buf *buf;
  u8_t *__src;
  atomic_t *target;
  
  smp = smp_chan_get(conn);
  iVar1 = -0x39;
  if (smp != (bt_smp *)0x0) {
    target = smp->flags;
    iVar4 = atomic_test_bit(target,4);
    iVar1 = -5;
    if (iVar4 == 0) {
      iVar1 = atomic_test_bit(target,3);
      if ((iVar1 == 0) && (iVar1 = atomic_test_bit(target,1), iVar1 == 0)) {
        iVar1 = -0x16;
        _Var2 = sec_level_reachable();
        if (CONCAT31(extraout_var,_Var2) != 0) {
          if (*(int *)(conn->field_20 + 0x2c) == 0) {
            pbVar5 = bt_keys_get_addr(conn->id,(bt_addr_le_t *)conn->field_20);
            *(bt_keys **)(conn->field_20 + 0x2c) = pbVar5;
            if (pbVar5 == (bt_keys *)0x0) {
              return -0xc;
            }
          }
          iVar1 = smp_init(smp);
          if ((iVar1 == 0) && (buf = smp_create_pdu(smp,'\x01'), buf != (net_buf *)0x0)) {
            __src = (u8_t *)net_buf_simple_add((net_buf_simple *)&buf->field_4,6);
            uVar3 = get_auth((char)conn + '\n');
            __src[2] = uVar3;
            uVar3 = get_io_capa();
            _Var2 = oobd_present;
            *__src = uVar3;
            *(_Bool *)(__src + 1) = _Var2;
            __src[3] = '\x10';
            __src[4] = '\x05';
            __src[5] = '\a';
            *(undefined2 *)&smp->local_dist = 0x705;
            smp->preq[0] = '\x01';
            memcpy(smp->preq + 1,__src,6);
            smp_send(smp,buf,(bt_conn_tx_cb_t *)0x0);
            atomic_set_bit(&smp->allowed_cmds,2);
            atomic_set_bit(&smp->allowed_cmds,0xb);
            atomic_set_bit(target,3);
          }
          else {
            iVar1 = -0x37;
          }
        }
      }
      else {
        iVar1 = -0x10;
      }
    }
  }
  return iVar1;
}



u8_t smp_security_request(bt_smp *smp,net_buf *buf)

{
  bt_conn *conn;
  atomic_t *target;
  u8_t uVar1;
  int bit;
  bt_keys *pbVar2;
  undefined3 extraout_var;
  int iVar3;
  byte *pbVar4;
  uint uVar5;
  
  target = smp->flags;
  conn = (smp->chan).chan.conn;
  pbVar4 = *(byte **)&buf->field_4;
  bit = atomic_test_bit(target,3);
  if (bit != 0) {
    return '\0';
  }
  bit = atomic_test_bit(target,1);
  if (bit != 0) {
    return '\0';
  }
  uVar5 = (uint)*pbVar4 & 7;
  if (sc_supported != false) {
    uVar5 = (uint)*pbVar4 & 0xf;
  }
  if (*(int *)(conn->field_20 + 0x2c) == 0) {
    pbVar2 = bt_keys_find(0x20,conn->id,(bt_addr_le_t *)conn->field_20);
    *(bt_keys **)(conn->field_20 + 0x2c) = pbVar2;
    if (pbVar2 == (bt_keys *)0x0) {
      pbVar2 = bt_keys_find(4,conn->id,(bt_addr_le_t *)conn->field_20);
      *(bt_keys **)(conn->field_20 + 0x2c) = pbVar2;
    }
LAB_23021e90:
    bit = *(int *)(conn->field_20 + 0x2c);
    if (bit != 0) {
      if (((uVar5 & 4) == 0) || ((*(byte *)(bit + 9) & 1) != 0)) {
        if (((uVar5 & 8) == 0) || ((*(ushort *)(bit + 10) & 0x20) != 0)) {
          iVar3 = bt_conn_le_start_encryption
                            (conn,(u8_t *)(bit + 0xc),(u8_t *)(bit + 0x14),(u8_t *)(bit + 0x16),
                             (uint)*(byte *)(bit + 8));
          bit = 1;
          if (iVar3 < 0) {
            return '\b';
          }
          goto LAB_23021e60;
        }
      }
      else {
        uVar1 = get_io_capa();
        if (CONCAT31(extraout_var,uVar1) == 3) {
          printf("Unsupported auth requirements: 0x%x, repairing\r\n",uVar5);
        }
      }
    }
  }
  else {
    if ((*(ushort *)(*(int *)(conn->field_20 + 0x2c) + 10) & 0x24) != 0) goto LAB_23021e90;
  }
  bit = smp_send_pairing_req(conn);
  if (bit < 0) {
    return '\b';
  }
  bit = 0xe;
LAB_23021e60:
  atomic_set_bit(target,bit);
  return '\0';
}



// WARNING: Type propagation algorithm not settling

u8_t smp_pairing_req(bt_smp *smp,net_buf *buf)

{
  u8_t *__src;
  byte bVar1;
  u8_t uVar2;
  _Bool _Var3;
  int iVar4;
  undefined3 extraout_var;
  bt_keys *pbVar5;
  undefined3 extraout_var_00;
  atomic_t *target;
  bt_conn *pbVar6;
  
  __src = *(u8_t **)&buf->field_4;
  if (9 < (byte)(__src[3] - 7)) {
    return '\x06';
  }
  pbVar6 = (smp->chan).chan.conn;
  if (*(int *)(pbVar6->field_20 + 0x2c) == 0) {
    pbVar5 = bt_keys_get_addr(pbVar6->id,(bt_addr_le_t *)pbVar6->field_20);
    *(bt_keys **)(pbVar6->field_20 + 0x2c) = pbVar5;
    if (pbVar5 == (bt_keys *)0x0) {
      return '\b';
    }
  }
  target = smp->flags;
  iVar4 = atomic_test_bit(target,0xe);
  if ((iVar4 == 0) && (iVar4 = smp_init(smp), iVar4 != 0)) {
    return (u8_t)iVar4;
  }
  smp->preq[0] = '\x01';
  memcpy(smp->preq + 1,__src,6);
  smp->prsp[0] = '\x02';
  bVar1 = get_auth((char)pbVar6 + '\n');
  smp->prsp[3] = bVar1;
  uVar2 = get_io_capa();
  _Var3 = oobd_present;
  smp->prsp[1] = uVar2;
  *(_Bool *)(smp->prsp + 2) = _Var3;
  smp->prsp[4] = '\x10';
  smp->prsp[5] = __src[4] & 7;
  smp->prsp[6] = __src[5] & 5;
  if (((bVar1 & 8) != 0) && ((__src[2] & 8) != 0)) {
    atomic_set_bit(target,5);
    smp->prsp[5] = smp->prsp[5] & 6;
    smp->prsp[6] = smp->prsp[6] & 4;
  }
  if (((smp->prsp[3] & 0x20) != 0) && ((__src[2] & 0x20) != 0)) {
    atomic_set_bit(target,0x13);
  }
  smp->local_dist = smp->prsp[6];
  smp->remote_dist = smp->prsp[5];
  if (((smp->prsp[3] & 1) != 0) && ((__src[2] & 1) != 0)) {
    atomic_set_bit(target,0xc);
  }
  atomic_set_bit(target,3);
  uVar2 = get_pair_method(smp,*__src);
  smp->method = uVar2;
  _Var3 = update_keys_check(smp);
  if (CONCAT31(extraout_var,_Var3) == 0) {
LAB_23022032:
    uVar2 = '\x03';
  }
  else {
    iVar4 = atomic_test_bit(target,5);
    uVar2 = smp->method;
    if (iVar4 == 0) {
      if (((uVar2 != '\0') || (iVar4 = atomic_test_bit(target,0xe), iVar4 != 0)) ||
         ((bt_auth == (bt_conn_auth_cb *)0x0 ||
          (bt_auth->pairing_confirm == (anon_subr_void_bt_conn_ptr_for_pairing_confirm *)0x0)))) {
        uVar2 = send_pairing_rsp(smp);
        if (CONCAT31(extraout_var_00,uVar2) == 0) {
          atomic_set_bit(&smp->allowed_cmds,3);
          uVar2 = legacy_request_tk(smp);
          return uVar2;
        }
        return uVar2;
      }
    }
    else {
      if (pbVar6->required_sec_level == BT_SECURITY_L4) {
        if (uVar2 != '\0') {
          bVar1 = smp->preq[4];
          if (smp->prsp[4] < smp->preq[4]) {
            bVar1 = smp->prsp[4];
          }
          if (bVar1 != 0x10) {
            return 6;
          }
          goto LAB_230220ea;
        }
        goto LAB_23022032;
      }
      if ((((uVar2 != '\0') || (iVar4 = atomic_test_bit(target,0xe), iVar4 != 0)) ||
          (bt_auth == (bt_conn_auth_cb *)0x0)) ||
         (bt_auth->pairing_confirm == (anon_subr_void_bt_conn_ptr_for_pairing_confirm *)0x0)) {
LAB_230220ea:
        atomic_set_bit(&smp->allowed_cmds,0xc);
        uVar2 = send_pairing_rsp(smp);
        return uVar2;
      }
    }
    atomic_set_bit(target,9);
    (*bt_auth->pairing_confirm)((smp->chan).chan.conn);
  }
  return uVar2;
}



void smp_check_complete(bt_conn *conn,u8_t dist_complete)

{
  bt_smp *smp;
  
  smp = (bt_smp *)bt_l2cap_le_lookup_tx_cid(conn,6);
  smp->local_dist = ~dist_complete & smp->local_dist;
  if (*(short *)&smp->local_dist == 0) {
    smp_pairing_complete(smp,'\0');
    return;
  }
  return;
}



void smp_sign_info_sent(bt_conn *conn,void *user_data)

{
  if (conn->type == '\x01') {
    smp_check_complete(conn,'\x04');
    return;
  }
  return;
}



void le_sc_oob_config_set_isra_3_constprop_19(int *param_1,char *param_2)

{
  byte bVar1;
  char cVar2;
  
  bVar1 = *(byte *)((int)param_1 + 0xaa);
  if (*(char *)(*param_1 + 3) == '\0') {
    cVar2 = (char)((uint)bVar1 & 1) + '\x01';
    if (((*(byte *)((int)param_1 + 0xa3) & 1) == 0) && (cVar2 = '\x03', (bVar1 & 1) != 0)) {
      cVar2 = '\0';
    }
  }
  else {
    cVar2 = (char)(((uint)bVar1 & 1) << 1);
    if (((*(byte *)((int)param_1 + 0xa3) & 1) == 0) && (cVar2 = '\x03', (bVar1 & 1) != 0)) {
      cVar2 = '\x01';
    }
  }
  *param_2 = cVar2;
  return;
}



int smp_error(bt_smp *smp,u8_t reason)

{
  net_buf *buf;
  u8_t *puVar1;
  int iVar2;
  
  smp_pairing_complete(smp,reason);
  buf = smp_create_pdu(smp,'\x05');
  if (buf == (net_buf *)0x0) {
    iVar2 = -0x37;
  }
  else {
    puVar1 = (u8_t *)net_buf_simple_add((net_buf_simple *)&buf->field_4,1);
    *puVar1 = reason;
    bt_l2cap_send_cb((smp->chan).chan.conn,6,buf,(bt_conn_tx_cb_t *)0x0,(void *)0x0);
    iVar2 = 0;
  }
  return iVar2;
}



void bt_smp_dhkey_ready(u8_t *dhkey)

{
  atomic_t *target;
  u8_t reason;
  int iVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  bt_smp *smp;
  
  iVar1 = atomic_test_and_clear_bit(bt_smp_pool[0].flags,7);
  if (iVar1 == 0) {
    iVar1 = atomic_test_and_clear_bit(bt_smp_pool[1].flags,7);
    if (iVar1 == 0) {
      return;
    }
    iVar1 = 1;
  }
  else {
    iVar1 = 0;
  }
  reason = '\v';
  smp = bt_smp_pool + iVar1;
  if (dhkey == (u8_t *)0x0) {
LAB_23022292:
    smp_error(smp,reason);
    return;
  }
  memcpy(bt_smp_pool[iVar1].dhkey,dhkey,0x20);
  target = bt_smp_pool[iVar1].flags;
  iVar1 = atomic_test_bit(target,9);
  if ((iVar1 != 0) || (iVar1 = atomic_test_bit(target,0xf), iVar1 != 0)) {
    atomic_set_bit(target,8);
    return;
  }
  iVar1 = atomic_test_bit(target,8);
  if (iVar1 != 0) {
    if (((smp->chan).chan.conn)->role == '\0') {
      reason = compute_and_send_master_dhcheck(smp);
      iVar1 = CONCAT31(extraout_var,reason);
    }
    else {
      reason = compute_and_check_and_send_slave_dhcheck(smp);
      iVar1 = CONCAT31(extraout_var_00,reason);
    }
    reason = (u8_t)iVar1;
    if (iVar1 != 0) goto LAB_23022292;
  }
  return;
}



int bt_smp_recv(bt_l2cap_chan *chan,net_buf *buf)

{
  byte bVar1;
  u8_t reason;
  byte *pbVar2;
  int iVar3;
  undefined3 extraout_var;
  uint uVar4;
  
  if (*(short *)((int)&buf->field_4 + 4) == 0) {
    printf("Too small SMP PDU received\r\n");
  }
  else {
    pbVar2 = (byte *)net_buf_simple_pull_mem((net_buf_simple *)&buf->field_4,1);
    iVar3 = atomic_test_bit((atomic_t *)&chan[2].rtx_work.work_q,4);
    bVar1 = *pbVar2;
    if (iVar3 == 0) {
      if ((bVar1 < 0xe) &&
         (handlers[(uint)bVar1].func != (anon_subr_u8_t_bt_smp_ptr_net_buf_ptr_for_func *)0x0)) {
        iVar3 = atomic_test_and_clear_bit(chan[2].rtx_work.work.flags,(uint)bVar1);
        uVar4 = (uint)*pbVar2;
        if (iVar3 == 0) {
          printf("Unexpected SMP code 0x%02x\r\n",uVar4);
          reason = '\b';
          if (*pbVar2 == 5) {
            return 0;
          }
        }
        else {
          if ((uint)handlers[uVar4].expect_len == (uint)*(ushort *)((int)&buf->field_4 + 4)) {
            reason = (*handlers[uVar4].func)((bt_smp *)chan,buf);
            if (CONCAT31(extraout_var,reason) == 0) {
              return 0;
            }
          }
          else {
            printf("Invalid len %u for code 0x%02x\r\n");
            reason = '\n';
          }
        }
      }
      else {
        printf("Unhandled SMP code 0x%02x\r\n");
        reason = '\a';
      }
      smp_error((bt_smp *)chan,reason);
    }
    else {
      printf("SMP command (code 0x%02x) received after timeout\r\n");
    }
  }
  return 0;
}



void bt_smp_encrypt_change(bt_l2cap_chan *chan,u8_t hci_status)

{
  byte bVar1;
  k_work_q **target;
  u8_t uVar2;
  int bit;
  undefined3 extraout_var;
  undefined3 in_register_0000202d;
  bt_conn *pbVar3;
  
  target = &chan[2].rtx_work.work_q;
  pbVar3 = chan->conn;
  atomic_and((atomic_t *)target,-3);
  if (CONCAT31(in_register_0000202d,hci_status) != 0) {
    return;
  }
  if (pbVar3->encrypt == '\0') {
    return;
  }
  bit = atomic_test_bit((atomic_t *)target,3);
  if (bit == 0) {
    smp_reset((bt_smp *)chan);
    return;
  }
  bit = atomic_test_bit((atomic_t *)target,5);
  if (bit != 0) {
    if (((*(byte *)&chan[6].conn & 8) != 0) && ((*(byte *)((int)&chan[6].conn + 1) & 8) != 0)) {
      atomic_set_bit((atomic_t *)target,0x10);
    }
    *(ushort *)&chan[6].conn = *(ushort *)&chan[6].conn & 0xf7f7;
  }
  bVar1 = *(byte *)((int)&chan[6].conn + 1);
  bit = 6;
  if (((bVar1 & 1) == 0) && (bit = 8, (bVar1 & 2) == 0)) {
    if ((bVar1 & 4) == 0) goto LAB_23022436;
    bit = 10;
  }
  atomic_set_bit(chan[2].rtx_work.work.flags,bit);
LAB_23022436:
  atomic_set_bit((atomic_t *)target,2);
  if ((((pbVar3->role != '\0') || (*(char *)((int)&chan[6].conn + 1) == '\0')) &&
      (uVar2 = bt_smp_distribute_keys((bt_smp *)chan), CONCAT31(extraout_var,uVar2) == 0)) &&
     (*(short *)&chan[6].conn == 0)) {
    smp_pairing_complete((bt_smp *)chan,'\0');
    return;
  }
  return;
}



u8_t smp_send_pairing_confirm(bt_smp *smp)

{
  byte z;
  net_buf *buf;
  u8_t *res;
  int iVar1;
  
  z = smp->method;
  if (z < 3) {
    if (z != 0) {
      z = (byte)(smp->passkey >> ((uint)smp->passkey_round & 0x1f)) & 1 | 0x80;
      goto LAB_230224be;
    }
  }
  else {
    if (z != 3) {
      return '\b';
    }
  }
  z = 0;
LAB_230224be:
  buf = smp_create_pdu(smp,'\x03');
  if (buf == (net_buf *)0x0) {
    return '\b';
  }
  res = (u8_t *)net_buf_simple_add((net_buf_simple *)&buf->field_4,0x10);
  iVar1 = smp_f4(sc_public_key,smp->pkey,smp->prnd,z,res);
  if (iVar1 != 0) {
    net_buf_unref(buf);
    return '\b';
  }
  smp_send(smp,buf,(bt_conn_tx_cb_t *)0x0);
  atomic_and(smp->flags,-2);
  return '\0';
}



void smp_ident_sent(bt_conn *conn,void *user_data)

{
  if (conn->type == '\x01') {
    smp_check_complete(conn,'\x01');
    return;
  }
  return;
}



int smp_c1(u8_t *k,u8_t *r,u8_t *preq,u8_t *pres,bt_addr_le_t *ia,bt_addr_le_t *ra,u8_t *enc_data)

{
  byte bVar1;
  byte *pbVar2;
  int iVar3;
  byte *pbVar4;
  byte *pbVar5;
  byte local_40;
  u8_t uStack63;
  byte abStack62 [2];
  u8_t p1 [16];
  u8_t p2 [16];
  
  local_40 = ia->type;
  uStack63 = ra->type;
  memcpy(&local_40 + 2,preq,7);
  memcpy(p1 + 5,pres,7);
  iVar3 = 0;
  do {
    pbVar2 = r + iVar3;
    pbVar5 = &local_40 + iVar3;
    pbVar4 = enc_data + iVar3;
    iVar3 = iVar3 + 1;
    *pbVar4 = *pbVar2 ^ *pbVar5;
  } while (iVar3 != 0x10);
  iVar3 = bt_encrypt_le(k,enc_data,enc_data);
  if (iVar3 == 0) {
    memcpy(p1 + 0xc,&ra->a,6);
    memcpy(p2 + 2,&ia->a,6);
    memset(p2 + 8,0,4);
    pbVar2 = p1 + 0xc;
    pbVar5 = enc_data;
    while (enc_data + 0x10 != pbVar5) {
      bVar1 = *pbVar2;
      pbVar2 = pbVar2 + 1;
      *pbVar5 = *pbVar5 ^ bVar1;
      pbVar5 = pbVar5 + 1;
    }
    iVar3 = bt_encrypt_le(k,enc_data,enc_data);
  }
  return iVar3;
}



u8_t legacy_send_pairing_confirm(bt_smp *smp)

{
  net_buf *buf;
  u8_t *enc_data;
  int iVar1;
  bt_conn *pbVar2;
  
  pbVar2 = (smp->chan).chan.conn;
  buf = smp_create_pdu(smp,'\x03');
  if (buf != (net_buf *)0x0) {
    enc_data = (u8_t *)net_buf_simple_add((net_buf_simple *)&buf->field_4,0x10);
    iVar1 = smp_c1(smp->tk,smp->prnd,smp->preq,smp->prsp,(bt_addr_le_t *)(pbVar2->field_20 + 7),
                   (bt_addr_le_t *)(pbVar2->field_20 + 0xe),enc_data);
    if (iVar1 == 0) {
      smp_send(smp,buf,(bt_conn_tx_cb_t *)0x0);
      atomic_and(smp->flags,-2);
      return '\0';
    }
    net_buf_unref(buf);
  }
  return '\b';
}



u8_t legacy_pairing_confirm(bt_smp *smp)

{
  u8_t uVar1;
  int bit;
  
  bit = 3;
  if (((smp->chan).chan.conn)->role != '\0') {
    bit = atomic_test_bit(smp->flags,9);
    if (bit != 0) {
      atomic_set_bit(smp->flags,0);
      return '\0';
    }
    bit = 4;
  }
  atomic_set_bit(&smp->allowed_cmds,bit);
  uVar1 = legacy_send_pairing_confirm(smp);
  return uVar1;
}



u8_t smp_pairing_confirm(bt_smp *smp,net_buf *buf)

{
  atomic_t *target;
  u8_t uVar1;
  int iVar2;
  void *__src;
  
  __src = *(void **)&buf->field_4;
  target = smp->flags;
  atomic_and(target,-0x401);
  memcpy(smp->pcnf,__src,0x10);
  if (((smp->chan).chan.conn)->role == '\0') {
    atomic_set_bit(&smp->allowed_cmds,4);
    uVar1 = smp_send_pairing_random(smp);
    return uVar1;
  }
  iVar2 = atomic_test_bit(target,5);
  if (iVar2 != 0) {
    if (smp->method == '\x01') {
      iVar2 = atomic_test_bit(target,9);
      if (iVar2 != 0) {
        atomic_set_bit(target,0);
        return '\0';
      }
    }
    else {
      if (smp->method != '\x02') {
        return '\b';
      }
    }
    atomic_set_bit(&smp->allowed_cmds,4);
    uVar1 = smp_send_pairing_confirm(smp);
    return uVar1;
  }
  uVar1 = legacy_pairing_confirm(smp);
  return uVar1;
}



u8_t smp_pairing_rsp(bt_smp *smp,net_buf *buf)

{
  u8_t *__src;
  u8_t uVar1;
  _Bool _Var2;
  undefined3 extraout_var;
  int iVar3;
  undefined3 extraout_var_00;
  byte bVar4;
  atomic_t *target;
  bt_conn *pbVar5;
  
  __src = *(u8_t **)&buf->field_4;
  if (9 < (byte)(__src[3] - 7)) {
    return '\x06';
  }
  pbVar5 = (smp->chan).chan.conn;
  smp->local_dist = smp->local_dist & __src[4];
  smp->remote_dist = smp->remote_dist & __src[5];
  smp->prsp[0] = '\x02';
  memcpy(smp->prsp + 1,__src,6);
  if (((__src[2] & 8) != 0) && ((smp->preq[3] & 8) != 0)) {
    atomic_set_bit(smp->flags,5);
  }
  if (((__src[2] & 0x20) != 0) && ((smp->preq[3] & 0x20) != 0)) {
    atomic_set_bit(smp->flags,0x13);
  }
  if (((__src[2] & 1) != 0) && ((smp->preq[3] & 1) != 0)) {
    atomic_set_bit(smp->flags,0xc);
  }
  uVar1 = get_pair_method(smp,*__src);
  smp->method = uVar1;
  _Var2 = update_keys_check(smp);
  if (CONCAT31(extraout_var,_Var2) == 0) {
LAB_23022832:
    uVar1 = '\x03';
  }
  else {
    target = smp->flags;
    iVar3 = atomic_test_bit(target,5);
    uVar1 = smp->method;
    if (iVar3 == 0) {
      if (((uVar1 != '\0') || (iVar3 = atomic_test_bit(target,0xe), iVar3 == 0)) ||
         ((bt_auth == (bt_conn_auth_cb *)0x0 ||
          (bt_auth->pairing_confirm == (anon_subr_void_bt_conn_ptr_for_pairing_confirm *)0x0)))) {
        uVar1 = legacy_request_tk(smp);
        if (CONCAT31(extraout_var_00,uVar1) != 0) {
          return uVar1;
        }
        iVar3 = atomic_test_bit(target,9);
        if (iVar3 == 0) {
          atomic_set_bit(&smp->allowed_cmds,3);
          uVar1 = legacy_send_pairing_confirm(smp);
          return uVar1;
        }
        atomic_set_bit(target,0);
        return uVar1;
      }
    }
    else {
      if (pbVar5->required_sec_level == BT_SECURITY_L4) {
        if (uVar1 == '\0') goto LAB_23022832;
        bVar4 = smp->prsp[4];
        if (smp->preq[4] < smp->prsp[4]) {
          bVar4 = smp->preq[4];
        }
        if (bVar4 != 0x10) {
          return '\x06';
        }
      }
      *(ushort *)&smp->local_dist = *(ushort *)&smp->local_dist & 0x604;
      if ((((uVar1 != '\0') || (iVar3 = atomic_test_bit(target,0xe), iVar3 == 0)) ||
          (bt_auth == (bt_conn_auth_cb *)0x0)) ||
         (bt_auth->pairing_confirm == (anon_subr_void_bt_conn_ptr_for_pairing_confirm *)0x0)) {
        if (sc_public_key != (u8_t *)0x0) {
          atomic_set_bit(&smp->allowed_cmds,0xc);
          atomic_and(&smp->allowed_cmds,-0x801);
          uVar1 = sc_send_public_key(smp);
          return uVar1;
        }
        atomic_set_bit(target,6);
        return '\0';
      }
    }
    atomic_set_bit(target,9);
    (*bt_auth->pairing_confirm)((smp->chan).chan.conn);
  }
  return uVar1;
}



u8_t smp_ident_addr_info(bt_smp *smp,net_buf *buf)

{
  byte bVar1;
  bt_conn *conn;
  u8_t uVar2;
  char *pcVar3;
  int iVar4;
  bt_keys *keys;
  undefined3 extraout_var;
  byte *pbVar5;
  bt_addr_le_t *addr;
  bt_addr_le_t *addr_00;
  
  addr = *(bt_addr_le_t **)&buf->field_4;
  conn = (smp->chan).chan.conn;
  if ((addr->type == '\0') || (((addr->a).val[5] & 0xc0) == 0xc0)) {
    iVar4 = atomic_test_bit(smp->flags,0xc);
    if (iVar4 != 0) {
      addr_00 = (bt_addr_le_t *)conn->field_20;
      keys = bt_keys_get_type(2,conn->id,addr_00);
      if (keys == (bt_keys *)0x0) {
        pcVar3 = bt_addr_le_str_real(addr_00);
        printf("Unable to get keys for %s\r\n",pcVar3);
        return '\b';
      }
      pbVar5 = conn->field_20 + 7;
      if (conn->role == '\0') {
        pbVar5 = conn->field_20 + 0xe;
      }
      if ((((*pbVar5 == 1) && ((pbVar5[6] & 0xc0) == 0x40)) &&
          (memcpy(&(keys->irk).rpa,pbVar5 + 1,6), conn->field_20[0] != 0)) &&
         ((conn->field_20[6] & 0xc0) != 0xc0)) {
        memcpy(&keys->addr,addr,7);
        memcpy(addr_00,addr,7);
        bt_conn_identity_resolved(conn);
      }
      bt_id_add(keys);
    }
    bVar1 = smp->remote_dist;
    smp->remote_dist = bVar1 & 0xfd;
    if ((bVar1 & 4) != 0) {
      atomic_set_bit(&smp->allowed_cmds,10);
    }
    if (((conn->role != '\0') || (smp->remote_dist != '\0')) ||
       (uVar2 = bt_smp_distribute_keys(smp), CONCAT31(extraout_var,uVar2) == 0)) {
      if (*(short *)&smp->local_dist == 0) {
        smp_pairing_complete(smp,'\0');
      }
      uVar2 = '\0';
    }
  }
  else {
    pcVar3 = bt_addr_le_str_real(addr);
    printf("Invalid identity %s\r\n",pcVar3);
    pcVar3 = bt_addr_le_str_real((bt_addr_le_t *)conn->field_20);
    printf(" for %s\r\n",pcVar3);
    uVar2 = '\n';
  }
  return uVar2;
}



u8_t smp_public_key_slave(bt_smp *smp)

{
  u8_t uVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  int bit;
  
  switch(smp->method) {
  case '\0':
  case '\x03':
    atomic_set_bit(&smp->allowed_cmds,4);
    uVar1 = smp_send_pairing_confirm(smp);
    if (CONCAT31(extraout_var,uVar1) != 0) {
      return uVar1;
    }
    goto LAB_23022b04;
  case '\x01':
    atomic_set_bit(&smp->allowed_cmds,3);
    atomic_set_bit(smp->flags,9);
    (*bt_auth->passkey_entry)((smp->chan).chan.conn);
    goto LAB_23022b04;
  case '\x02':
    uVar1 = display_passkey(smp);
    bit = 3;
    if (CONCAT31(extraout_var_00,uVar1) != 0) {
      return uVar1;
    }
    break;
  case '\x04':
    return '\b';
  case '\x05':
    bit = 4;
    break;
  default:
    return '\b';
  }
  atomic_set_bit(&smp->allowed_cmds,bit);
LAB_23022b04:
  bit = bt_dh_key_gen(smp->pkey,bt_smp_dhkey_ready);
  uVar1 = '\b';
  if (bit == 0) {
    atomic_set_bit(smp->flags,7);
    uVar1 = '\0';
  }
  return uVar1;
}



// WARNING: Variable defined which should be unmapped: info
// WARNING: Type propagation algorithm not settling

u8_t smp_public_key(bt_smp *smp,net_buf *buf)

{
  void *__src;
  bt_conn *pbVar1;
  u8_t uVar2;
  int bit;
  bt_keys *pbVar3;
  int iVar4;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  u8_t *remote_pk;
  bt_conn_oob_info abStack20 [2];
  bt_conn_oob_info info;
  
  __src = *(void **)&buf->field_4;
  remote_pk = smp->pkey;
  memcpy(remote_pk,__src,0x20);
  memcpy(smp->pkey + 0x20,(void *)((int)__src + 0x20),0x20);
  bit = memcmp(remote_pk,sc_debug_public_key,0x40);
  if (bit == 0) {
    atomic_set_bit(smp->flags,0xd);
    pbVar1 = (smp->chan).chan.conn;
    if (*(int *)(pbVar1->field_20 + 0x2c) == 0) {
      pbVar3 = bt_keys_get_addr(pbVar1->id,(bt_addr_le_t *)pbVar1->field_20);
      *(bt_keys **)(pbVar1->field_20 + 0x2c) = pbVar3;
    }
    bit = *(int *)(pbVar1->field_20 + 0x2c);
    if (((bit != 0) && ((*(ushort *)(bit + 10) & 0x24) != 0)) && ((*(byte *)(bit + 9) & 2) != 0)) {
      return '\x03';
    }
  }
  if (((smp->chan).chan.conn)->role != '\0') {
    if (sc_public_key != (u8_t *)0x0) {
      uVar2 = sc_send_public_key(smp);
      if (CONCAT31(extraout_var_01,uVar2) != 0) {
        return uVar2;
      }
      uVar2 = smp_public_key_slave(smp);
      return uVar2;
    }
    bit = 6;
    goto LAB_23022c0c;
  }
  switch(smp->method) {
  case '\0':
  case '\x03':
    atomic_set_bit(&smp->allowed_cmds,3);
    break;
  case '\x01':
    atomic_set_bit(smp->flags,9);
    (*bt_auth->passkey_entry)((smp->chan).chan.conn);
    break;
  case '\x02':
    uVar2 = display_passkey(smp);
    if (CONCAT31(extraout_var,uVar2) != 0) {
      return uVar2;
    }
    atomic_set_bit(&smp->allowed_cmds,3);
    uVar2 = smp_send_pairing_confirm(smp);
    if (CONCAT31(extraout_var_00,uVar2) != 0) {
      return uVar2;
    }
    break;
  default:
    goto switchD_23022bee_caseD_4;
  case '\x05':
    bit = bt_rand(smp->prnd,0x10);
    if (bit == 0) {
      if (bt_auth == (bt_conn_auth_cb *)0x0) {
        return '\x02';
      }
      if (bt_auth->oob_data_request ==
          (anon_subr_void_bt_conn_ptr_bt_conn_oob_info_ptr_for_oob_data_request *)0x0) {
        return '\x02';
      }
      abStack20[0] = (bt_conn_oob_info)0x301;
      le_sc_oob_config_set_isra_3_constprop_19(smp,&abStack20[0].field_1);
      smp->oobd_local = (bt_le_oob_sc_data *)0x0;
      smp->oobd_remote = (bt_le_oob_sc_data *)0x0;
      atomic_set_bit(smp->flags,0xb);
      (*bt_auth->oob_data_request)((smp->chan).chan.conn,abStack20);
      break;
    }
    goto switchD_23022bee_caseD_4;
  }
  iVar4 = bt_dh_key_gen(remote_pk,bt_smp_dhkey_ready);
  bit = 7;
  if (iVar4 == 0) {
LAB_23022c0c:
    atomic_set_bit(smp->flags,bit);
    uVar2 = '\0';
  }
  else {
switchD_23022bee_caseD_4:
    uVar2 = '\b';
  }
  return uVar2;
}



void bt_smp_pkey_ready(u8_t *pkey)

{
  u8_t reason;
  int iVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  
  sc_public_key = pkey;
  if (pkey == (u8_t *)0x0) {
    printf("Public key not available\r\n");
    return;
  }
  k_sem_give(&sc_local_pkey_ready);
  iVar1 = atomic_test_bit(bt_smp_pool[0].flags,6);
  if (iVar1 != 0) {
    if ((bt_smp_pool[0].chan.chan.conn)->role == '\0') {
      reason = sc_send_public_key(bt_smp_pool);
      if (CONCAT31(extraout_var_02,reason) != 0) {
        smp_error(bt_smp_pool,reason);
      }
      atomic_set_bit(&bt_smp_pool[0].allowed_cmds,0xc);
    }
    else {
      reason = sc_send_public_key(bt_smp_pool);
      if ((CONCAT31(extraout_var,reason) != 0) ||
         (reason = smp_public_key_slave(bt_smp_pool), CONCAT31(extraout_var_01,reason) != 0)) {
        smp_error(bt_smp_pool,reason);
      }
    }
  }
  iVar1 = atomic_test_bit(bt_smp_pool[1].flags,6);
  if (iVar1 != 0) {
    if ((bt_smp_pool[1].chan.chan.conn)->role == '\0') {
      reason = sc_send_public_key(bt_smp_pool + 1);
      if (CONCAT31(extraout_var_00,reason) != 0) {
        smp_error(bt_smp_pool + 1,reason);
      }
      atomic_set_bit(&bt_smp_pool[1].allowed_cmds,0xc);
      return;
    }
    reason = sc_send_public_key(bt_smp_pool + 1);
    if ((CONCAT31(extraout_var_03,reason) != 0) ||
       (reason = smp_public_key_slave(bt_smp_pool + 1), CONCAT31(extraout_var_04,reason) != 0)) {
      smp_error(bt_smp_pool + 1,reason);
      return;
    }
  }
  return;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Could not reconcile some variable overlaps

u8_t smp_pairing_random(bt_smp *smp,net_buf *buf)

{
  u8_t uVar1;
  int bit;
  undefined3 extraout_var;
  int iVar2;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  uint len;
  u8_t uVar3;
  atomic_t *target;
  u8_t *x;
  bt_conn *conn;
  u8_t *k;
  u8_t auStack60 [4];
  u8_t ediv [2];
  u8_t rand [8];
  u32_t_conflict passkey;
  undefined auStack40 [8];
  
  x = smp->rrnd;
  memcpy(x,*(void **)&buf->field_4,0x10);
  target = smp->flags;
  bit = atomic_test_bit(target,5);
  conn = (smp->chan).chan.conn;
  if (bit == 0) {
    k = smp->tk;
    bit = smp_c1(k,x,smp->preq,smp->prsp,(bt_addr_le_t *)(conn->field_20 + 7),
                 (bt_addr_le_t *)(conn->field_20 + 0xe),rand + 4);
    if (bit != 0) {
      return '\b';
    }
    bit = memcmp(smp->pcnf,rand + 4,0x10);
    if (bit != 0) {
      return '\x04';
    }
    uVar1 = conn->role;
    if (uVar1 != '\0') {
      memcpy(rand + 4,x,8);
      memcpy(auStack40,smp->prnd,8);
      bit = bt_encrypt_le(k,rand + 4,rand + 4);
      if (bit != 0) {
        return '\b';
      }
      memcpy(k,rand + 4,0x10);
      bit = 1;
LAB_23022ed6:
      atomic_set_bit(target,bit);
      uVar1 = smp_send_pairing_random(smp);
      return uVar1;
    }
    memcpy(rand + 4,smp->prnd,8);
    memcpy(auStack40,x,8);
    bit = bt_encrypt_le(k,rand + 4,rand + 4);
    if (bit != 0) {
      return '\b';
    }
    memset(auStack60,0,2);
    memset(ediv,0,8);
    len = (uint)smp->prsp[4];
    if ((uint)smp->preq[4] < (uint)smp->prsp[4]) {
      len = (uint)smp->preq[4];
    }
    bit = bt_conn_le_start_encryption(conn,ediv,auStack60,rand + 4,len);
    if (bit != 0) {
      printf("Failed to start encryption\r\n");
      return '\b';
    }
    bit = 1;
LAB_23022ea4:
    atomic_set_bit(target,bit);
    return uVar1;
  }
  if (conn->role == '\0') {
    uVar1 = sc_smp_check_confirm(smp);
    if (CONCAT31(extraout_var,uVar1) != 0) {
      return uVar1;
    }
    switch(smp->method) {
    case '\x01':
    case '\x02':
      uVar3 = smp->passkey_round + '\x01';
      smp->passkey_round = uVar3;
      if (uVar3 != '\x14') {
        bit = bt_rand(smp->prnd,0x10);
        if (bit != 0) {
          return '\b';
        }
        atomic_set_bit(&smp->allowed_cmds,3);
        uVar1 = smp_send_pairing_confirm(smp);
        return uVar1;
      }
    case '\0':
    case '\x05':
      iVar2 = atomic_test_bit(target,7);
      bit = 8;
      if (iVar2 == 0) {
        uVar1 = compute_and_send_master_dhcheck(smp);
        return uVar1;
      }
      goto LAB_23022ea4;
    case '\x03':
      bit = smp_g2(sc_public_key,smp->pkey,smp->prnd,x,(u32_t_conflict *)(rand + 4));
      if (bit == 0) {
        atomic_set_bit(target,9);
        atomic_set_bit(target,8);
        (*bt_auth->passkey_confirm)((smp->chan).chan.conn,rand._4_4_);
        return uVar1;
      }
    }
  }
  else {
    switch(smp->method) {
    case '\x01':
    case '\x02':
      uVar1 = sc_smp_check_confirm(smp);
      if (CONCAT31(extraout_var_00,uVar1) != 0) {
        return uVar1;
      }
      atomic_set_bit(&smp->allowed_cmds,3);
      uVar1 = smp_send_pairing_random(smp);
      if (CONCAT31(extraout_var_01,uVar1) != 0) {
        return uVar1;
      }
      uVar3 = smp->passkey_round + '\x01';
      smp->passkey_round = uVar3;
      if (uVar3 != '\x14') {
        bit = bt_rand(smp->prnd,0x10);
        if (bit != 0) {
          return '\b';
        }
        return uVar1;
      }
      atomic_set_bit(&smp->allowed_cmds,0xd);
      bit = 0xf;
      goto LAB_23022ea4;
    case '\x03':
      bit = smp_g2(smp->pkey,sc_public_key,x,smp->prnd,(u32_t_conflict *)(rand + 4));
      if (bit != 0) {
        return '\b';
      }
      atomic_set_bit(target,9);
      (*bt_auth->passkey_confirm)((smp->chan).chan.conn,rand._4_4_);
    case '\0':
      atomic_set_bit(&smp->allowed_cmds,0xd);
      bit = 0xf;
      goto LAB_23022ed6;
    case '\x05':
      bit = bt_rand(smp->prnd,0x10);
      if (bit == 0) {
        if (bt_auth == (bt_conn_auth_cb *)0x0) {
          return '\x02';
        }
        if (bt_auth->oob_data_request ==
            (anon_subr_void_bt_conn_ptr_bt_conn_oob_info_ptr_for_oob_data_request *)0x0) {
          return '\x02';
        }
        rand._4_4_ = CONCAT22(rand._6_2_,0x301);
        le_sc_oob_config_set_isra_3_constprop_19(smp,rand + 5);
        smp->oobd_local = (bt_le_oob_sc_data *)0x0;
        smp->oobd_remote = (bt_le_oob_sc_data *)0x0;
        atomic_set_bit(target,0xb);
        (*bt_auth->oob_data_request)((smp->chan).chan.conn,(bt_conn_oob_info *)(rand + 4));
        return '\0';
      }
    }
  }
  return '\b';
}



// WARNING: Type propagation algorithm not settling

_Bool bt_smp_request_ltk(bt_conn *conn,u16_t ediv,u8_t *ltk)

{
  byte bVar1;
  uint __n;
  bt_smp *smp;
  int iVar2;
  bt_keys *pbVar3;
  undefined2 in_register_0000202e;
  short in_a3;
  void *in_a4;
  short sStack42;
  uint uStack40;
  u8_t *puStack36;
  
  uStack40 = CONCAT22(in_register_0000202e,ediv);
  sStack42 = in_a3;
  puStack36 = ltk;
  smp = smp_chan_get(conn);
  if (smp == (bt_smp *)0x0) {
    return false;
  }
  if ((sStack42 == 0) && ((uStack40 | (uint)puStack36) == 0)) {
    iVar2 = atomic_test_bit(smp->flags,3);
    if ((iVar2 != 0) && (iVar2 = atomic_test_bit(smp->flags,1), iVar2 != 0)) {
      __n = (uint)smp->prsp[4];
      if ((uint)smp->preq[4] < (uint)smp->prsp[4]) {
        __n = (uint)smp->preq[4];
      }
      memcpy(in_a4,smp->tk,__n);
      if (__n < 0x10) {
        memset((void *)((int)in_a4 + __n),0,0x10 - __n);
      }
      goto LAB_2302311c;
    }
  }
  if (*(int *)(conn->field_20 + 0x2c) == 0) {
    pbVar3 = bt_keys_find(0x20,conn->id,(bt_addr_le_t *)conn->field_20);
    *(bt_keys **)(conn->field_20 + 0x2c) = pbVar3;
    if (pbVar3 == (bt_keys *)0x0) {
      pbVar3 = bt_keys_find(1,conn->id,(bt_addr_le_t *)conn->field_20);
      *(bt_keys **)(conn->field_20 + 0x2c) = pbVar3;
    }
  }
  iVar2 = *(int *)(conn->field_20 + 0x2c);
  if ((sStack42 == 0) && ((uStack40 | (uint)puStack36) == 0)) {
    if (iVar2 == 0) goto LAB_23023202;
    if ((*(ushort *)(iVar2 + 10) & 0x20) != 0) {
      bVar1 = *(byte *)(iVar2 + 8);
      __n = (uint)bVar1;
      memcpy(in_a4,(void *)(iVar2 + 0x16),__n);
      if (bVar1 < 0x10) {
        memset((void *)((int)in_a4 + __n),0,0x10 - __n);
        return true;
      }
      return true;
    }
  }
  else {
    if (iVar2 == 0) goto LAB_23023202;
  }
  if ((((*(ushort *)(iVar2 + 10) & 1) != 0) &&
      (iVar2 = memcmp((void *)(iVar2 + 100),&uStack40,8), iVar2 == 0)) &&
     (iVar2 = memcmp((void *)(*(int *)(conn->field_20 + 0x2c) + 0x6c),&sStack42,2), iVar2 == 0)) {
    bVar1 = *(byte *)(*(int *)(conn->field_20 + 0x2c) + 8);
    __n = (uint)bVar1;
    memcpy(in_a4,(void *)(*(int *)(conn->field_20 + 0x2c) + 0x6e),__n);
    if (bVar1 < 0x10) {
      memset((void *)((int)in_a4 + __n),0,0x10 - __n);
    }
LAB_2302311c:
    atomic_set_bit(smp->flags,1);
    return true;
  }
LAB_23023202:
  iVar2 = atomic_test_bit(smp->flags,0xe);
  if (iVar2 != 0) {
    bt_conn_security_changed((smp->chan).chan.conn,2);
  }
  smp_reset(smp);
  return false;
}



// WARNING: Variable defined which should be unmapped: sig

int bt_smp_sign_verify(bt_conn *conn,net_buf *buf)

{
  bt_keys *pbVar1;
  char *pcVar2;
  int iVar3;
  bt_addr_le_t *addr;
  u32_t_conflict local_20;
  u32_t_conflict cnt;
  u8_t sig [12];
  
  memcpy(&cnt,(void *)(*(int *)&buf->field_4 + ((uint)*(ushort *)((int)&buf->field_4 + 4) - 0xc)),
         0xc);
  addr = (bt_addr_le_t *)conn->field_20;
  pbVar1 = bt_keys_find(0x10,conn->id,addr);
  if (pbVar1 == (bt_keys *)0x0) {
    pcVar2 = bt_addr_le_str_real(addr);
    printf("Unable to find Remote CSRK for %s\r\n",pcVar2);
    iVar3 = -2;
  }
  else {
    local_20 = (pbVar1->remote_csrk).cnt;
    memcpy((void *)(*(int *)&buf->field_4 + ((uint)*(ushort *)((int)&buf->field_4 + 4) - 0xc)),
           &local_20,4);
    iVar3 = smp_sign_buf((u8_t *)&pbVar1->remote_csrk,*(u8_t **)&buf->field_4,
                         (u16_t)(((uint)*(ushort *)((int)&buf->field_4 + 4) - 0xc) * 0x10000 >> 0x10
                                ));
    if (iVar3 == 0) {
      iVar3 = memcmp(&cnt,(void *)(*(int *)&buf->field_4 +
                                  ((uint)*(ushort *)((int)&buf->field_4 + 4) - 0xc)),0xc);
      if (iVar3 == 0) {
        (pbVar1->remote_csrk).cnt = (pbVar1->remote_csrk).cnt + 1;
      }
      else {
        pcVar2 = bt_addr_le_str_real(addr);
        printf("Unable to verify signature for %s\r\n",pcVar2);
        iVar3 = -0x4d;
      }
    }
    else {
      pcVar2 = bt_addr_le_str_real(addr);
      printf("Unable to create signature for %s\r\n",pcVar2);
      iVar3 = -5;
    }
  }
  return iVar3;
}



// WARNING: Variable defined which should be unmapped: cnt

int bt_smp_sign(bt_conn *conn,net_buf *buf)

{
  bt_keys *pbVar1;
  char *pcVar2;
  int iVar3;
  bt_addr_le_t *addr;
  u32_t_conflict uStack20;
  u32_t_conflict cnt;
  
  addr = (bt_addr_le_t *)conn->field_20;
  pbVar1 = bt_keys_find(8,conn->id,addr);
  if (pbVar1 == (bt_keys *)0x0) {
    pcVar2 = bt_addr_le_str_real(addr);
    printf("Unable to find local CSRK for %s\r\n",pcVar2);
    iVar3 = -2;
  }
  else {
    net_buf_simple_add((net_buf_simple *)&buf->field_4,0xc);
    uStack20 = (pbVar1->local_csrk).cnt;
    memcpy((void *)(*(int *)&buf->field_4 + ((uint)*(ushort *)((int)&buf->field_4 + 4) - 0xc)),
           &uStack20,4);
    iVar3 = smp_sign_buf((u8_t *)&pbVar1->local_csrk,*(u8_t **)&buf->field_4,
                         (u16_t)(((uint)*(ushort *)((int)&buf->field_4 + 4) - 0xc) * 0x10000 >> 0x10
                                ));
    if (iVar3 == 0) {
      (pbVar1->local_csrk).cnt = (pbVar1->local_csrk).cnt + 1;
    }
    else {
      pcVar2 = bt_addr_le_str_real(addr);
      printf("Unable to create signature for %s\r\n",pcVar2);
      iVar3 = -5;
    }
  }
  return iVar3;
}



// WARNING: Type propagation algorithm not settling

int bt_smp_auth_passkey_entry(bt_conn *conn,uint passkey)

{
  u8_t uVar1;
  bt_smp *smp;
  int bit;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  bt_conn *pbVar2;
  atomic_t *target;
  uint auStack36 [4];
  
  smp = smp_chan_get(conn);
  if (smp == (bt_smp *)0x0) {
    return -0x16;
  }
  target = smp->flags;
  bit = atomic_test_and_clear_bit(target,9);
  if (bit == 0) {
    return 0xffffffea;
  }
  bit = atomic_test_bit(target,5);
  if (bit == 0) {
    auStack36[0] = passkey;
    memcpy(smp->tk,auStack36,4);
    bit = atomic_test_and_clear_bit(target,0);
    if (bit == 0) {
      return 0;
    }
    uVar1 = legacy_pairing_confirm(smp);
    if (CONCAT31(extraout_var,uVar1) == 0) {
      bit = 3;
      if (((smp->chan).chan.conn)->role != '\0') {
        bit = 4;
      }
      atomic_set_bit(&smp->allowed_cmds,bit);
      return 0;
    }
    smp_error(smp,'\x01');
    return 0;
  }
  pbVar2 = (smp->chan).chan.conn;
  smp->passkey = passkey;
  if (pbVar2->role == '\0') {
    uVar1 = smp_send_pairing_confirm(smp);
    if (CONCAT31(extraout_var_00,uVar1) == 0) {
      bit = 3;
LAB_2302342c:
      atomic_set_bit(&smp->allowed_cmds,bit);
      return 0;
    }
  }
  else {
    bit = atomic_test_bit(target,0);
    if (bit == 0) {
      return 0;
    }
    uVar1 = smp_send_pairing_confirm(smp);
    bit = 4;
    if (CONCAT31(extraout_var_01,uVar1) == 0) goto LAB_2302342c;
  }
  smp_error(smp,'\x01');
  return 0;
}



// WARNING: Type propagation algorithm not settling

int bt_smp_auth_passkey_confirm(bt_conn *conn)

{
  atomic_t *target;
  u8_t uVar1;
  bt_smp *smp;
  int iVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  
  smp = smp_chan_get(conn);
  if (smp != (bt_smp *)0x0) {
    target = smp->flags;
    iVar2 = atomic_test_and_clear_bit(target,9);
    if (iVar2 != 0) {
      iVar2 = atomic_test_bit(target,7);
      if ((iVar2 != 0) || (iVar2 = atomic_test_bit(target,0xf), iVar2 != 0)) {
        atomic_set_bit(target,8);
        return 0;
      }
      iVar2 = atomic_test_bit(target,8);
      if (iVar2 == 0) {
        return 0;
      }
      if (((smp->chan).chan.conn)->role == '\0') {
        uVar1 = compute_and_send_master_dhcheck(smp);
        iVar2 = CONCAT31(extraout_var,uVar1);
      }
      else {
        uVar1 = compute_and_check_and_send_slave_dhcheck(smp);
        iVar2 = CONCAT31(extraout_var_00,uVar1);
      }
      if (iVar2 == 0) {
        return 0;
      }
      smp_error(smp,(u8_t)iVar2);
      return 0;
    }
  }
  return -0x16;
}



int bt_smp_auth_cancel(bt_conn *conn)

{
  bt_smp *smp;
  int iVar1;
  u8_t reason;
  
  smp = smp_chan_get(conn);
  if ((smp != (bt_smp *)0x0) && (iVar1 = atomic_test_and_clear_bit(smp->flags,9), iVar1 != 0)) {
    switch(smp->method) {
    case '\0':
      reason = '\b';
      break;
    case '\x01':
    case '\x02':
      reason = '\x01';
      break;
    case '\x03':
      reason = '\x04';
      break;
    default:
      return 0;
    case '\x05':
      reason = '\x02';
    }
    iVar1 = smp_error(smp,reason);
    return iVar1;
  }
  return -0x16;
}



int bt_smp_auth_pairing_confirm(bt_conn *conn)

{
  atomic_t *target;
  u8_t uVar1;
  bt_smp *smp;
  int iVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  
  smp = smp_chan_get(conn);
  if (smp != (bt_smp *)0x0) {
    target = smp->flags;
    iVar2 = atomic_test_and_clear_bit(target,9);
    if (iVar2 != 0) {
      if (conn->role != '\0') {
        iVar2 = atomic_test_bit(target,5);
        if (iVar2 == 0) {
          atomic_set_bit(&smp->allowed_cmds,3);
          uVar1 = send_pairing_rsp(smp);
          return CONCAT31(extraout_var_01,uVar1);
        }
        atomic_set_bit(&smp->allowed_cmds,0xc);
        uVar1 = send_pairing_rsp(smp);
        if (CONCAT31(extraout_var_02,uVar1) == 0) {
          return 0;
        }
        return -5;
      }
      iVar2 = atomic_test_bit(target,5);
      if (iVar2 == 0) {
        atomic_set_bit(&smp->allowed_cmds,3);
        uVar1 = legacy_send_pairing_confirm(smp);
        return CONCAT31(extraout_var,uVar1);
      }
      if (sc_public_key != (u8_t *)0x0) {
        atomic_set_bit(&smp->allowed_cmds,0xc);
        uVar1 = sc_send_public_key(smp);
        return CONCAT31(extraout_var_00,uVar1);
      }
      atomic_set_bit(target,6);
      return 0;
    }
  }
  return -0x16;
}



int bt_smp_start_security(bt_conn *conn)

{
  int iVar1;
  _Bool _Var2;
  u8_t uVar3;
  undefined3 extraout_var;
  atomic_t *target;
  bt_smp *smp;
  undefined3 extraout_var_00;
  bt_keys *pbVar4;
  undefined3 extraout_var_01;
  net_buf *buf;
  u8_t *puVar5;
  
  if (conn->role == '\0') {
    smp = smp_chan_get(conn);
    if (smp != (bt_smp *)0x0) {
      iVar1 = atomic_test_bit(conn->flags,0xb);
      if ((iVar1 != 0) || (_Var2 = smp_keys_check(conn), CONCAT31(extraout_var,_Var2) == 0)) {
        iVar1 = smp_send_pairing_req(conn);
        return iVar1;
      }
      target = smp->flags;
      iVar1 = atomic_test_bit(target,3);
      if ((iVar1 != 0) || (iVar1 = atomic_test_bit(target,1), iVar1 != 0)) {
        return -0x10;
      }
      iVar1 = *(int *)(conn->field_20 + 0x2c);
      iVar1 = bt_conn_le_start_encryption
                        (conn,(u8_t *)(iVar1 + 0xc),(u8_t *)(iVar1 + 0x14),(u8_t *)(iVar1 + 0x16),
                         (uint)*(byte *)(iVar1 + 8));
      if (iVar1 != 0) {
        return iVar1;
      }
      atomic_set_bit(&smp->allowed_cmds,0xb);
LAB_23023682:
      atomic_set_bit(target,1);
      return iVar1;
    }
LAB_230235fe:
    iVar1 = -0x39;
  }
  else {
    if (conn->role == '\x01') {
      smp = smp_chan_get(conn);
      if (smp == (bt_smp *)0x0) goto LAB_230235fe;
      target = smp->flags;
      iVar1 = atomic_test_bit(target,4);
      if (iVar1 != 0) {
        return -5;
      }
      iVar1 = atomic_test_bit(target,3);
      if (iVar1 != 0) {
        return -0x10;
      }
      iVar1 = atomic_test_bit(target,1);
      if (iVar1 != 0) {
        return -0x10;
      }
      _Var2 = sec_level_reachable();
      if ((CONCAT31(extraout_var_00,_Var2) != 0) ||
         ((iVar1 = atomic_test_bit(conn->flags,0xb), iVar1 == 0 &&
          (_Var2 = smp_keys_check(conn), CONCAT31(extraout_var_01,_Var2) != 0)))) {
        if (*(int *)(conn->field_20 + 0x2c) == 0) {
          pbVar4 = bt_keys_get_addr(conn->id,(bt_addr_le_t *)conn->field_20);
          *(bt_keys **)(conn->field_20 + 0x2c) = pbVar4;
          if (pbVar4 == (bt_keys *)0x0) {
            return -0xc;
          }
        }
        iVar1 = smp_init(smp);
        if ((iVar1 != 0) || (buf = smp_create_pdu(smp,'\v'), buf == (net_buf *)0x0)) {
          return -0x37;
        }
        puVar5 = (u8_t *)net_buf_simple_add((net_buf_simple *)&buf->field_4,1);
        uVar3 = get_auth((char)conn + '\n');
        *puVar5 = uVar3;
        bt_l2cap_send_cb(conn,6,buf,(bt_conn_tx_cb_t *)0x0,(void *)0x0);
        atomic_set_bit(target,0xe);
        target = &smp->allowed_cmds;
        goto LAB_23023682;
      }
    }
    iVar1 = -0x16;
  }
  return iVar1;
}



void bt_smp_update_keys(bt_conn *conn)

{
  bt_smp *smp;
  int iVar1;
  bt_keys *pbVar2;
  char *pcVar3;
  byte bVar4;
  int iVar5;
  atomic_t *target;
  
  smp = smp_chan_get(conn);
  if (smp != (bt_smp *)0x0) {
    target = smp->flags;
    iVar1 = atomic_test_bit(target,3);
    if (iVar1 != 0) {
      if (*(bt_keys **)(conn->field_20 + 0x2c) != (bt_keys *)0x0) {
        bt_keys_clear(*(bt_keys **)(conn->field_20 + 0x2c));
      }
      pbVar2 = bt_keys_get_addr(conn->id,(bt_addr_le_t *)conn->field_20);
      *(bt_keys **)(conn->field_20 + 0x2c) = pbVar2;
      if (pbVar2 == (bt_keys *)0x0) {
        pcVar3 = bt_addr_le_str_real((bt_addr_le_t *)conn->field_20);
        printf("Unable to get keys for %s\r\n",pcVar3);
        smp_error(smp,'\b');
        return;
      }
      iVar1 = atomic_test_bit(target,0xd);
      if (iVar1 != 0) {
        *(byte *)(*(int *)(conn->field_20 + 0x2c) + 9) =
             *(byte *)(*(int *)(conn->field_20 + 0x2c) + 9) | 2;
      }
      bVar4 = *(byte *)(*(int *)(conn->field_20 + 0x2c) + 9);
      if ((smp->method < 6) && ((1 << ((uint)smp->method & 0x1f) & 0x2eU) != 0)) {
        bVar4 = bVar4 | 1;
      }
      else {
        bVar4 = bVar4 & 0xfe;
      }
      *(byte *)(*(int *)(conn->field_20 + 0x2c) + 9) = bVar4;
      bVar4 = smp->preq[4];
      if (smp->prsp[4] < smp->preq[4]) {
        bVar4 = smp->prsp[4];
      }
      *(byte *)(*(int *)(conn->field_20 + 0x2c) + 8) = bVar4;
      iVar1 = atomic_test_bit(target,5);
      iVar5 = *(int *)(conn->field_20 + 0x2c);
      if (iVar1 == 0) {
        *(byte *)(iVar5 + 9) = *(byte *)(iVar5 + 9) & 0xef;
      }
      else {
        *(byte *)(iVar5 + 9) = *(byte *)(iVar5 + 9) | 0x10;
        iVar1 = atomic_test_bit(target,0xc);
        if (iVar1 != 0) {
          bt_keys_add_type(*(bt_keys **)(conn->field_20 + 0x2c),0x20);
          memcpy((void *)(*(int *)(conn->field_20 + 0x2c) + 0x16),smp->tk,0x10);
          memset((void *)(*(int *)(conn->field_20 + 0x2c) + 0xc),0,8);
          memset((void *)(*(int *)(conn->field_20 + 0x2c) + 0x14),0,2);
          return;
        }
      }
    }
  }
  return;
}



int bt_smp_init(void)

{
  bt_pub_key_cb pub_key_cb;
  
  k_sem_init(&sc_local_pkey_ready,0,1);
  sc_supported = (_Bool)((bt_dev.supported_commands[34] & 6) == 6);
  bt_pub_key_gen((bt_pub_key_cb *)&ram0x4200dbb8);
  return 0;
}



bt_keys * bt_keys_find_addr(u8_t id,bt_addr_le_t *addr)

{
  undefined3 in_register_00002029;
  int iVar1;
  
  if (((uint)key_pool[0].id != CONCAT31(in_register_00002029,id)) ||
     (iVar1 = memcmp(&key_pool[0].addr,addr,7), iVar1 != 0)) {
    if (((uint)key_pool[1].id != CONCAT31(in_register_00002029,id)) ||
       (iVar1 = memcmp(&key_pool[1].addr,addr,7), iVar1 != 0)) {
      return (bt_keys *)0x0;
    }
    iVar1 = 1;
  }
  return key_pool + iVar1;
}



bt_keys * bt_keys_find(int type,u8_t id,bt_addr_le_t *addr)

{
  int iVar1;
  undefined3 in_register_0000202d;
  
  if (((((uint)key_pool[0].keys & type) == 0) ||
      ((uint)key_pool[0].id != CONCAT31(in_register_0000202d,id))) ||
     (iVar1 = memcmp(&key_pool[0].addr,addr,7), iVar1 != 0)) {
    if (((((uint)key_pool[1].keys & type) == 0) ||
        ((uint)key_pool[1].id != CONCAT31(in_register_0000202d,id))) ||
       (iVar1 = memcmp(&key_pool[1].addr,addr,7), iVar1 != 0)) {
      return (bt_keys *)0x0;
    }
    iVar1 = 0x84;
  }
  else {
    iVar1 = 0;
  }
  return (bt_keys *)(&key_pool[0].id + iVar1);
}



bt_keys * bt_keys_get_addr(u8_t id,bt_addr_le_t *addr)

{
  uint uVar1;
  bt_keys *pbVar2;
  undefined3 in_register_00002029;
  int iVar3;
  undefined4 local_30;
  undefined2 uStack44;
  undefined uStack42;
  undefined4 uStack40;
  undefined2 uStack36;
  undefined uStack34;
  
  if (((uint)key_pool[0].id == CONCAT31(in_register_00002029,id)) &&
     (iVar3 = memcmp(&key_pool[0].addr,addr,7), iVar3 == 0)) {
    iVar3 = 0;
  }
  else {
    local_30 = 0;
    uStack44 = 0;
    uStack42 = 0;
    iVar3 = memcmp(&key_pool[0].addr,&local_30,7);
    uVar1 = 0;
    if (iVar3 != 0) {
      uVar1 = (uint)(key_pool[0].enc_size != '\0') << 1;
    }
    if (((uint)key_pool[1].id != CONCAT31(in_register_00002029,id)) ||
       (iVar3 = memcmp(&key_pool[1].addr,addr,7), iVar3 != 0)) {
      if (uVar1 == 2) {
        local_30 = 0;
        uStack44 = 0;
        uStack42 = 0;
        iVar3 = memcmp(&key_pool[1].addr,&local_30,7);
        if ((iVar3 == 0) || (key_pool[1].enc_size == '\0')) {
          uVar1 = 1;
        }
        else {
          pbVar2 = key_pool + 1;
          if (key_pool[0].aging_counter <= key_pool[1].aging_counter) {
            pbVar2 = key_pool;
          }
          bt_unpair(pbVar2->id,&pbVar2->addr);
          uStack40 = 0;
          uStack36 = 0;
          uStack34 = 0;
          iVar3 = memcmp(&pbVar2->addr,&uStack40,7);
          if (iVar3 != 0) {
            return (bt_keys *)0x0;
          }
          uVar1 = ((int)pbVar2[-0x80022a].slave_ltk.ediv >> 2) * 0x3e0f83e1;
          if (1 < uVar1) {
            return (bt_keys *)0x0;
          }
        }
      }
      pbVar2 = key_pool + uVar1;
      pbVar2->id = id;
      memcpy(&key_pool[uVar1].addr,addr,7);
      aging_counter_val = aging_counter_val + 1;
      key_pool[uVar1].aging_counter = aging_counter_val;
      last_keys_updated = pbVar2;
      return pbVar2;
    }
    iVar3 = 0x84;
  }
  return (bt_keys *)(&key_pool[0].id + iVar3);
}



void bt_keys_foreach(int type,anon_subr_void_bt_keys_ptr_void_ptr *func,void *data)

{
  if (((uint)key_pool[0].keys & type) != 0) {
    (*func)(key_pool,data);
  }
  if (((uint)key_pool[1].keys & type) != 0) {
                    // WARNING: Could not recover jumptable at 0x23023b1e. Too many branches
                    // WARNING: Treating indirect jump as call
    (*func)((bt_keys *)0x42011dc0,data);
    return;
  }
  return;
}



bt_keys * bt_keys_find(int type,u8_t id,bt_addr_le_t *addr)

{
  int iVar1;
  undefined3 in_register_0000202d;
  
  if (((((uint)key_pool[0].keys & type) == 0) ||
      ((uint)key_pool[0].id != CONCAT31(in_register_0000202d,id))) ||
     (iVar1 = memcmp(&key_pool[0].addr,addr,7), iVar1 != 0)) {
    if (((((uint)key_pool[1].keys & type) == 0) ||
        ((uint)key_pool[1].id != CONCAT31(in_register_0000202d,id))) ||
       (iVar1 = memcmp(&key_pool[1].addr,addr,7), iVar1 != 0)) {
      return (bt_keys *)0x0;
    }
    iVar1 = 0x84;
  }
  else {
    iVar1 = 0;
  }
  return (bt_keys *)(&key_pool[0].id + iVar1);
}



bt_keys * bt_keys_get_type(int type,u8_t id,bt_addr_le_t *addr)

{
  bt_keys *pbVar1;
  
  pbVar1 = bt_keys_find(type,id,addr);
  if ((pbVar1 == (bt_keys *)0x0) && (pbVar1 = bt_keys_get_addr(id,addr), pbVar1 != (bt_keys *)0x0))
  {
    pbVar1->keys = (ushort)type | pbVar1->keys;
  }
  return pbVar1;
}



bt_keys * bt_keys_find_irk(u8_t id,bt_addr_le_t *addr)

{
  _Bool _Var1;
  undefined3 in_register_00002029;
  uint uVar2;
  int iVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  
  uVar2 = CONCAT31(in_register_00002029,id);
  if ((addr->type != '\x01') || (((addr->a).val[5] & 0xc0) != 0x40)) {
    return (bt_keys *)0x0;
  }
  if ((((key_pool[0].keys & 2) == 0) || ((uint)key_pool[0].id != uVar2)) ||
     (iVar3 = memcmp(&addr->a,&key_pool[0].irk.rpa,6), iVar3 != 0)) {
    if ((((key_pool[1].keys & 2) == 0) || ((uint)key_pool[1].id != uVar2)) ||
       (iVar3 = memcmp(&addr->a,&key_pool[1].irk.rpa,6), iVar3 != 0)) {
      if ((((key_pool[0].keys & 2) != 0) && ((uint)key_pool[0].id == uVar2)) &&
         (_Var1 = bt_rpa_irk_matches((u8_t *)&key_pool[0].irk,&addr->a),
         CONCAT31(extraout_var,_Var1) != 0)) {
        iVar3 = 0;
LAB_23023c42:
        memcpy(key_pool[0].irk.rpa.val + iVar3,&addr->a,6);
        return (bt_keys *)(&key_pool[0].id + iVar3);
      }
      if (((key_pool[1].keys & 2) != 0) && ((uint)key_pool[1].id == uVar2)) {
        _Var1 = bt_rpa_irk_matches((u8_t *)&key_pool[1].irk,&addr->a);
        iVar3 = 0x84;
        if (CONCAT31(extraout_var_00,_Var1) != 0) goto LAB_23023c42;
      }
      return (bt_keys *)0x0;
    }
    iVar3 = 0x84;
  }
  else {
    iVar3 = 0;
  }
  return (bt_keys *)(&key_pool[0].id + iVar3);
}



bt_keys * bt_keys_find_addr(u8_t id,bt_addr_le_t *addr)

{
  int iVar1;
  undefined3 in_register_00002029;
  
  if (((uint)key_pool[0].id != CONCAT31(in_register_00002029,id)) ||
     (iVar1 = memcmp(&key_pool[0].addr,addr,7), iVar1 != 0)) {
    if (((uint)key_pool[1].id != CONCAT31(in_register_00002029,id)) ||
       (iVar1 = memcmp(&key_pool[1].addr,addr,7), iVar1 != 0)) {
      return (bt_keys *)0x0;
    }
    iVar1 = 1;
  }
  return key_pool + iVar1;
}



void bt_keys_add_type(bt_keys *keys,int type)

{
  keys->keys = (ushort)type | keys->keys;
  return;
}



void bt_keys_clear(bt_keys *keys)

{
  if ((keys->keys & 2) != 0) {
    bt_id_del(keys);
  }
  memset(keys,0,0x84);
  return;
}



void keys_clear_id(bt_keys *keys,void *data)

{
  if (*(u8_t *)data == keys->id) {
    bt_keys_clear(keys);
    return;
  }
  return;
}



void bt_keys_clear_all(u8_t id)

{
  u8_t auStack17 [13];
  
  auStack17[0] = id;
  bt_keys_foreach(0x3f,keys_clear_id,auStack17);
  return;
}



void bt_keys_update_usage(u8_t id,bt_addr_le_t *addr)

{
  bt_keys *pbVar1;
  
  pbVar1 = bt_keys_find_addr(id,addr);
  if ((pbVar1 != (bt_keys *)0x0) && (last_keys_updated != pbVar1)) {
    aging_counter_val = aging_counter_val + 1;
    last_keys_updated = pbVar1;
    pbVar1->aging_counter = aging_counter_val;
  }
  return;
}



u8_t notify_func(bt_conn *conn,bt_gatt_subscribe_params *params,void *data,u16_t length)

{
  bool bVar1;
  undefined2 in_register_00002036;
  
  bVar1 = params->value != 0;
  if (bVar1) {
    printf("Notification: data length %u\r\n",CONCAT22(in_register_00002036,length));
  }
  else {
    printf("Unsubscribed\r\n");
    params->value_handle = 0;
  }
  return (u8_t)bVar1;
}



void le_param_updated(bt_conn *conn,u16_t interval,u16_t latency,u16_t timeout)

{
  printf("LE conn param updated: int 0x%04x lat %d to %d \r\n");
  return;
}



void ble_set_tx_pwr(char *pcWriteBuffer,int xWriteBufferLen,int argc,char **argv)

{
  char *fmt;
  byte abStack17 [4];
  u8_t power;
  
  if (argc == 2) {
    get_uint8_from_string(argv + 1,abStack17);
    if (0x14 < abStack17[0]) {
      printf("ble_set_tx_pwr, invalid value, value shall be in [0x%x - 0x%x]\r\n",0,0x14);
      return;
    }
    xWriteBufferLen = bt_set_tx_pwr(abStack17[0]);
    if (xWriteBufferLen != 0) {
      printf("ble_set_tx_pwr, Fail to set tx power (err %d)\r\n",xWriteBufferLen);
      return;
    }
    fmt = "ble_set_tx_pwr, Set tx power successfully\r\n";
  }
  else {
    fmt = "Number of Parameters is not correct\r\n";
  }
  printf(fmt,xWriteBufferLen);
  return;
}



void ble_unsubscribe(char *pcWriteBuffer,int xWriteBufferLen,int argc,char **argv)

{
  char *fmt;
  
  if (default_conn == (bt_conn *)0x0) {
    fmt = "Not connected\r\n";
  }
  else {
    xWriteBufferLen = 0x42012000;
    if (subscribe_params.value_handle == 0) {
      fmt = "No subscription found\r\n";
    }
    else {
      xWriteBufferLen =
           bt_gatt_unsubscribe(default_conn,(bt_gatt_subscribe_params *)&subscribe_params);
      if (xWriteBufferLen != 0) {
        printf("Unsubscribe failed (err %d)\r\n",xWriteBufferLen);
        return;
      }
      fmt = "Unsubscribe success\r\n";
    }
  }
  printf(fmt,xWriteBufferLen);
  return;
}



void write_func(bt_conn *conn,u8_t err,bt_gatt_write_params *params)

{
  undefined3 in_register_0000202d;
  
  printf("Write complete: err %u \r\n",CONCAT31(in_register_0000202d,err));
  memset(&write_params,0,0x28);
  return;
}



void ble_exchange_mtu(char *pcWriteBuffer,int xWriteBufferLen,int argc,char **argv)

{
  char *fmt;
  
  if (default_conn == (bt_conn *)0x0) {
    fmt = "Not connected\r\n";
  }
  else {
    exchange_params.func = exchange_func;
    xWriteBufferLen = bt_gatt_exchange_mtu(default_conn,&exchange_params);
    if (xWriteBufferLen != 0) {
      printf("Exchange failed (err %d)\r\n",xWriteBufferLen);
      return;
    }
    fmt = "Exchange pending\r\n";
  }
  printf(fmt,xWriteBufferLen);
  return;
}



void exchange_func(bt_conn *conn,u8_t err,bt_gatt_exchange_params *params)

{
  u16_t uVar1;
  undefined2 extraout_var;
  undefined3 in_register_0000202d;
  char *pcVar2;
  
  if (CONCAT31(in_register_0000202d,err) == 0) {
    pcVar2 = "successful";
  }
  else {
    pcVar2 = "failed";
  }
  uVar1 = bt_gatt_get_mtu(conn);
  printf("Exchange %s MTU Size =%d \r\n",pcVar2,CONCAT22(extraout_var,uVar1));
  return;
}



void ble_auth_pairing_confirm(char *pcWriteBuffer,int xWriteBufferLen,int argc,char **argv)

{
  if (default_conn == (bt_conn *)0x0) {
    printf("Not connected\r\n");
    return;
  }
  bt_conn_auth_pairing_confirm(default_conn);
  return;
}



void ble_auth_passkey_confirm(char *pcWriteBuffer,int xWriteBufferLen,int argc,char **argv)

{
  if (default_conn == (bt_conn *)0x0) {
    printf("Not connected\r\n");
    return;
  }
  bt_conn_auth_passkey_confirm(default_conn);
  return;
}



void ble_auth_cancel(char *pcWriteBuffer,int xWriteBufferLen,int argc,char **argv)

{
  if (default_conn == (bt_conn *)0x0) {
    printf("Not connected\r\n");
    return;
  }
  bt_conn_auth_cancel(default_conn);
  return;
}



void ble_auth(char *pcWriteBuffer,int xWriteBufferLen,int argc,char **argv)

{
  int iVar1;
  char *fmt;
  
  iVar1 = bt_conn_auth_cb_register(&auth_cb_display);
  if (iVar1 == 0) {
    fmt = "Register auth callback successfully\r\n";
  }
  else {
    fmt = "Auth callback has already been registered\r\n";
  }
  printf(fmt);
  return;
}



void ble_security(char *pcWriteBuffer,int xWriteBufferLen,int argc,char **argv)

{
  char *fmt;
  uint8_t local_11 [4];
  u8_t sec_level;
  
  local_11[0] = '\x04';
  if (default_conn == (bt_conn *)0x0) {
    fmt = "Please firstly choose the connection using ble_select_conn\r\n";
  }
  else {
    if (argc == 2) {
      get_uint8_from_string(argv + 1,local_11);
    }
    xWriteBufferLen = bt_conn_set_security(default_conn,local_11[0]);
    if (xWriteBufferLen != 0) {
      printf("Failed to start security, (err %d) \r\n",xWriteBufferLen);
      return;
    }
    fmt = "Start security successfully\r\n";
  }
  printf(fmt,xWriteBufferLen);
  return;
}



void ble_select_conn(char *pcWriteBuffer,int xWriteBufferLen,int argc,char **argv)

{
  char *fmt;
  bt_conn *pbVar1;
  uint8_t auStack32 [4];
  u8_t addr_val [6];
  bt_addr_le_t addr;
  
  if (argc == 3) {
    get_uint8_from_string(argv + 1,addr_val + 4);
    get_bytearray_from_string(argv + 2,auStack32,6);
    reverse_bytearray(auStack32,addr_val + 5,6);
    pbVar1 = bt_conn_lookup_addr_le('\0',(bt_addr_le_t *)(addr_val + 4));
    if (pbVar1 != (bt_conn *)0x0) {
      if (default_conn == (bt_conn *)0x0) {
        default_conn = pbVar1;
        return;
      }
      bt_conn_unref(default_conn);
      default_conn = pbVar1;
      return;
    }
    fmt = "No matching connection found\r\n";
  }
  else {
    fmt = "Number of Parameters is not correct\r\n";
  }
  printf(fmt);
  return;
}



void ble_disconnect(char *pcWriteBuffer,int xWriteBufferLen,int argc,char **argv)

{
  char *fmt;
  bt_conn *conn;
  int iVar1;
  uint8_t uStack33;
  uint8_t auStack32 [3];
  s8_t type;
  u8_t addr_val [6];
  bt_addr_le_t addr;
  
  uStack33 = -1;
  if (argc == 3) {
    get_uint8_from_string(argv + 1,&uStack33);
    get_bytearray_from_string(argv + 2,auStack32,6);
    reverse_bytearray(auStack32,addr_val + 5,6);
    addr_val[4] = uStack33;
    conn = bt_conn_lookup_addr_le('\0',(bt_addr_le_t *)(addr_val + 4));
    if (conn != (bt_conn *)0x0) {
      iVar1 = bt_conn_disconnect(conn,'\x13');
      if (iVar1 == 0) {
        fmt = "Disconnect successfully\r\n";
      }
      else {
        fmt = "Disconnection failed\r\n";
      }
      printf(fmt);
      bt_conn_unref(conn);
      return;
    }
    fmt = "Not connected\r\n";
  }
  else {
    fmt = "Number of Parameters is not correct\r\n";
  }
  printf(fmt);
  return;
}



// WARNING: Variable defined which should be unmapped: param

void ble_connect(char *pcWriteBuffer,int xWriteBufferLen,int argc,char **argv)

{
  int iVar1;
  int iVar2;
  char *fmt;
  bt_conn *pbVar3;
  uint8_t uStack41;
  byte local_28 [3];
  s8_t type;
  u8_t addr_val [6];
  bt_addr_le_t addr;
  bt_le_conn_param param;
  
  uStack41 = -1;
  stack0xffffffe8 = DAT_4200dd00;
  memset(local_28,0,6);
  if (argc == 3) {
    get_uint8_from_string(argv + 1,&uStack41);
    addr_val[4] = uStack41;
    get_bytearray_from_string(argv + 2,local_28,6);
    iVar1 = 0;
    do {
      iVar2 = iVar1 + 1;
      printf("addr[%d]:[0x%x]\r\n",iVar1,(uint)local_28[iVar1]);
      iVar1 = iVar2;
    } while (iVar2 != 6);
    reverse_bytearray(local_28,addr_val + 5,6);
    pbVar3 = bt_conn_create_le((bt_addr_le_t *)(addr_val + 4),(bt_le_conn_param *)(addr.a.val + 3));
    if (pbVar3 == (bt_conn *)0x0) {
      fmt = "Connection failed\r\n";
    }
    else {
      fmt = "Connection pending\r\n";
    }
  }
  else {
    fmt = "Number of Parameters is not correct\r\n";
  }
  printf(fmt);
  return;
}



void ble_stop_advertise(char *pcWriteBuffer,int xWriteBufferLen,int argc,char **argv)

{
  int iVar1;
  char *fmt;
  
  iVar1 = bt_le_adv_stop();
  if (iVar1 == 0) {
    fmt = "Advertising stopped\r\n";
  }
  else {
    fmt = "Failed to stop advertising\r\n";
  }
  printf(fmt);
  return;
}



void ble_get_device_name(char *pcWriteBuffer,int xWriteBufferLen,int argc,char **argv)

{
  char *pcVar1;
  
  pcVar1 = bt_get_name();
  if (pcVar1 != (char *)0x0) {
    printf("device_name: %s\r\n",pcVar1);
    return;
  }
  printf("Failed to read device name\r\n");
  return;
}



// WARNING: Could not reconcile some variable overlaps

void ble_start_advertise(char *pcWriteBuffer,int xWriteBufferLen,int argc,char **argv)

{
  char *fmt;
  u8_t *__s;
  size_t sVar1;
  int iVar2;
  bt_data *sd;
  u8_t auStack52 [4];
  u8_t auStack48 [4];
  u8_t auStack44 [2];
  byte local_2a;
  byte local_29;
  u8_t uStack40;
  u8_t uStack39;
  uint8_t adv_type;
  uint8_t mode;
  bt_le_adv_param param;
  
  if ((argc - 3U & 0xfffffffd) == 0) {
    _adv_type = 0xa0;
    param._0_2_ = 0xf0;
    uStack40 = '\0';
    get_uint8_from_string(argv + 1,&local_2a);
    printf("adv_type 0x%x\r\n",(uint)local_2a);
    if (local_2a == 0) {
      uStack39 = '\v';
    }
    else {
      if (local_2a == 1) {
        uStack39 = '\b';
      }
      else {
        if (local_2a != 2) {
          fmt = "Arg1 is invalid\r\n";
          goto LAB_230241b6;
        }
        uStack39 = '\0';
      }
    }
    get_uint8_from_string(argv + 2,&local_29);
    printf("mode 0x%x\r\n",(uint)local_29);
    if (local_29 < 3) {
      if (local_29 == 0) {
        auStack52[0] = '\x06';
        ad_discov[0].data = auStack52;
      }
      else {
        if (local_29 == 1) {
          auStack48[0] = '\x04';
          ad_discov[0].data = auStack48;
        }
        else {
          auStack44[0] = '\x05';
          ad_discov[0].data = auStack44;
        }
      }
      ad_discov[0]._0_2_ = 0x101;
      __s = (u8_t *)bt_get_name();
      sVar1 = strlen((char *)__s);
      ad_discov[1].type = '\t';
      ad_discov[1].data_len = (u8_t)sVar1;
      ad_discov[1].data = __s;
      if (argc == 5) {
        get_uint16_from_string(argv + 3,(uint16_t *)&adv_type);
        get_uint16_from_string(argv + 4,(uint16_t *)&param);
        printf("interval min 0x%x\r\n",(uint)_adv_type);
        printf("interval max 0x%x\r\n",(uint)param._0_2_);
      }
      if (1 < local_2a) {
        sd = (bt_data *)0x0;
      }
      else {
        sd = ad_discov;
      }
      iVar2 = bt_le_adv_start((bt_le_adv_param *)&uStack40,ad_discov,2,sd,(uint)(1 >= local_2a));
      if (iVar2 != 0) {
        printf("Failed to start advertising (err %d) \r\n",iVar2);
        return;
      }
      fmt = "Advertising started\r\n";
    }
    else {
      fmt = "Arg2 is invalid\r\n";
    }
  }
  else {
    fmt = "Number of Parameters is not correct\r\n";
  }
LAB_230241b6:
  printf(fmt);
  return;
}



void ble_set_adv_channel(char *pcWriteBuffer,int xWriteBufferLen,int argc,char **argv)

{
  char *fmt;
  int iVar1;
  uint8_t auStack17 [4];
  u8_t channel;
  
  auStack17[0] = '\a';
  if (argc == 2) {
    get_uint8_from_string(argv + 1,auStack17);
    iVar1 = set_adv_channel_map(auStack17[0]);
    if (iVar1 == 0) {
      fmt = "Set adv channel success\r\n";
    }
    else {
      fmt = "Failed to Set adv channel\r\n";
    }
  }
  else {
    fmt = "Number of Parameters is not correct\r\n";
  }
  printf(fmt);
  return;
}



void ble_stop_scan(char *pcWriteBuffer,int xWriteBufferLen,int argc,char **argv)

{
  int iVar1;
  
  iVar1 = bt_le_scan_stop();
  if (iVar1 != 0) {
    printf("Stopping scanning failed (err %d)\r\n",iVar1);
    return;
  }
  printf("Scan successfully stopped \r\n");
  return;
}



void ble_disable(char *pcWriteBuffer,int xWriteBufferLen,int argc,char **argv)

{
  int iVar1;
  char *fmt;
  
  iVar1 = bt_disable();
  if (iVar1 == 0) {
    fmt = "Disable bt successfully\r\n";
  }
  else {
    fmt = "Fail to disable bt, there is existed scan/adv/conn event \r\n";
  }
  printf(fmt);
  return;
}



u8_t discover_func(bt_conn *conn,bt_gatt_attr *attr,bt_gatt_discover_params *params)

{
  byte bVar1;
  u8_t uVar2;
  bt_uuid **ppbVar3;
  char acStack56 [4];
  char str [37];
  
  if (attr == (bt_gatt_attr *)0x0) {
    printf("Discover complete\r\n");
    memset(params,0,0x2c);
    uVar2 = '\0';
  }
  else {
    bVar1 = params->type;
    if (bVar1 == 2) {
      ppbVar3 = (bt_uuid **)attr->user_data;
      bt_uuid_to_str(*ppbVar3,acStack56,0x25);
      printf("Include %s found: handle %x, start %x, end %x\r\n",acStack56,(uint)attr->handle,
             (uint)*(ushort *)(ppbVar3 + 1),(uint)*(ushort *)((int)ppbVar3 + 6));
    }
    else {
      if (bVar1 < 2) {
        ppbVar3 = (bt_uuid **)attr->user_data;
        bt_uuid_to_str(*ppbVar3,acStack56,0x25);
        printf("Service %s found: start handle %x, end_handle %x\r\n",acStack56,(uint)attr->handle,
               (uint)*(ushort *)(ppbVar3 + 1));
      }
      else {
        if (bVar1 == 3) {
          ppbVar3 = (bt_uuid **)attr->user_data;
          bt_uuid_to_str(*ppbVar3,acStack56,0x25);
          printf("Characteristic %s found: attr->handle %x  chrc->handle %x \r\n",acStack56,
                 (uint)attr->handle,(uint)*(ushort *)(ppbVar3 + 1));
          bVar1 = *(byte *)((int)ppbVar3 + 6);
          printf("Properties: ");
          if ((bVar1 & 1) != 0) {
            printf("[bcast]\r\n");
          }
          if ((bVar1 & 2) != 0) {
            printf("[read]\r\n");
          }
          if ((bVar1 & 8) != 0) {
            printf("[write]\r\n");
          }
          if ((bVar1 & 4) != 0) {
            printf("[write w/w rsp]\r\n");
          }
          if ((bVar1 & 0x10) != 0) {
            printf("[notify]\r\n");
          }
          if ((bVar1 & 0x20) != 0) {
            printf("[indicate]");
          }
          if ((bVar1 & 0x40) != 0) {
            printf("[auth]\r\n");
          }
          if (-1 < (char)bVar1) {
            return '\x01';
          }
          printf("[ext prop]\r\n");
          return '\x01';
        }
        bt_uuid_to_str(attr->uuid,acStack56,0x25);
        printf("Descriptor %s found: handle %x\r\n",acStack56,(uint)attr->handle);
      }
    }
    uVar2 = '\x01';
  }
  return uVar2;
}



void ble_set_data_len(char *pcWriteBuffer,int xWriteBufferLen,int argc,char **argv)

{
  char *fmt;
  uint16_t uStack20;
  uint16_t uStack18;
  u16_t tx_octets;
  u16_t tx_time;
  
  if (argc == 3) {
    if (default_conn == (bt_conn *)0x0) {
      fmt = "Not connected\r\n";
    }
    else {
      get_uint16_from_string(argv + 1,&uStack20);
      get_uint16_from_string(argv + 2,&uStack18);
      xWriteBufferLen = bt_le_set_data_len(default_conn,uStack20,uStack18);
      if (xWriteBufferLen != 0) {
        printf("ble_set_data_len, LE Set Data Length (err %d)\r\n",xWriteBufferLen);
        return;
      }
      fmt = "ble_set_data_len, LE Set Data Length success\r\n";
    }
  }
  else {
    fmt = "Number of Parameters is not correct\r\n";
  }
  printf(fmt,xWriteBufferLen);
  return;
}



void ble_subscribe(char *pcWriteBuffer,int xWriteBufferLen,int argc,char **argv)

{
  char *fmt;
  
  if (argc == 4) {
    if (default_conn == (bt_conn *)0x0) {
      fmt = "Not connected\r\n";
    }
    else {
      get_uint16_from_string(argv + 1,&subscribe_params.ccc_handle);
      get_uint16_from_string(argv + 2,&subscribe_params.value_handle);
      get_uint16_from_string(argv + 3,&subscribe_params.value);
      subscribe_params.notify = notify_func;
      xWriteBufferLen =
           bt_gatt_subscribe(default_conn,(bt_gatt_subscribe_params *)&subscribe_params);
      if (xWriteBufferLen != 0) {
        printf("Subscribe failed (err %d)\r\n",xWriteBufferLen);
        return;
      }
      fmt = "Subscribed\r\n";
    }
  }
  else {
    fmt = "Number of Parameters is not correct\r\n";
  }
  printf(fmt,xWriteBufferLen);
  return;
}



void ble_write(char *pcWriteBuffer,int xWriteBufferLen,int argc,char **argv)

{
  char *fmt;
  uint array_size;
  
  if (argc == 5) {
    if (default_conn == (bt_conn *)0x0) {
      fmt = "Not connected\r\n";
    }
    else {
      if (write_params.func == (bt_gatt_write_func_t *)0x0) {
        get_uint16_from_string(argv + 1,&write_params.handle);
        get_uint16_from_string(argv + 2,&write_params.offset);
        get_uint16_from_string(argv + 3,&write_params.length);
        array_size = (uint)write_params.length;
        if (0x200 < write_params.length) {
          array_size = 0x200;
        }
        get_bytearray_from_string(argv + 4,gatt_write_buf,array_size);
        write_params.data = gatt_write_buf;
        write_params.length = (u16_t)array_size;
        write_params.func = write_func;
        xWriteBufferLen = bt_gatt_write(default_conn,(bt_gatt_write_params *)&write_params);
        if (xWriteBufferLen != 0) {
          printf("Write failed (err %d)\r\n",xWriteBufferLen);
          return;
        }
        fmt = "Write pending\r\n";
      }
      else {
        fmt = "Write ongoing\r\n";
      }
    }
  }
  else {
    fmt = "Number of Parameters is not correct\r\n";
  }
  printf(fmt,xWriteBufferLen);
  return;
}



void ble_read(char *pcWriteBuffer,int xWriteBufferLen,int argc,char **argv)

{
  char *fmt;
  
  if (argc == 3) {
    if (default_conn == (bt_conn *)0x0) {
      fmt = "Not connected\r\n";
    }
    else {
      get_uint16_from_string(argv + 1,(uint16_t *)&read_params.field_3);
      get_uint16_from_string(argv + 2,(uint16_t *)((int)&read_params.field_3 + 2));
      read_params.func = read_func;
      read_params.handle_count = 1;
      xWriteBufferLen = bt_gatt_read(default_conn,(bt_gatt_read_params *)&read_params);
      if (xWriteBufferLen != 0) {
        printf("Read failed (err %d)\r\n",xWriteBufferLen);
        return;
      }
      fmt = "Read pending\r\n";
    }
  }
  else {
    fmt = "Number of Parameters is not correct\r\n";
  }
  printf(fmt,xWriteBufferLen);
  return;
}



u8_t read_func(bt_conn *conn,u8_t err,bt_gatt_read_params *params,void *data,u16_t length)

{
  int iVar1;
  undefined3 in_register_0000202d;
  undefined2 in_register_0000203a;
  size_t __n;
  byte *pbVar2;
  undefined auStack56 [4];
  char str [22];
  
  __n = CONCAT22(in_register_0000203a,length);
  printf("Read complete: err %u length %u \r\n",CONCAT31(in_register_0000202d,err),__n);
  memset(auStack56,0,0xf);
  if ((__n - 1 & 0xffff) < 0x16) {
    memcpy(auStack56,data,__n);
    printf("device name : %s \r\n",auStack56);
    iVar1 = 0;
    while (iVar1 < (int)__n) {
      pbVar2 = (byte *)((int)data + iVar1);
      iVar1 = iVar1 + 1;
      printf("buf=[0x%x]\r\n",(uint)*pbVar2);
    }
  }
  if (data == (void *)0x0) {
    memset(params,0,0x28);
  }
  return (u8_t)(data != (void *)0x0);
}



_Bool data_cb(bt_data *data,void *user_data)

{
  size_t __n;
  
  if ((uint)data->type - 8 < 2) {
    __n = (size_t)data->data_len;
    if (0x1d < data->data_len) {
      __n = 0x1d;
    }
    memcpy(user_data,data->data,__n);
    return false;
  }
  return true;
}



void ble_discover(char *pcWriteBuffer,int xWriteBufferLen,int argc,char **argv)

{
  char *fmt;
  int iVar1;
  bt_uuid_16 *pbVar2;
  uint8_t auStack33 [4];
  u8_t disc_type;
  
  if (argc == 5) {
    if (default_conn == (bt_conn *)0x0) {
      fmt = "Not connected\r\n";
    }
    else {
      discover_params.func = discover_func;
      discover_params.field_3._0_2_ = 1;
      discover_params.end_handle = 0xffff;
      get_uint8_from_string(argv + 1,auStack33);
      if (auStack33[0] == '\0') {
        discover_params.type = '\0';
        auStack33[0] = discover_params.type;
      }
      else {
        if ((((auStack33[0] != '\x01') && (auStack33[0] != '\x02')) && (auStack33[0] != '\x03')) &&
           (auStack33[0] != '\x04')) {
          fmt = "Invalid discovery type\r\n";
          goto LAB_230248fc;
        }
      }
      discover_params.type = auStack33[0];
      get_uint16_from_string(argv + 2,&uuid.val);
      pbVar2 = &uuid;
      if (uuid.val == 0) {
        pbVar2 = (bt_uuid_16 *)0x0;
      }
      discover_params.uuid = (bt_uuid *)pbVar2;
      get_uint16_from_string(argv + 3,(uint16_t *)&discover_params.field_3);
      get_uint16_from_string(argv + 4,&discover_params.end_handle);
      iVar1 = bt_gatt_discover(default_conn,(bt_gatt_discover_params *)&discover_params);
      if (iVar1 != 0) {
        printf("Discover failed (err %d)\r\n",iVar1);
        return;
      }
      fmt = "Discover pending\r\n";
    }
  }
  else {
    fmt = "Number of Parameters is not correct\r\n";
  }
LAB_230248fc:
  printf(fmt);
  return;
}



void ble_auth_passkey(char *pcWriteBuffer,int xWriteBufferLen,int argc,char **argv)

{
  char *fmt;
  
  if (argc == 2) {
    if (default_conn == (bt_conn *)0x0) {
      fmt = "Not connected\r\n";
    }
    else {
      xWriteBufferLen = atoi(argv[1]);
      if ((uint)xWriteBufferLen < 1000000) {
        bt_conn_auth_passkey_entry(default_conn,xWriteBufferLen);
        return;
      }
      fmt = "Passkey should be between 0-999999\r\n";
    }
  }
  else {
    fmt = "Number of Parameters is not correct\r\n";
  }
  printf(fmt,xWriteBufferLen);
  return;
}



void ble_conn_update(char *pcWriteBuffer,int xWriteBufferLen,int argc,char **argv)

{
  char *fmt;
  undefined auStack24 [2];
  undefined auStack22 [2];
  bt_le_conn_param param;
  
  if (argc == 5) {
    get_uint16_from_string(argv + 1,(uint16_t *)auStack24);
    get_uint16_from_string(argv + 2,(uint16_t *)(auStack24 + 2));
    get_uint16_from_string(argv + 3,(uint16_t *)&param);
    get_uint16_from_string(argv + 4,&param.interval_max);
    xWriteBufferLen = bt_conn_le_param_update(default_conn,(bt_le_conn_param *)auStack24);
    if (xWriteBufferLen != 0) {
      printf("conn update failed (err %d)\r\n",xWriteBufferLen);
      return;
    }
    fmt = "conn update initiated\r\n";
  }
  else {
    fmt = "Number of Parameters is not correct\r\n";
  }
  printf(fmt,xWriteBufferLen);
  return;
}



void ble_unpair(char *pcWriteBuffer,int xWriteBufferLen,int argc,char **argv)

{
  char *fmt;
  int iVar1;
  uint8_t auStack32 [4];
  u8_t addr_val [6];
  bt_addr_le_t addr;
  
  if (argc == 3) {
    get_uint8_from_string(argv + 1,addr_val + 4);
    get_bytearray_from_string(argv + 2,auStack32,6);
    reverse_bytearray(auStack32,addr_val + 5,6);
    iVar1 = bt_unpair('\0',(bt_addr_le_t *)(addr_val + 4));
    if (iVar1 == 0) {
      fmt = "Unpair successfully\r\n";
    }
    else {
      fmt = "Failed to unpair\r\n";
    }
  }
  else {
    fmt = "Number of Parameters is not correct\r\n";
  }
  printf(fmt);
  return;
}



void ble_start_scan(char *pcWriteBuffer,int xWriteBufferLen,int argc,char **argv)

{
  char *fmt;
  uint8_t uStack24;
  uint8_t uStack23;
  uint16_t uStack22;
  bt_le_scan_param scan_param;
  
  if (argc == 5) {
    get_uint8_from_string(argv + 1,&uStack24);
    get_uint8_from_string(argv + 2,&uStack23);
    get_uint16_from_string(argv + 3,&uStack22);
    get_uint16_from_string(argv + 4,(uint16_t *)&scan_param);
    xWriteBufferLen = bt_le_scan_start(&uStack24,device_found);
    if (xWriteBufferLen != 0) {
      printf("Failed to start scan (err %d) \r\n",xWriteBufferLen);
      return;
    }
    fmt = "Start scan successfully \r\n";
  }
  else {
    fmt = "Number of Parameters is not correct\r\n";
  }
  printf(fmt,xWriteBufferLen);
  return;
}



void ble_set_device_name(char *pcWriteBuffer,int xWriteBufferLen,int argc,char **argv)

{
  size_t sVar1;
  int iVar2;
  char *fmt;
  
  sVar1 = strlen(argv[1]);
  if ((sVar1 != 0) && (sVar1 = strlen(argv[1]), sVar1 < 0x1e)) {
    iVar2 = bt_set_name(argv[1]);
    if (iVar2 == 0) {
      fmt = "Set the device name successfully\r\n";
    }
    else {
      fmt = "Failed to set device name\r\n";
    }
    printf(fmt);
    return;
  }
  sVar1 = strlen(argv[1]);
  printf("Invaild lenth(%d)\r\n",sVar1);
  return;
}



void ble_init(char *pcWriteBuffer,int xWriteBufferLen,int argc,char **argv)

{
  char *fmt;
  
  if (ble_inited == false) {
    default_conn = (bt_conn *)0x0;
    bt_conn_cb_register(&conn_callbacks);
    ble_inited = true;
    fmt = "Init successfully \r\n";
  }
  else {
    fmt = "Has initialized \r\n";
  }
  printf(fmt);
  return;
}



// WARNING: Variable defined which should be unmapped: type

int bt_addr_le_to_str(bt_addr_le_t *addr,char *str)

{
  u8_t uVar1;
  int iVar2;
  char *__src;
  char acStack28 [4];
  char type [10];
  
  uVar1 = addr->type;
  if (uVar1 == '\x01') {
    __src = "random";
  }
  else {
    if (uVar1 == '\0') {
      __src = "public";
    }
    else {
      if (uVar1 == '\x02') {
        __src = "public-id";
      }
      else {
        if (uVar1 != '\x03') {
          snprintf(acStack28,10,"0x%02x");
          goto LAB_23024c88;
        }
        __src = "random-id";
      }
    }
  }
  strcpy(acStack28,__src);
LAB_23024c88:
  iVar2 = snprintf(str,0x1e,"%02X:%02X:%02X:%02X:%02X:%02X (%s)",(uint)(addr->a).val[5],
                   (uint)(addr->a).val[4],(uint)(addr->a).val[3],(uint)(addr->a).val[2],
                   (uint)(addr->a).val[1]);
  return iVar2;
}



// WARNING: Variable defined which should be unmapped: name

void device_found(bt_addr_le_t *addr,s8_t rssi,u8_t evtype,net_buf_simple *buf)

{
  undefined3 in_register_0000202d;
  undefined3 in_register_00002031;
  char acStack80 [4];
  char le_addr [30];
  char name [30];
  
  memset(le_addr + 0x1c,0,0x1e);
  bt_data_parse(buf,data_cb,le_addr + 0x1c);
  bt_addr_le_to_str(addr,acStack80);
  printf("[DEVICE]: %s, AD evt type %u, RSSI %i %s \r\n",acStack80,
         CONCAT31(in_register_00002031,evtype),CONCAT31(in_register_0000202d,rssi),le_addr + 0x1c);
  return;
}



void ble_read_local_address(char *pcWriteBuffer,int xWriteBufferLen,int argc,char **argv)

{
  undefined auStack64 [4];
  bt_addr_le_t local_pub_addr;
  bt_addr_le_t local_ram_addr;
  char le_addr [30];
  
  bt_get_local_public_address((bt_addr_le_t *)auStack64);
  bt_addr_le_to_str((bt_addr_le_t *)auStack64,(char *)(local_ram_addr.a.val + 3));
  printf("Local public addr : %s\r\n",local_ram_addr.a.val + 3);
  bt_get_local_ramdon_address((bt_addr_le_t *)(local_pub_addr.a.val + 3));
  bt_addr_le_to_str((bt_addr_le_t *)(local_pub_addr.a.val + 3),(char *)(local_ram_addr.a.val + 3));
  printf("Local random addr : %s\r\n",local_ram_addr.a.val + 3);
  return;
}



void connected(bt_conn *conn,u8_t err)

{
  bt_addr_le_t *addr_00;
  undefined3 in_register_0000202d;
  char acStack48 [4];
  char addr [30];
  
  addr_00 = bt_conn_get_dst(conn);
  bt_addr_le_to_str(addr_00,acStack48);
  if (CONCAT31(in_register_0000202d,err) == 0) {
    printf("Connected: %s \r\n",acStack48);
    if (default_conn == (bt_conn *)0x0) {
      default_conn = conn;
    }
  }
  else {
    printf("Failed to connect to %s (%u) \r\n",acStack48);
  }
  return;
}



void disconnected(bt_conn *conn,u8_t reason)

{
  bt_addr_le_t *addr_00;
  undefined3 in_register_0000202d;
  char acStack48 [4];
  char addr [30];
  
  addr_00 = bt_conn_get_dst(conn);
  bt_addr_le_to_str(addr_00,acStack48);
  printf("Disconnected: %s (reason %u) \r\n",acStack48,CONCAT31(in_register_0000202d,reason));
  if (default_conn == conn) {
    default_conn = (bt_conn *)0x0;
  }
  return;
}



void security_changed(bt_conn *conn,bt_security_t level,bt_security_err err)

{
  bt_addr_le_t *addr_00;
  undefined3 in_register_0000202d;
  char acStack48 [4];
  char addr [30];
  
  addr_00 = bt_conn_get_dst(conn);
  bt_addr_le_to_str(addr_00,acStack48);
  printf("Security changed: %s level %u \r\n",acStack48,CONCAT31(in_register_0000202d,level));
  return;
}



void auth_passkey_display(bt_conn *conn,uint passkey)

{
  bt_addr_le_t *addr_00;
  char acStack48 [4];
  char addr [30];
  
  addr_00 = bt_conn_get_dst(conn);
  bt_addr_le_to_str(addr_00,acStack48);
  printf("passkey_str is: %06u\r\n",passkey);
  return;
}



void auth_passkey_entry(bt_conn *conn)

{
  bt_addr_le_t *addr_00;
  char acStack48 [4];
  char addr [30];
  
  addr_00 = bt_conn_get_dst(conn);
  bt_addr_le_to_str(addr_00,acStack48);
  printf("Enter passkey for %s\r\n",acStack48);
  return;
}



void auth_passkey_confirm(bt_conn *conn,uint passkey)

{
  bt_addr_le_t *addr_00;
  char acStack48 [4];
  char addr [30];
  
  addr_00 = bt_conn_get_dst(conn);
  bt_addr_le_to_str(addr_00,acStack48);
  printf("Confirm passkey for %s: %06u\r\n",acStack48,passkey);
  return;
}



void auth_cancel(bt_conn *conn)

{
  bt_addr_le_t *addr_00;
  char acStack48 [4];
  char addr [30];
  
  addr_00 = bt_conn_get_dst(conn);
  bt_addr_le_to_str(addr_00,acStack48);
  printf("Pairing cancelled: %s\r\n",acStack48);
  return;
}



void auth_pairing_confirm(bt_conn *conn)

{
  bt_addr_le_t *addr_00;
  char acStack48 [4];
  char addr [30];
  
  addr_00 = bt_conn_get_dst(conn);
  bt_addr_le_to_str(addr_00,acStack48);
  printf("Confirm pairing for %s\r\n",acStack48);
  return;
}



void auth_pairing_complete(bt_conn *conn,_Bool bonded)

{
  bt_addr_le_t *addr_00;
  undefined3 in_register_0000202d;
  char *pcVar1;
  char acStack48 [4];
  char addr [30];
  
  addr_00 = bt_conn_get_dst(conn);
  bt_addr_le_to_str(addr_00,acStack48);
  if (CONCAT31(in_register_0000202d,bonded) == 0) {
    pcVar1 = "Paired";
  }
  else {
    pcVar1 = "Bonded";
  }
  printf("%s with %s\r\n",pcVar1,acStack48);
  return;
}



void auth_pairing_failed(bt_conn *conn,bt_security_err reason)

{
  bt_addr_le_t *addr_00;
  char acStack48 [4];
  char addr [30];
  
  addr_00 = bt_conn_get_dst(conn);
  bt_addr_le_to_str(addr_00,acStack48);
  printf("Pairing failed with %s\r\n",acStack48);
  return;
}



void identity_resolved(bt_conn *conn,bt_addr_le_t *rpa,bt_addr_le_t *identity)

{
  char acStack80 [4];
  char addr_identity [30];
  char addr_rpa [30];
  
  bt_addr_le_to_str(identity,acStack80);
  bt_addr_le_to_str(rpa,addr_identity + 0x1c);
  printf("Identity resolved %s -> %s \r\n",addr_identity + 0x1c,acStack80);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void ble_get_all_conn_info(char *pcWriteBuffer,int xWriteBufferLen,int argc,char **argv)

{
  char *pcVar1;
  int iVar2;
  int iVar3;
  char acStack120 [4];
  char le_addr [30];
  bt_conn_info info [2];
  
  iVar3 = bt_conn_get_remote_dev_info((bt_conn_info *)(le_addr + 0x1c));
  if (0 < iVar3) {
    bt_addr_le_to_str(info[0].field_3._4_4_,acStack120);
    printf("ble local device address: %s\r\n",acStack120);
  }
  printf("ble connected devices count: %d\r\n",iVar3);
  iVar2 = 0;
  pcVar1 = le_addr;
  while (iVar2 < iVar3) {
    bt_addr_le_to_str(*(bt_addr_le_t **)(pcVar1 + 0x2c),acStack120);
    printf("[%d]: address %s\r\n",iVar2,acStack120);
    iVar2 = iVar2 + 1;
    pcVar1 = pcVar1 + 0x1c;
  }
  return;
}



// WARNING: Variable defined which should be unmapped: handle
// WARNING: Could not reconcile some variable overlaps

void ble_write_without_rsp(char *pcWriteBuffer,int xWriteBufferLen,int argc,char **argv)

{
  char *fmt;
  int iVar1;
  uint array_size;
  _Bool _Stack21;
  uint16_t uStack20;
  _Bool sign;
  u16_t uStack18;
  u16_t handle;
  u16_t len;
  
  if (argc == 5) {
    if (default_conn != (bt_conn *)0x0) {
      get_uint8_from_string(argv + 1,&_Stack21);
      get_uint16_from_string(argv + 2,&uStack20);
      get_uint16_from_string(argv + 3,(uint16_t *)&stack0xffffffee);
      array_size = (uint)uStack18;
      if (0x200 < uStack18) {
        array_size = 0x200;
      }
      uStack18 = (u16_t)array_size;
      get_bytearray_from_string(argv + 4,gatt_write_buf,array_size);
      iVar1 = bt_gatt_write_without_response_cb
                        (default_conn,uStack20,gatt_write_buf,uStack18,_Stack21,
                         (bt_gatt_complete_func_t *)0x0,(void *)0x0);
      printf("Write Complete (err %d)\r\n",iVar1);
      return;
    }
    fmt = "Not connected\r\n";
  }
  else {
    fmt = "Number of Parameters is not correct\r\n";
  }
  printf(fmt);
  return;
}



int ble_cli_register(void)

{
  return 0;
}



void k_queue_init(k_queue *queue,int size)

{
  QueueHandle_t pQVar1;
  
  pQVar1 = xQueueGenericCreate(size,5,'\0');
  *(QueueHandle_t *)&queue->hdl = pQVar1;
  if (pQVar1 == (QueueHandle_t)0x0) {
    vAssertCalled();
  }
  *(sys_dlist_t **)&(queue->poll_events).field_0 = &queue->poll_events;
  *(sys_dlist_t **)&(queue->poll_events).field_1 = &queue->poll_events;
  return;
}



void k_queue_insert(k_queue *queue,void *prev,void *data)

{
  BaseType_t BVar1;
  void *apvStack20 [4];
  
  apvStack20[0] = data;
  BVar1 = xQueueGenericSend((QueueHandle_t)queue->hdl,apvStack20,0xffffffff,0);
  if (BVar1 != 1) {
    vAssertCalled();
  }
  return;
}



void k_queue_append(k_queue *queue,void *data)

{
  k_queue_insert(queue,(void *)0x0,data);
  return;
}



void k_queue_free(k_queue *queue)

{
  if ((queue != (k_queue *)0x0) && ((QueueHandle_t)queue->hdl != (QueueHandle_t)0x0)) {
    vQueueDelete((QueueHandle_t)queue->hdl);
    queue->hdl = (void *)0x0;
    return;
  }
  printf("Queue is NULL\n\r\n");
  return;
}



void k_queue_prepend(k_queue *queue,void *data)

{
  k_queue_insert(queue,(void *)0x0,data);
  return;
}



void k_queue_append_list(k_queue *queue,void *head,void *tail)

{
  while (head != (void *)0x0) {
    k_queue_append(queue,head);
    head = *(void **)head;
  }
  return;
}



void * k_queue_get(k_queue *queue,s32_t timeout)

{
  BaseType_t BVar1;
  void *pvVar2;
  void *pvStack20;
  void *msg;
  
  pvStack20 = (void *)0x0;
  if (timeout == -1) {
    timeout = 0xffffffff;
  }
  BVar1 = xQueueReceive((QueueHandle_t)queue->hdl,&pvStack20,timeout);
  pvVar2 = (void *)0x0;
  if (BVar1 == 1) {
    pvVar2 = pvStack20;
  }
  return pvVar2;
}



int k_queue_is_empty(k_queue *queue)

{
  UBaseType_t UVar1;
  
  UVar1 = uxQueueMessagesWaiting((QueueHandle_t)queue->hdl);
  return (uint)(UVar1 == 0);
}



int k_queue_get_cnt(k_queue *queue)

{
  UBaseType_t UVar1;
  
  UVar1 = uxQueueMessagesWaiting((QueueHandle_t)queue->hdl);
  return UVar1;
}



int k_sem_init(k_sem *sem,uint initial_count,uint limit)

{
  int iVar1;
  QueueHandle_t pQVar2;
  
  if (sem == (k_sem *)0x0) {
    printf("sem is NULL\n\r\n");
    iVar1 = -0x16;
  }
  else {
    pQVar2 = xQueueCreateCountingSemaphore(limit,initial_count);
    *(QueueHandle_t *)&(sem->sem).hdl = pQVar2;
    *(sys_dlist_t **)&(sem->poll_events).field_0 = &sem->poll_events;
    *(sys_dlist_t **)&(sem->poll_events).field_1 = &sem->poll_events;
    iVar1 = 0;
  }
  return iVar1;
}



int k_sem_take(k_sem *sem,uint32_t timeout)

{
  BaseType_t BVar1;
  
  if (sem != (k_sem *)0x0) {
    BVar1 = xQueueSemaphoreTake((QueueHandle_t)(sem->sem).hdl,timeout);
    return -(uint)(BVar1 != 1);
  }
  return -1;
}



int k_sem_give(k_sem *sem)

{
  int iVar1;
  BaseType_t BVar2;
  
  if (sem == (k_sem *)0x0) {
    printf("sem is NULL\n\r\n");
    iVar1 = -0x16;
  }
  else {
    BVar2 = xQueueGenericSend((QueueHandle_t)(sem->sem).hdl,(void *)0x0,0,0);
    iVar1 = -(uint)(BVar2 != 1);
  }
  return iVar1;
}



int k_sem_delete(k_sem *sem)

{
  QueueHandle_t xQueue;
  int iVar1;
  
  if ((sem == (k_sem *)0x0) ||
     (xQueue = (QueueHandle_t)(sem->sem).hdl, xQueue == (QueueHandle_t)0x0)) {
    printf("sem is NULL\n\r\n");
    iVar1 = -0x16;
  }
  else {
    vQueueDelete(xQueue);
    iVar1 = 0;
    (sem->sem).hdl = (void *)0x0;
  }
  return iVar1;
}



uint k_sem_count_get(k_sem *sem)

{
  UBaseType_t UVar1;
  
  UVar1 = uxQueueMessagesWaiting((QueueHandle_t)(sem->sem).hdl);
  return UVar1;
}



int k_thread_create(k_thread *new_thread,char *name,size_t stack_size,k_thread_entry_t entry,
                   int prio)

{
  xTaskCreate((TaskFunction_t *)entry,name,(uint16_t)(stack_size >> 2),(void *)0x0,prio,
              (TaskHandle_t *)new_thread);
  return -(uint)(new_thread->task == 0);
}



void k_thread_delete(k_thread *new_thread)

{
  if ((new_thread != (k_thread *)0x0) && ((TaskHandle_t)new_thread->task != (TaskHandle_t)0x0)) {
    vTaskDelete((TaskHandle_t)new_thread->task);
    new_thread->task = 0;
    return;
  }
  printf("task is NULL\n\r\n");
  return;
}



int k_yield(void)

{
  ecall();
  return 0;
}



uint irq_lock(void)

{
  vTaskEnterCritical();
  return 1;
}



void irq_unlock(void)

{
  if ((xSchedulerRunning != 0) && (pxCurrentTCB->uxCriticalNesting != 0)) {
    vTaskExitCritical();
    return;
  }
  return;
}



void k_timer_init(k_timer_t_conflict1 *timer,k_timer_handler_t_conflict handle,void *args)

{
  TimerHandle_t ptVar1;
  
  if (timer == (k_timer_t_conflict1 *)0x0) {
    vAssertCalled();
  }
  timer->args = args;
  timer->handler = handle;
  ptVar1 = xTimerCreate("Timer",1000,0,(void *)0x0,(TimerCallbackFunction_t *)handle);
  *(TimerHandle_t *)&(timer->timer).hdl = ptVar1;
  if (ptVar1 == (TimerHandle_t)0x0) {
    vAssertCalled();
    return;
  }
  return;
}



void k_timer_stop(k_timer_t_conflict1 *timer)

{
  BaseType_t BVar1;
  
  if (timer == (k_timer_t_conflict1 *)0x0) {
    vAssertCalled();
  }
  BVar1 = xTimerGenericCommand((TimerHandle_t)(timer->timer).hdl,3,0,(BaseType_t *)0x0,0);
  if (BVar1 != 1) {
    vAssertCalled();
    return;
  }
  return;
}



void k_timer_delete(k_timer_t_conflict1 *timer)

{
  BaseType_t BVar1;
  
  if (timer == (k_timer_t_conflict1 *)0x0) {
    vAssertCalled();
  }
  BVar1 = xTimerGenericCommand((TimerHandle_t)(timer->timer).hdl,5,0,(BaseType_t *)0x0,0);
  if (BVar1 != 1) {
    vAssertCalled();
    return;
  }
  return;
}



longlong k_now_ms(void)

{
  longlong in_fa0;
  
  xTaskGetTickCount();
  return in_fa0;
}



u32_t_conflict k_uptime_get_32(void)

{
  u32_t_conflict in_a0;
  
  k_now_ms();
  return in_a0;
}



void k_timer_start(k_timer_t_conflict1 *timer,uint32_t timeout)

{
  TimerHandle_t xTimer;
  k_timer_t_conflict1 *pkVar1;
  BaseType_t BVar2;
  TickType_t xOptionalValue;
  
  pkVar1 = timer;
  if (timer == (k_timer_t_conflict1 *)0x0) {
    pkVar1 = (k_timer_t_conflict1 *)vAssertCalled();
  }
  timer->timeout = timeout;
  k_now_ms();
  *(k_timer_t_conflict1 **)&timer->start_ms = pkVar1;
  BVar2 = xTimerGenericCommand((TimerHandle_t)(timer->timer).hdl,3,0,(BaseType_t *)0x0,0);
  if (BVar2 != 1) {
    vAssertCalled();
  }
  BVar2 = xTimerGenericCommand
                    ((TimerHandle_t)(timer->timer).hdl,4,(timeout * 1000) / 1000,(BaseType_t *)0x0,0
                    );
  if (BVar2 != 1) {
    vAssertCalled();
  }
  xTimer = (TimerHandle_t)(timer->timer).hdl;
  xOptionalValue = xTaskGetTickCount();
  BVar2 = xTimerGenericCommand(xTimer,1,xOptionalValue,(BaseType_t *)0x0,0);
  if (BVar2 != 1) {
    vAssertCalled();
    return;
  }
  return;
}



void k_get_random_byte_array(uint8_t *buf,size_t len)

{
  uint8_t *puVar1;
  int iVar2;
  
  puVar1 = buf + len;
  while (buf != puVar1) {
    iVar2 = bl_rand();
    *buf = (uint8_t)iVar2;
    buf = buf + 1;
  }
  return;
}



void * k_malloc(size_t xWantedSize)

{
  size_t sVar1;
  size_t sVar2;
  BlockLink_t *pBVar3;
  A_BLOCK_LINK *pAVar4;
  BlockLink_t *pxBlockToInsert;
  uint uVar5;
  uint uVar6;
  
  if (pxEnd == (BlockLink_t *)0x0) {
    vAssertCalled();
  }
  vTaskSuspendAll();
  sVar2 = xFreeBytesRemaining;
  sVar1 = xBlockAllocatedBit;
  if (((xBlockAllocatedBit & xWantedSize) == 0) && (xWantedSize != 0)) {
    uVar6 = xWantedSize + 8;
    if ((uVar6 & 7) != 0) {
      uVar6 = (uVar6 & 0xfffffff8) + 8;
    }
    if ((uVar6 != 0) && (uVar6 <= xFreeBytesRemaining)) {
      pAVar4 = xStart.pxNextFreeBlock;
      pBVar3 = &xStart;
      do {
        pxBlockToInsert = pBVar3;
        pBVar3 = (BlockLink_t *)pAVar4;
        if (uVar6 <= pBVar3->xBlockSize) break;
        pAVar4 = pBVar3->pxNextFreeBlock;
      } while (pBVar3->pxNextFreeBlock != (A_BLOCK_LINK *)0x0);
      if (pxEnd != pBVar3) {
        pAVar4 = pxBlockToInsert->pxNextFreeBlock;
        pxBlockToInsert->pxNextFreeBlock = pBVar3->pxNextFreeBlock;
        uVar5 = pBVar3->xBlockSize;
        pAVar4 = pAVar4 + 1;
        if (0x10 < uVar5 - uVar6) {
          pxBlockToInsert = (BlockLink_t *)((int)&pBVar3->pxNextFreeBlock + uVar6);
          pxBlockToInsert->xBlockSize = uVar5 - uVar6;
          pBVar3->xBlockSize = uVar6;
          prvInsertBlockIntoFreeList(pxBlockToInsert);
          uVar5 = pBVar3->xBlockSize;
        }
        xFreeBytesRemaining = sVar2 - uVar5;
        if (xFreeBytesRemaining < xMinimumEverFreeBytesRemaining) {
          xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
        }
        pBVar3->xBlockSize = sVar1 | uVar5;
        pBVar3->pxNextFreeBlock = (A_BLOCK_LINK *)0x0;
        xTaskResumeAll();
        if (pAVar4 != (A_BLOCK_LINK *)0x0) {
          return pAVar4;
        }
        goto LAB_230359be;
      }
    }
  }
  xTaskResumeAll();
LAB_230359be:
  vApplicationMallocFailedHook();
  return (void *)0x0;
}



void k_free(void *pv)

{
  uint uVar1;
  
  if (pv == (void *)0x0) {
    return;
  }
  uVar1 = *(uint *)((int)pv + -4);
  if ((uVar1 & xBlockAllocatedBit) == 0) {
    vAssertCalled();
    if (*(int *)((int)pv + -8) == 0) {
      uVar1 = *(uint *)((int)pv + -4);
      if ((uVar1 & xBlockAllocatedBit) == 0) {
        return;
      }
      goto LAB_23035ace;
    }
  }
  else {
    if (*(int *)((int)pv + -8) == 0) goto LAB_23035ace;
  }
  vAssertCalled();
  uVar1 = *(uint *)((int)pv + -4);
  if (((uVar1 & xBlockAllocatedBit) == 0) || (*(int *)((int)pv + -8) != 0)) {
    return;
  }
LAB_23035ace:
  *(uint *)((int)pv + -4) = ~xBlockAllocatedBit & uVar1;
  vTaskSuspendAll();
  xFreeBytesRemaining = *(int *)((int)pv + -4) + xFreeBytesRemaining;
  prvInsertBlockIntoFreeList((BlockLink_t *)((int)pv + -8));
  xTaskResumeAll();
  return;
}



int atomic_cas(atomic_t *target,atomic_val_t old_value,atomic_val_t new_value)

{
  int iVar1;
  
  irq_lock();
  iVar1 = *target;
  if (iVar1 == old_value) {
    *target = new_value;
  }
  irq_unlock();
  return (uint)(iVar1 == old_value);
}



atomic_val_t atomic_inc(atomic_t *target)

{
  int iVar1;
  
  irq_lock();
  iVar1 = *target;
  *target = iVar1 + 1;
  irq_unlock();
  return iVar1;
}



atomic_val_t atomic_dec(atomic_t *target)

{
  int iVar1;
  
  irq_lock();
  iVar1 = *target;
  *target = iVar1 + -1;
  irq_unlock();
  return iVar1;
}



atomic_val_t atomic_get(atomic_t *target)

{
  return *target;
}



atomic_val_t atomic_set(atomic_t *target,atomic_val_t value)

{
  atomic_t aVar1;
  
  irq_lock();
  aVar1 = *target;
  *target = value;
  irq_unlock();
  return aVar1;
}



atomic_val_t atomic_clear(atomic_t *target)

{
  atomic_t aVar1;
  
  irq_lock();
  aVar1 = *target;
  *target = 0;
  irq_unlock();
  return aVar1;
}



atomic_val_t atomic_or(atomic_t *target,atomic_val_t value)

{
  uint uVar1;
  
  irq_lock();
  uVar1 = *target;
  *target = value | uVar1;
  irq_unlock();
  return uVar1;
}



atomic_val_t atomic_and(atomic_t *target,atomic_val_t value)

{
  uint uVar1;
  
  irq_lock();
  uVar1 = *target;
  *target = value & uVar1;
  irq_unlock();
  return uVar1;
}



void fixed_data_unref(net_buf *buf,u8_t *data)

{
  return;
}



net_buf_pool * net_buf_pool_get(int id)

{
  return &acl_tx_pool + id;
}



int net_buf_id(net_buf *buf)

{
  return (int)((int)buf - (int)(&acl_tx_pool)[buf->pool_id].__bufs) >> 5;
}



u8_t * fixed_data_alloc(net_buf *buf,size_t *size,s32_t timeout)

{
  uint *puVar1;
  int iVar2;
  uint uVar3;
  
  puVar1 = (uint *)((&acl_tx_pool)[buf->pool_id].alloc)->alloc_data;
  uVar3 = *size;
  if (*puVar1 < *size) {
    uVar3 = *puVar1;
  }
  *size = uVar3;
  iVar2 = net_buf_id(buf);
  return (u8_t *)(iVar2 * *puVar1 + puVar1[1]);
}



// WARNING: Could not reconcile some variable overlaps

net_buf * net_buf_alloc_len(net_buf_pool *pool,size_t size,s32_t timeout)

{
  ushort uVar1;
  net_buf *data;
  u32_t_conflict uVar2;
  uint uVar3;
  u32_t_conflict uVar4;
  u8_t *puVar5;
  size_t asStack36 [2];
  
  asStack36[0] = size;
  uVar2 = k_uptime_get_32();
  uVar3 = irq_lock();
  if (pool->uninit_count == 0) {
    irq_unlock();
    data = (net_buf *)k_queue_get((k_queue *)pool,timeout);
    if (data == (net_buf *)0x0) {
      return (net_buf *)0x0;
    }
  }
  else {
    if ((pool->uninit_count < pool->buf_count) &&
       (data = (net_buf *)k_queue_get((k_queue *)pool,0), data != (net_buf *)0x0)) {
      irq_unlock(uVar3);
    }
    else {
      uVar1 = pool->uninit_count;
      pool->uninit_count = uVar1 - 1;
      irq_unlock(uVar3);
      data = pool->__bufs + ((uint)pool->buf_count - (uint)uVar1);
      data->pool_id = (char)((int)&pool[-0x25b759e].__bufs >> 2) * -0x49;
    }
  }
  if (asStack36[0] == 0) {
    *(undefined4 *)((int)&data->field_4 + 8) = 0;
  }
  else {
    if (1 < timeout + 1U) {
      uVar4 = k_uptime_get_32();
      uVar3 = uVar4 - uVar2;
      if ((uint)timeout < uVar4 - uVar2) {
        uVar3 = timeout;
      }
      timeout = timeout - uVar3;
    }
    puVar5 = (*((&acl_tx_pool)[data->pool_id].alloc)->cb->alloc)(data,asStack36,timeout);
    *(u8_t **)((int)&data->field_4 + 8) = puVar5;
    if (puVar5 == (u8_t *)0x0) {
      k_queue_prepend((k_queue *)(&acl_tx_pool + data->pool_id),data);
      return (net_buf *)0x0;
    }
  }
  data->field_0 = 0;
  *(undefined2 *)&data->ref = 1;
  *(undefined2 *)((int)&data->field_4 + 4) = 0;
  *(undefined2 *)((int)&data->field_4 + 6) = (undefined2)asStack36[0];
  *(undefined4 *)&data->field_4 = *(undefined4 *)((int)&data->field_4 + 8);
  return data;
}



net_buf * net_buf_alloc_fixed(net_buf_pool *pool,s32_t timeout)

{
  net_buf *pnVar1;
  
  pnVar1 = net_buf_alloc_len(pool,*(size_t *)pool->alloc->alloc_data,timeout);
  return pnVar1;
}



net_buf * net_buf_get(k_fifo *fifo,s32_t timeout)

{
  net_buf *pnVar1;
  net_buf *pnVar2;
  net_buf *pnVar3;
  
  pnVar2 = (net_buf *)k_queue_get((k_queue *)fifo,timeout);
  pnVar1 = pnVar2;
  if (pnVar2 != (net_buf *)0x0) {
    while ((pnVar1->flags & 1) != 0) {
      pnVar3 = (net_buf *)k_queue_get((k_queue *)fifo,0);
      *(net_buf **)&pnVar1->field_0 = pnVar3;
      pnVar1->flags = pnVar1->flags & 0xfe;
      pnVar1 = pnVar3;
    }
    pnVar1->field_0 = 0;
  }
  return pnVar2;
}



void net_buf_simple_reserve(net_buf_simple *buf,size_t reserve)

{
  buf->data = buf->__buf + reserve;
  return;
}



void net_buf_put(k_fifo *fifo,net_buf *buf)

{
  net_buf *tail;
  
  tail = buf;
  while ((net_buf *)tail->field_0 != (net_buf *)0x0) {
    tail->flags = tail->flags | 1;
    tail = (net_buf *)tail->field_0;
  }
  k_queue_append_list((k_queue *)fifo,buf,tail);
  return;
}



void net_buf_unref(net_buf *buf)

{
  byte bVar1;
  u8_t *puVar2;
  u8_t uVar3;
  net_buf *pnVar4;
  
  while( true ) {
    if (buf == (net_buf *)0x0) {
      return;
    }
    pnVar4 = (net_buf *)buf->field_0;
    uVar3 = buf->ref + -1;
    buf->ref = uVar3;
    if (uVar3 != '\0') break;
    puVar2 = *(u8_t **)((int)&buf->field_4 + 8);
    if (puVar2 != (u8_t *)0x0) {
      if ((buf->flags & 2) == 0) {
        (*((&acl_tx_pool)[buf->pool_id].alloc)->cb->unref)(buf,puVar2);
      }
      *(undefined4 *)((int)&buf->field_4 + 8) = 0;
    }
    bVar1 = buf->pool_id;
    *(undefined4 *)&buf->field_4 = 0;
    buf->field_0 = 0;
    if ((&acl_tx_pool)[bVar1].destroy == (anon_subr_void_net_buf_ptr_for_destroy *)0x0) {
      k_queue_prepend((k_queue *)(&acl_tx_pool + bVar1),buf);
    }
    else {
      (*(&acl_tx_pool)[bVar1].destroy)(buf);
    }
    buf = pnVar4;
    if (&acl_tx_pool + bVar1 == &hci_rx_pool) {
      bl_handle_queued_msg();
      return;
    }
  }
  return;
}



net_buf * net_buf_ref(net_buf *buf)

{
  buf->ref = buf->ref + '\x01';
  return buf;
}



void net_buf_frag_insert(net_buf *parent,net_buf *frag)

{
  net_buf *pnVar1;
  net_buf *pnVar2;
  
  pnVar1 = frag;
  if (parent->field_0 != 0) {
    do {
      pnVar2 = pnVar1;
      pnVar1 = (net_buf *)pnVar2->field_0;
    } while (pnVar1 != (net_buf *)0x0);
    pnVar2->field_0 = parent->field_0;
  }
  *(net_buf **)&parent->field_0 = frag;
  return;
}



net_buf * net_buf_frag_add(net_buf *head,net_buf *frag)

{
  net_buf *parent;
  net_buf *pnVar1;
  
  pnVar1 = head;
  if (head != (net_buf *)0x0) {
    do {
      parent = pnVar1;
      pnVar1 = (net_buf *)parent->field_0;
    } while (pnVar1 != (net_buf *)0x0);
    net_buf_frag_insert(parent,frag);
    return head;
  }
  frag->ref = frag->ref + '\x01';
  return frag;
}



net_buf * net_buf_frag_del(net_buf *parent,net_buf *frag)

{
  net_buf *pnVar1;
  
  if (parent != (net_buf *)0x0) {
    parent->field_0 = frag->field_0;
  }
  pnVar1 = (net_buf *)frag->field_0;
  frag->field_0 = 0;
  net_buf_unref(frag);
  return pnVar1;
}



void * net_buf_simple_add(net_buf_simple *buf,size_t len)

{
  ushort uVar1;
  
  uVar1 = buf->len;
  buf->len = (short)len + uVar1;
  return buf->data + uVar1;
}



void * net_buf_simple_add_mem(net_buf_simple *buf,void *mem,size_t len)

{
  ushort uVar1;
  void *pvVar2;
  
  uVar1 = buf->len;
  buf->len = uVar1 + (short)len;
  pvVar2 = memcpy(buf->data + uVar1,mem,len);
  return pvVar2;
}



u8_t * net_buf_simple_add_u8(net_buf_simple *buf,u8_t val)

{
  ushort uVar1;
  u8_t *puVar2;
  
  uVar1 = buf->len;
  puVar2 = buf->data;
  buf->len = uVar1 + 1;
  puVar2[uVar1] = val;
  return puVar2 + uVar1;
}



void net_buf_simple_add_le16(net_buf_simple *buf,u16_t val)

{
  ushort uVar1;
  u8_t *puVar2;
  
  uVar1 = buf->len;
  puVar2 = buf->data;
  buf->len = uVar1 + 2;
  puVar2[uVar1] = (u8_t)val;
  (puVar2 + uVar1)[1] = (u8_t)(val >> 8);
  return;
}



void * net_buf_simple_push(net_buf_simple *buf,size_t len)

{
  u8_t *puVar1;
  
  puVar1 = buf->data;
  buf->data = puVar1 + -len;
  buf->len = (short)len + buf->len;
  return puVar1 + -len;
}



void net_buf_simple_push_le16(net_buf_simple *buf,u16_t val)

{
  u8_t *puVar1;
  
  puVar1 = buf->data;
  buf->data = puVar1 + -2;
  buf->len = buf->len + 2;
  puVar1[-2] = (u8_t)val;
  puVar1[-1] = (u8_t)(val >> 8);
  return;
}



void * net_buf_simple_pull(net_buf_simple *buf,size_t len)

{
  u8_t *puVar1;
  
  buf->len = buf->len - (short)len;
  puVar1 = buf->data;
  buf->data = puVar1 + len;
  return puVar1 + len;
}



void * net_buf_simple_pull_mem(net_buf_simple *buf,size_t len)

{
  u8_t *puVar1;
  
  puVar1 = buf->data;
  buf->len = buf->len - (short)len;
  buf->data = puVar1 + len;
  return puVar1;
}



u8_t net_buf_simple_pull_u8(net_buf_simple *buf)

{
  u8_t uVar1;
  
  uVar1 = *buf->data;
  net_buf_simple_pull(buf,1);
  return uVar1;
}



u16_t net_buf_simple_pull_le16(net_buf_simple *buf)

{
  u16_t uVar1;
  
  uVar1 = *(u16_t *)buf->data;
  net_buf_simple_pull(buf,2);
  return uVar1;
}



size_t net_buf_simple_headroom(net_buf_simple *buf)

{
  return (size_t)(buf->data + -(int)buf->__buf);
}



size_t net_buf_simple_tailroom(net_buf_simple *buf)

{
  return ((uint)buf->size - (uint)buf->len) - (int)(buf->data + -(int)buf->__buf);
}



size_t net_buf_append_bytes
                 (net_buf *buf,size_t len,void *value,s32_t timeout,
                 net_buf_allocator_cb *allocate_cb,void *user_data)

{
  net_buf *pnVar1;
  uint len_00;
  net_buf *frag;
  size_t sVar2;
  
  pnVar1 = buf;
  do {
    frag = pnVar1;
    pnVar1 = (net_buf *)frag->field_0;
  } while ((net_buf *)frag->field_0 != (net_buf *)0x0);
  sVar2 = 0;
  while( true ) {
    len_00 = net_buf_simple_tailroom((net_buf_simple *)&frag->field_4);
    if (len < len_00) {
      len_00 = len;
    }
    len_00 = len_00 & 0xffff;
    len = len - len_00;
    net_buf_simple_add_mem((net_buf_simple *)&frag->field_4,value,len_00);
    sVar2 = sVar2 + len_00;
    value = (void *)((int)value + len_00);
    if ((len == 0) || (frag = (*allocate_cb)(timeout,user_data), frag == (net_buf *)0x0)) break;
    net_buf_frag_add(buf,frag);
  }
  return sVar2;
}



char * bt_hex_real(void *buf,size_t len)

{
  char "0123456789abcdef" [17];
  char str [128];
  byte *pbVar1;
  char *pcVar2;
  
  if (0x3f < len) {
    len = 0x3f;
  }
  pbVar1 = (byte *)buf;
  pcVar2 = (char *)&ram0x42012110;
  while (pbVar1 != (byte *)((int)buf + len)) {
    *pcVar2 = "0123456789abcdef"[*pbVar1 >> 4];
    pcVar2[1] = *(char *)(((uint)*pbVar1 & 0xf) + 0x23076794);
    pbVar1 = pbVar1 + 1;
    pcVar2 = pcVar2 + 2;
  }
  *(undefined *)(len * 2 + 0x42012110) = 0;
  return (char *)0x42012110;
}



// WARNING: Variable defined which should be unmapped: type

char * bt_addr_le_str_real(bt_addr_le_t *addr)

{
  u8_t uVar1;
  char str [30];
  char *__src;
  char acStack28 [4];
  char type [10];
  
  uVar1 = addr->type;
  if (uVar1 == '\x01') {
    __src = "random";
  }
  else {
    if (uVar1 == '\0') {
      __src = "public";
    }
    else {
      if (uVar1 == '\x02') {
        __src = "public-id";
      }
      else {
        if (uVar1 != '\x03') {
          snprintf(acStack28,10,"0x%02x");
          goto LAB_23025aaa;
        }
        __src = "random-id";
      }
    }
  }
  strcpy(acStack28,__src);
LAB_23025aaa:
  snprintf((char *)&ram0x42012190,0x1e,"%02X:%02X:%02X:%02X:%02X:%02X (%s)",(uint)(addr->a).val[5],
           (uint)(addr->a).val[4],(uint)(addr->a).val[3],(uint)(addr->a).val[2],
           (uint)(addr->a).val[1]);
  return (char *)0x42012190;
}



// WARNING: Type propagation algorithm not settling

_Bool polling_events(k_poll_event *events,int num_events,s32_t timeout,int *last_registered)

{
  bool bVar1;
  int iVar2;
  uint uVar3;
  k_poll_event *pkVar4;
  int iVar5;
  uint uVar6;
  k_poll_event *pkVar7;
  
  iVar2 = 0;
  bVar1 = true;
  pkVar7 = events;
  do {
    if (num_events <= iVar2) {
      return (_Bool)bVar1;
    }
    uVar3 = irq_lock();
    uVar6 = *(uint *)&pkVar7->field_0xc >> 8 & 0xf;
    if (uVar6 == 2) {
      uVar6 = k_sem_count_get((k_sem *)pkVar7->field_7);
      if (uVar6 != 0) {
        uVar6 = 3;
        goto LAB_23025bcc;
      }
LAB_23025b8a:
      if ((timeout != 0) && (bVar1)) {
        uVar6 = *(uint *)&pkVar7->field_0xc >> 8 & 0xf;
        if ((uVar6 == 2) || (uVar6 == 3)) {
          iVar5 = pkVar7->field_7;
          (pkVar7->_node).field_0 = iVar5 + 4;
          pkVar4 = *(k_poll_event **)(iVar5 + 8);
          *(k_poll_event **)&(pkVar7->_node).field_1 = pkVar4;
          *(k_poll_event **)&pkVar4->_node = events + iVar2;
          *(k_poll_event **)(iVar5 + 8) = events + iVar2;
        }
        else {
          if (uVar6 == 1) {
            iVar5 = pkVar7->field_7;
            (pkVar7->_node).field_0 = iVar5;
            pkVar4 = *(k_poll_event **)(iVar5 + 4);
            *(k_poll_event **)&(pkVar7->_node).field_1 = pkVar4;
            *(k_poll_event **)&pkVar4->_node = events + iVar2;
            *(k_poll_event **)(iVar5 + 4) = events + iVar2;
          }
        }
        pkVar7->poller = (_poller *)0x0;
        *last_registered = *last_registered + 1;
      }
    }
    else {
      if (uVar6 == 3) {
        iVar5 = k_queue_is_empty((k_queue *)pkVar7->field_7);
        if (iVar5 == 0) {
          uVar6 = 4;
          goto LAB_23025bcc;
        }
        goto LAB_23025b8a;
      }
      if ((uVar6 != 1) || (uVar6 = 2, *(int *)(pkVar7->field_7 + 8) == 0)) goto LAB_23025b8a;
LAB_23025bcc:
      pkVar7->poller = (_poller *)0x0;
      bVar1 = false;
      *(uint *)&pkVar7->field_0xc =
           (*(uint *)&pkVar7->field_0xc >> 0xc & 0xf | uVar6) << 0xc |
           *(uint *)&pkVar7->field_0xc & 0xffff0fff;
    }
    irq_unlock(uVar3);
    iVar2 = iVar2 + 1;
    pkVar7 = pkVar7 + 1;
  } while( true );
}



void k_poll_event_init(k_poll_event *event,u32_t_conflict type,int mode,void *obj)

{
  event->poller = (_poller *)0x0;
  *(uint *)&event->field_0xc =
       *(uint *)&event->field_0xc & 0xff | (type & 0xf) << 8 | (mode & 1U) << 0x10;
  *(void **)&event->field_7 = obj;
  return;
}



int k_poll(k_poll_event *events,int num_events,s32_t timeout)

{
  int iVar1;
  _Bool _Var2;
  undefined3 extraout_var;
  uint uVar3;
  uint uVar4;
  int iVar5;
  int iStack36;
  int last_registered;
  
  iStack36 = -1;
  _Var2 = polling_events(events,num_events,timeout,&iStack36);
  if (CONCAT31(extraout_var,_Var2) != 0) {
    k_sem_take(&g_poll_sem,timeout);
    iStack36 = -1;
    polling_events(events,num_events,timeout,&iStack36);
  }
  uVar3 = irq_lock();
  events = events + iStack36;
  iVar1 = iStack36;
  while (-1 < iVar1) {
    events->poller = (_poller *)0x0;
    uVar4 = *(uint *)&events->field_0xc >> 8 & 0xf;
    if (((uVar4 == 2) || (uVar4 == 3)) || (uVar4 == 1)) {
      iVar5 = (events->_node).field_0;
      *(int *)(events->_node).field_1 = iVar5;
      *(undefined4 *)(iVar5 + 4) = (events->_node).field_1;
    }
    irq_unlock();
    irq_lock();
    iVar1 = iVar1 + -1;
    events = events + -1;
  }
  irq_unlock(uVar3);
  return 0;
}



int k_poll_signal_raise(k_poll_signal *signal,int result)

{
  uint uVar1;
  int iVar2;
  k_poll_signal *pkVar3;
  
  uVar1 = irq_lock();
  signal->signaled = 1;
  pkVar3 = (k_poll_signal *)(signal->poll_events).field_0;
  signal->result = result;
  if (signal != pkVar3) {
    iVar2 = (pkVar3->poll_events).field_0;
    *(int *)(pkVar3->poll_events).field_1 = iVar2;
    *(undefined4 *)(iVar2 + 4) = (pkVar3->poll_events).field_1;
    pkVar3->signaled = 0;
    pkVar3->result = pkVar3->result | 0x2000;
    k_sem_give(&g_poll_sem);
  }
  irq_unlock(uVar1);
  return 0;
}



_Bool bt_rpa_irk_matches(u8_t *irk,bt_addr_t *addr)

{
  bool bVar1;
  int iVar2;
  undefined auStack36 [4];
  u8_t hash [3];
  undefined uStack29;
  u8_t res [16];
  
  memcpy(hash,addr->val + 3,3);
  memset(&uStack29,0,0xd);
  iVar2 = bt_encrypt_le(irk,hash,hash);
  if (iVar2 == 0) {
    memcpy(auStack36,hash,3);
    iVar2 = memcmp(addr,auStack36,3);
    bVar1 = iVar2 == 0;
  }
  else {
    bVar1 = false;
  }
  return (_Bool)bVar1;
}



void k_work_submit_to_queue(k_work_q *work_q,k_work *work)

{
  uint uVar1;
  
  uVar1 = atomic_or(work->flags,1);
  if ((uVar1 & 1) == 0) {
    k_queue_append((k_queue *)work_q,work);
    return;
  }
  return;
}



void work_queue_main(void *p1)

{
  void *pvVar1;
  uint uVar2;
  
  do {
    pvVar1 = k_queue_get((k_queue *)&g_work_queue_main,-1);
    uVar2 = atomic_and((atomic_t *)((int)pvVar1 + 8),-2);
    if ((uVar2 & 1) != 0) {
      (**(code **)((int)pvVar1 + 4))(pvVar1,*(code **)((int)pvVar1 + 4));
    }
    k_yield();
  } while( true );
}



int k_work_q_start(void)

{
  int iVar1;
  
  timer_records[0].timer = (void *)0x0;
  timer_records[0].delay_work = (k_delayed_work *)0x0;
  timer_records[1].timer = (void *)0x0;
  timer_records[1].delay_work = (k_delayed_work *)0x0;
  timer_records[2].timer = (void *)0x0;
  timer_records[2].delay_work = (k_delayed_work *)0x0;
  timer_records[3].timer = (void *)0x0;
  timer_records[3].delay_work = (k_delayed_work *)0x0;
  timer_records[4].timer = (void *)0x0;
  timer_records[4].delay_work = (k_delayed_work *)0x0;
  k_queue_init((k_queue *)&g_work_queue_main,0x14);
  iVar1 = k_thread_create(&work_q_thread,"work_q_thread",0x600,work_queue_main,0x1e);
  return iVar1;
}



int k_work_init(k_work *work,k_work_handler_t *handler)

{
  atomic_and(work->flags,-2);
  work->handler = handler;
  return 0;
}



void k_work_submit(k_work *work)

{
  k_work_submit_to_queue(&g_work_queue_main,work);
  return;
}



void k_delayed_work_init(k_delayed_work *work,k_work_handler_t *handler)

{
  k_work_init((k_work *)work,handler);
  k_timer_init((k_timer_t_conflict1 *)&work->timer,work_timeout,work);
  work->work_q = (k_work_q *)0x0;
  return;
}



void k_delayed_work_del_timer(k_delayed_work *work)

{
  if ((work != (k_delayed_work *)0x0) && ((work->timer).timer.hdl != (void *)0x0)) {
    k_timer_delete((k_timer_t_conflict1 *)&work->timer);
    (work->timer).timer.hdl = (void *)0x0;
    return;
  }
  return;
}



int add_timer_record(k_delayed_work *delay_work)

{
  _snode *p_Var1;
  timer_rec_d *ptVar2;
  timer_rec_d *ptVar3;
  int iVar4;
  
  p_Var1 = (_snode *)(delay_work->timer).timer.hdl;
  ptVar2 = timer_records;
  ptVar3 = timer_records;
  do {
    if ((((bt_conn_tx *)ptVar3)->node).next == p_Var1) {
      return 0;
    }
    ptVar3 = (timer_rec_d *)&((bt_conn_tx *)ptVar3)->user_data;
  } while ((bt_conn_tx *)ptVar3 != conn_tx);
  iVar4 = 0;
  do {
    if ((ptVar2->timer).hdl == (void *)0x0) {
      *(_snode **)&timer_records[iVar4].timer.hdl = p_Var1;
      timer_records[iVar4].delay_work = delay_work;
      return 0;
    }
    iVar4 = iVar4 + 1;
    ptVar2 = ptVar2 + 1;
  } while (iVar4 != 5);
  return -1;
}



int remv_timer_record(k_delayed_work *delay_work)

{
  timer_rec_d *ptVar1;
  int iVar2;
  
  ptVar1 = timer_records;
  iVar2 = 0;
  do {
    if ((ptVar1->timer).hdl == (delay_work->timer).timer.hdl) {
      timer_records[iVar2].timer.hdl = (void *)0x0;
      return 0;
    }
    iVar2 = iVar2 + 1;
    ptVar1 = ptVar1 + 1;
  } while (iVar2 != 5);
  return 0;
}



int k_delayed_work_cancel(k_delayed_work *work)

{
  uint uVar1;
  uint uVar2;
  
  uVar1 = irq_lock();
  uVar2 = atomic_get((work->work).flags);
  uVar2 = uVar2 & 1;
  if (uVar2 == 0) {
    if (work->work_q == (k_work_q *)0x0) {
      uVar2 = 0xffffffea;
    }
    else {
      k_timer_stop((k_timer_t_conflict1 *)&work->timer);
      remv_timer_record(work);
      work->work_q = (k_work_q *)0x0;
      (work->timer).timeout = 0;
      (work->timer).start_ms = 0;
    }
  }
  else {
    uVar2 = 0xffffffbc;
  }
  irq_unlock(uVar1);
  return uVar2;
}



int k_delayed_work_submit(k_delayed_work *work,uint32_t delay)

{
  uint uVar1;
  int iVar2;
  
  uVar1 = irq_lock();
  if (work->work_q != (k_work_q *)0x0) {
    iVar2 = -0x30;
    if (work->work_q != &g_work_queue_main) goto done;
    iVar2 = k_delayed_work_cancel(work);
    if (iVar2 < 0) goto done;
  }
  work->work_q = &g_work_queue_main;
  if (delay == 0) {
    k_work_submit_to_queue(&g_work_queue_main,(k_work *)work);
    work->work_q = (k_work_q *)0x0;
  }
  else {
    k_timer_start((k_timer_t_conflict1 *)&work->timer,delay);
    iVar2 = add_timer_record(work);
    if (iVar2 == 0) goto done;
    vAssertCalled();
  }
  iVar2 = 0;
done:
  irq_unlock(uVar1);
  return iVar2;
}



timer_rec_d * get_timer_record(void *hdl)

{
  timer_rec_d *ptVar1;
  int iVar2;
  
  ptVar1 = timer_records;
  iVar2 = 0;
  do {
    if ((ptVar1->timer).hdl == hdl) {
      return timer_records + iVar2;
    }
    iVar2 = iVar2 + 1;
    ptVar1 = ptVar1 + 1;
  } while (iVar2 != 5);
  return (timer_rec_d *)0x0;
}



void work_timeout(void *timer)

{
  k_delayed_work *work;
  timer_rec_d *ptVar1;
  
  ptVar1 = get_timer_record(timer);
  if (ptVar1 == (timer_rec_d *)0x0) {
    vAssertCalled();
  }
  work = ptVar1->delay_work;
  k_timer_stop((k_timer_t_conflict1 *)&work->timer);
  k_work_submit_to_queue(work->work_q,(k_work *)work);
  work->work_q = (k_work_q *)0x0;
  (ptVar1->timer).hdl = (void *)0x0;
  return;
}



void reverse_bytearray(uint8_t *src,uint8_t *result,int array_size)

{
  uint8_t *puVar1;
  int iVar2;
  
  result = result + array_size;
  iVar2 = 0;
  while (result = result + -1, iVar2 < array_size) {
    puVar1 = src + iVar2;
    iVar2 = iVar2 + 1;
    *result = *puVar1;
  }
  return;
}



void gf_double(uint8_t *out,uint8_t *in)

{
  byte *pbVar1;
  byte *pbVar2;
  uint uVar3;
  
  uVar3 = (int)(char)*in >> 0x1f & 0x87;
  pbVar1 = out + 0xf;
  pbVar2 = in + 0xf;
  while( true ) {
    *pbVar1 = (byte)uVar3 ^ *pbVar2 << 1;
    if (pbVar2 == in) break;
    uVar3 = (uint)(*pbVar2 >> 7);
    pbVar1 = pbVar1 + -1;
    pbVar2 = pbVar2 + -1;
  }
  return;
}



int tc_cmac_erase(TCCmacState_t s)

{
  if (s != (TCCmacState_t)0x0) {
    _set(s,0,0x58);
    return 1;
  }
  return 0;
}



int tc_cmac_init(TCCmacState_t s)

{
  if (s != (TCCmacState_t)0x0) {
    _set(s,0,0x10);
    _set(s->leftover,0,0x10);
    s->leftover_offset = 0;
    *(undefined4 *)&s->countdown = 0;
    *(undefined4 *)((int)&s->countdown + 4) = 0x10000;
    return 1;
  }
  return 0;
}



int tc_cmac_setup(TCCmacState_t s,uint8_t *key,TCAesKeySched_t sched)

{
  if ((s != (TCCmacState_t)0x0) && (key != (uint8_t *)0x0)) {
    _set(s,0,0x58);
    s->sched = sched;
    tc_aes128_set_encrypt_key(sched,key);
    _set(s,0,0x10);
    tc_aes_encrypt((uint8_t *)s,(uint8_t *)s,s->sched);
    gf_double(s->K1,(uint8_t *)s);
    gf_double(s->K2,s->K1);
    tc_cmac_init(s);
    return 1;
  }
  return 0;
}



int tc_cmac_update(TCCmacState_t s,uint8_t *data,size_t data_length)

{
  uint8_t *puVar1;
  byte *pbVar2;
  uint to_len;
  byte *pbVar3;
  uint uVar4;
  TCCmacState_t ptVar5;
  int iVar6;
  uint uVar7;
  
  if (s == (TCCmacState_t)0x0) {
    return 0;
  }
  if (data_length == 0) {
    return 1;
  }
  if (data == (uint8_t *)0x0) {
    return 0;
  }
  uVar4 = *(uint *)&s->countdown;
  to_len = *(uint *)((int)&s->countdown + 4);
  if ((uVar4 | to_len) == 0) {
    return 0;
  }
  uVar7 = s->leftover_offset;
  *(uint *)&s->countdown = uVar4 - 1;
  *(int *)((int)&s->countdown + 4) = (uint)(uVar4 - 1 < uVar4) + (to_len - 1);
  to_len = data_length;
  if (uVar7 != 0) {
    to_len = 0x10 - uVar7;
    if (data_length < to_len) {
      _copy(s->leftover + uVar7,data_length,data,data_length);
      data_length = data_length + s->leftover_offset;
      goto LAB_2302621a;
    }
    _copy(s->leftover + uVar7,to_len,data,to_len);
    data_length = (data_length - 0x10) + uVar7;
    data = data + to_len;
    s->leftover_offset = 0;
    ptVar5 = s;
    do {
      puVar1 = ptVar5->iv;
      ptVar5->iv[0] = ptVar5->iv[0] ^ ptVar5->leftover[0];
      ptVar5 = (TCCmacState_t)(puVar1 + 1);
    } while ((TCCmacState_t)s->K1 != (TCCmacState_t)(puVar1 + 1));
    tc_aes_encrypt((uint8_t *)s,(uint8_t *)s,s->sched);
    to_len = data_length;
  }
  while (0x10 < data_length) {
    iVar6 = 0;
    do {
      pbVar2 = s->iv + iVar6;
      pbVar3 = data + (to_len - data_length) + iVar6;
      iVar6 = iVar6 + 1;
      *pbVar2 = *pbVar3 ^ *pbVar2;
    } while (iVar6 != 0x10);
    tc_aes_encrypt((uint8_t *)s,(uint8_t *)s,s->sched);
    data_length = data_length - 0x10;
  }
  if (data_length == 0) {
    return 1;
  }
  _copy(s->leftover,data_length,data + (to_len - data_length),data_length);
LAB_2302621a:
  s->leftover_offset = data_length;
  return 1;
}



int tc_cmac_final(uint8_t *tag,TCCmacState_t s)

{
  byte *pbVar1;
  uint8_t *puVar2;
  int iVar3;
  uint uVar4;
  TCCmacState_t ptVar5;
  
  if ((tag != (uint8_t *)0x0) && (s != (TCCmacState_t)0x0)) {
    uVar4 = s->leftover_offset;
    if (uVar4 == 0x10) {
      puVar2 = s->K1;
    }
    else {
      _set(s->leftover + uVar4,0,0x10 - uVar4);
      puVar2 = s->K2;
      s->leftover[s->leftover_offset] = -0x80;
    }
    iVar3 = 0;
    ptVar5 = s;
    do {
      pbVar1 = puVar2 + iVar3;
      iVar3 = iVar3 + 1;
      ptVar5->iv[0] = ptVar5->iv[0] ^ ptVar5->leftover[0] ^ *pbVar1;
      ptVar5 = (TCCmacState_t)(ptVar5->iv + 1);
    } while (iVar3 != 0x10);
    tc_aes_encrypt(tag,(uint8_t *)s,s->sched);
    tc_cmac_erase(s);
    return 1;
  }
  return 0;
}



uint _copy(uint8_t *to,uint to_len,uint8_t *from,uint from_len)

{
  if (from_len <= to_len) {
    memcpy(to,from,from_len);
    return from_len;
  }
  return 0;
}



void * _set(void *__s,int __c,size_t __n)

{
  uint uVar1;
  uint extraout_a1;
  uint *puVar2;
  uint *puVar3;
  void *pvVar4;
  uint uVar5;
  
  uVar1 = 0xf;
  if (0xf < __n) {
    uVar5 = (uint)__s & 0xf;
    puVar3 = (uint *)__s;
    if (uVar5 != 0) {
      pvVar4 = __s;
      __s = (void *)(*(code *)(uVar5 * 4 + 0x2306d210))();
      puVar3 = (uint *)((int)pvVar4 - (uVar5 - 0x10));
      __n = __n + (uVar5 - 0x10);
      __c = extraout_a1;
      if (__n <= uVar1) goto LAB_2306d200;
    }
    if (__c != 0) {
      uVar5 = __c & 0xffU | (__c & 0xffU) << 8;
      __c = uVar5 | uVar5 << 0x10;
    }
    uVar5 = __n & 0xfffffff0;
    __n = __n & 0xf;
    puVar2 = (uint *)(uVar5 + (int)puVar3);
    do {
      *puVar3 = __c;
      puVar3[1] = __c;
      puVar3[2] = __c;
      puVar3[3] = __c;
      puVar3 = puVar3 + 4;
    } while (puVar3 < puVar2);
    if (__n == 0) {
      return __s;
    }
  }
LAB_2306d200:
                    // WARNING: Could not recover jumptable at 0x2306d210. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar4 = (void *)(*(code *)(&UNK_2306d214 + (uVar1 - __n) * 4))();
  return pvVar4;
}



uint8_t _double_byte(uint8_t a)

{
  undefined3 in_register_00002029;
  
  return a << 1 ^ (char)(CONCAT31(in_register_00002029,a) >> 7) * '\x1b';
}



rx_msg_struct * bl_find_valid_queued_entry(void)

{
  int iVar1;
  int iVar2;
  undefined auStack40 [4];
  rx_msg_struct empty_msg;
  
  iVar1 = 0;
  memset(auStack40,0,8);
  do {
    iVar2 = memcmp(msg_array + iVar1,auStack40,8);
    if (iVar2 == 0) {
      return msg_array + iVar1;
    }
    iVar1 = iVar1 + 1;
  } while (iVar1 != 9);
  return (rx_msg_struct *)0x0;
}



void bl_onchiphci_rx_packet_handler
               (uint8_t pkt_type,uint16_t src_id,uint8_t *param,uint8_t param_len,void *rx_buf)

{
  uint8_t uVar1;
  bool bVar2;
  uint32_t monitor;
  undefined uVar3;
  bt_buf_type type;
  undefined3 in_register_00002029;
  int iVar4;
  undefined *puVar5;
  int iVar6;
  rx_msg_struct *data;
  void *__dest;
  uint uVar7;
  undefined2 in_register_0000202e;
  undefined3 in_register_00002035;
  size_t xWantedSize;
  size_t len;
  
  xWantedSize = CONCAT31(in_register_00002035,param_len);
  iVar4 = CONCAT31(in_register_00002029,pkt_type);
  uVar3 = (undefined)src_id;
  uVar3 = (undefined)(src_id >> 8);
  if (rx_buf == (void *)0x0) {
    if (iVar4 == 1) {
      type = BT_BUF_ACL_IN;
LAB_2302641c:
      rx_buf = bt_buf_get_rx(type,0);
    }
    else {
      if (1 < (iVar4 - 2U & 0xff)) {
        if (((iVar4 == 4) && (*param == '\x02')) && (iVar6 = bt_buf_get_rx_avail_cnt(), iVar6 < 2))
        goto LAB_23026436;
        type = BT_BUF_EVT;
        goto LAB_2302641c;
      }
      rx_buf = bt_buf_get_cmd_complete(-1);
    }
    if ((net_buf *)rx_buf == (net_buf *)0x0) {
LAB_23026436:
      monitor = monitor + 1;
      if ((monitor & 0xff) == 0) {
        puts("hci_rx_pool is not available\n");
      }
      if (((iVar4 != 4) || (*param != '\x02')) &&
         (data = bl_find_valid_queued_entry(), data != (rx_msg_struct *)0x0)) {
        *(undefined *)&data->src_id = uVar3;
        data->pkt_type = pkt_type;
        *(undefined *)((int)&data->src_id + 1) = uVar3;
        if (xWantedSize != 0) {
          __dest = k_malloc(xWantedSize);
          *(undefined *)((int)&data->param + 1) = (char)((uint)__dest >> 8);
          *(char *)&data->param = (char)__dest;
          *(undefined *)((int)&data->param + 2) = (char)((uint)__dest >> 0x10);
          *(undefined *)((int)&data->param + 3) = (char)((uint)__dest >> 0x18);
          memcpy(__dest,param,xWantedSize);
        }
        data->param_len = param_len;
        k_queue_append(&msg_queue,data);
        return;
      }
      return;
    }
    monitor = 0;
  }
  puVar5 = (undefined *)
           ((uint)*(ushort *)((int)&((net_buf *)rx_buf)->field_4 + 4) +
           *(int *)&((net_buf *)rx_buf)->field_4);
  switch(iVar4 - 1U & 0xff) {
  case 0:
    ((net_buf *)rx_buf)->user_data[0] = '\x03';
    uVar7 = bt_onchiphci_hanlde_rx_acl(param,puVar5);
    len = uVar7 & 0xffff;
    goto LAB_23026568;
  case 1:
    *puVar5 = 0xe;
    puVar5[1] = param_len + '\x03';
    puVar5[3] = uVar3;
    puVar5[2] = 1;
    puVar5[4] = uVar3;
    len = xWantedSize + 5;
    memcpy(puVar5 + 5,param,xWantedSize);
    bVar2 = true;
    break;
  case 2:
    *puVar5 = 0xf;
    puVar5[1] = 4;
    uVar1 = *param;
    puVar5[4] = uVar3;
    puVar5[2] = uVar1;
    puVar5[3] = 1;
    puVar5[5] = uVar3;
    bVar2 = true;
    len = 6;
    break;
  case 3:
    ((net_buf *)rx_buf)->user_data[0] = '\x01';
    *puVar5 = 0x3e;
    puVar5[1] = param_len;
    len = xWantedSize + 2;
    memcpy(puVar5 + 2,param,xWantedSize);
LAB_23026568:
    bVar2 = false;
    break;
  case 4:
    ((net_buf *)rx_buf)->user_data[0] = '\x01';
    *puVar5 = uVar3;
    puVar5[1] = param_len;
    bVar2 = CONCAT22(in_register_0000202e,src_id) == 0x13;
    len = xWantedSize + 2;
    memcpy(puVar5 + 2,param,xWantedSize);
    break;
  default:
    return;
  }
  net_buf_simple_add((net_buf_simple *)&((net_buf *)rx_buf)->field_4,len);
  if (bVar2) {
    bt_recv_prio();
    return;
  }
  hci_driver_enque_recvq((net_buf *)rx_buf);
  return;
}



void bl_handle_queued_msg(void)

{
  int iVar1;
  net_buf *rx_buf;
  uint8_t *__s;
  
  iVar1 = k_queue_is_empty(&msg_queue);
  if (iVar1 == 0) {
    rx_buf = bt_buf_get_rx(BT_BUF_ACL_IN,0);
    if (rx_buf != (net_buf *)0x0) {
      __s = (uint8_t *)k_queue_get(&msg_queue,0);
      bl_onchiphci_rx_packet_handler
                (*__s,*(uint16_t *)(__s + 1),*(uint8_t **)(__s + 3),__s[7],rx_buf);
      if (*(void **)(__s + 3) != (void *)0x0) {
        k_free(*(void **)(__s + 3));
      }
      memset(__s,0,8);
      return;
    }
  }
  return;
}



void bl_onchiphci_interface_deinit(void)

{
  void *pvVar1;
  
  while (pvVar1 = k_queue_get(&msg_queue,0), pvVar1 != (void *)0x0) {
    if (*(void **)((int)pvVar1 + 3) != (void *)0x0) {
      k_free(*(void **)((int)pvVar1 + 3));
    }
  }
  k_queue_free(&msg_queue);
  return;
}



uint8_t bl_onchiphci_interface_init(void)

{
  uint8_t uVar1;
  
  memset(msg_array,0,0x48);
  k_queue_init(&msg_queue,9);
  uVar1 = bt_onchiphci_interface_init(bl_onchiphci_rx_packet_handler);
  return uVar1;
}



// WARNING: Could not reconcile some variable overlaps

int bl_onchiphci_send_2_controller(net_buf *buf)

{
  ushort uVar1;
  int iVar2;
  ushort dest_id;
  byte pkt_type;
  ushort *puVar3;
  ushort uStack44;
  byte bStack42;
  hci_pkt_struct pkt;
  
  pkt_type = buf->user_data[0];
  if (pkt_type == 0) {
    dest_id = *(ushort *)((int)&buf->field_4 + 4);
    if ((2 < dest_id) &&
       (puVar3 = *(ushort **)&buf->field_4, (uint)*(byte *)(puVar3 + 1) <= (uint)dest_id)) {
      uStack44 = *puVar3;
      net_buf_simple_pull((net_buf_simple *)&buf->field_4,3);
      pkt.p._0_4_ = *(byte **)&buf->field_4;
      dest_id = 0;
      if ((((uint)uStack44 - 0x2013 & 0xffff) < 0x20) &&
         (dest_id = (ushort)pkt_type, (1 << ((uint)uStack44 - 0x2013 & 0x1f) & 0xa000e1cdU) != 0)) {
        dest_id = (ushort)*(byte *)pkt.p;
      }
      pkt.p._4_4_ = pkt.p._4_4_ & 0xffffff00 | (uint)*(byte *)(puVar3 + 1);
LAB_23026778:
      iVar2 = bt_onchiphci_send(pkt_type,dest_id,(hci_pkt_struct *)&uStack44);
      return iVar2;
    }
  }
  else {
    if ((pkt_type == 2) && (3 < *(ushort *)((int)&buf->field_4 + 4))) {
      dest_id = (*(ushort **)&buf->field_4)[1];
      uVar1 = **(ushort **)&buf->field_4;
      net_buf_simple_pull((net_buf_simple *)&buf->field_4,4);
      if (dest_id <= *(ushort *)((int)&buf->field_4 + 4)) {
        pkt.p._4_4_ = *(uint *)&buf->field_4;
        pkt.p._0_4_ = (byte *)CONCAT22(pkt.p._2_2_,dest_id);
        dest_id = (ushort)(((uint)uVar1 << 0x14) >> 0x14);
        bStack42 = (byte)(uVar1 >> 0xc);
        pkt_type = 1;
        uStack44 = dest_id;
        goto LAB_23026778;
      }
    }
  }
  return -0x16;
}



int atomic_test_bit(atomic_t *target,int bit)

{
  atomic_val_t aVar1;
  
  aVar1 = atomic_get(target);
  return aVar1 >> (bit & 0x1fU) & 1;
}



void tx_free(bt_conn_tx *tx)

{
  tx->cb = (bt_conn_tx_cb_t *)0x0;
  tx->user_data = (void *)0x0;
  tx->pending_no_cb = 0;
  k_queue_append((k_queue *)&free_tx,tx);
  return;
}



// WARNING: Type propagation algorithm not settling

int send_frag(ushort *param_1,net_buf *param_2,int param_3,int param_4)

{
  ushort uVar1;
  bt_conn_tx *tx;
  undefined *puVar2;
  bt_conn_tx *pbVar3;
  int iVar4;
  bt_conn_tx *pbVar5;
  undefined4 uVar6;
  int *unaff_s6;
  
  tx = *(bt_conn_tx **)param_2->user_data;
  k_sem_take(&bt_dev.le.pkts,0xffffffff);
  if (*(char *)((int)param_1 + 0xd) == '\x04') {
    puVar2 = (undefined *)net_buf_simple_push((net_buf_simple *)&param_2->field_4,4);
    uVar1 = *param_1;
    *puVar2 = (char)uVar1;
    puVar2[1] = (byte)((uint)(param_3 << 0xc) >> 8) | (byte)((uint)uVar1 >> 8);
    iVar4 = (uint)*(ushort *)((int)&param_2->field_4 + 4) - 4;
    puVar2[2] = (char)((uint)(iVar4 * 0x10000) >> 0x10);
    puVar2[3] = (char)((uint)iVar4 >> 8);
    irq_lock();
    if (tx == (bt_conn_tx *)0x0) {
      iVar4 = *(int *)(param_1 + 0xc);
      if (iVar4 == 0) {
        unaff_s6 = (int *)(param_1 + 0xe);
        iVar4 = *(int *)(param_1 + 0xe);
      }
      else {
        unaff_s6 = (int *)(iVar4 + 0xc);
        iVar4 = *(int *)(iVar4 + 0xc);
      }
      *unaff_s6 = iVar4 + 1;
    }
    else {
      tx->node = 0;
      if (*(bt_conn_tx **)(param_1 + 0xc) == (bt_conn_tx *)0x0) {
        *(bt_conn_tx **)(param_1 + 0xc) = tx;
        *(bt_conn_tx **)(param_1 + 10) = tx;
      }
      else {
        *(bt_conn_tx **)&(*(bt_conn_tx **)(param_1 + 0xc))->node = tx;
        *(bt_conn_tx **)(param_1 + 0xc) = tx;
      }
    }
    irq_unlock();
    param_2->user_data[0] = '\x02';
    iVar4 = bt_send(param_2);
    if (iVar4 == 0) {
      return 1;
    }
    printf("Unable to send to driver (err %d)\r\n");
    irq_lock();
    if (tx == (bt_conn_tx *)0x0) {
      *unaff_s6 = *unaff_s6 + -1;
    }
    else {
      pbVar3 = (bt_conn_tx *)0x0;
      pbVar5 = *(bt_conn_tx **)(param_1 + 10);
      while (pbVar5 != (bt_conn_tx *)0x0) {
        if (tx == pbVar5) {
          uVar6 = tx->node;
          if (pbVar3 == (bt_conn_tx *)0x0) {
            *(undefined4 *)(param_1 + 10) = uVar6;
            if (tx == *(bt_conn_tx **)(param_1 + 0xc)) {
              *(undefined4 *)(param_1 + 0xc) = uVar6;
            }
          }
          else {
            pbVar3->node = uVar6;
            if (tx == *(bt_conn_tx **)(param_1 + 0xc)) {
              *(bt_conn_tx **)(param_1 + 0xc) = pbVar3;
            }
          }
          tx->node = 0;
          break;
        }
        pbVar3 = pbVar5;
        pbVar5 = *(bt_conn_tx **)&pbVar5->node;
      }
    }
    irq_unlock();
  }
  k_sem_give(&bt_dev.le.pkts);
  if (tx != (bt_conn_tx *)0x0) {
    tx_free(tx);
  }
  if (param_4 != 0) {
    net_buf_unref(param_2);
    param_4 = 0;
  }
  return param_4;
}



void notify_connected(bt_conn *conn)

{
  bt_conn_cb *pbVar1;
  
  pbVar1 = callback_list;
  while (pbVar1 != (bt_conn_cb *)0x0) {
    if (pbVar1->connected != (anon_subr_void_bt_conn_ptr_u8_t_for_connected *)0x0) {
      (*pbVar1->connected)(conn,conn->err);
    }
    pbVar1 = pbVar1->_next;
  }
  if (conn->err == '\0') {
    bt_gatt_connected(conn);
    return;
  }
  return;
}



void bt_conn_reset_rx_state(bt_conn *conn)

{
  if (conn->rx_len != 0) {
    net_buf_unref(conn->rx);
    conn->rx = (net_buf *)0x0;
    conn->rx_len = 0;
    return;
  }
  return;
}



void conn_cleanup(bt_conn *conn)

{
  net_buf *buf;
  void *pvVar1;
  
  while (buf = net_buf_get((k_fifo *)(k_queue *)&conn->tx_queue,0), buf != (net_buf *)0x0) {
    if (*(bt_conn_tx **)buf->user_data != (bt_conn_tx *)0x0) {
      tx_free(*(bt_conn_tx **)buf->user_data);
    }
    net_buf_unref(buf);
  }
  bt_conn_reset_rx_state(conn);
  k_delayed_work_submit(&conn->update_work,0);
  k_queue_free((k_queue *)&conn->tx_queue);
  pvVar1 = (conn->update_work).timer.timer.hdl;
  (conn->tx_queue)._queue.hdl = (void *)0x0;
  if (pvVar1 != (void *)0x0) {
    k_delayed_work_del_timer(&conn->update_work);
    return;
  }
  return;
}



void tx_notify(bt_conn *conn)

{
  bt_conn_tx *tx;
  uint uVar1;
  void *pvVar2;
  _snode *p_Var3;
  bt_conn_tx_cb_t *pbVar4;
  
  while( true ) {
    uVar1 = irq_lock();
    tx = (bt_conn_tx *)(conn->tx_complete).head;
    if (tx == (bt_conn_tx *)0x0) break;
    p_Var3 = (tx->node).next;
    *(_snode **)&(conn->tx_complete).head = p_Var3;
    if (tx == (bt_conn_tx *)(conn->tx_complete).tail) {
      *(_snode **)&(conn->tx_complete).tail = p_Var3;
    }
    irq_unlock(uVar1);
    pvVar2 = tx->user_data;
    pbVar4 = tx->cb;
    tx_free(tx);
    (*pbVar4)(conn,pvVar2);
  }
  irq_unlock();
  return;
}



void tx_complete_work(k_work *work)

{
  tx_notify((bt_conn *)work[-4].flags);
  return;
}



k_sem * bt_conn_get_pkts(bt_conn *conn)

{
  return &bt_dev.le.pkts;
}



void notify_le_param_updated(bt_conn *conn)

{
  bt_conn_cb *pbVar1;
  int iVar2;
  
  iVar2 = atomic_test_bit(conn->flags,9);
  pbVar1 = callback_list;
  if ((((iVar2 != 0) && (*(ushort *)(conn->field_20 + 0x18) <= *(ushort *)(conn->field_20 + 0x16)))
      && (*(ushort *)(conn->field_20 + 0x16) <= *(ushort *)(conn->field_20 + 0x1a))) &&
     (*(int *)(conn->field_20 + 0x1c) == *(int *)(conn->field_20 + 0x20))) {
    atomic_and(conn->flags,-0x201);
    pbVar1 = callback_list;
  }
  while (pbVar1 != (bt_conn_cb *)0x0) {
    if (pbVar1->le_param_updated !=
        (anon_subr_void_bt_conn_ptr_u16_t_u16_t_u16_t_for_le_param_updated *)0x0) {
      (*pbVar1->le_param_updated)
                (conn,*(u16_t *)(conn->field_20 + 0x16),*(u16_t *)(conn->field_20 + 0x1c),
                 *(u16_t *)(conn->field_20 + 0x1e));
    }
    pbVar1 = pbVar1->_next;
  }
  return;
}



_Bool le_param_req(bt_conn *conn,bt_le_conn_param *param)

{
  bt_conn_cb *pbVar1;
  _Bool _Var2;
  _Bool _Var3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  
  _Var2 = bt_le_conn_params_valid(param);
  pbVar1 = callback_list;
  if (CONCAT31(extraout_var,_Var2) == 0) {
LAB_23026aee:
    _Var2 = false;
  }
  else {
    while (pbVar1 != (bt_conn_cb *)0x0) {
      if ((pbVar1->le_param_req !=
           (anon_subr__Bool_bt_conn_ptr_bt_le_conn_param_ptr_for_le_param_req *)0x0) &&
         ((_Var3 = (*pbVar1->le_param_req)(conn,param), CONCAT31(extraout_var_00,_Var3) == 0 ||
          (_Var3 = bt_le_conn_params_valid(param), CONCAT31(extraout_var_01,_Var3) == 0))))
      goto LAB_23026aee;
      pbVar1 = pbVar1->_next;
    }
  }
  return _Var2;
}



_Bool le_check_valid_conn(void)

{
  atomic_val_t aVar1;
  bool bVar2;
  
  aVar1 = atomic_get(&conns[0].ref);
  bVar2 = true;
  if (aVar1 == 0) {
    aVar1 = atomic_get(&conns[1].ref);
    bVar2 = aVar1 != 0;
  }
  return (_Bool)bVar2;
}



void bt_conn_identity_resolved(bt_conn *conn)

{
  bt_conn_cb *pbVar1;
  bt_addr_le_t *pbVar2;
  
  pbVar2 = (bt_addr_le_t *)(conn->field_20 + 0xe);
  if (conn->role != '\0') {
    pbVar2 = (bt_addr_le_t *)(conn->field_20 + 7);
  }
  pbVar1 = callback_list;
  while (pbVar1 != (bt_conn_cb *)0x0) {
    if (pbVar1->identity_resolved !=
        (anon_subr_void_bt_conn_ptr_bt_addr_le_t_ptr_bt_addr_le_t_ptr_for_identity_resolved *)0x0) {
      (*pbVar1->identity_resolved)(conn,pbVar2,(bt_addr_le_t *)conn->field_20);
    }
    pbVar1 = pbVar1->_next;
  }
  return;
}



int bt_conn_le_start_encryption(bt_conn *conn,u8_t *rand,u8_t *ediv,u8_t *ltk,size_t len)

{
  u16_t uVar1;
  net_buf *buf;
  undefined *puVar2;
  int iVar3;
  
  buf = bt_hci_cmd_create(0x2019,'\x1c');
  if (buf != (net_buf *)0x0) {
    puVar2 = (undefined *)net_buf_simple_add((net_buf_simple *)&buf->field_4,0x1c);
    uVar1 = conn->handle;
    *puVar2 = (char)uVar1;
    puVar2[1] = (char)(uVar1 >> 8);
    memcpy(puVar2 + 2,rand,8);
    memcpy(puVar2 + 10,ediv,2);
    memcpy(puVar2 + 0xc,ltk,len);
    if (len < 0x10) {
      memset(puVar2 + 0xc + len,0,0x10 - len);
    }
    iVar3 = bt_hci_cmd_send_sync(0x2019,buf,(net_buf **)0x0);
    return iVar3;
  }
  return -0x37;
}



void bt_conn_security_changed(bt_conn *param_1,int param_2)

{
  bt_conn_cb *pbVar1;
  
  pbVar1 = callback_list;
  while (pbVar1 != (bt_conn_cb *)0x0) {
    if (pbVar1->security_changed !=
        (anon_subr_void_bt_conn_ptr_bt_security_t_bt_security_err_for_security_changed *)0x0) {
      (*pbVar1->security_changed)(param_1,param_1->sec_level,(bt_security_err)param_2);
    }
    pbVar1 = pbVar1->_next;
  }
  if ((param_2 == 0) && (1 < (byte)param_1->sec_level)) {
    bt_keys_update_usage(param_1->id,(bt_addr_le_t *)param_1->field_20);
    return;
  }
  return;
}



int bt_conn_set_security(bt_conn *conn,bt_security_t sec)

{
  int iVar1;
  undefined3 in_register_0000202d;
  
  if (conn->state == BT_CONN_CONNECTED) {
    iVar1 = 0;
    if (((uint)(byte)conn->sec_level < CONCAT31(in_register_0000202d,sec)) &&
       ((uint)(byte)conn->required_sec_level < CONCAT31(in_register_0000202d,sec))) {
      if (sec < '\0') {
        atomic_or(conn->flags,0x800);
      }
      else {
        atomic_and(conn->flags,-0x801);
      }
      conn->required_sec_level = sec & 0x7f;
      iVar1 = bt_smp_start_security(conn);
      if (iVar1 != 0) {
        conn->required_sec_level = conn->sec_level;
      }
    }
    return iVar1;
  }
  return -0x39;
}



bt_security_t bt_conn_get_security(bt_conn *conn)

{
  return conn->sec_level;
}



void bt_conn_cb_register(bt_conn_cb *cb)

{
  bt_conn_cb *pbVar1;
  
  pbVar1 = cb;
  cb->_next = callback_list;
  callback_list = pbVar1;
  return;
}



void bt_conn_recv(bt_conn *conn,net_buf *buf,u8_t flags)

{
  ushort uVar1;
  char *fmt;
  size_t sVar2;
  undefined3 in_register_00002031;
  int iVar3;
  uint uVar4;
  
  iVar3 = CONCAT31(in_register_00002031,flags);
  tx_notify(conn);
  if (iVar3 == 1) {
    if (conn->rx_len == 0) {
      fmt = "Unexpected L2CAP continuation\r\n";
    }
    else {
      uVar4 = (uint)*(ushort *)((int)&buf->field_4 + 4);
      if (conn->rx_len < uVar4) {
        fmt = "L2CAP data overflow\r\n";
      }
      else {
        sVar2 = net_buf_simple_tailroom((net_buf_simple *)&conn->rx->field_4);
        if (uVar4 <= sVar2) {
          net_buf_simple_add_mem
                    ((net_buf_simple *)&conn->rx->field_4,*(void **)&buf->field_4,
                     (uint)*(ushort *)((int)&buf->field_4 + 4));
          conn->rx_len = conn->rx_len - *(short *)((int)&buf->field_4 + 4);
          net_buf_unref(buf);
          if (conn->rx_len != 0) {
            return;
          }
          buf = conn->rx;
          conn->rx_len = 0;
          conn->rx = (net_buf *)0x0;
          goto LAB_23026e1e;
        }
        fmt = "Not enough buffer space for L2CAP data\r\n";
      }
    }
    printf(fmt);
  }
  else {
    if (iVar3 == 2) {
      uVar1 = **(ushort **)&buf->field_4;
      if (conn->rx_len != 0) {
        printf("Unexpected first L2CAP frame\r\n");
        bt_conn_reset_rx_state(conn);
      }
      uVar4 = ((uint)uVar1 - (uint)*(ushort *)((int)&buf->field_4 + 4)) + 4;
      conn->rx_len = (u16_t)(uVar4 * 0x10000 >> 0x10);
      if ((uVar4 & 0xffff) != 0) {
        conn->rx = buf;
        return;
      }
LAB_23026e1e:
      if ((uint)**(ushort **)&buf->field_4 + 4 == (uint)*(ushort *)((int)&buf->field_4 + 4)) {
        bt_l2cap_recv(conn,buf);
        return;
      }
      printf("ACL len mismatch (%u != %u)\r\n");
      goto LAB_23026db4;
    }
    printf("Unexpected ACL flags (0x%02x)\r\n",iVar3);
  }
  bt_conn_reset_rx_state(conn);
LAB_23026db4:
  net_buf_unref(buf);
  return;
}



int bt_conn_send_cb(bt_conn *conn,net_buf *buf,bt_conn_tx_cb_t *cb,void *user_data)

{
  int iVar1;
  bt_conn_tx *tx;
  
  if (conn->state == BT_CONN_CONNECTED) {
    if (cb == (bt_conn_tx_cb_t *)0x0) {
      *(undefined4 *)buf->user_data = 0;
    }
    else {
      tx = (bt_conn_tx *)k_queue_get((k_queue *)&free_tx,-1);
      if (tx == (bt_conn_tx *)0x0) {
        printf("Unable to allocate TX context\r\n");
        net_buf_unref(buf);
        return -0x37;
      }
      if (conn->state != BT_CONN_CONNECTED) {
        printf("Disconnected while allocating context\r\n");
        net_buf_unref(buf);
        tx_free(tx);
        goto LAB_23026e92;
      }
      tx->cb = cb;
      tx->user_data = user_data;
      tx->pending_no_cb = 0;
      *(bt_conn_tx **)buf->user_data = tx;
    }
    net_buf_put(&conn->tx_queue,buf);
    k_sem_give(&g_poll_sem);
    iVar1 = 0;
  }
  else {
    printf("not connected!\r\n");
    net_buf_unref(buf);
LAB_23026e92:
    iVar1 = -0x39;
  }
  return iVar1;
}



int bt_conn_prepare_events(k_poll_event *events)

{
  int iVar1;
  int iVar2;
  atomic_val_t aVar3;
  uint uVar4;
  
  conn_change.signaled = 0;
  k_poll_event_init(events,1,0,&conn_change);
  aVar3 = atomic_get(&conns[0].ref);
  iVar1 = 1;
  if (aVar3 != 0) {
    if ((conns[0].state == BT_CONN_DISCONNECTED) &&
       (uVar4 = atomic_and(conns[0].flags,-0x41), (uVar4 & 0x40) != 0)) {
      conn_cleanup(conns);
      iVar1 = 1;
    }
    else {
      iVar1 = 1;
      if (conns[0].state == BT_CONN_CONNECTED) {
        k_poll_event_init(events + 1,3,0,&conns[0].tx_queue);
        *(undefined *)&events[1].field_0xc = 1;
        iVar1 = 2;
      }
    }
  }
  aVar3 = atomic_get(&conns[1].ref);
  iVar2 = iVar1;
  if (aVar3 != 0) {
    if ((conns[1].state == BT_CONN_DISCONNECTED) &&
       (uVar4 = atomic_and(conns[1].flags,-0x41), (uVar4 & 0x40) != 0)) {
      conn_cleanup(conns + 1);
    }
    else {
      if (conns[1].state == BT_CONN_CONNECTED) {
        iVar2 = iVar1 + 1;
        k_poll_event_init(events + iVar1,3,0,&conns[1].tx_queue);
        *(undefined *)&events[iVar1].field_0xc = 1;
      }
    }
  }
  return iVar2;
}



bt_conn * bt_conn_add_le(u8_t id,bt_addr_le_t *peer)

{
  int iVar1;
  atomic_val_t aVar2;
  
  iVar1 = atomic_get(&conns[0].ref);
  if (iVar1 != 0) {
    aVar2 = atomic_get(&conns[1].ref);
    if (aVar2 != 0) {
      return (bt_conn *)0x0;
    }
    iVar1 = 1;
  }
  memset(conns + iVar1,0,0xa0);
  k_delayed_work_init(&conns[iVar1].update_work,conn_update_timeout);
  k_work_init(&conns[iVar1].tx_complete_work,tx_complete_work);
  atomic_set(&conns[iVar1].ref,1);
  conns[iVar1].id = id;
  memcpy(conns[iVar1].field_20,peer,7);
  conns[iVar1].sec_level = BT_SECURITY_LOW;
  conns[iVar1].required_sec_level = BT_SECURITY_LOW;
  conns[iVar1].type = '\x01';
  *(undefined4 *)(conns[iVar1].field_20 + 0x18) = 0x280018;
  return conns + iVar1;
}



void bt_conn_set_state(bt_conn *conn,bt_conn_state_t state)

{
  bt_conn_state_t bVar1;
  bt_conn_tx *tx;
  uint uVar2;
  undefined3 in_register_0000202d;
  _snode *p_Var3;
  
  bVar1 = conn->state;
  if ((uint)bVar1 == CONCAT31(in_register_0000202d,state)) {
    printf("no transition\r\n");
    return;
  }
  conn->state = state;
  if (bVar1 == BT_CONN_DISCONNECTED) {
    atomic_inc(&conn->ref);
  }
  else {
    if ((bVar1 == BT_CONN_CONNECT) && (conn->type == '\x01')) {
      k_delayed_work_cancel(&conn->update_work);
    }
  }
  switch(conn->state) {
  case BT_CONN_DISCONNECTED:
    if (conn->type != '\x04') {
      if (((uint)bVar1 - 4 & 0xff) < 2) {
        do {
          uVar2 = irq_lock();
          if (conn->pending_no_cb == 0) {
            tx = (bt_conn_tx *)(conn->tx_pending).head;
            if (tx != (bt_conn_tx *)0x0) {
              p_Var3 = (tx->node).next;
              *(_snode **)&(conn->tx_pending).head = p_Var3;
              if (tx == (bt_conn_tx *)(conn->tx_pending).tail) {
                *(_snode **)&(conn->tx_pending).tail = p_Var3;
              }
            }
            irq_unlock(uVar2);
            if (tx == (bt_conn_tx *)0x0) {
              tx_notify(conn);
              if (conn->type == '\x01') {
                k_delayed_work_cancel(&conn->update_work);
              }
              atomic_or(conn->flags,0x40);
              k_poll_signal_raise(&conn_change,0);
              return;
            }
            irq_lock();
            conn->pending_no_cb = tx->pending_no_cb;
            tx->pending_no_cb = 0;
            irq_unlock();
            tx_free(tx);
          }
          else {
            conn->pending_no_cb = conn->pending_no_cb - 1;
            irq_unlock();
          }
          k_sem_give(&bt_dev.le.pkts);
        } while( true );
      }
      if (bVar1 != BT_CONN_CONNECT) {
        if ((bVar1 != BT_CONN_CONNECT_SCAN) && (bVar1 != BT_CONN_CONNECT_DIR_ADV)) {
          return;
        }
        if (conn->err == '\0') goto LAB_23027182;
      }
      notify_connected(conn);
    }
LAB_23027182:
    atomic_dec(&conn->ref);
    return;
  case BT_CONN_CONNECT_SCAN:
  case BT_CONN_CONNECT_DIR_ADV:
  case BT_CONN_DISCONNECT:
    break;
  case BT_CONN_CONNECT:
    if (conn->type == '\x01') {
      k_delayed_work_submit(&conn->update_work,3000);
      return;
    }
    break;
  case BT_CONN_CONNECTED:
    if (conn->type != '\x04') {
      k_queue_init((k_queue *)&conn->tx_queue,0x14);
      k_poll_signal_raise(&conn_change,0);
      (conn->channels).head = (sys_snode_t *)0x0;
      (conn->channels).tail = (sys_snode_t *)0x0;
      bt_l2cap_connected(conn);
      notify_connected(conn);
      return;
    }
    break;
  default:
    printf("no valid (%u) state was set\r\n",CONCAT31(in_register_0000202d,state));
    return;
  }
  return;
}



bt_conn * bt_conn_lookup_handle(u16_t handle)

{
  bt_conn *pbVar1;
  undefined2 in_register_0000202a;
  atomic_val_t aVar2;
  int iVar3;
  
  pbVar1 = conns;
  aVar2 = atomic_get(&conns[0].ref);
  if (((aVar2 == 0) || (1 < (byte)(conns[0].state + ~BT_CONN_CONNECT))) ||
     ((uint)conns[0].handle != CONCAT22(in_register_0000202a,handle))) {
    pbVar1 = conns + 1;
    aVar2 = atomic_get(&conns[1].ref);
    if (aVar2 == 0) {
      return (bt_conn *)0x0;
    }
    if (1 < (byte)(conns[1].state + ~BT_CONN_CONNECT)) {
      return (bt_conn *)0x0;
    }
    if ((uint)conns[1].handle != CONCAT22(in_register_0000202a,handle)) {
      return (bt_conn *)0x0;
    }
    iVar3 = 0xa0;
  }
  else {
    iVar3 = 0;
  }
  atomic_inc(&pbVar1->ref);
  return (bt_conn *)((int)&conns[0].handle + iVar3);
}



int bt_conn_addr_le_cmp(bt_conn *conn,bt_addr_le_t *peer)

{
  int iVar1;
  
  iVar1 = memcmp(peer,conn->field_20,7);
  if (iVar1 != 0) {
    iVar1 = 0x7e;
    if (conn->role != '\0') {
      iVar1 = 0x77;
    }
    iVar1 = memcmp(peer,(void *)((int)&conn->handle + iVar1),7);
    return iVar1;
  }
  return 0;
}



bt_conn * bt_conn_lookup_state_le(bt_addr_le_t *peer,bt_conn_state_t state)

{
  atomic_val_t aVar1;
  int iVar2;
  undefined3 in_register_0000202d;
  int iVar3;
  
  aVar1 = atomic_get(&conns[0].ref);
  if ((((aVar1 == 0) || (conns[0].type != '\x01')) ||
      ((peer != (bt_addr_le_t *)0x0 && (iVar2 = bt_conn_addr_le_cmp(conns,peer), iVar2 != 0)))) ||
     ((uint)conns[0].state != CONCAT31(in_register_0000202d,state))) {
    aVar1 = atomic_get(&conns[1].ref);
    if (((aVar1 == 0) || (conns[1].type != '\x01')) ||
       (((peer != (bt_addr_le_t *)0x0 && (iVar2 = bt_conn_addr_le_cmp(conns + 1,peer), iVar2 != 0))
        || ((uint)conns[1].state != CONCAT31(in_register_0000202d,state))))) {
      return (bt_conn *)0x0;
    }
    iVar2 = 0x360;
    iVar3 = 0xa0;
  }
  else {
    iVar2 = 0x2c0;
    iVar3 = 0;
  }
  atomic_inc((atomic_t *)(gatt_write_buf + iVar2 + 0x174));
  return (bt_conn *)((int)&conns[0].handle + iVar3);
}



bt_conn * bt_conn_lookup_addr_le(u8_t id,bt_addr_le_t *peer)

{
  bt_conn *pbVar1;
  bt_conn *pbVar2;
  undefined3 in_register_00002029;
  atomic_val_t aVar3;
  int iVar4;
  
  pbVar1 = conns;
  aVar3 = atomic_get(&conns[0].ref);
  if ((((aVar3 == 0) || (conns[0].type != '\x01')) ||
      ((uint)conns[0].id != CONCAT31(in_register_00002029,id))) ||
     (iVar4 = bt_conn_addr_le_cmp(conns,peer), iVar4 != 0)) {
    pbVar1 = conns + 1;
    aVar3 = atomic_get(&conns[1].ref);
    if (((aVar3 != 0) && (conns[1].type == '\x01')) &&
       ((uint)conns[1].id == CONCAT31(in_register_00002029,id))) {
      pbVar2 = conns + 1;
      iVar4 = bt_conn_addr_le_cmp(conns + 1,peer);
      if (iVar4 == 0) goto LAB_2302747a;
    }
    pbVar2 = (bt_conn *)0x0;
  }
  else {
    pbVar2 = conns;
LAB_2302747a:
    atomic_inc(&pbVar1->ref);
  }
  return pbVar2;
}



bt_conn * bt_conn_lookup_state_le(bt_addr_le_t *peer,bt_conn_state_t state)

{
  atomic_val_t aVar1;
  int iVar2;
  undefined3 in_register_0000202d;
  int iVar3;
  
  aVar1 = atomic_get(&conns[0].ref);
  if ((((aVar1 == 0) || (conns[0].type != '\x01')) ||
      ((peer != (bt_addr_le_t *)0x0 && (iVar2 = bt_conn_addr_le_cmp(conns,peer), iVar2 != 0)))) ||
     ((uint)conns[0].state != CONCAT31(in_register_0000202d,state))) {
    aVar1 = atomic_get(&conns[1].ref);
    if (((aVar1 == 0) || (conns[1].type != '\x01')) ||
       (((peer != (bt_addr_le_t *)0x0 && (iVar2 = bt_conn_addr_le_cmp(conns + 1,peer), iVar2 != 0))
        || ((uint)conns[1].state != CONCAT31(in_register_0000202d,state))))) {
      return (bt_conn *)0x0;
    }
    iVar2 = 0x360;
    iVar3 = 0xa0;
  }
  else {
    iVar2 = 0x2c0;
    iVar3 = 0;
  }
  atomic_inc((atomic_t *)(gatt_write_buf + iVar2 + 0x174));
  return (bt_conn *)((int)&conns[0].handle + iVar3);
}



void bt_conn_foreach(int type,anon_subr_void_bt_conn_ptr_void_ptr *func,void *data)

{
  atomic_val_t aVar1;
  
  aVar1 = atomic_get(&conns[0].ref);
  if ((aVar1 != 0) && (((uint)conns[0].type & type) != 0)) {
    (*func)(conns,data);
  }
  aVar1 = atomic_get(&conns[1].ref);
  if ((aVar1 != 0) && (((uint)conns[1].type & type) != 0)) {
                    // WARNING: Could not recover jumptable at 0x23027508. Too many branches
                    // WARNING: Treating indirect jump as call
    (*func)((bt_conn *)0x42012318,data);
    return;
  }
  return;
}



void bt_conn_disconnect_all(u8_t id)

{
  u8_t auStack17 [13];
  
  auStack17[0] = id;
  bt_conn_foreach(7,disconnect_all,auStack17);
  return;
}



void bt_conn_unref(bt_conn *conn)

{
  atomic_dec(&conn->ref);
  return;
}



bt_addr_le_t * bt_conn_get_dst(bt_conn *conn)

{
  return (bt_addr_le_t *)conn->field_20;
}



int bt_conn_get_info(bt_conn *conn,bt_conn_info *info)

{
  info->type = conn->type;
  info->role = conn->role;
  info->id = conn->id;
  if (conn->type == '\x01') {
    *(byte **)(info->field_3 + 4) = conn->field_20;
    *(bt_addr_le_t **)info->field_3 = bt_dev.id_addr + conn->id;
    if (conn->role == '\0') {
      *(byte **)(info->field_3 + 8) = conn->field_20 + 7;
      *(byte **)(info->field_3 + 0xc) = conn->field_20 + 0xe;
    }
    else {
      *(byte **)(info->field_3 + 8) = conn->field_20 + 0xe;
      *(byte **)(info->field_3 + 0xc) = conn->field_20 + 7;
    }
    *(undefined2 *)(info->field_3 + 0x10) = *(undefined2 *)(conn->field_20 + 0x16);
    *(undefined2 *)(info->field_3 + 0x12) = *(undefined2 *)(conn->field_20 + 0x1c);
    *(undefined2 *)(info->field_3 + 0x14) = *(undefined2 *)(conn->field_20 + 0x1e);
    return 0;
  }
  return -0x16;
}



int bt_conn_get_remote_dev_info(bt_conn_info *info)

{
  int iVar1;
  int iVar2;
  atomic_val_t aVar3;
  
  iVar2 = atomic_get(&conns[0].ref);
  if (iVar2 != 0) {
    bt_conn_get_info(conns,info);
    iVar2 = 1;
  }
  aVar3 = atomic_get(&conns[1].ref);
  iVar1 = iVar2;
  if (aVar3 != 0) {
    iVar1 = iVar2 + 1;
    bt_conn_get_info(conns + 1,info + iVar2);
  }
  return iVar1;
}



int bt_conn_disconnect(bt_conn *conn,u8_t reason)

{
  u16_t uVar1;
  int iVar2;
  net_buf *buf;
  undefined *puVar3;
  
  switch((uint)conn->state - 1 & 0xff) {
  case 0:
    conn->err = reason;
    bt_conn_set_state(conn,BT_CONN_DISCONNECTED);
    bt_le_scan_update(false);
  case 4:
    iVar2 = 0;
    break;
  case 1:
    conn->err = reason;
    bt_conn_set_state(conn,BT_CONN_DISCONNECTED);
    iVar2 = bt_le_adv_stop();
    return iVar2;
  case 2:
    k_delayed_work_cancel(&conn->update_work);
    iVar2 = bt_hci_cmd_send(0x200e,(net_buf *)0x0);
    return iVar2;
  case 3:
    buf = bt_hci_cmd_create(0x406,'\x03');
    iVar2 = -0x37;
    if (buf != (net_buf *)0x0) {
      puVar3 = (undefined *)net_buf_simple_add((net_buf_simple *)&buf->field_4,3);
      uVar1 = conn->handle;
      puVar3[2] = reason;
      *puVar3 = (char)uVar1;
      puVar3[1] = (char)(uVar1 >> 8);
      iVar2 = bt_hci_cmd_send(0x406,buf);
      if (iVar2 == 0) {
        bt_conn_set_state(conn,BT_CONN_DISCONNECT);
      }
    }
    break;
  default:
    iVar2 = -0x39;
  }
  return iVar2;
}



void disconnect_all(bt_conn *conn,void *data)

{
  if ((conn->id == *(u8_t *)data) && (conn->state == BT_CONN_CONNECTED)) {
    bt_conn_disconnect(conn,'\x13');
    return;
  }
  return;
}



// WARNING: Variable defined which should be unmapped: dst

bt_conn * bt_conn_create_le(bt_addr_le_t *peer,bt_le_conn_param *param)

{
  bt_conn_state_t bVar1;
  _Bool _Var2;
  int iVar3;
  undefined3 extraout_var;
  bt_conn *conn;
  bt_addr_le_t *__src;
  u8_t auStack24 [4];
  bt_addr_le_t dst;
  
  iVar3 = atomic_test_bit(bt_dev.flags,1);
  if ((((iVar3 != 0) && (_Var2 = bt_le_conn_params_valid(param), CONCAT31(extraout_var,_Var2) != 0))
      && (iVar3 = atomic_test_bit(bt_dev.flags,0xb), iVar3 == 0)) &&
     (iVar3 = atomic_test_bit(bt_dev.flags,0xf), iVar3 == 0)) {
    conn = bt_conn_lookup_addr_le('\0',peer);
    if (conn == (bt_conn *)0x0) {
      if ((byte)(peer->type - 2) < 2) {
        memcpy(auStack24,peer,7);
        auStack24[0] = auStack24[0] + -2;
      }
      else {
        __src = bt_lookup_id_addr('\0',peer);
        memcpy(auStack24,__src,7);
      }
      conn = bt_conn_add_le('\0',(bt_addr_le_t *)auStack24);
      if (conn != (bt_conn *)0x0) goto start_scan;
    }
    else {
      bVar1 = conn->state;
      if (bVar1 == BT_CONN_CONNECT_SCAN) {
        *(u16_t *)(conn->field_20 + 0x18) = param->interval_min;
        *(u16_t *)(conn->field_20 + 0x1a) = param->interval_max;
        *(u16_t *)(conn->field_20 + 0x1c) = param->latency;
        *(u16_t *)(conn->field_20 + 0x1e) = param->timeout;
        return conn;
      }
      if (bVar1 == BT_CONN_DISCONNECTED) {
        printf("Found valid but disconnected conn object\r\n");
start_scan:
        *(u16_t *)(conn->field_20 + 0x18) = param->interval_min;
        *(u16_t *)(conn->field_20 + 0x1a) = param->interval_max;
        *(u16_t *)(conn->field_20 + 0x1c) = param->latency;
        *(u16_t *)(conn->field_20 + 0x1e) = param->timeout;
        bt_conn_set_state(conn,BT_CONN_CONNECT_SCAN);
        bt_le_scan_update(true);
        return conn;
      }
      if ((byte)(bVar1 + ~BT_CONN_CONNECT_DIR_ADV) < 2) {
        return conn;
      }
      atomic_dec(&conn->ref);
    }
  }
  return (bt_conn *)0x0;
}



int bt_conn_le_conn_update(bt_conn *conn,bt_le_conn_param *param)

{
  u16_t uVar1;
  net_buf *buf;
  undefined *__s;
  int iVar2;
  
  buf = bt_hci_cmd_create(0x2013,'\x0e');
  if (buf != (net_buf *)0x0) {
    __s = (undefined *)net_buf_simple_add((net_buf_simple *)&buf->field_4,0xe);
    memset(__s,0,0xe);
    uVar1 = conn->handle;
    *__s = (char)uVar1;
    __s[1] = (char)(uVar1 >> 8);
    uVar1 = param->interval_min;
    __s[2] = (char)uVar1;
    __s[3] = (char)(uVar1 >> 8);
    uVar1 = param->interval_max;
    __s[4] = (char)uVar1;
    __s[5] = (char)(uVar1 >> 8);
    uVar1 = param->latency;
    __s[6] = (char)uVar1;
    __s[7] = (char)(uVar1 >> 8);
    uVar1 = param->timeout;
    __s[8] = (char)uVar1;
    __s[9] = (char)(uVar1 >> 8);
    iVar2 = bt_hci_cmd_send_sync(0x2013,buf,(net_buf **)0x0);
    return iVar2;
  }
  return -0x37;
}



int send_conn_le_param_update(bt_conn *conn,bt_le_conn_param *param)

{
  int iVar1;
  
  if (((((bt_dev.le.features[0] & 2) == 0) || ((conn->field_20[0x24] & 2) == 0)) ||
      (iVar1 = atomic_test_bit(conn->flags,10), iVar1 != 0)) && (conn->role != '\0')) {
    iVar1 = bt_l2cap_update_conn_param(conn,param);
    return iVar1;
  }
  iVar1 = bt_conn_le_conn_update(conn,param);
  if (iVar1 == 0) {
    *(u16_t *)(conn->field_20 + 0x20) = param->latency;
    *(u16_t *)(conn->field_20 + 0x22) = param->timeout;
  }
  return iVar1;
}



void conn_update_timeout(k_work *work)

{
  bt_conn *conn;
  uint uVar1;
  bt_le_conn_param *param;
  bt_conn_cb *pbVar2;
  void *local_20;
  atomic_t aStack28;
  undefined4 uStack24;
  undefined4 uStack20;
  
  param = (bt_le_conn_param *)&local_20;
  conn = (bt_conn *)work[-7].flags;
  if (*(char *)((int)work[-6].flags + 1) == '\0') {
    bt_l2cap_disconnected(conn);
    pbVar2 = callback_list;
    while (pbVar2 != (bt_conn_cb *)0x0) {
      if (pbVar2->disconnected != (anon_subr_void_bt_conn_ptr_u8_t_for_disconnected *)0x0) {
        (*pbVar2->disconnected)(conn,*(u8_t *)work[-6].flags);
      }
      pbVar2 = pbVar2->_next;
    }
    atomic_dec(work[-1].flags);
  }
  else {
    if (*(char *)((int)work[-7].flags + 2) == '\x01') {
      if (*(char *)((int)work[-7].flags + 3) == '\0') {
        bt_hci_cmd_send(0x200e,(net_buf *)0x0);
      }
      else {
        uVar1 = atomic_and((atomic_t *)(work + -6),-0x201);
        if ((uVar1 & 0x200) == 0) {
          uStack24 = DAT_4200dd08;
          uStack20 = DAT_4200dd0c;
          param = (bt_le_conn_param *)&uStack24;
        }
        else {
          local_20 = work[5]._reserved;
          aStack28 = work[5].flags[0];
        }
        send_conn_le_param_update(conn,param);
        atomic_or((atomic_t *)(work + -6),0x100);
      }
    }
  }
  return;
}



int bt_conn_le_param_update(bt_conn *conn,bt_le_conn_param *param)

{
  int iVar1;
  
  if ((((param->interval_min <= *(ushort *)(conn->field_20 + 0x16)) &&
       (*(ushort *)(conn->field_20 + 0x16) <= param->interval_max)) &&
      (*(u16_t *)(conn->field_20 + 0x1c) == param->latency)) &&
     (*(u16_t *)(conn->field_20 + 0x1e) == param->timeout)) {
    atomic_and(conn->flags,-0x201);
    return -0x45;
  }
  if (conn->role != '\0') {
    iVar1 = atomic_test_bit(conn->flags,8);
    if (iVar1 == 0) {
      *(u16_t *)(conn->field_20 + 0x18) = param->interval_min;
      *(u16_t *)(conn->field_20 + 0x1a) = param->interval_max;
      *(u16_t *)(conn->field_20 + 0x20) = param->latency;
      *(u16_t *)(conn->field_20 + 0x22) = param->timeout;
      atomic_or(conn->flags,0x200);
      return 0;
    }
  }
  iVar1 = send_conn_le_param_update(conn,param);
  return iVar1;
}



net_buf * bt_conn_create_pdu_timeout(net_buf_pool *pool,size_t reserve,s32_t timeout)

{
  net_buf *pnVar1;
  
  if (pool == (net_buf_pool *)0x0) {
    pool = &acl_tx_pool;
  }
  pnVar1 = net_buf_alloc_fixed(pool,timeout);
  if (pnVar1 == (net_buf *)0x0) {
    printf("Unable to allocate buffer: timeout %d\r\n",timeout);
  }
  else {
    net_buf_simple_reserve((net_buf_simple *)&pnVar1->field_4,reserve + 5);
  }
  return pnVar1;
}



net_buf * create_frag(net_buf *buf)

{
  net_buf *buf_00;
  size_t len;
  int in_a1;
  net_buf_simple *buf_01;
  uint uVar1;
  
  buf_00 = bt_conn_create_pdu_timeout((net_buf_pool *)0x0,0,-1);
  if (*(char *)&buf->field_0 == '\x04') {
    *(undefined4 *)buf_00->user_data = 0;
    uVar1 = (uint)bt_dev.le.mtu;
    buf_01 = (net_buf_simple *)&buf_00->field_4;
    len = net_buf_simple_tailroom(buf_01);
    if (uVar1 < len) {
      len = (size_t)bt_dev.le.mtu;
    }
    else {
      len = net_buf_simple_tailroom(buf_01);
      len = len & 0xffff;
    }
    net_buf_simple_add_mem(buf_01,*(void **)(in_a1 + 8),len);
    net_buf_simple_pull((net_buf_simple *)(in_a1 + 8),len);
  }
  else {
    net_buf_unref(buf_00);
    buf_00 = (net_buf *)0x0;
  }
  return buf_00;
}



void bt_conn_process_tx(bt_conn *param_1)

{
  uint uVar1;
  net_buf *buf;
  int iVar2;
  net_buf *pnVar3;
  undefined4 uVar4;
  
  if ((param_1->state == BT_CONN_DISCONNECTED) &&
     (uVar1 = atomic_and(param_1->flags,-0x41), (uVar1 & 0x40) != 0)) {
    conn_cleanup(param_1);
    return;
  }
  buf = net_buf_get(&param_1->tx_queue,0);
  if (buf == (net_buf *)0x0) {
    vAssertCalled();
  }
  if (bt_dev.le.mtu < *(ushort *)((int)&buf->field_4 + 4)) {
    pnVar3 = create_frag((net_buf *)&param_1->state);
    if (pnVar3 != (net_buf *)0x0) {
      uVar4 = 0;
      while (iVar2 = send_frag(param_1,uVar4,1), iVar2 != 0) {
        if (*(ushort *)((int)&buf->field_4 + 4) <= bt_dev.le.mtu) {
          uVar4 = 1;
          goto LAB_23027bca;
        }
        pnVar3 = create_frag((net_buf *)&param_1->state);
        if (pnVar3 == (net_buf *)0x0) break;
        uVar4 = 1;
      }
    }
  }
  else {
    uVar4 = 0;
LAB_23027bca:
    iVar2 = send_frag(param_1,buf,uVar4,0);
    if (iVar2 != 0) {
      return;
    }
  }
  net_buf_unref(buf);
  return;
}



int bt_conn_auth_cb_register(bt_conn_auth_cb *cb)

{
  bt_conn_auth_cb *pbVar1;
  
  if (cb == (bt_conn_auth_cb *)0x0) {
    bt_auth = (bt_conn_auth_cb *)0x0;
    pbVar1 = bt_auth;
  }
  else {
    if (bt_auth != (bt_conn_auth_cb *)0x0) {
      return -0x45;
    }
    pbVar1 = cb;
    if (cb->cancel == (anon_subr_void_bt_conn_ptr_for_cancel *)0x0) {
      if (cb->passkey_display != (anon_subr_void_bt_conn_ptr_uint_for_passkey_display *)0x0) {
        return -0x16;
      }
      if (cb->passkey_entry != (anon_subr_void_bt_conn_ptr_for_passkey_entry *)0x0) {
        return -0x16;
      }
      if (cb->passkey_confirm != (anon_subr_void_bt_conn_ptr_uint_for_passkey_confirm *)0x0) {
        return -0x16;
      }
      pbVar1 = cb;
      if (cb->pairing_confirm != (anon_subr_void_bt_conn_ptr_for_pairing_confirm *)0x0) {
        return -0x16;
      }
    }
  }
  bt_auth = pbVar1;
  return 0;
}



int bt_conn_auth_passkey_entry(bt_conn *conn,uint passkey)

{
  if ((bt_auth != (bt_conn_auth_cb *)0x0) && (conn->type == '\x01')) {
    bt_smp_auth_passkey_entry(conn,passkey);
    return 0;
  }
  return -0x16;
}



int bt_conn_auth_passkey_confirm(bt_conn *conn)

{
  int iVar1;
  
  if ((bt_auth != (bt_conn_auth_cb *)0x0) && (conn->type == '\x01')) {
    iVar1 = bt_smp_auth_passkey_confirm(conn);
    return iVar1;
  }
  return -0x16;
}



int bt_conn_auth_cancel(bt_conn *conn)

{
  int iVar1;
  
  if ((bt_auth != (bt_conn_auth_cb *)0x0) && (conn->type == '\x01')) {
    iVar1 = bt_smp_auth_cancel(conn);
    return iVar1;
  }
  return -0x16;
}



int bt_conn_auth_pairing_confirm(bt_conn *conn)

{
  int iVar1;
  
  if ((bt_auth != (bt_conn_auth_cb *)0x0) && (conn->type == '\x01')) {
    iVar1 = bt_smp_auth_pairing_confirm(conn);
    return iVar1;
  }
  return -0x16;
}



u8_t bt_conn_index(bt_conn *conn)

{
  return (u8_t)((char)((int)&conn[-0x699b6b].update_work.timer.timeout >> 5) * -0x33);
}



int bt_conn_init(void)

{
  bt_conn *data;
  bt_conn *pbVar1;
  int iVar2;
  atomic_val_t aVar3;
  int iVar4;
  
  if (queue_inited == false) {
    k_queue_init((k_queue *)&acl_tx_pool,2);
  }
  k_queue_init((k_queue *)&free_tx,0x14);
  data = (bt_conn *)conn_tx;
  do {
    pbVar1 = (bt_conn *)&data->rx;
    k_queue_append((k_queue *)&free_tx,data);
    data = pbVar1;
  } while (pbVar1 != conns);
  bt_att_init();
  iVar2 = bt_smp_init();
  if (iVar2 == 0) {
    bt_l2cap_init();
    aVar3 = atomic_get(&conns[0].ref);
    if ((aVar3 != 0) && (iVar4 = atomic_test_bit(conns[0].flags,0), iVar4 != 0)) {
      conns[0].id = '\0';
      bt_conn_set_state(conns,BT_CONN_CONNECT_SCAN);
    }
    aVar3 = atomic_get(&conns[1].ref);
    if ((aVar3 != 0) && (iVar4 = atomic_test_bit(conns[1].flags,0), iVar4 != 0)) {
      conns[1].id = '\0';
      bt_conn_set_state(conns + 1,BT_CONN_CONNECT_SCAN);
    }
  }
  return iVar2;
}



int bt_rand(void *buf,size_t len)

{
  k_get_random_byte_array((uint8_t *)buf,len);
  return 0;
}



// WARNING: Variable defined which should be unmapped: s

int bt_encrypt_le(u8_t *key,u8_t *plaintext,u8_t *enc_data)

{
  u8_t uVar1;
  int iVar2;
  u8_t *puVar3;
  u8_t *puVar4;
  u8_t *puVar5;
  u8_t auStack208 [4];
  u8_t tmp [16];
  tc_aes_key_sched_struct s;
  
  puVar3 = auStack208;
  puVar4 = key + 0xf;
  do {
    puVar5 = puVar4 + -1;
    *puVar3 = *puVar4;
    puVar3 = puVar3 + 1;
    puVar4 = puVar5;
  } while (key + -1 != puVar5);
  iVar2 = tc_aes128_set_encrypt_key((TCAesKeySched_t)(tmp + 0xc),auStack208);
  if (iVar2 != 0) {
    puVar3 = auStack208;
    puVar4 = plaintext + 0xf;
    do {
      puVar5 = puVar4 + -1;
      *puVar3 = *puVar4;
      puVar3 = puVar3 + 1;
      puVar4 = puVar5;
    } while (puVar5 != plaintext + -1);
    iVar2 = tc_aes_encrypt(enc_data,auStack208,(TCAesKeySched_t)(tmp + 0xc));
    if (iVar2 != 0) {
      puVar4 = enc_data + 7;
      puVar3 = enc_data + 0xf;
      do {
        uVar1 = *enc_data;
        puVar5 = puVar3 + -1;
        *enc_data = *puVar3;
        *puVar3 = uVar1;
        enc_data = enc_data + 1;
        puVar3 = puVar5;
      } while (puVar4 != puVar5);
      return 0;
    }
  }
  return -0x16;
}



void sys_slist_remove(sys_slist_t *list,sys_snode_t *prev_node,sys_snode_t *node)

{
  sys_snode_t *psVar1;
  
  psVar1 = (sys_snode_t *)node->next;
  if (prev_node == (sys_snode_t *)0x0) {
    list->head = psVar1;
    if (list->tail == node) {
      list->tail = psVar1;
    }
  }
  else {
    *(sys_snode_t **)&prev_node->next = psVar1;
    if (list->tail == node) {
      list->tail = prev_node;
    }
  }
  node->next = (_snode *)0x0;
  return;
}



u8_t found_attr(bt_gatt_attr *attr,void *user_data)

{
  *(bt_gatt_attr **)user_data = attr;
  return '\0';
}



u16_t find_static_attr(bt_gatt_attr *attr)

{
  anon_subr_int_bt_conn_ptr_bt_l2cap_chan_ptr_ptr_for_accept *paVar1;
  bt_gatt_service_static *pbVar2;
  uint uVar3;
  
  pbVar2 = &_1_gatt_svc;
  uVar3 = 1;
  do {
    if (&att_fixed_chan <= pbVar2) {
      return 0;
    }
    paVar1 = (anon_subr_int_bt_conn_ptr_bt_l2cap_chan_ptr_ptr_for_accept *)0x0;
    while( true ) {
      if (paVar1 == ((bt_l2cap_fixed_chan *)pbVar2)->accept) break;
      if (attr == (bt_gatt_attr *)((int)paVar1 * 0x14 + *(int *)pbVar2)) {
        return (u16_t)((uint)(paVar1 + uVar3) & 0xffff);
      }
      paVar1 = paVar1 + 1;
    }
    pbVar2 = (bt_gatt_service_static *)&((bt_l2cap_fixed_chan *)pbVar2)->node;
    uVar3 = (uint)(paVar1 + uVar3) & 0xffff;
  } while( true );
}



// WARNING: Exceeded maximum restarts with more pending

void gatt_ccc_changed(bt_gatt_attr *attr,_bt_gatt_ccc_conflict2 *ccc)

{
  ushort uVar1;
  ushort uVar2;
  
  uVar1 = ccc->cfg[1].value;
  uVar2 = ccc->cfg[0].value;
  if (uVar2 < uVar1) {
    uVar2 = uVar1;
  }
  if (ccc->value != uVar2) {
    ccc->value = uVar2;
    if (ccc->cfg_changed != (anon_subr_void_bt_gatt_attr_ptr_u16_t_for_cfg_changed *)0x0) {
                    // WARNING: Could not recover jumptable at 0x23027efa. Too many branches
                    // WARNING: Treating indirect jump as call
      (*ccc->cfg_changed)();
      return;
    }
  }
  return;
}



void gatt_indicate_rsp(bt_conn *conn,u8_t err,void *pdu,u16_t length,void *user_data)

{
  undefined3 in_register_0000202d;
  
                    // WARNING: Could not recover jumptable at 0x23027f06. Too many branches
                    // WARNING: Treating indirect jump as call
  (**(code **)((int)user_data + 0x20))
            (*(undefined4 *)((int)user_data + 0x1c),CONCAT31(in_register_0000202d,err));
  return;
}



void sc_restore_rsp(bt_conn *conn,bt_gatt_attr *attr,u8_t err)

{
  return;
}



void gatt_subscription_remove(bt_conn *conn,sys_snode_t *prev,bt_gatt_subscribe_params *params)

{
  sys_slist_remove(&subscriptions,prev,&params->node);
                    // WARNING: Could not recover jumptable at 0x23027f3a. Too many branches
                    // WARNING: Treating indirect jump as call
  (*params->notify)(conn,params,(void *)0x0,0);
  return;
}



void gatt_mtu_rsp(bt_conn *conn,u8_t err,void *pdu,u16_t length,void *user_data)

{
                    // WARNING: Could not recover jumptable at 0x23027f42. Too many branches
                    // WARNING: Treating indirect jump as call
  (**(code **)((int)user_data + 0x18))(user_data);
  return;
}



void gatt_write_rsp(bt_conn *conn,u8_t err,void *pdu,u16_t length,void *user_data)

{
                    // WARNING: Could not recover jumptable at 0x23027f4a. Too many branches
                    // WARNING: Treating indirect jump as call
  (**(code **)((int)user_data + 0x18))(user_data);
  return;
}



bt_gatt_ccc_cfg * find_ccc_cfg(bt_conn *conn,_bt_gatt_ccc_conflict2 *ccc)

{
  int iVar1;
  undefined4 uStack24;
  undefined2 uStack20;
  undefined uStack18;
  
  if (conn == (bt_conn *)0x0) {
    uStack24 = 0;
    uStack20 = 0;
    uStack18 = 0;
    iVar1 = memcmp(&ccc->cfg[0].peer,&uStack24,7);
    if (iVar1 == 0) {
LAB_23027f70:
      iVar1 = 0;
      goto LAB_23027f72;
    }
    uStack24 = 0;
    uStack20 = 0;
    uStack18 = 0;
    iVar1 = memcmp(&ccc->cfg[1].peer,&uStack24,7);
  }
  else {
    if ((conn->id == ccc->cfg[0].id) &&
       (iVar1 = bt_conn_addr_le_cmp(conn,&ccc->cfg[0].peer), iVar1 == 0)) goto LAB_23027f70;
    if (conn->id != ccc->cfg[1].id) {
      return (bt_gatt_ccc_cfg *)0x0;
    }
    iVar1 = bt_conn_addr_le_cmp(conn,&ccc->cfg[1].peer);
  }
  if (iVar1 != 0) {
    return (bt_gatt_ccc_cfg *)0x0;
  }
  iVar1 = 10;
LAB_23027f72:
  return (bt_gatt_ccc_cfg *)(&ccc->cfg[0].id + iVar1);
}



int gatt_notify(bt_conn *conn,u16_t handle,bt_gatt_notify_params_conflict1 *params)

{
  net_buf *buf;
  undefined *puVar1;
  int iVar2;
  
  buf = bt_att_create_pdu(conn,'\x1b',(uint)params->len + 2);
  if (buf != (net_buf *)0x0) {
    puVar1 = (undefined *)net_buf_simple_add((net_buf_simple *)&buf->field_4,2);
    *puVar1 = (char)handle;
    puVar1[1] = (char)(handle >> 8);
    net_buf_simple_add((net_buf_simple *)&buf->field_4,(uint)params->len);
    memcpy(puVar1 + 2,params->data,(uint)params->len);
    iVar2 = bt_att_send(conn,buf,(bt_conn_tx_cb_t *)params->func,params->user_data);
    return iVar2;
  }
  printf("No buffer available to send notification\r\n");
  return -0xc;
}



void gatt_read_multiple_rsp(bt_conn *conn,u8_t err,void *pdu,u16_t length,void *user_data)

{
  code *UNRECOVERED_JUMPTABLE;
  undefined3 in_register_0000202d;
  int iVar1;
  undefined2 in_register_00002036;
  
  iVar1 = CONCAT31(in_register_0000202d,err);
  UNRECOVERED_JUMPTABLE = *(code **)((int)user_data + 0x18);
  if ((iVar1 == 0) && (CONCAT22(in_register_00002036,length) != 0)) {
    (*UNRECOVERED_JUMPTABLE)(user_data,pdu,CONCAT22(in_register_00002036,length),0);
    UNRECOVERED_JUMPTABLE = *(code **)((int)user_data + 0x18);
    iVar1 = 0;
  }
                    // WARNING: Could not recover jumptable at 0x23028086. Too many branches
                    // WARNING: Treating indirect jump as call
  (*UNRECOVERED_JUMPTABLE)(conn,iVar1,user_data,0,0);
  return;
}



// WARNING: Type propagation algorithm not settling

void gatt_write_ccc_rsp(bt_conn *conn,u8_t err,void *pdu,u16_t length,void *user_data)

{
  sys_snode_t sVar1;
  undefined3 in_register_0000202d;
  sys_snode_t prev;
  sys_snode_t sVar2;
  
  atomic_and((atomic_t *)((int)user_data + 0x2c),-3);
  if (CONCAT31(in_register_0000202d,err) == 0) {
                    // WARNING: Could not recover jumptable at 0x230280fa. Too many branches
                    // WARNING: Treating indirect jump as call
    (**(code **)((int)user_data + 0x20))(conn,user_data,0,0);
    return;
  }
  if (subscriptions.head != (sys_snode_t *)0x0) {
    sVar1 = (sys_snode_t)(subscriptions.head)->next;
    sVar2 = (sys_snode_t)subscriptions.head;
    while( true ) {
      prev = sVar1;
      if (sVar2 == (sys_snode_t)((int)user_data + 0x30)) {
        gatt_subscription_remove(conn,(sys_snode_t *)prev,(bt_gatt_subscribe_params *)user_data);
        return;
      }
      if (prev == (sys_snode_t)0x0) break;
      sVar1 = *(sys_snode_t *)prev;
      sVar2 = prev;
    }
  }
  return;
}



int gatt_send(bt_conn *conn,net_buf *buf,bt_att_func_t *func,void *params)

{
  int iVar1;
  
  if (params == (void *)0x0) {
    iVar1 = bt_att_send(conn,buf,(bt_conn_tx_cb_t *)0x0,(void *)0x0);
  }
  else {
    *(net_buf **)((int)params + 0x10) = buf;
    *(bt_att_func_t **)((int)params + 4) = func;
    *(undefined4 *)((int)params + 8) = 0;
    iVar1 = bt_att_req_send(conn,(bt_att_req_conflict26 *)params);
  }
  if (iVar1 != 0) {
    printf("Error sending ATT PDU: %d\r\n",iVar1);
  }
  return iVar1;
}



int gatt_indicate(bt_conn *conn,u16_t handle,bt_gatt_indicate_params_conflict2 *params)

{
  net_buf *buf;
  undefined *puVar1;
  int iVar2;
  code *func;
  
  buf = bt_att_create_pdu(conn,'\x1d',(uint)params->len + 2);
  if (buf != (net_buf *)0x0) {
    puVar1 = (undefined *)net_buf_simple_add((net_buf_simple *)&buf->field_4,2);
    *puVar1 = (char)handle;
    puVar1[1] = (char)(handle >> 8);
    net_buf_simple_add((net_buf_simple *)&buf->field_4,(uint)params->len);
    memcpy(puVar1 + 2,params->data,(uint)params->len);
    if (params->func == (bt_gatt_indicate_func_t *)0x0) {
      params = (bt_gatt_indicate_params_conflict2 *)0x0;
      func = (bt_att_func_t *)0x0;
    }
    else {
      func = gatt_indicate_rsp;
    }
    iVar2 = gatt_send(conn,buf,func,params);
    return iVar2;
  }
  printf("No buffer available to send indication\r\n");
  return -0xc;
}



undefined4 match_uuid(undefined4 param_1,undefined4 *param_2)

{
  *param_2 = param_1;
  return 0;
}



void sc_indicate_rsp(bt_conn *conn,bt_gatt_attr *attr,u8_t err)

{
  uint uVar1;
  
  atomic_and(gatt_sc.flags,-3);
  uVar1 = atomic_get(gatt_sc.flags);
  if ((uVar1 & 1) != 0) {
    k_delayed_work_submit((k_delayed_work *)&gatt_sc.work,0);
    return;
  }
  return;
}



u8_t disconnected_cb(bt_gatt_attr *attr,void *user_data)

{
  bool bVar1;
  bt_addr_le_t *peer;
  _Bool _Var2;
  bt_conn *conn;
  int iVar3;
  undefined3 extraout_var;
  void *pvVar4;
  undefined4 uStack56;
  undefined2 uStack52;
  undefined uStack50;
  
  if (attr->write == bt_gatt_attr_write_ccc) {
    pvVar4 = attr->user_data;
    if (*(short *)((int)pvVar4 + 0x14) != 0) {
      peer = (bt_addr_le_t *)((int)pvVar4 + 1);
      bVar1 = false;
      do {
        if (*(short *)(peer + 1) != 0) {
          if ((*(u8_t *)((int)user_data + 8) == peer[-1].a.val[5]) &&
             (iVar3 = bt_conn_addr_le_cmp((bt_conn *)user_data,peer), iVar3 == 0)) {
            _Var2 = bt_addr_le_is_bonded
                              (*(u8_t *)((int)user_data + 8),(bt_addr_le_t *)((int)user_data + 0x70)
                              );
            if (CONCAT31(extraout_var,_Var2) == 0) {
              uStack56 = 0;
              uStack52 = 0;
              uStack50 = 0;
              memcpy(peer,&uStack56,7);
              peer[-1].a.val[5] = '\0';
              *(undefined2 *)(peer + 1) = 0;
            }
            else {
              memcpy(peer,(bt_addr_le_t *)((int)user_data + 0x70),7);
            }
          }
          else {
            conn = bt_conn_lookup_addr_le(peer[-1].a.val[5],peer);
            if (conn != (bt_conn *)0x0) {
              if (conn->state == BT_CONN_CONNECTED) {
                bVar1 = true;
              }
              bt_conn_unref(conn);
            }
          }
        }
        peer = (bt_addr_le_t *)(peer[1].a.val + 2);
      } while (peer != (bt_addr_le_t *)((int)pvVar4 + 0x15));
      if (!bVar1) {
        *(undefined2 *)((int)pvVar4 + 0x14) = 0;
        if (*(code **)((int)pvVar4 + 0x18) != (code *)0x0) {
          (**(code **)((int)pvVar4 + 0x18))(attr,0);
        }
      }
    }
    return '\x01';
  }
  return '\x01';
}



gatt_sc_cfg * find_sc_cfg(u8_t id,bt_addr_le_t *addr)

{
  int iVar1;
  undefined3 in_register_00002029;
  int iVar2;
  gatt_sc_cfg *pgVar3;
  
  pgVar3 = sc_cfg;
  iVar1 = 0;
  do {
    if ((uint)pgVar3->id == CONCAT31(in_register_00002029,id)) {
      iVar2 = memcmp(&pgVar3->peer,addr,7);
      if (iVar2 == 0) {
        return sc_cfg + iVar1;
      }
    }
    iVar1 = iVar1 + 1;
    pgVar3 = pgVar3 + 1;
  } while (iVar1 != 4);
  return (gatt_sc_cfg *)0x0;
}



int gatt_write_ccc(bt_conn *conn,u16_t handle,u16_t value,bt_gatt_subscribe_params *params)

{
  net_buf *buf;
  undefined *puVar1;
  int iVar2;
  
  buf = bt_att_create_pdu(conn,'\x12',4);
  if (buf != (net_buf *)0x0) {
    puVar1 = (undefined *)net_buf_simple_add((net_buf_simple *)&buf->field_4,2);
    *puVar1 = (char)handle;
    puVar1[1] = (char)(handle >> 8);
    net_buf_simple_add_le16((net_buf_simple *)&buf->field_4,value);
    atomic_or(params->flags,2);
    iVar2 = gatt_send(conn,buf,gatt_write_ccc_rsp,params);
    return iVar2;
  }
  return -0xc;
}



ssize_t read_appearance(bt_conn *conn,bt_gatt_attr *attr,void *buf,u16_t len,u16_t offset)

{
  size_t __n;
  undefined2 in_register_00002036;
  undefined2 in_register_0000203a;
  uint uVar1;
  undefined2 auStack18 [2];
  u16_t appearance;
  
  uVar1 = CONCAT22(in_register_0000203a,offset);
  auStack18[0] = 0x341;
  __n = 0xfffffff9;
  if (uVar1 < 3) {
    __n = 2 - uVar1;
    if ((int)CONCAT22(in_register_00002036,len) < (int)(2 - uVar1)) {
      __n = CONCAT22(in_register_00002036,len);
    }
    memcpy(buf,(void *)((int)auStack18 + uVar1),__n);
  }
  return __n;
}



// WARNING: Could not reconcile some variable overlaps

ssize_t read_ppcp(bt_conn *conn,bt_gatt_attr *attr,void *buf,u16_t len,u16_t offset)

{
  size_t __n;
  undefined2 in_register_00002036;
  undefined2 in_register_0000203a;
  uint uVar1;
  undefined4 uStack24;
  anon_struct_for_ppcp ppcp;
  
  uVar1 = CONCAT22(in_register_0000203a,offset);
  uStack24 = 0x280018;
  ppcp._0_4_ = 0x1900000;
  __n = 0xfffffff9;
  if (uVar1 < 9) {
    __n = 8 - uVar1;
    if ((int)CONCAT22(in_register_00002036,len) < (int)(8 - uVar1)) {
      __n = CONCAT22(in_register_00002036,len);
    }
    memcpy(buf,(void *)((int)&uStack24 + uVar1),__n);
  }
  return __n;
}



ssize_t read_name(bt_conn *conn,bt_gatt_attr *attr,void *buf,u16_t len,u16_t offset)

{
  uint __n;
  char *__s;
  size_t sVar1;
  undefined2 in_register_00002036;
  undefined2 in_register_0000203a;
  uint uVar2;
  
  uVar2 = CONCAT22(in_register_0000203a,offset);
  __s = bt_get_name();
  sVar1 = strlen(__s);
  __n = 0xfffffff9;
  if (uVar2 <= (sVar1 & 0xffff)) {
    __n = (sVar1 & 0xffff) - uVar2;
    if ((int)CONCAT22(in_register_00002036,len) < (int)__n) {
      __n = CONCAT22(in_register_00002036,len);
    }
    __n = __n & 0xffff;
    memcpy(buf,__s + uVar2,__n);
  }
  return __n;
}



ssize_t bt_gatt_attr_read_ccc(bt_conn *conn,bt_gatt_attr *attr,void *buf,u16_t len,u16_t offset)

{
  size_t __n;
  bt_gatt_ccc_cfg *pbVar1;
  undefined2 in_register_00002036;
  undefined2 in_register_0000203a;
  uint uVar2;
  u16_t auStack18 [2];
  u16_t value;
  
  uVar2 = CONCAT22(in_register_0000203a,offset);
  pbVar1 = find_ccc_cfg(conn,(_bt_gatt_ccc_conflict2 *)attr->user_data);
  auStack18[0] = 0;
  if (pbVar1 != (bt_gatt_ccc_cfg *)0x0) {
    auStack18[0] = pbVar1->value;
  }
  __n = 0xfffffff9;
  if (uVar2 < 3) {
    __n = 2 - uVar2;
    if ((int)CONCAT22(in_register_00002036,len) < (int)(2 - uVar2)) {
      __n = CONCAT22(in_register_00002036,len);
    }
    memcpy(buf,(void *)((int)auStack18 + uVar2),__n);
  }
  return __n;
}



ssize_t bt_gatt_attr_read_service(bt_conn *conn,bt_gatt_attr *attr,void *buf,u16_t len,u16_t offset)

{
  size_t __n;
  char *pcVar1;
  undefined2 in_register_00002036;
  size_t sVar2;
  undefined2 in_register_0000203a;
  uint uVar3;
  undefined2 *puVar4;
  undefined2 auStack18 [2];
  u16_t uuid16;
  
  uVar3 = CONCAT22(in_register_0000203a,offset);
  sVar2 = CONCAT22(in_register_00002036,len);
  pcVar1 = (char *)attr->user_data;
  if (*pcVar1 == '\0') {
    auStack18[0] = *(undefined2 *)(pcVar1 + 2);
    if (2 < uVar3) {
      return -7;
    }
    __n = 2 - uVar3;
    if ((int)sVar2 < (int)(2 - uVar3)) {
      __n = sVar2;
    }
    puVar4 = auStack18;
  }
  else {
    puVar4 = (undefined2 *)(pcVar1 + 1);
    if (0x10 < uVar3) {
      return -7;
    }
    __n = 0x10 - uVar3;
    if ((int)sVar2 < (int)(0x10 - uVar3)) {
      __n = sVar2;
    }
  }
  memcpy(buf,(void *)((int)puVar4 + uVar3),__n);
  return __n;
}



void sc_save(u8_t id,bt_addr_le_t *peer,u16_t start,u16_t end)

{
  ushort uVar1;
  ushort uVar2;
  gatt_sc_cfg *pgVar3;
  undefined2 in_register_00002032;
  undefined2 in_register_00002036;
  undefined4 uStack40;
  undefined2 uStack36;
  u8_t uStack34;
  
  pgVar3 = find_sc_cfg(id,peer);
  if (pgVar3 == (gatt_sc_cfg *)0x0) {
    uStack40 = 0;
    uStack36 = 0;
    uStack34 = '\0';
    pgVar3 = find_sc_cfg('\0',(bt_addr_le_t *)&uStack40);
    if (pgVar3 == (gatt_sc_cfg *)0x0) {
      printf("unable to save SC: no cfg left\r\n");
      return;
    }
    pgVar3->id = id;
    memcpy(&pgVar3->peer,peer,7);
  }
  uVar1 = (pgVar3->data).start;
  uVar2 = (pgVar3->data).end;
  if (uVar1 == 0) {
    if (uVar2 == 0) {
      (pgVar3->data).start = start;
      goto LAB_230285e6;
    }
  }
  else {
    if (CONCAT22(in_register_00002032,start) < (uint)uVar1) {
      (pgVar3->data).start = start;
    }
  }
  if (CONCAT22(in_register_00002036,end) <= (uint)uVar2) {
    return;
  }
LAB_230285e6:
  (pgVar3->data).end = end;
  return;
}



_Bool sc_ccc_cfg_write(bt_conn *conn,bt_gatt_attr *attr,u16_t value)

{
  gatt_sc_cfg *__s;
  undefined2 in_register_00002032;
  
  if (CONCAT22(in_register_00002032,value) == 2) {
    sc_save(conn->id,(bt_addr_le_t *)conn->field_20,0,0);
  }
  else {
    __s = find_sc_cfg(conn->id,(bt_addr_le_t *)conn->field_20);
    if (__s != (gatt_sc_cfg *)0x0) {
      memset(__s,0,0xc);
    }
  }
  return true;
}



u8_t notify_cb(bt_gatt_attr *attr,void *user_data)

{
  bt_addr_le_t *peer;
  gatt_sc_cfg *pgVar1;
  _Bool _Var2;
  bt_conn *conn;
  undefined3 extraout_var;
  int iVar3;
  u16_t handle;
  u16_t *puVar4;
  _bt_gatt_ccc_conflict2 *p_Var5;
  undefined4 uStack56;
  undefined2 uStack52;
  undefined uStack50;
  
  if (attr->write != bt_gatt_attr_write_ccc) {
    return '\x01';
  }
  p_Var5 = (_bt_gatt_ccc_conflict2 *)attr->user_data;
  if (p_Var5 == &sc_ccc) {
    pgVar1 = sc_cfg;
    do {
      peer = (bt_addr_le_t *)
             ((int)&(((bt_gatt_indicate_params_conflict3 *)pgVar1)->_req).node.next + 1);
      uStack56 = 0;
      uStack52 = 0;
      uStack50 = 0;
      iVar3 = memcmp(peer,&uStack56,7);
      if (iVar3 != 0) {
        conn = bt_conn_lookup_state_le(peer,BT_CONN_CONNECTED);
        if (conn == (bt_conn *)0x0) {
          puVar4 = *(u16_t **)(*(int *)((int)user_data + 8) + 0x24);
          sc_save(*(u8_t *)&(((bt_gatt_indicate_params_conflict3 *)pgVar1)->_req).node.next,peer,
                  *puVar4,puVar4[1]);
        }
        else {
          bt_conn_unref(conn);
        }
      }
      pgVar1 = (gatt_sc_cfg *)&(((bt_gatt_indicate_params_conflict3 *)pgVar1)->_req).state;
    } while ((bt_gatt_indicate_params_conflict3 *)pgVar1 != sc_restore_params);
  }
  peer = &p_Var5->cfg[0].peer;
  do {
    if ((*(short *)(peer + 1) == *(short *)((int)user_data + 4)) &&
       (conn = bt_conn_lookup_addr_le(peer[-1].a.val[5],peer), conn != (bt_conn *)0x0)) {
      if ((conn->state == BT_CONN_CONNECTED) &&
         ((p_Var5->cfg_match == (anon_subr__Bool_bt_conn_ptr_bt_gatt_attr_ptr_for_cfg_match *)0x0 ||
          (_Var2 = (*p_Var5->cfg_match)(conn,attr), CONCAT31(extraout_var,_Var2) != 0)))) {
        handle = attr->handle - 1;
        if (*(short *)((int)user_data + 4) == 2) {
          iVar3 = gatt_indicate(conn,handle,
                                *(bt_gatt_indicate_params_conflict2 **)((int)user_data + 8));
        }
        else {
          iVar3 = gatt_notify(conn,handle,
                              (bt_gatt_notify_params_conflict1 *)
                              *(bt_gatt_indicate_params_conflict2 **)((int)user_data + 8));
        }
        bt_conn_unref(conn);
        if (iVar3 < 0) {
          return '\0';
        }
        *(undefined4 *)user_data = 0;
      }
      else {
        bt_conn_unref(conn);
      }
    }
    peer = (bt_addr_le_t *)(peer[1].a.val + 2);
    if ((bt_addr_le_t *)((int)&p_Var5->value + 1) == peer) {
      return '\x01';
    }
  } while( true );
}



void sc_indicate(u16_t start,u16_t end)

{
  u16_t uVar1;
  undefined2 in_register_0000202a;
  bt_conn *conn;
  uint uVar2;
  atomic_val_t aVar3;
  undefined2 in_register_0000202e;
  
  conn = bt_conn_lookup_state_le((bt_addr_le_t *)0x0,BT_CONN_CONNECTED);
  if ((conn == (bt_conn *)0x0) ||
     (uVar2 = atomic_or(gatt_sc.flags,1), uVar1 = start, (uVar2 & 1) != 0)) {
    if (CONCAT22(in_register_0000202a,start) < (uint)gatt_sc.start) {
      gatt_sc.start = start;
      uVar1 = start;
      if (CONCAT22(in_register_0000202e,end) <= (uint)gatt_sc.end) goto submit;
    }
    else {
      uVar1 = gatt_sc.start;
      if (CONCAT22(in_register_0000202e,end) <= (uint)gatt_sc.end) {
        return;
      }
    }
  }
  gatt_sc.start = uVar1;
  gatt_sc.end = end;
submit:
  aVar3 = atomic_get(gatt_sc.flags);
  if (((aVar3 >> 1 & 1U) == 0) && (conn != (bt_conn *)0x0)) {
    k_delayed_work_submit((k_delayed_work *)&gatt_sc.work,10);
    bt_conn_unref(conn);
    return;
  }
  return;
}



ssize_t bt_gatt_attr_write_ccc
                  (bt_conn *conn,bt_gatt_attr *attr,void *buf,u16_t len,u16_t offset,u8_t flags)

{
  uint uVar1;
  _Bool _Var2;
  bt_gatt_ccc_cfg *pbVar3;
  undefined3 extraout_var;
  undefined2 in_register_00002036;
  undefined2 in_register_0000203a;
  int iVar4;
  _bt_gatt_ccc_conflict2 *ccc;
  undefined4 uStack40;
  undefined2 uStack36;
  undefined uStack34;
  
  iVar4 = CONCAT22(in_register_00002036,len);
  ccc = (_bt_gatt_ccc_conflict2 *)attr->user_data;
  if (CONCAT22(in_register_0000203a,offset) != 0) {
    return -7;
  }
  if (1 < (iVar4 - 1U & 0xffff)) {
    return -0xd;
  }
  uVar1 = (uint)*(byte *)buf;
  if (iVar4 != 1) {
    uVar1 = (uint)CONCAT11(*(undefined *)((int)buf + 1),*(byte *)buf);
  }
  pbVar3 = find_ccc_cfg(conn,ccc);
  if (pbVar3 == (bt_gatt_ccc_cfg *)0x0) {
    if (uVar1 == 0) {
      return iVar4;
    }
    pbVar3 = find_ccc_cfg((bt_conn *)0x0,ccc);
    if (pbVar3 == (bt_gatt_ccc_cfg *)0x0) {
      printf("No space to store CCC cfg\r\n");
      return -0x11;
    }
    memcpy(&pbVar3->peer,conn->field_20,7);
    pbVar3->id = conn->id;
  }
  if ((ccc->cfg_write == (anon_subr__Bool_bt_conn_ptr_bt_gatt_attr_ptr_u16_t_for_cfg_write *)0x0) ||
     (_Var2 = (*ccc->cfg_write)(conn,attr,(u16_t)uVar1), CONCAT31(extraout_var,_Var2) != 0)) {
    pbVar3->value = (u16_t)uVar1;
    if ((uint)ccc->value != uVar1) {
      gatt_ccc_changed(attr,ccc);
    }
    if (uVar1 == 0) {
      uStack40 = 0;
      uStack36 = 0;
      uStack34 = 0;
      memcpy(&pbVar3->peer,&uStack40,7);
      pbVar3->id = '\0';
      pbVar3->value = 0;
    }
  }
  else {
    iVar4 = -3;
  }
  return iVar4;
}



void bt_gatt_init(void)

{
  anon_subr_int_bt_conn_ptr_bt_l2cap_chan_ptr_ptr_for_accept **ppaVar1;
  bool bVar2;
  int iVar3;
  uint uVar4;
  bt_gatt_service_static *pbVar5;
  
  iVar3 = atomic_cas(&init,0,1);
  if (iVar3 != 0) {
    uVar4 = (uint)last_static_handle;
    bVar2 = false;
    pbVar5 = &_1_gatt_svc;
    while (pbVar5 < &att_fixed_chan) {
      ppaVar1 = &((bt_l2cap_fixed_chan *)pbVar5)->accept;
      pbVar5 = (bt_gatt_service_static *)&((bt_l2cap_fixed_chan *)pbVar5)->node;
      uVar4 = (uint)(*ppaVar1 + uVar4) & 0xffff;
      bVar2 = true;
    }
    if (bVar2) {
      last_static_handle = (u16_t)uVar4;
    }
    k_delayed_work_init((k_delayed_work *)&gatt_sc.work,sc_process);
    return;
  }
  return;
}



void bt_gatt_deinit(void)

{
  k_delayed_work_del_timer((k_delayed_work *)&gatt_sc.work);
  return;
}



undefined4 bt_gatt_service_unregister(int *param_1)

{
  sys_snode_t prev_node;
  sys_snode_t sVar1;
  
  prev_node = (sys_snode_t)0x0;
  sVar1 = (sys_snode_t)db.head;
  while( true ) {
    if (sVar1 == (sys_snode_t)0x0) {
      return 0xfffffffe;
    }
    if ((sys_snode_t)(param_1 + 2) == sVar1) break;
    prev_node = sVar1;
    sVar1 = *(sys_snode_t *)sVar1;
  }
  sys_slist_remove(&db,(sys_snode_t *)prev_node,(sys_snode_t *)(param_1 + 2));
  sc_indicate(*(u16_t *)(*param_1 + 0x10),*(u16_t *)(param_1[1] * 0x14 + *param_1 + -4));
  return 0;
}



ssize_t bt_gatt_attr_read(bt_conn *conn,bt_gatt_attr *attr,void *buf,u16_t buf_len,u16_t offset,
                         void *value,u16_t value_len)

{
  uint __n;
  undefined2 in_register_00002036;
  undefined2 in_register_0000203a;
  uint uVar1;
  undefined2 in_register_00002042;
  
  uVar1 = CONCAT22(in_register_0000203a,offset);
  __n = 0xfffffff9;
  if (uVar1 <= CONCAT22(in_register_00002042,value_len)) {
    __n = CONCAT22(in_register_00002042,value_len) - uVar1;
    if ((int)CONCAT22(in_register_00002036,buf_len) < (int)__n) {
      __n = CONCAT22(in_register_00002036,buf_len);
    }
    __n = __n & 0xffff;
    memcpy(buf,(void *)((int)value + uVar1),__n);
  }
  return __n;
}



uint16_t bt_gatt_attr_value_handle(bt_gatt_attr *attr)

{
  u16_t uVar1;
  undefined2 extraout_var;
  uint16_t uVar2;
  
  if (attr == (bt_gatt_attr *)0x0) {
    uVar2 = 0;
  }
  else {
    uVar2 = 0;
    if ((attr->read == bt_gatt_attr_read_chrc) &&
       (uVar2 = *(uint16_t *)((int)attr->user_data + 4), uVar2 == 0)) {
      if (attr->handle == 0) {
        uVar1 = find_static_attr(attr);
        return (uint16_t)((uint)((CONCAT22(extraout_var,uVar1) + 1) * 0x10000) >> 0x10);
      }
      uVar2 = attr->handle + 1;
    }
  }
  return uVar2;
}



uint lexical_block_0(bt_gatt_attr *param_1)

{
  ushort uVar1;
  u16_t uVar2;
  uint uVar3;
  
  uVar1 = *(ushort *)((int)param_1->user_data + 4);
  uVar3 = (uint)uVar1;
  if (uVar1 == 0) {
    if (param_1->handle == 0) {
      uVar2 = find_static_attr(param_1);
      return (uint)uVar2 + 1 & 0xffff;
    }
    uVar3 = (uint)param_1->handle + 1 & 0xffff;
  }
  return uVar3;
}



ssize_t bt_gatt_attr_read_chrc(bt_conn *conn,bt_gatt_attr *attr,void *buf,u16_t len,u16_t offset)

{
  char **ppcVar1;
  uint __n;
  uint16_t uVar2;
  char *pcVar3;
  undefined2 in_register_00002036;
  undefined2 in_register_0000203a;
  uint uVar4;
  uint uVar5;
  u8_t auStack52 [4];
  gatt_chrc pdu;
  
  uVar4 = CONCAT22(in_register_0000203a,offset);
  ppcVar1 = (char **)attr->user_data;
  auStack52[0] = *(u8_t *)((int)ppcVar1 + 6);
  uVar2 = bt_gatt_attr_value_handle(attr);
  auStack52[1] = (u8_t)uVar2;
  auStack52[2] = (u8_t)(uVar2 >> 8);
  pcVar3 = *ppcVar1;
  if (*pcVar3 == '\0') {
    auStack52[3] = (u8_t)*(undefined2 *)(pcVar3 + 2);
    pdu.properties = (u8_t)((ushort)*(undefined2 *)(pcVar3 + 2) >> 8);
    uVar5 = 5;
  }
  else {
    memcpy(auStack52 + 3,pcVar3 + 1,0x10);
    uVar5 = 0x13;
  }
  __n = 0xfffffff9;
  if (uVar4 <= uVar5) {
    __n = uVar5 - uVar4;
    if ((int)CONCAT22(in_register_00002036,len) < (int)(uVar5 - uVar4)) {
      __n = CONCAT22(in_register_00002036,len);
    }
    __n = __n & 0xffff;
    memcpy(buf,auStack52 + uVar4,__n);
  }
  return __n;
}



// WARNING: Could not reconcile some variable overlaps

void bt_gatt_foreach_attr_type
               (u16_t start_handle,u16_t end_handle,bt_uuid *uuid,void *attr_data,
               uint16_t num_matches,bt_gatt_attr_func_t *func,void *user_data)

{
  uint uVar1;
  anon_subr_int_bt_conn_ptr_bt_l2cap_chan_ptr_ptr_for_accept *paVar2;
  sys_snode_t sVar3;
  u8_t uVar4;
  undefined2 in_register_0000202a;
  anon_subr_int_bt_conn_ptr_bt_l2cap_chan_ptr_ptr_for_accept *paVar5;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  int iVar6;
  undefined2 in_register_0000202e;
  undefined2 in_register_0000203a;
  sys_snode_t sVar7;
  _snode *p_Var8;
  anon_subr_int_bt_conn_ptr_bt_l2cap_chan_ptr_ptr_for_accept *paVar9;
  bt_gatt_attr *pbVar10;
  anon_subr_int_bt_conn_ptr_bt_l2cap_chan_ptr_ptr_for_accept *paVar11;
  bt_gatt_service_static *pbVar12;
  bt_uuid *pbStack84;
  bt_gatt_attr attr;
  
  uVar1 = CONCAT22(in_register_0000203a,num_matches);
  paVar5 = (anon_subr_int_bt_conn_ptr_bt_l2cap_chan_ptr_ptr_for_accept *)
           CONCAT22(in_register_0000202a,start_handle);
  if (uVar1 == 0) {
    uVar1 = 0xffff;
  }
  if (paVar5 <= (anon_subr_int_bt_conn_ptr_bt_l2cap_chan_ptr_ptr_for_accept *)
                (uint)last_static_handle) {
    pbVar12 = &_1_gatt_svc;
    paVar9 = (anon_subr_int_bt_conn_ptr_bt_l2cap_chan_ptr_ptr_for_accept *)0x1;
    while (pbVar12 < &att_fixed_chan) {
      if (((bt_l2cap_fixed_chan *)pbVar12)->accept + (int)paVar9 < paVar5) {
        paVar2 = (anon_subr_int_bt_conn_ptr_bt_l2cap_chan_ptr_ptr_for_accept *)
                 ((uint)(((bt_l2cap_fixed_chan *)pbVar12)->accept + (int)paVar9) & 0xffff);
      }
      else {
        paVar11 = (anon_subr_int_bt_conn_ptr_bt_l2cap_chan_ptr_ptr_for_accept *)0x0;
        while( true ) {
          paVar2 = (anon_subr_int_bt_conn_ptr_bt_l2cap_chan_ptr_ptr_for_accept *)
                   ((uint)(paVar11 + (int)paVar9) & 0xffff);
          if (((bt_l2cap_fixed_chan *)pbVar12)->accept <= paVar11) break;
          memcpy(&pbStack84,(void *)((int)paVar11 * 0x14 + *(int *)pbVar12),0x14);
          attr.user_data._0_2_ = (u16_t)((uint)((int)(paVar11 + (int)paVar9) * 0x10000) >> 0x10);
          if ((anon_subr_int_bt_conn_ptr_bt_l2cap_chan_ptr_ptr_for_accept *)
              CONCAT22(in_register_0000202e,end_handle) < paVar2) {
            return;
          }
          if (((paVar5 <= paVar2) &&
              ((uuid == (bt_uuid *)0x0 || (iVar6 = bt_uuid_cmp(uuid,pbStack84), iVar6 == 0)))) &&
             ((attr_data == (void *)0x0 ||
              ((anon_subr_ssize_t_bt_conn_ptr_bt_gatt_attr_ptr_void_ptr_u16_t_u16_t_u8_t_for_write *
               )attr_data == attr.write)))) {
            uVar1 = uVar1 - 1 & 0xffff;
            uVar4 = (*func)((bt_gatt_attr *)&pbStack84,user_data);
            if (uVar1 == 0) {
              return;
            }
            if (CONCAT31(extraout_var,uVar4) == 0) {
              return;
            }
          }
          paVar11 = paVar11 + 1;
        }
      }
      pbVar12 = (bt_gatt_service_static *)&((bt_l2cap_fixed_chan *)pbVar12)->node;
      paVar9 = paVar2;
    }
  }
  sVar3 = (sys_snode_t)db.head;
  if (db.head != (sys_snode_t *)0x0) {
    while ((sys_snode_t *)((int)sVar3 + -8) != (sys_snode_t *)0x0) {
      sVar7 = *(sys_snode_t *)sVar3;
      if (((sVar7 == (sys_snode_t)0x0) || (sVar7 == (sys_snode_t)0x8)) ||
         (paVar5 < (anon_subr_int_bt_conn_ptr_bt_l2cap_chan_ptr_ptr_for_accept *)
                   (uint)*(ushort *)(*(int *)((int)sVar7 + -8) + 0x10))) {
        p_Var8 = (_snode *)0x0;
        while (p_Var8 < ((sys_snode_t *)((int)sVar3 + -4))->next) {
          pbVar10 = (bt_gatt_attr *)(((sys_snode_t *)((int)sVar3 + -8))->next + (int)p_Var8 * 5);
          if ((anon_subr_int_bt_conn_ptr_bt_l2cap_chan_ptr_ptr_for_accept *)
              CONCAT22(in_register_0000202e,end_handle) <
              (anon_subr_int_bt_conn_ptr_bt_l2cap_chan_ptr_ptr_for_accept *)(uint)pbVar10->handle) {
            return;
          }
          if (((paVar5 <= (anon_subr_int_bt_conn_ptr_bt_l2cap_chan_ptr_ptr_for_accept *)
                          (uint)pbVar10->handle) &&
              ((uuid == (bt_uuid *)0x0 || (iVar6 = bt_uuid_cmp(uuid,pbVar10->uuid), iVar6 == 0))))
             && ((attr_data == (void *)0x0 || (attr_data == pbVar10->user_data)))) {
            uVar1 = uVar1 - 1 & 0xffff;
            uVar4 = (*func)(pbVar10,user_data);
            if (uVar1 == 0) {
              return;
            }
            if (CONCAT31(extraout_var_00,uVar4) == 0) {
              return;
            }
          }
          p_Var8 = (_snode *)((int)&p_Var8->next + 1);
        }
      }
      sVar3 = *(sys_snode_t *)sVar3;
      if (sVar3 == (sys_snode_t)0x0) {
        return;
      }
    }
  }
  return;
}



void bt_gatt_foreach_attr
               (u16_t start_handle,u16_t end_handle,bt_gatt_attr_func_t *func,void *user_data)

{
  bt_gatt_foreach_attr_type(start_handle,end_handle,(bt_uuid *)0x0,(void *)0x0,0,func,user_data);
  return;
}



int bt_gatt_service_register(bt_uuid **param_1)

{
  ushort start_handle;
  sys_snode_t *psVar1;
  sys_snode_t *psVar2;
  u16_t start_handle_00;
  int iVar3;
  bt_conn *conn;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  uint uVar4;
  sys_snode_t sVar5;
  sys_snode_t *psVar6;
  sys_snode_t *psVar7;
  sys_snode_t *psVar8;
  uint uVar9;
  bt_uuid *pbVar10;
  short sVar11;
  uint uVar12;
  bt_gatt_attr *pbStack88;
  bt_uuid abStack84 [2];
  undefined2 uStack82;
  bt_uuid abStack80 [2];
  undefined2 uStack78;
  int iStack76;
  undefined2 uStack72;
  bt_gatt_indicate_params_conflict2 *pbStack68;
  bt_uuid **ppbStack60;
  sys_slist_t *psStack56;
  undefined4 uStack52;
  bt_uuid abStack44 [2];
  undefined2 uStack42;
  undefined auStack40 [2];
  undefined2 uStack38;
  bt_att_func_t *pbStack36;
  
  bt_gatt_init();
  abStack44[0] = (bt_uuid)0x0;
  uStack42 = 0x1800;
  iVar3 = bt_uuid_cmp(*(bt_uuid **)*param_1,abStack44);
  if (iVar3 == 0) {
    return 0xffffffbb;
  }
  pbStack68 = (bt_gatt_indicate_params_conflict2 *)auStack40;
  auStack40[0] = 0;
  uStack38 = 0x1801;
  uStack52 = 0x23028c68;
  conn = (bt_conn *)bt_uuid_cmp(*(bt_uuid **)*param_1,(bt_uuid *)pbStack68);
  if (conn == (bt_conn *)0x0) {
    return 0xffffffbb;
  }
  pbVar10 = *param_1;
  sVar11 = *(short *)(param_1 + 1);
  if (db.head == (sys_snode_t *)0x0) {
    uVar9 = (uint)last_static_handle;
    uVar12 = 0;
LAB_23028cca:
    while ((psVar1 = db.tail, pbVar10 != (bt_uuid *)0x0 && (sVar11 != 0))) {
      start_handle = *(ushort *)(pbVar10 + 0x10);
      if (start_handle == 0) {
        *(short *)(pbVar10 + 0x10) = (short)((uVar9 + 1) * 0x10000 >> 0x10);
        uVar4 = uVar9 + 1 & 0xffff;
      }
      else {
        uVar4 = (uint)start_handle;
        if ((uint)start_handle <= uVar9) {
          pbStack36 = (bt_att_func_t *)0x0;
          bt_gatt_foreach_attr(start_handle,start_handle,found_attr,&pbStack36);
          uVar4 = uVar9;
          if (pbStack36 != (bt_att_func_t *)0x0) {
            printf("Unable to register handle 0x%04x\r\n");
            return 0xffffffea;
          }
        }
      }
      sVar11 = sVar11 + -1;
      pbVar10 = pbVar10 + 0x14;
      uVar9 = uVar4;
    }
    if ((uVar12 == 0) || (uVar12 < (uint)*(ushort *)(*param_1 + 0x10))) {
LAB_23028ce4:
      psVar8 = (sys_snode_t *)(param_1 + 2);
      psVar8->next = (_snode *)0x0;
      psVar2 = psVar8;
      if (db.tail != (sys_snode_t *)0x0) {
        *(sys_snode_t **)&(db.tail)->next = psVar8;
LAB_23028d62:
        psVar8 = db.head;
        psVar2 = (sys_snode_t *)(param_1 + 2);
      }
    }
    else {
      psVar8 = db.head;
      psVar2 = db.tail;
      if (db.head != (sys_snode_t *)0x0) {
        psVar6 = (sys_snode_t *)0x0;
        sVar5 = (sys_snode_t)db.head;
        while (psVar7 = (sys_snode_t *)((int)sVar5 + -8), psVar7 != (sys_snode_t *)0x0) {
          if ((uint)*(ushort *)(*param_1 + 0x10) < (uint)*(ushort *)&psVar7->next[4].next) {
            psVar8 = (sys_snode_t *)(param_1 + 2);
            if (psVar6 == (sys_snode_t *)0x0) {
              *(sys_snode_t **)(param_1 + 2) = db.head;
              db.head = psVar8;
              psVar2 = db.tail;
              if (psVar1 == (sys_snode_t *)0x0) goto LAB_23028d62;
            }
            else {
              if (psVar6[2].next == (_snode *)0x0) goto LAB_23028ce4;
              *(_snode **)(param_1 + 2) = psVar6[2].next;
              *(sys_snode_t **)&psVar6[2].next = psVar8;
              psVar8 = db.head;
              psVar2 = db.tail;
            }
            break;
          }
          sVar5 = *(sys_snode_t *)sVar5;
          psVar6 = psVar7;
          if (sVar5 == (sys_snode_t)0x0) break;
        }
      }
    }
    db.tail = psVar2;
    db.head = psVar8;
    sc_indicate(*(u16_t *)(*param_1 + 0x10),*(u16_t *)(*param_1 + (int)param_1[1] * 0x14 + -4));
    return 0;
  }
  if (db.tail != (sys_snode_t *)0x0) {
    uVar9 = (uint)*(ushort *)&db.tail[-2].next[(int)db.tail[-1].next * 5 + -1].next;
    uVar12 = uVar9;
    goto LAB_23028cca;
  }
  ebreak();
  psStack56 = &db;
  pbStack88 = pbStack68->attr;
  if ((conn != (bt_conn *)0x0) && (conn->state != BT_CONN_CONNECTED)) {
    return 0xffffffc7;
  }
  start_handle_00 = pbStack88->handle;
  ppbStack60 = param_1;
  if ((start_handle_00 == 0) &&
     (start_handle_00 = find_static_attr(pbStack88), CONCAT22(extraout_var,start_handle_00) == 0)) {
LAB_23028db4:
    iStack76 = -2;
  }
  else {
    if (pbStack68->uuid != (bt_uuid *)0x0) {
      pbStack88 = (bt_gatt_attr *)0x0;
      bt_gatt_foreach_attr_type
                (start_handle_00,0xffff,pbStack68->uuid,(void *)0x0,1,match_uuid,&pbStack88);
      if ((pbStack88 == (bt_gatt_attr *)0x0) ||
         ((start_handle_00 = pbStack88->handle, start_handle_00 == 0 &&
          (start_handle_00 = find_static_attr(pbStack88),
          CONCAT22(extraout_var_00,start_handle_00) == 0)))) goto LAB_23028db4;
    }
    abStack84[0] = (bt_uuid)0x0;
    uStack82 = 0x2803;
    iVar3 = bt_uuid_cmp(pbStack88->uuid,abStack84);
    if (iVar3 == 0) {
      if ((*(byte *)((int)pbStack68->attr->user_data + 6) & 0x20) == 0) {
        return 0xffffffea;
      }
      start_handle_00 = bt_gatt_attr_value_handle(pbStack68->attr);
    }
    if (conn == (bt_conn *)0x0) {
      iStack76 = -0x39;
      uStack72 = 2;
      uStack78 = 0x2902;
      abStack80[0] = (bt_uuid)0x0;
      bt_gatt_foreach_attr_type(start_handle_00,0xffff,abStack80,(void *)0x0,1,notify_cb,&iStack76);
    }
    else {
      iStack76 = gatt_indicate(conn,start_handle_00,pbStack68);
    }
  }
  return iStack76;
}



// WARNING: Variable defined which should be unmapped: data
// WARNING: Could not reconcile some variable overlaps

int bt_gatt_indicate(bt_conn *conn,bt_gatt_indicate_params_conflict2 *params)

{
  u16_t start_handle;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  int iVar1;
  bt_gatt_attr *pbStack40;
  bt_gatt_attr *attr;
  bt_uuid abStack32 [2];
  undefined2 uStack30;
  int iStack28;
  notify_data data;
  
  pbStack40 = params->attr;
  if ((conn != (bt_conn *)0x0) && (conn->state != BT_CONN_CONNECTED)) {
    return -0x39;
  }
  start_handle = pbStack40->handle;
  if ((start_handle == 0) &&
     (start_handle = find_static_attr(pbStack40), CONCAT22(extraout_var,start_handle) == 0)) {
LAB_23028db4:
    iStack28 = -2;
  }
  else {
    if (params->uuid != (bt_uuid *)0x0) {
      pbStack40 = (bt_gatt_attr *)0x0;
      bt_gatt_foreach_attr_type
                (start_handle,0xffff,params->uuid,(void *)0x0,1,match_uuid,&pbStack40);
      if ((pbStack40 == (bt_gatt_attr *)0x0) ||
         ((start_handle = pbStack40->handle, start_handle == 0 &&
          (start_handle = find_static_attr(pbStack40), CONCAT22(extraout_var_00,start_handle) == 0))
         )) goto LAB_23028db4;
    }
    attr._0_1_ = 0;
    attr._2_2_ = 0x2803;
    iVar1 = bt_uuid_cmp(pbStack40->uuid,(bt_uuid *)&attr);
    if (iVar1 == 0) {
      if ((*(byte *)((int)params->attr->user_data + 6) & 0x20) == 0) {
        return -0x16;
      }
      start_handle = bt_gatt_attr_value_handle(params->attr);
    }
    if (conn == (bt_conn *)0x0) {
      iStack28 = -0x39;
      data.err._0_2_ = 2;
      uStack30 = 0x2902;
      abStack32[0] = (bt_uuid)0x0;
      data._4_4_ = params;
      bt_gatt_foreach_attr_type(start_handle,0xffff,abStack32,(void *)0x0,1,notify_cb,&iStack28);
    }
    else {
      iStack28 = gatt_indicate(conn,start_handle,params);
    }
  }
  return iStack28;
}



// WARNING: Variable defined which should be unmapped: sc_range

void sc_process(k_work *work)

{
  int iVar1;
  atomic_t aStack20;
  u16_t sc_range [2];
  
  aStack20 = work[-1].flags[0];
  atomic_and((atomic_t *)(work + 3),-2);
  work[-2].handler = (k_work_handler_t *)0x230769fc;
  work[-2].flags[0] = 0x230281ec;
  *(atomic_t **)&work[-1]._reserved = &aStack20;
  *(undefined2 *)work[-1].flags = 0;
  *(undefined2 *)((int)work[-1].flags + 2) = 0;
  *(undefined2 *)&work[-1].handler = 4;
  iVar1 = bt_gatt_indicate((bt_conn *)0x0,(bt_gatt_indicate_params_conflict2 *)(work + -4));
  if (iVar1 == 0) {
    atomic_or((atomic_t *)(work + 3),2);
  }
  return;
}



u16_t bt_gatt_get_mtu(bt_conn *conn)

{
  u16_t uVar1;
  bt_att *pbVar2;
  
  pbVar2 = att_chan_get(conn);
  if (pbVar2 == (bt_att *)0x0) {
    uVar1 = 0;
  }
  else {
    uVar1 = (pbVar2->chan).tx.mtu;
  }
  return uVar1;
}



u8_t bt_gatt_check_perm(bt_conn *conn,bt_gatt_attr *attr,u8_t mask)

{
  byte bVar1;
  bt_security_t bVar2;
  undefined3 extraout_var;
  byte bVar3;
  
  bVar1 = attr->perm;
  if ((((mask & 1) == 0) ||
      ((bVar3 = 2, (bVar1 & 0x15) != 0 &&
       (attr->read !=
        (anon_subr_ssize_t_bt_conn_ptr_bt_gatt_attr_ptr_void_ptr_u16_t_u16_t_for_read *)0x0)))) &&
     (((mask & 2) == 0 ||
      ((bVar3 = 3, (bVar1 & 0x2a) != 0 &&
       (attr->write !=
        (anon_subr_ssize_t_bt_conn_ptr_bt_gatt_attr_ptr_void_ptr_u16_t_u16_t_u8_t_for_write *)0x0)))
      ))) {
    bVar1 = bVar1 & mask;
    if (((bVar1 & 0x30) != 0) &&
       (bVar2 = bt_conn_get_security(conn), CONCAT31(extraout_var,bVar2) < 3)) {
      return '\x05';
    }
    bVar3 = bVar1 & 0xc;
    if (((bVar1 & 0xc) != 0) && (bVar3 = 0, conn->encrypt == '\0')) {
      bVar3 = 0xf;
    }
  }
  return (u8_t)bVar3;
}



u8_t update_ccc(bt_gatt_attr *attr,void *user_data)

{
  bt_conn *conn;
  u8_t uVar1;
  bt_security_t bVar2;
  int iVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  gatt_sc_cfg *pgVar4;
  undefined3 extraout_var_01;
  bt_addr_le_t *peer;
  uint uVar5;
  _bt_gatt_ccc_conflict2 *ccc;
  ushort uStack52;
  ushort uStack50;
  u16_t sc_range [2];
  
  if (attr->write != bt_gatt_attr_write_ccc) {
    return '\x01';
  }
  ccc = (_bt_gatt_ccc_conflict2 *)attr->user_data;
  conn = *(bt_conn **)user_data;
  peer = &ccc->cfg[0].peer;
  do {
    iVar3 = bt_conn_addr_le_cmp(conn,peer);
    if (iVar3 == 0) {
      uVar1 = bt_gatt_check_perm(conn,attr,'*');
      iVar3 = CONCAT31(extraout_var,uVar1);
      if (iVar3 == 0) {
LAB_23028fd8:
        if (*(short *)(peer + 1) != 0) {
          gatt_ccc_changed(attr,ccc);
          if (ccc != &sc_ccc) {
            return '\x01';
          }
          pgVar4 = find_sc_cfg(conn->id,(bt_addr_le_t *)conn->field_20);
          if (pgVar4 == (gatt_sc_cfg *)0x0) {
            return '\x01';
          }
          uStack52 = (pgVar4->data).start;
          uStack50 = (pgVar4->data).end;
          if ((uStack52 | uStack50) == 0) {
            return '\x01';
          }
          uVar1 = bt_conn_index(conn);
          iVar3 = CONCAT31(extraout_var_01,uVar1);
          sc_restore_params[iVar3].attr = (bt_gatt_attr *)0x230769fc;
          sc_restore_params[iVar3].func = sc_restore_rsp;
          *(ushort **)&sc_restore_params[iVar3].data = &uStack52;
          sc_restore_params[iVar3].len = 4;
          iVar3 = bt_gatt_indicate(conn,(bt_gatt_indicate_params_conflict2 *)
                                        (sc_restore_params + iVar3));
          if (iVar3 != 0) {
            printf("SC restore indication failed\r\n");
          }
          memset(&pgVar4->data,0,4);
          return '\x01';
        }
      }
      else {
        if (iVar3 == 3) {
          printf("CCC %p not writable\r\n",attr);
        }
        else {
          uVar5 = 2;
          if (iVar3 == 5) {
            uVar5 = 3;
          }
          bVar2 = bt_conn_get_security(conn);
          if (uVar5 <= CONCAT31(extraout_var_00,bVar2)) goto LAB_23028fd8;
          if (*(byte *)((int)user_data + 4) < uVar5) {
            *(undefined *)((int)user_data + 4) = (char)uVar5;
          }
        }
      }
    }
    peer = (bt_addr_le_t *)(peer[1].a.val + 2);
    if (peer == (bt_addr_le_t *)((int)&ccc->value + 1)) {
      return '\x01';
    }
  } while( true );
}



int bt_gatt_exchange_mtu(bt_conn *conn,bt_gatt_exchange_params *params)

{
  net_buf *buf;
  undefined *puVar1;
  int iVar2;
  
  if (conn->state != BT_CONN_CONNECTED) {
    return -0x39;
  }
  buf = bt_att_create_pdu(conn,'\x02',2);
  if (buf != (net_buf *)0x0) {
    puVar1 = (undefined *)net_buf_simple_add((net_buf_simple *)&buf->field_4,2);
    *puVar1 = 0xf7;
    puVar1[1] = 0;
    iVar2 = gatt_send(conn,buf,gatt_mtu_rsp,params);
    return iVar2;
  }
  return -0xc;
}



int bt_gatt_discover(bt_conn *conn,bt_gatt_discover_params *params)

{
  undefined2 uVar1;
  int iVar2;
  net_buf *buf;
  undefined *puVar3;
  u16_t val;
  code *func;
  undefined *puVar4;
  bt_uuid *pbVar5;
  net_buf_simple *buf_00;
  bt_uuid abStack56 [2];
  undefined2 uStack54;
  bt_uuid abStack52 [2];
  undefined2 uStack50;
  bt_uuid abStack48 [2];
  undefined2 uStack46;
  bt_uuid abStack44 [2];
  undefined2 uStack42;
  undefined auStack40 [2];
  undefined2 uStack38;
  undefined auStack36 [2];
  undefined2 uStack34;
  
  if (conn->state != BT_CONN_CONNECTED) {
    return -0x39;
  }
  switch(params->type) {
  case '\0':
  case '\x01':
    if (params->uuid == (bt_uuid *)0x0) {
      buf = bt_att_create_pdu(conn,'\x10',4);
      if (buf == (net_buf *)0x0) goto LAB_23029138;
      puVar3 = (undefined *)net_buf_simple_add((net_buf_simple *)&buf->field_4,4);
      uVar1 = *(undefined2 *)&params->field_3;
      *puVar3 = (char)uVar1;
      puVar3[1] = (char)((ushort)uVar1 >> 8);
      val = params->end_handle;
      puVar3[2] = (char)val;
      puVar3[3] = (char)(val >> 8);
      if (params->type == '\0') {
        val = 0x2800;
      }
      else {
        val = 0x2801;
      }
      net_buf_simple_add_le16((net_buf_simple *)&buf->field_4,val);
      func = gatt_read_group_rsp;
      goto LAB_230291de;
    }
    buf = bt_att_create_pdu(conn,'\x06',6);
    if (buf != (net_buf *)0x0) {
      buf_00 = (net_buf_simple *)&buf->field_4;
      puVar3 = (undefined *)net_buf_simple_add(buf_00,6);
      uVar1 = *(undefined2 *)&params->field_3;
      *puVar3 = (char)uVar1;
      puVar3[1] = (char)((ushort)uVar1 >> 8);
      val = params->end_handle;
      puVar3[2] = (char)val;
      puVar3[3] = (char)(val >> 8);
      if (params->type == '\0') {
        uStack34 = 0x2800;
        auStack36[0] = 0;
        puVar4 = auStack36;
      }
      else {
        uStack38 = 0x2801;
        auStack40[0] = 0;
        puVar4 = auStack40;
      }
      uVar1 = *(undefined2 *)(puVar4 + 2);
      puVar3[4] = (char)uVar1;
      puVar3[5] = (char)((ushort)uVar1 >> 8);
      pbVar5 = params->uuid;
      if (pbVar5->type == '\0') {
        net_buf_simple_add_le16(buf_00,*(u16_t *)(pbVar5 + 2));
      }
      else {
        if (pbVar5->type != '\x02') {
          printf("Unknown UUID type %u\r\n");
          net_buf_unref(buf);
          return -0x16;
        }
        net_buf_simple_add_mem(buf_00,pbVar5 + 1,0x10);
      }
      func = gatt_find_type_rsp;
      goto LAB_230291de;
    }
    goto LAB_23029138;
  case '\x02':
  case '\x03':
    buf = bt_att_create_pdu(conn,'\b',4);
    if (buf == (net_buf *)0x0) goto LAB_23029138;
    puVar3 = (undefined *)net_buf_simple_add((net_buf_simple *)&buf->field_4,4);
    uVar1 = *(undefined2 *)&params->field_3;
    *puVar3 = (char)uVar1;
    puVar3[1] = (char)((ushort)uVar1 >> 8);
    val = params->end_handle;
    puVar3[2] = (char)val;
    puVar3[3] = (char)(val >> 8);
    if (params->type == '\x02') {
      val = 0x2802;
    }
    else {
      val = 0x2803;
    }
    net_buf_simple_add_le16((net_buf_simple *)&buf->field_4,val);
    func = gatt_read_type_rsp;
    goto LAB_230291de;
  case '\x04':
    if (params->uuid != (bt_uuid *)0x0) {
      abStack56[0] = (bt_uuid)0x0;
      uStack54 = 0x2800;
      iVar2 = bt_uuid_cmp(params->uuid,abStack56);
      if (iVar2 == 0) {
        return -0x16;
      }
      abStack52[0] = (bt_uuid)0x0;
      uStack50 = 0x2801;
      iVar2 = bt_uuid_cmp(params->uuid,abStack52);
      if (iVar2 == 0) {
        return -0x16;
      }
      abStack48[0] = (bt_uuid)0x0;
      uStack46 = 0x2802;
      iVar2 = bt_uuid_cmp(params->uuid,abStack48);
      if (iVar2 == 0) {
        return -0x16;
      }
      abStack44[0] = (bt_uuid)0x0;
      uStack42 = 0x2803;
      iVar2 = bt_uuid_cmp(params->uuid,abStack44);
      if (iVar2 == 0) {
        return -0x16;
      }
    }
switchD_23029126_caseD_5:
    buf = bt_att_create_pdu(conn,'\x04',4);
    if (buf == (net_buf *)0x0) {
LAB_23029138:
      iVar2 = -0xc;
    }
    else {
      puVar3 = (undefined *)net_buf_simple_add((net_buf_simple *)&buf->field_4,4);
      uVar1 = *(undefined2 *)&params->field_3;
      *puVar3 = (char)uVar1;
      puVar3[1] = (char)((ushort)uVar1 >> 8);
      val = params->end_handle;
      func = gatt_find_info_rsp;
      puVar3[2] = (char)val;
      puVar3[3] = (char)(val >> 8);
LAB_230291de:
      iVar2 = gatt_send(conn,buf,func,params);
    }
    return iVar2;
  case '\x05':
    goto switchD_23029126_caseD_5;
  default:
    printf("Invalid discovery type: %u\r\n");
    return -0x16;
  }
}



// WARNING: Exceeded maximum restarts with more pending

void gatt_discover_next(bt_conn *conn,u16_t last_handle,bt_gatt_discover_params *params)

{
  int iVar1;
  undefined2 in_register_0000202e;
  
  iVar1 = CONCAT22(in_register_0000202e,last_handle);
  if (iVar1 != 0) {
    if (iVar1 == 0xffff) {
      *(undefined2 *)&params->field_3 = 0xffff;
      goto done;
    }
    *(short *)&params->field_3 = (short)((iVar1 + 1U) * 0x10000 >> 0x10);
    if ((uint)params->end_handle < (iVar1 + 1U & 0xffff)) goto done;
  }
  iVar1 = bt_gatt_discover(conn,params);
  if (iVar1 == 0) {
    return;
  }
done:
                    // WARNING: Could not recover jumptable at 0x230293a0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*params->func)(conn,(bt_gatt_attr *)0x0);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void gatt_find_type_rsp(bt_conn *conn,u8_t err,void *pdu,u16_t length,void *user_data)

{
  u16_t last_handle;
  int iVar1;
  undefined3 in_register_0000202d;
  undefined2 in_register_00002036;
  uint uVar2;
  uint uVar3;
  undefined auStack84 [2];
  undefined2 uStack82;
  undefined auStack80 [2];
  undefined2 uStack78;
  undefined4 uStack76;
  bt_gatt_service_val value;
  bt_gatt_attr attr;
  
  uVar2 = CONCAT22(in_register_00002036,length);
  uVar3 = CONCAT31(in_register_0000202d,err);
  if (uVar3 == 0) {
    last_handle = 0;
    while (3 < uVar2) {
      last_handle = *(u16_t *)((int)pdu + uVar3 * 4 + 2);
      if (*(char *)((int)user_data + 0x28) == '\0') {
        auStack84[0] = 0;
        uStack82 = 0x2800;
        value._4_4_ = auStack84;
      }
      else {
        auStack80[0] = 0;
        uStack78 = 0x2801;
        value._4_4_ = auStack80;
      }
      uStack76 = *(undefined4 *)((int)user_data + 0x18);
      value.uuid._0_2_ = last_handle;
      iVar1 = (**(code **)((int)user_data + 0x1c))
                        (conn,&value.end_handle,user_data,*(code **)((int)user_data + 0x1c));
      if (iVar1 == 0) {
        return;
      }
      uVar3 = uVar3 + 1 & 0xff;
      uVar2 = uVar2 - 4 & 0xffff;
    }
    if (uVar2 == 0) {
      gatt_discover_next(conn,last_handle,(bt_gatt_discover_params *)user_data);
      return;
    }
  }
  (**(code **)((int)user_data + 0x1c))(conn,0,user_data,*(code **)((int)user_data + 0x1c));
  return;
}



// WARNING: Could not reconcile some variable overlaps

void gatt_read_group_rsp(bt_conn *conn,u8_t err,void *pdu,u16_t length,void *user_data)

{
  ushort last_handle;
  int iVar1;
  void *__dest;
  undefined3 in_register_0000202d;
  size_t __n;
  uint uVar2;
  code *pcVar3;
  ushort *puVar4;
  undefined auStack120 [2];
  undefined2 uStack118;
  undefined auStack116 [2];
  undefined2 uStack114;
  u16_t *puStack112;
  bt_gatt_service_val value;
  anon_union u;
  bt_gatt_attr attr;
  
  if (CONCAT31(in_register_0000202d,err) != 0) {
    pcVar3 = *(code **)((int)user_data + 0x1c);
    goto LAB_230294bc;
  }
  if (*(char *)pdu == '\x06') {
    value.end_handle._0_1_ = '\0';
LAB_2302950c:
    uVar2 = (uint)length - 1;
    puVar4 = (ushort *)((int)pdu + 1);
    last_handle = 0;
    while (uVar2 = uVar2 & 0xffff, *(byte *)pdu <= uVar2) {
      stack0xffffffac = (undefined *)0x0;
      if (((*puVar4 == 0) || (last_handle = puVar4[1], last_handle == 0)) || (last_handle < *puVar4)
         ) goto done;
      if ((char)value.end_handle == '\0') {
        __n = 2;
        __dest = (void *)&value.field_0x6;
LAB_230295ce:
        memcpy(__dest,puVar4 + 2,__n);
      }
      else {
        if ((char)value.end_handle == '\x02') {
          __n = 0x10;
          __dest = (void *)((int)&value.end_handle + 1);
          goto LAB_230295ce;
        }
      }
      if (*(char *)((int)user_data + 0x28) == '\0') {
        auStack116[0] = 0;
        uStack114 = 0x2800;
        unique0x10000079 = auStack116;
      }
      else {
        auStack120[0] = 0;
        uStack118 = 0x2801;
        unique0x1000007d = auStack120;
      }
      puStack112 = &value.end_handle;
      value.uuid._0_2_ = last_handle;
      iVar1 = (**(code **)((int)user_data + 0x1c))
                        (conn,u + 0x10,user_data,*(code **)((int)user_data + 0x1c));
      if (iVar1 == 0) {
        return;
      }
      uVar2 = uVar2 - (uint)*(byte *)pdu;
      puVar4 = (ushort *)((int)puVar4 + (uint)*(byte *)pdu);
    }
    if ((uVar2 == 0) && (last_handle != 0)) {
      gatt_discover_next(conn,last_handle,(bt_gatt_discover_params *)user_data);
      return;
    }
  }
  else {
    if (*(char *)pdu == '\x14') {
      value.end_handle._0_1_ = '\x02';
      goto LAB_2302950c;
    }
    printf("Invalid data len %u\r\n");
  }
done:
  pcVar3 = *(code **)((int)user_data + 0x1c);
LAB_230294bc:
  (*pcVar3)(conn,0,user_data,pcVar3);
  return;
}



// WARNING: Variable defined which should be unmapped: u_1
// WARNING: Could not reconcile some variable overlaps

void gatt_read_type_rsp(bt_conn *conn,u8_t err,void *pdu,u16_t length,void *user_data)

{
  char cVar1;
  undefined2 uVar2;
  ushort last_handle;
  uint uVar3;
  int iVar4;
  net_buf *buf;
  undefined *puVar5;
  undefined3 in_register_0000202d;
  code *pcVar6;
  ushort *puVar7;
  undefined auStack104 [2];
  undefined2 uStack102;
  undefined auStack100 [2];
  undefined2 uStack98;
  u16_t *puStack96;
  bt_gatt_include value;
  anon_union u;
  anon_union u_1;
  
  if (CONCAT31(in_register_0000202d,err) != 0) {
    pcVar6 = *(code **)((int)user_data + 0x1c);
    goto LAB_23029610;
  }
  cVar1 = *(char *)pdu;
  if (*(char *)((int)user_data + 0x28) == '\x02') {
    if (cVar1 == '\x06') {
      stack0xffffffbc = (undefined *)((uint)stack0xffffffbc & 0xffffff00 | 2);
LAB_23029636:
      uVar3 = (uint)length - 1;
      puVar7 = (ushort *)((int)pdu + 1);
      last_handle = 0;
      while (uVar3 = uVar3 & 0xffff, *(byte *)pdu <= uVar3) {
        last_handle = *puVar7;
        if (last_handle == 0) goto done;
        value.uuid._0_2_ = puVar7[1];
        value.uuid._2_2_ = puVar7[2];
        if (u[16] == 0) {
          stack0xffffffbc = (undefined *)((uint)stack0xffffffbc & 0xffff | (uint)puVar7[3] << 0x10);
          puStack96 = (u16_t *)(u + 0x10);
        }
        else {
          if (u[16] == 2) {
            *(ushort *)((int)user_data + 0x20) = last_handle;
            *(ushort *)((int)user_data + 0x22) = (ushort)value.uuid;
            *(ushort *)((int)user_data + 0x24) = value.uuid._2_2_;
            buf = bt_att_create_pdu(conn,'\n',2);
            if (buf == (net_buf *)0x0) {
              last_handle = 0xfff4;
            }
            else {
              puVar5 = (undefined *)net_buf_simple_add((net_buf_simple *)&buf->field_4,2);
              uVar2 = *(undefined2 *)((int)user_data + 0x22);
              *puVar5 = (char)uVar2;
              puVar5[1] = (char)((ushort)uVar2 >> 8);
              uVar3 = gatt_send(conn,buf,read_included_uuid_cb,user_data);
              last_handle = (ushort)(uVar3 & 0xffff);
              if ((uVar3 & 0xffff) == 0) {
                return;
              }
            }
            goto LAB_23029762;
          }
        }
        if ((*(bt_uuid **)((int)user_data + 0x18) == (bt_uuid *)0x0) ||
           (iVar4 = bt_uuid_cmp((bt_uuid *)(u + 0x10),*(bt_uuid **)((int)user_data + 0x18)),
           iVar4 == 0)) {
          u._0_4_ = 0;
          u._4_4_ = 0;
          auStack104[0] = 0;
          uStack102 = 0x2802;
          u._12_4_ = (uint)last_handle;
          value._4_4_ = auStack104;
          u._8_4_ = &puStack96;
          iVar4 = (**(code **)((int)user_data + 0x1c))
                            (conn,&value.start_handle,user_data,*(code **)((int)user_data + 0x1c));
          if (iVar4 == 0) {
            return;
          }
        }
        uVar3 = uVar3 - (uint)*(byte *)pdu;
        puVar7 = (ushort *)((int)puVar7 + (uint)*(byte *)pdu);
      }
      goto LAB_23029660;
    }
    if (cVar1 == '\b') {
      stack0xffffffbc = (undefined *)((uint)stack0xffffffbc & 0xffffff00);
      goto LAB_23029636;
    }
LAB_23029784:
    printf("Invalid data len %u\r\n");
  }
  else {
    if (cVar1 == '\a') {
      value._4_4_ = (undefined *)((uint)value._5_3_ << 8);
    }
    else {
      if (cVar1 != '\x15') goto LAB_23029784;
      value._4_4_ = (undefined *)CONCAT31(value._5_3_,2);
    }
    uVar3 = (uint)length - 1;
    puVar7 = (ushort *)((int)pdu + 1);
    last_handle = 0;
    while (uVar3 = uVar3 & 0xffff, *(byte *)pdu <= uVar3) {
      last_handle = *puVar7;
      if (last_handle == 0) goto done;
      if ((char)value.start_handle == '\0') {
        value._4_4_ = (undefined *)
                      ((uint)value._4_4_ & 0xffff | (uint)*(ushort *)((int)puVar7 + 5) << 0x10);
      }
      else {
        if ((char)value.start_handle == '\x02') {
          memcpy((void *)((int)&value.start_handle + 1),(void *)((int)puVar7 + 5),0x10);
        }
      }
      if (*(bt_uuid **)((int)user_data + 0x18) == (bt_uuid *)0x0) {
LAB_230297f0:
        auStack100[0] = 0;
        uStack98 = 0x2803;
        value.uuid._0_2_ = *(ushort *)((int)puVar7 + 3);
        value.uuid._2_2_ = CONCAT11(value.uuid._3_1_,*(undefined *)(puVar7 + 1));
        puStack96 = &value.start_handle;
        unique0x100000f4 = auStack100;
        iVar4 = (**(code **)((int)user_data + 0x1c))
                          (conn,u + 0x10,user_data,*(code **)((int)user_data + 0x1c));
        if (iVar4 == 0) {
          return;
        }
      }
      else {
        iVar4 = bt_uuid_cmp((bt_uuid *)&value.start_handle,*(bt_uuid **)((int)user_data + 0x18));
        if (iVar4 == 0) goto LAB_230297f0;
      }
      uVar3 = uVar3 - (uint)*(byte *)pdu;
      puVar7 = (ushort *)((int)puVar7 + (uint)*(byte *)pdu);
    }
LAB_23029660:
    if ((uVar3 == 0) && (last_handle != 0)) {
LAB_23029762:
      gatt_discover_next(conn,last_handle,(bt_gatt_discover_params *)user_data);
      return;
    }
  }
done:
  pcVar6 = *(code **)((int)user_data + 0x1c);
LAB_23029610:
  (*pcVar6)(conn,0,user_data,pcVar6);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void read_included_uuid_cb(bt_conn *conn,u8_t err,void *pdu,u16_t length,void *user_data)

{
  int iVar1;
  undefined2 in_register_00002036;
  undefined auStack68 [2];
  undefined2 uStack66;
  u16_t *puStack64;
  bt_gatt_include value;
  anon_union_for_u u;
  
  if (CONCAT22(in_register_00002036,length) == 0x10) {
    value.uuid._0_2_ = *(undefined2 *)((int)user_data + 0x22);
    value.uuid._2_2_ = *(undefined2 *)((int)user_data + 0x24);
    value.start_handle._0_1_ = 2;
    puStack64 = &value.start_handle;
    memcpy((void *)((int)&value.start_handle + 1),pdu,0x10);
    if ((*(bt_uuid **)((int)user_data + 0x18) == (bt_uuid *)0x0) ||
       (iVar1 = bt_uuid_cmp((bt_uuid *)&value.start_handle,*(bt_uuid **)((int)user_data + 0x18)),
       iVar1 == 0)) {
      uStack66 = 0x2802;
      register0x0000203c = auStack68;
      auStack68[0] = 0;
      iVar1 = (**(code **)((int)user_data + 0x1c))
                        (conn,u + 0x10,user_data,*(code **)((int)user_data + 0x1c));
      if (iVar1 == 0) {
        return;
      }
    }
    gatt_discover_next(conn,*(u16_t *)((int)user_data + 0x20),(bt_gatt_discover_params *)user_data);
  }
  else {
    printf("Invalid data len %u\r\n",CONCAT22(in_register_00002036,length));
    (**(code **)((int)user_data + 0x1c))(conn,0,user_data,*(code **)((int)user_data + 0x1c));
  }
  return;
}



void gatt_find_info_rsp(bt_conn *conn,u8_t err,void *pdu,u16_t length,void *user_data)

{
  bt_uuid bVar1;
  bool bVar2;
  uint uVar3;
  u16_t *puVar4;
  int iVar5;
  undefined3 in_register_0000202d;
  u16_t last_handle;
  uint uVar6;
  bt_uuid abStack104 [2];
  undefined2 uStack102;
  bt_uuid abStack100 [2];
  undefined2 uStack98;
  bt_uuid abStack96 [2];
  undefined2 uStack94;
  bt_uuid abStack92 [2];
  undefined2 uStack90;
  bt_uuid bStack88;
  undefined uStack87;
  u16_t uStack86;
  anon_union_for_u u;
  
  if (CONCAT31(in_register_0000202d,err) == 0) {
    bVar1 = *(bt_uuid *)pdu;
    if (bVar1 == (bt_uuid)0x1) {
      bStack88 = (bt_uuid)0x0;
      uVar6 = 4;
    }
    else {
      if (bVar1 != (bt_uuid)0x2) {
        printf("Invalid format %u\r\n");
        goto done;
      }
      uVar6 = 0x12;
      bStack88 = bVar1;
    }
    uVar3 = (uint)length - 1 & 0xffff;
    if (uVar6 <= uVar3) {
      uVar3 = uVar3 / uVar6;
      puVar4 = (u16_t *)((int)pdu + 1);
      bVar2 = false;
      last_handle = 0;
      do {
        if (uVar3 == 0) {
          gatt_discover_next(conn,last_handle,(bt_gatt_discover_params *)user_data);
          return;
        }
        last_handle = *puVar4;
        if (bVar2) {
LAB_230299c0:
          bVar2 = false;
        }
        else {
          if (bStack88 == (bt_uuid)0x0) {
            uStack86 = puVar4[1];
          }
          else {
            if (bStack88 == (bt_uuid)0x2) {
              memcpy(&uStack87,puVar4 + 1,0x10);
            }
          }
          if ((*(bt_uuid **)((int)user_data + 0x18) != (bt_uuid *)0x0) &&
             (iVar5 = bt_uuid_cmp(&bStack88,*(bt_uuid **)((int)user_data + 0x18)), iVar5 != 0))
          goto LAB_230299c0;
          if (*(char *)((int)user_data + 0x28) != '\x04') {
LAB_23029a60:
            unique0x10000057 = &bStack88;
            iVar5 = (**(code **)((int)user_data + 0x1c))
                              (conn,u + 0x10,user_data,*(code **)((int)user_data + 0x1c));
            if (iVar5 == 0) {
              return;
            }
            goto LAB_230299c0;
          }
          abStack104[0] = (bt_uuid)0x0;
          uStack102 = 0x2800;
          iVar5 = bt_uuid_cmp(&bStack88,abStack104);
          if (iVar5 == 0) goto LAB_230299c0;
          abStack100[0] = (bt_uuid)0x0;
          uStack98 = 0x2801;
          iVar5 = bt_uuid_cmp(&bStack88,abStack100);
          if (iVar5 == 0) goto LAB_230299c0;
          abStack96[0] = (bt_uuid)0x0;
          uStack94 = 0x2802;
          iVar5 = bt_uuid_cmp(&bStack88,abStack96);
          if (iVar5 == 0) goto LAB_230299c0;
          abStack92[0] = (bt_uuid)0x0;
          uStack90 = 0x2803;
          iVar5 = bt_uuid_cmp(&bStack88,abStack92);
          if (iVar5 != 0) goto LAB_23029a60;
          bVar2 = true;
        }
        uVar3 = uVar3 - 1;
        puVar4 = (u16_t *)((int)puVar4 + uVar6);
      } while( true );
    }
  }
done:
  (**(code **)((int)user_data + 0x1c))(conn,0,user_data,*(code **)((int)user_data + 0x1c));
  return;
}



int bt_gatt_read(bt_conn *conn,bt_gatt_read_params *params)

{
  undefined2 uVar1;
  net_buf *buf;
  int iVar2;
  undefined *puVar3;
  char *pcVar4;
  uint uVar5;
  code *func;
  net_buf_simple *buf_00;
  
  if (conn->state != BT_CONN_CONNECTED) {
    return -0x39;
  }
  uVar5 = params->handle_count;
  if (uVar5 == 0) {
    buf = bt_att_create_pdu(conn,'\b',4);
    if (buf == (net_buf *)0x0) {
      return -0xc;
    }
    buf_00 = (net_buf_simple *)&buf->field_4;
    puVar3 = (undefined *)net_buf_simple_add(buf_00,4);
    uVar1 = *(undefined2 *)&params->field_3;
    *puVar3 = (char)uVar1;
    puVar3[1] = (char)((ushort)uVar1 >> 8);
    uVar1 = *(undefined2 *)((int)&params->field_3 + 2);
    puVar3[2] = (char)uVar1;
    puVar3[3] = (char)((ushort)uVar1 >> 8);
    pcVar4 = *(char **)((int)&params->field_3 + 4);
    if (*pcVar4 == '\0') {
      net_buf_simple_add_le16(buf_00,*(u16_t *)(pcVar4 + 2));
    }
    else {
      net_buf_simple_add_mem(buf_00,pcVar4 + 1,0x10);
    }
  }
  else {
    if (1 < uVar5) {
      buf = bt_att_create_pdu(conn,'\x0e',uVar5 << 1);
      if (buf == (net_buf *)0x0) {
        return -0xc;
      }
      uVar5 = 0;
      while (uVar5 < params->handle_count) {
        iVar2 = uVar5 * 2;
        uVar5 = uVar5 + 1 & 0xff;
        net_buf_simple_add_le16
                  ((net_buf_simple *)&buf->field_4,*(u16_t *)(*(int *)&params->field_3 + iVar2));
      }
      func = gatt_read_multiple_rsp;
      goto LAB_23029b54;
    }
    if (*(short *)((int)&params->field_3 + 2) == 0) {
      buf = bt_att_create_pdu(conn,'\n',2);
      if (buf == (net_buf *)0x0) {
        return -0xc;
      }
      puVar3 = (undefined *)net_buf_simple_add((net_buf_simple *)&buf->field_4,2);
      uVar1 = *(undefined2 *)&params->field_3;
      *puVar3 = (char)uVar1;
      puVar3[1] = (char)((ushort)uVar1 >> 8);
    }
    else {
      buf = bt_att_create_pdu(conn,'\f',4);
      if (buf == (net_buf *)0x0) {
        return -0xc;
      }
      puVar3 = (undefined *)net_buf_simple_add((net_buf_simple *)&buf->field_4,4);
      uVar1 = *(undefined2 *)&params->field_3;
      *puVar3 = (char)uVar1;
      puVar3[1] = (char)((ushort)uVar1 >> 8);
      uVar1 = *(undefined2 *)((int)&params->field_3 + 2);
      puVar3[2] = (char)uVar1;
      puVar3[3] = (char)((ushort)uVar1 >> 8);
    }
  }
  func = gatt_read_rsp;
LAB_23029b54:
  iVar2 = gatt_send(conn,buf,func,params);
  return iVar2;
}



void gatt_read_rsp(bt_conn *conn,u8_t err,void *pdu,u16_t length,void *user_data)

{
  code *UNRECOVERED_JUMPTABLE;
  uint uVar1;
  u16_t uVar2;
  int iVar3;
  undefined2 extraout_var;
  undefined3 in_register_0000202d;
  undefined2 in_register_00002036;
  int iVar4;
  uint uVar5;
  short *psVar6;
  
  iVar4 = CONCAT22(in_register_00002036,length);
  iVar3 = CONCAT31(in_register_0000202d,err);
  if ((iVar3 == 0) && (iVar4 != 0)) {
    if (*(int *)((int)user_data + 0x1c) == 0) {
      uVar1 = iVar4 - 1;
      psVar6 = (short *)((int)pdu + 1);
      while (uVar1 = uVar1 & 0xffff, uVar1 != 0) {
        if (*psVar6 == 0) {
          printf("Invalid handle\r\n");
          return;
        }
        uVar5 = (uint)*(byte *)pdu;
        if (uVar1 < uVar5) {
          uVar5 = uVar1;
        }
        *(short *)((int)user_data + 0x20) = *psVar6;
        iVar3 = (**(code **)((int)user_data + 0x18))
                          (conn,0,user_data,psVar6 + 1,uVar5 - 2 & 0xffff,
                           *(code **)((int)user_data + 0x18));
        if (iVar3 == 0) {
          return;
        }
        if (uVar1 < *(byte *)pdu) break;
        if (*(short *)((int)user_data + 0x22) == *(short *)((int)user_data + 0x20))
        goto LAB_23029cb0;
        *(short *)((int)user_data + 0x20) = *(short *)((int)user_data + 0x20) + 1;
        uVar1 = uVar1 - (uint)*(byte *)pdu;
        psVar6 = (short *)((int)psVar6 + (uint)*(byte *)pdu);
      }
    }
    else {
      iVar3 = (**(code **)((int)user_data + 0x18))
                        (user_data,pdu,iVar4,*(code **)((int)user_data + 0x18));
      if (iVar3 == 0) {
        return;
      }
      uVar2 = bt_att_get_mtu(conn);
      if (iVar4 < CONCAT22(extraout_var,uVar2) + -1) {
LAB_23029cb0:
        UNRECOVERED_JUMPTABLE = *(code **)((int)user_data + 0x18);
        iVar3 = 0;
        goto LAB_23029c0a;
      }
      *(short *)((int)user_data + 0x22) = length + *(short *)((int)user_data + 0x22);
    }
    iVar3 = bt_gatt_read(conn,(bt_gatt_read_params *)user_data);
    if (-1 < iVar3) {
      return;
    }
    UNRECOVERED_JUMPTABLE = *(code **)((int)user_data + 0x18);
    iVar3 = 0xe;
  }
  else {
    UNRECOVERED_JUMPTABLE = *(code **)((int)user_data + 0x18);
  }
LAB_23029c0a:
                    // WARNING: Could not recover jumptable at 0x23029c1a. Too many branches
                    // WARNING: Treating indirect jump as call
  (*UNRECOVERED_JUMPTABLE)(conn,iVar3,user_data,0,0);
  return;
}



int bt_gatt_write_without_response_cb
              (bt_conn *conn,u16_t handle,void *data,u16_t length,_Bool sign,
              bt_gatt_complete_func_t *func,void *user_data)

{
  net_buf *buf;
  undefined *puVar1;
  int iVar2;
  u8_t op;
  size_t len;
  undefined2 in_register_00002036;
  size_t __n;
  undefined3 in_register_00002039;
  
  __n = CONCAT22(in_register_00002036,length);
  if (conn->state != BT_CONN_CONNECTED) {
    return -0x39;
  }
  if ((conn->encrypt == '\0') && (CONCAT31(in_register_00002039,sign) != 0)) {
    len = __n + 0xe;
    op = -0x2e;
  }
  else {
    len = __n + 2;
    op = 'R';
  }
  buf = bt_att_create_pdu(conn,op,len);
  if (buf != (net_buf *)0x0) {
    puVar1 = (undefined *)net_buf_simple_add((net_buf_simple *)&buf->field_4,2);
    *puVar1 = (char)handle;
    puVar1[1] = (char)(handle >> 8);
    memcpy(puVar1 + 2,data,__n);
    net_buf_simple_add((net_buf_simple *)&buf->field_4,__n);
    iVar2 = bt_att_send(conn,buf,(bt_conn_tx_cb_t *)func,user_data);
    return iVar2;
  }
  return -0xc;
}



int bt_gatt_write(bt_conn *conn,bt_gatt_write_params *params)

{
  ushort uVar1;
  u16_t uVar2;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  undefined *puVar3;
  net_buf *buf;
  int iVar4;
  code *func;
  size_t __n;
  
  if (conn->state != BT_CONN_CONNECTED) {
    return -0x39;
  }
  if ((params->offset == 0) &&
     (uVar1 = params->length, uVar2 = bt_att_get_mtu(conn),
     (uint)uVar1 <= CONCAT22(extraout_var_00,uVar2) - 3U)) {
    buf = bt_att_create_pdu(conn,'\x12',(uint)params->length + 2);
    if (buf != (net_buf *)0x0) {
      puVar3 = (undefined *)net_buf_simple_add((net_buf_simple *)&buf->field_4,2);
      uVar2 = params->handle;
      *puVar3 = (char)uVar2;
      puVar3[1] = (char)(uVar2 >> 8);
      memcpy(puVar3 + 2,params->data,(uint)params->length);
      net_buf_simple_add((net_buf_simple *)&buf->field_4,(uint)params->length);
      func = gatt_write_rsp;
      goto LAB_23029ee6;
    }
  }
  else {
    uVar1 = params->length;
    uVar2 = bt_att_get_mtu(conn);
    if ((uint)uVar1 < CONCAT22(extraout_var,uVar2) - 5U) {
      __n = (size_t)params->length;
    }
    else {
      uVar2 = bt_att_get_mtu(conn);
      __n = (uint)uVar2 - 5 & 0xffff;
    }
    buf = bt_att_create_pdu(conn,'\x16',__n + 4);
    if (buf != (net_buf *)0x0) {
      puVar3 = (undefined *)net_buf_simple_add((net_buf_simple *)&buf->field_4,4);
      uVar2 = params->handle;
      *puVar3 = (char)uVar2;
      puVar3[1] = (char)(uVar2 >> 8);
      uVar2 = params->offset;
      puVar3[2] = (char)uVar2;
      puVar3[3] = (char)(uVar2 >> 8);
      memcpy(puVar3 + 4,params->data,__n);
      net_buf_simple_add((net_buf_simple *)&buf->field_4,__n);
      params->offset = params->offset + (short)__n;
      func = gatt_prepare_write_rsp;
      params->data = (void *)((int)params->data + __n);
      params->length = params->length - (short)__n;
LAB_23029ee6:
      iVar4 = gatt_send(conn,buf,func,params);
      return iVar4;
    }
  }
  return -0xc;
}



void gatt_prepare_write_rsp(bt_conn *conn,u8_t err,void *pdu,u16_t length,void *user_data)

{
  net_buf *buf;
  undefined *puVar1;
  undefined3 in_register_0000202d;
  undefined2 in_register_00002036;
  
  if (CONCAT31(in_register_0000202d,err) != 0) {
                    // WARNING: Could not recover jumptable at 0x23029f08. Too many branches
                    // WARNING: Treating indirect jump as call
    (**(code **)((int)user_data + 0x18))(user_data,CONCAT22(in_register_00002036,length));
    return;
  }
  if (*(short *)((int)user_data + 0x24) == 0) {
    buf = bt_att_create_pdu(conn,'\x18',1);
    if (buf != (net_buf *)0x0) {
      puVar1 = (undefined *)net_buf_simple_add((net_buf_simple *)&buf->field_4,1);
      *puVar1 = 1;
      gatt_send(conn,buf,gatt_write_rsp,user_data);
      return;
    }
    return;
  }
  bt_gatt_write(conn,(bt_gatt_write_params *)user_data);
  return;
}



int bt_gatt_subscribe(bt_conn *conn,bt_gatt_subscribe_params *params)

{
  bool bVar1;
  sys_snode_t *psVar2;
  bt_gatt_subscribe_params *pbVar3;
  _snode *p_Var4;
  int iVar5;
  
  if (conn->state != BT_CONN_CONNECTED) {
    return -0x39;
  }
  pbVar3 = (bt_gatt_subscribe_params *)subscriptions.head;
  if (subscriptions.head != (sys_snode_t *)0x0) {
    pbVar3 = (bt_gatt_subscribe_params *)(subscriptions.head + -0xc);
  }
  bVar1 = false;
  while (pbVar3 != (bt_gatt_subscribe_params *)0x0) {
    if (pbVar3 == params) {
      return -0x45;
    }
    iVar5 = bt_conn_addr_le_cmp(conn,&pbVar3->_peer);
    if (((iVar5 == 0) && (pbVar3->value_handle == params->value_handle)) &&
       (params->value <= pbVar3->value)) {
      bVar1 = true;
    }
    if ((pbVar3 == (bt_gatt_subscribe_params *)0xffffffd0) ||
       (p_Var4 = (pbVar3->node).next, p_Var4 == (_snode *)0x0)) break;
    pbVar3 = (bt_gatt_subscribe_params *)(p_Var4 + -0xc);
  }
  if ((bVar1) || (iVar5 = gatt_write_ccc(conn,params->ccc_handle,params->value,params), iVar5 == 0))
  {
    memcpy(&params->_peer,conn->field_20,7);
    psVar2 = &params->node;
    *(sys_snode_t **)&(params->node).next = subscriptions.head;
    subscriptions.head = psVar2;
    if (subscriptions.tail == (sys_snode_t *)0x0) {
      subscriptions.tail = &params->node;
    }
    iVar5 = 0;
  }
  return iVar5;
}



int bt_gatt_unsubscribe(bt_conn *conn,bt_gatt_subscribe_params *params)

{
  bool bVar1;
  bool bVar2;
  bt_gatt_subscribe_params *pbVar3;
  bt_gatt_subscribe_params *pbVar4;
  int iVar5;
  uint uVar6;
  sys_snode_t *node;
  bt_gatt_subscribe_params *pbVar7;
  sys_snode_t *prev_node;
  
  if (conn->state != BT_CONN_CONNECTED) {
    return -0x39;
  }
  pbVar7 = (bt_gatt_subscribe_params *)0x0;
  pbVar3 = (bt_gatt_subscribe_params *)subscriptions.head;
  if (subscriptions.head != (sys_snode_t *)0x0) {
    pbVar7 = (bt_gatt_subscribe_params *)(subscriptions.head + -0xc);
    if (pbVar7 == (bt_gatt_subscribe_params *)0x0) {
      pbVar3 = (bt_gatt_subscribe_params *)0x0;
    }
    else {
      pbVar3 = (bt_gatt_subscribe_params *)(subscriptions.head)->next;
      if (pbVar3 != (bt_gatt_subscribe_params *)0x0) {
        pbVar3 = (bt_gatt_subscribe_params *)&pbVar3[-1]._req.func;
      }
    }
  }
  bVar1 = false;
  bVar2 = false;
  prev_node = (sys_snode_t *)0x0;
  while (pbVar4 = pbVar3, pbVar7 != (bt_gatt_subscribe_params *)0x0) {
    node = &pbVar7->node;
    if (pbVar7 == params) {
      sys_slist_remove(&subscriptions,prev_node,node);
      uVar6 = atomic_get(params->flags);
      if ((uVar6 & 2) != 0) {
        bt_att_req_cancel(conn,params);
      }
      bVar1 = true;
      node = prev_node;
    }
    else {
      iVar5 = bt_conn_addr_le_cmp(conn,&pbVar7->_peer);
      if ((iVar5 == 0) && (pbVar7->value_handle == params->value_handle)) {
        bVar2 = true;
      }
    }
    pbVar3 = (bt_gatt_subscribe_params *)0x0;
    pbVar7 = pbVar4;
    prev_node = node;
    if ((pbVar4 != (bt_gatt_subscribe_params *)0x0) &&
       (pbVar3 = (bt_gatt_subscribe_params *)(pbVar4->node).next,
       pbVar3 != (bt_gatt_subscribe_params *)0x0)) {
      pbVar3 = (bt_gatt_subscribe_params *)&pbVar3[-1]._req.func;
    }
  }
  if (bVar1) {
    if (!bVar2) {
      params->value = 0;
      iVar5 = gatt_write_ccc(conn,params->ccc_handle,0,params);
      return iVar5;
    }
    (*params->notify)(conn,params,(void *)0x0,0);
    iVar5 = 0;
  }
  else {
    iVar5 = -0x16;
  }
  return iVar5;
}



void bt_gatt_notification(bt_conn *conn,u16_t handle,void *data,u16_t length)

{
  bt_gatt_subscribe_params *pbVar1;
  bt_gatt_subscribe_params *pbVar2;
  bt_gatt_subscribe_params *params;
  u8_t uVar3;
  int iVar4;
  undefined3 extraout_var;
  undefined2 in_register_0000202e;
  
  if (subscriptions.head == (sys_snode_t *)0x0) {
    return;
  }
  params = (bt_gatt_subscribe_params *)(subscriptions.head + -0xc);
  if (params != (bt_gatt_subscribe_params *)0x0) {
    pbVar1 = (bt_gatt_subscribe_params *)(subscriptions.head)->next;
    if (pbVar1 != (bt_gatt_subscribe_params *)0x0) {
      pbVar1 = (bt_gatt_subscribe_params *)&pbVar1[-1]._req.func;
    }
    while( true ) {
      pbVar2 = pbVar1;
      iVar4 = bt_conn_addr_le_cmp(conn,&params->_peer);
      if (((iVar4 == 0) && ((uint)params->value_handle == CONCAT22(in_register_0000202e,handle))) &&
         (uVar3 = (*params->notify)(conn,params,data,length), CONCAT31(extraout_var,uVar3) == 0)) {
        bt_gatt_unsubscribe(conn,params);
      }
      if (pbVar2 == (bt_gatt_subscribe_params *)0x0) break;
      pbVar1 = (bt_gatt_subscribe_params *)(pbVar2->node).next;
      params = pbVar2;
      if (pbVar1 != (bt_gatt_subscribe_params *)0x0) {
        pbVar1 = (bt_gatt_subscribe_params *)&pbVar1[-1]._req.func;
      }
    }
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

void bt_gatt_connected(bt_conn *conn)

{
  sys_snode_t sVar1;
  _Bool _Var2;
  bt_security_t bVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  int iVar4;
  char *key_00;
  char acStack64 [4];
  char id_str [4];
  conn_data data;
  char key [36];
  
  data.conn._0_1_ = 1;
  id_str = conn;
  _Var2 = bt_addr_le_is_bonded(conn->id,(bt_addr_le_t *)conn->field_20);
  if (CONCAT31(extraout_var,_Var2) != 0) {
    key_00 = (char *)0x0;
    if (conn->id != '\0') {
      u8_to_dec(acStack64,'\x04',conn->id);
      key_00 = acStack64;
    }
    bt_settings_encode_key(&data.sec,0x24,"ccc",(bt_addr_le_t *)conn->field_20,key_00);
  }
  bt_gatt_foreach_attr(1,0xffff,update_ccc,id_str);
  bVar3 = bt_conn_get_security(conn);
  sVar1 = (sys_snode_t)subscriptions.head;
  if (CONCAT31(extraout_var_00,bVar3) < (uint)(byte)data.conn) {
    bt_conn_set_security(conn,(byte)data.conn);
    sVar1 = (sys_snode_t)subscriptions.head;
  }
  while ((sVar1 != (sys_snode_t)0x0 &&
         ((bt_gatt_subscribe_params *)((int)sVar1 + -0x30) != (bt_gatt_subscribe_params *)0x0))) {
    iVar4 = bt_conn_addr_le_cmp(conn,(bt_addr_le_t *)((int)sVar1 + -0x18));
    if (iVar4 == 0) {
      gatt_write_ccc(conn,*(u16_t *)((int)sVar1 + -10),
                     *(u16_t *)&((sys_snode_t *)((int)sVar1 + -8))->next,
                     (bt_gatt_subscribe_params *)((int)sVar1 + -0x30));
    }
    sVar1 = *(sys_snode_t *)sVar1;
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

void bt_gatt_encrypt_change(bt_conn *conn)

{
  bt_conn *pbStack24;
  conn_data data;
  
  data.conn._0_1_ = 1;
  pbStack24 = conn;
  bt_gatt_foreach_attr(1,0xffff,update_ccc,&pbStack24);
  return;
}



_Bool bt_gatt_change_aware(bt_conn *conn,_Bool req)

{
  return true;
}



void bt_gatt_disconnected(bt_conn *conn)

{
  bt_gatt_subscribe_params *params;
  bt_gatt_subscribe_params *pbVar1;
  bt_gatt_subscribe_params *pbVar2;
  _Bool _Var3;
  int iVar4;
  undefined3 extraout_var;
  uint uVar5;
  sys_snode_t *prev;
  
  bt_gatt_foreach_attr(1,0xffff,disconnected_cb,conn);
  if ((subscriptions.head != (sys_snode_t *)0x0) &&
     ((bt_gatt_subscribe_params *)(subscriptions.head + -0xc) != (bt_gatt_subscribe_params *)0x0)) {
    pbVar1 = (bt_gatt_subscribe_params *)(subscriptions.head)->next;
    if (pbVar1 != (bt_gatt_subscribe_params *)0x0) {
      pbVar1 = (bt_gatt_subscribe_params *)&pbVar1[-1]._req.func;
    }
    prev = (sys_snode_t *)0x0;
    params = (bt_gatt_subscribe_params *)(subscriptions.head + -0xc);
LAB_2302a2dc:
    pbVar2 = pbVar1;
    iVar4 = bt_conn_addr_le_cmp(conn,&params->_peer);
    if (iVar4 == 0) {
      _Var3 = bt_addr_le_is_bonded(conn->id,(bt_addr_le_t *)conn->field_20);
      if ((CONCAT31(extraout_var,_Var3) != 0) &&
         (uVar5 = atomic_get(params->flags), (uVar5 & 1) == 0)) {
        if ((params->_peer).type != '\0') {
          memcpy(&params->_peer,(bt_addr_le_t *)conn->field_20,7);
        }
        goto LAB_2302a2ea;
      }
      params->value = 0;
      gatt_subscription_remove(conn,prev,params);
    }
    else {
LAB_2302a2ea:
      prev = &params->node;
    }
    if (pbVar2 != (bt_gatt_subscribe_params *)0x0) {
      pbVar1 = (bt_gatt_subscribe_params *)(pbVar2->node).next;
      params = pbVar2;
      if (pbVar1 != (bt_gatt_subscribe_params *)0x0) {
        pbVar1 = (bt_gatt_subscribe_params *)&pbVar1[-1]._req.func;
      }
      goto LAB_2302a2dc;
    }
  }
  return;
}



void uuid_to_uuid128(bt_uuid *src,bt_uuid_128 *dst)

{
  u8_t uVar1;
  undefined2 uVar2;
  void *pvVar3;
  undefined4 uVar4;
  
  uVar1 = src->type;
  if (uVar1 == '\x01') {
    pvVar3 = memcpy(dst,&uuid128_base,0x11);
    uVar4 = *(undefined4 *)(src + 4);
    *(undefined *)((int)pvVar3 + 0xd) = (char)uVar4;
    *(undefined *)((int)pvVar3 + 0xf) = (char)((uint)uVar4 >> 0x10);
    *(undefined *)((int)pvVar3 + 0xe) = (char)((uint)uVar4 >> 8);
    *(undefined *)((int)pvVar3 + 0x10) = (char)((uint)uVar4 >> 0x18);
  }
  else {
    if (uVar1 == '\0') {
      pvVar3 = memcpy(dst,&uuid128_base,0x11);
      uVar2 = *(undefined2 *)(src + 2);
      *(undefined *)((int)pvVar3 + 0xd) = (char)uVar2;
      *(undefined *)((int)pvVar3 + 0xe) = (char)((ushort)uVar2 >> 8);
    }
    else {
      if (uVar1 == '\x02') {
        memcpy(dst,src,0x11);
        return;
      }
    }
  }
  return;
}



int bt_uuid_cmp(bt_uuid *u1,bt_uuid *u2)

{
  u8_t uVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  undefined uStack56;
  undefined auStack55 [3];
  bt_uuid_128 uuid1;
  undefined auStack35 [3];
  bt_uuid_128 uuid2;
  
  uVar1 = u2->type;
  if (uVar1 == u1->type) {
    if (uVar1 == '\x01') {
      uVar3 = *(uint *)(u1 + 4);
      uVar4 = *(uint *)(u2 + 4);
    }
    else {
      if (uVar1 != '\0') {
        if (uVar1 != '\x02') {
          return -0x16;
        }
        u2 = u2 + 1;
        u1 = u1 + 1;
        goto LAB_2302a3fa;
      }
      uVar3 = (uint)*(ushort *)(u1 + 2);
      uVar4 = (uint)*(ushort *)(u2 + 2);
    }
    iVar2 = uVar3 - uVar4;
  }
  else {
    uuid_to_uuid128(u1,(bt_uuid_128 *)&uStack56);
    uuid_to_uuid128(u2,(bt_uuid_128 *)(uuid1.val + 0xf));
    u2 = (bt_uuid *)auStack35;
    u1 = (bt_uuid *)(&uStack56 + 1);
LAB_2302a3fa:
    iVar2 = memcmp(u1,u2,0x10);
  }
  return iVar2;
}



_Bool bt_uuid_create(bt_uuid *uuid,u8_t *data,u8_t data_len)

{
  undefined3 in_register_00002031;
  int iVar1;
  
  iVar1 = CONCAT31(in_register_00002031,data_len);
  if (iVar1 == 4) {
    uuid->type = '\x01';
    *(undefined4 *)(uuid + 4) = *(undefined4 *)data;
  }
  else {
    if (iVar1 == 0x10) {
      uuid->type = '\x02';
      memcpy(uuid + 1,data,0x10);
      return true;
    }
    if (iVar1 != 2) {
      return false;
    }
    uuid->type = '\0';
    *(undefined2 *)(uuid + 2) = *(undefined2 *)data;
  }
  return true;
}



// WARNING: Variable defined which should be unmapped: tmp5

void bt_uuid_to_str(bt_uuid *uuid,char *str,size_t len)

{
  u8_t uVar1;
  uint uVar2;
  undefined auStack32 [2];
  ushort uStack30;
  u16_t tmp0;
  u16_t tmp2;
  u16_t tmp3;
  u16_t tmp4;
  u32_t_conflict tmp1;
  u32_t_conflict tmp5;
  
  uVar1 = uuid->type;
  if (uVar1 == '\x01') {
    uVar2 = *(uint *)(uuid + 4);
  }
  else {
    if (uVar1 != '\0') {
      if (uVar1 != '\x02') {
        memset(str,0,len);
        return;
      }
      memcpy(auStack32,uuid + 1,2);
      memcpy(&tmp3,uuid + 3,4);
      memcpy(&uStack30,uuid + 7,2);
      memcpy(&tmp0,uuid + 9,2);
      memcpy(&tmp2,uuid + 0xb,2);
      memcpy(&tmp1,uuid + 0xd,4);
      snprintf(str,len,"%08x-%04x-%04x-%04x-%08x%04x",tmp1,(uint)tmp2,(uint)tmp0,(uint)uStack30,
               _tmp3);
      return;
    }
    uVar2 = (uint)*(ushort *)(uuid + 2);
  }
  snprintf(str,len,"%04x",uVar2);
  return;
}



void bt_settings_encode_key(char *path,size_t path_size,char *subsys,bt_addr_le_t *addr,char *key)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  
  uVar2 = (uint)(addr->a).val[4];
  uVar1 = (uint)(addr->a).val[5];
  uVar3 = (uint)(addr->a).val[3];
  uVar4 = (uint)(addr->a).val[2];
  if (key == (char *)0x0) {
    snprintf(path,path_size,"bt/%s/%02x%02x%02x%02x%02x%02x%u",subsys,uVar1,uVar2,uVar3,uVar4);
  }
  else {
    snprintf(path,path_size,"bt/%s/%02x%02x%02x%02x%02x%02x%u/%s",subsys,uVar1,uVar2,uVar3,uVar4);
  }
  return;
}



u8_t u8_to_dec(char *buf,u8_t buflen,u8_t value)

{
  undefined3 in_register_0000202d;
  uint uVar1;
  undefined3 in_register_00002031;
  uint uVar2;
  int iVar3;
  uint uVar4;
  u8_t uVar5;
  
  uVar2 = CONCAT31(in_register_00002031,value);
  uVar1 = CONCAT31(in_register_0000202d,buflen);
  iVar3 = 4;
  uVar5 = '\0';
  uVar4 = 100;
  while( true ) {
    if (uVar1 == 0) {
      return uVar5;
    }
    iVar3 = iVar3 + -1;
    if (iVar3 == 0) break;
    if (((uVar4 <= uVar2) || (uVar4 == 1)) || (uVar5 != '\0')) {
      uVar5 = uVar5 + '\x01';
      *buf = (char)(uVar2 / uVar4) + '0';
      uVar1 = uVar1 - 1 & 0xff;
      buf = buf + 1;
    }
    uVar2 = uVar2 % uVar4;
    uVar4 = uVar4 / 10;
  }
  *buf = '\0';
  return uVar5;
}



void add_round_key(uint8_t *s,uint *k)

{
  *s = *(byte *)((int)k + 3) ^ *s;
  s[1] = (byte)*(undefined2 *)((int)k + 2) ^ s[1];
  s[2] = (byte)(*k >> 8) ^ s[2];
  s[3] = (byte)*k ^ s[3];
  s[4] = *(byte *)((int)k + 7) ^ s[4];
  s[5] = (byte)*(undefined2 *)((int)k + 6) ^ s[5];
  s[6] = (byte)(k[1] >> 8) ^ s[6];
  s[7] = (byte)k[1] ^ s[7];
  s[8] = *(byte *)((int)k + 0xb) ^ s[8];
  s[9] = (byte)*(undefined2 *)((int)k + 10) ^ s[9];
  s[10] = (byte)(k[2] >> 8) ^ s[10];
  s[0xb] = (byte)k[2] ^ s[0xb];
  s[0xc] = *(byte *)((int)k + 0xf) ^ s[0xc];
  s[0xd] = (byte)*(undefined2 *)((int)k + 0xe) ^ s[0xd];
  s[0xe] = (byte)(k[3] >> 8) ^ s[0xe];
  s[0xf] = (byte)k[3] ^ s[0xf];
  return;
}



void shift_rows(uint8_t *s)

{
  uint8_t local_20;
  uint8_t uStack31;
  uint8_t uStack30;
  uint8_t uStack29;
  uint8_t t [16];
  
  local_20 = *s;
  t[11] = s[0xb];
  uStack31 = s[5];
  uStack30 = s[10];
  uStack29 = s[0xf];
  t[0] = s[4];
  t[1] = s[9];
  t[2] = s[0xe];
  t[3] = s[3];
  t[4] = s[8];
  t[5] = s[0xd];
  t[6] = s[2];
  t[7] = s[7];
  t[8] = s[0xc];
  t[9] = s[1];
  t[10] = s[6];
  _copy(s,0x10,&local_20,0x10);
  return;
}



void mult_row_column(uint8_t *out,uint8_t *in)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  byte bVar5;
  
  bVar1 = _double_byte(*in);
  bVar2 = _double_byte(in[1]);
  *out = bVar1 ^ in[1] ^ in[2] ^ in[3] ^ bVar2;
  bVar1 = *in;
  bVar2 = _double_byte(in[1]);
  bVar3 = _double_byte(in[2]);
  out[1] = bVar2 ^ bVar1 ^ in[2] ^ in[3] ^ bVar3;
  bVar1 = in[1];
  bVar2 = *in;
  bVar3 = _double_byte(in[2]);
  bVar4 = _double_byte(in[3]);
  out[2] = bVar3 ^ bVar2 ^ bVar1 ^ in[3] ^ bVar4;
  bVar4 = _double_byte(*in);
  bVar1 = in[1];
  bVar2 = *in;
  bVar3 = in[2];
  bVar5 = _double_byte(in[3]);
  out[3] = bVar5 ^ bVar2 ^ bVar1 ^ bVar3 ^ bVar4;
  return;
}



int tc_aes128_set_encrypt_key(TCAesKeySched_t s,uint8_t *k)

{
  int iVar1;
  byte *pbVar2;
  byte *pbVar3;
  uint uVar4;
  TCAesKeySched_t ptVar5;
  uint uVar6;
  uint uStack60;
  uint rconst [11];
  
  memcpy(&uStack60,&DAT_23076cb8,0x2c);
  iVar1 = 0;
  if ((s != (TCAesKeySched_t)0x0) && (k != (uint8_t *)0x0)) {
    pbVar2 = k;
    ptVar5 = s;
    do {
      pbVar3 = pbVar2 + 4;
      ptVar5->words[0] =
           (uint)*pbVar2 << 0x18 | (uint)pbVar2[1] << 0x10 | (uint)pbVar2[3] | (uint)pbVar2[2] << 8;
      pbVar2 = pbVar3;
      ptVar5 = (TCAesKeySched_t)(ptVar5->words + 1);
    } while (k + 0x10 != pbVar3);
    uVar4 = 4;
    do {
      uVar6 = s->words[3];
      if ((uVar4 & 3) == 0) {
        uVar6 = *(uint *)((int)&uStack60 + (uVar4 & 0xfffffffc)) ^
                ((uint)sbox[(uVar6 << 8) >> 0x10 & 0xff] << 0x10 |
                 (uint)sbox[(uVar6 << 8) >> 0x18] << 0x18 | (uint)sbox[uVar6 >> 0x18] |
                (uint)sbox[uVar6 & 0xff] << 8);
      }
      uVar4 = uVar4 + 1;
      s->words[4] = uVar6 ^ s->words[0];
      s = (TCAesKeySched_t)(s->words + 1);
    } while (uVar4 != 0x2c);
    iVar1 = 1;
  }
  return iVar1;
}



int tc_aes_encrypt(uint8_t *out,uint8_t *in,TCAesKeySched_t s)

{
  byte *pbVar1;
  byte *pbVar2;
  byte *out_00;
  uint *k;
  uint *puVar3;
  byte local_40 [4];
  uint8_t state [16];
  uint8_t t [16];
  
  if (((out != (uint8_t *)0x0) && (in != (uint8_t *)0x0)) && (s != (TCAesKeySched_t)0x0)) {
    _copy(local_40,0x10,in,0x10);
    add_round_key(local_40,(uint *)s);
    out_00 = state + 0xc;
    pbVar1 = local_40;
    k = s->words + 4;
    do {
      do {
        pbVar2 = pbVar1 + 1;
        *pbVar1 = sbox[*pbVar1];
        pbVar1 = pbVar2;
      } while (pbVar2 != out_00);
      shift_rows(local_40);
      mult_row_column(out_00,local_40);
      mult_row_column(t,state);
      mult_row_column(t + 4,state + 4);
      mult_row_column(t + 8,state + 8);
      _copy(local_40,0x10,out_00,0x10);
      puVar3 = k + 4;
      add_round_key(local_40,k);
      pbVar2 = local_40;
      pbVar1 = local_40;
      k = puVar3;
    } while (puVar3 != s->words + 0x28);
    do {
      pbVar1 = pbVar2 + 1;
      *pbVar2 = sbox[*pbVar2];
      pbVar2 = pbVar1;
    } while (out_00 != pbVar1);
    shift_rows(local_40);
    add_round_key(local_40,s->words + 0x28);
    _copy(out,0x10,local_40,0x10);
    _set(local_40,0,0x10);
    return 1;
  }
  return 0;
}



u8_t att_prepare_write_req(bt_att *att,net_buf *buf)

{
  return '\x06';
}



att_type_t att_op_get_type(u8_t op)

{
  att_type_t aVar1;
  undefined3 in_register_00002029;
  uint uVar2;
  uint uVar3;
  
  uVar2 = CONCAT31(in_register_00002029,op);
  if (uVar2 == 0xe) {
LAB_2302aa56:
    aVar1 = ATT_REQUEST;
  }
  else {
    if (uVar2 < 0xf) {
      if (uVar2 == 7) {
        return ATT_RESPONSE;
      }
      if (uVar2 < 8) {
        if (uVar2 == 3) {
          return ATT_RESPONSE;
        }
        if (3 < uVar2) {
          if (uVar2 == 5) {
            return ATT_RESPONSE;
          }
          goto LAB_2302aa56;
        }
        if (uVar2 == 1) {
          return ATT_RESPONSE;
        }
        if (uVar2 == 2) {
          return ATT_REQUEST;
        }
      }
      else {
        if (uVar2 == 10) {
          return ATT_REQUEST;
        }
        if (10 < uVar2) {
          if (uVar2 == 0xc) {
            return ATT_REQUEST;
          }
          return ATT_RESPONSE;
        }
        if (uVar2 == 8) {
          return ATT_REQUEST;
        }
        if (uVar2 == 9) {
          return ATT_RESPONSE;
        }
      }
    }
    else {
      if (uVar2 == 0x17) {
        return ATT_RESPONSE;
      }
      if (uVar2 < 0x18) {
        if (uVar2 == 0x11) {
          return ATT_RESPONSE;
        }
        if (uVar2 < 0x12) {
          if (uVar2 == 0xf) {
            return ATT_RESPONSE;
          }
          if (uVar2 == 0x10) {
            return ATT_REQUEST;
          }
        }
        else {
          if (uVar2 == 0x13) {
            return ATT_RESPONSE;
          }
          if (uVar2 < 0x13) {
            return ATT_REQUEST;
          }
          if (uVar2 == 0x16) {
            return ATT_REQUEST;
          }
        }
      }
      else {
        if (uVar2 == 0x1d) {
          return ATT_INDICATION;
        }
        if (uVar2 < 0x1e) {
          if (uVar2 == 0x19) {
            return ATT_RESPONSE;
          }
          if (uVar2 < 0x19) {
            return ATT_REQUEST;
          }
          uVar3 = 0x1b;
          aVar1 = ATT_NOTIFICATION;
        }
        else {
          if (uVar2 == 0x52) {
            return ATT_COMMAND;
          }
          if (uVar2 == 0xd2) {
            return ATT_COMMAND;
          }
          uVar3 = 0x1e;
          aVar1 = ATT_CONFIRMATION;
        }
        if (uVar2 == uVar3) {
          return aVar1;
        }
      }
    }
    aVar1 = ATT_UNKNOWN;
    if ((op & 0x40) != 0) {
      return ATT_COMMAND;
    }
  }
  return aVar1;
}



void att_req_destroy(bt_att_req_conflict26 *req)

{
  if (req->buf != (net_buf *)0x0) {
    net_buf_unref(req->buf);
  }
  if (req->destroy != (bt_att_destroy_t_conflict)0x0) {
    (*req->destroy)(req);
  }
  memset(req,0,0x18);
  return;
}



u8_t att_notify(bt_att *att,net_buf *buf)

{
  bt_conn *conn;
  u16_t handle;
  
  conn = (att->chan).chan.conn;
  handle = net_buf_simple_pull_le16((net_buf_simple *)&buf->field_4);
  bt_gatt_notification(conn,handle,*(void **)&buf->field_4,*(u16_t *)((int)&buf->field_4 + 4));
  return '\0';
}



void bt_gatt_foreach_attr
               (u16_t start_handle,u16_t end_handle,bt_gatt_attr_func_t *func,void *user_data)

{
  bt_gatt_foreach_attr_type(start_handle,end_handle,(bt_uuid *)0x0,(void *)0x0,0,func,user_data);
  return;
}



u8_t read_group_cb(bt_gatt_attr *attr,void *user_data)

{
  byte bVar1;
  ushort uVar2;
  u16_t uVar3;
  undefined uVar4;
  u8_t uVar5;
  int iVar6;
  undefined *puVar7;
  size_t len;
  undefined uVar8;
  bt_conn **ppbVar9;
  bt_conn *pbVar10;
  bt_uuid abStack40 [2];
  undefined2 uStack38;
  bt_uuid abStack36 [2];
  undefined2 uStack34;
  
  ppbVar9 = *(bt_conn ***)user_data;
  pbVar10 = *ppbVar9;
  abStack40[0] = (bt_uuid)0x0;
  uStack38 = 0x2800;
  iVar6 = bt_uuid_cmp(attr->uuid,abStack40);
  if (iVar6 != 0) {
    abStack36[0] = (bt_uuid)0x0;
    uStack34 = 0x2801;
    iVar6 = bt_uuid_cmp(attr->uuid,abStack36);
    if (iVar6 != 0) {
      iVar6 = *(int *)((int)user_data + 0x10);
      if (iVar6 == 0) {
        return '\x01';
      }
      uVar2 = attr->handle;
      if (uVar2 <= *(ushort *)(iVar6 + 2)) {
        return '\x01';
      }
      *(undefined *)(iVar6 + 2) = (char)uVar2;
      *(undefined *)(iVar6 + 3) = (char)(uVar2 >> 8);
      return '\x01';
    }
  }
  iVar6 = bt_uuid_cmp(attr->uuid,*(bt_uuid **)((int)user_data + 4));
  if (iVar6 == 0) {
    if ((**(byte **)((int)user_data + 0xc) == 0) ||
       ((int)(uint)**(byte **)((int)user_data + 0xc) <=
        (int)((uint)*(ushort *)((int)ppbVar9 + 0x56) -
             (uint)*(ushort *)(*(int *)((int)user_data + 8) + 0xc)))) {
      puVar7 = (undefined *)
               net_buf_simple_add((net_buf_simple *)(*(int *)((int)user_data + 8) + 8),4);
      *(undefined **)((int)user_data + 0x10) = puVar7;
      uVar3 = attr->handle;
      uVar4 = (undefined)uVar3;
      *puVar7 = uVar4;
      uVar8 = (undefined)(uVar3 >> 8);
      puVar7[1] = uVar8;
      iVar6 = *(int *)((int)user_data + 0x10);
      *(undefined *)(iVar6 + 3) = uVar8;
      *(undefined *)(iVar6 + 2) = uVar4;
      uVar2 = *(ushort *)(*(int *)((int)user_data + 8) + 0xc);
      len = (*attr->read)(pbVar10,attr,
                          (void *)(*(int *)(*(int *)((int)user_data + 8) + 8) + (uint)uVar2),
                          *(short *)((int)ppbVar9 + 0x56) - uVar2,0);
      if (-1 < (int)len) {
        bVar1 = **(byte **)((int)user_data + 0xc);
        if (bVar1 == 0) {
          **(byte **)((int)user_data + 0xc) = (byte)(len + 4);
        }
        else {
          if ((uint)bVar1 != len + 4) {
            *(short *)(*(int *)((int)user_data + 8) + 0xc) =
                 *(short *)(*(int *)((int)user_data + 8) + 0xc) + -4;
            goto LAB_2302ac0c;
          }
        }
        net_buf_simple_add((net_buf_simple *)(*(int *)((int)user_data + 8) + 8),len);
        goto LAB_2302abf0;
      }
    }
LAB_2302ac0c:
    uVar5 = '\0';
  }
  else {
    *(undefined4 *)((int)user_data + 0x10) = 0;
LAB_2302abf0:
    uVar5 = '\x01';
  }
  return uVar5;
}



u8_t read_type_cb(bt_gatt_attr *attr,void *user_data)

{
  byte bVar1;
  u16_t uVar2;
  ushort uVar3;
  bool bVar4;
  char cVar5;
  int iVar6;
  undefined3 extraout_var;
  undefined *puVar7;
  size_t len;
  bt_conn **ppbVar8;
  bt_conn *conn;
  
  ppbVar8 = *(bt_conn ***)user_data;
  conn = *ppbVar8;
  bVar4 = true;
  iVar6 = bt_uuid_cmp(attr->uuid,*(bt_uuid **)((int)user_data + 4));
  if (iVar6 == 0) {
    bVar4 = (bool)bt_gatt_check_perm(conn,attr,'\x15');
    *(bool *)((int)user_data + 0x14) = bVar4;
    if (CONCAT31(extraout_var,bVar4) == 0) {
      puVar7 = (undefined *)
               net_buf_simple_add((net_buf_simple *)(*(int *)((int)user_data + 8) + 8),2);
      *(undefined **)((int)user_data + 0x10) = puVar7;
      uVar2 = attr->handle;
      *puVar7 = (char)uVar2;
      puVar7[1] = (char)(uVar2 >> 8);
      uVar3 = *(ushort *)(*(int *)((int)user_data + 8) + 0xc);
      len = (*attr->read)(conn,attr,
                          (void *)(*(int *)(*(int *)((int)user_data + 8) + 8) + (uint)uVar3),
                          *(short *)((int)ppbVar8 + 0x56) - uVar3,0);
      if ((int)len < 0) {
        cVar5 = '\x0e';
        if (len + 0xff < 0xff) {
          cVar5 = -(char)len;
        }
        *(char *)((int)user_data + 0x14) = cVar5;
      }
      else {
        bVar1 = **(byte **)((int)user_data + 0xc);
        if (bVar1 == 0) {
          **(byte **)((int)user_data + 0xc) = (byte)(len + 2);
        }
        else {
          if ((uint)bVar1 != len + 2) {
            *(short *)(*(int *)((int)user_data + 8) + 0xc) =
                 *(short *)(*(int *)((int)user_data + 8) + 0xc) + -2;
            return bVar4;
          }
        }
        net_buf_simple_add((net_buf_simple *)(*(int *)((int)user_data + 8) + 8),len);
        bVar4 = (int)(uint)**(byte **)((int)user_data + 0xc) <
                (int)((uint)*(ushort *)((int)ppbVar8 + 0x56) -
                     (uint)*(ushort *)(*(int *)((int)user_data + 8) + 0xc));
      }
    }
    else {
      bVar4 = (bool)**(char **)((int)user_data + 0xc);
      if (bVar4 != false) {
        *(undefined *)((int)user_data + 0x14) = 0;
        bVar4 = false;
      }
    }
  }
  return (u8_t)bVar4;
}



u8_t find_type_cb(bt_gatt_attr *attr,void *user_data)

{
  byte data_len;
  ushort uVar1;
  u16_t uVar2;
  undefined uVar3;
  _Bool _Var4;
  int iVar5;
  uint uVar6;
  undefined3 extraout_var;
  char *fmt;
  undefined3 extraout_var_00;
  undefined *puVar7;
  undefined uVar8;
  bt_conn **ppbVar9;
  bt_conn *pbVar10;
  bt_uuid local_60 [2];
  undefined2 uStack94;
  bt_uuid abStack92 [2];
  undefined2 uStack90;
  u8_t auStack88 [4];
  u8_t uuid [16];
  bt_uuid_128 ref_uuid;
  bt_uuid_128 recvd_uuid;
  
  ppbVar9 = *(bt_conn ***)user_data;
  pbVar10 = *ppbVar9;
  local_60[0] = (bt_uuid)0x0;
  uStack94 = 0x2801;
  iVar5 = bt_uuid_cmp(attr->uuid,local_60);
  if (iVar5 == 0) goto skip;
  abStack92[0] = (bt_uuid)0x0;
  uStack90 = 0x2800;
  iVar5 = bt_uuid_cmp(attr->uuid,abStack92);
  if (iVar5 != 0) {
    iVar5 = *(int *)((int)user_data + 8);
    if (iVar5 == 0) {
      return '\x01';
    }
    uVar1 = attr->handle;
    if (*(ushort *)(iVar5 + 2) < uVar1) {
      *(undefined *)(iVar5 + 2) = (char)uVar1;
      *(undefined *)(iVar5 + 3) = (char)(uVar1 >> 8);
      return '\x01';
    }
    return '\x01';
  }
  if ((uint)*(ushort *)((int)ppbVar9 + 0x56) - (uint)*(ushort *)(*(int *)((int)user_data + 4) + 0xc)
      < 4) {
    return '\0';
  }
  uVar6 = (*attr->read)(pbVar10,attr,auStack88,0x10,0);
  if ((int)uVar6 < 0) goto skip;
  data_len = *(byte *)((int)user_data + 0x10);
  if ((uint)data_len == uVar6) {
    iVar5 = memcmp(*(u8_t **)((int)user_data + 0xc),auStack88,(uint)data_len);
LAB_2302ae6e:
    if (iVar5 == 0) {
      *(undefined *)((int)user_data + 0x11) = 0;
      puVar7 = (undefined *)
               net_buf_simple_add((net_buf_simple *)(*(int *)((int)user_data + 4) + 8),4);
      *(undefined **)((int)user_data + 8) = puVar7;
      uVar2 = attr->handle;
      uVar3 = (undefined)uVar2;
      *puVar7 = uVar3;
      uVar8 = (undefined)(uVar2 >> 8);
      puVar7[1] = uVar8;
      iVar5 = *(int *)((int)user_data + 8);
      *(undefined *)(iVar5 + 2) = uVar3;
      *(undefined *)(iVar5 + 3) = uVar8;
      return '\x01';
    }
  }
  else {
    _Var4 = bt_uuid_create((bt_uuid *)(ref_uuid.val + 0xf),*(u8_t **)((int)user_data + 0xc),data_len
                          );
    if (CONCAT31(extraout_var,_Var4) == 0) {
      uVar6 = (uint)*(byte *)((int)user_data + 0x10);
      fmt = "Unable to create UUID: size %u\r\n";
    }
    else {
      _Var4 = bt_uuid_create((bt_uuid *)(uuid + 0xc),auStack88,(u8_t)uVar6);
      if (CONCAT31(extraout_var_00,_Var4) != 0) {
        iVar5 = bt_uuid_cmp((bt_uuid *)(ref_uuid.val + 0xf),(bt_uuid *)(uuid + 0xc));
        goto LAB_2302ae6e;
      }
      fmt = "Unable to create UUID: size %d\r\n";
    }
    printf(fmt,uVar6);
  }
skip:
  *(undefined4 *)((int)user_data + 8) = 0;
  return '\x01';
}



u8_t find_info_cb(bt_gatt_attr *attr,void *user_data)

{
  u16_t uVar1;
  undefined2 uVar2;
  bool bVar3;
  char *pcVar4;
  undefined *puVar5;
  int iVar6;
  int iVar7;
  
  iVar7 = *(int *)user_data;
  if (*(int *)((int)user_data + 8) == 0) {
    pcVar4 = (char *)net_buf_simple_add((net_buf_simple *)(*(int *)((int)user_data + 4) + 8),1);
    *(char **)((int)user_data + 8) = pcVar4;
    *pcVar4 = (attr->uuid->type != '\0') + '\x01';
  }
  if (**(char **)((int)user_data + 8) == '\x01') {
    if (attr->uuid->type != '\0') {
      return '\0';
    }
    puVar5 = (undefined *)net_buf_simple_add((net_buf_simple *)(*(int *)((int)user_data + 4) + 8),4)
    ;
    *(undefined **)((int)user_data + 0xc) = puVar5;
    uVar1 = attr->handle;
    *puVar5 = (char)uVar1;
    puVar5[1] = (char)(uVar1 >> 8);
    iVar6 = *(int *)((int)user_data + 0xc);
    uVar2 = *(undefined2 *)(attr->uuid + 2);
    *(undefined *)(iVar6 + 2) = (char)uVar2;
    *(undefined *)(iVar6 + 3) = (char)((ushort)uVar2 >> 8);
    bVar3 = (uint)*(ushort *)(iVar7 + 0x56) - (uint)*(ushort *)(*(int *)((int)user_data + 4) + 0xc)
            < 5;
  }
  else {
    if (**(char **)((int)user_data + 8) != '\x02') {
      return '\0';
    }
    if (attr->uuid->type != '\x02') {
      return '\0';
    }
    puVar5 = (undefined *)
             net_buf_simple_add((net_buf_simple *)(*(int *)((int)user_data + 4) + 8),0x12);
    *(undefined **)((int)user_data + 0xc) = puVar5;
    uVar1 = attr->handle;
    *puVar5 = (char)uVar1;
    puVar5[1] = (char)(uVar1 >> 8);
    memcpy((void *)(*(int *)((int)user_data + 0xc) + 2),attr->uuid + 1,0x10);
    bVar3 = (uint)*(ushort *)(iVar7 + 0x56) - (uint)*(ushort *)(*(int *)((int)user_data + 4) + 0xc)
            < 0x13;
  }
  return (u8_t)(bVar3 ^ 1);
}



void bt_att_connected(bt_l2cap_chan *chan)

{
  k_queue_init((k_queue *)chan[3].rtx_work.work.flags,0x14);
  *(undefined2 *)((int)&chan[1].rtx_work.work.handler + 2) = 0x17;
  *(undefined2 *)((int)&chan[1].conn + 2) = 0x17;
  k_delayed_work_init((k_delayed_work *)&chan[2].rtx_work.timer.args,att_timeout);
  chan[2].rtx_work.timer.timer.hdl = (void *)0x0;
  chan[2].rtx_work.timer.handler = (k_timer_handler_t *)0x0;
  return;
}



bt_conn_tx_cb_t * att_cb(void)

{
  att_type_t aVar1;
  u8_t *in_a0;
  uint uVar2;
  code *pcVar3;
  
  aVar1 = att_op_get_type(*in_a0);
  uVar2 = (uint)aVar1 - 1 & 0xff;
  if (uVar2 < 5) {
    pcVar3 = *(code **)(&CSWTCH_31 + uVar2 * 4);
  }
  else {
    pcVar3 = att_pdu_sent;
  }
  return pcVar3;
}



int att_send(bt_conn *conn,net_buf *buf,bt_conn_tx_cb_t *cb,void *user_data)

{
  int iVar1;
  
  if (**(char **)&buf->field_4 == -0x2e) {
    iVar1 = bt_smp_sign(conn,buf);
    if (iVar1 != 0) {
      printf("Error signing data\r\n");
      net_buf_unref(buf);
      return iVar1;
    }
  }
  if (cb == (bt_conn_tx_cb_t *)0x0) {
    cb = att_cb();
  }
  iVar1 = bt_l2cap_send_cb(conn,4,buf,cb,user_data);
  return iVar1;
}



int att_send_req(bt_att *att,bt_att_req_conflict26 *req)

{
  bt_conn *conn;
  int iVar1;
  size_t sVar2;
  net_buf *buf;
  bt_conn_tx_cb_t *cb;
  net_buf *buf_00;
  
  att->req = req;
  iVar1 = k_sem_take(&att->tx_sem,0);
  buf_00 = req->buf;
  if (iVar1 < 0) {
    k_queue_append((k_queue *)&att->tx_queue,buf_00);
    iVar1 = 0;
  }
  else {
    sVar2 = net_buf_simple_headroom((net_buf_simple *)&buf_00->field_4);
    (req->state).offset = (u16_t)sVar2;
    buf = req->buf;
    (req->state).len = *(u16_t *)((int)&buf_00->field_4 + 4);
    conn = (att->chan).chan.conn;
    buf_00 = net_buf_ref(buf);
    cb = att_cb();
    iVar1 = bt_l2cap_send_cb(conn,4,buf_00,cb,(void *)0x0);
    if (iVar1 != 0) {
      net_buf_unref(req->buf);
      req->buf = (net_buf *)0x0;
    }
  }
  return iVar1;
}



u8_t att_handle_rsp(bt_att *att,void *pdu,u16_t len,u8_t err)

{
  bt_att_req_conflict26 *req;
  sys_snode_t *psVar1;
  bt_att_func_t *pbVar2;
  
  k_delayed_work_cancel((k_delayed_work *)&att->timeout_work);
  req = att->req;
  if (req == (bt_att_req_conflict26 *)0x0) {
    printf("No pending ATT request\r\n");
  }
  else {
    if (req != &cancel) {
      if (req->buf != (net_buf *)0x0) {
        net_buf_unref(req->buf);
        att->req->buf = (net_buf *)0x0;
      }
      pbVar2 = att->req->func;
      att->req->func = (bt_att_func_t *)0x0;
      (*pbVar2)((att->chan).chan.conn,err,pdu,len,att->req);
      if (att->req->func == (bt_att_func_t *)0x0) {
        att_req_destroy(att->req);
      }
    }
    att->req = (bt_att_req_conflict26 *)0x0;
  }
  req = (bt_att_req_conflict26 *)(att->reqs).head;
  if (req != (bt_att_req_conflict26 *)0x0) {
    psVar1 = (sys_snode_t *)(req->node).next;
    (att->reqs).head = psVar1;
    if (req == (bt_att_req_conflict26 *)(att->reqs).tail) {
      (att->reqs).tail = psVar1;
    }
    att_send_req(att,req);
  }
  return '\0';
}



u8_t att_handle_find_info_rsp(bt_att *att,net_buf *buf)

{
  u8_t uVar1;
  
  uVar1 = att_handle_rsp(att,*(void **)&buf->field_4,*(u16_t *)((int)&buf->field_4 + 4),'\0');
  return uVar1;
}



u8_t att_handle_find_type_rsp(bt_att *att,net_buf *buf)

{
  u8_t uVar1;
  
  uVar1 = att_handle_rsp(att,*(void **)&buf->field_4,*(u16_t *)((int)&buf->field_4 + 4),'\0');
  return uVar1;
}



u8_t att_handle_read_type_rsp(bt_att *att,net_buf *buf)

{
  u8_t uVar1;
  
  uVar1 = att_handle_rsp(att,*(void **)&buf->field_4,*(u16_t *)((int)&buf->field_4 + 4),'\0');
  return uVar1;
}



u8_t att_handle_read_rsp(bt_att *att,net_buf *buf)

{
  u8_t uVar1;
  
  uVar1 = att_handle_rsp(att,*(void **)&buf->field_4,*(u16_t *)((int)&buf->field_4 + 4),'\0');
  return uVar1;
}



u8_t att_handle_read_blob_rsp(bt_att *att,net_buf *buf)

{
  u8_t uVar1;
  
  uVar1 = att_handle_rsp(att,*(void **)&buf->field_4,*(u16_t *)((int)&buf->field_4 + 4),'\0');
  return uVar1;
}



u8_t att_handle_read_mult_rsp(bt_att *att,net_buf *buf)

{
  u8_t uVar1;
  
  uVar1 = att_handle_rsp(att,*(void **)&buf->field_4,*(u16_t *)((int)&buf->field_4 + 4),'\0');
  return uVar1;
}



u8_t att_handle_read_group_rsp(bt_att *att,net_buf *buf)

{
  u8_t uVar1;
  
  uVar1 = att_handle_rsp(att,*(void **)&buf->field_4,*(u16_t *)((int)&buf->field_4 + 4),'\0');
  return uVar1;
}



u8_t att_handle_write_rsp(bt_att *att,net_buf *buf)

{
  u8_t uVar1;
  
  uVar1 = att_handle_rsp(att,*(void **)&buf->field_4,*(u16_t *)((int)&buf->field_4 + 4),'\0');
  return uVar1;
}



u8_t att_handle_prepare_write_rsp(bt_att *att,net_buf *buf)

{
  u8_t uVar1;
  
  uVar1 = att_handle_rsp(att,*(void **)&buf->field_4,*(u16_t *)((int)&buf->field_4 + 4),'\0');
  return uVar1;
}



u8_t att_handle_exec_write_rsp(bt_att *att,net_buf *buf)

{
  u8_t uVar1;
  
  uVar1 = att_handle_rsp(att,*(void **)&buf->field_4,*(u16_t *)((int)&buf->field_4 + 4),'\0');
  return uVar1;
}



u8_t att_confirm(bt_att *att,net_buf *buf)

{
  u8_t uVar1;
  
  uVar1 = att_handle_rsp(att,*(void **)&buf->field_4,*(u16_t *)((int)&buf->field_4 + 4),'\0');
  return uVar1;
}



u8_t att_error_rsp(bt_att *att,net_buf *buf)

{
  byte bVar1;
  u8_t err;
  bt_conn *conn;
  bt_security_t sec;
  int iVar2;
  net_buf *pnVar3;
  bt_att_req_conflict26 *pbVar4;
  
  pbVar4 = att->req;
  if ((pbVar4 == (bt_att_req_conflict26 *)0x0) || (pbVar4 == &cancel)) {
    err = '\x0e';
    goto done;
  }
  pnVar3 = pbVar4->buf;
  iVar2 = *(int *)&buf->field_4;
  if (pnVar3 != (net_buf *)0x0) {
    *(uint *)&pnVar3->field_4 = *(int *)((int)&pnVar3->field_4 + 8) + (uint)(pbVar4->state).offset;
    *(u16_t *)((int)&pnVar3->field_4 + 4) = (pbVar4->state).len;
  }
  err = *(u8_t *)(iVar2 + 3);
  if (att->req->retrying != false) goto done;
  conn = (att->chan).chan.conn;
  if (err == '\x05') {
    bVar1 = conn->sec_level;
    if (bVar1 < 2) goto LAB_2302b21e;
    if (bVar1 == 2) {
      sec = BT_SECURITY_L3;
    }
    else {
      sec = BT_SECURITY_L4;
      if (bVar1 != 3) goto done;
    }
  }
  else {
    if ((err != '\x0f') || (1 < (byte)conn->sec_level)) goto done;
LAB_2302b21e:
    sec = BT_SECURITY_MEDIUM;
  }
  iVar2 = bt_conn_set_security(conn,sec);
  if (iVar2 == 0) {
    att->req->retrying = true;
    return '\0';
  }
done:
  err = att_handle_rsp(att,(void *)0x0,0,err);
  return err;
}



int bt_att_accept(bt_conn *conn,bt_l2cap_chan **chan)

{
  int iVar1;
  bt_att *__s;
  
  if (bt_req_pool[0].chan.chan.conn == (bt_conn *)0x0) {
    __s = bt_req_pool;
    iVar1 = 0;
  }
  else {
    if (bt_req_pool[1].chan.chan.conn != (bt_conn *)0x0) {
      printf("No available ATT context for conn %p\r\n",conn);
      return -0xc;
    }
    __s = bt_req_pool + 1;
    iVar1 = 1;
  }
  memset(__s,0,0xe4);
  bt_req_pool[iVar1].chan.chan.ops = (bt_l2cap_chan_ops *)0x4200d538;
  k_sem_init(&bt_req_pool[iVar1].tx_sem,10,10);
  *(bt_att **)chan = bt_req_pool + iVar1;
  return 0;
}



u8_t att_mtu_rsp(bt_att *att,net_buf *buf)

{
  u8_t err;
  ushort *pdu;
  u16_t len;
  ushort uVar1;
  
  if (att != (bt_att *)0x0) {
    pdu = *(ushort **)&buf->field_4;
    uVar1 = *pdu;
    if (uVar1 < 0x17) {
      err = '\x04';
      len = 0;
      pdu = (ushort *)0x0;
    }
    else {
      if (0xf7 < uVar1) {
        uVar1 = 0xf7;
      }
      (att->chan).rx.mtu = uVar1;
      (att->chan).tx.mtu = uVar1;
      len = *(u16_t *)((int)&buf->field_4 + 4);
      err = '\0';
    }
    err = att_handle_rsp(att,pdu,len,err);
    return err;
  }
  return '\0';
}



// WARNING: Type propagation algorithm not settling

void att_reset(bt_att *att)

{
  int iVar1;
  net_buf *buf;
  bt_att_req_conflict26 *req;
  bt_att_req_conflict26 *pbVar2;
  
  while (buf = (net_buf *)k_queue_get((k_queue *)&att->tx_queue,0), buf != (net_buf *)0x0) {
    net_buf_unref(buf);
  }
  atomic_or(att->flags,4);
  iVar1 = 10;
  do {
    iVar1 = iVar1 + -1;
    k_sem_give(&att->tx_sem);
  } while (iVar1 != 0);
  req = (bt_att_req_conflict26 *)(att->reqs).head;
  if (req != (bt_att_req_conflict26 *)0x0) {
    pbVar2 = *(bt_att_req_conflict26 **)&req->node;
    while( true ) {
      if (req->func != (bt_att_func_t *)0x0) {
        (*req->func)((bt_conn *)0x0,'\x0e',(void *)0x0,0,req);
      }
      att_req_destroy(req);
      if (pbVar2 == (bt_att_req_conflict26 *)0x0) break;
      req = pbVar2;
      pbVar2 = *(bt_att_req_conflict26 **)&pbVar2->node;
    }
  }
  req = att->req;
  (att->reqs).head = (sys_snode_t *)0x0;
  (att->reqs).tail = (sys_snode_t *)0x0;
  if (req == (bt_att_req_conflict26 *)0x0) {
    return;
  }
  att_handle_rsp(att,(void *)0x0,0,'\x0e');
  return;
}



void bt_att_disconnected(bt_l2cap_chan *chan)

{
  att_reset((bt_att *)chan);
  bt_gatt_disconnected(chan->conn);
  if (*(int *)&chan[2].state != 0) {
    k_delayed_work_del_timer((k_delayed_work *)&chan[2].rtx_work.timer.args);
  }
  if (chan[3].rtx_work.work.flags[0] != 0) {
    k_queue_free((k_queue *)chan[3].rtx_work.work.flags);
    chan[3].rtx_work.work.flags[0] = 0;
  }
  if (chan[3].destroy != (bt_l2cap_chan_destroy_t *)0x0) {
    k_sem_delete((k_sem *)&chan[3].destroy);
    return;
  }
  return;
}



void att_timeout(k_work *work)

{
  printf("ATT Timeout\r\n");
  att_reset((bt_att *)(work + -0xe));
  bt_gatt_disconnected((bt_conn *)work[-0xe]._reserved);
  work[-0xe]._reserved = (void *)0x0;
  return;
}



// WARNING: Type propagation algorithm not settling

void bt_att_encrypt_change(bt_l2cap_chan *chan,u8_t hci_status)

{
  bt_conn *conn;
  atomic_val_t aVar1;
  bt_conn_tx_cb_t *cb;
  undefined3 in_register_0000202d;
  net_buf *buf;
  k_work_q *pkVar2;
  
  if (CONCAT31(in_register_0000202d,hci_status) != 0) {
    att_handle_rsp((bt_att *)chan,(void *)0x0,0,'\x05');
    return;
  }
  conn = chan->conn;
  bt_gatt_encrypt_change(conn);
  if (((conn->sec_level != BT_SECURITY_LOW) &&
      (pkVar2 = chan[2].rtx_work.work_q, pkVar2 != (k_work_q *)0x0)) &&
     (*(char *)&pkVar2[1].fifo._queue.poll_events.field_1 != '\0')) {
    k_sem_take((k_sem *)&chan[3].destroy,0xffffffff);
    if ((chan->conn->state == BT_CONN_CONNECTED) &&
       (aVar1 = atomic_get(chan[2].rtx_work.work.flags), (aVar1 >> 2 & 1U) != 0)) {
      printf("Disconnected\r\n");
      k_sem_give((k_sem *)&chan[3].destroy);
      return;
    }
    buf = (net_buf *)chan[2].rtx_work.work_q[1].fifo._queue.poll_events.field_0;
    cb = att_cb();
    bt_l2cap_send_cb(conn,4,buf,cb,(void *)0x0);
    chan[2].rtx_work.work_q[1].fifo._queue.poll_events.field_0 = 0;
  }
  return;
}



undefined4 att_exec_write_req(void)

{
  return 6;
}



void att_pdu_sent(bt_conn *conn,void *user_data)

{
  k_work_q *pkVar1;
  bt_l2cap_chan *pbVar2;
  net_buf *buf;
  size_t sVar3;
  int iVar4;
  
  pbVar2 = bt_l2cap_le_lookup_tx_cid(conn,4);
  do {
    buf = net_buf_get((k_fifo *)pbVar2[3].rtx_work.work.flags,0);
    if (buf == (net_buf *)0x0) {
      k_sem_give((k_sem *)&pbVar2[3].destroy);
      return;
    }
    pkVar1 = pbVar2[2].rtx_work.work_q;
    if ((pkVar1 != (k_work_q *)0x0) && ((net_buf *)pkVar1[1].fifo._queue.poll_events.field_0 == buf)
       ) {
      sVar3 = net_buf_simple_headroom((net_buf_simple *)&buf->field_4);
      *(short *)&pkVar1[1].fifo._queue.hdl = (short)sVar3;
      *(undefined2 *)((int)&pkVar1[1].fifo._queue.hdl + 2) = *(undefined2 *)((int)&buf->field_4 + 4)
      ;
    }
    iVar4 = att_send(conn,buf,(bt_conn_tx_cb_t *)0x0,(void *)0x0);
  } while (iVar4 != 0);
  return;
}



bt_att * att_chan_get(bt_conn *conn)

{
  char *fmt;
  bt_att *pbVar1;
  atomic_val_t aVar2;
  
  if (conn->state == BT_CONN_CONNECTED) {
    pbVar1 = (bt_att *)bt_l2cap_le_lookup_rx_cid(conn,4);
    if (pbVar1 == (bt_att *)0x0) {
      printf("Unable to find ATT channel\r\n");
      return (bt_att *)0x0;
    }
    aVar2 = atomic_get(pbVar1->flags);
    if ((aVar2 >> 2 & 1U) == 0) {
      return pbVar1;
    }
    fmt = "ATT context flagged as disconnected\r\n";
  }
  else {
    fmt = "Not connected\r\n";
  }
  printf(fmt);
  return (bt_att *)0x0;
}



void att_req_sent(bt_conn *conn,void *user_data)

{
  bt_l2cap_chan *pbVar1;
  
  pbVar1 = bt_l2cap_le_lookup_tx_cid(conn,4);
  if (pbVar1[2].rtx_work.work_q != (k_work_q *)0x0) {
    k_delayed_work_submit((k_delayed_work *)&pbVar1[2].rtx_work.timer.args,30000);
  }
  att_pdu_sent(conn,user_data);
  return;
}



void att_cfm_sent(bt_conn *conn,void *user_data)

{
  bt_l2cap_le_lookup_tx_cid(conn,4);
  att_pdu_sent(conn,user_data);
  return;
}



void att_rsp_sent(bt_conn *conn,void *user_data)

{
  bt_l2cap_le_lookup_tx_cid(conn,4);
  att_pdu_sent(conn,user_data);
  return;
}



u8_t write_cb(bt_gatt_attr *attr,void *user_data)

{
  u8_t uVar1;
  u8_t uVar2;
  undefined3 extraout_var;
  uint uVar3;
  char cVar4;
  
  uVar2 = bt_gatt_check_perm(*(bt_conn **)user_data,attr,'*');
  *(u8_t *)((int)user_data + 0x14) = uVar2;
  uVar1 = '\0';
  if (CONCAT31(extraout_var,uVar2) == 0) {
    uVar3 = (*attr->write)(*(bt_conn **)user_data,attr,*(void **)((int)user_data + 0xc),
                           *(u16_t *)((int)user_data + 0x10),*(u16_t *)((int)user_data + 0x12),
                           (*(char *)((int)user_data + 8) == '\0') << 1);
    if ((int)uVar3 < 0) {
      cVar4 = '\x0e';
      if (uVar3 + 0xff < 0xff) {
        cVar4 = -(char)uVar3;
      }
    }
    else {
      if (uVar3 == (uint)*(ushort *)((int)user_data + 0x10)) {
        *(undefined *)((int)user_data + 0x14) = 0;
        return '\x01';
      }
      cVar4 = '\x0e';
    }
    *(char *)((int)user_data + 0x14) = cVar4;
    uVar1 = uVar2;
  }
  return uVar1;
}



u8_t read_cb(bt_gatt_attr *attr,void *user_data)

{
  ushort uVar1;
  u8_t uVar2;
  u8_t uVar3;
  char cVar4;
  void *pvVar5;
  undefined3 extraout_var;
  size_t len;
  bt_conn *conn;
  bt_conn **ppbVar6;
  
  ppbVar6 = *(bt_conn ***)user_data;
  conn = *ppbVar6;
  pvVar5 = net_buf_simple_add((net_buf_simple *)(*(int *)((int)user_data + 8) + 8),0);
  *(void **)((int)user_data + 0xc) = pvVar5;
  *(undefined *)((int)user_data + 0x10) = 0;
  uVar3 = bt_gatt_check_perm(conn,attr,'\x15');
  *(u8_t *)((int)user_data + 0x10) = uVar3;
  uVar2 = '\0';
  if (CONCAT31(extraout_var,uVar3) == 0) {
    uVar1 = *(ushort *)(*(int *)((int)user_data + 8) + 0xc);
    len = (*attr->read)(conn,attr,(void *)(*(int *)(*(int *)((int)user_data + 8) + 8) + (uint)uVar1)
                        ,*(short *)((int)ppbVar6 + 0x56) - uVar1,*(u16_t *)((int)user_data + 4));
    if ((int)len < 0) {
      cVar4 = '\x0e';
      if (len + 0xff < 0xff) {
        cVar4 = -(char)len;
      }
      *(char *)((int)user_data + 0x10) = cVar4;
      uVar2 = uVar3;
    }
    else {
      uVar2 = '\x01';
      net_buf_simple_add((net_buf_simple *)(*(int *)((int)user_data + 8) + 8),len);
    }
  }
  return uVar2;
}



net_buf * bt_att_create_pdu(bt_conn *conn,u8_t op,size_t len)

{
  att_type_t aVar1;
  bt_att *pbVar2;
  undefined3 extraout_var;
  u8_t *puVar3;
  undefined3 in_register_0000202d;
  s32_t timeout;
  
  pbVar2 = att_chan_get(conn);
  if (pbVar2 != (bt_att *)0x0) {
    if ((uint)(pbVar2->chan).tx.mtu < len + 1) {
      printf("ATT MTU exceeded, max %u, wanted %zu\r\n");
      pbVar2 = (bt_att *)0x0;
    }
    else {
      aVar1 = att_op_get_type(op);
      if ((CONCAT31(extraout_var,aVar1) == 2) || (timeout = -1, CONCAT31(extraout_var,aVar1) == 4))
      {
        timeout = 30000;
      }
      pbVar2 = (bt_att *)bt_l2cap_create_pdu_timeout((net_buf_pool *)0x0,0,timeout);
      if (pbVar2 == (bt_att *)0x0) {
        printf("Unable to allocate buffer for op 0x%02x\r\n",CONCAT31(in_register_0000202d,op));
      }
      else {
        puVar3 = (u8_t *)net_buf_simple_add((net_buf_simple *)&(pbVar2->chan).chan.node,1);
        *puVar3 = op;
      }
    }
  }
  return (net_buf *)pbVar2;
}



u8_t att_indicate(bt_att *att,net_buf *buf)

{
  bt_conn *conn;
  u16_t handle;
  net_buf *buf_00;
  
  conn = (att->chan).chan.conn;
  handle = net_buf_simple_pull_le16((net_buf_simple *)&buf->field_4);
  bt_gatt_notification(conn,handle,*(void **)&buf->field_4,*(u16_t *)((int)&buf->field_4 + 4));
  buf_00 = bt_att_create_pdu(conn,'\x1e',0);
  if (buf_00 != (net_buf *)0x0) {
    bt_l2cap_send_cb(conn,4,buf_00,att_cfm_sent,(void *)0x0);
  }
  return '\0';
}



u8_t att_mtu_req(bt_att *att,net_buf *buf)

{
  u8_t uVar1;
  net_buf *buf_00;
  undefined *puVar2;
  ushort uVar3;
  bt_conn *conn;
  
  uVar3 = **(ushort **)&buf->field_4;
  if (uVar3 < 0x17) {
    uVar1 = '\x04';
  }
  else {
    conn = (att->chan).chan.conn;
    buf_00 = bt_att_create_pdu(conn,'\x03',2);
    uVar1 = '\x0e';
    if (buf_00 != (net_buf *)0x0) {
      puVar2 = (undefined *)net_buf_simple_add((net_buf_simple *)&buf_00->field_4,2);
      *puVar2 = 0xf7;
      puVar2[1] = 0;
      bt_l2cap_send_cb(conn,4,buf_00,att_rsp_sent,(void *)0x0);
      if (0xf7 < uVar3) {
        uVar3 = 0xf7;
      }
      (att->chan).rx.mtu = uVar3;
      (att->chan).tx.mtu = uVar3;
      uVar1 = '\0';
    }
  }
  return uVar1;
}



void send_err_rsp(bt_conn *conn,u8_t req,u16_t handle,u8_t err)

{
  net_buf *buf;
  u8_t *puVar1;
  
  buf = bt_att_create_pdu(conn,'\x01',4);
  if (buf != (net_buf *)0x0) {
    puVar1 = (u8_t *)net_buf_simple_add((net_buf_simple *)&buf->field_4,4);
    puVar1[1] = (u8_t)handle;
    *puVar1 = req;
    puVar1[2] = (u8_t)(handle >> 8);
    puVar1[3] = err;
    bt_l2cap_send_cb(conn,4,buf,att_rsp_sent,(void *)0x0);
    return;
  }
  return;
}



int bt_att_recv(bt_l2cap_chan *chan,net_buf *buf)

{
  att_type_t aVar1;
  u8_t err;
  byte *pbVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  byte op;
  int iVar3;
  att_handler_conflict2 *paVar4;
  int iVar5;
  
  if (*(short *)((int)&buf->field_4 + 4) == 0) {
    printf("Too small ATT PDU received\r\n");
  }
  else {
    pbVar2 = (byte *)net_buf_simple_pull_mem((net_buf_simple *)&buf->field_4,1);
    paVar4 = handlers;
    iVar5 = 0;
    do {
      if ((uint)paVar4->op == (uint)*pbVar2) {
        if ((uint)*(ushort *)((int)&buf->field_4 + 4) < (uint)handlers[iVar5].expect_len) {
          printf("Invalid len %u for code 0x%02x\r\n");
          iVar3 = 4;
        }
        else {
          err = (*handlers[iVar5].func)((bt_att *)chan,buf);
          iVar3 = CONCAT31(extraout_var_00,err);
        }
        err = (u8_t)iVar3;
        if (handlers[iVar5].type != ATT_REQUEST) {
          return 0;
        }
        if (iVar3 == 0) {
          return 0;
        }
        op = *pbVar2;
        if (op == 0) {
          return 0;
        }
        goto LAB_2302b9c2;
      }
      iVar5 = iVar5 + 1;
      paVar4 = paVar4 + 1;
    } while (iVar5 != 0x1c);
    printf("Unhandled ATT code 0x%02x\r\n",(uint)*pbVar2);
    op = *pbVar2;
    aVar1 = att_op_get_type(op);
    if ((CONCAT31(extraout_var,aVar1) != 0) && (err = '\x06', op != 0)) {
LAB_2302b9c2:
      send_err_rsp(chan->conn,op,0,err);
    }
  }
  return 0;
}



u8_t att_read_group_req(bt_att *att,net_buf *buf)

{
  u16_t end_handle;
  u16_t handle;
  _Bool _Var1;
  u16_t *puVar2;
  undefined3 extraout_var;
  int iVar3;
  net_buf *buf_00;
  char *pcVar4;
  u8_t data_len;
  bt_conn *conn;
  bt_uuid abStack80 [2];
  undefined2 uStack78;
  bt_uuid abStack76 [2];
  undefined2 uStack74;
  bt_uuid abStack72 [4];
  anon_union_for_u u;
  read_group_data data;
  
  data_len = *(char *)((int)&buf->field_4 + 4) + -4;
  if ((data_len != '\x02') && (data_len != '\x10')) {
    return '\x04';
  }
  conn = (att->chan).chan.conn;
  puVar2 = (u16_t *)net_buf_simple_pull_mem((net_buf_simple *)&buf->field_4,4);
  handle = *puVar2;
  end_handle = puVar2[1];
  _Var1 = bt_uuid_create(abStack72,(u8_t *)(puVar2 + 2),data_len);
  if (CONCAT31(extraout_var,_Var1) == 0) {
    return '\x0e';
  }
  if (handle != 0) {
    if (end_handle == 0) {
      handle = 0;
    }
    else {
      if (handle <= end_handle) {
        abStack80[0] = (bt_uuid)0x0;
        uStack78 = 0x2800;
        iVar3 = bt_uuid_cmp(abStack72,abStack80);
        if (iVar3 == 0) {
LAB_2302ba66:
          conn = (att->chan).chan.conn;
          memset(u + 0x10,0,0x14);
          buf_00 = bt_att_create_pdu(conn,'\x11',1);
          if (buf_00 == (net_buf *)0x0) {
            return '\x0e';
          }
          unique0x10000076 = att;
          pcVar4 = (char *)net_buf_simple_add((net_buf_simple *)&buf_00->field_4,1);
          *pcVar4 = '\0';
          bt_gatt_foreach_attr(handle,end_handle,read_group_cb,u + 0x10);
          if (*pcVar4 != '\0') {
            bt_l2cap_send_cb(conn,4,buf_00,att_rsp_sent,(void *)0x0);
            return '\0';
          }
          net_buf_unref(buf_00);
          send_err_rsp(conn,'\x10',handle,'\n');
          return '\0';
        }
        abStack76[0] = (bt_uuid)0x0;
        uStack74 = 0x2801;
        iVar3 = bt_uuid_cmp(abStack72,abStack76);
        if (iVar3 == 0) goto LAB_2302ba66;
        data_len = '\x10';
        goto LAB_2302bade;
      }
    }
  }
  data_len = '\x01';
LAB_2302bade:
  send_err_rsp(conn,'\x10',handle,data_len);
  return '\0';
}



// WARNING: Could not reconcile some variable overlaps

u8_t att_read_mult_req(bt_att *att,net_buf *buf)

{
  bt_conn *conn;
  u8_t uVar1;
  u16_t start_handle;
  bt_att *pbStack52;
  read_data data;
  
  conn = (att->chan).chan.conn;
  memset(&pbStack52,0,0x14);
  data._4_4_ = bt_att_create_pdu(conn,'\x0f',0);
  if (data._4_4_ == (net_buf *)0x0) {
    uVar1 = '\x0e';
  }
  else {
    pbStack52 = att;
    do {
      if (*(ushort *)((int)&buf->field_4 + 4) < 2) {
        bt_l2cap_send_cb(conn,4,data._4_4_,att_rsp_sent,(void *)0x0);
        goto LAB_2302bba4;
      }
      start_handle = net_buf_simple_pull_le16((net_buf_simple *)&buf->field_4);
      data.rsp._0_1_ = '\x01';
      bt_gatt_foreach_attr(start_handle,start_handle,read_cb,&pbStack52);
    } while ((u8_t)data.rsp == '\0');
    net_buf_unref(data._4_4_);
    send_err_rsp(conn,'\x0e',start_handle,(u8_t)data.rsp);
LAB_2302bba4:
    uVar1 = '\0';
  }
  return uVar1;
}



// WARNING: Variable defined which should be unmapped: data
// WARNING: Could not reconcile some variable overlaps

u8_t att_read_rsp(bt_att *att,u8_t op,u8_t rsp,u16_t handle,u16_t offset)

{
  u8_t uVar1;
  bt_conn *conn;
  _Bool _Var2;
  undefined3 extraout_var;
  undefined2 in_register_00002036;
  bt_att *pbStack52;
  read_data data;
  
  conn = (att->chan).chan.conn;
  _Var2 = bt_gatt_change_aware(conn,true);
  uVar1 = '\x12';
  if ((CONCAT31(extraout_var,_Var2) != 0) &&
     (uVar1 = '\x01', CONCAT22(in_register_00002036,handle) != 0)) {
    memset(&pbStack52,0,0x14);
    data._4_4_ = bt_att_create_pdu(conn,rsp,0);
    if (data._4_4_ == (net_buf *)0x0) {
      uVar1 = '\x0e';
    }
    else {
      data.rsp._0_1_ = '\x01';
      pbStack52 = att;
      data.att._0_2_ = offset;
      bt_gatt_foreach_attr(handle,handle,read_cb,&pbStack52);
      uVar1 = (u8_t)data.rsp;
      if ((u8_t)data.rsp == '\0') {
        bt_l2cap_send_cb(conn,4,data._4_4_,att_rsp_sent,(void *)0x0);
      }
      else {
        net_buf_unref(data._4_4_);
        send_err_rsp(conn,op,handle,(u8_t)data.rsp);
        uVar1 = '\0';
      }
    }
  }
  return uVar1;
}



u8_t att_read_blob_req(bt_att *att,net_buf *buf)

{
  u8_t uVar1;
  
  uVar1 = att_read_rsp(att,'\f','\r',**(u16_t **)&buf->field_4,(*(u16_t **)&buf->field_4)[1]);
  return uVar1;
}



u8_t att_read_req(bt_att *att,net_buf *buf)

{
  u8_t uVar1;
  
  uVar1 = att_read_rsp(att,'\n','\v',**(u16_t **)&buf->field_4,0);
  return uVar1;
}



// WARNING: Removing unreachable block (ram,0x2302bd9a)
// WARNING: Could not reconcile some variable overlaps

u8_t att_read_type_req(bt_att *att,net_buf *buf)

{
  u16_t end_handle;
  u16_t start_handle;
  _Bool _Var1;
  u16_t *puVar2;
  undefined3 extraout_var;
  net_buf *buf_00;
  undefined *puVar3;
  u8_t data_len;
  bt_conn *conn;
  bt_uuid abStack76 [4];
  anon_union_for_u u;
  read_type_data data;
  
  data_len = *(char *)((int)&buf->field_4 + 4) + -4;
  if ((data_len != '\x02') && (data_len != '\x10')) {
    return '\x04';
  }
  conn = (att->chan).chan.conn;
  puVar2 = (u16_t *)net_buf_simple_pull_mem((net_buf_simple *)&buf->field_4,4);
  start_handle = *puVar2;
  end_handle = puVar2[1];
  _Var1 = bt_uuid_create(abStack76,(u8_t *)(puVar2 + 2),data_len);
  if (CONCAT31(extraout_var,_Var1) == 0) {
    return '\x0e';
  }
  if (start_handle != 0) {
    if (end_handle == 0) {
      start_handle = 0;
    }
    else {
      if (start_handle <= end_handle) {
        conn = (att->chan).chan.conn;
        memset(u + 0x10,0,0x18);
        buf_00 = bt_att_create_pdu(conn,'\t',1);
        if (buf_00 == (net_buf *)0x0) {
          return '\x0e';
        }
        unique0x10000060 = att;
        puVar3 = (undefined *)net_buf_simple_add((net_buf_simple *)&buf_00->field_4,1);
        *puVar3 = 0;
        data.item._0_1_ = '\n';
        bt_gatt_foreach_attr(start_handle,end_handle,read_type_cb,u + 0x10);
        net_buf_unref(buf_00);
        goto LAB_2302bd4e;
      }
    }
  }
  data.item._0_1_ = '\x01';
LAB_2302bd4e:
  send_err_rsp(conn,'\b',start_handle,(u8_t)data.item);
  return '\0';
}



// WARNING: Variable defined which should be unmapped: data
// WARNING: Could not reconcile some variable overlaps

u8_t att_find_type_req(bt_att *att,net_buf *buf)

{
  u16_t end_handle;
  u16_t *puVar1;
  int iVar2;
  u16_t start_handle;
  u8_t err;
  bt_conn *conn;
  bt_att_handle_group *pbVar3;
  bt_uuid abStack60 [2];
  u16_t uStack58;
  bt_uuid abStack56 [2];
  undefined2 uStack54;
  bt_att *pbStack52;
  find_type_data data;
  
  conn = (att->chan).chan.conn;
  puVar1 = (u16_t *)net_buf_simple_pull_mem((net_buf_simple *)&buf->field_4,6);
  start_handle = *puVar1;
  if (start_handle != 0) {
    end_handle = puVar1[1];
    if (end_handle == 0) {
      start_handle = 0;
    }
    else {
      if (start_handle <= end_handle) {
        uStack58 = puVar1[2];
        pbVar3 = *(bt_att_handle_group **)&buf->field_4;
        abStack60[0] = (bt_uuid)0x0;
        abStack56[0] = (bt_uuid)0x0;
        uStack54 = 0x2800;
        iVar2 = bt_uuid_cmp(abStack60,abStack56);
        if (iVar2 == 0) {
          data.value._0_1_ = *(undefined *)((int)&buf->field_4 + 4);
          conn = (att->chan).chan.conn;
          memset(&pbStack52,0,0x14);
          data.att = (bt_att *)bt_att_create_pdu(conn,'\a',0);
          if (data.att == (bt_att *)0x0) {
            return '\x0e';
          }
          data.buf = (net_buf *)0x0;
          data.value._1_1_ = '\n';
          pbStack52 = att;
          data.group = pbVar3;
          bt_gatt_foreach_attr(start_handle,end_handle,find_type_cb,&pbStack52);
          if (data.value._1_1_ == '\0') {
            bt_l2cap_send_cb(conn,4,(net_buf *)data.att,att_rsp_sent,(void *)0x0);
            return '\0';
          }
          net_buf_unref((net_buf *)data.att);
          err = data.value._1_1_;
        }
        else {
          err = '\n';
        }
        goto LAB_2302be30;
      }
    }
  }
  err = '\x01';
LAB_2302be30:
  send_err_rsp(conn,'\x06',start_handle,err);
  return '\0';
}



u8_t att_find_info_req(bt_att *att,net_buf *buf)

{
  u16_t end_handle;
  u16_t start_handle;
  u8_t err;
  bt_conn *conn;
  bt_att *local_30;
  find_info_data data;
  
  conn = (att->chan).chan.conn;
  start_handle = **(u16_t **)&buf->field_4;
  if (start_handle != 0) {
    end_handle = (*(u16_t **)&buf->field_4)[1];
    if (end_handle == 0) {
      start_handle = 0;
    }
    else {
      if (start_handle <= end_handle) {
        memset(&local_30,0,0x10);
        data.att = (bt_att *)bt_att_create_pdu(conn,'\x05',0);
        if (data.att == (bt_att *)0x0) {
          return '\x0e';
        }
        local_30 = att;
        bt_gatt_foreach_attr(start_handle,end_handle,find_info_cb,&local_30);
        if (data.buf != (net_buf *)0x0) {
          bt_l2cap_send_cb(conn,4,(net_buf *)data.att,att_rsp_sent,(void *)0x0);
          return '\0';
        }
        net_buf_unref((net_buf *)data.att);
        err = '\n';
        goto LAB_2302bf22;
      }
    }
  }
  err = '\x01';
LAB_2302bf22:
  send_err_rsp(conn,'\x04',start_handle,err);
  return '\0';
}



// WARNING: Variable defined which should be unmapped: data
// WARNING: Could not reconcile some variable overlaps

u8_t att_write_rsp(bt_conn *conn,u8_t req,u8_t rsp,u16_t handle,void *value,u16_t len)

{
  u8_t uVar1;
  _Bool _Var2;
  undefined3 extraout_var;
  undefined3 in_register_0000202d;
  undefined3 in_register_00002031;
  undefined2 in_register_00002036;
  bt_conn *pbStack56;
  write_data_conflict data;
  
  _Var2 = bt_gatt_change_aware(conn,(_Bool)(CONCAT31(in_register_0000202d,req) != 0));
  uVar1 = '\x12';
  if ((CONCAT31(extraout_var,_Var2) != 0) &&
     (uVar1 = '\x01', CONCAT22(in_register_00002036,handle) != 0)) {
    memset(&pbStack56,0,0x18);
    if ((CONCAT31(in_register_00002031,rsp) != 0) &&
       (data.conn = (bt_conn *)bt_att_create_pdu(conn,rsp,0), data.conn == (bt_conn *)0x0)) {
      return '\x0e';
    }
    data.value._2_2_ = 0;
    data.len._0_1_ = '\x01';
    pbStack56 = conn;
    data.buf._0_1_ = req;
    data._8_4_ = value;
    data.value._0_2_ = len;
    bt_gatt_foreach_attr(handle,handle,write_cb,&pbStack56);
    if ((u8_t)data.len == '\0') {
      if (data.conn != (bt_conn *)0x0) {
        bt_l2cap_send_cb(conn,4,(net_buf *)data.conn,att_rsp_sent,(void *)0x0);
        return '\0';
      }
    }
    else {
      if ((CONCAT31(in_register_00002031,rsp) != 0) &&
         (net_buf_unref((net_buf *)data.conn), CONCAT31(in_register_0000202d,req) != 0)) {
        send_err_rsp(conn,req,handle,(u8_t)data.len);
      }
    }
    uVar1 = '\0';
  }
  return uVar1;
}



u8_t att_write_req(bt_att *att,net_buf *buf)

{
  bt_conn *conn;
  u8_t uVar1;
  u16_t handle;
  
  conn = (att->chan).chan.conn;
  handle = net_buf_simple_pull_le16((net_buf_simple *)&buf->field_4);
  uVar1 = att_write_rsp(conn,'\x12','\x13',handle,*(void **)&buf->field_4,
                        *(u16_t *)((int)&buf->field_4 + 4));
  return uVar1;
}



u8_t att_write_cmd(bt_att *att,net_buf *buf)

{
  bt_conn *conn;
  u8_t uVar1;
  u16_t handle;
  
  conn = (att->chan).chan.conn;
  handle = net_buf_simple_pull_le16((net_buf_simple *)&buf->field_4);
  uVar1 = att_write_rsp(conn,'\0','\0',handle,*(void **)&buf->field_4,
                        *(u16_t *)((int)&buf->field_4 + 4));
  return uVar1;
}



u8_t att_signed_write_cmd(bt_att *att,net_buf *buf)

{
  u16_t handle;
  u8_t uVar1;
  int iVar2;
  net_buf_simple *buf_00;
  bt_conn *conn;
  
  conn = (att->chan).chan.conn;
  buf_00 = (net_buf_simple *)&buf->field_4;
  handle = **(u16_t **)&buf->field_4;
  net_buf_simple_push(buf_00,1);
  iVar2 = bt_smp_sign_verify(conn,buf);
  if (iVar2 == 0) {
    net_buf_simple_pull(buf_00,1);
    net_buf_simple_pull(buf_00,2);
    uVar1 = att_write_rsp(conn,'\0','\0',handle,*(void **)&buf->field_4,
                          (u16_t)(((uint)*(ushort *)((int)&buf->field_4 + 4) - 0xc) * 0x10000 >>
                                 0x10));
    return uVar1;
  }
  printf("Error verifying data\r\n");
  return '\0';
}



void bt_att_init(void)

{
  anon_subr_int_bt_conn_ptr_bt_l2cap_chan_ptr_ptr_for_accept **ppaVar1;
  bool bVar2;
  int iVar3;
  uint uVar4;
  bt_gatt_service_static *pbVar5;
  
  iVar3 = atomic_cas(&init,0,1);
  if (iVar3 != 0) {
    uVar4 = (uint)last_static_handle;
    bVar2 = false;
    pbVar5 = &_1_gatt_svc;
    while (pbVar5 < &att_fixed_chan) {
      ppaVar1 = &((bt_l2cap_fixed_chan *)pbVar5)->accept;
      pbVar5 = (bt_gatt_service_static *)&((bt_l2cap_fixed_chan *)pbVar5)->node;
      uVar4 = (uint)(*ppaVar1 + uVar4) & 0xffff;
      bVar2 = true;
    }
    if (bVar2) {
      last_static_handle = (u16_t)uVar4;
    }
    k_delayed_work_init((k_delayed_work *)&gatt_sc.work,sc_process);
    return;
  }
  return;
}



u16_t bt_att_get_mtu(bt_conn *conn)

{
  u16_t uVar1;
  bt_att *pbVar2;
  
  pbVar2 = att_chan_get(conn);
  if (pbVar2 == (bt_att *)0x0) {
    uVar1 = 0;
  }
  else {
    uVar1 = (pbVar2->chan).tx.mtu;
  }
  return uVar1;
}



int bt_att_send(bt_conn *conn,net_buf *buf,bt_conn_tx_cb_t *cb,void *user_data)

{
  int iVar1;
  bt_att *pbVar2;
  
  pbVar2 = att_chan_get(conn);
  if (pbVar2 == (bt_att *)0x0) {
    net_buf_unref(buf);
    iVar1 = -0x39;
  }
  else {
    if ((cb == (bt_conn_tx_cb_t *)0x0) && (iVar1 = k_sem_take(&pbVar2->tx_sem,0), iVar1 < 0)) {
      k_queue_append((k_queue *)&pbVar2->tx_queue,buf);
      return 0;
    }
    iVar1 = att_send(conn,buf,cb,user_data);
    if ((iVar1 != 0) && (cb == (bt_conn_tx_cb_t *)0x0)) {
      k_sem_give(&pbVar2->tx_sem);
    }
  }
  return iVar1;
}



int bt_att_req_send(bt_conn *conn,bt_att_req_conflict26 *req)

{
  bt_att *att;
  int iVar1;
  sys_snode_t *psVar2;
  
  att = att_chan_get(conn);
  if (att == (bt_att *)0x0) {
    net_buf_unref(req->buf);
    iVar1 = -0x39;
    req->buf = (net_buf *)0x0;
  }
  else {
    if (att->req == (bt_att_req_conflict26 *)0x0) {
      iVar1 = att_send_req(att,req);
      return iVar1;
    }
    (req->node).next = (_snode *)0x0;
    psVar2 = (att->reqs).tail;
    if (psVar2 == (sys_snode_t *)0x0) {
      *(bt_att_req_conflict26 **)&(att->reqs).tail = req;
      *(bt_att_req_conflict26 **)&(att->reqs).head = req;
    }
    else {
      *(bt_att_req_conflict26 **)&psVar2->next = req;
      *(bt_att_req_conflict26 **)&(att->reqs).tail = req;
    }
    iVar1 = 0;
  }
  return iVar1;
}



// WARNING: Type propagation algorithm not settling

void bt_att_req_cancel(bt_conn *param_1,sys_snode_t param_2)

{
  bt_att *pbVar1;
  sys_snode_t sVar2;
  sys_snode_t sVar3;
  
  if ((param_1 == (bt_conn *)0x0) || (param_2 == (sys_snode_t)0x0)) {
    return;
  }
  pbVar1 = att_chan_get(param_1);
  if (pbVar1 == (bt_att *)0x0) {
    return;
  }
  if ((sys_snode_t)((sys_snode_t *)&pbVar1->req)->next == param_2) {
    pbVar1->req = &cancel;
  }
  else {
    sVar2 = (sys_snode_t)0x0;
    sVar3 = (sys_snode_t)(pbVar1->reqs).head;
    while (sVar3 != (sys_snode_t)0x0) {
      if (param_2 == sVar3) {
        sVar3 = *(sys_snode_t *)param_2;
        if (sVar2 == (sys_snode_t)0x0) {
          sVar2 = (sys_snode_t)((sys_snode_t *)&(pbVar1->reqs).tail)->next;
          *(sys_snode_t *)&(pbVar1->reqs).head = sVar3;
          if (param_2 == sVar2) {
            *(sys_snode_t *)&((sys_snode_t *)&(pbVar1->reqs).tail)->next = sVar3;
          }
        }
        else {
          *(sys_snode_t *)sVar2 = sVar3;
          if (param_2 == (sys_snode_t)((sys_snode_t *)&(pbVar1->reqs).tail)->next) {
            *(sys_snode_t *)&((sys_snode_t *)&(pbVar1->reqs).tail)->next = sVar2;
          }
        }
        *(undefined4 *)param_2 = 0;
        break;
      }
      sVar2 = sVar3;
      sVar3 = *(sys_snode_t *)sVar3;
    }
  }
  att_req_destroy((bt_att_req_conflict26 *)param_2);
  return;
}



uint32_t fdt32_ld(fdt32_t *p)

{
  return (uint)*(byte *)((int)p + 2) << 8 |
         (uint)*(byte *)p << 0x18 | (uint)*(byte *)((int)p + 1) << 0x10 |
         (uint)*(byte *)((int)p + 3);
}



int nextprop_(void *fdt,int offset)

{
  uint32_t uVar1;
  int iStack36;
  int nextoffset;
  
  while( true ) {
    uVar1 = fdt_next_tag(fdt,offset,&iStack36);
    if (uVar1 == 3) {
      return offset;
    }
    if (uVar1 == 9) break;
    offset = iStack36;
    if (uVar1 != 4) {
      return -1;
    }
  }
  if (iStack36 < 0) {
    return iStack36;
  }
  return -0xb;
}



fdt_property * fdt_get_property_by_offset_(void *fdt,int offset,int *lenp)

{
  fdt_property *pfVar1;
  uint32_t uVar2;
  
  uVar2 = fdt_check_prop_offset_(fdt,offset);
  if ((int)uVar2 < 0) {
    pfVar1 = (fdt_property *)0x0;
    if (lenp == (int *)0x0) {
      return (fdt_property *)0x0;
    }
  }
  else {
    uVar2 = fdt32_ld((fdt32_t *)((int)fdt + 8));
    pfVar1 = (fdt_property *)((int)fdt + uVar2 + offset);
    if (lenp == (int *)0x0) {
      return pfVar1;
    }
    uVar2 = fdt32_ld(&pfVar1->len);
  }
  *lenp = uVar2;
  return pfVar1;
}



char * fdt_get_string(void *fdt,int stroffset,int *lenp)

{
  char *__s;
  uint32_t uVar1;
  void *pvVar2;
  uint __n;
  uint uVar3;
  
  uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 0xc));
  pvVar2 = (void *)fdt_ro_probe_(fdt);
  if (pvVar2 == (void *)0x0) {
    uVar3 = uVar1 + stroffset;
    uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 4));
    if (uVar3 < uVar1) {
      __n = uVar1 - uVar3;
      uVar1 = fdt32_ld((fdt32_t *)fdt);
      if (uVar1 == 0xd00dfeed) {
        if (-1 < stroffset) {
          uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 0x14));
          if (0x10 < uVar1) {
            uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 0x20));
            if (uVar1 <= (uint)stroffset) goto LAB_2302c3e4;
            if (uVar1 - stroffset < __n) {
              __n = uVar1 - stroffset;
            }
          }
LAB_2302c384:
          __s = (char *)((int)fdt + uVar3);
          pvVar2 = memchr(__s,0,__n);
          if (pvVar2 != (void *)0x0) {
            pvVar2 = (void *)((int)pvVar2 - (int)__s);
            goto joined_r0x2302c3da;
          }
          pvVar2 = (void *)0xfffffff8;
          goto fail;
        }
      }
      else {
        if (uVar1 != 0x2ff20112) {
          pvVar2 = (void *)0xfffffff3;
          goto fail;
        }
        if ((stroffset < 0) &&
           (uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 0x20)), -uVar1 <= (uint)stroffset)) {
          if ((uint)-stroffset < __n) {
            __n = -stroffset;
          }
          goto LAB_2302c384;
        }
      }
    }
LAB_2302c3e4:
    pvVar2 = (void *)0xfffffffc;
  }
fail:
  __s = (char *)0x0;
joined_r0x2302c3da:
  if (lenp != (int *)0x0) {
    *(void **)lenp = pvVar2;
  }
  return __s;
}



char * fdt_get_name(void *fdt,int nodeoffset,int *len)

{
  uint32_t uVar1;
  size_t sVar2;
  uint32_t uVar3;
  char *__s;
  
  uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 8));
  sVar2 = fdt_ro_probe_(fdt);
  if ((sVar2 == 0) && (sVar2 = fdt_check_node_offset_(fdt,nodeoffset), -1 < (int)sVar2)) {
    uVar3 = fdt32_ld((fdt32_t *)((int)fdt + 0x14));
    __s = (char *)((int)fdt + nodeoffset + uVar1 + 4);
    if (uVar3 < 0x10) {
      __s = strrchr(__s,0x2f);
      if (__s == (char *)0x0) {
        sVar2 = 0xfffffff5;
        goto fail;
      }
      __s = __s + 1;
    }
    if (len == (int *)0x0) {
      return __s;
    }
    sVar2 = strlen(__s);
  }
  else {
fail:
    __s = (char *)0x0;
    if (len == (int *)0x0) {
      return (char *)0x0;
    }
  }
  *len = sVar2;
  return __s;
}



int fdt_subnode_offset_namelen(void *fdt,int offset,char *name,int namelen)

{
  int iVar1;
  char *__s1;
  void *pvVar2;
  int iStack40;
  int depth;
  int olen;
  
  iVar1 = fdt_ro_probe_(fdt);
  if (iVar1 == 0) {
    iStack40 = 0;
    while (-1 < offset) {
      if (iStack40 < 0) goto LAB_2302c492;
      if ((((iStack40 == 1) && (__s1 = fdt_get_name(fdt,offset,&depth), __s1 != (char *)0x0)) &&
          (namelen <= depth)) && (iVar1 = memcmp(__s1,name,namelen), iVar1 == 0)) {
        if (__s1[namelen] == '\0') {
          return offset;
        }
        pvVar2 = memchr(name,0x40,namelen);
        if ((pvVar2 == (void *)0x0) && (__s1[namelen] == '@')) {
          return offset;
        }
      }
      offset = fdt_next_node(fdt,offset,&iStack40);
    }
    iVar1 = offset;
    if (iStack40 < 0) {
LAB_2302c492:
      iVar1 = -1;
    }
  }
  return iVar1;
}



int fdt_subnode_offset(void *fdt,int parentoffset,char *name)

{
  size_t namelen;
  int iVar1;
  
  namelen = strlen(name);
  iVar1 = fdt_subnode_offset_namelen(fdt,parentoffset,name,namelen);
  return iVar1;
}



int fdt_first_property_offset(void *fdt,int nodeoffset)

{
  int offset;
  
  offset = fdt_check_node_offset_(fdt,nodeoffset);
  if (-1 < offset) {
    offset = nextprop_(fdt,offset);
    return offset;
  }
  return offset;
}



int fdt_next_property_offset(void *fdt,int offset)

{
  int offset_00;
  
  offset_00 = fdt_check_prop_offset_(fdt,offset);
  if (-1 < offset_00) {
    offset_00 = nextprop_(fdt,offset_00);
    return offset_00;
  }
  return offset_00;
}



// WARNING: Variable defined which should be unmapped: slen

fdt_property *
fdt_get_property_namelen_(void *fdt,int offset,char *name,int namelen,int *lenp,int *poffset)

{
  int offset_00;
  fdt_property *pfVar1;
  uint32_t stroffset;
  char *__s1;
  int iVar2;
  int iStack36;
  int slen;
  
  offset_00 = fdt_first_property_offset(fdt,offset);
  do {
    if (offset_00 < 0) {
LAB_2302c590:
      if (lenp != (int *)0x0) {
        *lenp = offset_00;
      }
      return (fdt_property *)0x0;
    }
    pfVar1 = fdt_get_property_by_offset_(fdt,offset_00,lenp);
    if (pfVar1 == (fdt_property *)0x0) {
      offset_00 = -0xd;
      goto LAB_2302c590;
    }
    stroffset = fdt32_ld(&pfVar1->nameoff);
    __s1 = fdt_get_string(fdt,stroffset,&iStack36);
    if (((__s1 != (char *)0x0) && (namelen == iStack36)) &&
       (iVar2 = memcmp(__s1,name,namelen), iVar2 == 0)) {
      if (poffset == (int *)0x0) {
        return pfVar1;
      }
      *poffset = offset_00;
      return pfVar1;
    }
    offset_00 = fdt_next_property_offset(fdt,offset_00);
  } while( true );
}



void * fdt_getprop_namelen(void *fdt,int nodeoffset,char *name,int namelen,int *lenp)

{
  fdt_property *pfVar1;
  uint32_t uVar2;
  int iStack20;
  int poffset;
  
  pfVar1 = fdt_get_property_namelen_(fdt,nodeoffset,name,namelen,lenp,&iStack20);
  if (pfVar1 != (fdt_property *)0x0) {
    uVar2 = fdt32_ld((fdt32_t *)((int)fdt + 0x14));
    if (((uVar2 < 0x10) && ((iStack20 + 0xcU & 7) != 0)) &&
       (uVar2 = fdt32_ld(&pfVar1->len), 7 < uVar2)) {
      pfVar1 = (fdt_property *)&pfVar1[1].len;
    }
    else {
      pfVar1 = pfVar1 + 1;
    }
  }
  return pfVar1;
}



void * fdt_getprop(void *fdt,int nodeoffset,char *name,int *lenp)

{
  size_t namelen;
  void *pvVar1;
  
  namelen = strlen(name);
  pvVar1 = fdt_getprop_namelen(fdt,nodeoffset,name,namelen,lenp);
  return pvVar1;
}



// WARNING: Variable defined which should be unmapped: length

int fdt_stringlist_count(void *fdt,int nodeoffset,char *property)

{
  int iVar1;
  char *__string;
  size_t sVar2;
  char *pcVar3;
  int iStack20;
  int length;
  
  __string = (char *)fdt_getprop(fdt,nodeoffset,property,&iStack20);
  iVar1 = iStack20;
  if (__string != (char *)0x0) {
    pcVar3 = __string + iStack20;
    iVar1 = 0;
    while (__string < pcVar3) {
      sVar2 = strnlen(__string,(size_t)(pcVar3 + -(int)__string));
      iStack20 = sVar2 + 1;
      __string = __string + iStack20;
      if (pcVar3 < __string) {
        return -0xf;
      }
      iVar1 = iVar1 + 1;
    }
  }
  return iVar1;
}



char * fdt_stringlist_get(void *fdt,int nodeoffset,char *property,int idx,int *lenp)

{
  char *__string;
  size_t sVar1;
  int iVar2;
  char *pcVar3;
  int iStack36;
  int length;
  
  __string = (char *)fdt_getprop(fdt,nodeoffset,property,&iStack36);
  if (__string == (char *)0x0) {
    if (lenp != (int *)0x0) {
      *lenp = iStack36;
      return (char *)0x0;
    }
  }
  else {
    pcVar3 = __string + iStack36;
    while (__string < pcVar3) {
      sVar1 = strnlen(__string,(size_t)(pcVar3 + -(int)__string));
      iStack36 = sVar1 + 1;
      if (pcVar3 < __string + iStack36) {
        iVar2 = -0xf;
        if (lenp == (int *)0x0) {
          return (char *)0x0;
        }
        goto LAB_2302c710;
      }
      if (idx == 0) {
        if (lenp != (int *)0x0) {
          *lenp = sVar1;
          return __string;
        }
        return __string;
      }
      idx = idx + -1;
      __string = __string + iStack36;
    }
    if (lenp != (int *)0x0) {
      iVar2 = -1;
LAB_2302c710:
      *lenp = iVar2;
    }
  }
  return (char *)0x0;
}



uint32_t fdt32_ld(fdt32_t *p)

{
  return (uint)*(byte *)((int)p + 2) << 8 |
         (uint)*(byte *)p << 0x18 | (uint)*(byte *)((int)p + 1) << 0x10 |
         (uint)*(byte *)((int)p + 3);
}



int fdt_ro_probe_(void *fdt)

{
  uint32_t uVar1;
  int iVar2;
  
  uVar1 = fdt32_ld((fdt32_t *)fdt);
  if (uVar1 == 0xd00dfeed) {
    uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 0x14));
    iVar2 = -10;
    if (1 < uVar1) {
      uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 0x18));
      iVar2 = 0;
      if (0x11 < uVar1) {
        iVar2 = -10;
      }
    }
  }
  else {
    iVar2 = -9;
    if (uVar1 == 0x2ff20112) {
      uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 0x24));
      iVar2 = 0;
      if (uVar1 == 0) {
        iVar2 = -7;
      }
    }
  }
  return iVar2;
}



void * fdt_offset_ptr(void *fdt,int offset,uint len)

{
  uint32_t uVar1;
  void *pvVar2;
  uint uVar3;
  
  uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 8));
  uVar3 = uVar1 + offset;
  pvVar2 = (void *)0x0;
  if ((uint)offset <= uVar3) {
    pvVar2 = (void *)0x0;
    if (uVar3 <= uVar3 + len) {
      uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 4));
      pvVar2 = (void *)0x0;
      if (uVar3 + len <= uVar1) {
        uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 0x14));
        if (0x10 < uVar1) {
          if (len + offset < (uint)offset) {
            return (void *)0x0;
          }
          uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 0x24));
          if (uVar1 < len + offset) {
            return (void *)0x0;
          }
        }
        pvVar2 = (void *)((int)fdt + uVar3);
      }
    }
  }
  return pvVar2;
}



uint32_t fdt_next_tag(void *fdt,int startoffset,int *nextoffset)

{
  int offset;
  int offset_00;
  uint *puVar1;
  char *pcVar2;
  void *pvVar3;
  uint32_t uVar4;
  uint uVar5;
  uint uVar6;
  
  *nextoffset = -8;
  puVar1 = (uint *)fdt_offset_ptr(fdt,startoffset,4);
  if (puVar1 != (uint *)0x0) {
    uVar5 = *puVar1;
    offset = startoffset + 4;
    uVar5 = uVar5 << 0x18 | uVar5 >> 0x18 | (uVar5 >> 8 & 0xff) << 0x10 |
            (uVar5 >> 0x10 & 0xff) << 8;
    *nextoffset = -0xb;
    offset_00 = offset;
    switch(uVar5) {
    case 1:
      do {
        offset = offset_00 + 1;
        pcVar2 = (char *)fdt_offset_ptr(fdt,offset_00,1);
        if (pcVar2 == (char *)0x0) {
          return 9;
        }
        offset_00 = offset;
      } while (*pcVar2 != '\0');
      break;
    case 2:
    case 4:
    case 9:
      break;
    case 3:
      puVar1 = (uint *)fdt_offset_ptr(fdt,offset,4);
      if (puVar1 == (uint *)0x0) {
        return 9;
      }
      uVar6 = *puVar1;
      uVar6 = uVar6 << 0x18 | uVar6 >> 0x18 | (uVar6 >> 8 & 0xff) << 0x10 |
              (uVar6 >> 0x10 & 0xff) << 8;
      uVar4 = fdt32_ld((fdt32_t *)((int)fdt + 0x14));
      offset = startoffset + 0xcU + uVar6;
      if (((uVar4 < 0x10) && (7 < uVar6)) && ((startoffset + 0xcU & 7) != 0)) {
        offset = offset + 4;
      }
      break;
    default:
      goto LAB_2302c8b6;
    }
    pvVar3 = fdt_offset_ptr(fdt,startoffset,offset - startoffset);
    if (pvVar3 != (void *)0x0) {
      *nextoffset = offset + 3U & 0xfffffffc;
      return uVar5;
    }
  }
LAB_2302c8b6:
  return 9;
}



int fdt_check_node_offset_(void *fdt,int offset)

{
  uint32_t uVar1;
  int aiStack20 [4];
  
  if (((offset < 0) || ((offset & 3U) != 0)) ||
     (aiStack20[0] = offset, uVar1 = fdt_next_tag(fdt,offset,aiStack20), uVar1 != 1)) {
    aiStack20[0] = -4;
  }
  return aiStack20[0];
}



int fdt_check_prop_offset_(void *fdt,int offset)

{
  uint32_t uVar1;
  int aiStack20 [4];
  
  if (((offset < 0) || ((offset & 3U) != 0)) ||
     (aiStack20[0] = offset, uVar1 = fdt_next_tag(fdt,offset,aiStack20), uVar1 != 3)) {
    aiStack20[0] = -4;
  }
  return aiStack20[0];
}



int fdt_next_node(void *fdt,int offset,int *depth)

{
  uint32_t uVar1;
  int iVar2;
  int iStack36;
  int nextoffset;
  
  iStack36 = 0;
  if (offset < 0) goto LAB_2302c998;
  iStack36 = fdt_check_node_offset_(fdt,offset);
  iVar2 = iStack36;
  do {
    if (iVar2 < 0) {
      return iStack36;
    }
LAB_2302c998:
    do {
      while (iVar2 = iStack36, uVar1 = fdt_next_tag(fdt,iStack36,&iStack36), uVar1 != 2) {
        if (uVar1 == 9) {
          if (iStack36 < 0) {
            if (iStack36 != -8) {
              return iStack36;
            }
            if (depth != (int *)0x0) {
              return -8;
            }
          }
          return -1;
        }
        if (uVar1 == 1) {
          if (depth == (int *)0x0) {
            return iVar2;
          }
          *depth = *depth + 1;
          return iVar2;
        }
      }
    } while (depth == (int *)0x0);
    iVar2 = *depth + -1;
    *depth = iVar2;
  } while( true );
}



void cmd_blog_info_dump(char *buf,int len,int argc,char **argv)

{
  blog_info_t *pbVar1;
  blog_info_t *pbVar2;
  size_t __n;
  int iVar3;
  char *pcVar4;
  byte *pbVar5;
  byte **ppbVar6;
  char local_b0 [4];
  char name_buf [128];
  
  memset(local_b0,0,0x80);
  bl_printk("blog code1 = %p - %p\r\n",&_fsymc_info_bloop,&_fsymf_info_bloopbloop_base);
  bl_printk("blog code2 = %p - %p\r\n",&_fsymf_info_bloopbloop_base,&_bl_static_blogfile_code_end);
  bl_printk("blog code3 = %p - %p\r\n",&_bl_static_blogfile_code_end,&_bl_static_blogfile_code_end);
  pbVar1 = &_fsymc_info_bloop;
  do {
    if ((blog_info_t *)((int)&_fsymc_info_loopset.name + 3U) < pbVar1) {
      return;
    }
    __n = strlen(pbVar1->name);
    if (0x80 < __n) {
      bl_printk("name too long.\r\n");
      return;
    }
    if (local_b0[0] == '\0') {
LAB_2302cae4:
      bl_printk("[%-48s] = [%d]\r\n",pbVar1->name,(uint)*pbVar1->level);
      if ((local_b0[0] == '\0') || (iVar3 = strcmp(pbVar1->name,local_b0), iVar3 != 0)) {
        pbVar2 = &_fsymf_info_bloopbloop_base;
        strcpy(local_b0,pbVar1->name);
        while (pbVar2 < (blog_info_t *)&_bl_static_blogfile_code_end) {
          pcVar4 = strstr(pbVar2->name,pbVar1->name);
          if (pcVar4 == pbVar2->name) {
            ppbVar6 = (byte **)&_bl_static_blogfile_code_end;
            bl_printk("[%-48s] = [%d]\r\n",pcVar4,(uint)*pbVar2->level);
            while (ppbVar6 < &_bl_static_blogfile_code_end) {
              pbVar5 = (byte *)strstr((char *)ppbVar6[1],pbVar2->name);
              if (pbVar5 == ppbVar6[1]) {
                bl_printk("[%-48s] = [%d]\r\n",pbVar5,(uint)**ppbVar6);
              }
              ppbVar6 = ppbVar6 + 2;
            }
          }
          pbVar2 = pbVar2 + 1;
        }
      }
    }
    else {
      iVar3 = strcmp(local_b0,pbVar1->name);
      if (iVar3 != 0) {
        __n = strlen(local_b0);
        memset(local_b0,0,__n);
        goto LAB_2302cae4;
      }
    }
    pbVar1 = pbVar1 + 1;
  } while( true );
}



size_t blog_strcpy(size_t cur_len,char *dst,char *src)

{
  char cVar1;
  char *pcVar2;
  
  pcVar2 = src;
  while ((cVar1 = *pcVar2, cVar1 != '\0' && (pcVar2 + (cur_len - (int)src) < (char *)0x100))) {
    pcVar2 = pcVar2 + 1;
    *dst = cVar1;
    dst = dst + 1;
  }
  return (size_t)(pcVar2 + -(int)src);
}



void cmd_blog_set_level(char *buf,int len,int argc,char **argv)

{
  blog_info_t *pbVar1;
  int iVar2;
  char *format;
  size_t sVar3;
  int iVar4;
  char *__s;
  int iVar5;
  blog_info_t *pbVar6;
  blog_level_t bVar7;
  int iVar8;
  
  if (argc != 3) {
    bl_printk("arg error.\r\n");
    goto LAB_2302cbb2;
  }
  iVar2 = strcmp(argv[1],"all");
  if (iVar2 == 0) {
    bVar7 = BLOG_LEVEL_ALL;
LAB_2302cc60:
    __s = argv[2];
    sVar3 = strlen(__s);
    iVar5 = 0;
    iVar2 = 0;
    while (iVar2 < (int)sVar3) {
      if (__s[iVar2] == '.') {
        iVar5 = iVar5 + 1;
      }
      iVar2 = iVar2 + 1;
    }
    if (iVar5 == 0) {
      pbVar1 = &_fsymf_info_bloopbloop_base;
      pbVar6 = &_fsymc_info_bloop;
    }
    else {
      if (iVar5 == 1) {
        pbVar1 = (blog_info_t *)&_bl_static_blogfile_code_end;
        pbVar6 = &_fsymf_info_bloopbloop_base;
      }
      else {
        if (iVar5 != 2) {
          __s = argv[2];
          format = "input name = %s not support.\r\n";
          goto LAB_2302cc58;
        }
        pbVar1 = (blog_info_t *)&_bl_static_blogfile_code_end;
        pbVar6 = (blog_info_t *)&_bl_static_blogfile_code_end;
      }
    }
    iVar2 = ((int)((int)pbVar1 - (int)pbVar6) >> 3) + -1;
    iVar5 = 0;
    while (__s = argv[2], iVar5 <= iVar2) {
      iVar8 = iVar5 + iVar2 >> 1;
      pbVar1 = pbVar6 + iVar8;
      iVar4 = strcmp(pbVar1->name,__s);
      if (iVar4 < 0) {
        iVar5 = iVar8 + 1;
      }
      else {
        if (iVar4 == 0) {
          *pbVar1->level = bVar7;
          bl_printk("set %s = %d\r\n",pbVar1->name,(uint)*pbVar1->level);
          return;
        }
        iVar2 = iVar8 + -1;
      }
    }
    format = "input name = %s not find.\r\n";
  }
  else {
    iVar2 = strcmp(argv[1],"debug");
    bVar7 = BLOG_LEVEL_DEBUG;
    if (iVar2 == 0) goto LAB_2302cc60;
    iVar2 = strcmp(argv[1],"info");
    bVar7 = BLOG_LEVEL_INFO;
    if (iVar2 == 0) goto LAB_2302cc60;
    iVar2 = strcmp(argv[1],"warn");
    bVar7 = BLOG_LEVEL_WARN;
    if (iVar2 == 0) goto LAB_2302cc60;
    iVar2 = strcmp(argv[1],"error");
    bVar7 = BLOG_LEVEL_ERROR;
    if (iVar2 == 0) goto LAB_2302cc60;
    iVar2 = strcmp(argv[1],"assert");
    bVar7 = BLOG_LEVEL_ASSERT;
    if (iVar2 == 0) goto LAB_2302cc60;
    iVar2 = strcmp(argv[1],"never");
    bVar7 = BLOG_LEVEL_NEVER;
    if (iVar2 == 0) goto LAB_2302cc60;
    __s = argv[1];
    format = "input level = %s not support.\r\n";
  }
LAB_2302cc58:
  bl_printk(format,__s);
LAB_2302cbb2:
  bl_printk("set blog error.\r\n");
  return;
}



void blog_port_output(char *log,size_t size)

{
  bl_printk("%.*s",log);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void blog_hexdump_out(char *name,uint8_t width,uint8_t *buf,uint16_t size)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  size_t sVar4;
  size_t sVar5;
  undefined3 in_register_0000202d;
  undefined2 in_register_00002036;
  uint uVar6;
  uint uVar7;
  size_t cur_len;
  undefined4 uStack72;
  char dump_string [8];
  
  uVar6 = CONCAT22(in_register_00002036,size);
  uStack72 = 0;
  dump_string._0_4_ = 0;
  uVar1 = 0;
  while (uVar1 < uVar6) {
    uVar3 = snprintf(log_buf,0x100,"[%s]: %04X-%04X: ",name,uVar1,
                     CONCAT31(in_register_0000202d,width) + uVar1 + -1);
    if (0x100 < uVar3) {
      uVar3 = 0x100;
    }
    cur_len = uVar3 & 0xffff;
    uVar7 = 0;
    uVar2 = CONCAT31(in_register_0000202d,width) & 0xffff;
    uVar3 = uVar1;
    while ((uVar7 & 0xffff) < uVar2) {
      if ((int)uVar3 < (int)uVar6) {
        snprintf((char *)&uStack72,8,"%02X ",(uint)buf[uVar3]);
      }
      else {
        strncpy((char *)&uStack72,"   ",8);
      }
      sVar4 = blog_strcpy(cur_len,log_buf + cur_len,(char *)&uStack72);
      uVar7 = uVar7 + 1;
      cur_len = cur_len + sVar4 & 0xffff;
      if ((uVar7 & 7) == 0) {
        sVar4 = blog_strcpy(cur_len,log_buf + cur_len," ");
        cur_len = cur_len + sVar4 & 0xffff;
      }
      uVar3 = uVar3 + 1;
    }
    sVar4 = blog_strcpy(cur_len,log_buf + cur_len,"  ");
    cur_len = sVar4 + cur_len & 0xffff;
    uVar3 = uVar1;
    while ((uVar3 - uVar1 & 0xffff) < uVar2) {
      if ((int)uVar3 < (int)uVar6) {
        uVar7 = (uint)buf[uVar3];
        if (0x5e < uVar7 - 0x20) {
          uVar7 = 0x2e;
        }
        snprintf((char *)&uStack72,8,"%c",uVar7);
        sVar4 = blog_strcpy(cur_len,log_buf + cur_len,(char *)&uStack72);
        cur_len = cur_len + sVar4 & 0xffff;
      }
      uVar3 = uVar3 + 1;
    }
    sVar5 = strlen("\r\n");
    if (0x100 < sVar5 + cur_len) {
      sVar5 = strlen("\r\n");
      cur_len = 0x100 - sVar5 & 0xffff;
    }
    sVar4 = blog_strcpy(cur_len,log_buf + cur_len,"\r\n");
    blog_port_output(log_buf,sVar4 + cur_len & 0xffff);
    uVar1 = uVar1 + uVar2 & 0xffff;
  }
  return;
}



void blog_init(void)

{
  blog_level_t **ppbVar1;
  undefined *puVar2;
  blog_info_t *pbVar3;
  undefined4 *puVar4;
  
  bl_printk("\r\nblog init set power on level %d, %d, %d.\r\n",2,2);
  pbVar3 = &_fsymc_info_bloop;
  while (pbVar3 < &_fsymf_info_bloopbloop_base) {
    ppbVar1 = &pbVar3->level;
    pbVar3 = pbVar3 + 1;
    **ppbVar1 = BLOG_LEVEL_INFO;
  }
  pbVar3 = &_fsymf_info_bloopbloop_base;
  while (pbVar3 < (blog_info_t *)&_bl_static_blogfile_code_end) {
    ppbVar1 = &pbVar3->level;
    pbVar3 = pbVar3 + 1;
    **ppbVar1 = BLOG_LEVEL_INFO;
  }
  puVar4 = (undefined4 *)&_bl_static_blogfile_code_end;
  while (puVar4 < &_bl_static_blogfile_code_end) {
    puVar2 = (undefined *)*puVar4;
    puVar4 = puVar4 + 2;
    *puVar2 = 2;
  }
  return;
}



void wifiprov_ccc_cfg_changed(bt_gatt_attr *attr,u16_t value)

{
  return;
}



// WARNING: Could not reconcile some variable overlaps

void __bl_ble_sync_task(void *p_arg)

{
  uint16_t mtu;
  u16_t uVar1;
  pro_handle_t ppVar2;
  QueueHandle_t pQVar3;
  BaseType_t BVar4;
  int iVar5;
  TickType_t TVar6;
  undefined auStack308 [4];
  queue_buf recv_buf;
  
  cJSON_InitHooks(&__g_cjson_hooks);
  ppVar2 = pro_trans_init((pro_dev *)((int)p_arg + 0xef0),&ble_gatt_func,(void *)0x0);
  *(pro_handle_t *)((int)p_arg + 0x40c) = ppVar2;
  *(undefined *)((int)p_arg + 0x61e) = 1;
  pQVar3 = xQueueGenericCreateStatic(1,0,(uint8_t *)0x0,(StaticQueue_t *)((int)p_arg + 4),'\x03');
  *(QueueHandle_t *)p_arg = pQVar3;
  pQVar3 = xQueueGenericCreateStatic
                     (2,0x104,(uint8_t *)((int)p_arg + 0x100),(StaticQueue_t *)((int)p_arg + 0xb0),
                      '\0');
  *(QueueHandle_t *)((int)p_arg + 0xac) = pQVar3;
  mtu = 0;
  while (*(char *)((int)p_arg + 0x620) == '\0') {
    BVar4 = xQueueReceive(*(QueueHandle_t *)((int)p_arg + 0xac),auStack308,10000);
    if (BVar4 == 1) {
      if (*(bt_conn **)((int)p_arg + 0x684) != (bt_conn *)0x0) {
        uVar1 = bt_gatt_get_mtu(*(bt_conn **)((int)p_arg + 0x684));
        mtu = uVar1 - 3;
      }
      iVar5 = pro_trans_read(*(pro_handle_t *)((int)p_arg + 0x40c),auStack308,recv_buf.buf._252_4_,
                             mtu);
      if (((iVar5 != 0) && (_fsymc_level_blsync_ble < BLOG_LEVEL_WARN)) &&
         (_fsymf_level_blsync_bleblsync_ble < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar6 = xTaskGetTickCount();
        }
        else {
          TVar6 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] protocol analyze failed\r\n",TVar6,&DAT_2306e4ac,
                  "blsync_ble.c",0x142);
      }
    }
    else {
      pro_trans_reset(*(pro_handle_t *)((int)p_arg + 0x40c));
    }
  }
  *(undefined *)((int)p_arg + 0x61e) = 0;
  vTaskDelete(*(TaskHandle_t *)((int)p_arg + 0xee8));
  return;
}



void scan_complete_cb(void *param)

{
  byte bVar1;
  bl_ble_sync_t *pbVar2;
  
  pbVar2 = gp_index;
  gp_index->scaning = '\0';
  bVar1 = pbVar2->w_ap_item;
  if (bVar1 < 0x32) {
    memcpy(pbVar2->ap_item + bVar1,param,0x30);
    gp_index->w_ap_item = gp_index->w_ap_item + '\x01';
  }
  return;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Could not reconcile some variable overlaps

int __recv_event(void *p_drv,pro_event *p_event)

{
  event_type_t eVar1;
  bl_ble_sync_t *pbVar2;
  blog_level_t bVar3;
  SemaphoreHandle_t *ppQVar4;
  pro_handle_t handle;
  TickType_t TVar5;
  wifi_conn *__dest;
  code *pcVar6;
  BaseType_t BVar7;
  cJSON *object;
  cJSON *item;
  char *__s;
  void *__src;
  size_t bytes;
  uint uVar8;
  blesync_wifi_func *pbVar9;
  anon_subr_void_wifi_conn_ptr_for_local_connect_remote_ap *paVar10;
  anon_subr_void_for_local_disconnect_remote_ap *paVar11;
  anon_subr_void_anon_subr_void_void_ptr_ptr_for_local_wifi_state_get *paVar12;
  undefined4 uStack52;
  char bssid [20];
  
  uStack52 = 0;
  bssid._0_4_ = 0;
  bssid._4_4_ = 0;
  bssid._8_4_ = 0;
  bssid._12_4_ = 0;
  if ((_fsymc_level_blsync_ble < BLOG_LEVEL_WARN) &&
     (_fsymf_level_blsync_bleblsync_ble < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar5 = xTaskGetTickCount();
    }
    else {
      TVar5 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] event type %d, id %d\r\n",TVar5,&DAT_2306e4ac,"blsync_ble.c",0xa0,
              (uint)p_event->type,p_event->event_id);
  }
  bVar3 = _fsymc_level_blsync_ble;
  pbVar2 = gp_index;
  eVar1 = p_event->type;
  if (eVar1 == PROTOCOL_EVENT_DATA) {
    uVar8 = p_event->event_id;
    if (uVar8 == 2) {
      memset(&gp_index->conn_info,0,0x20);
      pbVar2 = gp_index;
      (gp_index->conn_info).ssid_tail[0] = '\0';
      bytes = p_event->length;
      __src = p_event->p_buf;
      __dest = &pbVar2->conn_info;
    }
    else {
      if (uVar8 != 3) {
        if (uVar8 != (uint)eVar1) {
          return 2;
        }
        return 0;
      }
      memset((gp_index->conn_info).pask,0,0x40);
      bytes = p_event->length;
      __src = p_event->p_buf;
      __dest = (wifi_conn *)(gp_index->conn_info).pask;
    }
    memcpy(__dest,__src,bytes);
    return 0;
  }
  if (eVar1 != PROTOCOL_EVENT_CMD) {
    return 0;
  }
  switch(p_event->event_id) {
  case 3:
    pcVar6 = (code *)&gp_index->conn_info;
    paVar10 = gp_index->wifi_func->local_connect_remote_ap;
    if (paVar10 == (anon_subr_void_wifi_conn_ptr_for_local_connect_remote_ap *)0x0) {
      return 0;
    }
    break;
  case 4:
    paVar11 = gp_index->wifi_func->local_disconnect_remote_ap;
    if (paVar11 != (anon_subr_void_for_local_disconnect_remote_ap *)0x0) {
      (*paVar11)();
      return 0;
    }
    return 0;
  default:
    return 2;
  case 7:
    pro_trans_layer_ack_read(gp_index->pro_handle,"v1.1.0",7);
    return 0;
  case 9:
    pbVar9 = gp_index->wifi_func;
    if (pbVar9->local_wifi_scan ==
        (anon_subr_void_anon_subr_void_void_ptr_ptr_for_local_wifi_scan *)0x0) {
      return 0;
    }
    *(undefined2 *)&gp_index->w_ap_item = 0;
    pbVar2->scaning = '\x01';
    paVar10 = (anon_subr_void_wifi_conn_ptr_for_local_connect_remote_ap *)pbVar9->local_wifi_scan;
    pcVar6 = scan_complete_cb;
    break;
  case 0xb:
    if (gp_index->w_ap_item == 0) {
      return 1;
    }
    uVar8 = (uint)gp_index->r_ap_item;
    if ((uint)gp_index->w_ap_item == uVar8) {
      *(undefined2 *)&gp_index->w_ap_item = 0;
      if (BLOG_LEVEL_INFO < bVar3) {
        return 0;
      }
      if (_fsymf_level_blsync_bleblsync_ble < BLOG_LEVEL_WARN) {
        if (TrapNetCounter == 0) {
          TVar5 = xTaskGetTickCount();
        }
        else {
          TVar5 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] wifi list end\r\n",TVar5,&DAT_2306e4ac,"blsync_ble.c",0xd2);
        return 0;
      }
      return 0;
    }
    if ((_fsymc_level_blsync_ble < BLOG_LEVEL_WARN) &&
       (_fsymf_level_blsync_bleblsync_ble < BLOG_LEVEL_WARN)) {
      if (TrapNetCounter == 0) {
        TVar5 = xTaskGetTickCount();
      }
      else {
        TVar5 = xTaskGetTickCountFromISR();
      }
      gp_index->r_ap_item = gp_index->r_ap_item + '\x01';
      bl_printk("[%10u][%s: %s:%4d] item_nums %d\r\n",TVar5,&DAT_2306e4ac,"blsync_ble.c",0xd6);
    }
    object = cJSON_CreateObject();
    ppQVar4 = &pbVar2->xSemaphore + uVar8 * 0xc;
    sprintf((char *)&uStack52,"%02X:%02X:%02X:%02X:%02X:%02X",(uint)*(byte *)(ppQVar4 + 0x3f1),
            (uint)*(byte *)((int)ppQVar4 + 0xfc5),(uint)*(byte *)((int)ppQVar4 + 0xfc6),
            (uint)*(byte *)((int)ppQVar4 + 0xfc7),(uint)*(byte *)(ppQVar4 + 0x3f2),
            (uint)*(byte *)((int)ppQVar4 + 0xfc9));
    __floatunsidf((uint)*(byte *)((int)ppQVar4 + 0xfca));
    item = cJSON_CreateNumber();
    cJSON_AddItemToObject(object,"chan",item);
    item = cJSON_CreateString((char *)&uStack52);
    cJSON_AddItemToObject(object,"bssid",item);
    __floatsidf((int)*(char *)(ppQVar4 + 0x3f3));
    item = cJSON_CreateNumber();
    cJSON_AddItemToObject(object,"rssi",item);
    item = cJSON_CreateString((char *)(pbVar2->ap_item + uVar8));
    cJSON_AddItemToObject(object,"ssid",item);
    __floatunsidf((uint)*(byte *)((int)ppQVar4 + 0xfcb));
    item = cJSON_CreateNumber();
    cJSON_AddItemToObject(object,"auth",item);
    __s = cJSON_Print(object);
    handle = gp_index->pro_handle;
    bytes = strlen(__s);
    pro_trans_layer_ack_read(handle,__s,bytes);
    cJSON_Delete(object);
    goto LAB_2302d470;
  case 0xc:
    paVar10 = (anon_subr_void_wifi_conn_ptr_for_local_connect_remote_ap *)gp_index->complete_cb;
    if (paVar10 == (anon_subr_void_wifi_conn_ptr_for_local_connect_remote_ap *)0x0) {
      return 0;
    }
    pcVar6 = (code *)gp_index->p_arg;
    break;
  case 0xd:
    paVar12 = gp_index->wifi_func->local_wifi_state_get;
    if (paVar12 == (anon_subr_void_anon_subr_void_void_ptr_ptr_for_local_wifi_state_get *)0x0) {
      return 0;
    }
    (*paVar12)(wifi_state_get_cb);
    BVar7 = xQueueSemaphoreTake((QueueHandle_t)gp_index->xSemaphore,10000);
    if (BVar7 != 1) {
      return 2;
    }
    sprintf((char *)&uStack52,"%02X:%02X:%02X:%02X:%02X:%02X",(uint)(gp_index->state).bssid[0],
            (uint)(gp_index->state).bssid[1],(uint)(gp_index->state).bssid[2],
            (uint)(gp_index->state).bssid[3],(uint)(gp_index->state).bssid[4],
            (uint)(gp_index->state).bssid[5]);
    object = cJSON_CreateObject();
    __floatunsidf((uint)(gp_index->state).state);
    item = cJSON_CreateNumber();
    cJSON_AddItemToObject(object,"state",item);
    item = cJSON_CreateString((char *)&gp_index->state);
    cJSON_AddItemToObject(object,"ip",item);
    item = cJSON_CreateString((gp_index->state).gw);
    cJSON_AddItemToObject(object,"gw",item);
    item = cJSON_CreateString((gp_index->state).mask);
    cJSON_AddItemToObject(object,"mask",item);
    item = cJSON_CreateString((gp_index->state).ssid);
    cJSON_AddItemToObject(object,"ssid",item);
    item = cJSON_CreateString((char *)&uStack52);
    cJSON_AddItemToObject(object,"bssid",item);
    __s = cJSON_Print(object);
    handle = gp_index->pro_handle;
    bytes = strlen(__s);
    pro_trans_layer_ack_read(handle,__s,bytes);
    cJSON_Delete(object);
LAB_2302d470:
    vPortFree(__s);
    return 0;
  }
  (*paVar10)(pcVar6);
  return 0;
}



void wifi_state_get_cb(void *p_arg)

{
  bl_ble_sync_t *pbVar1;
  
  pbVar1 = gp_index;
  memcpy(&gp_index->state,p_arg,0x58);
  xQueueGenericSend((QueueHandle_t)pbVar1->xSemaphore,(void *)0x0,0,0);
  return;
}



size_t write_data(bt_conn *param_1,uint8_t *param_2,size_t param_3)

{
  bl_ble_sync_t *pbVar1;
  blog_level_t bVar2;
  TickType_t TVar3;
  
  bVar2 = _fsymc_level_blsync_ble;
  gp_index->p_cur_conn = param_1;
  if ((bVar2 < BLOG_LEVEL_WARN) && (_fsymf_level_blsync_bleblsync_ble < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] write length %d\r\n",TVar3,&DAT_2306e4ac,"blsync_ble.c",0x7c,
              param_3);
    if ((_fsymc_level_blsync_ble < BLOG_LEVEL_WARN) &&
       (_fsymf_level_blsync_bleblsync_ble < BLOG_LEVEL_WARN)) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] %s:\r\n",TVar3,&DAT_2306e4ac,"blsync_ble.c",0x7d,&DAT_23077518);
      blog_hexdump_out("data",'\x10',param_2,(uint16_t)param_3);
    }
  }
  pbVar1 = gp_index;
  (gp_index->send_buf).len = param_3;
  memcpy(&pbVar1->send_buf,param_2,param_3);
  xQueueGenericSend(gp_index->xQueue1,&gp_index->send_buf,0,0);
  return param_3;
}



undefined4 __ble_bytes_send(uint8_t *param_1,uint param_2)

{
  blog_level_t bVar1;
  undefined4 uVar2;
  TickType_t TVar3;
  
  uVar2 = 0xffffffff;
  if ((gp_index->p_cur_conn != (bt_conn *)0x0) && (param_2 < 0x100)) {
    memcpy(gp_index->attr_read_buf,param_1,param_2);
    bVar1 = _fsymc_level_blsync_ble;
    gp_index->rbuf_len = (uint16_t)param_2;
    if ((bVar1 < BLOG_LEVEL_WARN) && (_fsymf_level_blsync_bleblsync_ble < BLOG_LEVEL_WARN)) {
      if (TrapNetCounter == 0) {
        xTaskGetTickCount();
      }
      else {
        xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d]  ble send size %d\r\n",&DAT_2306e4ac,"blsync_ble.c",0x91,param_2
               );
      if ((_fsymc_level_blsync_ble < BLOG_LEVEL_WARN) &&
         (_fsymf_level_blsync_bleblsync_ble < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] %s:\r\n",TVar3,&DAT_2306e4ac,"blsync_ble.c",0x93,&DAT_23077518
                 );
        blog_hexdump_out("data",'\x10',param_1,(uint16_t)param_2);
      }
    }
    printf("\r\n");
    uVar2 = 0;
  }
  return uVar2;
}



void blsync_disconnected(bt_conn *conn,u8_t reason)

{
  printf("disconnected (reason %u)%s\r\n");
  blsync_conn = (bt_conn *)0x0;
  return;
}



void blsync_exchange_func(bt_conn *conn,u8_t err,bt_gatt_exchange_params *params)

{
  undefined3 in_register_0000202d;
  char *pcVar1;
  
  if (CONCAT31(in_register_0000202d,err) == 0) {
    pcVar1 = "successful";
  }
  else {
    pcVar1 = "failed";
  }
  printf("Exchange %s\r\n",pcVar1);
  return;
}



ssize_t read_data(bt_conn *conn,bt_gatt_attr *attr,void *buf,u16_t len,u16_t offset)

{
  TickType_t TVar1;
  ssize_t sVar2;
  
  if (gp_index->rbuf_len == 0) {
    sVar2 = -4;
  }
  else {
    if ((_fsymc_level_blsync_ble < BLOG_LEVEL_WARN) &&
       (_fsymf_level_blsync_bleblsync_ble < BLOG_LEVEL_WARN)) {
      if (TrapNetCounter == 0) {
        TVar1 = xTaskGetTickCount();
      }
      else {
        TVar1 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] read length %d\r\n",TVar1,&DAT_2306e4ac,"blsync_ble.c",0x6d,
                (uint)gp_index->rbuf_len);
    }
    pro_trans_ack(gp_index->pro_handle);
    sVar2 = bt_gatt_attr_read(conn,attr,buf,len,offset,gp_index->attr_read_buf,gp_index->rbuf_len);
    gp_index->rbuf_len = 0;
  }
  return sVar2;
}



void blsync_connected(bt_conn *conn,u8_t err)

{
  char "blsync_connected" [17];
  int iVar1;
  
  printf("%s\n","blsync_connected");
  blsync_conn = conn;
  iVar1 = bt_le_set_data_len(conn,0xfb,0x848);
  if (iVar1 == 0) {
    printf("Set data length success.\n");
  }
  else {
    printf("Set data length failure, err: %d\n",iVar1);
  }
  blsync_exchg_mtu.func = blsync_exchange_func;
  iVar1 = bt_gatt_exchange_mtu(blsync_conn,&blsync_exchg_mtu);
  if (iVar1 == 0) {
    printf("Exchange mtu size pending.\n",0);
    return;
  }
  printf("Exchange mtu size failure, err: %d\n",iVar1);
  return;
}



int bl_ble_sync_start(bl_ble_sync_t *index,blesync_wifi_func *func,pfn_complete_cb_t *cb,
                     void *cb_arg)

{
  uint uVar1;
  int iVar2;
  TickType_t TVar3;
  TaskHandle_t ptVar4;
  
  if ((index == (bl_ble_sync_t *)0x0) || (func == (blesync_wifi_func *)0x0)) {
    iVar2 = -1;
    if ((_fsymc_level_blsync_ble < BLOG_LEVEL_WARN) &&
       (_fsymf_level_blsync_bleblsync_ble < BLOG_LEVEL_WARN)) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] ble sync init failed\r\n",TVar3,&DAT_2306e4ac,"blsync_ble.c",
                0x16d);
      iVar2 = -1;
    }
  }
  else {
    memset(index,0,0x1908);
    uVar1 = isRegister;
    gp_index = index;
    index->wifi_func = func;
    index->complete_cb = cb;
    index->p_arg = cb_arg;
    *(undefined2 *)&index->task_runing = 0;
    index->stop_flag = '\0';
    if (uVar1 == 0) {
      isRegister = 1;
      bt_conn_cb_register(&blsync_conn_callbacks);
    }
    bt_gatt_service_register(&wifiprov_server);
    ptVar4 = xTaskCreateStatic(__bl_ble_sync_task,"pro",0x200,index,10,index->stack,&index->task);
    index->task_handle = ptVar4;
    iVar2 = 0;
  }
  return iVar2;
}



int bl_ble_sync_stop(bl_ble_sync_t *index)

{
  TaskHandle_t ptVar1;
  
  if (index == (bl_ble_sync_t *)0x0) {
    return -1;
  }
  bt_gatt_service_unregister(&wifiprov_server);
  index->stop_flag = '\x01';
  ptVar1 = xTaskGetCurrentTaskHandle();
  if (gp_index->task_handle == ptVar1) {
    while (gp_index->scaning == '\x01') {
      vTaskDelay(10);
    }
    vTaskDelete(index->task_handle);
  }
  else {
    while ((gp_index->scaning == '\x01' || (index->task_runing == '\x01'))) {
      vTaskDelay(10);
    }
  }
  return 0;
}



void * __malloc(size_t size)

{
  void *pvVar1;
  TickType_t TVar2;
  
  pvVar1 = pvPortMalloc(size);
  if (((pvVar1 != (void *)0x0) && (_fsymc_level_blsync_ble < BLOG_LEVEL_WARN)) &&
     (_fsymf_level_blsync_bletransfer < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] malloc %p\r\n",TVar2,&DAT_2306e4ac,"transfer.c",0x1e,pvVar1);
  }
  return pvVar1;
}



void __free(void *ptr)

{
  TickType_t TVar1;
  
  if (((ptr != (void *)0x0) && (_fsymc_level_blsync_ble < BLOG_LEVEL_WARN)) &&
     (_fsymf_level_blsync_bletransfer < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] free %p\r\n",TVar1,&DAT_2306e4ac,"transfer.c",0x14,ptr);
  }
  vPortFree(ptr);
  return;
}



void __clear_dev(pro_handle_t handle)

{
  *(undefined4 *)&handle->tol_len_now = 0;
  __free(handle->pyld_buf);
  handle->pyld_buf = (uint8_t *)0x0;
  return;
}



// WARNING: Could not reconcile some variable overlaps

int __protocol_send(pro_handle_t handle,uint8_t seq,uint8_t ack,uint8_t type,void *p_data,
                   uint16_t length)

{
  ushort uVar1;
  bool bVar2;
  void *__dest;
  BaseType_t BVar3;
  undefined3 in_register_00002031;
  undefined2 in_register_0000203e;
  uint uVar4;
  int iVar5;
  uint uVar6;
  char *pcVar7;
  char cVar8;
  uint uVar9;
  byte bStack69;
  byte bStack68;
  uint8_t uStack67;
  uint8_t dst_len;
  ushort uStack66;
  general_head head;
  
  uVar4 = CONCAT22(in_register_0000203e,length);
  bStack68 = 0;
  uStack66 = 0;
  if (CONCAT31(in_register_00002031,ack) != 0) {
    bStack68 = 8;
  }
  uVar6 = 0xfffffffd;
  bStack68 = bStack68 | 0x10;
  uStack67 = seq;
  __dest = __malloc((uint)handle->mtu);
  if (__dest != (void *)0x0) {
    uVar9 = 0;
    do {
      bStack69 = 4;
      uVar1 = handle->mtu;
      if (uVar9 == 0) {
        *(char *)((int)__dest + 4) = (char)length;
        iVar5 = (uint)uVar1 - 6;
        *(undefined *)((int)__dest + 5) = (char)(length >> 8);
        bStack69 = 6;
        handle->enc_handle->is_head = '\x01';
        cVar8 = '\x06';
        pcVar7 = (char *)((int)__dest + 6);
      }
      else {
        iVar5 = (uint)uVar1 - 4;
        cVar8 = '\x04';
        pcVar7 = (char *)((int)__dest + 4);
      }
      bStack69 = bStack69 + 1;
      uVar6 = (*handle->enc_handle->pfnc->pfn_enc_write)
                        (handle->enc_handle->p_drv,'\x01',type,(uint8_t *)(pcVar7 + 1),&bStack69,
                         (uint8_t *)((int)p_data + uVar9),(char)length - (char)uVar9,
                         (int16_t)((uint)(((iVar5 * 0x10000 >> 0x10) + -1) * 0x10000) >> 0x10));
      handle->enc_handle->is_head = '\0';
      if ((int)uVar6 < 0) break;
      uVar9 = uVar9 + (uVar6 & 0xff) & 0xffff;
      if (uVar9 < uVar4) {
        bVar2 = false;
      }
      else {
        if (uVar4 != uVar9) {
          uVar6 = 0xfffffffe;
          break;
        }
        uStack66 = uStack66 | 0x8000;
        bVar2 = true;
      }
      if ((uVar6 & 0xff) < uVar4) {
        bStack68 = bStack68 | 2;
      }
      memcpy(__dest,&bStack68,2);
      *(undefined *)((int)__dest + 2) = (char)uStack66;
      *(undefined *)((int)__dest + 3) = (char)(uStack66 >> 8);
      *pcVar7 = (bStack69 - 1) - cVar8;
      (*handle->p_func->pfu_bytes_send)((void *)0x0,__dest,(uint)bStack69);
      uStack67 = uStack67 + '\x01';
      uStack66 = uStack66 + 1;
      BVar3 = xQueueSemaphoreTake((QueueHandle_t)handle->xSemaphore,10000);
      if (BVar3 != 1) {
        uVar6 = 0xfffffffc;
        break;
      }
    } while (!bVar2);
    __free(__dest);
  }
  return uVar6;
}



// WARNING: Could not reconcile some variable overlaps

int pro_trans_read(pro_handle_t handle,void *buf,size_t bytes,uint16_t mtu)

{
  uint8_t uVar1;
  uint8_t *puVar2;
  TickType_t TVar3;
  uint8_t *puVar4;
  uint uVar5;
  int iVar6;
  size_t sVar7;
  int iVar8;
  event_type_t eVar9;
  byte local_36;
  uint8_t uStack53;
  byte bStack52;
  uint8_t uStack51;
  uint8_t dst_len;
  uint8_t ev_id;
  general_head head;
  pro_event ev;
  
  if (handle == (pro_handle_t)0x0) {
    return -2;
  }
  if (buf == (void *)0x0) {
    return -2;
  }
  handle->mtu = mtu;
  memcpy(&bStack52,buf,2);
  uVar1 = uStack51;
  if ((bStack52 & 1) != 0) {
    if (handle->old_seq != uStack51) {
      TVar3 = xTaskGetTickCount();
      *(TickType_t *)&handle->seq_start_ms = TVar3;
      *(undefined4 *)((int)&handle->seq_start_ms + 4) = 0;
      handle->old_seq = uVar1;
    }
    if ((*(uint *)&handle->seq_start_ms | *(uint *)((int)&handle->seq_start_ms + 4)) != 0) {
      TVar3 = xTaskGetTickCount();
      iVar6 = *(int *)((int)&handle->seq_start_ms + 4);
      uVar5 = TVar3 - *(int *)&handle->seq_start_ms;
      iVar8 = -(uint)(TVar3 < uVar5);
      if ((0 < iVar8 - iVar6) || ((iVar8 == iVar6 && (10000 < uVar5)))) {
        __clear_dev(handle);
        if (BLOG_LEVEL_INFO < _fsymc_level_blsync_ble) {
          return -4;
        }
        if (BLOG_LEVEL_INFO < _fsymf_level_blsync_bletransfer) {
          return -4;
        }
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] -----------timeout-----------\r\n",TVar3,&DAT_2306e4ac,
                  "transfer.c",0x145);
        return -4;
      }
    }
  }
  _dst_len = *(ushort *)((int)buf + 2);
  eVar9 = bStack52 >> 4 & 3;
  sVar7 = (size_t)*(byte *)((int)buf + 4);
  if ((_dst_len & 0x7fff) == 0) {
    puVar2 = (uint8_t *)((int)buf + 7);
    handle->total_length = CONCAT11(*(undefined *)((int)buf + 5),*(byte *)((int)buf + 4));
    sVar7 = (size_t)*(byte *)((int)buf + 6);
    if (bytes - 4 == sVar7 + 3) {
      if (handle->pyld_buf != (uint8_t *)0x0) {
        __clear_dev(handle);
      }
      if (handle->total_length == 0) {
LAB_2302df24:
        handle->enc_handle->is_head = '\x01';
        goto LAB_2302df2c;
      }
      puVar4 = (uint8_t *)__malloc((uint)handle->total_length);
      handle->pyld_buf = puVar4;
      if (puVar4 != (uint8_t *)0x0) goto LAB_2302df24;
LAB_2302df62:
      iVar8 = -3;
      goto __end;
    }
LAB_2302df10:
    iVar8 = -2;
  }
  else {
    puVar2 = (uint8_t *)((int)buf + 5);
    if (bytes - 4 != sVar7 + 1) goto LAB_2302df10;
    handle->enc_handle->is_head = '\0';
LAB_2302df2c:
    iVar8 = (*handle->enc_handle->pfnc->pfn_enc_read)
                      (handle->enc_handle->p_drv,eVar9,&uStack53,
                       handle->pyld_buf + handle->tol_len_now,&local_36,puVar2,sVar7);
    if (iVar8 == 0) {
      uVar5 = (uint)handle->tol_len_now + (uint)local_36;
      handle->tol_len_now = (uint16_t)(uVar5 * 0x10000 >> 0x10);
      if (((bStack52 & 2) != 0) && (-1 < (short)_dst_len)) goto __end;
      if ((uint)handle->total_length != (uVar5 & 0xffff)) {
        __clear_dev(handle);
        goto LAB_2302df10;
      }
      head.ctrl = eVar9;
      if (handle->p_func->pfn_recv_event !=
          (anon_subr_int_void_ptr_pro_event_ptr_for_pfn_recv_event *)0x0) {
        puVar2 = (uint8_t *)__malloc(0x100);
        handle->ack_buf = puVar2;
        if (puVar2 == (uint8_t *)0x0) goto LAB_2302df62;
        iVar8 = (*handle->p_func->pfn_recv_event)(handle->p_drv,(pro_event *)&head);
      }
    }
    __clear_dev(handle);
  }
__end:
  if ((bStack52 >> 3 & 1) == 0) {
    __protocol_send(handle,uStack51,'\x01',(uint8_t)iVar8,handle->ack_buf,
                    (ushort)*(byte *)&handle->ack_len);
  }
  handle->ack_len = 0;
  __free(handle->ack_buf);
  handle->ack_buf = (uint8_t *)0x0;
  return iVar8;
}



int pro_trans_ack(pro_handle_t handle)

{
  BaseType_t BVar1;
  int iVar2;
  
  BVar1 = xQueueGenericSend((QueueHandle_t)handle->xSemaphore,(void *)0x0,0,0);
  if (BVar1 == 1) {
    iVar2 = 0;
  }
  else {
    iVar2 = 2;
  }
  return iVar2;
}



int pro_trans_layer_ack_read(pro_handle_t handle,void *ack_buf,size_t bytes)

{
  int iVar1;
  
  if ((handle != (pro_handle_t)0x0) && (iVar1 = -2, ack_buf != (void *)0x0)) {
    if (bytes < 0x101) {
      iVar1 = -3;
      if (handle->ack_buf != (uint8_t *)0x0) {
        memcpy(handle->ack_buf,ack_buf,bytes);
        iVar1 = 0;
        handle->ack_len = (uint16_t)bytes;
      }
    }
    return iVar1;
  }
  return -2;
}



pro_handle_t pro_trans_init(pro_dev *p_dev,pro_func *p_func,void *p_drv)

{
  enc_handle_t peVar1;
  QueueHandle_t pQVar2;
  
  memset(p_dev,0,0xb0);
  peVar1 = pro_encrypt_init(&p_dev->enc,&p_dev->enc);
  p_dev->enc_handle = peVar1;
  p_dev->p_func = p_func;
  p_dev->p_drv = p_drv;
  pQVar2 = xQueueGenericCreateStatic
                     (1,0,(uint8_t *)0x0,(StaticQueue_t *)&p_dev->xSemaphoreBuffer,'\x03');
  *(QueueHandle_t *)&p_dev->xSemaphore = pQVar2;
  return (pro_handle_t)p_dev;
}



void pro_trans_reset(pro_handle_t handle)

{
  *(undefined4 *)&handle->tol_len_now = 0;
  __free(handle->pyld_buf);
  handle->pyld_buf = (uint8_t *)0x0;
  return;
}



int __pack_encrypt_read(void *p_drv,uint8_t pack_type,uint8_t *dst_id,uint8_t *dst_buf,
                       uint8_t *dst_len,uint8_t *src_buf,size_t src_lenght)

{
  int iVar1;
  undefined3 in_register_0000202d;
  uint uVar2;
  
  if (*(char *)((int)p_drv + 0x10) == '\0') {
    src_buf = src_buf + 1;
    uVar2 = src_lenght - 1;
  }
  else {
    src_buf = src_buf + 9;
    uVar2 = src_lenght - 9;
  }
  *(bool *)((int)p_drv + 0xc) = CONCAT31(in_register_0000202d,pack_type) != 0;
                    // WARNING: Could not recover jumptable at 0x2302e0e6. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (**(code **)**(code ***)p_drv)((*(code ***)p_drv)[1],dst_buf,dst_len,src_buf,uVar2 & 0xff)
  ;
  return iVar1;
}



int __pack_encrypt_write
              (void *p_drv,uint8_t pack_type,uint8_t src_id,uint8_t *dst_buf,uint8_t *dst_len,
              uint8_t *src_buf,uint8_t src_len,int16_t remain_len)

{
  int iVar1;
  undefined3 in_register_00002031;
  undefined3 in_register_00002041;
  short sVar2;
  
  *dst_buf = '\0';
  if (*(char *)((int)p_drv + 0x10) == '\0') {
    dst_buf = dst_buf + 1;
    sVar2 = remain_len + -1;
    *dst_len = *dst_len + '\x01';
  }
  else {
    dst_buf[1] = '\0';
    dst_buf[2] = '\0';
    dst_buf[3] = '\0';
    dst_buf[4] = '\0';
    dst_buf[5] = '\0';
    dst_buf[6] = '\0';
    dst_buf[7] = '\0';
    dst_buf[8] = '\0';
    dst_buf = dst_buf + 9;
    sVar2 = remain_len + -9;
    *dst_len = *dst_len + '\t';
  }
  *(undefined *)((int)p_drv + 0xc) = 1;
                    // WARNING: Could not recover jumptable at 0x2302e152. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (**(code **)(**(int **)p_drv + 4))
                    ((*(int **)p_drv)[1],dst_buf,CONCAT31(in_register_00002031,src_id),src_buf,
                     CONCAT31(in_register_00002041,src_len),(int)sVar2);
  return iVar1;
}



enc_handle_t pro_encrypt_init(encrypt *p_enc,void *p_drv)

{
  pyld_handle_t ppVar1;
  
  ppVar1 = pro_payload_init(&p_enc->pyld,&p_enc->pyld);
  p_enc->pyld_handle = ppVar1;
  p_enc->p_drv = p_drv;
  p_enc->pfnc = &__g_enc_func;
  return (enc_handle_t)p_enc;
}



int __payload_write(void *p_arg,uint8_t *dst_buf,uint8_t *dst_len,uint8_t src_id,uint8_t *src_buf,
                   uint8_t src_len,int16_t remain_len)

{
  uint8_t uVar1;
  undefined3 in_register_0000203d;
  uint uVar2;
  short in_register_00002042;
  uint __n;
  
  uVar2 = CONCAT31(in_register_0000203d,src_len);
  if (in_register_00002042 < 0) {
    return -2;
  }
  if (*(char *)((int)p_arg + 8) == '\0') {
    __n = (int)(((uint)(ushort)remain_len - 1) * 0x10000) >> 0x10;
    if ((int)uVar2 < (int)__n) {
      __n = uVar2;
    }
    __n = __n & 0xff;
    if (__n != 4) {
      return -2;
    }
    *dst_buf = src_id;
    memcpy(dst_buf + 1,src_buf,4);
    uVar1 = *dst_len + '\x05';
  }
  else {
    __n = (int)(((uint)(ushort)remain_len - 2) * 0x10000) >> 0x10;
    if ((int)uVar2 < (int)__n) {
      __n = uVar2;
    }
    __n = __n & 0xff;
    *dst_buf = (uint8_t)__n;
    dst_buf[1] = src_id;
    memcpy(dst_buf + 2,src_buf,__n);
    uVar1 = *dst_len + '\x02' + (uint8_t)__n;
  }
  *dst_len = uVar1;
  return __n;
}



int __payload_read(void *p_arg,uint8_t *dst_buf,uint8_t *dst_type,uint8_t *dst_len,uint8_t *src_buf,
                  uint8_t src_len)

{
  byte bVar1;
  uint8_t *__src;
  undefined3 in_register_0000203d;
  uint uVar2;
  
  if (*(char *)((int)p_arg + 8) == '\0') {
    if (CONCAT31(in_register_0000203d,src_len) != 5) {
      return -2;
    }
    *dst_len = '\x04';
    __src = src_buf + 1;
    *dst_type = *src_buf;
    bVar1 = *dst_len;
  }
  else {
    uVar2 = CONCAT31(in_register_0000203d,src_len) - 2;
    if (uVar2 != (uint)*src_buf) {
      return -2;
    }
    *dst_len = (uint8_t)uVar2;
    __src = src_buf + 2;
    *dst_type = src_buf[1];
    bVar1 = *dst_len;
  }
  memcpy(dst_buf,__src,(uint)bVar1);
  return 0;
}



pyld_handle_t pro_payload_init(payload *p_pyld,void *p_drv)

{
  p_pyld->pfnc = (pro_pyld_func *)0x2308277c;
  p_pyld->p_drv = p_drv;
  return (pyld_handle_t)p_pyld;
}



cJSON * cJSON_New_Item(void)

{
  cJSON *__s;
  
  __s = (cJSON *)(*cJSON_malloc)(0x28);
  if (__s != (cJSON *)0x0) {
    memset(__s,0,0x28);
  }
  return __s;
}



char * ensure(printbuffer *p,int needed)

{
  uint uVar1;
  size_t sVar2;
  int iVar3;
  char *__dest;
  
  __dest = (char *)0x0;
  if ((p != (printbuffer *)0x0) && (__dest = p->buffer, __dest != (char *)0x0)) {
    iVar3 = p->offset;
    if (p->length < needed + iVar3) {
      uVar1 = (needed + iVar3) - 1;
      uVar1 = uVar1 | (int)uVar1 >> 1;
      uVar1 = uVar1 | (int)uVar1 >> 2;
      uVar1 = uVar1 | (int)uVar1 >> 4;
      uVar1 = uVar1 | (int)uVar1 >> 8;
      sVar2 = (uVar1 | (int)uVar1 >> 0x10) + 1;
      __dest = (char *)(*cJSON_malloc)(sVar2);
      if (__dest == (char *)0x0) {
        (*cJSON_free)(p->buffer);
        p->length = 0;
        p->buffer = (char *)0x0;
        return (char *)0x0;
      }
      memcpy(__dest,p->buffer,p->length);
      (*cJSON_free)(p->buffer);
      iVar3 = p->offset;
      p->length = sVar2;
      p->buffer = __dest;
    }
    __dest = __dest + iVar3;
  }
  return __dest;
}



char * cJSON_strdup(char *str)

{
  size_t sVar1;
  char *__dest;
  
  sVar1 = strlen(str);
  __dest = (char *)(*cJSON_malloc)(sVar1 + 1);
  if (__dest != (char *)0x0) {
    memcpy(__dest,str,sVar1 + 1);
  }
  return __dest;
}



int update(printbuffer *p)

{
  int iVar1;
  size_t sVar2;
  
  iVar1 = 0;
  if (p != (printbuffer *)0x0) {
    iVar1 = 0;
    if (p->buffer != (char *)0x0) {
      iVar1 = p->offset;
      sVar2 = strlen(p->buffer + iVar1);
      iVar1 = iVar1 + sVar2;
    }
  }
  return iVar1;
}



char * print_number(cJSON *item,printbuffer *p)

{
  __gcc_CMPtype _Var1;
  char *buffer;
  char *extraout_a0;
  char *format;
  undefined4 uVar2;
  undefined4 uVar3;
  double in_fa1;
  
  uVar3 = *(undefined4 *)((int)&item->valuedouble + 4);
  uVar2 = *(undefined4 *)&item->valuedouble;
  _Var1 = __eqdf2();
  if (_Var1 == 0) {
    if (p == (printbuffer *)0x0) {
      buffer = (char *)(*cJSON_malloc)(2);
    }
    else {
      buffer = ensure(p,2);
    }
    if (buffer == (char *)0x0) {
      return (char *)0x0;
    }
    strcpy(buffer,"0");
    return buffer;
  }
  __floatsidf(item->valueint);
  __subdf3();
  fabs(in_fa1);
  _Var1 = __ledf2();
  if (((_Var1 < 1) && (_Var1 = __ledf2(), _Var1 < 1)) && (_Var1 = __gedf2(), -1 < _Var1)) {
    if (p == (printbuffer *)0x0) {
      buffer = (char *)(*cJSON_malloc)(0x15);
    }
    else {
      buffer = ensure(p,0x15);
    }
    if (buffer == (char *)0x0) {
      return (char *)0x0;
    }
    sprintf(buffer,"%d",item->valueint);
    return buffer;
  }
  if (p == (printbuffer *)0x0) {
    in_fa1 = (double)(*cJSON_malloc)(0x40);
    buffer = extraout_a0;
  }
  else {
    buffer = ensure(p,0x40);
  }
  if (buffer == (char *)0x0) {
    return (char *)0x0;
  }
  floor(in_fa1);
  __subdf3();
  fabs(in_fa1);
  _Var1 = __ledf2();
  if (_Var1 < 1) {
    fabs(in_fa1);
    _Var1 = __ledf2();
    if (_Var1 < 0) {
      format = "%.0f";
      goto LAB_2302e4f2;
    }
  }
  fabs(in_fa1);
  _Var1 = __ledf2();
  if (-1 < _Var1) {
    fabs(in_fa1);
    _Var1 = __gedf2();
    if (_Var1 < 1) {
      format = "%f";
      goto LAB_2302e4f2;
    }
  }
  format = "%e";
LAB_2302e4f2:
  sprintf(buffer,format,uVar2,uVar3);
  return buffer;
}



char * print_string_ptr(char *str,printbuffer *p)

{
  char cVar1;
  int iVar2;
  char *pcVar3;
  bool bVar4;
  bool bVar5;
  byte bVar6;
  byte *pbVar7;
  char *__dest;
  byte *pbVar8;
  
  bVar5 = false;
  __dest = str;
  while (cVar1 = *__dest, cVar1 != '\0') {
    bVar4 = true;
    if ((0x1e < (byte)(cVar1 - 1U)) && (cVar1 != '\"')) {
      bVar4 = cVar1 == '\\';
    }
    bVar5 = (bool)(bVar5 | bVar4);
    __dest = __dest + 1;
  }
  if (bVar5) {
    if (str == (char *)0x0) {
      if (p == (printbuffer *)0x0) {
        __dest = (char *)(*cJSON_malloc)(3);
      }
      else {
        __dest = ensure(p,3);
      }
      if (__dest == (char *)0x0) {
        return (char *)0x0;
      }
      strcpy(__dest,"\"\"");
      return __dest;
    }
    iVar2 = 0;
    pbVar8 = (byte *)str;
    while( true ) {
      bVar6 = *pbVar8;
      if (bVar6 == 0) break;
      __dest = strchr("\"\\\b\f\n\r\t",(uint)bVar6);
      if (__dest == (char *)0x0) {
        if (bVar6 < 0x20) {
          iVar2 = iVar2 + 6;
        }
        else {
          iVar2 = iVar2 + 1;
        }
      }
      else {
        iVar2 = iVar2 + 2;
      }
      pbVar8 = pbVar8 + 1;
    }
    if (p == (printbuffer *)0x0) {
      pcVar3 = (char *)(*cJSON_malloc)(iVar2 + 3U);
    }
    else {
      pcVar3 = ensure(p,iVar2 + 3U);
    }
    if (pcVar3 == (char *)0x0) {
      return (char *)0x0;
    }
    *pcVar3 = '\"';
    pbVar8 = (byte *)(pcVar3 + 1);
    while (bVar6 = *str, bVar6 != 0) {
      pbVar7 = (byte *)str + 1;
      if (((bVar6 < 0x20) || (bVar6 == 0x22)) || (bVar6 == 0x5c)) {
        *pbVar8 = 0x5c;
        bVar6 = *str;
        if (bVar6 == 0xc) {
          pbVar8[1] = 0x66;
          pbVar8 = pbVar8 + 2;
          str = (char *)pbVar7;
        }
        else {
          if (bVar6 < 0xd) {
            if (bVar6 == 9) {
              bVar6 = 0x74;
            }
            else {
              if (bVar6 == 10) {
                bVar6 = 0x6e;
              }
              else {
                if (bVar6 != 8) goto LAB_2302e750;
                bVar6 = 0x62;
              }
            }
            pbVar8[1] = bVar6;
            pbVar8 = pbVar8 + 2;
            str = (char *)pbVar7;
          }
          else {
            if (bVar6 == 0x22) {
              pbVar8[1] = 0x22;
              pbVar8 = pbVar8 + 2;
              str = (char *)pbVar7;
            }
            else {
              if (bVar6 == 0x5c) {
                pbVar8[1] = 0x5c;
                pbVar8 = pbVar8 + 2;
                str = (char *)pbVar7;
              }
              else {
                if (bVar6 == 0xd) {
                  pbVar8[1] = 0x72;
                  pbVar8 = pbVar8 + 2;
                  str = (char *)pbVar7;
                }
                else {
LAB_2302e750:
                  sprintf((char *)(pbVar8 + 1),"u%04x");
                  pbVar8 = pbVar8 + 6;
                  str = (char *)pbVar7;
                }
              }
            }
          }
        }
      }
      else {
        *pbVar8 = bVar6;
        pbVar8 = pbVar8 + 1;
        str = (char *)pbVar7;
      }
    }
    *pbVar8 = 0x22;
  }
  else {
    __dest = __dest + -(int)str;
    if (p == (printbuffer *)0x0) {
      pcVar3 = (char *)(*cJSON_malloc)((size_t)(__dest + 3));
    }
    else {
      pcVar3 = ensure(p,(int)(__dest + 3));
    }
    if (pcVar3 == (char *)0x0) {
      return (char *)0x0;
    }
    *pcVar3 = '\"';
    pbVar8 = (byte *)(pcVar3 + 1 + (int)__dest);
    strcpy(pcVar3 + 1,str);
    *pbVar8 = 0x22;
  }
  pbVar8[1] = 0;
  return pcVar3;
}



char * print_array(int depth,int fmt,printbuffer *p)

{
  undefined4 *__dest;
  size_t sVar1;
  undefined *__dest_00;
  char *__s;
  int iVar2;
  char **__s_00;
  size_t __n;
  printbuffer *in_a3;
  char *pcVar3;
  cJSON *item;
  int iVar4;
  char **ppcVar5;
  
  __dest = *(undefined4 **)depth;
  iVar4 = 0;
  while (__dest != (undefined4 *)0x0) {
    iVar4 = iVar4 + 1;
    __dest = (undefined4 *)*__dest;
  }
  if (iVar4 == 0) {
    if (in_a3 == (printbuffer *)0x0) {
      __dest = (undefined4 *)(*cJSON_malloc)(3);
    }
    else {
      __dest = (undefined4 *)ensure(in_a3,3);
    }
    if (__dest != (undefined4 *)0x0) {
      strcpy((char *)__dest,"[]");
    }
  }
  else {
    if (in_a3 == (printbuffer *)0x0) {
      __s_00 = (char **)(*cJSON_malloc)(iVar4 << 2);
      if (__s_00 != (char **)0x0) {
        memset(__s_00,0,iVar4 << 2);
        item = *(cJSON **)depth;
        iVar2 = 0;
        sVar1 = 5;
        ppcVar5 = __s_00;
        while (item != (cJSON *)0x0) {
          if (iVar2 != 0) goto LAB_2302e8b4;
          __s = print_value(item,fmt + 1,(int)p,(printbuffer *)0x0);
          *ppcVar5 = __s;
          if (__s == (char *)0x0) {
            iVar2 = 1;
          }
          else {
            __n = strlen(__s);
            sVar1 = sVar1 + (uint)(p != (printbuffer *)0x0) + 2 + __n;
          }
          item = item->next;
          ppcVar5 = ppcVar5 + 1;
        }
        if ((iVar2 == 0) &&
           (__dest = (undefined4 *)(*cJSON_malloc)(sVar1), __dest != (undefined4 *)0x0)) {
          *(undefined *)__dest = 0x5b;
          __dest_00 = (undefined *)((int)__dest + 1);
          *(undefined *)((int)__dest + 1) = 0;
          ppcVar5 = __s_00;
          do {
            __n = strlen(*ppcVar5);
            memcpy(__dest_00,*ppcVar5,__n);
            __dest_00 = __dest_00 + __n;
            if (iVar4 + -1 != iVar2) {
              *__dest_00 = 0x2c;
              if (p == (printbuffer *)0x0) {
                __dest_00 = __dest_00 + 1;
              }
              else {
                __dest_00[1] = 0x20;
                __dest_00 = __dest_00 + 2;
              }
              *__dest_00 = 0;
            }
            __s = *ppcVar5;
            iVar2 = iVar2 + 1;
            ppcVar5 = ppcVar5 + 1;
            (*cJSON_free)(__s);
          } while (iVar4 != iVar2);
          (*cJSON_free)(__s_00);
          *__dest_00 = 0x5d;
          __dest_00[1] = 0;
        }
        else {
LAB_2302e8b4:
          iVar2 = 0;
          do {
            if (__s_00[iVar2] != (char *)0x0) {
              (*cJSON_free)(__s_00[iVar2]);
            }
            iVar2 = iVar2 + 1;
          } while (iVar4 != iVar2);
          __dest = (undefined4 *)0x0;
          (*cJSON_free)(__s_00);
        }
      }
    }
    else {
      iVar4 = in_a3->offset;
      __s = ensure(in_a3,1);
      if (__s != (char *)0x0) {
        *__s = '[';
        in_a3->offset = in_a3->offset + 1;
        item = *(cJSON **)depth;
        while (item != (cJSON *)0x0) {
          print_value(item,fmt + 1,(int)p,in_a3);
          iVar2 = update(in_a3);
          in_a3->offset = iVar2;
          if (item->next != (cJSON *)0x0) {
            __s = ensure(in_a3,(uint)(p != (printbuffer *)0x0) + 2);
            if (__s == (char *)0x0) {
              return (char *)0x0;
            }
            *__s = ',';
            pcVar3 = __s + 1;
            if (p != (printbuffer *)0x0) {
              pcVar3 = __s + 2;
              __s[1] = ' ';
            }
            *pcVar3 = '\0';
            in_a3->offset = in_a3->offset + (uint)(p != (printbuffer *)0x0) + 1;
          }
          item = item->next;
        }
        __s = ensure(in_a3,2);
        if (__s != (char *)0x0) {
          *__s = ']';
          __s[1] = '\0';
          __dest = (undefined4 *)(in_a3->buffer + iVar4);
        }
      }
    }
  }
  return (char *)__dest;
}



char * print_value(cJSON *item,int depth,int fmt,printbuffer *p)

{
  char *str;
  char *__src;
  
  if (item == (cJSON *)0x0) {
    return (char *)0x0;
  }
  if (p != (printbuffer *)0x0) {
    switch(*(undefined *)&item->type) {
    case 0:
      str = ensure(p,6);
      if (str == (char *)0x0) {
        return (char *)0x0;
      }
      __src = "false";
      break;
    case 1:
      str = ensure(p,5);
      if (str == (char *)0x0) {
        return (char *)0x0;
      }
      __src = "true";
      break;
    case 2:
      str = ensure(p,5);
      if (str == (char *)0x0) {
        return (char *)0x0;
      }
      __src = "null";
      break;
    case 3:
LAB_2302ea06:
      str = print_number(item,p);
      return str;
    case 4:
LAB_2302ea14:
      str = print_string_ptr(item->valuestring,p);
      return str;
    case 5:
switchD_2302e9b4_caseD_5:
      str = print_array((int)&item->child,depth,(printbuffer *)fmt);
      return str;
    case 6:
switchD_2302e9b4_caseD_6:
      str = print_object((int)&item->child,depth,(printbuffer *)fmt);
      return str;
    default:
LAB_2302e9ce:
      return (char *)0x0;
    }
    strcpy(str,__src);
    return str;
  }
  switch(*(undefined *)&item->type) {
  case 0:
    str = "false";
    break;
  case 1:
    str = "true";
    break;
  case 2:
    str = "null";
    break;
  case 3:
    p = (printbuffer *)0x0;
    goto LAB_2302ea06;
  case 4:
    p = (printbuffer *)0x0;
    goto LAB_2302ea14;
  case 5:
    goto switchD_2302e9b4_caseD_5;
  case 6:
    goto switchD_2302e9b4_caseD_6;
  default:
    goto LAB_2302e9ce;
  }
  str = cJSON_strdup(str);
  return str;
}



char * print_object(int depth,int fmt,printbuffer *p)

{
  size_t sVar1;
  char *__s;
  size_t sVar2;
  char **__s_00;
  char **__s_01;
  size_t sVar3;
  char *__dest;
  printbuffer *in_a3;
  int *piVar4;
  char *__s_02;
  int iVar5;
  char **ppcVar6;
  int needed;
  int needed_00;
  int needed_01;
  char **ppcVar7;
  size_t __n;
  cJSON *item;
  char **ppcStack88;
  
  piVar4 = *(int **)depth;
  needed_00 = 0;
  while (piVar4 != (int *)0x0) {
    needed_00 = needed_00 + 1;
    piVar4 = (int *)*piVar4;
  }
  if (needed_00 == 0) {
    if (in_a3 == (printbuffer *)0x0) {
      sVar2 = 3;
      if (p != (printbuffer *)0x0) {
        sVar2 = fmt + 4;
      }
      __s = (char *)(*cJSON_malloc)(sVar2);
    }
    else {
      needed_00 = 3;
      if (p != (printbuffer *)0x0) {
        needed_00 = fmt + 4;
      }
      __s = ensure(in_a3,needed_00);
    }
    if (__s != (char *)0x0) {
      *__s = '{';
      __s_02 = __s + 1;
      if (p != (printbuffer *)0x0) {
        __s[1] = '\n';
        __s_02 = __s + 2;
        while ((int)(__s_02 + (-2 - (int)__s)) < fmt + -1) {
          *__s_02 = '\t';
          __s_02 = __s_02 + 1;
        }
      }
      *__s_02 = '}';
      __s_02[1] = '\0';
      return __s;
    }
  }
  else {
    if (in_a3 == (printbuffer *)0x0) {
      __n = needed_00 << 2;
      __s_00 = (char **)(*cJSON_malloc)(__n);
      if (__s_00 != (char **)0x0) {
        __s_01 = (char **)(*cJSON_malloc)(__n);
        if (__s_01 != (char **)0x0) {
          memset(__s_00,0,__n);
          memset(__s_01,0,__n);
          item = *(cJSON **)depth;
          if (p == (printbuffer *)0x0) {
            sVar2 = 7;
            needed = 0;
          }
          else {
            sVar2 = fmt + 8;
            needed = fmt + 3;
          }
          needed_01 = 0;
          ppcVar6 = __s_00;
          ppcStack88 = __s_01;
          while (item != (cJSON *)0x0) {
            __s = print_string_ptr(item->string,(printbuffer *)0x0);
            *ppcStack88 = __s;
            __s_02 = print_value(item,fmt + 1,(int)p,(printbuffer *)0x0);
            *ppcVar6 = __s_02;
            if ((__s == (char *)0x0) || (__s_02 == (char *)0x0)) {
              needed_01 = 1;
            }
            else {
              sVar1 = strlen(__s_02);
              sVar3 = strlen(__s);
              sVar2 = needed + 2 + sVar2 + sVar1 + sVar3;
            }
            item = item->next;
            ppcVar6 = ppcVar6 + 1;
            ppcStack88 = ppcStack88 + 1;
          }
          if ((needed_01 == 0) && (__s = (char *)(*cJSON_malloc)(sVar2), __s != (char *)0x0)) {
            *__s = '{';
            __s_02 = __s + 1;
            if (p != (printbuffer *)0x0) {
              __s_02 = __s + 2;
              __s[1] = '\n';
            }
            *__s_02 = '\0';
            needed = 0;
            ppcVar6 = __s_00;
            ppcVar7 = __s_01;
            do {
              __dest = __s_02;
              if (p != (printbuffer *)0x0) {
                iVar5 = 0;
                while (__dest = __s_02 + iVar5, iVar5 < fmt + 1) {
                  *__dest = '\t';
                  iVar5 = iVar5 + 1;
                }
              }
              __n = strlen(*ppcVar7);
              memcpy(__dest,*ppcVar7,__n);
              __dest = __dest + __n;
              *__dest = ':';
              __s_02 = __dest + 1;
              if (p != (printbuffer *)0x0) {
                __s_02 = __dest + 2;
                __dest[1] = '\t';
              }
              strcpy(__s_02,*ppcVar6);
              __n = strlen(*ppcVar6);
              __s_02 = __s_02 + __n;
              if (needed_00 + -1 != needed) {
                *__s_02 = ',';
                __s_02 = __s_02 + 1;
              }
              if (p != (printbuffer *)0x0) {
                *__s_02 = '\n';
                __s_02 = __s_02 + 1;
              }
              *__s_02 = '\0';
              __dest = *ppcVar7;
              needed = needed + 1;
              ppcVar7 = ppcVar7 + 1;
              (*cJSON_free)(__dest);
              __dest = *ppcVar6;
              ppcVar6 = ppcVar6 + 1;
              (*cJSON_free)(__dest);
            } while (needed_00 != needed);
            (*cJSON_free)(__s_01);
            (*cJSON_free)(__s_00);
            if (p != (printbuffer *)0x0) {
              while (needed_01 < fmt) {
                __s_02[needed_01] = '\t';
                needed_01 = needed_01 + 1;
              }
              if (fmt < 0) {
                fmt = 0;
              }
              __s_02 = __s_02 + fmt;
            }
            *__s_02 = '}';
            __s_02[1] = '\0';
            return __s;
          }
          sVar1 = 0;
          do {
            if (*(void **)((int)__s_01 + sVar1) != (void *)0x0) {
              (*cJSON_free)(*(void **)((int)__s_01 + sVar1));
            }
            if (*(void **)((int)__s_00 + sVar1) != (void *)0x0) {
              (*cJSON_free)(*(void **)((int)__s_00 + sVar1));
            }
            sVar1 = sVar1 + 4;
          } while (__n != sVar1);
          (*cJSON_free)(__s_01);
        }
        (*cJSON_free)(__s_00);
      }
    }
    else {
      needed = (uint)(p != (printbuffer *)0x0) + 1;
      needed_00 = in_a3->offset;
      __s = ensure(in_a3,(uint)(p != (printbuffer *)0x0) + 2);
      if (__s != (char *)0x0) {
        *__s = '{';
        __s_02 = __s + 1;
        if (p != (printbuffer *)0x0) {
          __s_02 = __s + 2;
          __s[1] = '\n';
        }
        *__s_02 = '\0';
        needed_01 = fmt + 1;
        in_a3->offset = in_a3->offset + needed;
        item = *(cJSON **)depth;
        while (item != (cJSON *)0x0) {
          if (p != (printbuffer *)0x0) {
            __s = ensure(in_a3,needed_01);
            if (__s == (char *)0x0) {
              return (char *)0x0;
            }
            iVar5 = 0;
            while (iVar5 < needed_01) {
              __s[iVar5] = '\t';
              iVar5 = iVar5 + 1;
            }
            in_a3->offset = in_a3->offset + needed_01;
          }
          print_string_ptr(item->string,in_a3);
          iVar5 = update(in_a3);
          in_a3->offset = iVar5;
          __s = ensure(in_a3,needed);
          if (__s == (char *)0x0) {
            return (char *)0x0;
          }
          *__s = ':';
          if (p != (printbuffer *)0x0) {
            __s[1] = '\t';
          }
          in_a3->offset = in_a3->offset + needed;
          print_value(item,needed_01,(int)p,in_a3);
          iVar5 = update(in_a3);
          in_a3->offset = iVar5;
          iVar5 = (uint)(item->next != (cJSON *)0x0) + (uint)(p != (printbuffer *)0x0);
          __s = ensure(in_a3,iVar5 + 1);
          if (__s == (char *)0x0) {
            return (char *)0x0;
          }
          if (item->next != (cJSON *)0x0) {
            *__s = ',';
            __s = __s + 1;
          }
          if (p != (printbuffer *)0x0) {
            *__s = '\n';
            __s = __s + 1;
          }
          *__s = '\0';
          in_a3->offset = iVar5 + in_a3->offset;
          item = item->next;
        }
        needed = 2;
        if (p != (printbuffer *)0x0) {
          needed = fmt + 2;
        }
        __s = ensure(in_a3,needed);
        if (__s != (char *)0x0) {
          if (p != (printbuffer *)0x0) {
            needed_00 = 0;
            while (needed_00 < fmt) {
              __s[needed_00] = '\t';
              needed_00 = needed_00 + 1;
            }
            if (fmt < 0) {
              fmt = 0;
            }
            __s = __s + fmt;
            needed_00 = fmt;
          }
          *__s = '}';
          __s[1] = '\0';
          return in_a3->buffer + needed_00;
        }
      }
    }
  }
  return (char *)0x0;
}



void cJSON_InitHooks(cJSON_Hooks *hooks)

{
  code *pcVar1;
  
  if (hooks == (cJSON_Hooks *)0x0) {
    cJSON_malloc = malloc;
  }
  else {
    pcVar1 = hooks->malloc_fn;
    if (pcVar1 == (anon_subr_void_ptr_size_t *)0x0) {
      pcVar1 = malloc;
    }
    cJSON_malloc = pcVar1;
    if (hooks->free_fn != (anon_subr_void_void_ptr_for_free_fn *)0x0) {
      cJSON_free = (anon_subr_void_void_ptr *)hooks->free_fn;
      return;
    }
  }
  cJSON_free = free;
  return;
}



void cJSON_Delete(cJSON *c)

{
  cJSON *pcVar1;
  
  while (c != (cJSON *)0x0) {
    pcVar1 = c->next;
    if (((c->type & 0x100U) == 0) &&
       (((c->child == (cJSON *)0x0 || (cJSON_Delete(c->child), (c->type & 0x100U) == 0)) &&
        (c->valuestring != (char *)0x0)))) {
      (*cJSON_free)(c->valuestring);
    }
    if (((c->type & 0x200U) == 0) && (c->string != (char *)0x0)) {
      (*cJSON_free)(c->string);
    }
    (*cJSON_free)(c);
    c = pcVar1;
  }
  return;
}



char * cJSON_Print(cJSON *item)

{
  char *pcVar1;
  
  pcVar1 = print_value(item,0,1,(printbuffer *)0x0);
  return pcVar1;
}



void cJSON_AddItemToArray(cJSON *array,cJSON *item)

{
  cJSON *pcVar1;
  cJSON *pcVar2;
  
  if (item != (cJSON *)0x0) {
    pcVar1 = array->child;
    if (array->child == (cJSON *)0x0) {
      array->child = item;
      return;
    }
    do {
      pcVar2 = pcVar1;
      pcVar1 = pcVar2->next;
    } while (pcVar2->next != (cJSON *)0x0);
    pcVar2->next = item;
    item->prev = pcVar2;
  }
  return;
}



void cJSON_AddItemToObject(cJSON *object,char *string,cJSON *item)

{
  char *pcVar1;
  
  if (item != (cJSON *)0x0) {
    if (item->string != (char *)0x0) {
      (*cJSON_free)(item->string);
    }
    pcVar1 = cJSON_strdup(string);
    item->string = pcVar1;
    cJSON_AddItemToArray(object,item);
    return;
  }
  return;
}



cJSON * cJSON_CreateNumber(void)

{
  undefined4 in_a0;
  cJSON *pcVar1;
  SItype SVar2;
  undefined4 in_a1;
  
  pcVar1 = cJSON_New_Item();
  if (pcVar1 != (cJSON *)0x0) {
    pcVar1->type = 3;
    *(undefined4 *)&pcVar1->valuedouble = in_a0;
    *(undefined4 *)((int)&pcVar1->valuedouble + 4) = in_a1;
    SVar2 = __fixdfsi();
    pcVar1->valueint = SVar2;
  }
  return pcVar1;
}



cJSON * cJSON_CreateString(char *string)

{
  cJSON *pcVar1;
  char *pcVar2;
  
  pcVar1 = cJSON_New_Item();
  if (pcVar1 != (cJSON *)0x0) {
    pcVar1->type = 4;
    pcVar2 = cJSON_strdup(string);
    pcVar1->valuestring = pcVar2;
  }
  return pcVar1;
}



cJSON * cJSON_CreateObject(void)

{
  cJSON *pcVar1;
  
  pcVar1 = cJSON_New_Item();
  if (pcVar1 != (cJSON *)0x0) {
    pcVar1->type = 6;
  }
  return pcVar1;
}



cli_command * cli_command_get(int idx,int *is_static_cmd)

{
  cli_st *pcVar1;
  cli_command *pcVar2;
  
  pcVar1 = cli;
  pcVar2 = (cli_command *)0xffffffff;
  if (-1 < idx) {
    pcVar2 = (cli_command *)0xffffffff;
    if ((uint)idx < cli->num_static_cmds + 8) {
      if ((uint)idx < cli->num_static_cmds) {
        if (is_static_cmd != (int *)0x0) {
          *is_static_cmd = 1;
        }
        pcVar2 = pcVar1->static_cmds + idx;
      }
      else {
        if (is_static_cmd != (int *)0x0) {
          *is_static_cmd = 0;
        }
        pcVar2 = pcVar1->dynamic_cmds[idx - pcVar1->num_static_cmds];
      }
    }
  }
  return pcVar2;
}



void exit_cmd(char *buf,int len,int argc,char **argv)

{
  cliexit = 1;
  return;
}



int cb_idnoe(void *arg,inode_t *node)

{
  uint8_t uVar1;
  char *pcVar2;
  undefined4 uVar3;
  
  if (*(int *)arg == 0) {
    *(undefined4 *)arg = 1;
    printf("\tSize\t\t\t\t\t Name\t\t\tFiletype\r\n");
    printf("----------------------------------------------------------------------------------\r\n")
    ;
  }
  uVar1 = node->type;
  uVar3 = 0x1c;
  if ((1 < (byte)(uVar1 - 1)) && (uVar3 = 0x50, uVar1 != '\x03')) {
    uVar3 = 0;
  }
  if (uVar1 == '\x01') {
    pcVar2 = "Char Device";
  }
  else {
    if (uVar1 == '\x02') {
      pcVar2 = "Block Device";
    }
    else {
      if (uVar1 == '\x03') {
        pcVar2 = "File System";
      }
      else {
        pcVar2 = "Unknown";
      }
    }
  }
  printf("%10d\t\t%30s\t\t\t%s\r\n",uVar3,node->i_name,pcVar2);
  return 0;
}



void ota_cmd(char *buf,int len,int argc,char **argv)

{
  aos_task_new("LOCAL OTA",tftp_ota_thread,(void *)0x0,0x1000);
  return;
}



void tftp_ota_thread(void *arg)

{
  aos_task_exit(0);
  return;
}



void cat_cmd(char *buf,int len,int argc,char **argv)

{
  int fd;
  ssize_t sVar1;
  byte local_11 [4];
  char ch;
  
  if (argc != 2) {
    printf("invalid parameter!\r\n");
  }
  fd = aos_open(argv[1],0);
  if (fd < 0) {
    printf("open %s failed!\r\n",argv[1]);
  }
  else {
    while (sVar1 = aos_read(fd,local_11,1), sVar1 == 1) {
      printf("%c",(uint)local_11[0]);
    }
    printf("\r\n");
    aos_close(fd);
  }
  return;
}



void hexdump_cmd(char *buf,int len,int argc,char **argv)

{
  int fd;
  void *local_18;
  romfs_filebuf_t filebuf;
  
  if (argc != 2) {
    printf("invalid parameter!\r\n");
  }
  fd = aos_open(argv[1],0);
  if (fd < 0) {
    printf("open %s failed!\r\n",argv[1]);
  }
  else {
    memset(&local_18,0,8);
    aos_ioctl(fd,1,(ulong)&local_18);
    printf("Found file %s. XIP Addr %p, len %lu\r\n",argv[1],local_18,filebuf.buf);
    utils_hexdump(local_18,(uint)filebuf.buf);
    aos_close(fd);
  }
  return;
}



int aos_cli_init(int use_thread)

{
  cli_st *pcVar1;
  int iVar2;
  
  cli = (cli_st *)aos_malloc(0x244);
  iVar2 = 0xc;
  if (cli != (cli_st *)0x0) {
    memset(cli,0,0x244);
    pcVar1 = cli;
    cli->static_cmds = cmds_user;
    pcVar1->echo_disabled = 0;
    pcVar1->num_static_cmds = 0x5b;
    pcVar1->num_commands = 0x5b;
    pcVar1->initialized = 1;
    iVar2 = 0;
  }
  return iVar2;
}



void * aos_cli_event_cb_read_get(void)

{
  return console_cb_read;
}



int cli_putstr(char *msg)

{
  int iVar1;
  size_t sVar2;
  ssize_t sVar3;
  
  sVar2 = strlen(msg);
  iVar1 = 0;
  while ((iVar1 < (int)sVar2 &&
         (sVar3 = aos_write(fd_console,msg + iVar1,sVar2 - iVar1), -1 < sVar3))) {
    iVar1 = iVar1 + sVar3;
  }
  return 0;
}



void ps_cmd(char *buf,int len,int argc,char **argv)

{
  char *__dest;
  char *__dest_00;
  size_t sVar1;
  int iVar2;
  
  __dest_00 = (char *)pvPortMalloc(0x600);
  if (__dest_00 != (char *)0x0) {
    strcpy(__dest_00,"Task");
    sVar1 = strlen(__dest_00);
    __dest = __dest_00 + sVar1;
    sVar1 = strlen("Task");
    iVar2 = sVar1 - (int)__dest;
    while ((int)(__dest + iVar2) < 0xd) {
      *__dest = ' ';
      __dest = __dest + 1;
      *__dest = '\0';
    }
    strcpy(__dest,
           "State   Priority  Stack    #          Base\r\n********************************************************\r\n"
          );
    sVar1 = strlen(
                  "State   Priority  Stack    #          Base\r\n********************************************************\r\n"
                  );
    vTaskList(__dest + sVar1);
    cli_putstr(__dest_00);
    vPortFree(__dest_00);
    return;
  }
  return;
}



int aos_cli_printf(char *msg,...)

{
  size_t sVar1;
  int iVar2;
  undefined4 in_a1;
  undefined4 in_a2;
  undefined4 in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list ap;
  char message [256];
  undefined4 uStack28;
  undefined4 uStack24;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  undefined4 uStack8;
  undefined4 uStack4;
  
  uStack28 = in_a1;
  uStack24 = in_a2;
  uStack20 = in_a3;
  uStack16 = in_a4;
  uStack12 = in_a5;
  uStack8 = in_a6;
  uStack4 = in_a7;
  memset(&ap,0,0x100);
  sVar1 = 0;
  if (esc_tag_len != '\0') {
    strcpy((char *)&ap,esc_tag);
    sVar1 = strlen(esc_tag);
  }
  iVar2 = vsnprintf((char *)((int)&ap + sVar1),0x100 - sVar1,msg,&uStack28);
  if (0 < iVar2) {
    cli_putstr((char *)&ap);
  }
  return 0;
}



int proc_onecmd(int argc,char **argv)

{
  cli_st *pcVar1;
  cli_st *pcVar2;
  char *__s1;
  cli_command *pcVar3;
  int iVar4;
  uint idx;
  uint uVar5;
  char *__n;
  char *__s2;
  
  if (argc < 1) {
    return 0;
  }
  if (cli->echo_disabled == 0) {
    printf("\r\n");
  }
  __n = (char *)0x0;
  __s1 = strchr(*argv,0x2e);
  __s2 = *argv;
  if (__s1 != (char *)0x0) {
    __n = __s1 + -(int)__s2;
  }
  idx = 0;
  uVar5 = 0;
  while( true ) {
    if (cli->num_static_cmds + 8 <= idx) {
      return 1;
    }
    if (cli->num_commands <= uVar5) break;
    pcVar3 = cli_command_get(idx,(int *)0x0);
    __s1 = pcVar3->name;
    if (__s1 != (char *)0x0) {
      if (__n == (char *)0x0) {
        iVar4 = strcmp(__s1,__s2);
      }
      else {
        iVar4 = strncmp(__s1,__s2,(size_t)__n);
      }
      pcVar1 = cli;
      if (iVar4 == 0) {
        __s1 = (char *)aos_malloc(0x200);
        pcVar2 = cli;
        pcVar1->outbuf = __s1;
        if (pcVar2->outbuf == (char *)0x0) {
          aos_cli_printf("Error! cli alloc mem fail!\r\n");
          return 1;
        }
        memset(pcVar2->outbuf,0,0x200);
        (*pcVar3->function)(cli->outbuf,0x200,argc,argv);
        aos_cli_printf("%s",cli->outbuf);
        aos_free(cli->outbuf);
        cli->outbuf = (char *)0x0;
        return 0;
      }
      uVar5 = uVar5 + 1;
    }
    idx = idx + 1;
  }
  return 1;
}



void ls_cmd(char *buf,int len,int argc,char **argv)

{
  stat *st;
  int iVar1;
  aos_dir_t *dir;
  aos_dirent_t *paVar2;
  char *msg;
  size_t __n;
  size_t sVar3;
  undefined4 uStack180;
  int env;
  char path_name [128];
  
  uStack180 = 0;
  st = (stat *)pvPortMalloc(0x58);
  memset(stat,0,0x58);
  memset(&env,0,0x80);
  if (argc == 2) {
    iVar1 = strcmp(argv[1],"/sdcard");
    if (iVar1 == 0) {
      dir = aos_opendir("/sdcard");
      if (dir == (aos_dir_t *)0x0) {
        msg = "can not open sdcard\r\n";
LAB_2302f604:
        printf(msg);
        goto LAB_2302f5de;
      }
      printf("\tSize\t\t\t\t\t Name\t\t\tFiletype\r\n");
      printf(
            "----------------------------------------------------------------------------------\r\n"
            );
      while (paVar2 = aos_readdir(dir), paVar2 != (aos_dirent_t *)0x0) {
        snprintf((char *)&env,0x7f,"/sdcard/%s",&paVar2->field_0x5);
        iVar1 = aos_stat((char *)&env,st);
        if (iVar1 == 0) {
          iVar1 = -0x6a8;
          if (-1 < (int)(st->st_mode << 0x11)) {
            iVar1 = -0x68c;
          }
          printf("Warning: Moved an ENV (size %d) failed when recovery. Now will GC then retry.\r\n"
                 + iVar1 + 0x38,st->st_size,&paVar2->field_0x5);
        }
      }
    }
    else {
      msg = argv[1];
      __n = strlen("/romfs");
      iVar1 = memcmp(msg,"/romfs",__n);
      if (iVar1 != 0) {
        iVar1 = strcmp(argv[1],"/");
        if (iVar1 != 0) {
          msg = "un-supported direcotry!\r\n";
          goto LAB_2302f72a;
        }
        goto LAB_2302f712;
      }
      dir = aos_opendir(argv[1]);
      if (dir == (aos_dir_t *)0x0) {
        msg = "can not open romfs\r\n";
        goto LAB_2302f604;
      }
      printf("\tSize\t\t\t\t\t Name\t\t\tFiletype\r\n");
      printf(
            "----------------------------------------------------------------------------------\r\n"
            );
      while (paVar2 = aos_readdir(dir), paVar2 != (aos_dirent_t *)0x0) {
        memset(&env,0,0x80);
        snprintf((char *)&env,0x7f,"%s",argv[1]);
        __n = strlen((char *)&env);
        if (*(char *)((int)&uStack180 + __n + 3) != '/') {
          __n = strlen((char *)&env);
          *(undefined *)((int)&env + __n) = 0x2f;
        }
        __n = strlen((char *)&env);
        sVar3 = strlen((char *)&env);
        snprintf((char *)((int)&env + __n),0x7f - sVar3,"%s",&paVar2->field_0x5);
        iVar1 = aos_stat((char *)&env,st);
        if (iVar1 == 0) {
          iVar1 = -0x6a8;
          if (-1 < (int)(st->st_mode << 0x11)) {
            iVar1 = -0x68c;
          }
          printf("Warning: Moved an ENV (size %d) failed when recovery. Now will GC then retry.\r\n"
                 + iVar1 + 0x38,st->st_size,&paVar2->field_0x5);
        }
      }
    }
    aos_closedir(dir);
  }
  else {
    if (argc != 1) {
      msg = "invalid parameter!\r\n";
LAB_2302f72a:
      aos_cli_printf(msg);
      goto LAB_2302f5de;
    }
LAB_2302f712:
    inode_forearch_name(cb_idnoe,&uStack180);
  }
LAB_2302f5de:
  vPortFree(st);
  return;
}



void uptime_cmd(char *buf,int len,int argc,char **argv)

{
  char *pcVar1;
  char *pcVar2;
  int iVar3;
  int iVar4;
  longlong lVar5;
  DItype DVar6;
  
  lVar5 = aos_now_ms();
  aos_cli_printf("UP time in ms %llu\r\n",buf,len,(int)lVar5);
  pcVar1 = buf;
  iVar3 = len;
  __divdi3();
  __moddi3();
  pcVar2 = buf;
  iVar4 = len;
  __divdi3();
  __moddi3();
  __divdi3();
  __divdi3();
  DVar6 = __moddi3();
  aos_cli_printf("UP time in %llu days, %llu hours, %llu minutes, %llu seconds\r\n",buf,len,pcVar2,
                 iVar4,pcVar1,iVar3,(int)DVar6);
  return;
}



void reset_cmd(char *buf,int len,int argc,char **argv)

{
  aos_cli_printf("system reset\r\n");
  hal_sys_reset();
  return;
}



void poweroff_cmd(char *buf,int len,int argc,char **argv)

{
  aos_cli_printf("poweroff\r\n");
  hal_poweroff();
  return;
}



void reboot_cmd(char *buf,int len,int argc,char **argv)

{
  aos_cli_printf("reboot\r\n");
  hal_reboot();
  return;
}



// WARNING: Variable defined which should be unmapped: desc

void version_cmd(char *buf,int len,int argc,char **argv)

{
  int iVar1;
  size_t sVar2;
  int iStack76;
  int num;
  uint addr [4];
  uint size [4];
  char desc [4] [6];
  
  iStack76 = 4;
  aos_cli_printf("kernel version :posix\r\n");
  aos_cli_printf("release_bl_iot_sdk_1.6.11-1-g66bb28da-dirty");
  aos_cli_printf("\r\n");
  iVar1 = bl_chip_memory_ram(&iStack76,(uint *)&num,addr + 3,(char (*) [6])(size + 3));
  if (iVar1 == 0) {
    aos_cli_printf("Memory Configuration on %d banks:\r\n",iStack76);
    while (iVar1 < iStack76) {
      aos_cli_printf("    [%d]%6s %6u Kbytes @ %p\r\n",iVar1,(int)size + iVar1 * 6 + 0xc,
                     addr[iVar1 + 3] >> 10,(&num)[iVar1]);
      iVar1 = iVar1 + 1;
    }
  }
  sVar2 = xPortGetFreeHeapSize();
  aos_cli_printf("Heap left: %d Bytes\r\n",sVar2);
  return;
}



void devname_cmd(char *buf,int len,int argc,char **argv)

{
  aos_cli_printf("device name: %s\r\n",&UNK_23077830);
  return;
}



void echo_cmd(char *buf,int len,int argc,char **argv)

{
  int iVar1;
  char *pcVar2;
  
  if (argc == 1) {
    if (cli->echo_disabled == 0) {
      pcVar2 = "Enabled";
    }
    else {
      pcVar2 = "Disabled";
    }
    aos_cli_printf("Usage: echo on/off. Echo is currently %s\r\n",pcVar2);
    return;
  }
  iVar1 = strcmp(argv[1],"on");
  if (iVar1 == 0) {
    aos_cli_printf("Enable echo\r\n");
    cli->echo_disabled = 0;
  }
  else {
    iVar1 = strcmp(argv[1],"off");
    if (iVar1 == 0) {
      aos_cli_printf("Disable echo\r\n");
      cli->echo_disabled = 1;
    }
  }
  return;
}



void mmem_cmd(char *buf,int len,int argc,char **argv)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  
  if (argc == 3) {
    iVar2 = 4;
LAB_2302f9c2:
    uVar1 = strtol(argv[2],(char **)0x0,0);
  }
  else {
    if (argc == 4) {
      iVar2 = strtol(argv[3],(char **)0x0,0);
      goto LAB_2302f9c2;
    }
    if (argc != 2) goto LAB_2302f9e0;
    uVar1 = 0;
    iVar2 = 4;
  }
  len = strtol(argv[1],(char **)0x0,0);
  if ((uint *)len != (uint *)0x0) {
    if (iVar2 == 1) {
      uVar3 = (uint)*(byte *)len;
      *(byte *)len = (byte)uVar1;
      uVar1 = (uint)*(byte *)len;
    }
    else {
      if (iVar2 == 2) {
        uVar3 = (uint)*(ushort *)len;
        *(ushort *)len = (ushort)uVar1;
        uVar1 = (uint)*(ushort *)len;
      }
      else {
        uVar3 = *(uint *)len;
        *(uint *)len = uVar1;
        uVar1 = *(uint *)len;
      }
    }
    aos_cli_printf("value on 0x%x change from 0x%x to 0x%x.\r\n",len,uVar3,uVar1);
    return;
  }
LAB_2302f9e0:
  aos_cli_printf(
                 "m <addr> <value> <width>\r\naddr  : address to modify\r\nvalue : new value (default is 0)\r\nwidth : width of unit, 1/2/4 (default is 4)\r\n"
                 ,len);
  return;
}



void pmem_cmd(char *buf,int len,int argc,char **argv)

{
  ushort uVar1;
  undefined4 *puVar2;
  int iVar3;
  undefined4 uVar4;
  long lVar5;
  uint uVar6;
  char *pcStack52;
  char *pos;
  
  pcStack52 = (char *)0x0;
  if (argc == 3) {
    lVar5 = 4;
LAB_2302fad2:
    iVar3 = strtol(argv[2],(char **)0x0,0);
    if (0x400 < iVar3) {
      iVar3 = 0x400;
    }
  }
  else {
    if (argc == 4) {
      lVar5 = strtol(argv[3],(char **)0x0,0);
      goto LAB_2302fad2;
    }
    lVar5 = 4;
    iVar3 = 0x10;
    puVar2 = (undefined4 *)0x0;
    if (argc != 2) goto LAB_2302fa96;
  }
  puVar2 = (undefined4 *)strtol(argv[1],&pcStack52,0);
LAB_2302fa96:
  if ((pcStack52 == (char *)0x0) || (pcStack52 == argv[1])) {
    aos_cli_printf(
                  "p <addr> <nunits> <width>\r\naddr  : address to display\r\nnunits: number of units to display (default is 16)\r\nwidth : width of unit, 1/2/4 (default is 4)\r\n"
                  );
  }
  else {
    if (lVar5 == 1) {
      uVar6 = 0;
      while ((int)uVar6 < iVar3) {
        if ((uVar6 & 0xf) == 0) {
          aos_cli_printf("0x%08x:",(byte *)((int)puVar2 + uVar6));
        }
        aos_cli_printf(" %02x",(uint)*(byte *)((int)puVar2 + uVar6));
        if ((uVar6 & 0xf) == 0xf) {
          aos_cli_printf("\r\n");
        }
        uVar6 = uVar6 + 1;
      }
    }
    else {
      if (lVar5 == 2) {
        uVar6 = 0;
        while ((int)uVar6 < iVar3) {
          if ((uVar6 & 7) == 0) {
            aos_cli_printf("0x%08x:",puVar2);
          }
          uVar1 = *(ushort *)puVar2;
          puVar2 = (undefined4 *)((int)puVar2 + 2);
          aos_cli_printf(" %04x",(uint)uVar1);
          if ((uVar6 & 7) == 7) {
            aos_cli_printf("\r\n");
          }
          uVar6 = uVar6 + 1;
        }
      }
      else {
        uVar6 = 0;
        while ((int)uVar6 < iVar3) {
          if ((uVar6 & 3) == 0) {
            aos_cli_printf("0x%08x:",puVar2);
          }
          uVar4 = *puVar2;
          puVar2 = puVar2 + 1;
          aos_cli_printf(" %08x",uVar4);
          if ((uVar6 & 3) == 3) {
            aos_cli_printf("\r\n");
          }
          uVar6 = uVar6 + 1;
        }
      }
    }
  }
  return;
}



void help_cmd(char *buf,int len,int argc,char **argv)

{
  cli_command *pcVar1;
  uint idx;
  undefined *puVar2;
  char *pcVar3;
  uint uVar4;
  
  aos_cli_printf("====Build-in Commands====\r\n");
  pcVar1 = built_ins;
  aos_cli_printf("====Support %d cmds once, seperate by ; ====\r\n",4);
  do {
    if (((cfg_element_entry *)pcVar1)->task != 0) {
      puVar2 = *(undefined **)&((cfg_element_entry *)pcVar1)->element;
      if (*(undefined **)&((cfg_element_entry *)pcVar1)->element == (undefined *)0x0) {
        puVar2 = &DAT_2307cef0;
      }
      aos_cli_printf("%-25s: %s\r\n",puVar2);
    }
    pcVar1 = (cli_command *)&((cfg_element_entry *)pcVar1)->val;
  } while ((cfg_element_entry *)pcVar1 != cfg_entrys_mm);
  aos_cli_printf("\r\n");
  aos_cli_printf("====User Commands====\r\n");
  uVar4 = 0x10;
  idx = 0;
  while ((idx < cli->num_static_cmds + 8 && (uVar4 < cli->num_commands))) {
    pcVar1 = cli_command_get(idx,(int *)0x0);
    if (((pcVar1 < built_ins) || ((cli_command *)((int)&built_ins[0xf].function + 3U) < pcVar1)) &&
       (pcVar1->name != (char *)0x0)) {
      pcVar3 = pcVar1->help;
      if (pcVar1->help == (char *)0x0) {
        pcVar3 = "";
      }
      aos_cli_printf("%-25s: %s\r\n",pcVar3);
      uVar4 = uVar4 + 1;
    }
    idx = idx + 1;
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

int cli_getchar(char *inbuf)

{
  int32_t iVar1;
  uint uVar2;
  uint32_t local_50;
  uint32_t recv_size;
  uart_dev_t uart_stdio;
  
  local_50 = 0;
  memset(&recv_size,0,0x3c);
  recv_size._0_1_ = '\0';
  iVar1 = hal_uart_recv_II((uart_dev_t *)&recv_size,inbuf,1,&local_50,0xffffffff);
  if (iVar1 == 0) {
    uVar2 = (uint)(local_50 == 1);
  }
  else {
    uVar2 = 0;
  }
  return uVar2;
}



// WARNING: Could not reconcile some variable overlaps

void cli_main_input(char *buffer,int count)

{
  byte bVar1;
  char cVar2;
  cli_st *pcVar3;
  cli_st *pcVar4;
  uint8_t uVar5;
  anon_struct *paVar6;
  undefined1 *argv;
  size_t __n;
  cli_command *pcVar7;
  uint uVar8;
  char *__s1;
  char *__s;
  anon_struct aVar9;
  int iVar10;
  byte *__src;
  char *__s_00;
  uint idx;
  int iVar11;
  size_t __n_00;
  int iVar12;
  uint uStack84;
  anon_struct stat;
  char c;
  
  pcVar3 = cli;
  __s1 = cli->inbuf;
  if (__s1 == (char *)0x0) {
    __s1 = "inbuf_null\r\n";
LAB_2302fe04:
    aos_cli_printf(__s1);
    return;
  }
  iVar11 = 0;
  uVar5 = esc_tag_len;
LAB_2302fd26:
  esc_tag_len = uVar5;
  if (buffer == (char *)0x0) {
    iVar12 = cli_getchar((char *)&stat);
    if (iVar12 != 1) {
      return;
    }
  }
  else {
    if (count <= iVar11) {
      return;
    }
    __src = (byte *)(buffer + iVar11);
    iVar11 = iVar11 + 1;
    stat = (anon_struct)((uint)stat & 0xffffff00 | (uint)*__src);
  }
  pcVar4 = cli;
  cVar2 = key1_4388;
  if ((stat._0_1_ != '\n') && (stat._0_1_ != '\r')) {
    uVar5 = esc_tag_len;
    if (stat._0_1_ == '\x1b') {
      esc_4387 = '\x01';
      key1_4388 = -1;
      key2_4389 = -1;
    }
    else {
      if (esc_4387 != '\0') {
        if (key1_4388 < '\0') {
          __s = (char *)(int)stat._0_1_;
          key1_4388 = stat._0_1_;
          if (__s == (char *)0x5b) goto LAB_2302fd26;
          __s1[pcVar3->bp] = '\x1b';
          idx = pcVar3->bp + 1;
          pcVar3->bp = idx;
          __s1[idx] = stat._0_1_;
          pcVar3->bp = pcVar3->bp + 1;
          if (cli->echo_disabled == 0) {
            __s_00 = "\x1b%c";
LAB_2302fe8e:
            printf(__s_00,__s);
          }
        }
        else {
          if ((key2_4389 < '\0') && (key2_4389 = stat._0_1_, stat._0_1_ == 't')) {
            esc_tag[0] = '\x1b';
            esc_tag[1] = key1_4388;
            esc_tag_len = '\x02';
          }
          idx = SEXT14(key2_4389);
          if (((idx & 0xff) - 0x41 & 0xff) < 2) {
            __s_00 = __s1;
            if (idx == 0x41) {
              iVar10 = cli->his_idx;
              iVar12 = iVar10;
              do {
                iVar12 = (iVar12 + 0xff) % 0x100;
                if (cli->history[iVar12] != '\0') {
                  if (iVar10 != iVar12) {
                    do {
                      iVar12 = (iVar12 + 0xff) % 0x100;
                    } while (cli->history[iVar12] != '\0');
                    iVar12 = (iVar12 + 1) % 0x100;
                  }
                  break;
                }
              } while (iVar10 != iVar12);
              cli->his_idx = iVar12;
              while (pcVar4->history[iVar10] != '\0') {
                *__s_00 = pcVar4->history[iVar10];
                iVar10 = (iVar10 + 1) % 0x100;
                __s_00 = __s_00 + 1;
              }
            }
            else {
              iVar10 = cli->his_idx;
              iVar12 = iVar10;
              while (cli->history[iVar12] != '\0') {
                iVar12 = (iVar12 + 1) % 0x100;
              }
              if (iVar10 != iVar12) {
                do {
                  iVar12 = (iVar12 + 1) % 0x100;
                } while (cli->history[iVar12] == '\0');
              }
              cli->his_idx = iVar12;
              while (pcVar4->history[iVar10] != '\0') {
                *__s_00 = pcVar4->history[iVar10];
                iVar10 = (iVar10 + 1) % 0x100;
                __s_00 = __s_00 + 1;
              }
            }
            *__s_00 = '\0';
            printf("\r\n# %s",__s1);
            __n = strlen(__s1);
            pcVar3->bp = __n;
            esc_tag[0] = '\0';
            esc_tag_len = '\0';
          }
          else {
            if (idx == 0x74) {
              if (0x3f < esc_tag_len) {
                esc_tag[0] = '\0';
                esc_tag_len = '\0';
                esc_4387 = '\0';
                printf("Error: esc_tag buffer overflow\r\n");
                uVar5 = esc_tag_len;
                goto LAB_2302fd26;
              }
              idx = (uint)esc_tag_len + 1 & 0xff;
              esc_tag[(uint)esc_tag_len] = stat._0_1_;
              pcVar4 = cli;
              uVar5 = (uint8_t)idx;
              if (stat._0_1_ != 'm') goto LAB_2302fd26;
              esc_tag[idx] = '\0';
              esc_tag_len = esc_tag_len + '\x02';
              if (pcVar4->echo_disabled == 0) {
                __s = esc_tag;
                __s_00 = "%s";
                goto LAB_2302fe8e;
              }
            }
            else {
              __s1[pcVar3->bp] = '\x1b';
              uVar8 = pcVar3->bp + 1;
              pcVar3->bp = uVar8;
              __s1[uVar8] = cVar2;
              uVar8 = pcVar3->bp + 1;
              pcVar3->bp = uVar8;
              __s1[uVar8] = (char)(idx & 0xff);
              pcVar3->bp = pcVar3->bp + 1;
              if (cli->echo_disabled == 0) {
                printf("\x1b%c%c");
              }
              esc_tag[0] = '\0';
              esc_tag_len = '\0';
            }
          }
        }
        esc_4387 = '\0';
        uVar5 = esc_tag_len;
        goto LAB_2302fd26;
      }
      __s1[pcVar3->bp] = stat._0_1_;
      if ((stat._0_1_ == '\b') || (stat._0_1_ == '\x7f')) {
        uVar5 = esc_tag_len;
        if ((pcVar3->bp != 0) &&
           (pcVar3->bp = pcVar3->bp - 1, uVar5 = esc_tag_len, cli->echo_disabled == 0)) {
          printf("%c %c",8,8);
          uVar5 = esc_tag_len;
        }
      }
      else {
        if (stat._0_1_ == '\t') {
          __s1[pcVar3->bp] = '\0';
          aos_cli_printf("\r\n");
          iVar12 = 0;
          uVar8 = 0;
          idx = 0;
          __s_00 = (char *)0x0;
          while ((idx < cli->num_static_cmds + 8 && (uVar8 < cli->num_commands))) {
            pcVar7 = cli_command_get(idx,(int *)0x0);
            __s = __s_00;
            if (pcVar7->name != (char *)0x0) {
              iVar10 = strncmp(__s1,pcVar7->name,pcVar3->bp);
              if (iVar10 == 0) {
                iVar12 = iVar12 + 1;
                __s = pcVar7->name;
                if (iVar12 != 1) {
                  if (iVar12 == 2) {
                    aos_cli_printf("%s %s ",__s_00);
                    __s = __s_00;
                  }
                  else {
                    aos_cli_printf("%s ",__s);
                    __s = __s_00;
                  }
                }
              }
              uVar8 = uVar8 + 1;
            }
            idx = idx + 1;
            __s_00 = __s;
          }
          if (iVar12 == 1) {
            if ((__s_00 != (char *)0x0) && (__n = strlen(__s_00), __n < 0x100)) {
              idx = pcVar3->bp;
              memcpy(__s1 + idx,__s_00 + idx,__n - idx);
              iVar12 = (__n - idx) + pcVar3->bp;
              pcVar3->bp = iVar12 + 1;
              __s1[iVar12] = ' ';
              __s1[pcVar3->bp] = '\0';
            }
          }
          else {
            if (1 < iVar12) {
              aos_cli_printf("\r\n");
            }
          }
          aos_cli_printf("%s%s",&DAT_230777ac,__s1);
          uVar5 = esc_tag_len;
        }
        else {
          if (cli->echo_disabled == 0) {
            printf("%c",(uint)stat & 0xff);
          }
          idx = pcVar3->bp + 1;
          pcVar3->bp = idx;
          uVar5 = esc_tag_len;
          if (0xff < idx) {
            aos_cli_printf("Error: input buffer overflow\r\n");
            aos_cli_printf("# ");
            pcVar3->bp = 0;
            return;
          }
        }
      }
    }
    goto LAB_2302fd26;
  }
  __s1[pcVar3->bp] = '\0';
  __s1 = pcVar4->inbuf;
  pcVar3->bp = 0;
  __n = strlen(__s1);
  if (__n != 0) {
    __s = cli->inbuf;
    __n = strlen(__s);
    pcVar3 = cli;
    __n = __n + 1;
    iVar11 = cli->his_cur;
    __n_00 = 0x100 - iVar11;
    cli->his_idx = iVar11;
    __s_00 = pcVar3->history + iVar11;
    iVar12 = iVar11 + __n + -1;
    if ((int)__n_00 < (int)__n) {
      iVar12 = iVar12 % 0x100;
      cVar2 = pcVar3->history[iVar12];
      strncpy(__s_00,__s,__n_00);
      __n = __n - __n_00;
      __s = __s + __n_00;
      __s_00 = cli->history;
    }
    else {
      cVar2 = pcVar3->history[iVar11 + __n + -1];
    }
    strncpy(__s_00,__s,__n);
    pcVar3 = cli;
    iVar11 = (iVar12 + 1) % 0x100;
    cli->his_cur = iVar11;
    if (cVar2 != '\0') {
      while (iVar12 = (int)&pcVar3->initialized + iVar11, *(char *)(iVar12 + 0x144) != '\0') {
        *(undefined *)(iVar12 + 0x144) = 0;
        iVar11 = (iVar11 + 1) % 0x100;
      }
    }
  }
  stat = (anon_struct)0x0;
  memset(argvall_4310,0,0x100);
  memset(&stat,0,0x10);
  memset(&uStack84,0,4);
  iVar11 = 0;
  paVar6 = &stat;
  iVar12 = 0;
  do {
    __src = (byte *)(__s1 + iVar11);
    bVar1 = *__src;
    if (bVar1 != 0x20) {
      if (0x20 < bVar1) {
        if (bVar1 == 0x22) {
          if (((iVar11 == 0) || (__s_00 = __s1 + iVar11 + -1, *__s_00 != '\\')) ||
             ((uStack84 & 1) == 0)) {
            idx = uStack84 & 3;
            if (idx != 1) {
              if (idx == 2) goto LAB_2303049e;
              if (idx == 0) {
                aVar9 = *paVar6;
                uStack84 = uStack84 & 0xfffffffc | 3;
                *(int *)paVar6 = (int)aVar9 + 1;
                *(char **)(argvall_4310 + (iVar12 * 0x10 + (int)aVar9) * 4) = __s1 + iVar11 + 1;
              }
              else {
                if (idx == 3) {
                  uStack84._0_1_ = (byte)uStack84 & 0xfc;
                  goto LAB_23030464;
                }
              }
            }
          }
          else {
LAB_23030400:
            iVar11 = iVar11 + -1;
            __n = strlen((char *)__src);
            memcpy(__s_00,__src,__n + 1);
          }
        }
        else {
          if (bVar1 != 0x3b) goto LAB_2302fdce;
          if (((iVar11 != 0) && (__s_00 = __s1 + iVar11 + -1, *__s_00 == '\\')) &&
             ((uStack84 & 1) != 0)) goto LAB_23030400;
          if ((uStack84 & 2) != 0) goto LAB_2303049e;
          if ((uStack84 & 3) == 1) {
            uStack84 = uStack84 & 0xfffffffe;
            *__src = 0;
            if ((*paVar6 != (anon_struct)0x0) && (iVar12 = iVar12 + 1, iVar12 < 4)) {
              paVar6 = &stat + iVar12;
            }
          }
        }
        goto LAB_23030358;
      }
      if (bVar1 != 0) {
LAB_2302fdce:
        if ((uStack84 & 1) == 0) {
          aVar9 = *paVar6;
          uStack84 = uStack84 | 1;
          *(int *)paVar6 = (int)aVar9 + 1;
          *(byte **)(argvall_4310 + (iVar12 * 0x10 + (int)aVar9) * 4) = __src;
        }
        goto LAB_23030358;
      }
      if ((uStack84 & 2) == 0) {
        uStack84 = uStack84 | 4;
        goto LAB_23030358;
      }
LAB_2303049e:
      aos_cli_printf("syntax error\r\n");
      goto LAB_230303c0;
    }
    if (((iVar11 != 0) && (__s_00 = __s1 + iVar11 + -1, *__s_00 == '\\')) && ((uStack84 & 1) != 0))
    goto LAB_23030400;
    if ((uStack84 & 3) == 1) {
      uStack84._0_1_ = (byte)uStack84 & 0xfe;
LAB_23030464:
      uStack84 = uStack84 & 0xffffff00 | (uint)(byte)uStack84;
      *__src = 0;
    }
LAB_23030358:
  } while ((((uStack84 & 4) == 0) && (iVar11 = iVar11 + 1, iVar11 < 0x100)) &&
          ((iVar12 < 4 && ((int)*paVar6 < 0x10))));
  if ((uStack84 & 2) != 0) goto LAB_2303049e;
  paVar6 = &stat;
  argv = argvall_4310;
  idx = 0;
  iVar11 = 0;
  do {
    iVar11 = iVar11 + 1;
    uVar8 = proc_onecmd((int)*paVar6,(char **)argv);
    idx = idx | uVar8;
    if (iVar12 < iVar11) break;
    paVar6 = paVar6 + 1;
    argv = (undefined1 *)((char **)argv + 0x10);
  } while (iVar11 != 4);
  if (idx == 1) {
    if (__s1 != (char *)0x0) {
      aos_cli_printf("command \'%s\' not found\r\n",__s1);
    }
  }
  else {
    if (idx == 2) goto LAB_2303049e;
  }
LAB_230303c0:
  aos_cli_printf("\r\n");
  esc_tag[0] = '\0';
  esc_tag_len = '\0';
  __s1 = "# ";
  goto LAB_2302fe04;
}



void console_cb_read(int fd,void *param)

{
  ssize_t count;
  char acStack32 [4];
  char buffer [16];
  
  count = aos_read(fd,acStack32,0x10);
  if (0 < count) {
    if (count < 0x11) {
      fd_console = fd;
      cli_main_input(acStack32,count);
    }
    else {
      printf("-------------BUG from aos_read for ret\r\n");
    }
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

void aos_cli_input_direct(char *buffer,int count)

{
  byte bVar1;
  char cVar2;
  cli_st *pcVar3;
  cli_st *pcVar4;
  uint8_t uVar5;
  uint *puVar6;
  undefined1 *argv;
  size_t __n;
  cli_command *pcVar7;
  uint uVar8;
  char *__s1;
  char *__s;
  uint idx;
  int iVar9;
  byte *__src;
  char *__s_00;
  int iVar10;
  size_t __n_00;
  int iVar11;
  uint uStack84;
  uint auStack80 [7];
  
  pcVar3 = cli;
  __s1 = cli->inbuf;
  if (__s1 == (char *)0x0) {
    __s1 = "inbuf_null\r\n";
LAB_2302fe04:
    aos_cli_printf(__s1);
    return;
  }
  iVar10 = 0;
  uVar5 = esc_tag_len;
LAB_2302fd26:
  esc_tag_len = uVar5;
  if (buffer == (char *)0x0) {
    iVar11 = cli_getchar((char *)auStack80);
    if (iVar11 != 1) {
      return;
    }
  }
  else {
    if (count <= iVar10) {
      return;
    }
    __src = (byte *)(buffer + iVar10);
    iVar10 = iVar10 + 1;
    auStack80[0] = auStack80[0] & 0xffffff00 | (uint)*__src;
  }
  pcVar4 = cli;
  cVar2 = key1_4388;
  if (((char)auStack80[0] != '\n') && ((char)auStack80[0] != '\r')) {
    uVar5 = esc_tag_len;
    if ((char)auStack80[0] == '\x1b') {
      esc_4387 = '\x01';
      key1_4388 = -1;
      key2_4389 = -1;
    }
    else {
      if (esc_4387 != '\0') {
        if (key1_4388 < '\0') {
          __s = (char *)(int)(char)auStack80[0];
          key1_4388 = (char)auStack80[0];
          if (__s == (char *)0x5b) goto LAB_2302fd26;
          __s1[pcVar3->bp] = '\x1b';
          idx = pcVar3->bp + 1;
          pcVar3->bp = idx;
          __s1[idx] = (char)auStack80[0];
          pcVar3->bp = pcVar3->bp + 1;
          if (cli->echo_disabled == 0) {
            __s_00 = "\x1b%c";
LAB_2302fe8e:
            printf(__s_00,__s);
          }
        }
        else {
          if ((key2_4389 < '\0') && (key2_4389 = (char)auStack80[0], (char)auStack80[0] == 't')) {
            esc_tag[0] = '\x1b';
            esc_tag[1] = key1_4388;
            esc_tag_len = '\x02';
          }
          idx = SEXT14(key2_4389);
          if (((idx & 0xff) - 0x41 & 0xff) < 2) {
            __s_00 = __s1;
            if (idx == 0x41) {
              iVar9 = cli->his_idx;
              iVar11 = iVar9;
              do {
                iVar11 = (iVar11 + 0xff) % 0x100;
                if (cli->history[iVar11] != '\0') {
                  if (iVar9 != iVar11) {
                    do {
                      iVar11 = (iVar11 + 0xff) % 0x100;
                    } while (cli->history[iVar11] != '\0');
                    iVar11 = (iVar11 + 1) % 0x100;
                  }
                  break;
                }
              } while (iVar9 != iVar11);
              cli->his_idx = iVar11;
              while (pcVar4->history[iVar9] != '\0') {
                *__s_00 = pcVar4->history[iVar9];
                iVar9 = (iVar9 + 1) % 0x100;
                __s_00 = __s_00 + 1;
              }
            }
            else {
              iVar9 = cli->his_idx;
              iVar11 = iVar9;
              while (cli->history[iVar11] != '\0') {
                iVar11 = (iVar11 + 1) % 0x100;
              }
              if (iVar9 != iVar11) {
                do {
                  iVar11 = (iVar11 + 1) % 0x100;
                } while (cli->history[iVar11] == '\0');
              }
              cli->his_idx = iVar11;
              while (pcVar4->history[iVar9] != '\0') {
                *__s_00 = pcVar4->history[iVar9];
                iVar9 = (iVar9 + 1) % 0x100;
                __s_00 = __s_00 + 1;
              }
            }
            *__s_00 = '\0';
            printf("\r\n# %s",__s1);
            __n = strlen(__s1);
            pcVar3->bp = __n;
            esc_tag[0] = '\0';
            esc_tag_len = '\0';
          }
          else {
            if (idx == 0x74) {
              if (0x3f < esc_tag_len) {
                esc_tag[0] = '\0';
                esc_tag_len = '\0';
                esc_4387 = '\0';
                printf("Error: esc_tag buffer overflow\r\n");
                uVar5 = esc_tag_len;
                goto LAB_2302fd26;
              }
              idx = (uint)esc_tag_len + 1 & 0xff;
              esc_tag[(uint)esc_tag_len] = (char)auStack80[0];
              pcVar4 = cli;
              uVar5 = (uint8_t)idx;
              if ((char)auStack80[0] != 'm') goto LAB_2302fd26;
              esc_tag[idx] = '\0';
              esc_tag_len = esc_tag_len + '\x02';
              if (pcVar4->echo_disabled == 0) {
                __s = esc_tag;
                __s_00 = "%s";
                goto LAB_2302fe8e;
              }
            }
            else {
              __s1[pcVar3->bp] = '\x1b';
              uVar8 = pcVar3->bp + 1;
              pcVar3->bp = uVar8;
              __s1[uVar8] = cVar2;
              uVar8 = pcVar3->bp + 1;
              pcVar3->bp = uVar8;
              __s1[uVar8] = (char)(idx & 0xff);
              pcVar3->bp = pcVar3->bp + 1;
              if (cli->echo_disabled == 0) {
                printf("\x1b%c%c");
              }
              esc_tag[0] = '\0';
              esc_tag_len = '\0';
            }
          }
        }
        esc_4387 = '\0';
        uVar5 = esc_tag_len;
        goto LAB_2302fd26;
      }
      __s1[pcVar3->bp] = (char)auStack80[0];
      if (((char)auStack80[0] == '\b') || ((char)auStack80[0] == '\x7f')) {
        uVar5 = esc_tag_len;
        if ((pcVar3->bp != 0) &&
           (pcVar3->bp = pcVar3->bp - 1, uVar5 = esc_tag_len, cli->echo_disabled == 0)) {
          printf("%c %c",8,8);
          uVar5 = esc_tag_len;
        }
      }
      else {
        if ((char)auStack80[0] == '\t') {
          __s1[pcVar3->bp] = '\0';
          aos_cli_printf("\r\n");
          iVar11 = 0;
          uVar8 = 0;
          idx = 0;
          __s_00 = (char *)0x0;
          while ((idx < cli->num_static_cmds + 8 && (uVar8 < cli->num_commands))) {
            pcVar7 = cli_command_get(idx,(int *)0x0);
            __s = __s_00;
            if (pcVar7->name != (char *)0x0) {
              iVar9 = strncmp(__s1,pcVar7->name,pcVar3->bp);
              if (iVar9 == 0) {
                iVar11 = iVar11 + 1;
                __s = pcVar7->name;
                if (iVar11 != 1) {
                  if (iVar11 == 2) {
                    aos_cli_printf("%s %s ",__s_00);
                    __s = __s_00;
                  }
                  else {
                    aos_cli_printf("%s ",__s);
                    __s = __s_00;
                  }
                }
              }
              uVar8 = uVar8 + 1;
            }
            idx = idx + 1;
            __s_00 = __s;
          }
          if (iVar11 == 1) {
            if ((__s_00 != (char *)0x0) && (__n = strlen(__s_00), __n < 0x100)) {
              idx = pcVar3->bp;
              memcpy(__s1 + idx,__s_00 + idx,__n - idx);
              iVar11 = (__n - idx) + pcVar3->bp;
              pcVar3->bp = iVar11 + 1;
              __s1[iVar11] = ' ';
              __s1[pcVar3->bp] = '\0';
            }
          }
          else {
            if (1 < iVar11) {
              aos_cli_printf("\r\n");
            }
          }
          aos_cli_printf("%s%s",&DAT_230777ac,__s1);
          uVar5 = esc_tag_len;
        }
        else {
          if (cli->echo_disabled == 0) {
            printf("%c",auStack80[0] & 0xff);
          }
          idx = pcVar3->bp + 1;
          pcVar3->bp = idx;
          uVar5 = esc_tag_len;
          if (0xff < idx) {
            aos_cli_printf("Error: input buffer overflow\r\n");
            aos_cli_printf("# ");
            pcVar3->bp = 0;
            return;
          }
        }
      }
    }
    goto LAB_2302fd26;
  }
  __s1[pcVar3->bp] = '\0';
  __s1 = pcVar4->inbuf;
  pcVar3->bp = 0;
  __n = strlen(__s1);
  if (__n != 0) {
    __s = cli->inbuf;
    __n = strlen(__s);
    pcVar3 = cli;
    __n = __n + 1;
    iVar10 = cli->his_cur;
    __n_00 = 0x100 - iVar10;
    cli->his_idx = iVar10;
    __s_00 = pcVar3->history + iVar10;
    iVar11 = iVar10 + __n + -1;
    if ((int)__n_00 < (int)__n) {
      iVar11 = iVar11 % 0x100;
      cVar2 = pcVar3->history[iVar11];
      strncpy(__s_00,__s,__n_00);
      __n = __n - __n_00;
      __s = __s + __n_00;
      __s_00 = cli->history;
    }
    else {
      cVar2 = pcVar3->history[iVar10 + __n + -1];
    }
    strncpy(__s_00,__s,__n);
    pcVar3 = cli;
    iVar10 = (iVar11 + 1) % 0x100;
    cli->his_cur = iVar10;
    if (cVar2 != '\0') {
      while (iVar11 = (int)&pcVar3->initialized + iVar10, *(char *)(iVar11 + 0x144) != '\0') {
        *(undefined *)(iVar11 + 0x144) = 0;
        iVar10 = (iVar10 + 1) % 0x100;
      }
    }
  }
  auStack80[0] = 0;
  auStack80[1] = 0;
  auStack80[2] = 0;
  auStack80[3] = 0;
  memset(argvall_4310,0,0x100);
  memset(auStack80,0,0x10);
  memset(&uStack84,0,4);
  iVar10 = 0;
  puVar6 = auStack80;
  iVar11 = 0;
  do {
    __src = (byte *)(__s1 + iVar10);
    bVar1 = *__src;
    if (bVar1 != 0x20) {
      if (0x20 < bVar1) {
        if (bVar1 == 0x22) {
          if (((iVar10 == 0) || (__s_00 = __s1 + iVar10 + -1, *__s_00 != '\\')) ||
             ((uStack84 & 1) == 0)) {
            idx = uStack84 & 3;
            if (idx != 1) {
              if (idx == 2) goto LAB_2303049e;
              if (idx == 0) {
                idx = *puVar6;
                uStack84 = uStack84 & 0xfffffffc | 3;
                *puVar6 = idx + 1;
                *(char **)(argvall_4310 + (iVar11 * 0x10 + idx) * 4) = __s1 + iVar10 + 1;
              }
              else {
                if (idx == 3) {
                  uStack84._0_1_ = (byte)uStack84 & 0xfc;
                  goto LAB_23030464;
                }
              }
            }
          }
          else {
LAB_23030400:
            iVar10 = iVar10 + -1;
            __n = strlen((char *)__src);
            memcpy(__s_00,__src,__n + 1);
          }
        }
        else {
          if (bVar1 != 0x3b) goto LAB_2302fdce;
          if (((iVar10 != 0) && (__s_00 = __s1 + iVar10 + -1, *__s_00 == '\\')) &&
             ((uStack84 & 1) != 0)) goto LAB_23030400;
          if ((uStack84 & 2) != 0) goto LAB_2303049e;
          if ((uStack84 & 3) == 1) {
            uStack84 = uStack84 & 0xfffffffe;
            *__src = 0;
            if ((*puVar6 != 0) && (iVar11 = iVar11 + 1, iVar11 < 4)) {
              puVar6 = auStack80 + iVar11;
            }
          }
        }
        goto LAB_23030358;
      }
      if (bVar1 != 0) {
LAB_2302fdce:
        if ((uStack84 & 1) == 0) {
          idx = *puVar6;
          uStack84 = uStack84 | 1;
          *puVar6 = idx + 1;
          *(byte **)(argvall_4310 + (iVar11 * 0x10 + idx) * 4) = __src;
        }
        goto LAB_23030358;
      }
      if ((uStack84 & 2) == 0) {
        uStack84 = uStack84 | 4;
        goto LAB_23030358;
      }
LAB_2303049e:
      aos_cli_printf("syntax error\r\n");
      goto LAB_230303c0;
    }
    if (((iVar10 != 0) && (__s_00 = __s1 + iVar10 + -1, *__s_00 == '\\')) && ((uStack84 & 1) != 0))
    goto LAB_23030400;
    if ((uStack84 & 3) == 1) {
      uStack84._0_1_ = (byte)uStack84 & 0xfe;
LAB_23030464:
      uStack84 = uStack84 & 0xffffff00 | (uint)(byte)uStack84;
      *__src = 0;
    }
LAB_23030358:
  } while ((((uStack84 & 4) == 0) && (iVar10 = iVar10 + 1, iVar10 < 0x100)) &&
          ((iVar11 < 4 && ((int)*puVar6 < 0x10))));
  if ((uStack84 & 2) != 0) goto LAB_2303049e;
  puVar6 = auStack80;
  argv = argvall_4310;
  idx = 0;
  iVar10 = 0;
  do {
    iVar10 = iVar10 + 1;
    uVar8 = proc_onecmd(*puVar6,(char **)argv);
    idx = idx | uVar8;
    if (iVar11 < iVar10) break;
    puVar6 = puVar6 + 1;
    argv = (undefined1 *)((char **)argv + 0x10);
  } while (iVar10 != 4);
  if (idx == 1) {
    if (__s1 != (char *)0x0) {
      aos_cli_printf("command \'%s\' not found\r\n",__s1);
    }
  }
  else {
    if (idx == 2) goto LAB_2303049e;
  }
LAB_230303c0:
  aos_cli_printf("\r\n");
  esc_tag[0] = '\0';
  esc_tag_len = '\0';
  __s1 = "# ";
  goto LAB_2302fe04;
}



// WARNING: Variable defined which should be unmapped: qry
// WARNING: Could not reconcile some variable overlaps

void get_dns_request(void *arg,udp_pcb *upcb,pbuf *p,ip_addr_t *addr,u16_t port)

{
  u16_t uVar1;
  int iVar2;
  pbuf *buf;
  uint uVar3;
  char *dataptr;
  char *pcVar4;
  uint uVar5;
  uint local_50;
  int len;
  dns_ans_hdr hdr;
  dns_ans_hdr hdr_1;
  dns_ans_ans qry;
  
  *(udp_pcb **)((int)arg + 0x108) = upcb;
  *(ip_addr_t **)((int)arg + 0x10c) = addr;
  *(u16_t *)((int)arg + 0x110) = port;
  if (0xb < p->tot_len) {
    pbuf_copy_partial(p,&len,0xc,0);
    uVar1 = lwip_htons((u16_t)len);
    *(u16_t *)((int)arg + 0x100) = uVar1;
    uVar1 = lwip_htons(hdr.id);
    *(u16_t *)((int)arg + 0x102) = uVar1;
    local_50 = (uint)p->tot_len;
    if (0xff < p->tot_len) {
      local_50 = 0xff;
    }
    pbuf_copy_partial(p,arg,(u16_t)local_50,0xc);
    iVar2 = utils_dns_domain_get((uint8_t *)arg,(uint8_t *)arg,(int *)&local_50);
    if (iVar2 == 0) {
      if ((0 < (int)local_50) && (*(char *)((int)arg + (local_50 - 1)) == '.')) {
        local_50 = local_50 - 1;
      }
      *(undefined *)(local_50 + (int)arg) = 0;
    }
  }
  pbuf_free(p);
  buf = pbuf_alloc(PBUF_TRANSPORT,0x200,PBUF_RAM);
  if (buf != (pbuf *)0x0) {
    memset(&hdr.numauthrr,0,0xc);
    pcVar4 = (char *)((int)arg + -1);
    uVar3 = 0xc;
    hdr.numauthrr = lwip_htons(*(u16_t *)((int)arg + 0x100));
    hdr.numextrarr = lwip_htons(0x8180);
    hdr_1.id = lwip_htons(1);
    hdr_1.flag = lwip_htons(1);
    hdr_1.numquestions = lwip_htons(0);
    hdr_1.numanswers = lwip_htons(0);
    pbuf_take(buf,&hdr.numauthrr,0xc);
    do {
      dataptr = pcVar4 + 1;
      uVar5 = 0;
      pcVar4 = dataptr;
      while ((*pcVar4 != '.' && (*pcVar4 != '\0'))) {
        uVar5 = uVar5 + 1 & 0xff;
        pcVar4 = pcVar4 + 1;
      }
      pbuf_put_at(buf,(u16_t)uVar3,(u8_t)uVar5);
      pbuf_take_at(buf,dataptr,(u16_t)((uint)((int)(pcVar4 + -(int)dataptr) * 0x10000) >> 0x10),
                   (u16_t)((uVar3 + 1) * 0x10000 >> 0x10));
      uVar5 = uVar3 + uVar5 & 0xffff;
      uVar3 = uVar5 + 1 & 0xffff;
    } while (*pcVar4 != '\0');
    pbuf_put_at(buf,(u16_t)((uVar5 + 1) * 0x10000 >> 0x10),'\0');
    hdr_1.numauthrr = lwip_htons(1);
    hdr_1.numextrarr = lwip_htons(1);
    lwip_htons(0xc00c);
    lwip_htons(1);
    lwip_htons(1);
    lwip_htons(0);
    lwip_htonl(0x3c0004);
    lwip_htonl(0xc0a8a901);
    pbuf_take_at(buf,&hdr_1.numauthrr,0x14,(u16_t)((uVar5 + 2) * 0x10000 >> 0x10));
    pbuf_realloc(buf,(u16_t)((uVar5 + 0x16) * 0x10000 >> 0x10));
    udp_sendto(*(udp_pcb **)((int)arg + 0x108),buf,*(ip_addr_t **)((int)arg + 0x10c),
               *(u16_t *)((int)arg + 0x110));
    pbuf_free(buf);
  }
  return;
}



void dns_server_init(void)

{
  err_t eVar1;
  udp_pcb *pcb;
  undefined3 extraout_var;
  void *__s;
  
  pcb = udp_new();
  if (pcb == (udp_pcb *)0x0) {
    return;
  }
  eVar1 = udp_bind(pcb,&ip_addr_any,0x35);
  if ((CONCAT31(extraout_var,eVar1) == 0) && (__s = pvPortMalloc(0x114), __s != (void *)0x0)) {
    memset(__s,0,4);
    udp_recv(pcb,get_dns_request,__s);
    return;
  }
  udp_remove(pcb);
  return;
}



EfErrCode easyflash_init(void)

{
  EfErrCode EVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  char *format;
  size_t local_18;
  size_t default_env_set_size;
  ef_env *default_env_set;
  
  local_18 = 0;
  EVar1 = ef_port_init((ef_env **)&default_env_set_size,&local_18);
  if ((CONCAT31(extraout_var,EVar1) == 0) &&
     (EVar1 = ef_env_init((ef_env *)default_env_set_size,local_18),
     CONCAT31(extraout_var_00,EVar1) == 0)) {
    format = "EasyFlash V%s is initialize success.\r\n";
  }
  else {
    format = "EasyFlash V%s is initialize fail.\r\n";
  }
  ef_log_info(format,&UNK_23077e28);
  ef_log_info("You can get the latest version on https://github.com/armink/EasyFlash .\r\n");
  return EVar1;
}



size_t get_status(uint8_t *status_table,size_t status_num)

{
  size_t sVar1;
  size_t sVar2;
  
  sVar2 = status_num - 1;
  do {
    sVar1 = sVar2;
    sVar2 = sVar1 - 1;
    if (sVar2 == 0xffffffff) {
      return sVar1;
    }
  } while (status_table[sVar2] != '\0');
  return sVar1;
}



void update_sector_cache(uint32_t sec_addr,uint32_t empty_addr)

{
  sector_cache_node *psVar1;
  int iVar2;
  int iVar3;
  uint32_t uVar4;
  
  psVar1 = sector_cache_table;
  iVar2 = 4;
  iVar3 = 0;
  do {
    uVar4 = psVar1->addr;
    if ((sec_addr < empty_addr) && (empty_addr < sec_addr + 0x1000)) {
      if (sec_addr == uVar4) {
        psVar1 = sector_cache_table + iVar3;
        goto LAB_2303081c;
      }
      if ((uVar4 == 0xffffffff) && (iVar2 == 4)) {
        iVar2 = iVar3;
      }
    }
    else {
      if (sec_addr == uVar4) {
        sector_cache_table[iVar3].addr = 0xffffffff;
        return;
      }
    }
    iVar3 = iVar3 + 1;
    psVar1 = psVar1 + 1;
  } while (iVar3 != 4);
  if (iVar2 != 4) {
    psVar1 = sector_cache_table + iVar2;
    psVar1->addr = sec_addr;
LAB_2303081c:
    psVar1->empty_addr = empty_addr;
  }
  return;
}



uint32_t get_next_sector_addr(sector_meta_data_t pre_sec)

{
  uint uVar1;
  int iVar2;
  
  uVar1 = env_start_addr;
  if (pre_sec->addr != 0xffffffff) {
    if (pre_sec->combined == 0xffffffff) {
      iVar2 = 0x1000;
    }
    else {
      iVar2 = pre_sec->combined << 0xc;
    }
    uVar1 = iVar2 + pre_sec->addr;
    if (env_start_addr + 0x8000 <= uVar1) {
      return 0xffffffff;
    }
  }
  return uVar1;
}



_Bool gc_check_cb(sector_meta_data_t sector,void *arg1,void *arg2)

{
  if (sector->check_ok != false) {
    *(int *)arg1 = *(int *)arg1 + 1;
  }
  return false;
}



void update_env_cache(char *name,size_t name_len,uint32_t addr)

{
  uint32_t uVar1;
  int iVar2;
  env_cache_node *peVar3;
  int iVar4;
  int iVar5;
  ushort uVar6;
  
  uVar1 = ef_calc_crc32(0,name,name_len);
  peVar3 = env_cache_table;
  uVar6 = 0xffff;
  iVar5 = 0x10;
  iVar2 = 0x10;
  iVar4 = 0;
  do {
    if (addr == 0xffffffff) {
      if ((uint)peVar3->name_crc == uVar1 >> 0x10) {
        peVar3 = env_cache_table + iVar4;
        env_cache_table[iVar4].addr = 0xffffffff;
        goto LAB_2303091a;
      }
    }
    else {
      if ((uint)peVar3->name_crc == uVar1 >> 0x10) {
        env_cache_table[iVar4].addr = addr;
        return;
      }
      if (peVar3->addr == 0xffffffff) {
        if (iVar2 == 0x10) {
          iVar2 = iVar4;
        }
      }
      else {
        if (peVar3->active != 0) {
          peVar3->active = peVar3->active - 1;
        }
        if (peVar3->active < uVar6) {
          iVar5 = iVar4;
          uVar6 = peVar3->active;
        }
      }
    }
    iVar4 = iVar4 + 1;
    peVar3 = peVar3 + 1;
  } while (iVar4 != 0x10);
  if ((iVar2 != 0x10) || (iVar2 = iVar5, iVar5 != 0x10)) {
    peVar3 = env_cache_table + iVar2;
    env_cache_table[iVar2].addr = addr;
    peVar3->name_crc = (uint16_t)(uVar1 >> 0x10);
LAB_2303091a:
    peVar3->active = 0;
  }
  return;
}



_Bool find_env_cb(env_node_obj_t env,void *arg1,void *arg2)

{
  _Bool _Var1;
  size_t sVar2;
  int iVar3;
  
  sVar2 = strlen((char *)arg1);
  if (((((uint)env->name_len == sVar2) && (_Var1 = env->crc_is_ok, _Var1 != false)) &&
      (env->status == ENV_WRITE)) &&
     (iVar3 = strncmp(env->name,(char *)arg1,(uint)env->name_len), iVar3 == 0)) {
    *(undefined *)arg2 = 1;
  }
  else {
    _Var1 = false;
  }
  return _Var1;
}



_Bool sector_statistics_cb(sector_meta_data_t sector,void *arg1,void *arg2)

{
  sector_store_status_t sVar1;
  
  if (sector->check_ok != false) {
    sVar1 = (sector->status).store;
    if (sVar1 == SECTOR_STORE_EMPTY) {
      *(int *)arg1 = *(int *)arg1 + 1;
    }
    else {
      if (sVar1 == SECTOR_STORE_USING) {
        *(int *)arg2 = *(int *)arg2 + 1;
      }
    }
  }
  return false;
}



_Bool alloc_env_cb(sector_meta_data_t sector,void *arg1,void *arg2)

{
  sector_dirty_status_t sVar1;
  _Bool _Var2;
  
  _Var2 = sector->check_ok;
  if (_Var2 != false) {
    if ((*(uint *)arg1 < sector->remain) &&
       ((sVar1 = (sector->status).dirty, sVar1 == SECTOR_DIRTY_FALSE ||
        ((sVar1 == SECTOR_DIRTY_TRUE && (gc_request == false)))))) {
      *(uint32_t *)arg2 = sector->empty_env;
    }
    else {
      _Var2 = false;
    }
  }
  return _Var2;
}



EfErrCode write_status(uint32_t addr,uint8_t *status_table,size_t status_num,size_t status_index)

{
  EfErrCode EVar1;
  
  if (status_num <= status_index) {
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x111,
                 "(%s) has assert failed at %s.\r\n","status_index < status_num","write_status");
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  if (status_table == (uint8_t *)0x0) {
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x112,
                 "(%s) has assert failed at %s.\r\n","status_table","write_status");
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  memset(status_table,0xff,status_num * 8 - 1 >> 3);
  status_table[status_index - 1] = 0;
  EVar1 = ef_port_write(addr + (status_index - 1),(uint32_t *)(status_table + (status_index - 1)),1)
  ;
  return EVar1;
}



// WARNING: Could not reconcile some variable overlaps

EfErrCode read_env(env_node_obj_t env)

{
  char "read_env" [9];
  uint uVar1;
  uint32_t crc;
  size_t size;
  uint uVar2;
  uint32_t uStack92;
  env_hdr_data env_hdr;
  uint8_t buf [32];
  
  ef_port_read((env->addr).start,&uStack92,0x1c);
  size = get_status((uint8_t *)&uStack92,6);
  env->status = (env_status_t)(size & 0xff);
  env->len = env_hdr.magic;
  uVar2 = env_hdr.magic - 0x14;
  if (uVar2 < 0x7fed) {
    if (env_hdr.magic - 0xfed < 0x7013) {
      ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x223
                   ,"(%s) has assert failed at %s.\r\n",0x2307cdb4,"read_env");
      do {
                    // WARNING: Do nothing block with infinite loop
      } while( true );
    }
    uVar1 = 0;
    crc = 0;
    while (uVar1 < uVar2) {
      size = 0x20;
      if (uVar2 <= uVar1 + 0x20) {
        size = uVar2 - uVar1;
      }
      ef_port_read((env->addr).start + 0x14 + uVar1,&env_hdr.value_len,size);
      crc = ef_calc_crc32(crc,&env_hdr.value_len,size);
      uVar1 = uVar1 + size;
    }
    if (env_hdr.len == crc) {
      crc = (env->addr).start + 0x1c;
      env->crc_is_ok = true;
      ef_port_read(crc,(uint32_t *)env->name,(uint)(byte)env_hdr.crc32);
      (env->addr).value = crc + (byte)env_hdr.crc32;
      env->value_len = env_hdr._20_4_;
      env->name_len = (byte)env_hdr.crc32;
      return EF_NO_ERR;
    }
  }
  else {
    env->len = 0x1c;
    if ((size & 0xff) != 5) {
      env->status = ENV_ERR_HDR;
      ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x21c
                   ,"Error: The ENV @0x%08X length has an error.\r\n",(env->addr).start);
      write_status((env->addr).start,(uint8_t *)&uStack92,6,5);
    }
  }
  env->crc_is_ok = false;
  return EF_READ_ERR;
}



// WARNING: Variable defined which should be unmapped: status_table

EfErrCode update_sec_status(sector_meta_data_t sector,size_t new_env_len,_Bool *is_full)

{
  sector_store_status_t sVar1;
  EfErrCode EVar2;
  uint8_t auStack20 [4];
  uint8_t status_table [3];
  
  sVar1 = (sector->status).store;
  if (sVar1 == SECTOR_STORE_EMPTY) {
    EVar2 = write_status(sector->addr,auStack20,4,2);
  }
  else {
    EVar2 = EF_NO_ERR;
    if (sVar1 == SECTOR_STORE_USING) {
      if ((sector->remain < 0x5c) || (sector->remain - new_env_len < 0x5c)) {
        EVar2 = write_status(sector->addr,auStack20,4,3);
        update_sector_cache(sector->addr,sector->addr + 0x1000);
        if (is_full != (_Bool *)0x0) {
          *is_full = true;
        }
      }
      else {
        if (is_full != (_Bool *)0x0) {
          *is_full = false;
        }
      }
    }
  }
  return EVar2;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Could not reconcile some variable overlaps

EfErrCode format_sector(uint32_t addr)

{
  EfErrCode EVar1;
  undefined3 extraout_var;
  undefined uStack36;
  undefined uStack33;
  sector_hdr_data sec_hdr;
  
  if ((addr & 0xfff) != 0) {
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x3b5,
                 "(%s) has assert failed at %s.\r\n","addr % SECTOR_SIZE == 0","format_sector");
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  EVar1 = ef_port_erase(addr,0x1000);
  if (CONCAT31(extraout_var,EVar1) == 0) {
    memset(&uStack36,0xff,0x14);
    memset(&uStack36,0xff,3);
    uStack36 = 0;
    memset(&uStack36 + 3,0xff,3);
    sec_hdr._4_4_ = 0x30344645;
    uStack33 = 0;
    sec_hdr.magic = 0xffffffff;
    sec_hdr.combined = 0xffffffff;
    EVar1 = ef_port_write(addr,&uStack36,0x14);
    update_sector_cache(addr,addr + 0x1000);
  }
  return EVar1;
}



_Bool check_sec_hdr_cb(sector_meta_data_t sector,void *arg1,void *arg2)

{
  if (sector->check_ok == false) {
    ef_log_info("Warning: Sector header check failed. Format this sector (0x%08x).\r\n",sector->addr
               );
    *(int *)arg1 = *(int *)arg1 + 1;
    format_sector(sector->addr);
    return false;
  }
  return false;
}



// WARNING: Variable defined which should be unmapped: buf

uint32_t get_next_env_addr(sector_meta_data_t sector,env_node_obj_t pre_env)

{
  uint uVar1;
  uint32_t uVar2;
  sector_cache_node *psVar3;
  uint addr;
  int iVar4;
  uint32_t *puVar5;
  uint32_t uVar6;
  uint32_t local_40;
  uint8_t buf [32];
  
  if ((sector->status).store != SECTOR_STORE_EMPTY) {
    addr = (pre_env->addr).start;
    uVar6 = sector->addr;
    if (addr == 0xffffffff) {
      return uVar6 + 0x14;
    }
    if (addr <= uVar6 + 0x1000) {
      uVar1 = addr + 1;
      if (pre_env->crc_is_ok != false) {
        uVar1 = pre_env->len + addr;
      }
      psVar3 = sector_cache_table;
      iVar4 = 0;
      do {
        if ((uVar1 & 0xfffff000) == psVar3->addr) {
          if (uVar1 == sector_cache_table[iVar4].empty_addr) goto LAB_23030d60;
          break;
        }
        iVar4 = iVar4 + 1;
        psVar3 = psVar3 + 1;
      } while (iVar4 != 4);
      addr = uVar1;
      while (addr < uVar6 + 0xfec) {
        ef_port_read(addr,&local_40,0x20);
        uVar2 = addr - 8;
        puVar5 = &local_40;
        do {
          if (uVar6 + 0xfe4 == uVar2) break;
          if ((*puVar5 == 0x3034564b) && (uVar1 <= uVar2)) goto LAB_23030d62;
          uVar2 = uVar2 + 1;
          puVar5 = (uint32_t *)((int)puVar5 + 1);
        } while (addr + 0x14 != uVar2);
        addr = addr + 0x1c;
      }
LAB_23030d60:
      uVar2 = 0xffffffff;
LAB_23030d62:
      if ((sector->addr + 0x1000 < uVar2) || (pre_env->len == 0)) {
        uVar2 = 0xffffffff;
      }
      return uVar2;
    }
  }
  return 0xffffffff;
}



// WARNING: Could not reconcile some variable overlaps

EfErrCode read_sector_meta_data(uint32_t addr,sector_meta_data_t sector,_Bool traversal)

{
  char cVar1;
  EfErrCode EVar2;
  uint uVar3;
  size_t size;
  undefined3 in_register_00002031;
  sector_cache_node *psVar4;
  int iVar5;
  uint32_t uVar6;
  uint32_t uVar7;
  size_t sVar8;
  uint addr_00;
  char cVar9;
  uint32_t uVar10;
  undefined4 uStack188;
  sector_hdr_data sec_hdr;
  uint8_t buf [32];
  env_node_obj env_meta;
  
  if ((addr & 0xfff) != 0) {
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x24a,
                 "(%s) has assert failed at %s.\r\n","addr % SECTOR_SIZE == 0",
                 "read_sector_meta_data");
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  ef_port_read(addr,&uStack188,0x14);
  sector->addr = addr;
  sector->magic = sec_hdr._4_4_;
  if (sec_hdr._4_4_ == 0x30344645) {
    sector->combined = sec_hdr.magic;
    sector->check_ok = true;
    size = get_status((uint8_t *)&uStack188,4);
    uVar3 = size & 0xff;
    EVar2 = (EfErrCode)uVar3;
    (sector->status).store = EVar2;
    size = get_status((uint8_t *)((int)&uStack188 + 3),4);
    (sector->status).dirty = (sector_dirty_status_t)size;
    if (CONCAT31(in_register_00002031,traversal) != 0) {
      sector->remain = 0;
      sector->empty_env = addr + 0x14;
      if (uVar3 == 1) {
        sector->remain = 0xfec;
      }
      else {
        if (uVar3 == 2) {
          psVar4 = sector_cache_table;
          iVar5 = 0;
          do {
            if (addr == psVar4->addr) {
              uVar6 = sector_cache_table[iVar5].empty_addr;
              sector->empty_env = uVar6;
              sector->remain = (addr + 0x1000) - uVar6;
              goto LAB_23030eae;
            }
            iVar5 = iVar5 + 1;
            psVar4 = psVar4 + 1;
          } while (iVar5 != 4);
          sector->remain = 0xfec;
          do {
            uVar6 = get_next_env_addr(sector,(env_node_obj_t)(buf + 0x1c));
            if (uVar6 == 0xffffffff) {
              EVar2 = EF_NO_ERR;
LAB_23030f4c:
              uVar7 = sector->addr;
              uVar6 = sector->empty_env;
              uVar3 = uVar7 + 0x1000;
              cVar9 = '\0';
              uVar10 = uVar6;
              while (addr_00 = uVar10, addr_00 < uVar3) {
                uVar10 = addr_00 + 0x20;
                size = 0x20;
                if (uVar3 <= uVar10) {
                  size = (uVar7 + 0x1020) - uVar10;
                }
                ef_port_read(addr_00,&sec_hdr.reserved,size);
                sVar8 = 0;
                while (size != sVar8) {
                  cVar1 = *(char *)((int)&sec_hdr.reserved + sVar8);
                  if ((cVar9 != -1) && (cVar1 == -1)) {
                    uVar6 = addr_00 + sVar8;
                  }
                  sVar8 = sVar8 + 1;
                  cVar9 = cVar1;
                }
              }
              if (cVar9 != -1) {
                uVar6 = uVar3;
              }
              if (sector->empty_env != uVar6) {
                sector->empty_env = uVar6;
                sector->remain = (sector->addr + 0x1000) - uVar6;
              }
              update_sector_cache(sector->addr,sector->empty_env);
              return EVar2;
            }
            read_env((env_node_obj_t)(buf + 0x1c));
            if ((buf[29] == '\0') && ((buf[28] & 0xfb) != 1)) {
              ef_log_info("Error: The ENV (@0x%08X) CRC32 check failed!\r\n",uVar6);
              sector->remain = 0;
              goto LAB_23030f4c;
            }
            sector->empty_env = sector->empty_env + env_meta.magic;
            sector->remain = sector->remain - env_meta.magic;
          } while( true );
        }
      }
    }
LAB_23030eae:
    EVar2 = EF_NO_ERR;
  }
  else {
    sector->check_ok = false;
    sector->combined = 0xffffffff;
    EVar2 = EF_ENV_INIT_FAILED;
  }
  return EVar2;
}



void sector_iterator(sector_meta_data_t sector,sector_store_status_t status,void *arg1,void *arg2,
                    anon_subr__Bool_sector_meta_data_t_void_ptr_void_ptr *callback,
                    _Bool traversal_env)

{
  _Bool _Var1;
  uint32_t addr;
  undefined3 extraout_var;
  undefined3 in_register_0000202d;
  undefined3 in_register_0000203d;
  
  sector->addr = 0xffffffff;
  do {
    do {
      addr = get_next_sector_addr(sector);
      if (addr == 0xffffffff) {
        return;
      }
      read_sector_meta_data(addr,sector,false);
    } while ((CONCAT31(in_register_0000202d,status) != 0) &&
            ((uint)(sector->status).store != CONCAT31(in_register_0000202d,status)));
    if (CONCAT31(in_register_0000203d,traversal_env) != 0) {
      read_sector_meta_data(addr,sector,true);
    }
    _Var1 = (*callback)(sector,arg1,arg2);
  } while (CONCAT31(extraout_var,_Var1) == 0);
  return;
}



// WARNING: Variable defined which should be unmapped: using_sector

uint32_t alloc_env(sector_meta_data_t sector,size_t env_size)

{
  size_t asStack36 [2];
  uint32_t local_1c;
  uint32_t empty_env;
  size_t empty_sector;
  size_t using_sector;
  
  local_1c = 0xffffffff;
  empty_env = 0;
  empty_sector = 0;
  asStack36[0] = env_size;
  sector_iterator(sector,SECTOR_STORE_UNUSED,&empty_env,&empty_sector,sector_statistics_cb,false);
  if (empty_sector != 0) {
    sector_iterator(sector,SECTOR_STORE_USING,asStack36,&local_1c,alloc_env_cb,true);
  }
  if ((empty_env != 0) && (local_1c == 0xffffffff)) {
    if ((empty_env < 2) && (gc_request == false)) {
      ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x42d
                   ,"Trigger a GC check after alloc ENV failed.\r\n");
      gc_request = true;
    }
    else {
      sector_iterator(sector,SECTOR_STORE_EMPTY,asStack36,&local_1c,alloc_env_cb,true);
    }
  }
  return local_1c;
}



void gc_collect(void)

{
  uint uStack44;
  size_t empty_sec;
  sector_meta_data sector;
  
  uStack44 = 0;
  sector_iterator((sector_meta_data_t)&empty_sec,SECTOR_STORE_EMPTY,&uStack44,(void *)0x0,
                  gc_check_cb,false);
  ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x4fa,
               "The remain empty sector is %d, GC threshold is %d.\r\n",uStack44,1);
  if (uStack44 < 2) {
    sector_iterator((sector_meta_data_t)&empty_sec,SECTOR_STORE_UNUSED,(void *)0x0,(void *)0x0,do_gc
                    ,false);
  }
  gc_request = false;
  return;
}



uint32_t new_env(sector_meta_data_t sector,size_t env_size)

{
  uint32_t uVar1;
  
  uVar1 = alloc_env(sector,env_size);
  if ((uVar1 == 0xffffffff) && (gc_request != false)) {
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x4b6,
                 "Warning: Alloc an ENV (size %d) failed when new ENV. Now will GC then retry.\r\n",
                 env_size);
    gc_collect();
    uVar1 = alloc_env(sector,env_size);
  }
  return uVar1;
}



_Bool check_and_recovery_gc_cb(sector_meta_data_t sector,void *arg1,void *arg2)

{
  if ((sector->check_ok != false) && ((sector->status).dirty == SECTOR_DIRTY_GC)) {
    gc_request = true;
    gc_collect();
    return false;
  }
  return false;
}



// WARNING: Could not reconcile some variable overlaps

void env_iterator(env_node_obj_t env,void *arg1,void *arg2,
                 anon_subr__Bool_env_node_obj_t_void_ptr_void_ptr *callback)

{
  EfErrCode EVar1;
  _Bool _Var2;
  uint32_t addr;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined uStack56;
  sector_store_status_t sStack55;
  sector_meta_data sector;
  
  sector._0_4_ = 0xffffffff;
  do {
    do {
      addr = get_next_sector_addr((sector_meta_data_t)&uStack56);
      if (addr == 0xffffffff) {
        return;
      }
      EVar1 = read_sector_meta_data(addr,(sector_meta_data_t)&uStack56,false);
    } while ((CONCAT31(extraout_var,EVar1) != 0) || (1 < (byte)(sStack55 + ~SECTOR_STORE_EMPTY)));
    (env->addr).start = 0xffffffff;
    while( true ) {
      addr = get_next_env_addr((sector_meta_data_t)&uStack56,env);
      (env->addr).start = addr;
      if (addr == 0xffffffff) break;
      read_env(env);
      _Var2 = (*callback)(env,arg1,arg2);
      if (CONCAT31(extraout_var_00,_Var2) != 0) {
        return;
      }
    }
  } while( true );
}



_Bool find_env(char *key,env_node_obj_t env)

{
  char cVar1;
  int iVar2;
  size_t size;
  uint32_t uVar3;
  int iVar4;
  uint16_t uVar5;
  env_cache_node *peVar6;
  char local_70;
  char saved_name [64];
  
  size = strlen(key);
  uVar3 = ef_calc_crc32(0,key,size);
  peVar6 = env_cache_table;
  iVar2 = 0;
  do {
    if ((peVar6->addr != 0xffffffff) && ((uint)peVar6->name_crc == uVar3 >> 0x10)) {
      ef_port_read(peVar6->addr + 0x1c,&local_70,0x40);
      iVar4 = strncmp(key,(char *)&local_70,size);
      if (iVar4 == 0) {
        (env->addr).start = env_cache_table[iVar2].addr;
        uVar5 = 0xffff;
        if (env_cache_table[iVar2].active < 0xffef) {
          uVar5 = env_cache_table[iVar2].active + 0x10;
        }
        env_cache_table[iVar2].active = uVar5;
        read_env(env);
        return true;
      }
    }
    iVar2 = iVar2 + 1;
    peVar6 = peVar6 + 1;
  } while (iVar2 != 0x10);
  local_70 = '\0';
  env_iterator(env,key,&local_70,find_env_cb);
  cVar1 = local_70;
  if (local_70 != '\0') {
    update_env_cache(key,size,(env->addr).start);
  }
  return (_Bool)cVar1;
}



EfErrCode del_env(char *key,env_node_obj_t old_env,_Bool complete_del)

{
  _Bool last_is_complete_del;
  int iVar1;
  _Bool _Var2;
  EfErrCode EVar3;
  undefined3 extraout_var;
  uint32_t addr;
  undefined3 extraout_var_00;
  size_t sVar4;
  undefined3 extraout_var_01;
  size_t name_len;
  undefined3 in_register_00002031;
  uint32_t uStack128;
  uint8_t status_table [5];
  env_node_obj env;
  
  if (old_env == (env_node_obj_t)0x0) {
    _Var2 = find_env(key,(env_node_obj_t)(status_table + 4));
    if (CONCAT31(extraout_var,_Var2) == 0) {
      ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x447
                   ,"Not found \'%s\' in ENV.\r\n",key);
      return EF_ENV_NAME_ERR;
    }
    old_env = (env_node_obj_t)(status_table + 4);
  }
  addr = (old_env->addr).start;
  if (CONCAT31(in_register_00002031,complete_del) == 0) {
    EVar3 = write_status(addr,(uint8_t *)&uStack128,6,3);
    iVar1 = CONCAT31(extraout_var_00,EVar3);
    last_is_complete_del = true;
  }
  else {
    EVar3 = write_status(addr,(uint8_t *)&uStack128,6,4);
    iVar1 = CONCAT31(extraout_var_01,EVar3);
    if ((last_is_complete_del == false) && (iVar1 == 0)) {
      if (key == (char *)0x0) {
        name_len = (size_t)old_env->name_len;
        key = old_env->name;
      }
      else {
        name_len = strlen(key);
      }
      update_env_cache(key,name_len,0xffffffff);
    }
    last_is_complete_del = false;
  }
  EVar3 = (EfErrCode)iVar1;
  if (iVar1 == 0) {
    addr = ((old_env->addr).start & 0xfffff000) + 3;
    ef_port_read(addr,&uStack128,3);
    sVar4 = get_status((uint8_t *)&uStack128,4);
    if (sVar4 == 1) {
      EVar3 = write_status(addr,(uint8_t *)&uStack128,4,2);
    }
  }
  return EVar3;
}



EfErrCode move_env(env_node_obj_t env)

{
  EfErrCode EVar1;
  uint32_t addr;
  uint uVar2;
  size_t new_env_len;
  uint uVar3;
  char *__src;
  char cStack229;
  undefined auStack228 [3];
  _Bool find_ok;
  sector_meta_data sector;
  uint8_t status_table [5];
  undefined auStack136 [4];
  env_node_obj env_bak;
  
  if (env->status == ENV_WRITE) {
    del_env((char *)0x0,env,false);
  }
  addr = alloc_env((sector_meta_data_t)auStack228,env->len);
  if (addr == 0xffffffff) {
    return EF_ENV_FULL;
  }
  __src = env->name;
  if (in_recovery_check != false) {
    memset(&sector.empty_env,0,0x41);
    strncpy((char *)&sector.empty_env,__src,(uint)env->name_len);
    cStack229 = '\0';
    env_iterator((env_node_obj_t)auStack136,&sector.empty_env,&cStack229,find_env_cb);
    EVar1 = EF_NO_ERR;
    if (cStack229 != '\0') goto __exit;
  }
  new_env_len = env->len;
  update_sec_status((sector_meta_data_t)auStack228,new_env_len,(_Bool *)0x0);
  write_status(addr,(uint8_t *)&sector.empty_env,6,1);
  uVar3 = new_env_len - 8;
  uVar2 = 0;
  EVar1 = EF_NO_ERR;
  while (uVar2 < uVar3) {
    new_env_len = 0x20;
    if (uVar3 <= uVar2 + 0x20) {
      new_env_len = uVar3 - uVar2;
    }
    ef_port_read((env->addr).start + 8 + uVar2,(uint32_t *)auStack136,new_env_len);
    EVar1 = ef_port_write(addr + 8 + uVar2,(uint32_t *)auStack136,new_env_len);
    uVar2 = uVar2 + new_env_len;
  }
  write_status(addr,(uint8_t *)&sector.empty_env,6,2);
  update_sector_cache(addr & 0xfffff000,env->value_len + 0x1c + (uint)env->name_len + addr);
  update_env_cache(__src,(uint)env->name_len,addr);
  ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x4a6,
               "Moved the ENV (%.*s) from 0x%08X to 0x%08X.\r\n",(uint)env->name_len,__src,
               (env->addr).start,addr);
__exit:
  del_env((char *)0x0,env,true);
  return EVar1;
}



_Bool check_and_recovery_env_cb(env_node_obj_t env,void *arg1,void *arg2)

{
  _Bool _Var1;
  EfErrCode EVar2;
  undefined3 extraout_var;
  uint8_t auStack24 [4];
  uint8_t status_table [5];
  
  _Var1 = env->crc_is_ok;
  if ((_Var1 == false) || (env->status != ENV_PRE_DELETE)) {
    _Var1 = false;
    if (env->status == ENV_PRE_WRITE) {
      write_status((env->addr).start,auStack24,6,5);
      _Var1 = true;
    }
  }
  else {
    ef_log_info("Found an ENV (%.*s) which has changed value failed. Now will recovery it.\r\n",
                (uint)env->name_len,env->name);
    EVar2 = move_env(env);
    if (CONCAT31(extraout_var,EVar2) == 0) {
      ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x6d5
                   ,"Recovery the ENV successful.\r\n");
      _Var1 = false;
    }
    else {
      ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x6d7
                   ,
                   "Warning: Moved an ENV (size %d) failed when recovery. Now will GC then retry.\r\n"
                   ,env->len);
    }
  }
  return _Var1;
}



// WARNING: Could not reconcile some variable overlaps

_Bool do_gc(sector_meta_data_t sector,void *arg1,void *arg2)

{
  EfErrCode EVar1;
  undefined3 extraout_var;
  uint8_t auStack124 [4];
  uint8_t status_table [3];
  env_node_obj env;
  
  if ((sector->check_ok != false) && ((byte)((sector->status).dirty + ~SECTOR_DIRTY_FALSE) < 2)) {
    write_status(sector->addr + 3,auStack124,4,3);
    env.name._60_4_ = 0xffffffff;
    while( true ) {
      env.name._60_4_ = get_next_env_addr(sector,(env_node_obj_t)status_table);
      if (env.name._60_4_ == 0xffffffff) break;
      read_env((env_node_obj_t)status_table);
      if ((((_Bool)status_table[1] != false) && ((byte)(status_table[0] + ~ENV_PRE_WRITE) < 2)) &&
         (EVar1 = move_env((env_node_obj_t)status_table), CONCAT31(extraout_var,EVar1) != 0)) {
        ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",
                     0x4e1,"Error: Moved the ENV (%.*s) for GC failed.\r\n",(uint)status_table[2],
                     &env.value_len);
      }
    }
    format_sector(sector->addr);
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x4e6,
                 "Collect a sector @0x%08X\r\n",sector->addr);
    return false;
  }
  return false;
}



// WARNING: Could not reconcile some variable overlaps

EfErrCode create_env_blob(sector_meta_data_t sector,char *key,void *value,size_t len)

{
  size_t size;
  uint size_00;
  uint32_t addr;
  EfErrCode EVar1;
  size_t sVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  undefined auStack64 [3];
  _Bool _Stack61;
  uint8_t align_data [1];
  _Bool is_full;
  env_hdr_data env_hdr;
  
  addr = sector->empty_env;
  _Stack61 = false;
  sVar2 = strlen(key);
  if (sVar2 < 0x41) {
    memset(align_data,0xff,0x1c);
    env_hdr._4_4_ = 0x3034564b;
    sVar2 = strlen(key);
    env_hdr.crc32._0_1_ = (byte)sVar2;
    env_hdr.magic = len + 0x1c + (sVar2 & 0xff);
    env_hdr._20_4_ = len;
    if (env_hdr.magic < 0xfed) {
      if ((addr == 0xffffffff) && (addr = new_env(sector,env_hdr.magic), addr == 0xffffffff)) {
        return EF_ENV_FULL;
      }
      EVar1 = update_sec_status(sector,env_hdr.magic,&_Stack61);
      if (CONCAT31(extraout_var,EVar1) == 0) {
        env_hdr.len = ef_calc_crc32(0,&env_hdr.crc32,8);
        env_hdr.len = ef_calc_crc32(env_hdr.len,key,(uint)(byte)env_hdr.crc32);
        env_hdr.len = ef_calc_crc32(env_hdr.len,value,env_hdr._20_4_);
        EVar1 = write_status(addr,align_data,6,1);
        if ((CONCAT31(extraout_var_00,EVar1) == 0) &&
           (EVar1 = ef_port_write(addr + 8,(uint32_t *)(env_hdr.status_table + 4),0x14),
           CONCAT31(extraout_var_01,EVar1) == 0)) {
          size_00 = (uint)(byte)env_hdr.crc32;
          memset(auStack64,0xff,1);
          EVar1 = ef_port_write(addr + 0x1c,(uint32_t *)key,size_00);
          if (_Stack61 == false) {
            update_sector_cache(sector->addr,
                                env_hdr._20_4_ + 0x1c + (uint)(byte)env_hdr.crc32 + addr);
          }
          update_env_cache(key,(uint)(byte)env_hdr.crc32,addr);
          size = env_hdr._20_4_;
          if (CONCAT31(extraout_var_02,EVar1) == 0) {
            size_00 = (uint)(byte)env_hdr.crc32;
            memset(auStack64,0xff,1);
            EVar1 = ef_port_write(size_00 + 0x1c + addr,(uint32_t *)value,size);
            if (((CONCAT31(extraout_var_03,EVar1) == 0) &&
                (EVar1 = write_status(addr,align_data,6,2), CONCAT31(extraout_var_04,EVar1) == 0))
               && (_Stack61 != false)) {
              ef_log_debug(
                           "/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c"
                           ,0x562,"Trigger a GC check after created ENV.\r\n");
              gc_request = true;
            }
          }
        }
      }
    }
    else {
      ef_log_info("Error: The ENV size is too big\r\n");
      EVar1 = EF_ENV_FULL;
    }
  }
  else {
    ef_log_info("Error: The ENV name length is more than %d\r\n",0x40);
    EVar1 = EF_ENV_NAME_ERR;
  }
  return EVar1;
}



size_t ef_get_env_blob(char *key,void *value_buf,size_t buf_len,size_t *saved_value_len)

{
  size_t sVar1;
  _Bool _Var2;
  TickType_t TVar3;
  char *format;
  size_t sVar4;
  undefined3 extraout_var;
  undefined4 uVar5;
  undefined auStack120 [4];
  env_node_obj env;
  
  if (init_ok == false) {
    ef_log_info("ENV isn\'t initialize OK.\r\n");
    sVar1 = 0;
  }
  else {
    if ((key == (char *)0x0) || (value_buf == (void *)0x0)) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      uVar5 = 0x34c;
      format = "[%10u][%s: %s:%4d] key = %p, value_buf = %p\r\n";
    }
    else {
      sVar4 = strlen(key);
      if (sVar4 < 0x41) {
        ef_port_env_lock();
        _Var2 = find_env(key,(env_node_obj_t)auStack120);
        sVar1 = 0;
        if (CONCAT31(extraout_var,_Var2) != 0) {
          if (saved_value_len != (size_t *)0x0) {
            *saved_value_len = env.len;
          }
          if (env.len < buf_len) {
            buf_len = env.len;
          }
          ef_port_read(env.addr.start,(uint32_t *)value_buf,buf_len);
          sVar1 = buf_len;
        }
        ef_port_env_unlock();
        return sVar1;
      }
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      key = (char *)strlen(key);
      value_buf = (void *)0x40;
      uVar5 = 0x351;
      format = "[%10u][%s: %s:%4d] key err. %d > %d\r\n";
    }
    bl_printk(format,TVar3,&DAT_230781b4,&UNK_230781a8,uVar5,key,value_buf);
    sVar1 = 8;
  }
  return sVar1;
}



EfErrCode ef_set_env_blob(char *key,void *value_buf,size_t buf_len)

{
  _Bool _Var1;
  EfErrCode EVar2;
  TickType_t TVar3;
  char *format;
  size_t sVar4;
  uint32_t uVar5;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined4 uVar6;
  
  if (init_ok == false) {
    ef_log_info("ENV isn\'t initialize OK.\r\n");
    return EF_ENV_INIT_FAILED;
  }
  if ((key == (char *)0x0) || (value_buf == (void *)0x0)) {
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    uVar6 = 0x5d4;
    format = "[%10u][%s: %s:%4d] key = %p, value_buf = %p\r\n";
  }
  else {
    sVar4 = strlen(key);
    if (sVar4 < 0x41) {
      if (buf_len < 0xf8d) {
        ef_port_env_lock();
        sVar4 = strlen(key);
        uVar5 = new_env((sector_meta_data_t)sector_3152,buf_len + 0x1c + sVar4);
        EVar2 = EF_ENV_FULL;
        if (uVar5 != 0xffffffff) {
          _Var1 = find_env(key,(env_node_obj_t)env_3151);
          if ((CONCAT31(extraout_var,_Var1) == 0) ||
             (EVar2 = del_env(key,(env_node_obj_t)env_3151,false),
             CONCAT31(extraout_var_01,EVar2) == 0)) {
            EVar2 = create_env_blob((sector_meta_data_t)sector_3152,key,value_buf,buf_len);
            if ((CONCAT31(extraout_var,_Var1) != 0) && (CONCAT31(extraout_var_00,EVar2) == 0)) {
              EVar2 = del_env(key,(env_node_obj_t)env_3151,true);
            }
          }
          if (gc_request != false) {
            gc_collect();
          }
        }
        ef_port_env_unlock();
        return EVar2;
      }
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      value_buf = (void *)0xf8c;
      uVar6 = 0x5de;
      format = "[%10u][%s: %s:%4d] buf_len err. %d > %d\r\n";
      key = (char *)buf_len;
    }
    else {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      key = (char *)strlen(key);
      value_buf = (void *)0x40;
      uVar6 = 0x5d9;
      format = "[%10u][%s: %s:%4d] key err. %d > %d\r\n";
    }
  }
  bl_printk(format,TVar3,&DAT_230781b4,&UNK_230781a8,uVar6,key,value_buf);
  return EF_ENV_ARG_ERR;
}



EfErrCode ef_set_env(char *key,char *value)

{
  EfErrCode EVar1;
  size_t buf_len;
  
  buf_len = strlen(value);
  EVar1 = ef_set_env_blob(key,value,buf_len);
  return EVar1;
}



EfErrCode ef_save_env(void)

{
  return EF_NO_ERR;
}



EfErrCode ef_env_set_default(void)

{
  uint uVar1;
  uint32_t addr;
  EfErrCode EVar2;
  undefined3 extraout_var;
  size_t len;
  ef_env *peVar3;
  undefined auStack56 [4];
  sector_meta_data sector;
  
  if (default_env_set == (ef_env *)0x0) {
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x621,
                 "(%s) has assert failed at %s.\r\n","default_env_set","ef_env_set_default");
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  if (default_env_set_size == 0) {
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x622,
                 "(%s) has assert failed at %s.\r\n","default_env_set_size","ef_env_set_default");
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  ef_port_env_lock();
  addr = env_start_addr;
  while (addr < env_start_addr + 0x8000) {
    EVar2 = format_sector(addr);
    if (CONCAT31(extraout_var,EVar2) != 0) goto __exit;
    addr = addr + 0x1000;
  }
  uVar1 = 0;
  while (uVar1 < default_env_set_size) {
    len = default_env_set[uVar1].value_len;
    if (len == 0) {
      len = strlen((char *)default_env_set[uVar1].value);
    }
    sector.remain = 0xffffffff;
    peVar3 = default_env_set + uVar1;
    uVar1 = uVar1 + 1;
    create_env_blob((sector_meta_data_t)auStack56,peVar3->key,peVar3->value,len);
  }
  EVar2 = EF_NO_ERR;
__exit:
  ef_port_env_unlock();
  return EVar2;
}



// WARNING: Variable defined which should be unmapped: env

EfErrCode ef_load_env(void)

{
  int iStack132;
  size_t check_failed_count;
  sector_meta_data sector;
  env_node_obj env;
  
  in_recovery_check = true;
  iStack132 = 0;
  sector_iterator((sector_meta_data_t)&check_failed_count,SECTOR_STORE_UNUSED,&iStack132,(void *)0x0
                  ,check_sec_hdr_cb,false);
  if (iStack132 == 8) {
    ef_log_info("Warning: All sector header check failed. Set it to default.\r\n");
    ef_env_set_default();
  }
  ef_port_env_lock();
  sector_iterator((sector_meta_data_t)&check_failed_count,SECTOR_STORE_UNUSED,(void *)0x0,
                  (void *)0x0,check_and_recovery_gc_cb,false);
  while( true ) {
    env_iterator((env_node_obj_t)&sector.empty_env,(void *)0x0,(void *)0x0,check_and_recovery_env_cb
                );
    if (gc_request == false) break;
    gc_collect();
  }
  in_recovery_check = false;
  ef_port_env_unlock();
  return EF_NO_ERR;
}



EfErrCode ef_env_init(ef_env *default_env,size_t default_env_size)

{
  char "ef_env_init" [12];
  EfErrCode EVar1;
  undefined3 extraout_var;
  env_cache_node *peVar2;
  
  if (default_env == (ef_env *)0x0) {
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x71e,
                 "(%s) has assert failed at %s.\r\n","default_env","ef_env_init");
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  EVar1 = EF_NO_ERR;
  if (init_ok == false) {
    sector_cache_table[0].addr = 0xffffffff;
    sector_cache_table[1].addr = 0xffffffff;
    sector_cache_table[2].addr = 0xffffffff;
    sector_cache_table[3].addr = 0xffffffff;
    peVar2 = env_cache_table;
    do {
      peVar2->addr = 0xffffffff;
      peVar2 = peVar2 + 1;
    } while (peVar2 != (env_cache_node *)sector_3152);
    env_start_addr = 0;
    default_env_set = default_env;
    default_env_set_size = default_env_size;
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x738,
                 "ENV start address is 0x%08X, size is %d bytes.\r\n",0,0x8000);
    EVar1 = ef_load_env();
    if (CONCAT31(extraout_var,EVar1) == 0) {
      init_ok = true;
    }
  }
  return EVar1;
}



EfErrCode ef_port_read(uint32_t addr,uint32_t *buf,size_t size)

{
  int iVar1;
  
  iVar1 = bl_mtd_read(handle,addr,size,(uint8_t *)buf);
  return (EfErrCode)((iVar1 < 0) << 1);
}



EfErrCode ef_port_write(uint32_t addr,uint32_t *buf,size_t size)

{
  EfErrCode EVar1;
  int iVar2;
  
  iVar2 = bl_mtd_write(handle,addr,size,(uint8_t *)buf);
  if (iVar2 < 0) {
    EVar1 = EF_WRITE_ERR;
  }
  else {
    EVar1 = EF_NO_ERR;
  }
  return EVar1;
}



void ef_port_env_lock(void)

{
  xQueueSemaphoreTake((QueueHandle_t)env_cache_lock,0xffffffff);
  return;
}



void ef_port_env_unlock(void)

{
  xQueueGenericSend((QueueHandle_t)env_cache_lock,(void *)0x0,0,0);
  return;
}



void ef_log_debug(char *file,long line,char *format,...)

{
  undefined4 in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list args;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  undefined4 uStack8;
  undefined4 uStack4;
  
  uStack20 = in_a3;
  uStack16 = in_a4;
  uStack12 = in_a5;
  uStack8 = in_a6;
  uStack4 = in_a7;
  vprint(format,&uStack20);
  return;
}



EfErrCode ef_port_erase(uint32_t addr,size_t size)

{
  char "ef_port_erase" [14];
  int iVar1;
  
  if ((addr & 0xfff) != 0) {
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_port.c",0x77,
                 "(%s) has assert failed at %s.\r\n","addr % EF_ERASE_MIN_SIZE == 0","ef_port_erase"
                );
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  iVar1 = bl_mtd_erase(handle,addr,size);
  return (EfErrCode)((uint)iVar1 >> 0x1f);
}



void ef_log_info(char *format,...)

{
  undefined4 in_a1;
  undefined4 in_a2;
  undefined4 in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list args;
  undefined4 uStack28;
  undefined4 uStack24;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  undefined4 uStack8;
  undefined4 uStack4;
  
  uStack28 = in_a1;
  uStack24 = in_a2;
  uStack20 = in_a3;
  uStack16 = in_a4;
  uStack12 = in_a5;
  uStack8 = in_a6;
  uStack4 = in_a7;
  vprint(format,&uStack28);
  return;
}



// WARNING: Variable defined which should be unmapped: info
// WARNING: Could not reconcile some variable overlaps

EfErrCode ef_port_init(ef_env **default_env,size_t *default_env_size)

{
  int iVar1;
  undefined auStack44 [4];
  bl_mtd_info_t info;
  
  iVar1 = bl_mtd_open("PSM",&handle,2);
  if (iVar1 < 0) {
    ef_log_info("[EF] [PART] [XIP] error when get PSM partition %d\r\n",iVar1);
    puts("[EF] [PART] [XIP] Dead Loop. Reason: no Valid PSM partition found\r\n");
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  memset(auStack44,0,0x1c);
  bl_mtd_info(handle,(bl_mtd_info_t *)auStack44);
  ef_log_info("[EF] Found Valid PSM partition, XIP Addr %08x, flash addr %08x\r\n",info.size,
              info.name._12_4_);
  *default_env = default_env_set;
  *default_env_size = 1;
  printf("*default_env_size = 0x%08x\r\n",1);
  env_cache_lock = (SemaphoreHandle_t)xQueueCreateMutex('\x01');
  return EF_NO_ERR;
}



uint32_t ef_calc_crc32(uint32_t crc,void *buf,size_t size)

{
  uint uVar1;
  byte *pbVar2;
  
  uVar1 = ~crc;
  pbVar2 = (byte *)buf;
  while (pbVar2 != (byte *)(size + (int)buf)) {
    uVar1 = uVar1 >> 8 ^ crc32_table[(*pbVar2 ^ uVar1) & 0xff];
    pbVar2 = pbVar2 + 1;
  }
  return ~uVar1;
}



// WARNING: Removing unreachable block (ram,0x23031f20)
// WARNING: Removing unreachable block (ram,0x23031f36)

EventGroupHandle_t xEventGroupCreateStatic(StaticEventGroup_t *pxEventGroupBuffer)

{
  size_t xSize;
  
  if (pxEventGroupBuffer == (StaticEventGroup_t *)0x0) {
    vAssertCalled();
  }
  else {
    pxEventGroupBuffer->xDummy1 = 0;
    vListInitialise((List_t *)&pxEventGroupBuffer->xDummy2);
    pxEventGroupBuffer->ucDummy4 = '\x01';
  }
  return (EventGroupHandle_t)pxEventGroupBuffer;
}



EventBits_t
xEventGroupWaitBits(EventGroupHandle_t xEventGroup,EventBits_t uxBitsToWaitFor,
                   BaseType_t xClearOnExit,BaseType_t xWaitForAllBits,TickType_t xTicksToWait)

{
  uint uVar1;
  BaseType_t BVar2;
  uint uVar3;
  
  if (xEventGroup == (EventGroupHandle_t)0x0) {
    vAssertCalled();
  }
  if (((uxBitsToWaitFor & 0xff000000) == 0) && (uxBitsToWaitFor != 0)) {
    BVar2 = xTaskGetSchedulerState();
    if (BVar2 != 0) goto LAB_23031f68;
LAB_23031fe8:
    if (xTicksToWait == 0) goto LAB_23031f68;
    vAssertCalled();
    vTaskSuspendAll();
    uVar1 = xEventGroup->uxEventBits;
    uVar3 = uxBitsToWaitFor & uVar1;
    if (xWaitForAllBits != 0) goto LAB_23031fac;
LAB_23031f78:
    if (uVar3 == 0) {
LAB_23031fb0:
      if (xTicksToWait == 0) goto LAB_23032002;
      uVar1 = (uint)(xClearOnExit != 0) << 0x18;
      if (xWaitForAllBits != 0) {
        uVar1 = uVar1 | 0x4000000;
      }
      vTaskPlaceOnUnorderedEventList
                (&xEventGroup->xTasksWaitingForBits,uVar1 | uxBitsToWaitFor,xTicksToWait);
      BVar2 = xTaskResumeAll();
      if (BVar2 == 0) {
        ecall();
      }
      uVar1 = uxTaskResetEventItemValue();
      if ((int)(uVar1 << 6) < 0) goto LAB_23031fe0;
      vTaskEnterCritical();
      uVar1 = xEventGroup->uxEventBits;
      if (xWaitForAllBits == 0) {
        if ((uxBitsToWaitFor & uVar1) != 0) {
LAB_23032028:
          if (xClearOnExit != 0) {
            xEventGroup->uxEventBits = ~uxBitsToWaitFor & uVar1;
          }
        }
      }
      else {
        if (uxBitsToWaitFor == (uxBitsToWaitFor & uVar1)) goto LAB_23032028;
      }
      vTaskExitCritical();
LAB_23031fe0:
      return uVar1 & 0xffffff;
    }
  }
  else {
    vAssertCalled();
    BVar2 = xTaskGetSchedulerState();
    if (BVar2 == 0) goto LAB_23031fe8;
LAB_23031f68:
    vTaskSuspendAll();
    uVar1 = xEventGroup->uxEventBits;
    uVar3 = uxBitsToWaitFor & uVar1;
    if (xWaitForAllBits == 0) goto LAB_23031f78;
LAB_23031fac:
    if (uxBitsToWaitFor != uVar3) goto LAB_23031fb0;
  }
  if (xClearOnExit != 0) {
    xEventGroup->uxEventBits = ~uxBitsToWaitFor & uVar1;
    xTaskResumeAll();
    return uVar1;
  }
LAB_23032002:
  xTaskResumeAll();
  return uVar1;
}



EventBits_t xEventGroupSetBits(EventGroupHandle_t xEventGroup,EventBits_t uxBitsToSet)

{
  xLIST_ITEM *pxEventListItem;
  xLIST_ITEM *pxVar1;
  uint uVar2;
  uint uVar3;
  xLIST_ITEM *pxVar4;
  uint uVar5;
  
  if (xEventGroup == (EventGroupHandle_t)0x0) {
    vAssertCalled();
  }
  if ((uxBitsToSet & 0xff000000) != 0) {
    vAssertCalled();
  }
  vTaskSuspendAll();
  pxEventListItem = (xEventGroup->xTasksWaitingForBits).xListEnd.pxNext;
  pxVar4 = (xLIST_ITEM *)&(xEventGroup->xTasksWaitingForBits).xListEnd;
  uxBitsToSet = uxBitsToSet | xEventGroup->uxEventBits;
  xEventGroup->uxEventBits = uxBitsToSet;
  if (pxVar4 != pxEventListItem) {
    uVar5 = 0;
    do {
      while( true ) {
        uVar3 = ((ListItem_t *)pxEventListItem)->xItemValue;
        uVar2 = uVar3 & 0xffffff;
        pxVar1 = ((ListItem_t *)pxEventListItem)->pxNext;
        if ((int)(uVar3 << 5) < 0) break;
        if ((uVar2 & uxBitsToSet) != 0) {
LAB_230320a6:
          if ((int)(uVar3 << 7) < 0) {
            uVar5 = uVar5 | uVar2;
          }
          vTaskRemoveFromUnorderedEventList((ListItem_t *)pxEventListItem,uxBitsToSet | 0x2000000);
          uxBitsToSet = xEventGroup->uxEventBits;
        }
        pxEventListItem = pxVar1;
        if (pxVar4 == pxVar1) goto LAB_230320bc;
      }
      if (uVar2 == (uVar2 & uxBitsToSet)) goto LAB_230320a6;
      pxEventListItem = pxVar1;
    } while (pxVar4 != pxVar1);
LAB_230320bc:
    uxBitsToSet = uxBitsToSet & ~uVar5;
  }
  xEventGroup->uxEventBits = uxBitsToSet;
  xTaskResumeAll();
  return xEventGroup->uxEventBits;
}



void vEventGroupDelete(EventGroupHandle_t xEventGroup)

{
  ListItem_t *pxEventListItem;
  UBaseType_t UVar1;
  
  vTaskSuspendAll();
  UVar1 = (xEventGroup->xTasksWaitingForBits).uxNumberOfItems;
  while (UVar1 != 0) {
    while (pxEventListItem = (ListItem_t *)(xEventGroup->xTasksWaitingForBits).xListEnd.pxNext,
          pxEventListItem != (ListItem_t *)&(xEventGroup->xTasksWaitingForBits).xListEnd) {
      vTaskRemoveFromUnorderedEventList(pxEventListItem,0x2000000);
      if ((xEventGroup->xTasksWaitingForBits).uxNumberOfItems == 0) goto LAB_23032130;
    }
    vAssertCalled();
    vTaskRemoveFromUnorderedEventList
              ((ListItem_t *)(xEventGroup->xTasksWaitingForBits).xListEnd.pxNext,0x2000000);
    UVar1 = (xEventGroup->xTasksWaitingForBits).uxNumberOfItems;
  }
LAB_23032130:
  if (xEventGroup->ucStaticallyAllocated != '\0') {
    xTaskResumeAll();
    return;
  }
  vPortFree(xEventGroup);
  xTaskResumeAll();
  return;
}



void vListInitialise(List_t *pxList)

{
  ListItem_t *pLVar1;
  
  pLVar1 = (ListItem_t *)&pxList->xListEnd;
  pxList->pxIndex = pLVar1;
  (pxList->xListEnd).xItemValue = 0xffffffff;
  *(ListItem_t **)&(pxList->xListEnd).pxNext = pLVar1;
  *(ListItem_t **)&(pxList->xListEnd).pxPrevious = pLVar1;
  pxList->uxNumberOfItems = 0;
  return;
}



void vListInitialiseItem(ListItem_t *pxItem)

{
  pxItem->pvContainer = (xLIST *)0x0;
  return;
}



void vListInsertEnd(List_t *pxList,ListItem_t *pxNewListItem)

{
  xLIST_ITEM *pxVar1;
  ListItem_t *pLVar2;
  
  pLVar2 = pxList->pxIndex;
  *(ListItem_t **)&pxNewListItem->pxNext = pLVar2;
  pxVar1 = pLVar2->pxPrevious;
  pxNewListItem->pxPrevious = pxVar1;
  *(ListItem_t **)&pxVar1->pxNext = pxNewListItem;
  *(ListItem_t **)&pLVar2->pxPrevious = pxNewListItem;
  *(List_t **)&pxNewListItem->pvContainer = pxList;
  pxList->uxNumberOfItems = pxList->uxNumberOfItems + 1;
  return;
}



void vListInsert(List_t *pxList,ListItem_t *pxNewListItem)

{
  xLIST_ITEM *pxVar1;
  xLIST_ITEM *pxVar2;
  
  pxVar2 = (xLIST_ITEM *)&pxList->xListEnd;
  if (pxNewListItem->xItemValue == 0xffffffff) {
    pxVar1 = (pxList->xListEnd).pxPrevious;
    pxVar2 = pxVar1->pxNext;
  }
  else {
    do {
      pxVar1 = pxVar2;
      pxVar2 = pxVar1->pxNext;
    } while (pxVar2->xItemValue <= pxNewListItem->xItemValue);
  }
  pxNewListItem->pxNext = pxVar2;
  *(ListItem_t **)&pxVar2->pxPrevious = pxNewListItem;
  pxNewListItem->pxPrevious = pxVar1;
  *(ListItem_t **)&pxVar1->pxNext = pxNewListItem;
  *(List_t **)&pxNewListItem->pvContainer = pxList;
  pxList->uxNumberOfItems = pxList->uxNumberOfItems + 1;
  return;
}



UBaseType_t uxListRemove(ListItem_t *pxItemToRemove)

{
  xLIST_ITEM *pxVar1;
  xLIST *pxVar2;
  
  pxVar1 = pxItemToRemove->pxPrevious;
  pxVar2 = pxItemToRemove->pvContainer;
  pxItemToRemove->pxNext->pxPrevious = pxVar1;
  pxVar1->pxNext = pxItemToRemove->pxNext;
  if (pxVar2->pxIndex != pxItemToRemove) {
    pxItemToRemove->pvContainer = (xLIST *)0x0;
    pxVar2->uxNumberOfItems = pxVar2->uxNumberOfItems - 1;
    return pxVar2->uxNumberOfItems;
  }
  pxVar2->pxIndex = (ListItem_t *)pxItemToRemove->pxPrevious;
  pxItemToRemove->pvContainer = (xLIST *)0x0;
  pxVar2->uxNumberOfItems = pxVar2->uxNumberOfItems - 1;
  return pxVar2->uxNumberOfItems;
}



BaseType_t prvCopyDataToQueue(Queue_t *pxQueue,void *pvItemToQueue,BaseType_t xPosition)

{
  UBaseType_t UVar1;
  BaseType_t BVar2;
  UBaseType_t UVar3;
  size_t __n;
  int8_t *piVar4;
  int8_t *piVar5;
  
  __n = pxQueue->uxItemSize;
  UVar1 = pxQueue->uxMessagesWaiting;
  if (__n == 0) {
    UVar1 = UVar1 + 1;
    BVar2 = 0;
    if (pxQueue->pcHead == (int8_t *)0x0) {
      BVar2 = xTaskPriorityDisinherit(*(TaskHandle_t *)&pxQueue->u);
      *(undefined4 *)&pxQueue->u = 0;
    }
  }
  else {
    if (xPosition == 0) {
      UVar1 = UVar1 + 1;
      memcpy(pxQueue->pcWriteTo,pvItemToQueue,__n);
      piVar4 = pxQueue->pcWriteTo;
      BVar2 = 0;
      pxQueue->pcWriteTo = piVar4 + pxQueue->uxItemSize;
      if (*(int8_t **)&pxQueue->u <= piVar4 + pxQueue->uxItemSize) {
        pxQueue->uxMessagesWaiting = UVar1;
        pxQueue->pcWriteTo = pxQueue->pcHead;
        return 0;
      }
    }
    else {
      memcpy(*(void **)((int)&pxQueue->u + 4),pvItemToQueue,__n);
      UVar3 = pxQueue->uxItemSize;
      piVar4 = pxQueue->pcHead;
      piVar5 = (int8_t *)(*(int *)((int)&pxQueue->u + 4) + -UVar3);
      *(int8_t **)((int)&pxQueue->u + 4) = piVar5;
      if (piVar5 < piVar4) {
        *(int *)((int)&pxQueue->u + 4) = -UVar3 + *(int *)&pxQueue->u;
      }
      if (xPosition != 2) {
        pxQueue->uxMessagesWaiting = UVar1 + 1;
        return 0;
      }
      BVar2 = 0;
      if (UVar1 == 0) {
        UVar1 = 1;
      }
    }
  }
  pxQueue->uxMessagesWaiting = UVar1;
  return BVar2;
}



void prvCopyDataFromQueue(Queue_t *pxQueue,void *pvBuffer)

{
  int8_t *__src;
  size_t __n;
  int8_t *piVar1;
  
  __n = pxQueue->uxItemSize;
  if (__n != 0) {
    piVar1 = *(int8_t **)&pxQueue->u;
    __src = (int8_t *)(*(int *)((int)&pxQueue->u + 4) + __n);
    *(int8_t **)((int)&pxQueue->u + 4) = __src;
    if (piVar1 <= __src) {
      __src = pxQueue->pcHead;
      *(int8_t **)((int)&pxQueue->u + 4) = __src;
    }
    memcpy(pvBuffer,__src,__n);
    return;
  }
  return;
}



void prvUnlockQueue(Queue_t *pxQueue)

{
  char cVar1;
  int iVar2;
  BaseType_t BVar3;
  uint uVar4;
  
  vTaskEnterCritical();
  iVar2 = (int)pxQueue->cTxLock;
  if ((0 < iVar2) && ((pxQueue->xTasksWaitingToReceive).uxNumberOfItems != 0)) {
    do {
      BVar3 = xTaskRemoveFromEventList(&pxQueue->xTasksWaitingToReceive);
      if (BVar3 == 0) {
        uVar4 = iVar2 - 1U & 0xff;
        cVar1 = (char)uVar4;
      }
      else {
        vTaskMissedYield();
        uVar4 = iVar2 - 1U & 0xff;
        cVar1 = (char)uVar4;
      }
    } while ((uVar4 != 0) &&
            (iVar2 = (int)cVar1, (pxQueue->xTasksWaitingToReceive).uxNumberOfItems != 0));
  }
  pxQueue->cTxLock = -1;
  vTaskExitCritical();
  vTaskEnterCritical();
  iVar2 = (int)pxQueue->cRxLock;
  if ((0 < iVar2) && ((pxQueue->xTasksWaitingToSend).uxNumberOfItems != 0)) {
    do {
      BVar3 = xTaskRemoveFromEventList(&pxQueue->xTasksWaitingToSend);
      if (BVar3 == 0) {
        uVar4 = iVar2 - 1U & 0xff;
        cVar1 = (char)uVar4;
      }
      else {
        vTaskMissedYield();
        uVar4 = iVar2 - 1U & 0xff;
        cVar1 = (char)uVar4;
      }
    } while ((uVar4 != 0) &&
            (iVar2 = (int)cVar1, (pxQueue->xTasksWaitingToSend).uxNumberOfItems != 0));
  }
  pxQueue->cRxLock = -1;
  vTaskExitCritical();
  return;
}



BaseType_t xQueueGenericReset(QueueHandle_t xQueue,BaseType_t xNewQueue)

{
  BaseType_t BVar1;
  int8_t *piVar2;
  int iVar3;
  
  if (xQueue == (QueueHandle_t)0x0) {
    vAssertCalled();
  }
  vTaskEnterCritical();
  piVar2 = xQueue->pcHead;
  xQueue->uxMessagesWaiting = 0;
  iVar3 = xQueue->uxItemSize * xQueue->uxLength;
  xQueue->cRxLock = -1;
  xQueue->pcWriteTo = piVar2;
  xQueue->cTxLock = -1;
  *(int8_t **)&xQueue->u = piVar2 + iVar3;
  *(int8_t **)((int)&xQueue->u + 4) = piVar2 + (iVar3 - xQueue->uxItemSize);
  if (xNewQueue == 0) {
    if (((xQueue->xTasksWaitingToSend).uxNumberOfItems != 0) &&
       (BVar1 = xTaskRemoveFromEventList(&xQueue->xTasksWaitingToSend), BVar1 != 0)) {
      ecall();
      vTaskExitCritical();
      return 1;
    }
    vTaskExitCritical();
    return 1;
  }
  vListInitialise(&xQueue->xTasksWaitingToSend);
  vListInitialise(&xQueue->xTasksWaitingToReceive);
  vTaskExitCritical();
  return 1;
}



// WARNING: Removing unreachable block (ram,0x2303241e)

QueueHandle_t
xQueueGenericCreateStatic
          (UBaseType_t uxQueueLength,UBaseType_t uxItemSize,uint8_t *pucQueueStorage,
          StaticQueue_t *pxStaticQueue,uint8_t ucQueueType)

{
  size_t xSize;
  
  if (uxQueueLength == 0) {
    vAssertCalled();
  }
  if (pxStaticQueue == (StaticQueue_t *)0x0) {
    vAssertCalled();
  }
  if (pucQueueStorage == (uint8_t *)0x0) {
    if (uxItemSize == 0) goto LAB_23032422;
  }
  else {
    if (uxItemSize != 0) goto LAB_23032422;
  }
  vAssertCalled();
LAB_23032422:
  if (pxStaticQueue != (StaticQueue_t *)0x0) {
    pxStaticQueue->ucDummy6 = '\x01';
    if (uxItemSize == 0) {
      pucQueueStorage = (uint8_t *)pxStaticQueue;
    }
    *(uint8_t **)pxStaticQueue->pvDummy1 = pucQueueStorage;
    pxStaticQueue->uxDummy4[1] = uxQueueLength;
    pxStaticQueue->uxDummy4[2] = uxItemSize;
    xQueueGenericReset((QueueHandle_t)pxStaticQueue,1);
    pxStaticQueue->ucDummy9 = ucQueueType;
  }
  return (QueueHandle_t)pxStaticQueue;
}



QueueHandle_t
xQueueGenericCreate(UBaseType_t uxQueueLength,UBaseType_t uxItemSize,uint8_t ucQueueType)

{
  QueueHandle_t xQueue;
  
  if (uxQueueLength == 0) {
    vAssertCalled();
  }
  if (uxItemSize == 0) {
    xQueue = (QueueHandle_t)pvPortMalloc(0x50);
    if (xQueue == (QueueHandle_t)0x0) {
      return (QueueHandle_t)0x0;
    }
    xQueue->ucStaticallyAllocated = '\0';
    *(QueueHandle_t *)&xQueue->pcHead = xQueue;
  }
  else {
    xQueue = (QueueHandle_t)pvPortMalloc(uxQueueLength * uxItemSize + 0x50);
    if (xQueue == (QueueHandle_t)0x0) {
      return (QueueHandle_t)0x0;
    }
    xQueue->ucStaticallyAllocated = '\0';
    *(QueueHandle_t *)&xQueue->pcHead = xQueue + 1;
  }
  xQueue->uxLength = uxQueueLength;
  xQueue->uxItemSize = uxItemSize;
  xQueueGenericReset(xQueue,1);
  xQueue->ucQueueType = ucQueueType;
  return xQueue;
}



QueueHandle_t xQueueCreateCountingSemaphore(UBaseType_t uxMaxCount,UBaseType_t uxInitialCount)

{
  bool bVar1;
  QueueHandle_t pQVar2;
  
  if (uxMaxCount == 0) {
    vAssertCalled();
    bVar1 = uxInitialCount == 0;
  }
  else {
    bVar1 = uxInitialCount <= uxMaxCount;
  }
  if (!bVar1) {
    vAssertCalled();
  }
  pQVar2 = xQueueGenericCreate(uxMaxCount,0,'\x02');
  if (pQVar2 != (QueueHandle_t)0x0) {
    pQVar2->uxMessagesWaiting = uxInitialCount;
  }
  return pQVar2;
}



// WARNING: Variable defined which should be unmapped: xTimeOut

BaseType_t
xQueueGenericSend(QueueHandle_t xQueue,void *pvItemToQueue,TickType_t xTicksToWait,
                 BaseType_t xCopyPosition)

{
  bool bVar1;
  BaseType_t BVar2;
  int iVar3;
  TickType_t local_34 [3];
  undefined auStack40 [4];
  TimeOut_t xTimeOut;
  
  local_34[0] = xTicksToWait;
  if (xQueue == (QueueHandle_t)0x0) {
    vAssertCalled();
  }
  if ((pvItemToQueue == (void *)0x0) && (xQueue->uxItemSize != 0)) {
    vAssertCalled();
  }
  if ((xCopyPosition == 2) && (xQueue->uxLength != 1)) {
    vAssertCalled();
  }
  BVar2 = xTaskGetSchedulerState();
  if ((BVar2 == 0) && (local_34[0] != 0)) {
    vAssertCalled();
  }
  vTaskEnterCritical();
  bVar1 = false;
  if (xQueue->uxLength <= xQueue->uxMessagesWaiting) {
    do {
      if (xCopyPosition == 2) break;
      if (local_34[0] == 0) {
        vTaskExitCritical();
        return 0;
      }
      if (!bVar1) {
        vTaskInternalSetTimeOutState((TimeOut_t *)auStack40);
      }
      vTaskExitCritical();
      vTaskSuspendAll();
      vTaskEnterCritical();
      if (xQueue->cRxLock == -1) {
        xQueue->cRxLock = '\0';
      }
      if (xQueue->cTxLock == -1) {
        xQueue->cTxLock = '\0';
      }
      vTaskExitCritical();
      BVar2 = xTaskCheckForTimeOut((TimeOut_t *)auStack40,local_34);
      if (BVar2 != 0) {
        prvUnlockQueue((Queue_t *)xQueue);
        xTaskResumeAll();
        return 0;
      }
      vTaskEnterCritical();
      if (xQueue->uxMessagesWaiting == xQueue->uxLength) {
        vTaskExitCritical();
        vTaskPlaceOnEventList(&xQueue->xTasksWaitingToSend,local_34[0]);
        prvUnlockQueue((Queue_t *)xQueue);
        BVar2 = xTaskResumeAll();
        if (BVar2 == 0) {
          ecall();
        }
      }
      else {
        vTaskExitCritical();
        prvUnlockQueue((Queue_t *)xQueue);
        xTaskResumeAll();
      }
      bVar1 = true;
      vTaskEnterCritical();
    } while (xQueue->uxLength <= xQueue->uxMessagesWaiting);
  }
  iVar3 = prvCopyDataToQueue((Queue_t *)xQueue,pvItemToQueue,xCopyPosition);
  if ((xQueue->xTasksWaitingToReceive).uxNumberOfItems != 0) {
    iVar3 = xTaskRemoveFromEventList(&xQueue->xTasksWaitingToReceive);
  }
  if (iVar3 != 0) {
    ecall();
  }
  vTaskExitCritical();
  return 1;
}



QueueHandle_t xQueueCreateMutexStatic(uint8_t ucQueueType,StaticQueue_t *pxStaticQueue)

{
  QueueHandle_t xQueue;
  
  xQueue = xQueueGenericCreateStatic(1,0,(uint8_t *)0x0,pxStaticQueue,ucQueueType);
  if (xQueue != (QueueHandle_t)0x0) {
    *(undefined4 *)&xQueue->u = 0;
    xQueue->pcHead = (int8_t *)0x0;
    *(undefined4 *)((int)&xQueue->u + 4) = 0;
    xQueueGenericSend(xQueue,(void *)0x0,0,0);
  }
  return xQueue;
}



QueueHandle_t xQueueCreateMutex(uint8_t ucQueueType)

{
  QueueHandle_t xQueue;
  
  xQueue = xQueueGenericCreate(1,0,ucQueueType);
  if (xQueue != (QueueHandle_t)0x0) {
    *(undefined4 *)&xQueue->u = 0;
    xQueue->pcHead = (int8_t *)0x0;
    *(undefined4 *)((int)&xQueue->u + 4) = 0;
    xQueueGenericSend(xQueue,(void *)0x0,0,0);
  }
  return xQueue;
}



BaseType_t
xQueueGenericSendFromISR
          (QueueHandle_t xQueue,void *pvItemToQueue,BaseType_t *pxHigherPriorityTaskWoken,
          BaseType_t xCopyPosition)

{
  byte bVar1;
  BaseType_t BVar2;
  
  if (xQueue == (QueueHandle_t)0x0) {
    vAssertCalled();
  }
  if ((pvItemToQueue == (void *)0x0) && (xQueue->uxItemSize != 0)) {
    vAssertCalled();
  }
  if (xCopyPosition == 2) {
    if (xQueue->uxLength != 1) {
      vAssertCalled();
    }
  }
  else {
    if (xQueue->uxLength <= xQueue->uxMessagesWaiting) {
      return 0;
    }
  }
  bVar1 = xQueue->cTxLock;
  prvCopyDataToQueue((Queue_t *)xQueue,pvItemToQueue,xCopyPosition);
  if (bVar1 == 0xff) {
    if ((((xQueue->xTasksWaitingToReceive).uxNumberOfItems != 0) &&
        (BVar2 = xTaskRemoveFromEventList(&xQueue->xTasksWaitingToReceive), BVar2 != 0)) &&
       (pxHigherPriorityTaskWoken != (BaseType_t *)0x0)) {
      *pxHigherPriorityTaskWoken = 1;
    }
    return 1;
  }
  xQueue->cTxLock = (int8_t)(((uint)bVar1 + 1) * 0x1000000 >> 0x18);
  return 1;
}



BaseType_t xQueueGiveFromISR(QueueHandle_t xQueue,BaseType_t *pxHigherPriorityTaskWoken)

{
  BaseType_t BVar1;
  int8_t *piVar2;
  
  if (xQueue == (QueueHandle_t)0x0) {
    vAssertCalled();
  }
  if (xQueue->uxItemSize == 0) {
    piVar2 = xQueue->pcHead;
  }
  else {
    vAssertCalled();
    piVar2 = xQueue->pcHead;
  }
  if ((piVar2 == (int8_t *)0x0) && (*(int *)&xQueue->u != 0)) {
    vAssertCalled();
  }
  BVar1 = 0;
  if (xQueue->uxMessagesWaiting < xQueue->uxLength) {
    xQueue->uxMessagesWaiting = xQueue->uxMessagesWaiting + 1;
    if (xQueue->cTxLock == 0xff) {
      if ((((xQueue->xTasksWaitingToReceive).uxNumberOfItems != 0) &&
          (BVar1 = xTaskRemoveFromEventList(&xQueue->xTasksWaitingToReceive), BVar1 != 0)) &&
         (pxHigherPriorityTaskWoken != (BaseType_t *)0x0)) {
        *pxHigherPriorityTaskWoken = 1;
        return 1;
      }
    }
    else {
      xQueue->cTxLock = (int8_t)(((uint)(byte)xQueue->cTxLock + 1) * 0x1000000 >> 0x18);
    }
    BVar1 = 1;
  }
  return BVar1;
}



BaseType_t xQueueReceive(QueueHandle_t xQueue,void *pvBuffer,TickType_t xTicksToWait)

{
  BaseType_t BVar1;
  UBaseType_t UVar2;
  TickType_t local_34 [3];
  undefined auStack40 [4];
  TimeOut_t xTimeOut;
  
  local_34[0] = xTicksToWait;
  if (xQueue == (QueueHandle_t)0x0) {
    vAssertCalled();
  }
  if ((pvBuffer == (void *)0x0) && (xQueue->uxItemSize != 0)) {
    vAssertCalled();
  }
  BVar1 = xTaskGetSchedulerState();
  if ((BVar1 == 0) && (local_34[0] != 0)) {
    vAssertCalled();
  }
  vTaskEnterCritical();
  UVar2 = xQueue->uxMessagesWaiting;
  if (UVar2 != 0) {
LAB_230328f8:
    prvCopyDataFromQueue((Queue_t *)xQueue,pvBuffer);
    xQueue->uxMessagesWaiting = UVar2 - 1;
    if (((xQueue->xTasksWaitingToSend).uxNumberOfItems != 0) &&
       (BVar1 = xTaskRemoveFromEventList(&xQueue->xTasksWaitingToSend), BVar1 != 0)) {
      ecall();
    }
    vTaskExitCritical();
    return 1;
  }
  if (local_34[0] != 0) {
    vTaskInternalSetTimeOutState((TimeOut_t *)auStack40);
    do {
      vTaskExitCritical();
      vTaskSuspendAll();
      vTaskEnterCritical();
      if (xQueue->cRxLock == -1) {
        xQueue->cRxLock = '\0';
      }
      if (xQueue->cTxLock == -1) {
        xQueue->cTxLock = '\0';
      }
      vTaskExitCritical();
      BVar1 = xTaskCheckForTimeOut((TimeOut_t *)auStack40,local_34);
      if (BVar1 == 0) {
        vTaskEnterCritical();
        if (xQueue->uxMessagesWaiting == 0) {
          vTaskExitCritical();
          vTaskPlaceOnEventList(&xQueue->xTasksWaitingToReceive,local_34[0]);
          prvUnlockQueue((Queue_t *)xQueue);
          BVar1 = xTaskResumeAll();
          if (BVar1 == 0) {
            ecall();
          }
          goto LAB_230328ec;
        }
        vTaskExitCritical();
        prvUnlockQueue((Queue_t *)xQueue);
        xTaskResumeAll();
        vTaskEnterCritical();
        UVar2 = xQueue->uxMessagesWaiting;
      }
      else {
        prvUnlockQueue((Queue_t *)xQueue);
        xTaskResumeAll();
        vTaskEnterCritical();
        if (xQueue->uxMessagesWaiting == 0) break;
        vTaskExitCritical();
LAB_230328ec:
        vTaskEnterCritical();
        UVar2 = xQueue->uxMessagesWaiting;
      }
      if (UVar2 != 0) goto LAB_230328f8;
    } while (local_34[0] != 0);
  }
  vTaskExitCritical();
  return 0;
}



// WARNING: Type propagation algorithm not settling

BaseType_t xQueueSemaphoreTake(QueueHandle_t xQueue,TickType_t xTicksToWait)

{
  bool bVar1;
  BaseType_t BVar2;
  TaskHandle_t ptVar3;
  UBaseType_t uxHighestPriorityWaitingTask;
  int iVar4;
  TickType_t local_34 [3];
  undefined auStack40 [4];
  TimeOut_t xTimeOut;
  
  local_34[0] = xTicksToWait;
  if (xQueue == (QueueHandle_t)0x0) {
    vAssertCalled();
  }
  if (xQueue->uxItemSize != 0) {
    vAssertCalled();
  }
  BVar2 = xTaskGetSchedulerState();
  if ((BVar2 == 0) && (local_34[0] != 0)) {
    vAssertCalled();
  }
  vTaskEnterCritical();
  uxHighestPriorityWaitingTask = xQueue->uxMessagesWaiting;
  iVar4 = 0;
  bVar1 = false;
  while( true ) {
    if (uxHighestPriorityWaitingTask != 0) {
      xQueue->uxMessagesWaiting = uxHighestPriorityWaitingTask - 1;
      if (xQueue->pcHead == (int8_t *)0x0) {
        ptVar3 = pvTaskIncrementMutexHeldCount();
        *(TaskHandle_t *)&xQueue->u = ptVar3;
      }
      if (((xQueue->xTasksWaitingToSend).uxNumberOfItems != 0) &&
         (BVar2 = xTaskRemoveFromEventList(&xQueue->xTasksWaitingToSend), BVar2 != 0)) {
        ecall();
      }
      vTaskExitCritical();
      return 1;
    }
    if (local_34[0] == 0) break;
    if (!bVar1) {
      vTaskInternalSetTimeOutState((TimeOut_t *)auStack40);
    }
    vTaskExitCritical();
    vTaskSuspendAll();
    vTaskEnterCritical();
    if (xQueue->cRxLock == -1) {
      xQueue->cRxLock = '\0';
    }
    if (xQueue->cTxLock == -1) {
      xQueue->cTxLock = '\0';
    }
    vTaskExitCritical();
    BVar2 = xTaskCheckForTimeOut((TimeOut_t *)auStack40,local_34);
    if (BVar2 == 0) {
      vTaskEnterCritical();
      if (xQueue->uxMessagesWaiting == 0) {
        vTaskExitCritical();
        if (xQueue->pcHead == (int8_t *)0x0) {
          vTaskEnterCritical();
          iVar4 = xTaskPriorityInherit(*(TaskHandle_t *)&xQueue->u);
          vTaskExitCritical();
        }
        vTaskPlaceOnEventList(&xQueue->xTasksWaitingToReceive,local_34[0]);
        prvUnlockQueue((Queue_t *)xQueue);
        BVar2 = xTaskResumeAll();
        if (BVar2 == 0) {
          ecall();
        }
      }
      else {
        vTaskExitCritical();
        prvUnlockQueue((Queue_t *)xQueue);
        xTaskResumeAll();
      }
    }
    else {
      prvUnlockQueue((Queue_t *)xQueue);
      xTaskResumeAll();
      vTaskEnterCritical();
      if (xQueue->uxMessagesWaiting == 0) {
        vTaskExitCritical();
        if (iVar4 == 0) {
          return 0;
        }
        vTaskEnterCritical();
        uxHighestPriorityWaitingTask = (xQueue->xTasksWaitingToReceive).uxNumberOfItems;
        if (uxHighestPriorityWaitingTask != 0) {
          uxHighestPriorityWaitingTask =
               0x20 - ((xQueue->xTasksWaitingToReceive).xListEnd.pxNext)->xItemValue;
        }
        vTaskPriorityDisinheritAfterTimeout
                  (*(TaskHandle_t *)&xQueue->u,uxHighestPriorityWaitingTask);
        vTaskExitCritical();
        return 0;
      }
      vTaskExitCritical();
    }
    bVar1 = true;
    vTaskEnterCritical();
    uxHighestPriorityWaitingTask = xQueue->uxMessagesWaiting;
  }
  if (iVar4 != 0) {
    vAssertCalled();
  }
  vTaskExitCritical();
  return 0;
}



UBaseType_t uxQueueMessagesWaiting(QueueHandle_t xQueue)

{
  UBaseType_t UVar1;
  
  if (xQueue == (QueueHandle_t)0x0) {
    vAssertCalled();
  }
  vTaskEnterCritical();
  UVar1 = xQueue->uxMessagesWaiting;
  vTaskExitCritical();
  return UVar1;
}



void vQueueDelete(QueueHandle_t xQueue)

{
  QueueHandle_t *ppQVar1;
  int iVar2;
  QueueRegistryItem_t *pQVar3;
  
  if (xQueue == (QueueHandle_t)0x0) {
    vAssertCalled();
    iVar2 = 0;
    pQVar3 = xQueueRegistry;
    do {
      ppQVar1 = &pQVar3->xHandle;
      pQVar3 = pQVar3 + 1;
      if (*ppQVar1 == (QueueHandle_t)0x0) {
        xQueueRegistry[iVar2].pcQueueName = (char *)0x0;
        xQueueRegistry[iVar2].xHandle = (QueueHandle_t)0x0;
        break;
      }
      iVar2 = iVar2 + 1;
    } while (iVar2 != 8);
    if (cRam00000046 != '\0') {
      return;
    }
    vPortFree((void *)0x0);
    return;
  }
  iVar2 = 0;
  pQVar3 = xQueueRegistry;
  do {
    ppQVar1 = &pQVar3->xHandle;
    pQVar3 = pQVar3 + 1;
    if (xQueue == *ppQVar1) {
      xQueueRegistry[iVar2].pcQueueName = (char *)0x0;
      xQueueRegistry[iVar2].xHandle = (QueueHandle_t)0x0;
      break;
    }
    iVar2 = iVar2 + 1;
  } while (iVar2 != 8);
  if (xQueue->ucStaticallyAllocated != '\0') {
    return;
  }
  vPortFree(xQueue);
  return;
}



void vQueueAddToRegistry(QueueHandle_t xQueue,char *pcQueueName)

{
  char **ppcVar1;
  int iVar2;
  QueueRegistryItem_t *pQVar3;
  
  iVar2 = 0;
  pQVar3 = xQueueRegistry;
  do {
    ppcVar1 = &pQVar3->pcQueueName;
    pQVar3 = pQVar3 + 1;
    if (*ppcVar1 == (char *)0x0) {
      xQueueRegistry[iVar2].pcQueueName = pcQueueName;
      xQueueRegistry[iVar2].xHandle = xQueue;
      return;
    }
    iVar2 = iVar2 + 1;
  } while (iVar2 != 8);
  return;
}



void vQueueWaitForMessageRestricted
               (QueueHandle_t xQueue,TickType_t xTicksToWait,BaseType_t xWaitIndefinitely)

{
  vTaskEnterCritical();
  if (xQueue->cRxLock == -1) {
    xQueue->cRxLock = '\0';
  }
  if (xQueue->cTxLock == -1) {
    xQueue->cTxLock = '\0';
  }
  vTaskExitCritical();
  if (xQueue->uxMessagesWaiting != 0) {
    prvUnlockQueue((Queue_t *)xQueue);
    return;
  }
  vTaskPlaceOnEventListRestricted(&xQueue->xTasksWaitingToReceive,xTicksToWait,xWaitIndefinitely);
  prvUnlockQueue((Queue_t *)xQueue);
  return;
}



void prvInitialiseNewStreamBuffer
               (StreamBuffer_t *pxStreamBuffer,uint8_t *pucBuffer,size_t xBufferSizeBytes,
               size_t xTriggerLevelBytes,uint8_t ucFlags)

{
  uint8_t *puVar1;
  
  puVar1 = (uint8_t *)memset(pucBuffer,0x55,xBufferSizeBytes);
  if (pucBuffer != puVar1) {
    vAssertCalled();
  }
  memset(pxStreamBuffer,0,0x24);
  pxStreamBuffer->pucBuffer = pucBuffer;
  pxStreamBuffer->xLength = xBufferSizeBytes;
  pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
  pxStreamBuffer->ucFlags = ucFlags;
  return;
}



size_t prvWriteBytesToBuffer(StreamBuffer_t *pxStreamBuffer,uint8_t *pucData,size_t xCount)

{
  uint uVar1;
  uint __n;
  size_t __n_00;
  
  if (xCount == 0) {
    vAssertCalled();
    uVar1 = pxStreamBuffer->xHead;
    if (pxStreamBuffer->xLength < uVar1) {
      __n_00 = 0;
      goto LAB_23032d00;
    }
    memcpy(pxStreamBuffer->pucBuffer + uVar1,pucData,0);
    __n = pxStreamBuffer->xLength;
    if (uVar1 < __n) goto LAB_23032cde;
  }
  else {
    uVar1 = pxStreamBuffer->xHead;
    __n_00 = pxStreamBuffer->xLength - uVar1;
    if (xCount < __n_00) {
      __n = uVar1 + xCount;
      __n_00 = xCount;
    }
    else {
      __n = uVar1 + __n_00;
    }
    if (pxStreamBuffer->xLength < __n) {
LAB_23032d00:
      vAssertCalled();
    }
    memcpy(pxStreamBuffer->pucBuffer + uVar1,pucData,__n_00);
    if (__n_00 < xCount) {
      __n = xCount - __n_00;
      if (pxStreamBuffer->xLength < __n) {
        vAssertCalled();
        memcpy(pxStreamBuffer->pucBuffer,pucData + __n_00,__n);
      }
      else {
        memcpy(pxStreamBuffer->pucBuffer,pucData + __n_00,__n);
      }
    }
    __n = pxStreamBuffer->xLength;
    uVar1 = uVar1 + xCount;
    if (uVar1 < __n) goto LAB_23032cde;
  }
  uVar1 = uVar1 - __n;
LAB_23032cde:
  pxStreamBuffer->xHead = uVar1;
  return xCount;
}



size_t prvReadBytesFromBuffer
                 (StreamBuffer_t *pxStreamBuffer,uint8_t *pucData,size_t xMaxCount,
                 size_t xBytesAvailable)

{
  size_t sVar1;
  uint __n;
  
  if (xMaxCount <= xBytesAvailable) {
    xBytesAvailable = xMaxCount;
  }
  if (xBytesAvailable == 0) {
    return 0;
  }
  sVar1 = pxStreamBuffer->xTail;
  __n = pxStreamBuffer->xLength - sVar1;
  if (xBytesAvailable < __n) {
    __n = xBytesAvailable;
    if (xBytesAvailable <= xMaxCount) goto LAB_23032d6e;
LAB_23032dc8:
    vAssertCalled();
    if (sVar1 + __n <= pxStreamBuffer->xLength) goto LAB_23032d76;
  }
  else {
    if (xMaxCount < __n) goto LAB_23032dc8;
LAB_23032d6e:
    if (sVar1 + __n <= pxStreamBuffer->xLength) goto LAB_23032d76;
  }
  vAssertCalled();
LAB_23032d76:
  memcpy(pucData,pxStreamBuffer->pucBuffer + sVar1,__n);
  if (__n < xBytesAvailable) {
    if (xMaxCount < xBytesAvailable) {
      vAssertCalled();
    }
    memcpy(pucData + __n,pxStreamBuffer->pucBuffer,xBytesAvailable - __n);
  }
  sVar1 = sVar1 + xBytesAvailable;
  if (pxStreamBuffer->xLength <= sVar1) {
    sVar1 = sVar1 - pxStreamBuffer->xLength;
  }
  pxStreamBuffer->xTail = sVar1;
  return xBytesAvailable;
}



StreamBufferHandle_t
xStreamBufferGenericCreate
          (size_t xBufferSizeBytes,size_t xTriggerLevelBytes,BaseType_t xIsMessageBuffer)

{
  uint8_t uVar1;
  StreamBuffer_t *pxStreamBuffer;
  uint8_t ucFlags;
  
  ucFlags = (uint8_t)xBufferSizeBytes;
  if (xIsMessageBuffer == 1) {
    uVar1 = '\x01';
    if (xBufferSizeBytes < 5) {
      vAssertCalled();
      uVar1 = '\x01';
    }
joined_r0x23032e52:
    ucFlags = uVar1;
    if (xTriggerLevelBytes <= xBufferSizeBytes) goto joined_r0x23032e00;
  }
  else {
    uVar1 = '\0';
    if (xBufferSizeBytes != 0) goto joined_r0x23032e52;
    vAssertCalled();
    if (xTriggerLevelBytes == 0) goto joined_r0x23032e00;
  }
  vAssertCalled();
joined_r0x23032e00:
  if (xTriggerLevelBytes == 0) {
    xTriggerLevelBytes = 1;
  }
  pxStreamBuffer = (StreamBuffer_t *)pvPortMalloc(xBufferSizeBytes + 0x25);
  if (pxStreamBuffer != (StreamBuffer_t *)0x0) {
    prvInitialiseNewStreamBuffer
              (pxStreamBuffer,(uint8_t *)(pxStreamBuffer + 1),xBufferSizeBytes + 1,
               xTriggerLevelBytes,ucFlags);
  }
  return (StreamBufferHandle_t)pxStreamBuffer;
}



// WARNING: Removing unreachable block (ram,0x23032ee4)

StreamBufferHandle_t
xStreamBufferGenericCreateStatic
          (size_t xBufferSizeBytes,size_t xTriggerLevelBytes,BaseType_t xIsMessageBuffer,
          uint8_t *pucStreamBufferStorageArea,StaticStreamBuffer_t *pxStaticStreamBuffer)

{
  size_t xSize;
  
  if (pucStreamBufferStorageArea == (uint8_t *)0x0) {
    vAssertCalled();
  }
  if (pxStaticStreamBuffer == (StaticStreamBuffer_t *)0x0) {
    vAssertCalled();
  }
  if (xBufferSizeBytes < xTriggerLevelBytes) {
    vAssertCalled();
  }
  if (xTriggerLevelBytes == 0) {
    xTriggerLevelBytes = 1;
  }
  if (xBufferSizeBytes < 5) {
    vAssertCalled();
  }
  if (pucStreamBufferStorageArea == (uint8_t *)0x0) {
    pxStaticStreamBuffer = (StaticStreamBuffer_t *)0x0;
  }
  else {
    if (pxStaticStreamBuffer != (StaticStreamBuffer_t *)0x0) {
      prvInitialiseNewStreamBuffer
                ((StreamBuffer_t *)pxStaticStreamBuffer,pucStreamBufferStorageArea,xBufferSizeBytes,
                 xTriggerLevelBytes,(xIsMessageBuffer != 0) + '\x02');
      pxStaticStreamBuffer->ucDummy3 = pxStaticStreamBuffer->ucDummy3 | 2;
    }
  }
  return (StreamBufferHandle_t)pxStaticStreamBuffer;
}



void vStreamBufferDelete(StreamBufferHandle_t xStreamBuffer)

{
  if (xStreamBuffer == (StreamBufferHandle_t)0x0) {
    vAssertCalled();
    if ((bRam0000001c & 2) == 0) {
      vPortFree((void *)0x0);
      return;
    }
    memset((void *)0x0,0,0x24);
    return;
  }
  if ((xStreamBuffer->ucFlags & 2) == 0) {
    vPortFree(xStreamBuffer);
    return;
  }
  memset(xStreamBuffer,0,0x24);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

size_t xStreamBufferSpacesAvailable(StreamBufferHandle_t xStreamBuffer)

{
  uint uVar1;
  size_t sVar2;
  uint uVar3;
  
  if (xStreamBuffer == (StreamBufferHandle_t)0x0) {
    vAssertCalled();
    sVar2 = (_DAT_00000008 + iRam00000000 + -1) - _DAT_00000004;
    if (_DAT_00000008 <= sVar2) {
      sVar2 = sVar2 - _DAT_00000008;
    }
    return sVar2;
  }
  uVar3 = xStreamBuffer->xLength;
  uVar1 = (uVar3 + xStreamBuffer->xTail + -1) - xStreamBuffer->xHead;
  if (uVar3 <= uVar1) {
    return uVar1 - uVar3;
  }
  return uVar1;
}



size_t xStreamBufferSend(StreamBufferHandle_t xStreamBuffer,void *pvTxData,size_t xDataLengthBytes,
                        TickType_t xTicksToWait)

{
  TaskHandle_t ptVar1;
  BaseType_t BVar2;
  uint uVar3;
  uint uVar4;
  size_t sVar5;
  TickType_t aTStack52 [2];
  size_t sStack44;
  undefined auStack40 [4];
  TimeOut_t xTimeOut;
  
  aTStack52[0] = xTicksToWait;
  if (pvTxData == (void *)0x0) {
    vAssertCalled();
  }
  if (xStreamBuffer == (StreamBufferHandle_t)0x0) {
    vAssertCalled();
  }
  sVar5 = xDataLengthBytes;
  if (((xStreamBuffer->ucFlags & 1) == 0) ||
     (sVar5 = xDataLengthBytes + 4, xDataLengthBytes < sVar5)) {
    if (aTStack52[0] != 0) goto LAB_23032fc2;
LAB_23033064:
    uVar3 = xStreamBufferSpacesAvailable(xStreamBuffer);
    if (uVar3 != 0) goto LAB_23033014;
LAB_23033070:
    sVar5 = 0;
  }
  else {
    vAssertCalled();
    if (aTStack52[0] == 0) goto LAB_23033064;
LAB_23032fc2:
    vTaskSetTimeOutState((TimeOut_t *)auStack40);
    do {
      vTaskEnterCritical();
      uVar3 = xStreamBufferSpacesAvailable(xStreamBuffer);
      if (sVar5 <= uVar3) {
        vTaskExitCritical();
        break;
      }
      xTaskNotifyStateClear((TaskHandle_t)0x0);
      if (xStreamBuffer->xTaskWaitingToSend != (TaskHandle_t)0x0) {
        vAssertCalled();
      }
      ptVar1 = xTaskGetCurrentTaskHandle();
      xStreamBuffer->xTaskWaitingToSend = ptVar1;
      vTaskExitCritical();
      xTaskNotifyWait(0,0,(uint32_t *)0x0,aTStack52[0]);
      xStreamBuffer->xTaskWaitingToSend = (TaskHandle_t)0x0;
      BVar2 = xTaskCheckForTimeOut((TimeOut_t *)auStack40,aTStack52);
    } while (BVar2 == 0);
    if (uVar3 == 0) goto LAB_23033064;
LAB_23033014:
    if ((xStreamBuffer->ucFlags & 1) == 0) {
      sStack44 = xDataLengthBytes;
      if (uVar3 < xDataLengthBytes) {
        sStack44 = uVar3;
      }
    }
    else {
      if (uVar3 < sVar5) goto LAB_23033070;
      sStack44 = xDataLengthBytes;
      prvWriteBytesToBuffer((StreamBuffer_t *)xStreamBuffer,(uint8_t *)&sStack44,4);
    }
    sVar5 = prvWriteBytesToBuffer((StreamBuffer_t *)xStreamBuffer,(uint8_t *)pvTxData,sStack44);
    if (sVar5 != 0) {
      uVar3 = xStreamBuffer->xLength;
      uVar4 = (xStreamBuffer->xHead + uVar3) - xStreamBuffer->xTail;
      if (uVar3 <= uVar4) {
        uVar4 = uVar4 - uVar3;
      }
      if (xStreamBuffer->xTriggerLevelBytes <= uVar4) {
        vTaskSuspendAll();
        if (xStreamBuffer->xTaskWaitingToReceive != (TaskHandle_t)0x0) {
          xTaskGenericNotify(xStreamBuffer->xTaskWaitingToReceive,0,eNoAction,(uint32_t *)0x0);
          xStreamBuffer->xTaskWaitingToReceive = (TaskHandle_t)0x0;
        }
        xTaskResumeAll();
      }
    }
  }
  return sVar5;
}



size_t xStreamBufferSendFromISR
                 (StreamBufferHandle_t xStreamBuffer,void *pvTxData,size_t xDataLengthBytes,
                 BaseType_t *pxHigherPriorityTaskWoken)

{
  size_t sVar1;
  uint uVar2;
  uint uVar3;
  size_t sVar4;
  size_t asStack36 [3];
  
  if (pvTxData == (void *)0x0) {
    vAssertCalled();
  }
  if (xStreamBuffer == (StreamBufferHandle_t)0x0) {
    vAssertCalled();
  }
  sVar4 = xDataLengthBytes;
  if ((xStreamBuffer->ucFlags & 1) != 0) {
    sVar4 = xDataLengthBytes + 4;
  }
  sVar1 = xStreamBufferSpacesAvailable(xStreamBuffer);
  if (sVar1 == 0) {
LAB_230330e6:
    sVar4 = 0;
  }
  else {
    if ((xStreamBuffer->ucFlags & 1) == 0) {
      asStack36[0] = xDataLengthBytes;
      if (sVar1 < xDataLengthBytes) {
        asStack36[0] = sVar1;
      }
    }
    else {
      if (sVar1 < sVar4) goto LAB_230330e6;
      asStack36[0] = xDataLengthBytes;
      prvWriteBytesToBuffer((StreamBuffer_t *)xStreamBuffer,(uint8_t *)asStack36,4);
    }
    sVar4 = prvWriteBytesToBuffer((StreamBuffer_t *)xStreamBuffer,(uint8_t *)pvTxData,asStack36[0]);
    if (sVar4 != 0) {
      uVar2 = xStreamBuffer->xLength;
      uVar3 = (xStreamBuffer->xHead + uVar2) - xStreamBuffer->xTail;
      if (uVar2 <= uVar3) {
        uVar3 = uVar3 - uVar2;
      }
      if ((xStreamBuffer->xTriggerLevelBytes <= uVar3) &&
         (xStreamBuffer->xTaskWaitingToReceive != (TaskHandle_t)0x0)) {
        xTaskGenericNotifyFromISR
                  (xStreamBuffer->xTaskWaitingToReceive,0,eNoAction,(uint32_t *)0x0,
                   pxHigherPriorityTaskWoken);
        xStreamBuffer->xTaskWaitingToReceive = (TaskHandle_t)0x0;
      }
    }
  }
  return sVar4;
}



size_t xStreamBufferReceive
                 (StreamBufferHandle_t xStreamBuffer,void *pvRxData,size_t xBufferLengthBytes,
                 TickType_t xTicksToWait)

{
  bool bVar1;
  byte bVar2;
  size_t xBytesAvailable;
  TaskHandle_t ptVar3;
  uint uVar4;
  uint uVar5;
  uint xMaxCount;
  size_t sVar6;
  uint uStack36;
  size_t xTempNextMessageLength;
  
  if (pvRxData == (void *)0x0) {
    vAssertCalled();
  }
  if (xStreamBuffer == (StreamBufferHandle_t)0x0) {
    vAssertCalled();
  }
  bVar2 = xStreamBuffer->ucFlags;
  uVar5 = (uint)bVar2 & 1;
  xMaxCount = uVar5 * 4;
  if (xTicksToWait != 0) {
    vTaskEnterCritical();
    uVar4 = xStreamBuffer->xLength;
    xBytesAvailable = (xStreamBuffer->xHead + uVar4) - xStreamBuffer->xTail;
    if (uVar4 <= xBytesAvailable) {
      xBytesAvailable = xBytesAvailable - uVar4;
    }
    if (xMaxCount < xBytesAvailable) {
      vTaskExitCritical();
      goto LAB_230331d6;
    }
    xTaskNotifyStateClear((TaskHandle_t)0x0);
    if (xStreamBuffer->xTaskWaitingToReceive != (TaskHandle_t)0x0) {
      vAssertCalled();
    }
    ptVar3 = xTaskGetCurrentTaskHandle();
    xStreamBuffer->xTaskWaitingToReceive = ptVar3;
    vTaskExitCritical();
    xTaskNotifyWait(0,0,(uint32_t *)0x0,xTicksToWait);
    xStreamBuffer->xTaskWaitingToReceive = (TaskHandle_t)0x0;
  }
  uVar4 = xStreamBuffer->xLength;
  xBytesAvailable = (xStreamBuffer->xHead + uVar4) - xStreamBuffer->xTail;
  if (uVar4 <= xBytesAvailable) {
    xBytesAvailable = xBytesAvailable - uVar4;
  }
  if (xBytesAvailable <= xMaxCount) {
    return 0;
  }
LAB_230331d6:
  if ((bVar2 & 1) != 0) {
    sVar6 = xStreamBuffer->xTail;
    prvReadBytesFromBuffer
              ((StreamBuffer_t *)xStreamBuffer,(uint8_t *)&uStack36,xMaxCount,xBytesAvailable);
    xBytesAvailable = xBytesAvailable + uVar5 * -4;
    bVar1 = xBufferLengthBytes < uStack36;
    xBufferLengthBytes = uStack36;
    if (bVar1) {
      xStreamBuffer->xTail = sVar6;
      xBufferLengthBytes = 0;
    }
  }
  xBytesAvailable =
       prvReadBytesFromBuffer
                 ((StreamBuffer_t *)xStreamBuffer,(uint8_t *)pvRxData,xBufferLengthBytes,
                  xBytesAvailable);
  if (xBytesAvailable == 0) {
    return 0;
  }
  vTaskSuspendAll();
  if (xStreamBuffer->xTaskWaitingToSend != (TaskHandle_t)0x0) {
    xTaskGenericNotify(xStreamBuffer->xTaskWaitingToSend,0,eNoAction,(uint32_t *)0x0);
    xStreamBuffer->xTaskWaitingToSend = (TaskHandle_t)0x0;
  }
  xTaskResumeAll();
  return xBytesAvailable;
}



// WARNING: Variable defined which should be unmapped: xTempNextMessageLength

size_t xStreamBufferReceiveFromISR
                 (StreamBufferHandle_t xStreamBuffer,void *pvRxData,size_t xBufferLengthBytes,
                 BaseType_t *pxHigherPriorityTaskWoken)

{
  bool bVar1;
  size_t xBytesAvailable;
  uint uVar2;
  uint uVar3;
  uint xMaxCount;
  size_t sVar4;
  uint uStack36;
  size_t xTempNextMessageLength;
  
  if (pvRxData == (void *)0x0) {
    vAssertCalled();
  }
  if (xStreamBuffer == (StreamBufferHandle_t)0x0) {
    vAssertCalled();
  }
  uVar2 = xStreamBuffer->xLength;
  uVar3 = (uint)xStreamBuffer->ucFlags & 1;
  xBytesAvailable = (xStreamBuffer->xHead + uVar2) - xStreamBuffer->xTail;
  xMaxCount = uVar3 * 4;
  if (uVar2 <= xBytesAvailable) {
    xBytesAvailable = xBytesAvailable - uVar2;
  }
  if (xMaxCount < xBytesAvailable) {
    if ((xStreamBuffer->ucFlags & 1) != 0) {
      sVar4 = xStreamBuffer->xTail;
      prvReadBytesFromBuffer
                ((StreamBuffer_t *)xStreamBuffer,(uint8_t *)&uStack36,xMaxCount,xBytesAvailable);
      xBytesAvailable = xBytesAvailable + uVar3 * -4;
      bVar1 = xBufferLengthBytes < uStack36;
      xBufferLengthBytes = uStack36;
      if (bVar1) {
        xStreamBuffer->xTail = sVar4;
        xBufferLengthBytes = 0;
      }
    }
    xBytesAvailable =
         prvReadBytesFromBuffer
                   ((StreamBuffer_t *)xStreamBuffer,(uint8_t *)pvRxData,xBufferLengthBytes,
                    xBytesAvailable);
    if (xBytesAvailable != 0) {
      if (xStreamBuffer->xTaskWaitingToSend == (TaskHandle_t)0x0) {
        return xBytesAvailable;
      }
      xTaskGenericNotifyFromISR
                (xStreamBuffer->xTaskWaitingToSend,0,eNoAction,(uint32_t *)0x0,
                 pxHigherPriorityTaskWoken);
      xStreamBuffer->xTaskWaitingToSend = (TaskHandle_t)0x0;
      return xBytesAvailable;
    }
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BaseType_t xStreamBufferIsEmpty(StreamBufferHandle_t xStreamBuffer)

{
  if (xStreamBuffer != (StreamBufferHandle_t)0x0) {
    return (uint)(xStreamBuffer->xHead == xStreamBuffer->xTail);
  }
  vAssertCalled();
  return (uint)(_DAT_00000004 == iRam00000000);
}



void prvResetNextTaskUnblockTime(void)

{
  xNextTaskUnblockTime = *(TickType_t *)((int)((pxDelayedTaskList->xListEnd).pxNext)->pvOwner + 4);
  return;
}



void prvInitialiseNewTask
               (TaskFunction_t *pxTaskCode,char *pcName,uint32_t ulStackDepth,void *pvParameters,
               UBaseType_t uxPriority,TaskHandle_t *pxCreatedTask,TCB_t *pxNewTCB)

{
  char cVar1;
  char *pcVar2;
  char *pcVar3;
  StackType_t *pSVar4;
  
  memset(pxNewTCB->pxStack,0xa5,ulStackDepth * 4);
  pSVar4 = pxNewTCB->pxStack;
  if (pcName == (char *)0x0) {
    pxNewTCB->pcTaskName[0] = '\0';
  }
  else {
    pcVar2 = pcName + 0x10;
    pcVar3 = pxNewTCB->pcTaskName;
    do {
      cVar1 = *pcName;
      pcName = pcName + 1;
      *pcVar3 = cVar1;
      if (cVar1 == '\0') break;
      pcVar3 = pcVar3 + 1;
    } while (pcName != pcVar2);
    pxNewTCB->pcTaskName[0xf] = '\0';
  }
  if (0x1f < uxPriority) {
    uxPriority = 0x1f;
  }
  pxNewTCB->uxPriority = uxPriority;
  pxNewTCB->uxBasePriority = uxPriority;
  pxNewTCB->uxMutexesHeld = 0;
  vListInitialiseItem(&pxNewTCB->xStateListItem);
  vListInitialiseItem(&pxNewTCB->xEventListItem);
  pxNewTCB->ulNotifiedValue = 0;
  *(TCB_t **)&(pxNewTCB->xStateListItem).pvOwner = pxNewTCB;
  (pxNewTCB->xEventListItem).xItemValue = 0x20 - uxPriority;
  *(TCB_t **)&(pxNewTCB->xEventListItem).pvOwner = pxNewTCB;
  pxNewTCB->uxCriticalNesting = 0;
  pxNewTCB->ucNotifyState = '\0';
  pSVar4 = (StackType_t *)
           pxPortInitialiseStack
                     ((uint)(pSVar4 + (ulStackDepth - 1)) & 0xfffffff8,pxTaskCode,pvParameters);
  pxNewTCB->pxTopOfStack = pSVar4;
  if (pxCreatedTask != (TaskHandle_t *)0x0) {
    *(TCB_t **)pxCreatedTask = pxNewTCB;
  }
  return;
}



void prvDeleteTCB(TCB_t *pxTCB)

{
  uint8_t uVar1;
  
  uVar1 = pxTCB->ucStaticallyAllocated;
  if (uVar1 == '\0') {
    vPortFree(pxTCB->pxStack);
    vPortFree(pxTCB);
    return;
  }
  if (uVar1 != '\x01') {
    if (uVar1 == '\x02') {
      return;
    }
    vAssertCalled();
    return;
  }
  vPortFree(pxTCB);
  return;
}



void prvAddCurrentTaskToDelayedList(TickType_t xTicksToWait,BaseType_t xCanBlockIndefinitely)

{
  TickType_t TVar1;
  uint uVar2;
  UBaseType_t UVar3;
  
  TVar1 = xTickCount;
  UVar3 = uxListRemove(&pxCurrentTCB->xStateListItem);
  if (UVar3 == 0) {
    uxTopReadyPriority = ~(1 << (pxCurrentTCB->uxPriority & 0x1f)) & uxTopReadyPriority;
  }
  if ((xTicksToWait == 0xffffffff) && (xCanBlockIndefinitely != 0)) {
    vListInsertEnd(&xSuspendedTaskList,&pxCurrentTCB->xStateListItem);
    return;
  }
  uVar2 = xTicksToWait + TVar1;
  (pxCurrentTCB->xStateListItem).xItemValue = uVar2;
  if (TVar1 <= uVar2) {
    vListInsert(pxDelayedTaskList,&pxCurrentTCB->xStateListItem);
    if (uVar2 < xNextTaskUnblockTime) {
      xNextTaskUnblockTime = uVar2;
    }
    return;
  }
  vListInsert(pxOverflowDelayedTaskList,&pxCurrentTCB->xStateListItem);
  return;
}



void vTaskEnterCritical(void)

{
  pxCurrentTCB->uxCriticalNesting = pxCurrentTCB->uxCriticalNesting + 1;
  return;
}



void vTaskExitCritical(void)

{
  pxCurrentTCB->uxCriticalNesting = pxCurrentTCB->uxCriticalNesting - 1;
  return;
}



void prvAddNewTaskToReadyList(TCB_t *pxNewTCB)

{
  uint uVar1;
  List_t *pxList;
  List_t *pLVar2;
  
  if (xSchedulerRunning != 0) {
    vTaskEnterCritical();
  }
  uxCurrentNumberOfTasks = uxCurrentNumberOfTasks + 1;
  if (pxCurrentTCB == (TCB_t *)0x0) {
    if (uxCurrentNumberOfTasks == 1) {
      pxList = pxReadyTasksLists;
      pxCurrentTCB = pxNewTCB;
      do {
        pLVar2 = pxList + 1;
        vListInitialise(pxList);
        pxList = pLVar2;
      } while (pLVar2 != &xDelayedTaskList1);
      vListInitialise(&xDelayedTaskList1);
      vListInitialise(&xDelayedTaskList2);
      vListInitialise(&xPendingReadyList);
      vListInitialise(&xTasksWaitingTermination);
      vListInitialise(&xSuspendedTaskList);
      pxDelayedTaskList = &xDelayedTaskList1;
      pxOverflowDelayedTaskList = &xDelayedTaskList2;
      uVar1 = pxNewTCB->uxPriority;
    }
    else {
      uVar1 = pxNewTCB->uxPriority;
      pxCurrentTCB = pxNewTCB;
    }
  }
  else {
    uVar1 = pxNewTCB->uxPriority;
    if ((xSchedulerRunning == 0) && (pxCurrentTCB->uxPriority <= uVar1)) {
      pxCurrentTCB = pxNewTCB;
    }
  }
  uxTaskNumber = uxTaskNumber + 1;
  uxTopReadyPriority = 1 << (uVar1 & 0x1f) | uxTopReadyPriority;
  pxNewTCB->uxTCBNumber = uxTaskNumber;
  vListInsertEnd(pxReadyTasksLists + uVar1,&pxNewTCB->xStateListItem);
  if ((xSchedulerRunning != 0) && (pxCurrentTCB->uxCriticalNesting != 0)) {
    vTaskExitCritical();
  }
  if ((xSchedulerRunning != 0) && (pxCurrentTCB->uxPriority < pxNewTCB->uxPriority)) {
    ecall();
  }
  return;
}


/*
Unable to decompile 'prvIdleTask'
Cause: Exception while decompiling 230336ae: Decompiler process died

*/


// WARNING: Removing unreachable block (ram,0x23033796)
// WARNING: Removing unreachable block (ram,0x230337dc)

TaskHandle_t
xTaskCreateStatic(TaskFunction_t *pxTaskCode,char *pcName,uint32_t ulStackDepth,void *pvParameters,
                 UBaseType_t uxPriority,StackType_t *puxStackBuffer,StaticTask_t *pxTaskBuffer)

{
  TaskHandle_t ptVar1;
  size_t xSize;
  TaskHandle_t xReturn;
  
  ptVar1 = (TaskHandle_t)xSize;
  if (puxStackBuffer == (StackType_t *)0x0) {
    vAssertCalled();
    ptVar1 = (TaskHandle_t)xSize;
  }
  if (pxTaskBuffer == (StaticTask_t *)0x0) {
    vAssertCalled();
    return (TaskHandle_t)0x0;
  }
  xSize = 0;
  if (puxStackBuffer != (StackType_t *)0x0) {
    pxTaskBuffer->uxDummy20 = '\x02';
    *(StackType_t **)&pxTaskBuffer->pxDummy6 = puxStackBuffer;
    xSize = (size_t)ptVar1;
    prvInitialiseNewTask
              (pxTaskCode,pcName,ulStackDepth,pvParameters,uxPriority,(TaskHandle_t *)&xSize,
               (TCB_t *)pxTaskBuffer);
    prvAddNewTaskToReadyList((TCB_t *)pxTaskBuffer);
  }
  return (TaskHandle_t)xSize;
}



BaseType_t
xTaskCreate(TaskFunction_t *pxTaskCode,char *pcName,uint16_t usStackDepth,void *pvParameters,
           UBaseType_t uxPriority,TaskHandle_t *pxCreatedTask)

{
  StackType_t *pv;
  TCB_t *pxNewTCB;
  BaseType_t BVar1;
  undefined2 in_register_00002032;
  
  pv = (StackType_t *)pvPortMalloc(CONCAT22(in_register_00002032,usStackDepth) << 2);
  if (pv == (StackType_t *)0x0) {
    BVar1 = -1;
  }
  else {
    pxNewTCB = (TCB_t *)pvPortMalloc(0x60);
    if (pxNewTCB == (TCB_t *)0x0) {
      vPortFree(pv);
      BVar1 = -1;
    }
    else {
      pxNewTCB->pxStack = pv;
      pxNewTCB->ucStaticallyAllocated = '\0';
      prvInitialiseNewTask
                (pxTaskCode,pcName,CONCAT22(in_register_00002032,usStackDepth),pvParameters,
                 uxPriority,pxCreatedTask,pxNewTCB);
      prvAddNewTaskToReadyList(pxNewTCB);
      BVar1 = 1;
    }
  }
  return BVar1;
}



void vTaskDelete(TaskHandle_t xTaskToDelete)

{
  UBaseType_t UVar1;
  
  if (xSchedulerRunning != 0) {
    vTaskEnterCritical();
  }
  if (xTaskToDelete == (TaskHandle_t)0x0) {
    xTaskToDelete = (TaskHandle_t)pxCurrentTCB;
  }
  UVar1 = uxListRemove(&((TCB_t *)xTaskToDelete)->xStateListItem);
  if ((UVar1 == 0) && (pxReadyTasksLists[((TCB_t *)xTaskToDelete)->uxPriority].uxNumberOfItems == 0)
     ) {
    uxTopReadyPriority = ~(1 << (((TCB_t *)xTaskToDelete)->uxPriority & 0x1f)) & uxTopReadyPriority;
  }
  if ((((TCB_t *)xTaskToDelete)->xEventListItem).pvContainer != (xLIST *)0x0) {
    uxListRemove(&((TCB_t *)xTaskToDelete)->xEventListItem);
  }
  uxTaskNumber = uxTaskNumber + 1;
  if (pxCurrentTCB == (TCB_t *)xTaskToDelete) {
    vListInsertEnd(&xTasksWaitingTermination,&((TCB_t *)xTaskToDelete)->xStateListItem);
    uxDeletedTasksWaitingCleanUp = uxDeletedTasksWaitingCleanUp + 1;
  }
  else {
    uxCurrentNumberOfTasks = uxCurrentNumberOfTasks - 1;
    prvDeleteTCB((TCB_t *)xTaskToDelete);
    if (pxDelayedTaskList->uxNumberOfItems == 0) {
      xNextTaskUnblockTime = 0xffffffff;
    }
    else {
      prvResetNextTaskUnblockTime();
    }
  }
  if ((xSchedulerRunning != 0) && (pxCurrentTCB->uxCriticalNesting != 0)) {
    vTaskExitCritical();
  }
  if ((xSchedulerRunning != 0) && (pxCurrentTCB == (TCB_t *)xTaskToDelete)) {
    if (uxSchedulerSuspended == 0) {
      ecall();
    }
    else {
      vAssertCalled();
      ecall();
    }
    return;
  }
  return;
}


/*
Unable to decompile 'eTaskGetState'
Cause: Exception while decompiling 2303399e: Decompiler process died

*/

/*
Unable to decompile 'vTaskStartScheduler'
Cause: Exception while decompiling 23033a6c: Decompiler process died

*/


void vTaskSuspendAll(void)

{
  uxSchedulerSuspended = uxSchedulerSuspended + 1;
  return;
}



TickType_t xTaskGetTickCount(void)

{
  return xTickCount;
}



BaseType_t xTaskGetTickCount2(TickType_t *ticks,BaseType_t *overflow)

{
  BaseType_t BVar1;
  
  BVar1 = xNumOfOverflows;
  *ticks = xTickCount;
  *overflow = BVar1;
  return 1;
}



TickType_t xTaskGetTickCountFromISR(void)

{
  return xTickCount;
}



BaseType_t xTaskIncrementTick(void)

{
  List_t *pLVar1;
  List_t *pLVar2;
  TickType_t TVar3;
  void *pvVar4;
  int iVar5;
  int iVar6;
  uint uVar7;
  uint32_t uStack52;
  uint32_t tmp;
  
  iVar6 = bl_sys_time_sync_state(&uStack52);
  if (iVar6 != 0) {
    if (uxSchedulerSuspended == 0) {
      uVar7 = xTickCount + 1;
      xTickCount = uVar7;
      if (uVar7 == 0) {
        if (pxDelayedTaskList->uxNumberOfItems != 0) {
          vAssertCalled();
        }
        pLVar2 = pxOverflowDelayedTaskList;
        pLVar1 = pxDelayedTaskList;
        pxDelayedTaskList = pxOverflowDelayedTaskList;
        pxOverflowDelayedTaskList = pLVar1;
        xNumOfOverflows = xNumOfOverflows + 1;
        if (pLVar2->uxNumberOfItems == 0) {
          xNextTaskUnblockTime = 0xffffffff;
        }
        else {
          prvResetNextTaskUnblockTime();
        }
      }
      if (uVar7 < xNextTaskUnblockTime) {
        iVar6 = 0;
        TVar3 = xNextTaskUnblockTime;
      }
      else {
        iVar6 = 0;
        while (iVar5 = iVar6, pxDelayedTaskList->uxNumberOfItems != 0) {
          while( true ) {
            pvVar4 = ((pxDelayedTaskList->xListEnd).pxNext)->pvOwner;
            TVar3 = *(uint *)((int)pvVar4 + 4);
            if (uVar7 < *(uint *)((int)pvVar4 + 4)) goto LAB_23033c92;
            uxListRemove((ListItem_t *)((int)pvVar4 + 4));
            if (*(int *)((int)pvVar4 + 0x28) != 0) {
              uxListRemove((ListItem_t *)((int)pvVar4 + 0x18));
            }
            uxTopReadyPriority = 1 << (*(uint *)((int)pvVar4 + 0x2c) & 0x1f) | uxTopReadyPriority;
            vListInsertEnd(pxReadyTasksLists + *(uint *)((int)pvVar4 + 0x2c),
                           (ListItem_t *)((int)pvVar4 + 4));
            if (*(uint *)((int)pvVar4 + 0x2c) < pxCurrentTCB->uxPriority) break;
            iVar6 = 1;
            iVar5 = 1;
            if (pxDelayedTaskList->uxNumberOfItems == 0) goto LAB_23033c78;
          }
        }
LAB_23033c78:
        xNextTaskUnblockTime = 0xffffffff;
        iVar6 = iVar5;
        TVar3 = xNextTaskUnblockTime;
      }
LAB_23033c92:
      xNextTaskUnblockTime = TVar3;
      if (1 < pxReadyTasksLists[pxCurrentTCB->uxPriority].uxNumberOfItems) {
        iVar6 = 1;
      }
    }
    else {
      iVar6 = 0;
      uxPendedTicks = uxPendedTicks + 1;
    }
    if (xYieldPending != 0) {
      iVar6 = 1;
    }
  }
  return iVar6;
}


/*
Unable to decompile 'xTaskResumeAll'
Cause: Exception while decompiling 23033cbc: Decompiler process died

*/


void vTaskDelay(TickType_t xTicksToDelay)

{
  BaseType_t BVar1;
  
  if (xTicksToDelay == 0) {
    ecall();
    return;
  }
  if (uxSchedulerSuspended != 0) {
    vAssertCalled();
  }
  uxSchedulerSuspended = uxSchedulerSuspended + 1;
  prvAddCurrentTaskToDelayedList(xTicksToDelay,0);
  BVar1 = xTaskResumeAll();
  if (BVar1 == 0) {
    ecall();
  }
  return;
}



void vTaskSwitchContext(void)

{
  int iVar1;
  StackType_t *pSVar2;
  xLIST_ITEM *pxVar3;
  
  if (uxSchedulerSuspended == 0) {
    xYieldPending = 0;
    pSVar2 = pxCurrentTCB->pxStack;
    if ((((*pSVar2 != 0xa5a5a5a5) || (pSVar2[1] != 0xa5a5a5a5)) || (pSVar2[2] != 0xa5a5a5a5)) ||
       (pSVar2[3] != 0xa5a5a5a5)) {
      vApplicationStackOverflowHook((TaskHandle_t)pxCurrentTCB,pxCurrentTCB->pcTaskName);
    }
    iVar1 = __clzsi2(uxTopReadyPriority);
    iVar1 = 0x1f - iVar1;
    if (pxReadyTasksLists[iVar1].uxNumberOfItems == 0) {
      vAssertCalled();
    }
    pxVar3 = (pxReadyTasksLists[iVar1].pxIndex)->pxNext;
    *(xLIST_ITEM **)&pxReadyTasksLists[iVar1].pxIndex = pxVar3;
    if (pxVar3 == (xLIST_ITEM *)(iVar1 * 0x14 + 0x42012c10)) {
      pxVar3 = pxVar3->pxNext;
      *(xLIST_ITEM **)&pxReadyTasksLists[iVar1].pxIndex = pxVar3;
    }
    pxCurrentTCB = (TCB_t *)pxVar3->pvOwner;
    return;
  }
  xYieldPending = 1;
  return;
}



void vTaskPlaceOnEventList(List_t *pxEventList,TickType_t xTicksToWait)

{
  if (pxEventList == (List_t *)0x0) {
    vAssertCalled();
  }
  vListInsert(pxEventList,&pxCurrentTCB->xEventListItem);
  prvAddCurrentTaskToDelayedList(xTicksToWait,1);
  return;
}



void vTaskPlaceOnUnorderedEventList
               (List_t *pxEventList,TickType_t xItemValue,TickType_t xTicksToWait)

{
  ListItem_t *pxNewListItem;
  
  if (pxEventList == (List_t *)0x0) {
    vAssertCalled();
  }
  if (uxSchedulerSuspended == 0) {
    vAssertCalled();
  }
  pxNewListItem = &pxCurrentTCB->xEventListItem;
  (pxCurrentTCB->xEventListItem).xItemValue = xItemValue | 0x80000000;
  vListInsertEnd(pxEventList,pxNewListItem);
  prvAddCurrentTaskToDelayedList(xTicksToWait,1);
  return;
}



void vTaskPlaceOnEventListRestricted
               (List_t *pxEventList,TickType_t xTicksToWait,BaseType_t xWaitIndefinitely)

{
  if (pxEventList == (List_t *)0x0) {
    vAssertCalled();
  }
  vListInsertEnd(pxEventList,&pxCurrentTCB->xEventListItem);
  if (xWaitIndefinitely != 0) {
    xTicksToWait = 0xffffffff;
  }
  prvAddCurrentTaskToDelayedList(xTicksToWait,xWaitIndefinitely);
  return;
}



BaseType_t xTaskRemoveFromEventList(List_t *pxEventList)

{
  bool bVar1;
  void *pvVar2;
  
  pvVar2 = ((pxEventList->xListEnd).pxNext)->pvOwner;
  if (pvVar2 == (void *)0x0) {
    vAssertCalled();
  }
  uxListRemove((ListItem_t *)((int)pvVar2 + 0x18));
  if (uxSchedulerSuspended == 0) {
    uxListRemove((ListItem_t *)((int)pvVar2 + 4));
    uxTopReadyPriority = 1 << (*(uint *)((int)pvVar2 + 0x2c) & 0x1f) | uxTopReadyPriority;
    vListInsertEnd(pxReadyTasksLists + *(uint *)((int)pvVar2 + 0x2c),(ListItem_t *)((int)pvVar2 + 4)
                  );
  }
  else {
    vListInsertEnd(&xPendingReadyList,(ListItem_t *)((int)pvVar2 + 0x18));
  }
  bVar1 = pxCurrentTCB->uxPriority < *(uint *)((int)pvVar2 + 0x2c);
  if (bVar1) {
    xYieldPending = 1;
  }
  return (uint)bVar1;
}



void vTaskRemoveFromUnorderedEventList(ListItem_t *pxEventListItem,TickType_t xItemValue)

{
  void *pvVar1;
  
  if (uxSchedulerSuspended == 0) {
    vAssertCalled();
    pvVar1 = pxEventListItem->pvOwner;
    pxEventListItem->xItemValue = xItemValue | 0x80000000;
  }
  else {
    pvVar1 = pxEventListItem->pvOwner;
    pxEventListItem->xItemValue = xItemValue | 0x80000000;
  }
  if (pvVar1 == (void *)0x0) {
    vAssertCalled();
  }
  uxListRemove(pxEventListItem);
  uxListRemove((ListItem_t *)((int)pvVar1 + 4));
  uxTopReadyPriority = 1 << (*(uint *)((int)pvVar1 + 0x2c) & 0x1f) | uxTopReadyPriority;
  vListInsertEnd(pxReadyTasksLists + *(uint *)((int)pvVar1 + 0x2c),(ListItem_t *)((int)pvVar1 + 4));
  if (pxCurrentTCB->uxPriority < *(uint *)((int)pvVar1 + 0x2c)) {
    xYieldPending = 1;
  }
  return;
}


/*
Unable to decompile 'vTaskSetTimeOutState'
Cause: Exception while decompiling 23034116: Decompiler process died

*/


void vTaskInternalSetTimeOutState(TimeOut_t *pxTimeOut)

{
  TickType_t TVar1;
  
  TVar1 = xTickCount;
  pxTimeOut->xOverflowCount = xNumOfOverflows;
  pxTimeOut->xTimeOnEntering = TVar1;
  return;
}


/*
Unable to decompile 'xTaskCheckForTimeOut'
Cause: Exception while decompiling 2303418c: Decompiler process died

*/


void vTaskMissedYield(void)

{
  xYieldPending = 1;
  return;
}



void vTaskGetInfo(TaskHandle_t xTask,TaskStatus_t *pxTaskStatus,BaseType_t xGetFreeStackSpace,
                 eTaskState eState)

{
  eTaskState eVar1;
  undefined3 in_register_00002035;
  UBaseType_t UVar2;
  uint uVar3;
  
  if (xTask == (TaskHandle_t)0x0) {
    xTask = (TaskHandle_t)pxCurrentTCB;
  }
  pxTaskStatus->pcTaskName = xTask->pcTaskName;
  pxTaskStatus->xHandle = xTask;
  pxTaskStatus->uxCurrentPriority = xTask->uxPriority;
  pxTaskStatus->pxStackBase = xTask->pxStack;
  pxTaskStatus->xTaskNumber = xTask->uxTCBNumber;
  UVar2 = xTask->uxBasePriority;
  pxTaskStatus->ulRunTimeCounter = 0;
  pxTaskStatus->uxBasePriority = UVar2;
  if (CONCAT31(in_register_00002035,eState) == 5) {
    eVar1 = eTaskGetState(xTask);
    pxTaskStatus->eCurrentState = eVar1;
  }
  else {
    if (pxCurrentTCB == (TCB_t *)xTask) {
      pxTaskStatus->eCurrentState = eRunning;
    }
    else {
      pxTaskStatus->eCurrentState = eState;
      if (CONCAT31(in_register_00002035,eState) == 3) {
        uxSchedulerSuspended = uxSchedulerSuspended + 1;
        if ((xTask->xEventListItem).pvContainer != (xLIST *)0x0) {
          pxTaskStatus->eCurrentState = eBlocked;
        }
        xTaskResumeAll();
      }
    }
  }
  if (xGetFreeStackSpace != 0) {
    if (*(char *)xTask->pxStack == -0x5b) {
      uVar3 = 0;
      do {
        uVar3 = uVar3 + 1;
      } while (*(char *)((int)xTask->pxStack + uVar3) == -0x5b);
      pxTaskStatus->usStackHighWaterMark = (uint16_t)(uVar3 >> 2);
    }
    else {
      pxTaskStatus->usStackHighWaterMark = 0;
    }
    return;
  }
  pxTaskStatus->usStackHighWaterMark = 0;
  return;
}



UBaseType_t
prvListTasksWithinSingleList(TaskStatus_t *pxTaskStatusArray,List_t *pxList,eTaskState eState)

{
  TaskHandle_t xTask;
  xLIST_ITEM *pxVar1;
  int iVar2;
  TaskHandle_t ptVar3;
  
  pxVar1 = pxList->pxIndex->pxNext;
  *(xLIST_ITEM **)&pxList->pxIndex = pxVar1;
  if (pxVar1 == (xLIST_ITEM *)&pxList->xListEnd) {
    pxVar1 = (pxList->xListEnd).pxNext;
    *(xLIST_ITEM **)&pxList->pxIndex = pxVar1;
  }
  ptVar3 = (TaskHandle_t)pxVar1->pvOwner;
  iVar2 = 0;
  while( true ) {
    pxVar1 = pxVar1->pxNext;
    *(xLIST_ITEM **)&pxList->pxIndex = pxVar1;
    if ((xLIST_ITEM *)&pxList->xListEnd == pxVar1) {
      pxVar1 = (pxList->xListEnd).pxNext;
      *(xLIST_ITEM **)&pxList->pxIndex = pxVar1;
      xTask = (TaskHandle_t)pxVar1->pvOwner;
      vTaskGetInfo(xTask,pxTaskStatusArray,1,eState);
    }
    else {
      xTask = (TaskHandle_t)pxVar1->pvOwner;
      vTaskGetInfo(xTask,pxTaskStatusArray,1,eState);
    }
    if (ptVar3 == xTask) break;
    iVar2 = iVar2 + 1;
    pxTaskStatusArray = pxTaskStatusArray + 1;
    pxVar1 = (xLIST_ITEM *)pxList->pxIndex;
  }
  return iVar2 + 1;
}



UBaseType_t
uxTaskGetSystemState
          (TaskStatus_t *pxTaskStatusArray,UBaseType_t uxArraySize,uint32_t *pulTotalRunTime)

{
  int iVar1;
  UBaseType_t UVar2;
  int iVar3;
  TaskStatus_t *pxTaskStatusArray_00;
  UBaseType_t UVar4;
  List_t *pxList;
  
  uxSchedulerSuspended = uxSchedulerSuspended + 1;
  UVar4 = 0;
  if (uxCurrentNumberOfTasks <= uxArraySize) {
    pxList = pxReadyTasksLists + 0x1f;
    iVar1 = 0x20;
    UVar4 = 0;
    iVar3 = 0;
    do {
      iVar1 = iVar1 + -1;
      pxTaskStatusArray_00 = (TaskStatus_t *)(&pxTaskStatusArray->xHandle + iVar3 + UVar4);
      if (pxReadyTasksLists[iVar1].uxNumberOfItems != 0) {
        UVar2 = prvListTasksWithinSingleList(pxTaskStatusArray_00,pxList,eReady);
        UVar4 = UVar4 + UVar2;
        iVar3 = UVar4 * 8;
        pxTaskStatusArray_00 = pxTaskStatusArray + UVar4;
      }
      pxList = pxList + -1;
    } while (iVar1 != 0);
    if (pxDelayedTaskList->uxNumberOfItems != 0) {
      UVar2 = prvListTasksWithinSingleList(pxTaskStatusArray_00,pxDelayedTaskList,eBlocked);
      UVar4 = UVar4 + UVar2;
      pxTaskStatusArray_00 = pxTaskStatusArray + UVar4;
    }
    if (pxOverflowDelayedTaskList->uxNumberOfItems != 0) {
      UVar2 = prvListTasksWithinSingleList(pxTaskStatusArray_00,pxOverflowDelayedTaskList,eBlocked);
      UVar4 = UVar4 + UVar2;
      pxTaskStatusArray_00 = pxTaskStatusArray + UVar4;
    }
    if (xTasksWaitingTermination.uxNumberOfItems != 0) {
      UVar2 = prvListTasksWithinSingleList(pxTaskStatusArray_00,&xTasksWaitingTermination,eDeleted);
      UVar4 = UVar4 + UVar2;
      pxTaskStatusArray_00 = pxTaskStatusArray + UVar4;
    }
    if (xSuspendedTaskList.uxNumberOfItems != 0) {
      UVar2 = prvListTasksWithinSingleList(pxTaskStatusArray_00,&xSuspendedTaskList,eSuspended);
      UVar4 = UVar4 + UVar2;
    }
    if (pulTotalRunTime != (uint32_t *)0x0) {
      *pulTotalRunTime = 0;
    }
  }
  xTaskResumeAll();
  return UVar4;
}



TaskHandle_t xTaskGetCurrentTaskHandle(void)

{
  return (TaskHandle_t)pxCurrentTCB;
}



BaseType_t xTaskGetSchedulerState(void)

{
  BaseType_t BVar1;
  
  BVar1 = 1;
  if (xSchedulerRunning != 0) {
    BVar1 = (uint)(uxSchedulerSuspended == 0) << 1;
  }
  return BVar1;
}



BaseType_t xTaskPriorityInherit(TaskHandle_t pxMutexHolder)

{
  UBaseType_t UVar1;
  uint uVar2;
  
  if (pxMutexHolder == (TaskHandle_t)0x0) {
    return 0;
  }
  uVar2 = pxMutexHolder->uxPriority;
  if (uVar2 < pxCurrentTCB->uxPriority) {
    if (-1 < (int)(pxMutexHolder->xEventListItem).xItemValue) {
      (pxMutexHolder->xEventListItem).xItemValue = 0x20 - pxCurrentTCB->uxPriority;
    }
    if ((List_t *)(pxMutexHolder->xStateListItem).pvContainer != pxReadyTasksLists + uVar2) {
      pxMutexHolder->uxPriority = pxCurrentTCB->uxPriority;
      return 1;
    }
    UVar1 = uxListRemove(&pxMutexHolder->xStateListItem);
    if ((UVar1 == 0) && (pxReadyTasksLists[pxMutexHolder->uxPriority].uxNumberOfItems == 0)) {
      uxTopReadyPriority = ~(1 << (pxMutexHolder->uxPriority & 0x1f)) & uxTopReadyPriority;
    }
    uVar2 = pxCurrentTCB->uxPriority;
    uxTopReadyPriority = 1 << (uVar2 & 0x1f) | uxTopReadyPriority;
    pxMutexHolder->uxPriority = uVar2;
    vListInsertEnd(pxReadyTasksLists + uVar2,&pxMutexHolder->xStateListItem);
    uVar2 = 1;
  }
  else {
    uVar2 = (uint)(pxMutexHolder->uxBasePriority < pxCurrentTCB->uxPriority);
  }
  return uVar2;
}



BaseType_t xTaskPriorityDisinherit(TaskHandle_t pxMutexHolder)

{
  uint uVar1;
  UBaseType_t UVar2;
  
  if (pxMutexHolder == (TaskHandle_t)0x0) {
    return 0;
  }
  if (pxCurrentTCB != (TCB_t *)pxMutexHolder) {
    vAssertCalled();
  }
  if (pxMutexHolder->uxMutexesHeld == 0) {
    vAssertCalled();
    UVar2 = pxMutexHolder->uxMutexesHeld - 1;
    pxMutexHolder->uxMutexesHeld = UVar2;
    if (pxMutexHolder->uxPriority == pxMutexHolder->uxBasePriority) {
      return 0;
    }
  }
  else {
    UVar2 = pxMutexHolder->uxMutexesHeld - 1;
    pxMutexHolder->uxMutexesHeld = UVar2;
    if (pxMutexHolder->uxPriority == pxMutexHolder->uxBasePriority) {
      return 0;
    }
  }
  if (UVar2 != 0) {
    return 0;
  }
  UVar2 = uxListRemove(&pxMutexHolder->xStateListItem);
  if ((UVar2 == 0) && (pxReadyTasksLists[pxMutexHolder->uxPriority].uxNumberOfItems == 0)) {
    uxTopReadyPriority = ~(1 << (pxMutexHolder->uxPriority & 0x1f)) & uxTopReadyPriority;
  }
  uVar1 = pxMutexHolder->uxBasePriority;
  uxTopReadyPriority = 1 << (uVar1 & 0x1f) | uxTopReadyPriority;
  pxMutexHolder->uxPriority = uVar1;
  (pxMutexHolder->xEventListItem).xItemValue = 0x20 - uVar1;
  vListInsertEnd(pxReadyTasksLists + uVar1,&pxMutexHolder->xStateListItem);
  return 1;
}



void vTaskPriorityDisinheritAfterTimeout
               (TaskHandle_t pxMutexHolder,UBaseType_t uxHighestPriorityWaitingTask)

{
  UBaseType_t UVar1;
  TickType_t TVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  
  if (pxMutexHolder == (TaskHandle_t)0x0) {
    return;
  }
  if (pxMutexHolder->uxMutexesHeld == 0) {
    vAssertCalled();
    uVar5 = pxMutexHolder->uxBasePriority;
  }
  else {
    uVar5 = pxMutexHolder->uxBasePriority;
  }
  if (uVar5 < uxHighestPriorityWaitingTask) {
    uVar3 = pxMutexHolder->uxPriority;
    if (uVar3 == uxHighestPriorityWaitingTask) {
      return;
    }
  }
  else {
    uVar3 = pxMutexHolder->uxPriority;
    uxHighestPriorityWaitingTask = uVar5;
    if (uVar3 == uVar5) {
      return;
    }
  }
  if (pxMutexHolder->uxMutexesHeld == 1) {
    if (pxCurrentTCB == (TCB_t *)pxMutexHolder) {
      vAssertCalled();
      uVar3 = pxMutexHolder->uxPriority;
    }
    TVar2 = (pxMutexHolder->xEventListItem).xItemValue;
    pxMutexHolder->uxPriority = uxHighestPriorityWaitingTask;
    if (-1 < (int)TVar2) {
      (pxMutexHolder->xEventListItem).xItemValue = 0x20 - uxHighestPriorityWaitingTask;
    }
    if ((List_t *)(pxMutexHolder->xStateListItem).pvContainer == pxReadyTasksLists + uVar3) {
      UVar1 = uxListRemove(&pxMutexHolder->xStateListItem);
      if (UVar1 == 0) {
        uVar5 = pxMutexHolder->uxPriority;
        iVar4 = uVar5 * 4;
        uVar3 = 1 << (uVar5 & 0x1f);
        if (pxReadyTasksLists[uVar5].uxNumberOfItems == 0) {
          uxTopReadyPriority = ~uVar3 & uxTopReadyPriority;
        }
      }
      else {
        uVar5 = pxMutexHolder->uxPriority;
        uVar3 = 1 << (uVar5 & 0x1f);
        iVar4 = uVar5 << 2;
      }
      uxTopReadyPriority = uVar3 | uxTopReadyPriority;
      vListInsertEnd((List_t *)(&pxReadyTasksLists[0].uxNumberOfItems + iVar4 + uVar5),
                     &pxMutexHolder->xStateListItem);
      return;
    }
  }
  return;
}



void vTaskEnterCritical(void)

{
  if (xSchedulerRunning == 0) {
    return;
  }
  vTaskEnterCritical();
  return;
}



void vTaskExitCritical(void)

{
  if ((xSchedulerRunning != 0) && (pxCurrentTCB->uxCriticalNesting != 0)) {
    vTaskExitCritical();
    return;
  }
  return;
}



void vTaskList(char *pcWriteBuffer)

{
  TaskStatus_t *pTVar1;
  TaskStatus_t *pxTaskStatusArray;
  UBaseType_t uxArraySize;
  size_t sVar2;
  char *pcVar3;
  uint uVar4;
  
  uxArraySize = uxCurrentNumberOfTasks;
  *pcWriteBuffer = '\0';
  pxTaskStatusArray = (TaskStatus_t *)pvPortMalloc(uxArraySize * 0x24);
  if (pxTaskStatusArray != (TaskStatus_t *)0x0) {
    uxArraySize = uxTaskGetSystemState(pxTaskStatusArray,uxArraySize,(uint32_t *)0x0);
    if (uxArraySize != 0) {
      pTVar1 = pxTaskStatusArray;
      do {
        uVar4 = 0;
        if (pTVar1->eCurrentState < eInvalid) {
          uVar4 = (uint)(byte)"XRBSD"[pTVar1->eCurrentState];
        }
        strcpy(pcWriteBuffer,pTVar1->pcTaskName);
        sVar2 = strlen(pcWriteBuffer);
        if (sVar2 < 0xf) {
          pcVar3 = pcWriteBuffer + sVar2;
          do {
            *pcVar3 = ' ';
            pcVar3 = pcVar3 + 1;
          } while (pcWriteBuffer + 0xf != pcVar3);
          sVar2 = 0xf;
        }
        pcWriteBuffer = pcWriteBuffer + sVar2;
        *pcWriteBuffer = '\0';
        sprintf(pcWriteBuffer,"\t%c\t%u\t%u\t%u\t%p\r\n",uVar4,pTVar1->uxCurrentPriority,
                (uint)pTVar1->usStackHighWaterMark,pTVar1->xTaskNumber,pTVar1->pxStackBase);
        sVar2 = strlen(pcWriteBuffer);
        pTVar1 = pTVar1 + 1;
        pcWriteBuffer = pcWriteBuffer + sVar2;
      } while (pTVar1 != pxTaskStatusArray + uxArraySize);
    }
    vPortFree(pxTaskStatusArray);
    return;
  }
  return;
}



TickType_t uxTaskResetEventItemValue(void)

{
  TickType_t TVar1;
  
  TVar1 = (pxCurrentTCB->xEventListItem).xItemValue;
  (pxCurrentTCB->xEventListItem).xItemValue = 0x20 - pxCurrentTCB->uxPriority;
  return TVar1;
}



TaskHandle_t pvTaskIncrementMutexHeldCount(void)

{
  if (pxCurrentTCB != (TCB_t *)0x0) {
    pxCurrentTCB->uxMutexesHeld = pxCurrentTCB->uxMutexesHeld + 1;
  }
  return (TaskHandle_t)pxCurrentTCB;
}


/*
Unable to decompile 'ulTaskNotifyTake'
Cause: Exception while decompiling 23034906: Decompiler process died

*/

/*
Unable to decompile 'xTaskNotifyWait'
Cause: Exception while decompiling 230349ac: Decompiler process died

*/

/*
Unable to decompile 'xTaskGenericNotify'
Cause: 
Low-level Error: Assignment to constant at r0x23034aa6
*/


BaseType_t
xTaskGenericNotifyFromISR
          (TaskHandle_t xTaskToNotify,uint32_t ulValue,eNotifyAction eAction,
          uint32_t *pulPreviousNotificationValue,BaseType_t *pxHigherPriorityTaskWoken)

{
  uint8_t uVar1;
  undefined3 in_register_00002031;
  
  if (xTaskToNotify == (TaskHandle_t)0x0) {
    vAssertCalled();
  }
  if (pulPreviousNotificationValue != (uint32_t *)0x0) {
    *pulPreviousNotificationValue = xTaskToNotify->ulNotifiedValue;
  }
  uVar1 = xTaskToNotify->ucNotifyState;
  xTaskToNotify->ucNotifyState = '\x02';
  switch(CONCAT31(in_register_00002031,eAction)) {
  case 0:
    break;
  case 1:
    xTaskToNotify->ulNotifiedValue = ulValue | xTaskToNotify->ulNotifiedValue;
    break;
  case 2:
    xTaskToNotify->ulNotifiedValue = xTaskToNotify->ulNotifiedValue + 1;
    break;
  case 4:
    if (uVar1 == '\x02') {
      return 0;
    }
  case 3:
    xTaskToNotify->ulNotifiedValue = ulValue;
    break;
  default:
    if (xTaskToNotify->ulNotifiedValue != 0xffffffff) {
      vAssertCalled();
    }
  }
  if (uVar1 == '\x01') {
    if ((xTaskToNotify->xEventListItem).pvContainer != (xLIST *)0x0) {
      vAssertCalled();
    }
    if (uxSchedulerSuspended == 0) {
      uxListRemove(&xTaskToNotify->xStateListItem);
      uxTopReadyPriority = 1 << (xTaskToNotify->uxPriority & 0x1f) | uxTopReadyPriority;
      vListInsertEnd(pxReadyTasksLists + xTaskToNotify->uxPriority,&xTaskToNotify->xStateListItem);
    }
    else {
      vListInsertEnd(&xPendingReadyList,&xTaskToNotify->xEventListItem);
    }
    if (pxCurrentTCB->uxPriority < xTaskToNotify->uxPriority) {
      if (pxHigherPriorityTaskWoken != (BaseType_t *)0x0) {
        *pxHigherPriorityTaskWoken = 1;
      }
      xYieldPending = 1;
    }
  }
  return 1;
}



void vTaskNotifyGiveFromISR(TaskHandle_t xTaskToNotify,BaseType_t *pxHigherPriorityTaskWoken)

{
  uint8_t uVar1;
  
  if (xTaskToNotify == (TaskHandle_t)0x0) {
    vAssertCalled();
  }
  uVar1 = xTaskToNotify->ucNotifyState;
  xTaskToNotify->ucNotifyState = '\x02';
  xTaskToNotify->ulNotifiedValue = xTaskToNotify->ulNotifiedValue + 1;
  if (uVar1 == '\x01') {
    if ((xTaskToNotify->xEventListItem).pvContainer != (xLIST *)0x0) {
      vAssertCalled();
    }
    if (uxSchedulerSuspended == 0) {
      uxListRemove(&xTaskToNotify->xStateListItem);
      uxTopReadyPriority = 1 << (xTaskToNotify->uxPriority & 0x1f) | uxTopReadyPriority;
      vListInsertEnd(pxReadyTasksLists + xTaskToNotify->uxPriority,&xTaskToNotify->xStateListItem);
    }
    else {
      vListInsertEnd(&xPendingReadyList,&xTaskToNotify->xEventListItem);
    }
    if (pxCurrentTCB->uxPriority < xTaskToNotify->uxPriority) {
      if (pxHigherPriorityTaskWoken != (BaseType_t *)0x0) {
        *pxHigherPriorityTaskWoken = 1;
      }
      xYieldPending = 1;
      return;
    }
  }
  return;
}



BaseType_t xTaskNotifyStateClear(TaskHandle_t xTask)

{
  bool bVar1;
  
  if (xTask == (TaskHandle_t)0x0) {
    xTask = (TaskHandle_t)pxCurrentTCB;
  }
  if (xSchedulerRunning != 0) {
    vTaskEnterCritical();
  }
  bVar1 = ((TCB_t *)xTask)->ucNotifyState == '\x02';
  if (bVar1) {
    ((TCB_t *)xTask)->ucNotifyState = '\0';
  }
  if ((xSchedulerRunning != 0) && (pxCurrentTCB->uxCriticalNesting != 0)) {
    vTaskExitCritical();
  }
  return (uint)bVar1;
}



void prvCheckForValidListAndQueue(void)

{
  uint8_t ucStaticTimerQueueStorage [64];
  StaticQueue_t xStaticTimerQueue;
  
  vTaskEnterCritical();
  if (xTimerQueue == (QueueHandle_t)0x0) {
    vListInitialise(&xActiveTimerList1);
    vListInitialise(&xActiveTimerList2);
    pxCurrentTimerList = &xActiveTimerList1;
    pxOverflowTimerList = &xActiveTimerList2;
    xTimerQueue = xQueueGenericCreateStatic
                            (4,0x10,ucStaticTimerQueueStorage,&xStaticTimerQueue,'\0');
    if (xTimerQueue != (QueueHandle_t)0x0) {
      vQueueAddToRegistry(xTimerQueue,"TmrQ");
    }
  }
  vTaskExitCritical();
  return;
}



BaseType_t
prvInsertTimerInActiveList
          (Timer_t *pxTimer,TickType_t xNextExpiryTime,TickType_t xTimeNow,TickType_t xCommandTime)

{
  (pxTimer->xTimerListItem).xItemValue = xNextExpiryTime;
  *(Timer_t **)&(pxTimer->xTimerListItem).pvOwner = pxTimer;
  if (xTimeNow < xNextExpiryTime) {
    if ((xCommandTime <= xTimeNow) || (xNextExpiryTime < xCommandTime)) {
      vListInsert(pxCurrentTimerList,&pxTimer->xTimerListItem);
      return 0;
    }
  }
  else {
    if (xTimeNow - xCommandTime < pxTimer->xTimerPeriodInTicks) {
      vListInsert(pxOverflowTimerList,&pxTimer->xTimerListItem);
      return 0;
    }
  }
  return 1;
}



BaseType_t xTimerCreateTimerTask(void)

{
  StaticTask_t *pSStack28;
  StaticTask_t *pxTimerTaskTCBBuffer;
  StackType_t *pxTimerTaskStackBuffer;
  uint32_t ulTimerTaskStackSize;
  
  prvCheckForValidListAndQueue();
  if (xTimerQueue != (QueueHandle_t)0x0) {
    pSStack28 = (StaticTask_t *)0x0;
    pxTimerTaskTCBBuffer = (StaticTask_t *)0x0;
    vApplicationGetTimerTaskMemory
              (&pSStack28,(StackType_t **)&pxTimerTaskTCBBuffer,(uint32_t *)&pxTimerTaskStackBuffer)
    ;
    xTimerTaskHandle =
         xTaskCreateStatic(prvTimerTask,"Tmr Svc",(uint32_t)pxTimerTaskStackBuffer,(void *)0x0,0x1f,
                           (StackType_t *)pxTimerTaskTCBBuffer,pSStack28);
    if (xTimerTaskHandle != (TaskHandle_t)0x0) {
      return 1;
    }
  }
  vAssertCalled();
  return 0;
}



TimerHandle_t
xTimerCreate(char *pcTimerName,TickType_t xTimerPeriodInTicks,UBaseType_t uxAutoReload,
            void *pvTimerID,TimerCallbackFunction_t *pxCallbackFunction)

{
  TimerHandle_t ptVar1;
  
  ptVar1 = (TimerHandle_t)pvPortMalloc(0x2c);
  if (ptVar1 != (TimerHandle_t)0x0) {
    ptVar1->ucStatus = '\0';
    if (xTimerPeriodInTicks == 0) {
      vAssertCalled();
    }
    prvCheckForValidListAndQueue();
    ptVar1->pcTimerName = pcTimerName;
    ptVar1->xTimerPeriodInTicks = xTimerPeriodInTicks;
    ptVar1->pvTimerID = pvTimerID;
    ptVar1->pxCallbackFunction = pxCallbackFunction;
    vListInitialiseItem(&ptVar1->xTimerListItem);
    if (uxAutoReload != 0) {
      ptVar1->ucStatus = ptVar1->ucStatus | 4;
    }
  }
  return ptVar1;
}



// WARNING: Removing unreachable block (ram,0x23034fc4)

TimerHandle_t
xTimerCreateStatic(char *pcTimerName,TickType_t xTimerPeriodInTicks,UBaseType_t uxAutoReload,
                  void *pvTimerID,TimerCallbackFunction_t *pxCallbackFunction,
                  StaticTimer_t *pxTimerBuffer)

{
  size_t xSize;
  
  if (pxTimerBuffer == (StaticTimer_t *)0x0) {
    vAssertCalled(0x2c);
  }
  else {
    pxTimerBuffer->ucDummy8 = '\x02';
    if (xTimerPeriodInTicks == 0) {
      vAssertCalled();
    }
    prvCheckForValidListAndQueue();
    *(char **)&pxTimerBuffer->pvDummy1 = pcTimerName;
    pxTimerBuffer->xDummy3 = xTimerPeriodInTicks;
    pxTimerBuffer->pvDummy5 = pvTimerID;
    *(TimerCallbackFunction_t **)&pxTimerBuffer->pvDummy6 = pxCallbackFunction;
    vListInitialiseItem((ListItem_t *)&pxTimerBuffer->xDummy2);
    if (uxAutoReload != 0) {
      pxTimerBuffer->ucDummy8 = pxTimerBuffer->ucDummy8 | 4;
    }
  }
  return (TimerHandle_t)pxTimerBuffer;
}



// WARNING: Could not reconcile some variable overlaps

BaseType_t
xTimerGenericCommand
          (TimerHandle_t xTimer,BaseType_t xCommandID,TickType_t xOptionalValue,
          BaseType_t *pxHigherPriorityTaskWoken,TickType_t xTicksToWait)

{
  BaseType_t BVar1;
  BaseType_t BStack48;
  DaemonTaskMessage_t xMessage;
  
  if (xTimer == (TimerHandle_t)0x0) {
    vAssertCalled();
  }
  BVar1 = 0;
  if (xTimerQueue != (QueueHandle_t)0x0) {
    BStack48 = xCommandID;
    xMessage.xMessageID = xOptionalValue;
    xMessage.u._0_4_ = xTimer;
    if (5 < xCommandID) {
      BVar1 = xQueueGenericSendFromISR(xTimerQueue,&BStack48,pxHigherPriorityTaskWoken,0);
      return BVar1;
    }
    BVar1 = xTaskGetSchedulerState();
    if (BVar1 == 2) {
      BVar1 = xQueueGenericSend(xTimerQueue,&BStack48,xTicksToWait,0);
      return BVar1;
    }
    BVar1 = xQueueGenericSend(xTimerQueue,&BStack48,0,0);
  }
  return BVar1;
}



void prvSwitchTimerLists(void)

{
  List_t *pxList;
  TimerHandle_t xTimer;
  BaseType_t BVar1;
  xLIST_ITEM *pxVar2;
  uint uVar3;
  uint xOptionalValue;
  
  while (pxList = pxCurrentTimerList, pxCurrentTimerList->uxNumberOfItems != 0) {
    pxVar2 = (pxCurrentTimerList->xListEnd).pxNext;
    xTimer = (TimerHandle_t)pxVar2->pvOwner;
    xOptionalValue = pxVar2->xItemValue;
    uxListRemove(&xTimer->xTimerListItem);
    (*xTimer->pxCallbackFunction)(xTimer);
    pxList = pxCurrentTimerList;
    if ((xTimer->ucStatus & 4) != 0) {
      uVar3 = xTimer->xTimerPeriodInTicks + xOptionalValue;
      if (xOptionalValue < uVar3) {
        (xTimer->xTimerListItem).xItemValue = uVar3;
        *(TimerHandle_t *)&(xTimer->xTimerListItem).pvOwner = xTimer;
        vListInsert(pxList,&xTimer->xTimerListItem);
      }
      else {
        BVar1 = xTimerGenericCommand(xTimer,0,xOptionalValue,(BaseType_t *)0x0,0);
        if (BVar1 == 0) {
          vAssertCalled();
        }
      }
    }
  }
  pxCurrentTimerList = pxOverflowTimerList;
  pxOverflowTimerList = pxList;
  return;
}



// WARNING: Could not reconcile some variable overlaps

void prvTimerTask(void *pvParameters)

{
  uint xTimeNow;
  BaseType_t BVar1;
  TickType_t xTimeNow_00;
  TickType_t TVar2;
  uint xWaitIndefinitely;
  UBaseType_t xCommandTime;
  Timer_t *pxTimer;
  uint uStack64;
  DaemonTaskMessage_t xMessage;
  
  do {
    xCommandTime = pxCurrentTimerList->uxNumberOfItems;
    if (xCommandTime == 0) {
      vTaskSuspendAll(pvParameters);
      xTimeNow = xTaskGetTickCount();
      if (xTimeNow < xLastTime_2297) goto LAB_230352ac;
      xWaitIndefinitely = (uint)(pxOverflowTimerList->uxNumberOfItems == 0);
LAB_230351a6:
      xLastTime_2297 = xTimeNow;
      vQueueWaitForMessageRestricted(xTimerQueue,xCommandTime - xTimeNow,xWaitIndefinitely);
      BVar1 = xTaskResumeAll();
      if (BVar1 == 0) {
        ecall();
      }
    }
    else {
      xCommandTime = ((pxCurrentTimerList->xListEnd).pxNext)->xItemValue;
      vTaskSuspendAll(pvParameters);
      xTimeNow = xTaskGetTickCount();
      if (xTimeNow < xLastTime_2297) {
LAB_230352ac:
        prvSwitchTimerLists();
        xLastTime_2297 = xTimeNow;
        xTaskResumeAll();
      }
      else {
        xWaitIndefinitely = 0;
        if (xTimeNow < xCommandTime) goto LAB_230351a6;
        xLastTime_2297 = xTimeNow;
        xTaskResumeAll();
        pxTimer = (Timer_t *)((pxCurrentTimerList->xListEnd).pxNext)->pvOwner;
        uxListRemove(&pxTimer->xTimerListItem);
        if ((pxTimer->ucStatus & 4) == 0) {
          pxTimer->ucStatus = pxTimer->ucStatus & 0xfe;
        }
        else {
          BVar1 = prvInsertTimerInActiveList
                            (pxTimer,pxTimer->xTimerPeriodInTicks + xCommandTime,xTimeNow,
                             xCommandTime);
          if ((BVar1 != 0) &&
             (BVar1 = xTimerGenericCommand
                                ((TimerHandle_t)pxTimer,0,xCommandTime,(BaseType_t *)0x0,0),
             BVar1 == 0)) {
            vAssertCalled();
          }
        }
        (*pxTimer->pxCallbackFunction)((TimerHandle_t)pxTimer);
      }
    }
    while (pvParameters = (void *)xQueueReceive(xTimerQueue,&uStack64,0),
          pvParameters != (void *)0x0) {
      if ((-1 < (int)uStack64) ||
         ((*(code *)xMessage.xMessageID)((Timer_t *)xMessage.u,xMessage.u._4_4_,xMessage.xMessageID)
         , -1 < (int)uStack64)) {
        pxTimer = (Timer_t *)xMessage.u;
        if ((((Timer_t *)xMessage.u)->xTimerListItem).pvContainer != (xLIST *)0x0) {
          uxListRemove(&((Timer_t *)xMessage.u)->xTimerListItem);
        }
        xTimeNow_00 = xTaskGetTickCount();
        if (xTimeNow_00 < xLastTime_2297) {
          prvSwitchTimerLists();
        }
        xLastTime_2297 = xTimeNow_00;
        switch(uStack64) {
        case 0:
        case 1:
        case 2:
        case 6:
        case 7:
          pxTimer->ucStatus = pxTimer->ucStatus | 1;
          BVar1 = prvInsertTimerInActiveList
                            (pxTimer,pxTimer->xTimerPeriodInTicks + xMessage.xMessageID,xTimeNow_00,
                             xMessage.xMessageID);
          if (((BVar1 != 0) &&
              ((*pxTimer->pxCallbackFunction)((TimerHandle_t)pxTimer), (pxTimer->ucStatus & 4) != 0)
              ) && (BVar1 = xTimerGenericCommand
                                      ((TimerHandle_t)pxTimer,0,
                                       xMessage.xMessageID + pxTimer->xTimerPeriodInTicks,
                                       (BaseType_t *)0x0,0), BVar1 == 0)) {
            vAssertCalled();
          }
          break;
        case 3:
        case 8:
          pxTimer->ucStatus = pxTimer->ucStatus & 0xfe;
          break;
        case 4:
        case 9:
          pxTimer->ucStatus = pxTimer->ucStatus | 1;
          pxTimer->xTimerPeriodInTicks = xMessage.xMessageID;
          TVar2 = xMessage.xMessageID;
          if (xMessage.xMessageID == 0) {
            vAssertCalled();
            TVar2 = pxTimer->xTimerPeriodInTicks;
          }
          prvInsertTimerInActiveList(pxTimer,TVar2 + xTimeNow_00,xTimeNow_00,xTimeNow_00);
          break;
        case 5:
          if ((pxTimer->ucStatus & 2) == 0) {
            vPortFree(pxTimer);
          }
          else {
            pxTimer->ucStatus = pxTimer->ucStatus & 0xfe;
          }
        }
      }
    }
  } while( true );
}



void * pvTimerGetTimerID(TimerHandle_t xTimer)

{
  void *pvVar1;
  
  if (xTimer == (TimerHandle_t)0x0) {
    vAssertCalled();
  }
  vTaskEnterCritical();
  pvVar1 = xTimer->pvTimerID;
  vTaskExitCritical();
  return pvVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void vPortSetupTimerInterrupt(void)

{
  _DAT_02004000 = _DAT_0200bff8 + 10000;
  _DAT_02004004 = (uint)(_DAT_0200bff8 + 10000 < _DAT_0200bff8) + _DAT_0200bffc;
  ullNextTime._0_4_ = _DAT_0200bff8 + 20000;
  ullNextTime._4_4_ = _DAT_0200bffc + (uint)(_DAT_0200bff8 + 20000 < _DAT_0200bff8);
  return;
}


/*
Unable to decompile 'xPortStartScheduler'
Cause: Exception while decompiling 2303539c: Decompiler process died

*/

/*
Unable to decompile 'xPortStartFirstTask'
Cause: Exception while decompiling 23035700: Decompiler process died

*/


// WARNING: Removing unreachable block (ram,0x23035800)

void pxPortInitialiseStack(int param_1,undefined4 param_2,undefined4 param_3)

{
  int iVar1;
  undefined4 *puVar2;
  uint in_mstatus;
  
  *(uint *)(param_1 + -4) = in_mstatus & 0xfffffff7 | 0x1880;
  *(undefined4 *)(param_1 + -0x5c) = param_3;
  puVar2 = (undefined4 *)(param_1 + -0x74);
  *puVar2 = 0;
  iVar1 = 0x22;
  while (iVar1 != 0) {
    puVar2 = puVar2 + -1;
    *puVar2 = 0;
    iVar1 = iVar1 + -1;
  }
  puVar2[-1] = param_2;
  return;
}



void prvInsertBlockIntoFreeList(BlockLink_t *pxBlockToInsert)

{
  size_t sVar1;
  BlockLink_t *pBVar2;
  BlockLink_t *pBVar3;
  
  pBVar3 = &xStart;
  do {
    pBVar2 = pBVar3;
    pBVar3 = (BlockLink_t *)pBVar2->pxNextFreeBlock;
  } while (pBVar3 < pxBlockToInsert);
  sVar1 = pxBlockToInsert->xBlockSize;
  if (pxBlockToInsert == (BlockLink_t *)(pBVar2->xBlockSize + (int)&pBVar2->pxNextFreeBlock)) {
    sVar1 = pBVar2->xBlockSize + sVar1;
    pBVar2->xBlockSize = sVar1;
    pxBlockToInsert = pBVar2;
  }
  if ((pBVar3 == (BlockLink_t *)(sVar1 + (int)&pxBlockToInsert->pxNextFreeBlock)) &&
     (pBVar3 != pxEnd)) {
    pxBlockToInsert->xBlockSize = sVar1 + pBVar3->xBlockSize;
    pxBlockToInsert->pxNextFreeBlock = pBVar2->pxNextFreeBlock->pxNextFreeBlock;
  }
  else {
    *(BlockLink_t **)&pxBlockToInsert->pxNextFreeBlock = pBVar3;
  }
  if (pxBlockToInsert != pBVar2) {
    *(BlockLink_t **)&pBVar2->pxNextFreeBlock = pxBlockToInsert;
  }
  return;
}



void * pvPortMalloc(size_t xWantedSize)

{
  size_t sVar1;
  size_t sVar2;
  BlockLink_t *pBVar3;
  A_BLOCK_LINK *pAVar4;
  BlockLink_t *pxBlockToInsert;
  uint uVar5;
  uint uVar6;
  
  if (pxEnd == (BlockLink_t *)0x0) {
    vAssertCalled();
  }
  vTaskSuspendAll();
  sVar2 = xFreeBytesRemaining;
  sVar1 = xBlockAllocatedBit;
  if (((xBlockAllocatedBit & xWantedSize) == 0) && (xWantedSize != 0)) {
    uVar6 = xWantedSize + 8;
    if ((uVar6 & 7) != 0) {
      uVar6 = (uVar6 & 0xfffffff8) + 8;
    }
    if ((uVar6 != 0) && (uVar6 <= xFreeBytesRemaining)) {
      pAVar4 = xStart.pxNextFreeBlock;
      pBVar3 = &xStart;
      do {
        pxBlockToInsert = pBVar3;
        pBVar3 = (BlockLink_t *)pAVar4;
        if (uVar6 <= pBVar3->xBlockSize) break;
        pAVar4 = pBVar3->pxNextFreeBlock;
      } while (pBVar3->pxNextFreeBlock != (A_BLOCK_LINK *)0x0);
      if (pxEnd != pBVar3) {
        pAVar4 = pxBlockToInsert->pxNextFreeBlock;
        pxBlockToInsert->pxNextFreeBlock = pBVar3->pxNextFreeBlock;
        uVar5 = pBVar3->xBlockSize;
        pAVar4 = pAVar4 + 1;
        if (0x10 < uVar5 - uVar6) {
          pxBlockToInsert = (BlockLink_t *)((int)&pBVar3->pxNextFreeBlock + uVar6);
          pxBlockToInsert->xBlockSize = uVar5 - uVar6;
          pBVar3->xBlockSize = uVar6;
          prvInsertBlockIntoFreeList(pxBlockToInsert);
          uVar5 = pBVar3->xBlockSize;
        }
        xFreeBytesRemaining = sVar2 - uVar5;
        if (xFreeBytesRemaining < xMinimumEverFreeBytesRemaining) {
          xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
        }
        pBVar3->xBlockSize = sVar1 | uVar5;
        pBVar3->pxNextFreeBlock = (A_BLOCK_LINK *)0x0;
        xTaskResumeAll();
        if (pAVar4 != (A_BLOCK_LINK *)0x0) {
          return pAVar4;
        }
        goto LAB_230359be;
      }
    }
  }
  xTaskResumeAll();
LAB_230359be:
  vApplicationMallocFailedHook();
  return (void *)0x0;
}



void vPortFree(void *pv)

{
  uint uVar1;
  
  if (pv == (void *)0x0) {
    return;
  }
  uVar1 = *(uint *)((int)pv + -4);
  if ((uVar1 & xBlockAllocatedBit) == 0) {
    vAssertCalled();
    if (*(int *)((int)pv + -8) == 0) {
      uVar1 = *(uint *)((int)pv + -4);
      if ((uVar1 & xBlockAllocatedBit) == 0) {
        return;
      }
      goto LAB_23035ace;
    }
  }
  else {
    if (*(int *)((int)pv + -8) == 0) goto LAB_23035ace;
  }
  vAssertCalled();
  uVar1 = *(uint *)((int)pv + -4);
  if (((uVar1 & xBlockAllocatedBit) == 0) || (*(int *)((int)pv + -8) != 0)) {
    return;
  }
LAB_23035ace:
  *(uint *)((int)pv + -4) = ~xBlockAllocatedBit & uVar1;
  vTaskSuspendAll();
  xFreeBytesRemaining = *(int *)((int)pv + -4) + xFreeBytesRemaining;
  prvInsertBlockIntoFreeList((BlockLink_t *)((int)pv + -8));
  xTaskResumeAll();
  return;
}



size_t xPortGetFreeHeapSize(void)

{
  return xFreeBytesRemaining;
}



void vPortDefineHeapRegions(HeapRegion_t *pxHeapRegions)

{
  size_t sVar1;
  BlockLink_t *pBVar2;
  BlockLink_t *pBVar3;
  BlockLink_t *pBVar4;
  A_BLOCK_LINK *pAVar5;
  int iVar6;
  size_t sVar7;
  
  if (pxEnd == (BlockLink_t *)0x0) {
    sVar1 = pxHeapRegions->xSizeInBytes;
    pBVar4 = pxEnd;
  }
  else {
    vAssertCalled();
    sVar1 = pxHeapRegions->xSizeInBytes;
    pBVar4 = pxEnd;
  }
  pxEnd = pBVar4;
  if (sVar1 == 0) {
    xMinimumEverFreeBytesRemaining = 0;
  }
  else {
    iVar6 = 0;
    sVar7 = 0;
    do {
      pBVar3 = (BlockLink_t *)pxHeapRegions->pucStartAddress;
      pBVar2 = pBVar3;
      if (((uint)pBVar3 & 7) != 0) {
        pBVar2 = (BlockLink_t *)((int)&pBVar3->xBlockSize + 3U & 0xfffffff8);
        sVar1 = (int)pBVar3 + (sVar1 - (int)pBVar2);
      }
      if (iVar6 == 0) {
        xStart.xBlockSize = 0;
        pBVar3 = pBVar4;
        xStart.pxNextFreeBlock = (A_BLOCK_LINK *)pBVar2;
      }
      else {
        if (pBVar4 == (BlockLink_t *)0x0) {
          vAssertCalled();
          pBVar4 = pxEnd;
        }
        pBVar3 = pBVar4;
        if (pBVar2 <= pBVar4) {
          vAssertCalled();
          pBVar3 = pxEnd;
        }
      }
      pBVar4 = (BlockLink_t *)((int)&pBVar2[-1].pxNextFreeBlock + sVar1 & 0xfffffff8);
      ((A_BLOCK_LINK *)pBVar4)->xBlockSize = 0;
      ((A_BLOCK_LINK *)pBVar4)->pxNextFreeBlock = (A_BLOCK_LINK *)0x0;
      pAVar5 = (A_BLOCK_LINK *)((int)pBVar4 - (int)pBVar2);
      pxEnd = pBVar4;
      *(A_BLOCK_LINK **)&pBVar2->xBlockSize = pAVar5;
      *(BlockLink_t **)&pBVar2->pxNextFreeBlock = pBVar4;
      if (pBVar3 != (BlockLink_t *)0x0) {
        *(BlockLink_t **)&pBVar3->pxNextFreeBlock = pBVar2;
        pAVar5 = (A_BLOCK_LINK *)pBVar2->xBlockSize;
      }
      sVar1 = pxHeapRegions[1].xSizeInBytes;
      sVar7 = (int)&pAVar5->pxNextFreeBlock + sVar7;
      iVar6 = iVar6 + 1;
      pxHeapRegions = pxHeapRegions + 1;
    } while (sVar1 != 0);
    xMinimumEverFreeBytesRemaining = sVar7;
    if (sVar7 != 0) {
      xBlockAllocatedBit = 0x80000000;
      xFreeBytesRemaining = sVar7;
      return;
    }
  }
  xFreeBytesRemaining = xMinimumEverFreeBytesRemaining;
  vAssertCalled();
  xBlockAllocatedBit = 0x80000000;
  return;
}



void uart_generic_notify_handler(uint8_t id)

{
  uint uVar1;
  uint uVar2;
  undefined3 in_register_00002029;
  int iVar3;
  uint32_t uVar4;
  
  iVar3 = CONCAT31(in_register_00002029,id);
  uVar4 = uartAddr[iVar3];
  uVar2 = *(uint *)(uVar4 + 0x20);
  uVar1 = *(uint *)(uVar4 + 0x24);
  if (((uVar2 & 1) != 0) && ((uVar1 & 1) == 0)) {
    *(undefined4 *)(uVar4 + 0x28) = 1;
  }
  if (((uVar2 & 2) != 0) && ((uVar1 & 2) == 0)) {
    *(undefined4 *)(uVar4 + 0x28) = 2;
    if (g_uart_notify_arg[iVar3].rx_cb != (cb_uart_notify_t *)0x0) {
      (*g_uart_notify_arg[iVar3].rx_cb)(g_uart_notify_arg[iVar3].rx_cb_arg);
    }
  }
  if (((uVar2 & 4) != 0) && ((uVar1 & 4) == 0)) {
    if (g_uart_notify_arg[iVar3].tx_cb != (cb_uart_notify_t *)0x0) {
      (*g_uart_notify_arg[iVar3].tx_cb)(g_uart_notify_arg[iVar3].tx_cb_arg);
    }
  }
  if (((uVar2 & 8) != 0) && ((uVar1 & 8) == 0)) {
    if (g_uart_notify_arg[iVar3].rx_cb != (cb_uart_notify_t *)0x0) {
      (*g_uart_notify_arg[iVar3].rx_cb)(g_uart_notify_arg[iVar3].rx_cb_arg);
    }
  }
  if (((uVar2 & 0x10) != 0) && ((uVar1 & 0x10) == 0)) {
    *(undefined4 *)(uVar4 + 0x28) = 0x10;
    if (g_uart_notify_arg[iVar3].rx_cb != (cb_uart_notify_t *)0x0) {
      (*g_uart_notify_arg[iVar3].rx_cb)(g_uart_notify_arg[iVar3].rx_cb_arg);
    }
  }
  if (((uVar2 & 0x20) != 0) && ((uVar1 & 0x20) == 0)) {
    *(undefined4 *)(uVar4 + 0x28) = 0x20;
  }
  return;
}



void UART0_IRQHandler(void)

{
  uart_generic_notify_handler('\0');
  return;
}



void UART1_IRQHandler(void)

{
  uart_generic_notify_handler('\x01');
  return;
}



// WARNING: Could not reconcile some variable overlaps

int bl_uart_init(uint8_t id,uint8_t tx_pin,uint8_t rx_pin,uint8_t cts_pin,uint8_t rts_pin,
                uint32_t baudrate)

{
  uint8_t uart_clk_init;
  GLB_UART_SIG_FUN_Type fun;
  undefined3 in_register_00002029;
  GLB_UART_SIG_FUN_Type fun_00;
  UART_FifoCfg_Type UStack60;
  UART_FifoCfg_Type fifoCfg;
  GLB_GPIO_Cfg_Type cfg;
  UART_CFG_Type uartCfg;
  
  memcpy(&cfg.drive,&DAT_23078a54,0x10);
  UStack60 = DAT_4200dd10;
  if (uart_clk_init == '\0') {
    GLB_Set_UART_CLK('\x01',HBN_UART_CLK_160M,'\x03');
    uart_clk_init = '\x01';
  }
  fifoCfg.rxFifoDmaThreshold = '\a';
  fifoCfg._2_2_ = 2;
  cfg._0_2_ = 0x101;
  fifoCfg.txFifoDmaThreshold = rx_pin;
  GLB_GPIO_Init((GLB_GPIO_Cfg_Type *)&fifoCfg);
  fifoCfg._2_2_ = 2;
  fifoCfg.txFifoDmaThreshold = tx_pin;
  GLB_GPIO_Init((GLB_GPIO_Cfg_Type *)&fifoCfg);
  if (CONCAT31(in_register_00002029,id) == 0) {
    fun = GLB_UART_SIG_FUN_UART0_RXD;
    fun_00 = GLB_UART_SIG_FUN_UART0_TXD;
  }
  else {
    fun = GLB_UART_SIG_FUN_UART1_RXD;
    fun_00 = GLB_UART_SIG_FUN_UART1_TXD;
  }
  GLB_UART_Fun_Sel(tx_pin & 7,fun_00);
  GLB_UART_Fun_Sel(rx_pin & 7,fun);
  stack0xffffffd0 = 40000000;
  UART_IntMask(id,UART_INT_ALL,MASK);
  UART_Disable(id,UART_TXRX);
  UART_Init(id,(UART_CFG_Type *)&cfg.drive);
  UART_TxFreeRun(id,ENABLE);
  UART_FifoConfig(id,&UStack60);
  UART_Enable(id,UART_TXRX);
  return 0;
}



int bl_uart_data_send(uint8_t id,uint8_t data)

{
  uint32_t uVar1;
  uint8_t uVar2;
  undefined3 in_register_00002029;
  undefined3 extraout_var;
  
  uVar1 = uartAddr[CONCAT31(in_register_00002029,id)];
  do {
    uVar2 = UART_GetTxFifoCount(id);
  } while (CONCAT31(extraout_var,uVar2) == 0);
  *(uint8_t *)(uVar1 + 0x88) = data;
  return 0;
}



int bl_uart_data_recv(uint8_t id)

{
  uint32_t uVar1;
  uint8_t uVar2;
  undefined3 in_register_00002029;
  undefined3 extraout_var;
  uint uVar3;
  
  uVar1 = uartAddr[CONCAT31(in_register_00002029,id)];
  uVar2 = UART_GetRxFifoCount(id);
  if (CONCAT31(extraout_var,uVar2) == 0) {
    uVar3 = 0xffffffff;
  }
  else {
    uVar3 = (uint)*(byte *)(uVar1 + 0x8c);
  }
  return uVar3;
}



int bl_uart_int_rx_enable(uint8_t id)

{
  UART_SetRxTimeoutValue(id,'\x18');
  UART_IntMask(id,UART_INT_RX_FIFO_REQ,UNMASK);
  UART_IntMask(id,UART_INT_RX_END,UNMASK);
  UART_IntMask(id,UART_INT_RTO,UNMASK);
  return 0;
}



int bl_uart_int_rx_disable(uint8_t id)

{
  UART_IntMask(id,UART_INT_RX_FIFO_REQ,MASK);
  UART_IntMask(id,UART_INT_RX_END,MASK);
  UART_IntMask(id,UART_INT_RTO,MASK);
  return 0;
}



int bl_uart_int_tx_enable(uint8_t id)

{
  UART_IntMask(id,UART_INT_TX_FIFO_REQ,UNMASK);
  return 0;
}



int bl_uart_int_tx_disable(uint8_t id)

{
  UART_IntMask(id,UART_INT_TX_FIFO_REQ,MASK);
  return 0;
}



int bl_uart_flush(uint8_t id)

{
  uint8_t uVar1;
  undefined3 extraout_var;
  
  do {
    uVar1 = UART_GetTxFifoCount(id);
  } while (CONCAT31(extraout_var,uVar1) != 0x20);
  return 0;
}



void bl_uart_getdefconfig(uint8_t id,uint8_t *parity)

{
  if (parity != (uint8_t *)0x0) {
    *parity = '\0';
  }
  return;
}



// WARNING: Variable defined which should be unmapped: UartCfg
// WARNING: Could not reconcile some variable overlaps

void bl_uart_setconfig(uint8_t id,uint32_t baudrate,UART_Parity_Type parity)

{
  undefined auStack32 [4];
  UART_CFG_Type UartCfg;
  
  memcpy(auStack32,&DAT_23078a64,0x10);
  UartCfg.uartClk = baudrate;
  UartCfg.baudRate._2_1_ = parity;
  UART_Disable(id,UART_TXRX);
  UART_Init(id,(UART_CFG_Type *)auStack32);
  UART_TxFreeRun(id,ENABLE);
  UART_Enable(id,UART_TXRX);
  return;
}



void bl_uart_setbaud(uint8_t id,uint32_t baud)

{
  bl_uart_setconfig(id,baud,UART_PARITY_NONE);
  return;
}



int bl_uart_int_enable(uint8_t id)

{
  undefined3 in_register_00002029;
  uint source;
  
  if (CONCAT31(in_register_00002029,id) == 0) {
    bl_uart_int_rx_enable(id);
    bl_uart_int_tx_enable('\0');
    bl_irq_register(0x2d,UART0_IRQHandler);
    source = 0x2d;
  }
  else {
    if (CONCAT31(in_register_00002029,id) != 1) {
      return -1;
    }
    bl_uart_int_rx_enable(id);
    bl_uart_int_tx_enable('\x01');
    bl_irq_register(0x2e,UART1_IRQHandler);
    source = 0x2e;
  }
  bl_irq_enable(source);
  return 0;
}



int bl_uart_int_disable(uint8_t id)

{
  undefined3 in_register_00002029;
  uint source;
  
  if (CONCAT31(in_register_00002029,id) == 0) {
    bl_uart_int_rx_disable(id);
    bl_uart_int_tx_disable('\0');
    bl_irq_unregister(0x2d,UART0_IRQHandler);
    source = 0x2d;
  }
  else {
    if (CONCAT31(in_register_00002029,id) != 1) {
      return -1;
    }
    bl_uart_int_rx_disable(id);
    bl_uart_int_tx_disable('\x01');
    bl_irq_unregister(0x2e,UART1_IRQHandler);
    source = 0x2e;
  }
  bl_irq_disable(source);
  return 0;
}



int bl_uart_int_rx_notify_register(uint8_t id,cb_uart_notify_t *cb,void *arg)

{
  undefined3 in_register_00002029;
  uint uVar1;
  
  uVar1 = CONCAT31(in_register_00002029,id);
  if (uVar1 < 2) {
    g_uart_notify_arg[uVar1].rx_cb = cb;
    g_uart_notify_arg[uVar1].rx_cb_arg = arg;
    return 0;
  }
  return -1;
}



int bl_uart_int_tx_notify_register(uint8_t id,cb_uart_notify_t *cb,void *arg)

{
  undefined3 in_register_00002029;
  uint uVar1;
  
  uVar1 = CONCAT31(in_register_00002029,id);
  if (uVar1 < 2) {
    g_uart_notify_arg[uVar1].tx_cb = cb;
    g_uart_notify_arg[uVar1].tx_cb_arg = arg;
    return 0;
  }
  return -1;
}



// WARNING: Removing unreachable block (ram,0x23036074)

int bl_chip_info(char *info)

{
  char *pcVar1;
  undefined *__src;
  uint uVar2;
  uint in_register_90000c04;
  uint32_t misa;
  
  uVar2 = in_register_90000c04 >> 0x1e;
  if (uVar2 == 2) {
    memcpy(info,&DAT_23078d38,4);
    pcVar1 = info + 4;
  }
  else {
    if (uVar2 == 3) {
      memcpy(info,"RV128",5);
      pcVar1 = info + 5;
    }
    else {
      pcVar1 = info + 4;
      if (uVar2 == 1) {
        __src = &DAT_23078d30;
      }
      else {
        __src = &DAT_23078d48;
      }
      memcpy(info,__src,4);
    }
  }
  *pcVar1 = '-';
  pcVar1 = pcVar1 + 1;
  uVar2 = 0;
  do {
    if ((1 << (uVar2 & 0x1f) & in_register_90000c04) != 0) {
      *pcVar1 = (char)uVar2 + 'A';
      pcVar1 = pcVar1 + 1;
    }
    uVar2 = uVar2 + 1;
  } while (uVar2 != 0x1a);
  *pcVar1 = '\0';
  return 0;
}



int bl_chip_banner(char **banner)

{
  *banner = 
  "          \n\r      \n\r       \n\r     \n\r\n\r     \n\r"
  ;
  return 0;
}



int bl_chip_memory_ram(int *num,uint *addr,uint *size,char (*desc) [6])

{
  if (2 < *num) {
    *num = 3;
    *addr = 0x23000000;
    *size = 0x400000;
    strcpy((char *)desc,"flash");
    addr[1] = 0x4200c000;
    size[1] = 0x34000;
    strcpy((char *)(desc + 1),"tcm");
    addr[2] = 0x42040000;
    size[2] = 0xa000;
    strcpy((char *)(desc + 2),"wifi");
    return 0;
  }
  return -1;
}



int bl_sys_reset_por(void)

{
  GLB_SW_POR_Reset();
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void bl_sys_reset_system(void)

{
  GLB_SW_System_Reset();
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



int bl_sys_isxipaddr(uint32_t addr)

{
  return (uint)(((addr & 0xff000000) + 0xdd000000 & 0xdf000000) == 0);
}



// WARNING: Removing unreachable block (ram,0x23036206)
// WARNING: Removing unreachable block (ram,0x2303620c)

int bl_sys_em_config(void)

{
  GLB_Set_EM_Sel(GLB_EM_8KB);
  return 0;
}


/*
Unable to decompile 'bl_sys_early_init'
Cause: Exception while decompiling 2303621e: Decompiler process died

*/


int bl_sys_init(void)

{
  bl_sys_em_config();
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void bl_dma_int_process(void)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  int *piStack52;
  dma_ctx *pstctx;
  
  uVar1 = _DAT_4000c00c;
  uVar2 = _DAT_4000c004;
  uVar5 = 0;
  bl_irq_ctx_get(0x1f,&piStack52);
  do {
    uVar4 = 1 << (uVar5 & 0x1f);
    uVar7 = uVar4 & uVar2;
    uVar6 = uVar4 & uVar1;
    if (uVar7 == 0) {
      if (uVar6 != 0) {
LAB_23036290:
        uVar2 = _DAT_4000c010 | uVar4;
        _DAT_4000c010 = uVar2;
        goto LAB_2303629a;
      }
    }
    else {
      uVar2 = _DAT_4000c008 | uVar4;
      _DAT_4000c008 = uVar2;
      if (uVar6 != 0) goto LAB_23036290;
LAB_2303629a:
      iVar3 = *(int *)(*piStack52 + 4);
      while (iVar3 != *piStack52) {
        if (*(uint *)(iVar3 + 8) == uVar5) {
          if ((*(code **)(iVar3 + 0xc) != (code *)0x0) && (uVar7 != 0)) {
            (**(code **)(iVar3 + 0xc))();
          }
          if ((*(code **)(iVar3 + 0x10) != (code *)0x0) && (uVar6 != 0)) {
            (**(code **)(iVar3 + 0x10))();
          }
        }
        iVar3 = *(int *)(iVar3 + 4);
      }
    }
    uVar5 = uVar5 + 1;
    if (uVar5 == 4) {
      return;
    }
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int bl_dma_int_clear(int ch)

{
  uint uVar1;
  
  uVar1 = 1 << (ch & 0x1fU);
  if ((_DAT_4000c004 & uVar1 & 0xff) != 0) {
    _DAT_4000c008 = _DAT_4000c008 | uVar1;
  }
  if ((_DAT_4000c00c & uVar1 & 0xff) != 0) {
    _DAT_4000c010 = uVar1 | _DAT_4000c010;
  }
  return 0;
}



void bl_dma_IRQHandler(void)

{
  utils_list_hdr *puVar1;
  TickType_t TVar2;
  
  bl_dma_int_clear(0);
  puVar1 = utils_list_pop_front(&dma_copy_list);
  if (puVar1 == (utils_list_hdr *)0x0) {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_dma < BLOG_LEVEL_WARN))
    {
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] [INT] ASSERT here for empty chain\r\n",TVar2,&DAT_2306e4ac,
                &UNK_23078d64,0x9d);
    }
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  if (puVar1[1].next != (utils_list_hdr *)0x0) {
    (*(code *)puVar1[1].next)(puVar1[2].next);
  }
  if (dma_copy_list.first != (utils_list_hdr *)0x0) {
    DMA_LLI_Update('\0',(uint32_t)(dma_copy_list.first + 3));
    DMA_Channel_Enable('\0');
    return;
  }
  return;
}



int bl_dma_irq_register(int channel,void *tc_handler,void *interr_handler,void *ctx)

{
  int iVar1;
  TickType_t TVar2;
  int *piVar3;
  int **ppiVar4;
  int *piStack36;
  dma_ctx *pstctx;
  
  if (((uint)channel < 5) && (tc_handler != (void *)0x0)) {
    bl_irq_ctx_get(0x1f,&piStack36);
    iVar1 = *(int *)(*piStack36 + 4);
    while (*piStack36 != iVar1) {
      if (channel == *(int *)(iVar1 + 8)) {
        if (BLOG_LEVEL_WARN < _fsymc_level_hal_drv) {
          return -1;
        }
        if (BLOG_LEVEL_WARN < _fsymf_level_hal_drvbl_dma) {
          return -1;
        }
        if (TrapNetCounter == 0) {
          TVar2 = xTaskGetTickCount();
        }
        else {
          TVar2 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] channel %d already register \r\n",TVar2,&DAT_230781b4,
                  &UNK_23078d64,0x124,*(undefined4 *)(iVar1 + 8));
        return -1;
      }
      iVar1 = *(int *)(iVar1 + 4);
    }
    piVar3 = (int *)pvPortMalloc(0x18);
    if (((piVar3 == (int *)0x0) && (_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT)) &&
       (_fsymf_level_hal_drvbl_dma < BLOG_LEVEL_ASSERT)) {
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] malloc dma node failed. \r\n",TVar2,&DAT_23078e4c,&UNK_23078d64,
                0x12a);
    }
    piVar3[2] = channel;
    *(void **)(piVar3 + 3) = tc_handler;
    *(void **)(piVar3 + 4) = interr_handler;
    *(void **)(piVar3 + 5) = ctx;
    iVar1 = *piStack36;
    ppiVar4 = *(int ***)(iVar1 + 4);
    *piVar3 = iVar1;
    *(int ***)(piVar3 + 1) = ppiVar4;
    *(int **)(iVar1 + 4) = piVar3;
    *ppiVar4 = piVar3;
  }
  else {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
       (_fsymf_level_hal_drvbl_dma < BLOG_LEVEL_ASSERT)) {
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] not valid para \r\n",TVar2,&DAT_23078e4c,&UNK_23078d64,0x11c);
    }
  }
  return -1;
}



void bl_dma_init(void)

{
  void **ctx;
  char *format;
  void *pvVar1;
  undefined4 uVar2;
  undefined2 uStack20;
  DMA_Periph_Req_Type DStack18;
  DMA_LLI_Cfg_Type lliCfg;
  
  uStack20 = 0;
  DStack18 = DMA_REQ_UART0_RX;
  utils_list_init(&dma_copy_list);
  ctx = (void **)pvPortMalloc(4);
  if (ctx == (void **)0x0) {
    if (BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) {
      return;
    }
    if (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvbl_dma) {
      return;
    }
    if (TrapNetCounter == 0) {
      xTaskGetTickCount();
    }
    else {
      xTaskGetTickCountFromISR();
    }
    uVar2 = 0x180;
    format = "[%10u][%s: %s:%4d] malloc dma ctx failed \r\n";
  }
  else {
    pvVar1 = pvPortMalloc(8);
    *ctx = pvVar1;
    if (pvVar1 != (void *)0x0) {
      *(void **)((int)pvVar1 + 4) = pvVar1;
      *(void **)pvVar1 = pvVar1;
      DMA_Enable();
      DMA_IntMask('\0',DMA_INT_ALL,MASK);
      DMA_IntMask('\0',DMA_INT_TCOMPLETED,UNMASK);
      DMA_IntMask('\0',DMA_INT_ERR,UNMASK);
      DMA_LLI_Init('\0',(DMA_LLI_Cfg_Type *)&uStack20);
      bl_irq_register_with_ctx(0x1f,bl_dma_int_process,ctx);
      bl_dma_irq_register(0,bl_dma_IRQHandler,(void *)0x0,(void *)0x0);
      bl_irq_enable(0x1f);
      return;
    }
    if (BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) {
      return;
    }
    if (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvbl_dma) {
      return;
    }
    if (TrapNetCounter == 0) {
      xTaskGetTickCount();
    }
    else {
      xTaskGetTickCountFromISR();
    }
    uVar2 = 0x187;
    format = "[%10u][%s: %s:%4d] malloc dma pstqueue failed \r\n";
  }
  bl_printk(format,&DAT_23078e4c,&UNK_23078d64,uVar2);
  return;
}



void _irq_num_check(int irqnum)

{
  TickType_t TVar1;
  
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) && (_fsymf_level_hal_drvbl_irq < BLOG_LEVEL_ASSERT)
     ) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] illegal irqnum %d\r\n",TVar1,&DAT_23078e4c,"bl_irq.c",0x70,irqnum)
    ;
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void bl_irq_enable(uint source)

{
  (&DAT_02800400)[source] = 1;
  return;
}



void bl_irq_disable(uint source)

{
  (&DAT_02800400)[source] = 0;
  return;
}



void bl_irq_pending_clear(uint source)

{
  (&DAT_02800000)[source] = 0;
  return;
}



void bl_irq_register_with_ctx(int irqnum,void *handler,void *ctx)

{
  TickType_t TVar1;
  
  if (0x4f < (uint)irqnum) {
    _irq_num_check(irqnum);
  }
  if (handler_list[irqnum] == (anon_subr_void *)0x0) goto LAB_23036764;
  if (handler_list[irqnum] == (anon_subr_void *)handler) {
LAB_230367d6:
    handler_list[irqnum] = handler;
    if ((anon_subr_void *)ctx == (anon_subr_void *)0x0) {
      handler_list[irqnum + 0x50] = (anon_subr_void *)0x0;
    }
    else {
      handler_list[irqnum + 0x50] = ctx;
    }
  }
  else {
    if (_fsymc_level_hal_drv < BLOG_LEVEL_ERROR) {
      if (_fsymf_level_hal_drvbl_irq < BLOG_LEVEL_ERROR) {
        if (TrapNetCounter == 0) {
          TVar1 = xTaskGetTickCount();
        }
        else {
          TVar1 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] IRQ %d already registered with %p \r\n",TVar1,&DAT_230781b4,
                  "bl_irq.c",0x7e,irqnum,handler_list[irqnum]);
        goto LAB_23036764;
      }
      if ((anon_subr_void *)handler != (anon_subr_void *)0x0) goto LAB_230367d6;
    }
    else {
LAB_23036764:
      if ((anon_subr_void *)handler != (anon_subr_void *)0x0) goto LAB_230367d6;
      if (BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) {
        return;
      }
    }
    if (_fsymf_level_hal_drvbl_irq < BLOG_LEVEL_ASSERT) {
      if (TrapNetCounter == 0) {
        TVar1 = xTaskGetTickCount();
      }
      else {
        TVar1 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] handler is NULL pointer! \r\n",TVar1,&DAT_23078e4c,"bl_irq.c",
                0x82);
      return;
    }
  }
  return;
}



void bl_irq_ctx_get(int irqnum,void **ctx)

{
  if (0x4f < (uint)irqnum) {
    _irq_num_check(irqnum);
  }
  *(anon_subr_void **)ctx = handler_list[irqnum + 0x50];
  return;
}



void bl_irq_register(int irqnum,void *handler)

{
  bl_irq_register_with_ctx(irqnum,handler,(void *)0x0);
  return;
}



void bl_irq_unregister(int irqnum,void *handler)

{
  TickType_t TVar1;
  
  if (0x4f < (uint)irqnum) {
    _irq_num_check(irqnum);
  }
  if (((handler_list[irqnum] != (anon_subr_void *)handler) &&
      (_fsymc_level_hal_drv < BLOG_LEVEL_ERROR)) && (_fsymf_level_hal_drvbl_irq < BLOG_LEVEL_ERROR))
  {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] IRQ %d:%p Not match with registered %p\r\n",TVar1,&DAT_230781b4,
              "bl_irq.c",0xa8,irqnum,handler,handler_list[irqnum]);
  }
  handler_list[irqnum] = handler;
  return;
}



// WARNING: Exceeded maximum restarts with more pending

void interrupt_entry(uint32_t mcause)

{
  anon_subr_void *UNRECOVERED_JUMPTABLE_00;
  uint uVar1;
  
  uVar1 = mcause & 0x7ffffff;
  if (uVar1 < 0x50) {
    UNRECOVERED_JUMPTABLE_00 = handler_list[uVar1];
    if (UNRECOVERED_JUMPTABLE_00 != (anon_subr_void *)0x0) {
      if (handler_list[uVar1 + 0x50] != (anon_subr_void *)0x0) {
                    // WARNING: Could not recover jumptable at 0x230368fc. Too many branches
                    // WARNING: Treating indirect jump as call
        (*UNRECOVERED_JUMPTABLE_00)();
        return;
      }
                    // WARNING: Could not recover jumptable at 0x230368fe. Too many branches
                    // WARNING: Treating indirect jump as call
      (*UNRECOVERED_JUMPTABLE_00)();
      return;
    }
  }
  printf("Cannot handle mcause 0x%lx:%lu, adjust to externel(0x%lx:%lu)\r\n",uVar1,uVar1 - 0x10);
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void exception_entry(uint32_t mcause,uint32_t mepc,uint32_t mtval,uintptr_t *regs)

{
  char *s;
  
  if ((mcause & 0x3ff) == 4) {
    misaligned_load_trap(mcause,mepc);
    return;
  }
  if ((mcause & 0x3ff) != 6) {
    puts("Exception Entry--->>>\r\n");
    printf("mcause %08lx, mepc %08lx, mtval %08lx\r\n",mcause,mepc,mtval);
    printf("Exception code: %lu\r\n",mcause & 0xffff);
    switch(mcause & 0xffff) {
    case 0:
      s = "  msg: Instruction address misaligned\r\n";
      break;
    case 1:
      s = "  msg: Instruction access fault\r\n";
      break;
    case 2:
      s = "  msg: Illegal instruction\r\n";
      break;
    case 3:
      s = "  msg: Breakpoint\r\n";
      break;
    case 4:
      s = "  msg: Load address misaligned\r\n";
      break;
    case 5:
      s = "  msg: Load access fault\r\n";
      break;
    case 6:
      s = "  msg: Store/AMO access misaligned\r\n";
      break;
    case 7:
      s = "  msg: Store/AMO access fault\r\n";
      break;
    case 8:
      s = "  msg: Environment call from U-mode\r\n";
      break;
    case 9:
      s = "  msg: Environment call from S-mode\r\n";
      break;
    case 10:
    case 0xe:
      s = "  msg: Reserved\r\n";
      break;
    case 0xb:
      s = "  msg: Environment call from M-mode\r\n";
      break;
    case 0xc:
      s = "  msg: Instruction page fault\r\n";
      break;
    case 0xd:
      s = "  msg: Load page fault\r\n";
      break;
    case 0xf:
      s = "  msg: Store/AMO page fault\r\n";
      break;
    default:
      s = "  msg: Reserved default exception\r\n";
    }
    puts(s);
    backtrace_riscv(printf,regs);
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  misaligned_store_trap(mcause,mepc);
  return;
}



void bl_irq_init(void)

{
  undefined *puVar1;
  
  puts("[IRQ] Clearing and Disable all the pending IRQ...\r\n");
  puVar1 = &DAT_02800400;
  do {
    *puVar1 = 0;
    puVar1 = puVar1 + 1;
  } while (puVar1 != (undefined *)0x2800480);
  puVar1 = &DAT_02800000;
  do {
    *puVar1 = 0;
    puVar1 = puVar1 + 1;
  } while (puVar1 != (undefined *)0x2800080);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void _trng_trigger(void)

{
  if ((_DAT_40004200 & 1) == 0) {
    _DAT_40004200 = _DAT_40004200 | 0x606;
    _DAT_4000422c = trng_buffer[0];
    _DAT_40004230 = trng_buffer[1];
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void wait_trng4feed(void)

{
  do {
  } while ((_DAT_40004200 & 1) != 0);
  _DAT_40004200 = _DAT_40004200 & 0xfffffffd | 0x200;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) && (_fsymf_level_hal_drvbl_sec < BLOG_LEVEL_INFO)) {
    if (TrapNetCounter == 0) {
      xTaskGetTickCount();
    }
    else {
      xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] Feed random number is %08lx\r\n","DEBUG ","bl_sec.c",0x5b,
              trng_buffer[0]);
  }
  trng_buffer[0] = _DAT_40004208;
  trng_buffer[1] = _DAT_4000420c;
  trng_buffer[2] = _DAT_40004210;
  trng_buffer[3] = _DAT_40004214;
  trng_buffer[4] = _DAT_40004218;
  trng_buffer[5] = _DAT_4000421c;
  trng_buffer[6] = _DAT_40004220;
  trng_buffer[7] = _DAT_40004224;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void sec_trng_IRQHandler(uint param_1,int param_2)

{
  aos_now_ms();
  if ((param_2 < 1) && ((param_2 != 0 || (param_1 < 2000)))) {
    puts("[BL] [SEC] TRNG Handler\r\n");
  }
  _DAT_40004200 = _DAT_40004200 & 0xfffffffd | 0x200;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) && (_fsymf_level_hal_drvbl_sec < BLOG_LEVEL_INFO)) {
    if (TrapNetCounter == 0) {
      xTaskGetTickCount();
    }
    else {
      xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] random number is %08lx\r\n","DEBUG ","bl_sec.c",0xab,
              trng_buffer[0]);
  }
  trng_buffer[0] = _DAT_40004208;
  trng_buffer[1] = _DAT_4000420c;
  trng_buffer[2] = _DAT_40004210;
  trng_buffer[3] = _DAT_40004214;
  trng_buffer[4] = _DAT_40004218;
  trng_buffer[5] = _DAT_4000421c;
  trng_buffer[6] = _DAT_40004220;
  trng_buffer[7] = _DAT_40004224;
  return;
}



uint32_t bl_sec_get_random_word(void)

{
  uint uVar1;
  
  uVar1 = trng_idx & 7;
  if (uVar1 == 0) {
    trng_idx = uVar1;
    _trng_trigger();
  }
  trng_idx = uVar1 + 1;
  return trng_buffer[uVar1];
}



void bl_rand_stream(uint8_t *buf,int len)

{
  size_t __n;
  int iVar1;
  
  if (trng_idx != 0) {
    _trng_trigger();
    wait_trng4feed();
    trng_idx = 0;
  }
  iVar1 = 0;
  while (0 < len) {
    if (trng_idx != 0) {
      _trng_trigger();
      wait_trng4feed();
      trng_idx = 0;
    }
    __n = len;
    if (0x20 < len) {
      __n = 0x20;
    }
    memcpy(buf + iVar1,trng_buffer,__n);
    iVar1 = iVar1 + __n;
    len = len - __n;
    trng_idx = 0x1f;
  }
  _trng_trigger();
  wait_trng4feed();
  trng_idx = 0;
  return;
}



int bl_rand(void)

{
  int iVar1;
  uint32_t uVar2;
  
  iVar1 = 0x13;
  do {
    uVar2 = bl_sec_get_random_word();
    iVar1 = iVar1 + -1;
    if (iVar1 == 0) {
      puts("[BL] [SEC] Failed after loop (17)\r\n");
      break;
    }
  } while (uVar2 == 0);
  return uVar2 >> 1;
}



int bl_sec_init(void)

{
  g_bl_sec_sha_mutex =
       (SemaphoreHandle_t)xQueueCreateMutexStatic('\x01',(StaticQueue_t *)&sha_mutex_buf);
  _trng_trigger();
  wait_trng4feed();
  _trng_trigger();
  wait_trng4feed();
  bl_irq_register(0x1c,sec_trng_IRQHandler);
  bl_irq_enable(0x1c);
  return 0;
}



int bl_sec_test(void)

{
  int iVar1;
  
  bl_printk("------------------TRNG TEST---------------------------------\r\n");
  iVar1 = bl_rand();
  bl_printk("**********TRNG TEST rand[%08x]**************\r\n",iVar1);
  iVar1 = bl_rand();
  bl_printk("**********TRNG TEST rand[%08x]**************\r\n",iVar1);
  bl_printk("------------------------------------------------------------\r\n");
  return 0;
}



int bl_efuse_read_mac(uint8_t *mac)

{
  EF_Ctrl_Read_MAC_Address(mac);
  return 0;
}



int bl_efuse_read_mac_factory(uint8_t *mac)

{
  int8_t iVar1;
  undefined3 extraout_var;
  
  iVar1 = mfg_media_read_macaddr(mac,'\x01');
  return -(uint)(CONCAT31(extraout_var,iVar1) != 0);
}



int bl_efuse_read_capcode(uint8_t *capcode)

{
  int8_t iVar1;
  undefined3 extraout_var;
  
  iVar1 = mfg_media_read_xtal_capcode(capcode,'\x01');
  return -(uint)(CONCAT31(extraout_var,iVar1) != 0);
}



int bl_efuse_read_pwroft(int8_t *poweroffset)

{
  int8_t iVar1;
  undefined3 extraout_var;
  
  iVar1 = mfg_media_read_poweroffset(poweroffset,'\x01');
  return -(uint)(CONCAT31(extraout_var,iVar1) != 0);
}



int bl_wifi_clock_enable(void)

{
  int called;
  
  return 0;
}



int bl_wifi_enable_irq(void)

{
  bl_irq_register(0x46,mac_irq);
  bl_irq_register(0x4f,bl_irq_handler);
  bl_irq_enable(0x46);
  bl_irq_enable(0x4f);
  puts("Enable BMX IRQ\r\n");
  return 0;
}



int bl_wifi_sta_mac_addr_set(uint8_t *mac)

{
  memcpy(&wifi_env,mac,6);
  return 0;
}



int bl_wifi_ap_mac_addr_set(uint8_t *mac)

{
  memcpy(wifi_env.ap_mac_addr_board,mac,6);
  return 0;
}



int bl_wifi_mac_addr_get(uint8_t *mac)

{
  memcpy(mac,&wifi_env,6);
  return 0;
}



int bl_wifi_country_code_set(uint8_t country_code)

{
  wifi_env.country_code = country_code;
  return 0;
}



int bl_wifi_ap_info_set(uint8_t *ssid,uint8_t ssid_len,uint8_t *psk,uint8_t psk_len,uint8_t chan)

{
  undefined3 in_register_0000202d;
  undefined3 in_register_00002035;
  
  memset(&wifi_env.ap_info,0,99);
  memcpy(&wifi_env.ap_info,ssid,CONCAT31(in_register_0000202d,ssid_len));
  memcpy(wifi_env.ap_info.psk,psk,CONCAT31(in_register_00002035,psk_len));
  wifi_env.ap_info.chan = chan;
  wifi_env.ap_info_en = '\x01';
  return 0;
}



int bl_wifi_sta_info_set
              (uint8_t *ssid,uint8_t ssid_len,uint8_t *psk,uint8_t psk_len,int autoconnect)

{
  undefined3 in_register_0000202d;
  undefined3 in_register_00002035;
  
  memset(&wifi_env.sta_info,0,99);
  memcpy(&wifi_env.sta_info,ssid,CONCAT31(in_register_0000202d,ssid_len));
  memcpy(wifi_env.sta_info.psk,psk,CONCAT31(in_register_00002035,psk_len));
  wifi_env.sta_info_en = (uint8_t)autoconnect;
  return 0;
}



uint32_t fdt32_to_cpu(fdt32_t x)

{
  return (x >> 0x10 & 0xff) << 8 | x << 0x18 | x >> 0x18 | (x >> 8 & 0xff) << 0x10;
}



int dev_uart_init(uint8_t id,char *path,uint32_t rx_buf_size,uint32_t tx_buf_size)

{
  uart_dev_t **ppuVar1;
  undefined3 in_register_00002029;
  uint uVar2;
  TickType_t TVar3;
  char *format;
  void *pvVar4;
  int iVar5;
  undefined4 uVar6;
  uart_dev_t *__s;
  
  uVar2 = CONCAT31(in_register_00002029,id);
  if ((uVar2 < 3) && (path != (char *)0x0)) {
    if (uVar2 == 0) {
      ppuVar1 = &dev_uart0;
      __s = dev_uart0;
    }
    else {
      if (uVar2 != 1) {
        if (BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) {
          return -1;
        }
        if (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvhal_uart) {
          return -1;
        }
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        uVar6 = 0x74;
        format = "[%10u][%s: %s:%4d] err.\r\n";
        goto LAB_230370e0;
      }
      ppuVar1 = &dev_uart1;
      __s = dev_uart1;
    }
    if (__s == (uart_dev_t *)0x0) {
      __s = (uart_dev_t *)pvPortMalloc(0x3c);
      *ppuVar1 = __s;
      if (__s == (uart_dev_t *)0x0) {
        if (BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) {
          return -1;
        }
        if (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvhal_uart) {
          return -1;
        }
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        uVar6 = 0x3c;
      }
      else {
        memset(__s,0,0x3c);
        (*ppuVar1)->read_block_flag = '\x02';
        (*ppuVar1)->priv = (void *)0x0;
        __s = *ppuVar1;
        pvVar4 = pvPortMalloc(4);
        __s->priv = pvVar4;
        if ((*ppuVar1)->priv != (void *)0x0) {
          memset((*ppuVar1)->priv,0,4);
          (*ppuVar1)->rx_buf_size = rx_buf_size;
          (*ppuVar1)->tx_buf_size = tx_buf_size;
          if (*ppuVar1 == (uart_dev_t *)0x0) {
            if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
               (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_ASSERT)) {
              if (TrapNetCounter == 0) {
                TVar3 = xTaskGetTickCount();
              }
              else {
                TVar3 = xTaskGetTickCountFromISR();
              }
              bl_printk("[%10u][%s: %s:%4d] mem err.\r\n",TVar3,&DAT_23078e4c,"hal_uart.c",0x50);
            }
          }
          else {
            (*ppuVar1)->port = id;
            (*ppuVar1)->read_block_flag = '\x02';
            ((*ppuVar1)->config).baud_rate = 0x1c200;
            ((*ppuVar1)->config).data_width = DATA_WIDTH_8BIT;
            ((*ppuVar1)->config).parity = NO_PARITY;
            ((*ppuVar1)->config).stop_bits = STOP_BITS_1;
            ((*ppuVar1)->config).flow_control = FLOW_CONTROL_DISABLED;
            ((*ppuVar1)->config).mode = MODE_TX_RX;
          }
          iVar5 = aos_register_driver(path,(file_ops_t *)&uart_ops,*ppuVar1);
          return iVar5;
        }
        if (BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) {
          return -1;
        }
        if (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvhal_uart) {
          return -1;
        }
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        uVar6 = 0x45;
      }
      format = "[%10u][%s: %s:%4d] mem err.\r\n";
      goto LAB_230370e0;
    }
    if (BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) {
      return -1;
    }
    if (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvhal_uart) {
      return -1;
    }
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    uVar6 = 0x36;
  }
  else {
    if (BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) {
      return -1;
    }
    if (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvhal_uart) {
      return -1;
    }
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    uVar6 = 0x65;
  }
  format = "[%10u][%s: %s:%4d] arg err.\r\n";
LAB_230370e0:
  bl_printk(format,TVar3,&DAT_23078e4c,"hal_uart.c",uVar6);
  return -1;
}



int32_t hal_uart_send_trigger(uart_dev_t *uart)

{
  bl_uart_int_tx_enable(uart->port);
  return 0;
}



int32_t hal_uart_send_trigger_off(uart_dev_t *uart)

{
  bl_uart_int_tx_disable(uart->port);
  return 0;
}



int32_t hal_uart_init(uart_dev_t *uart)

{
  int iVar1;
  int iVar2;
  hal_uart_parity_t ahStack17 [4];
  uint8_t parity;
  
  iVar2 = aos_mutex_new((aos_mutex_t *)uart->priv);
  iVar1 = -1;
  if (iVar2 == 0) {
    bl_uart_getdefconfig(uart->port,ahStack17);
    if (ahStack17[0] == NO_PARITY) {
      (uart->config).parity = NO_PARITY;
    }
    else {
      if (ahStack17[0] != ODD_PARITY) {
        ahStack17[0] = EVEN_PARITY;
      }
      (uart->config).parity = ahStack17[0];
    }
    bl_uart_int_enable(uart->port);
    iVar1 = iVar2;
  }
  return iVar1;
}



int32_t hal_uart_recv_II(uart_dev_t *uart,void *data,uint32_t expect_size,uint32_t *recv_size,
                        uint32_t timeout)

{
  uint32_t uVar1;
  int iVar2;
  
  uVar1 = 0;
  while (uVar1 != expect_size) {
    iVar2 = bl_uart_data_recv(uart->port);
    if (iVar2 < 0) break;
    *(undefined *)((int)data + uVar1) = (char)iVar2;
    uVar1 = uVar1 + 1;
  }
  *recv_size = uVar1;
  return 0;
}



int32_t hal_uart_send(uart_dev_t *uart,void *data,uint32_t size,uint32_t timeout)

{
  uint8_t data_00;
  uint8_t *puVar1;
  
  puVar1 = (uint8_t *)((int)data + size);
  while ((uint8_t *)data != puVar1) {
    data_00 = *(uint8_t *)data;
    data = (uint8_t *)data + 1;
    bl_uart_data_send(uart->port,data_00);
  }
  return 0;
}



int32_t hal_uart_finalize(uart_dev_t *uart)

{
  aos_mutex_t *mutex;
  
  mutex = (aos_mutex_t *)uart->priv;
  bl_uart_int_disable(uart->port);
  aos_mutex_free(mutex);
  return 0;
}



int32_t hal_uart_notify_register(uart_dev_t *uart,hal_uart_int_t type,anon_subr_void_void_ptr *cb)

{
  undefined3 in_register_0000202d;
  
  if (CONCAT31(in_register_0000202d,type) == 0) {
    bl_uart_int_tx_notify_register(uart->port,(cb_uart_notify_t *)cb,uart);
  }
  else {
    if (CONCAT31(in_register_0000202d,type) != 1) {
      return -1;
    }
    bl_uart_int_rx_notify_register(uart->port,(cb_uart_notify_t *)cb,uart);
  }
  return 0;
}



undefined4 vfs_uart_init(void *param_1,int param_2)

{
  int nodeoffset;
  char *property;
  int nodeoffset_00;
  TickType_t TVar1;
  fdt32_t *pfVar2;
  uint32_t baudrate;
  uint32_t uVar3;
  int iVar4;
  char *__s2;
  uint32_t uVar5;
  undefined4 uVar6;
  int iVar7;
  char *name;
  fdt32_t x;
  fdt32_t x_00;
  char **ppcVar8;
  uint32_t rx_buf_size;
  uint32_t tx_buf_size;
  fdt32_t x_01;
  uint8_t uStack152;
  char **ppcStack148;
  uint local_7c;
  char *pcStack120;
  char *pcStack116;
  char *local_70;
  undefined4 uStack108;
  byte bStack104;
  uint8_t uStack92;
  uint8_t uStack80;
  uint8_t uStack68;
  char *apcStack64 [3];
  
  if (inited == '\x01') {
    return 0;
  }
  pcStack120 = "uart@4000A000";
  pcStack116 = "uart@4000A100";
  local_7c = 0;
  memcpy(&local_70,&PTR_DAT_23079448,0x30);
  ppcStack148 = &pcStack120;
  iVar7 = 0;
  do {
    name = *ppcStack148;
    nodeoffset = fdt_subnode_offset(param_1,param_2,name);
    if (nodeoffset < 1) {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          xTaskGetTickCount();
        }
        else {
          xTaskGetTickCountFromISR();
        }
        uVar6 = 300;
        goto LAB_2303747e;
      }
    }
    else {
      name = (char *)fdt_stringlist_count(param_1,nodeoffset,"status");
      if (name == (char *)0x1) {
        name = fdt_stringlist_get(param_1,nodeoffset,"status",0,(int *)&local_7c);
        if ((local_7c == 4) && (nodeoffset_00 = memcmp(&DAT_2307958c,name,4), nodeoffset_00 == 0)) {
          name = (char *)fdt_stringlist_count(param_1,nodeoffset,"path");
          if (name == (char *)0x1) {
            name = fdt_stringlist_get(param_1,nodeoffset,"path",0,(int *)&local_7c);
            if (((0x20 < local_7c) && (_fsymc_level_hal_drv < BLOG_LEVEL_WARN)) &&
               (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
              if (TrapNetCounter == 0) {
                TVar1 = xTaskGetTickCount();
              }
              else {
                TVar1 = xTaskGetTickCountFromISR();
              }
              bl_printk("[%10u][%s: %s:%4d] uart[%d] path lentmp = %d\r\n",TVar1,&DAT_2306e4ac,
                        "hal_uart.c",0x144,iVar7,local_7c);
            }
            pfVar2 = (fdt32_t *)fdt_getprop(param_1,nodeoffset,"baudrate",(int *)&local_7c);
            if (pfVar2 == (fdt32_t *)0x0) {
              if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                 (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                if (TrapNetCounter == 0) {
                  xTaskGetTickCount();
                }
                else {
                  xTaskGetTickCountFromISR();
                }
                uVar6 = 0x14b;
                name = "[%10u][%s: %s:%4d] uart[%d] baudrate NULL.\r\n";
LAB_230376aa:
                bl_printk(name,&DAT_2306e4ac,"hal_uart.c",uVar6,iVar7);
              }
            }
            else {
              x_00 = *pfVar2;
              pfVar2 = (fdt32_t *)fdt_getprop(param_1,nodeoffset,"id",(int *)&local_7c);
              if (pfVar2 == (fdt32_t *)0x0) {
                if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                   (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                  if (TrapNetCounter == 0) {
                    xTaskGetTickCount();
                  }
                  else {
                    xTaskGetTickCountFromISR();
                  }
                  uVar6 = 0x153;
                  name = "[%10u][%s: %s:%4d] uart[%d] id NULL.\r\n";
                  goto LAB_230376aa;
                }
              }
              else {
                x = *pfVar2;
                nodeoffset_00 = fdt_subnode_offset(param_1,nodeoffset,"buf_size");
                if (nodeoffset_00 < 1) {
                  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                     (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                    if (TrapNetCounter == 0) {
                      TVar1 = xTaskGetTickCount();
                    }
                    else {
                      TVar1 = xTaskGetTickCountFromISR();
                    }
                    bl_printk("[%10u][%s: %s:%4d] uart[%d] buf_size NULL, will use default.\r\n",
                              TVar1,&DAT_2306e4ac,"hal_uart.c",0x15b,iVar7);
                  }
                  tx_buf_size = 0x200;
                  rx_buf_size = 0x200;
LAB_2303782e:
                  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                     (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                    if (TrapNetCounter == 0) {
                      TVar1 = xTaskGetTickCount();
                    }
                    else {
                      TVar1 = xTaskGetTickCountFromISR();
                    }
                    bl_printk("[%10u][%s: %s:%4d] uart[%d] rx_buf_size %d, tx_buf_size %d\r\n",TVar1
                              ,&DAT_2306e4ac,"hal_uart.c",0x16c,iVar7,rx_buf_size,tx_buf_size);
                  }
                  baudrate = fdt32_to_cpu(x_00);
                  uVar3 = fdt32_to_cpu(x);
                  ppcVar8 = &local_70;
                  do {
                    nodeoffset_00 = fdt_subnode_offset(param_1,nodeoffset,"feature");
                    if (nodeoffset_00 < 1) {
                      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                         (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                        if (TrapNetCounter == 0) {
                          TVar1 = xTaskGetTickCount();
                        }
                        else {
                          TVar1 = xTaskGetTickCountFromISR();
                        }
                        bl_printk("[%10u][%s: %s:%4d] uart[%d] feature NULL.\r\n",TVar1,
                                  &DAT_2306e4ac,"hal_uart.c",0x171,iVar7);
                      }
                    }
                    else {
                      property = *ppcVar8;
                      iVar4 = fdt_stringlist_count(param_1,nodeoffset_00,property);
                      if (iVar4 == 1) {
                        __s2 = fdt_stringlist_get(param_1,nodeoffset_00,property,0,(int *)&local_7c)
                        ;
                        if ((local_7c == 4) &&
                           (nodeoffset_00 = memcmp(&DAT_2307958c,__s2,4), nodeoffset_00 == 0)) {
                          nodeoffset_00 = fdt_subnode_offset(param_1,nodeoffset,"pin");
                          if (nodeoffset_00 < 1) {
                            if ((BLOG_LEVEL_INFO < _fsymc_level_hal_drv) ||
                               (BLOG_LEVEL_INFO < _fsymf_level_hal_drvhal_uart)) goto LAB_230379e8;
                            if (TrapNetCounter == 0) {
                              TVar1 = xTaskGetTickCount();
                            }
                            else {
                              TVar1 = xTaskGetTickCountFromISR();
                            }
                            bl_printk("[%10u][%s: %s:%4d] uart[%d] pin NULL.\r\n",TVar1,
                                      &DAT_2306e4ac,"hal_uart.c",0x182,iVar7);
                            break;
                          }
                          property = ppcVar8[1];
                          pfVar2 = (fdt32_t *)
                                   fdt_getprop(param_1,nodeoffset_00,property,(int *)&local_7c);
                          if (pfVar2 == (fdt32_t *)0x0) {
                            if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                               (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                              if (TrapNetCounter == 0) {
                                TVar1 = xTaskGetTickCount();
                              }
                              else {
                                TVar1 = xTaskGetTickCountFromISR();
                              }
                              bl_printk("[%10u][%s: %s:%4d] uart[%d] %s NULL.\r\n",TVar1,
                                        &DAT_2306e4ac,"hal_uart.c",0x187,iVar7,property);
                            }
                          }
                          else {
                            uVar5 = fdt32_to_cpu(*pfVar2);
                            *(char *)(ppcVar8 + 2) = (char)uVar5;
                          }
                        }
                        else {
                          if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                             (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                            if (TrapNetCounter == 0) {
                              TVar1 = xTaskGetTickCount();
                            }
                            else {
                              TVar1 = xTaskGetTickCountFromISR();
                            }
                            bl_printk("[%10u][%s: %s:%4d] uart[%d] %s status = %s lentmp = %d\r\n",
                                      TVar1,&DAT_2306e4ac,"hal_uart.c",0x17b,iVar7,property,__s2);
                          }
                        }
                      }
                      else {
                        if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                           (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                          if (TrapNetCounter == 0) {
                            TVar1 = xTaskGetTickCount();
                          }
                          else {
                            TVar1 = xTaskGetTickCountFromISR();
                          }
                          bl_printk("[%10u][%s: %s:%4d] uart[%d] %s countindex = %d.\r\n",TVar1,
                                    &DAT_2306e4ac,"hal_uart.c",0x176,iVar7,property,iVar4);
                        }
                      }
                    }
                    ppcVar8 = ppcVar8 + 3;
                  } while (apcStack64 != ppcVar8);
                  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                     (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                    if (TrapNetCounter == 0) {
                      TVar1 = xTaskGetTickCount();
                    }
                    else {
                      TVar1 = xTaskGetTickCountFromISR();
                    }
                    bl_printk(
                              "[%10u][%s: %s:%4d] id = %d, %s = %d, %s = %d, %s = %d, %s = %d baudrate = %ld.\r\n"
                              ,TVar1,&DAT_2306e4ac,"hal_uart.c",0x192,uVar3 & 0xff,uStack108,
                              (uint)bStack104);
                  }
LAB_230379e8:
                  uStack152 = (uint8_t)uVar3;
                  bl_uart_flush(uStack152);
                  bl_uart_init(uStack152,bStack104,uStack92,uStack80,uStack68,baudrate);
                  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                     (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                    if (TrapNetCounter == 0) {
                      TVar1 = xTaskGetTickCount();
                    }
                    else {
                      TVar1 = xTaskGetTickCountFromISR();
                    }
                    bl_printk("[%10u][%s: %s:%4d] bl_uart_init %d ok.\r\n",TVar1,&DAT_2306e4ac,
                              "hal_uart.c",0x19a,uVar3 & 0xff);
                    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                       (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                      if (TrapNetCounter == 0) {
                        TVar1 = xTaskGetTickCount();
                      }
                      else {
                        TVar1 = xTaskGetTickCountFromISR();
                      }
                      bl_printk("[%10u][%s: %s:%4d] bl_uart_init %d baudrate = %ld ok.\r\n",TVar1,
                                &DAT_2306e4ac,"hal_uart.c",0x19b,uVar3 & 0xff,baudrate);
                    }
                  }
                  nodeoffset = dev_uart_init(uStack152,name,rx_buf_size,tx_buf_size);
                  if (((nodeoffset != 0) && (_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT)) &&
                     (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_ASSERT)) {
                    if (TrapNetCounter == 0) {
                      xTaskGetTickCount();
                    }
                    else {
                      xTaskGetTickCountFromISR();
                    }
                    bl_printk("[%10u][%s: %s:%4d] dev_uart_init err.\r\n",&DAT_23078e4c,"hal_uart.c"
                              ,0x19e);
                  }
                }
                else {
                  pfVar2 = (fdt32_t *)fdt_getprop(param_1,nodeoffset_00,"rx_size",(int *)&local_7c);
                  if (pfVar2 == (fdt32_t *)0x0) {
                    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                       (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                      if (TrapNetCounter == 0) {
                        xTaskGetTickCount();
                      }
                      else {
                        xTaskGetTickCountFromISR();
                      }
                      name = "rx_size";
                      uVar6 = 0x161;
LAB_2303747e:
                      property = "[%10u][%s: %s:%4d] uart[%d] %s NULL.\r\n";
                      goto LAB_230374f2;
                    }
                  }
                  else {
                    x_01 = *pfVar2;
                    pfVar2 = (fdt32_t *)
                             fdt_getprop(param_1,nodeoffset_00,"tx_size",(int *)&local_7c);
                    if (pfVar2 != (fdt32_t *)0x0) {
                      rx_buf_size = fdt32_to_cpu(x_01);
                      tx_buf_size = fdt32_to_cpu(*pfVar2);
                      goto LAB_2303782e;
                    }
                    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                       (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                      if (TrapNetCounter == 0) {
                        xTaskGetTickCount();
                      }
                      else {
                        xTaskGetTickCountFromISR();
                      }
                      name = "tx_size";
                      uVar6 = 0x167;
                      goto LAB_2303747e;
                    }
                  }
                }
              }
            }
          }
          else {
            if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
               (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
              if (TrapNetCounter == 0) {
                xTaskGetTickCount();
              }
              else {
                xTaskGetTickCountFromISR();
              }
              uVar6 = 0x13e;
              property = "[%10u][%s: %s:%4d] uart[%d] path_countindex = %d NULL.\r\n";
              goto LAB_230374f2;
            }
          }
        }
        else {
          if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
             (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
            if (TrapNetCounter == 0) {
              xTaskGetTickCount();
            }
            else {
              xTaskGetTickCountFromISR();
            }
            uVar6 = 0x137;
            property = "[%10u][%s: %s:%4d] uart[%d] status = %s\r\n";
            goto LAB_230374f2;
          }
        }
      }
      else {
        if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
           (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
          if (TrapNetCounter == 0) {
            xTaskGetTickCount();
          }
          else {
            xTaskGetTickCountFromISR();
          }
          uVar6 = 0x132;
          property = "[%10u][%s: %s:%4d] uart[%d] status_countindex = %d NULL.\r\n";
LAB_230374f2:
          bl_printk(property,&DAT_2306e4ac,"hal_uart.c",uVar6,iVar7,name);
        }
      }
    }
    ppcStack148 = ppcStack148 + 1;
    if (iVar7 != 0) {
      inited = (int8_t)iVar7;
      return 0;
    }
    iVar7 = 1;
  } while( true );
}



int32_t hal_uart_send_flush(uart_dev_t *uart,uint32_t timeout)

{
  bl_uart_flush(uart->port);
  return 0;
}



void hal_uart_setbaud(uart_dev_t *uart,uint32_t baud)

{
  bl_uart_setbaud(uart->port,baud);
  return;
}



void hal_uart_setconfig(uart_dev_t *uart,uint32_t baud,hal_uart_parity_t parity)

{
  bl_uart_setconfig(uart->port,baud,parity);
  return;
}



undefined4 hal_gpio_init_from_dts(void *param_1,int param_2)

{
  uint uVar1;
  uint *puVar2;
  int nodeoffset;
  char *format;
  TickType_t TVar3;
  int iVar4;
  char *format_00;
  undefined *puVar5;
  undefined4 uVar6;
  uint uVar7;
  int iVar8;
  int local_5c;
  char acStack88 [11];
  undefined uStack77;
  uint uStack76;
  char cStack72;
  byte bStack71;
  byte bStack70;
  undefined uStack69;
  uint uStack68;
  
  uStack76 = 0;
  puVar2 = (uint *)fdt_getprop(param_1,param_2,"max_num",(int *)&uStack76);
  uVar1 = 0xffffffff;
  if (puVar2 != (uint *)0x0) {
    uVar1 = *puVar2;
    uVar1 = uVar1 << 0x18 | uVar1 >> 0x18 | (uVar1 >> 8 & 0xff) << 0x10 |
            (uVar1 >> 0x10 & 0xff) << 8;
  }
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvhal_gpio < BLOG_LEVEL_WARN))
  {
    if (TrapNetCounter == 0) {
      xTaskGetTickCount();
    }
    else {
      xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [HAL] [GPIO] Max num is %d\r\n",&DAT_2306e4ac,"hal_gpio.c",0xb5,
              uVar1);
  }
  iVar8 = 0;
  do {
    if ((int)uVar1 <= iVar8) {
      return 0;
    }
    snprintf(acStack88,0xb,"gpio%u",iVar8);
    uStack77 = 0;
    local_5c = 0;
    nodeoffset = fdt_subnode_offset(param_1,param_2,acStack88);
    if (nodeoffset < 0) {
      if (BLOG_LEVEL_INFO < _fsymc_level_hal_drv) {
        return 0;
      }
      if (BLOG_LEVEL_INFO < _fsymf_level_hal_drvhal_gpio) {
        return 0;
      }
      if (TrapNetCounter == 0) {
        xTaskGetTickCount();
      }
      else {
        xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] %s NOT found\r\n",&DAT_2306e4ac,"hal_gpio.c",0x61,acStack88);
      return 0;
    }
    memset(&uStack76,0,0xc);
    cStack72 = '\0';
    format = fdt_stringlist_get(param_1,nodeoffset,"status",0,&local_5c);
    if ((local_5c == 4) && (iVar4 = memcmp(&DAT_2307958c,format,4), iVar4 == 0)) {
      puVar2 = (uint *)fdt_getprop(param_1,nodeoffset,"pin",&local_5c);
      if (puVar2 == (uint *)0x0) {
        if ((BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) ||
           (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvhal_gpio)) goto LAB_23037dae;
        if (TrapNetCounter == 0) {
          xTaskGetTickCount();
        }
        else {
          xTaskGetTickCountFromISR();
        }
        uVar6 = 0x70;
        format = "[%10u][%s: %s:%4d] no pin found for %s\r\n";
LAB_23037e6c:
        bl_printk(format,&DAT_23078e4c,"hal_gpio.c",uVar6,acStack88);
      }
      else {
        uVar7 = *puVar2;
        uStack76 = (uVar7 >> 0x10 & 0xff) << 8 |
                   uVar7 << 0x18 | uVar7 >> 0x18 | (uVar7 >> 8 & 0xff) << 0x10;
        format = fdt_stringlist_get(param_1,nodeoffset,"feature",0,&local_5c);
        if ((local_5c != 3) || (iVar4 = memcmp("led",format,3), iVar4 != 0)) {
          if ((BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) ||
             (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvhal_gpio)) goto LAB_23037dae;
          if (TrapNetCounter == 0) {
            xTaskGetTickCount();
          }
          else {
            xTaskGetTickCountFromISR();
          }
          uVar6 = 0x79;
LAB_23037fee:
          puVar5 = &DAT_23078e4c;
          format_00 = "[%10u][%s: %s:%4d] %s: unvalid GPIO config %3s\r\n";
          goto LAB_23037ea2;
        }
        bStack71 = 0;
        format = fdt_stringlist_get(param_1,nodeoffset,"active",0,&local_5c);
        if (local_5c == 2) {
          iVar4 = memcmp(&DAT_230799e8,format,2);
          if (iVar4 == 0) {
            bStack70 = 1;
          }
          else {
            if ((local_5c != 2) || (iVar4 = memcmp(&DAT_230799ec,format,2), iVar4 != 0))
            goto LAB_2303802a;
            bStack70 = 0;
          }
          format = fdt_stringlist_get(param_1,nodeoffset,"mode",0,&local_5c);
          if ((local_5c == 5) && (iVar4 = memcmp("blink",format,5), iVar4 == 0)) {
            uStack69 = 0;
          }
          else {
            if ((local_5c != 9) || (iVar4 = memcmp("heartbeat",format,9), iVar4 != 0)) {
              if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
                 (_fsymf_level_hal_drvhal_gpio < BLOG_LEVEL_ASSERT)) {
                if (TrapNetCounter == 0) {
                  xTaskGetTickCount();
                }
                else {
                  xTaskGetTickCountFromISR();
                }
                uVar6 = 0x8d;
                goto LAB_23037fee;
              }
              goto LAB_23037dae;
            }
            uStack69 = 1;
          }
          puVar2 = (uint *)fdt_getprop(param_1,nodeoffset,"time",&local_5c);
          if (puVar2 == (uint *)0x0) {
            if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
               (_fsymf_level_hal_drvhal_gpio < BLOG_LEVEL_ASSERT)) {
              if (TrapNetCounter == 0) {
                xTaskGetTickCount();
              }
              else {
                xTaskGetTickCountFromISR();
              }
              uVar6 = 0x93;
              format = "[%10u][%s: %s:%4d] %s: unvalid GPIO config\r\n";
              goto LAB_23037e6c;
            }
          }
          else {
            uVar7 = *puVar2;
            uStack68 = (uVar7 >> 0x10 & 0xff) << 8 |
                       uVar7 << 0x18 | uVar7 >> 0x18 | (uVar7 >> 8 & 0xff) << 0x10;
            cStack72 = '\x01';
          }
        }
        else {
LAB_2303802a:
          if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
             (_fsymf_level_hal_drvhal_gpio < BLOG_LEVEL_ASSERT)) {
            if (TrapNetCounter == 0) {
              xTaskGetTickCount();
            }
            else {
              xTaskGetTickCountFromISR();
            }
            uVar6 = 0x83;
            goto LAB_23037fee;
          }
        }
      }
    }
    else {
      if ((BLOG_LEVEL_INFO < _fsymc_level_hal_drv) ||
         (BLOG_LEVEL_INFO < _fsymf_level_hal_drvhal_gpio)) goto LAB_23037dae;
      if (TrapNetCounter == 0) {
        xTaskGetTickCount();
      }
      else {
        xTaskGetTickCountFromISR();
      }
      uVar6 = 0x6a;
      puVar5 = &DAT_2306e4ac;
      format_00 = "[%10u][%s: %s:%4d] [%s] status = %s\r\n";
LAB_23037ea2:
      bl_printk(format_00,puVar5,"hal_gpio.c",uVar6,acStack88,format);
    }
LAB_23037dae:
    if (cStack72 == '\x01') {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_gpio < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk(
                  "[%10u][%s: %s:%4d] New CONF: GPIO%02u: feature %u, active %u, mode %u, time %u\r\n"
                  ,TVar3,&DAT_2306e4ac,"hal_gpio.c",0xa6,uStack76,(uint)bStack71,(uint)bStack70);
      }
      loopset_led_trigger(uStack76,uStack68);
    }
    else {
      if (((cStack72 == '\0') && (_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT)) &&
         (_fsymf_level_hal_drvhal_gpio < BLOG_LEVEL_ASSERT)) {
        if (TrapNetCounter == 0) {
          xTaskGetTickCount();
        }
        else {
          xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] %s: unvalid GPIO config\r\n",&DAT_23078e4c,"hal_gpio.c",0xc3,
                  acStack88);
      }
    }
    iVar8 = iVar8 + 1;
  } while( true );
}



int hal_reboot(void)

{
  GLB_SW_POR_Reset();
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void hal_sys_reset(void)

{
  GLB_SW_System_Reset();
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void hal_poweroff(void)

{
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void hal_sys_capcode_update(uint8_t capin,uint8_t capout)

{
  uint8_t capin_static;
  uint8_t capout_static;
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  
  if ((CONCAT31(in_register_00002029,capin) != 0xff) &&
     (CONCAT31(in_register_0000202d,capout) != 0xff)) {
    (*_DAT_2101081c)();
    return;
  }
                    // WARNING: Could not recover jumptable at 0x2303818e. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_2101081c)((uint)capin_static,(uint)capout_static);
  return;
}



uint8_t hal_sys_capcode_get(void)

{
  uint8_t uVar1;
  
  uVar1 = AON_Get_Xtal_CapCode();
  return uVar1;
}



uint32_t fdt32_to_cpu(fdt32_t x)

{
  return (x >> 0x10 & 0xff) << 8 | x << 0x18 | x >> 0x18 | (x >> 8 & 0xff) << 0x10;
}



uint32_t hal_board_get_factory_addr(void)

{
  return factory_addr;
}



// WARNING: Could not reconcile some variable overlaps

undefined4 hal_board_cfg(void)

{
  char cVar1;
  byte bVar2;
  uint32_t ble_tx_power;
  int parentoffset;
  TickType_t TVar3;
  int nodeoffset;
  int iVar4;
  char *format;
  size_t sVar5;
  uint32_t uVar6;
  uint32_t uVar7;
  void *__src;
  uint32_t autoconnect;
  fdt32_t x;
  int iVar8;
  int iVar9;
  char *pcVar10;
  uint8_t chan;
  undefined4 uVar11;
  size_t *psVar12;
  size_t *psVar13;
  byte *pbVar14;
  fdt32_t *pfVar15;
  uint8_t capin;
  uint8_t psk_len;
  fdt32_t *pfVar16;
  int iStack220;
  byte local_c4 [4];
  uint32_t uStack192;
  int iStack188;
  size_t sStack184;
  size_t local_b4;
  size_t local_b0;
  int8_t iStack170;
  size_t local_a0 [3];
  size_t asStack146 [4];
  undefined4 local_80;
  byte bStack124;
  byte bStack123;
  
  parentoffset = hal_boot2_partition_addr_active("factory",&factory_addr,&uStack192);
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN))
  {
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [MAIN] [BOARD] [FLASH] addr from partition is %08x, ret is %d\r\n"
              ,TVar3,&DAT_2306e4ac,"hal_board.c",0x376,factory_addr,parentoffset);
  }
  if (factory_addr == 0) {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
       (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      bl_printk(
                "[%10u][%s: %s:%4d] [MAIN] [BOARD] [FLASH] Dead loop. Reason: NO valid Param Parition found\r\n"
                ,TVar3,&DAT_23078e4c,"hal_board.c",0x378);
    }
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  parentoffset = hal_boot2_partition_bus_addr_active("factory",&factory_addr,&uStack192);
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN))
  {
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [MAIN] [BOARD] [XIP] addr from partition is %08x, ret is %d\r\n",
              TVar3,&DAT_2306e4ac,"hal_board.c",0x37e,factory_addr,parentoffset);
  }
  ble_tx_power = factory_addr;
  if (factory_addr == 0) {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
       (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      bl_printk(
                "[%10u][%s: %s:%4d] [MAIN] [BOARD] [XIP] Dead loop. Reason: NO valid Param Parition found\r\n"
                ,TVar3,&DAT_23078e4c,"hal_board.c",0x380);
    }
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  iStack188 = 0;
  parentoffset = fdt_subnode_offset((void *)factory_addr,0,"wifi");
  if (((parentoffset < 1) && (_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT)) &&
     (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] wifi NULL.\r\n",TVar3,&DAT_23078e4c,"hal_board.c",0x242);
  }
  nodeoffset = fdt_subnode_offset((void *)ble_tx_power,parentoffset,"brd_rf");
  if (0 < nodeoffset) {
    local_a0[0] = 0;
    iVar4 = fdt_stringlist_count((void *)ble_tx_power,nodeoffset,"xtal_mode");
    if (iVar4 == 1) {
      format = fdt_stringlist_get((void *)ble_tx_power,nodeoffset,"xtal_mode",0,(int *)local_a0);
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] xtal_mode length %d\r\n",TVar3,&DAT_2306e4ac,"hal_board.c",
                  0x141,local_a0[0]);
      }
      if ((int)local_a0[0] < 3) {
        memcpy(&local_b0,format,local_a0[0]);
        local_b0 = local_b0 & 0xff00ffff;
        if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
           (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
          if (TrapNetCounter == 0) {
            TVar3 = xTaskGetTickCount();
          }
          else {
            TVar3 = xTaskGetTickCountFromISR();
          }
          bl_printk("[%10u][%s: %s:%4d] xtal_mode is %s\r\n",TVar3,&DAT_2306e4ac,"hal_board.c",0x145
                    ,&local_b0);
        }
        sVar5 = strlen((char *)&local_b0);
        iVar4 = 0;
        while (iVar4 < (int)sVar5) {
          if (*(char *)((int)&local_b0 + iVar4) == 'F') {
            local_80 = 0;
            pfVar15 = (fdt32_t *)fdt_getprop((void *)ble_tx_power,nodeoffset,"xtal",&local_80);
            if (local_80 == 0x14) {
              if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                 (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
                if (TrapNetCounter == 0) {
                  TVar3 = xTaskGetTickCount();
                }
                else {
                  TVar3 = xTaskGetTickCountFromISR();
                }
                autoconnect = fdt32_to_cpu(*pfVar15);
                uVar6 = fdt32_to_cpu(pfVar15[1]);
                uVar7 = fdt32_to_cpu(pfVar15[2]);
                fdt32_to_cpu(pfVar15[3]);
                fdt32_to_cpu(pfVar15[4]);
                bl_printk("[%10u][%s: %s:%4d] xtal dtb in DEC :%u %u %u %u %u\r\n",TVar3,
                          &DAT_2306e4ac,"hal_board.c",0xf9,autoconnect & 0xff,uVar6 & 0xff,
                          uVar7 & 0xff);
              }
              autoconnect = fdt32_to_cpu(*pfVar15);
              capin = (uint8_t)autoconnect;
              autoconnect = fdt32_to_cpu(pfVar15[1]);
              local_80._0_1_ = (byte)autoconnect;
              if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) &&
                 (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO)) {
                if (TrapNetCounter == 0) {
                  TVar3 = xTaskGetTickCount();
                }
                else {
                  TVar3 = xTaskGetTickCountFromISR();
                }
                bl_printk("[%10u][%s: %s:%4d] get xtal from F ready\r\n",TVar3,"DEBUG ",
                          "hal_board.c",0x114);
              }
              goto LAB_2303863a;
            }
            if (_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) {
              if (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT) {
                if (TrapNetCounter == 0) {
                  TVar3 = xTaskGetTickCount();
                }
                else {
                  TVar3 = xTaskGetTickCountFromISR();
                }
                bl_printk("[%10u][%s: %s:%4d] xtal dtb NULL.",TVar3,&DAT_23078e4c,"hal_board.c",
                          0x100);
              }
              if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) &&
                 (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO)) {
                if (TrapNetCounter == 0) {
                  TVar3 = xTaskGetTickCount();
                }
                else {
                  TVar3 = xTaskGetTickCountFromISR();
                }
                uVar11 = 0x117;
                format = "[%10u][%s: %s:%4d] get xtal from F failed\r\n";
                goto LAB_230389a4;
              }
            }
          }
          else {
            if (*(char *)((int)&local_b0 + iVar4) != 'M') {
              if (TrapNetCounter == 0) {
                TVar3 = xTaskGetTickCount();
              }
              else {
                TVar3 = xTaskGetTickCountFromISR();
              }
              bl_printk("[%10u][%s: %s:%4d] ASSERT: %s:%d\r\n",TVar3,&UNK_2307261c,"hal_board.c",
                        0x128,"hal_board.c",0x128);
              do {
                    // WARNING: Do nothing block with infinite loop
              } while( true );
            }
            local_80 = local_80 & 0xffffff00;
            iVar8 = bl_efuse_read_capcode((uint8_t *)&local_80);
            if (iVar8 == 0) {
              capin = (byte)local_80;
              if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) &&
                 (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO)) {
                if (TrapNetCounter == 0) {
                  TVar3 = xTaskGetTickCount();
                }
                else {
                  TVar3 = xTaskGetTickCountFromISR();
                }
                bl_printk("[%10u][%s: %s:%4d] get xtal from M ready\r\n",TVar3,"DEBUG ",
                          "hal_board.c",0x11f);
              }
              goto LAB_2303863a;
            }
            if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) &&
               (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO)) {
              if (TrapNetCounter == 0) {
                TVar3 = xTaskGetTickCount();
              }
              else {
                TVar3 = xTaskGetTickCountFromISR();
              }
              uVar11 = 0x122;
              format = "[%10u][%s: %s:%4d] get xtal from M failed\r\n";
LAB_230389a4:
              bl_printk(format,TVar3,"DEBUG ","hal_board.c",uVar11);
            }
          }
          iVar4 = iVar4 + 1;
          if (iVar4 == 2) break;
        }
        if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
           (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
          if (TrapNetCounter == 0) {
            TVar3 = xTaskGetTickCount();
          }
          else {
            TVar3 = xTaskGetTickCountFromISR();
          }
          bl_printk("[%10u][%s: %s:%4d] Using Default xtal\r\n",TVar3,&DAT_2306e4ac,"hal_board.c",
                    0x12e);
        }
        local_80._0_1_ = '2';
        capin = '2';
LAB_2303863a:
        hal_sys_capcode_update(capin,(byte)local_80);
      }
    }
    __src = fdt_getprop((void *)ble_tx_power,nodeoffset,"channel_div_table",&iStack188);
    if (iStack188 == 0x3c) {
      iVar4 = 0;
      do {
        autoconnect = fdt32_to_cpu(*(fdt32_t *)((int)__src + iVar4));
        *(uint32_t *)((int)&local_80 + iVar4) = autoconnect;
        iVar4 = iVar4 + 4;
      } while (iVar4 != 0x3c);
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] channel_div_table :\r\n",TVar3,&DAT_2306e4ac,"hal_board.c",600
                 );
      }
      log_buf_out("hal_board.c",0x259,&local_80,0x3c,LOG_BUF_OUT_DATA_TYPE_HEX);
    }
    else {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] channel_div_table NULL.\r\n",TVar3,&DAT_23078e4c,"hal_board.c"
                  ,0x25b);
      }
    }
    pfVar15 = (fdt32_t *)fdt_getprop((void *)ble_tx_power,nodeoffset,"channel_cnt_table",&iStack188)
    ;
    if (iStack188 == 0x38) {
      pfVar16 = pfVar15 + 0xe;
      psVar12 = local_a0;
      do {
        x = *pfVar15;
        pfVar15 = pfVar15 + 1;
        autoconnect = fdt32_to_cpu(x);
        *(short *)psVar12 = (short)autoconnect;
        psVar12 = (size_t *)((int)psVar12 + 2);
      } while (pfVar16 != pfVar15);
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] channel_cnt_table :\r\n",TVar3,&DAT_2306e4ac,"hal_board.c",
                  0x263);
      }
      log_buf_out("hal_board.c",0x264,local_a0,0x38,LOG_BUF_OUT_DATA_TYPE_HEX);
    }
    else {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] channel_cnt_table NULL.\r\n",TVar3,&DAT_23078e4c,"hal_board.c"
                  ,0x266);
      }
    }
    pfVar15 = (fdt32_t *)fdt_getprop((void *)ble_tx_power,nodeoffset,"lo_fcal_div",&iStack188);
    if (iStack188 == 4) {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        x = *pfVar15;
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        autoconnect = fdt32_to_cpu(x);
        bl_printk("[%10u][%s: %s:%4d] lo_fcal_div : %d\r\n",TVar3,&DAT_2306e4ac,"hal_board.c",0x26c,
                  autoconnect & 0xffff);
      }
    }
    else {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] lo_fcal_div NULL.\r\n",TVar3,&DAT_23078e4c,"hal_board.c",0x26e
                 );
      }
    }
  }
  nodeoffset = fdt_subnode_offset((void *)ble_tx_power,parentoffset,"mac");
  if (0 < nodeoffset) {
    local_b4 = 0;
    iVar4 = fdt_stringlist_count((void *)ble_tx_power,nodeoffset,"mode");
    if (iVar4 == 1) {
      format = fdt_stringlist_get((void *)ble_tx_power,nodeoffset,"mode",0,(int *)&local_b4);
      bl_printk("MAC address mode length %d\r\n",local_b4);
      if ((int)local_b4 < 4) {
        memcpy(&local_b0,format,local_b4);
        local_b0 = local_b0 & 0xffffff;
        bl_printk("MAC address mode is %s\r\n",&local_b0);
        sVar5 = strlen((char *)&local_b0);
        iVar4 = 0;
        do {
          if ((int)sVar5 <= iVar4) break;
          cVar1 = *(char *)((int)&local_b0 + iVar4);
          if (cVar1 == 'F') {
            __src = fdt_getprop((void *)ble_tx_power,nodeoffset,"sta_mac_addr",(int *)local_a0);
            if (local_a0[0] == 6) {
              memcpy(&local_80,__src,6);
              bl_wifi_sta_mac_addr_set((uint8_t *)&local_80);
              __src = fdt_getprop((void *)ble_tx_power,nodeoffset,"ap_mac_addr",(int *)local_a0);
              if (local_a0[0] == 6) {
                memcpy(&local_80,__src,6);
                bl_wifi_ap_mac_addr_set((uint8_t *)&local_80);
                if (BLOG_LEVEL_DEBUG < _fsymc_level_hal_drv) goto LAB_23038bfe;
                if (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO) {
                  if (TrapNetCounter == 0) {
                    TVar3 = xTaskGetTickCount();
                  }
                  else {
                    TVar3 = xTaskGetTickCountFromISR();
                  }
                  uVar11 = 0x9b;
                  format = "[%10u][%s: %s:%4d] get MAC from F ready\r\n";
                  goto LAB_23038bfa;
                }
                goto LAB_23038c08;
              }
              if (_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) {
                if (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT) {
                  if (TrapNetCounter == 0) {
                    TVar3 = xTaskGetTickCount();
                  }
                  else {
                    TVar3 = xTaskGetTickCountFromISR();
                  }
                  uVar11 = 0x54;
                  iVar8 = -0x10;
                  goto LAB_23039138;
                }
                goto LAB_2303913c;
              }
            }
            else {
              if (_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) {
                if (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT) {
                  if (TrapNetCounter == 0) {
                    TVar3 = xTaskGetTickCount();
                  }
                  else {
                    TVar3 = xTaskGetTickCountFromISR();
                  }
                  uVar11 = 0x47;
                  iVar8 = -0x38;
LAB_23039138:
                  bl_printk("[%10u][%s: %s:%4d] ap_mac_addr NULL.\r\n" + iVar8 + 0x10,TVar3,
                            &DAT_23078e4c,"hal_board.c",uVar11);
                }
LAB_2303913c:
                if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) &&
                   (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO)) {
                  if (TrapNetCounter == 0) {
                    TVar3 = xTaskGetTickCount();
                  }
                  else {
                    TVar3 = xTaskGetTickCountFromISR();
                  }
                  uVar11 = 0x9e;
                  format = "[%10u][%s: %s:%4d] get MAC from F failed\r\n";
                  goto LAB_2303890e;
                }
              }
            }
          }
          else {
            if (cVar1 == 'M') {
              iVar8 = bl_efuse_read_mac_factory((uint8_t *)&local_80);
              if (iVar8 == 0) {
                if (((byte)(bStack123 |
                           bStack124 |
                           local_80._3_1_ | local_80._2_1_ | (byte)local_80 | local_80._1_1_) != 0)
                   && (((byte)local_80 & local_80._1_1_ & local_80._2_1_ & local_80._3_1_ &
                        bStack124 & bStack123) != 1)) {
                  if (BLOG_LEVEL_DEBUG < _fsymc_level_hal_drv) goto LAB_23038bfe;
                  if (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO) {
                    if (TrapNetCounter == 0) {
                      TVar3 = xTaskGetTickCount();
                    }
                    else {
                      TVar3 = xTaskGetTickCountFromISR();
                    }
                    uVar11 = 0xa6;
                    format = "[%10u][%s: %s:%4d] get MAC from M ready\r\n";
                    goto LAB_23038bfa;
                  }
                  goto LAB_23038c08;
                }
              }
              if ((BLOG_LEVEL_DEBUG < _fsymc_level_hal_drv) ||
                 (BLOG_LEVEL_DEBUG < _fsymf_level_hal_drvhal_board)) goto LAB_23038912;
              if (TrapNetCounter == 0) {
                TVar3 = xTaskGetTickCount();
              }
              else {
                TVar3 = xTaskGetTickCountFromISR();
              }
              uVar11 = 0xa9;
              format = "[%10u][%s: %s:%4d] get MAC from M failed\r\n";
            }
            else {
              if (cVar1 != 'B') {
                if (TrapNetCounter == 0) {
                  TVar3 = xTaskGetTickCount();
                }
                else {
                  TVar3 = xTaskGetTickCountFromISR();
                }
                bl_printk("[%10u][%s: %s:%4d] ASSERT: %s:%d\r\n",TVar3,&UNK_2307261c,"hal_board.c",
                          0xaf,"hal_board.c",0xaf);
                do {
                    // WARNING: Do nothing block with infinite loop
                } while( true );
              }
              bl_efuse_read_mac((uint8_t *)&local_80);
              if (((byte)(bStack123 |
                         bStack124 |
                         local_80._3_1_ | local_80._2_1_ | (byte)local_80 | local_80._1_1_) != 0) &&
                 (((byte)local_80 & local_80._1_1_ & local_80._2_1_ & local_80._3_1_ & bStack124 &
                  bStack123) != 1)) {
                if (BLOG_LEVEL_DEBUG < _fsymc_level_hal_drv) goto LAB_23038bfe;
                if (BLOG_LEVEL_DEBUG < _fsymf_level_hal_drvhal_board) goto LAB_23038c08;
                if (TrapNetCounter == 0) {
                  TVar3 = xTaskGetTickCount();
                }
                else {
                  TVar3 = xTaskGetTickCountFromISR();
                }
                uVar11 = 0x90;
                format = "[%10u][%s: %s:%4d] get MAC from B ready\r\n";
LAB_23038bfa:
                bl_printk(format,TVar3,"DEBUG ","hal_board.c",uVar11);
                goto LAB_23038bfe;
              }
              if ((BLOG_LEVEL_DEBUG < _fsymc_level_hal_drv) ||
                 (BLOG_LEVEL_DEBUG < _fsymf_level_hal_drvhal_board)) goto LAB_23038912;
              if (TrapNetCounter == 0) {
                TVar3 = xTaskGetTickCount();
              }
              else {
                TVar3 = xTaskGetTickCountFromISR();
              }
              uVar11 = 0x93;
              format = "[%10u][%s: %s:%4d] get MAC from B failed\r\n";
            }
LAB_2303890e:
            bl_printk(format,TVar3,"DEBUG ","hal_board.c",uVar11);
          }
LAB_23038912:
          iVar4 = iVar4 + 1;
        } while (iVar4 != 3);
        if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
           (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
          if (TrapNetCounter == 0) {
            TVar3 = xTaskGetTickCount();
          }
          else {
            TVar3 = xTaskGetTickCountFromISR();
          }
          bl_printk("[%10u][%s: %s:%4d] Using Default MAC address\r\n",TVar3,&DAT_2306e4ac,
                    "hal_board.c",0xb5);
        }
        memcpy(&local_80,&mac_default_3792,6);
LAB_23038bfe:
        if (_fsymc_level_hal_drv < BLOG_LEVEL_WARN) {
LAB_23038c08:
          if (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN) {
            if (TrapNetCounter == 0) {
              TVar3 = xTaskGetTickCount();
            }
            else {
              TVar3 = xTaskGetTickCountFromISR();
            }
            bl_printk("[%10u][%s: %s:%4d] Set MAC addrress %02X:%02X:%02X:%02X:%02X:%02X\r\n",TVar3,
                      &DAT_2306e4ac,"hal_board.c",0xc0,local_80 & 0xff,local_80 >> 8 & 0xff,
                      local_80 >> 0x10 & 0xff);
          }
        }
        bl_wifi_ap_mac_addr_set((uint8_t *)&local_80);
        bl_wifi_sta_mac_addr_set((uint8_t *)&local_80);
      }
    }
  }
  nodeoffset = fdt_subnode_offset((void *)ble_tx_power,parentoffset,"region");
  if (0 < nodeoffset) {
    pfVar15 = (fdt32_t *)fdt_getprop((void *)ble_tx_power,nodeoffset,"country_code",&iStack188);
    if (iStack188 == 4) {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        autoconnect = fdt32_to_cpu(*pfVar15);
        bl_printk("[%10u][%s: %s:%4d] country_code : %d\r\n",TVar3,&DAT_2306e4ac,"hal_board.c",0x27f
                  ,autoconnect & 0xff);
      }
      autoconnect = fdt32_to_cpu(*pfVar15);
      bl_wifi_country_code_set((uint8_t)autoconnect);
    }
    else {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] country_code NULL.\r\n",TVar3,&DAT_23078e4c,"hal_board.c",
                  0x283);
      }
    }
  }
  nodeoffset = fdt_subnode_offset((void *)ble_tx_power,parentoffset,"brd_rf");
  if (nodeoffset < 1) goto LAB_2303990c;
  __src = fdt_getprop((void *)ble_tx_power,nodeoffset,"pwr_table_11b",&iStack188);
  if (iStack188 == 0x10) {
    iVar4 = 0;
    do {
      autoconnect = fdt32_to_cpu(*(fdt32_t *)(iVar4 * 4 + (int)__src));
      *(undefined *)((int)&local_80 + iVar4) = (char)autoconnect;
      iVar4 = iVar4 + 1;
    } while (iVar4 != 4);
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
       (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] pwr_table_11b :%u %u %u %u\r\n",TVar3,&DAT_2306e4ac,
                "hal_board.c",0x298,local_80 & 0xff,local_80 >> 8 & 0xff,local_80 >> 0x10 & 0xff);
    }
    bl_tpc_update_power_rate_11b((int8_t *)&local_80);
  }
  else {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
       (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] pwr_table_11b NULL. lentmp = %d\r\n",TVar3,&DAT_23078e4c,
                "hal_board.c",0x29b,iStack188);
    }
  }
  __src = fdt_getprop((void *)ble_tx_power,nodeoffset,"pwr_table_11g",&iStack188);
  if (iStack188 == 0x20) {
    iVar4 = 0;
    do {
      autoconnect = fdt32_to_cpu(*(fdt32_t *)(iVar4 * 4 + (int)__src));
      *(undefined *)((int)&local_80 + iVar4) = (char)autoconnect;
      iVar4 = iVar4 + 1;
    } while (iVar4 != 8);
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
       (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] pwr_table_11g :%u %u %u %u %u %u %u %u\r\n",TVar3,&DAT_2306e4ac,
                "hal_board.c",0x2ac,local_80 & 0xff,local_80 >> 8 & 0xff,local_80 >> 0x10 & 0xff);
    }
    bl_tpc_update_power_rate_11g((int8_t *)&local_80);
  }
  else {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
       (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] pwr_table_11g NULL. lentmp = %d\r\n",TVar3,&DAT_23078e4c,
                "hal_board.c",0x2af,iStack188);
    }
  }
  __src = fdt_getprop((void *)ble_tx_power,nodeoffset,"pwr_table_11n",&iStack188);
  if (iStack188 == 0x20) {
    iVar4 = 0;
    do {
      autoconnect = fdt32_to_cpu(*(fdt32_t *)(iVar4 * 4 + (int)__src));
      *(undefined *)((int)&local_80 + iVar4) = (char)autoconnect;
      iVar4 = iVar4 + 1;
    } while (iVar4 != 8);
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
       (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] pwr_table_11n :%u %u %u %u %u %u %u %u\r\n",TVar3,&DAT_2306e4ac,
                "hal_board.c",0x2c0,local_80 & 0xff,local_80 >> 8 & 0xff,local_80 >> 0x10 & 0xff);
    }
    bl_tpc_update_power_rate_11n((int8_t *)&local_80);
  }
  else {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
       (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] pwr_table_11n NULL. lentmp = %d\r\n",TVar3,&DAT_23078e4c,
                "hal_board.c",0x2c3,iStack188);
    }
  }
  sStack184 = 0;
  iVar4 = fdt_stringlist_count((void *)ble_tx_power,nodeoffset,"pwr_mode");
  if (iVar4 != 1) goto LAB_2303990c;
  format = fdt_stringlist_get((void *)ble_tx_power,nodeoffset,"pwr_mode",0,(int *)&sStack184);
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN))
  {
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] pwr_mode length %d\r\n",TVar3,&DAT_2306e4ac,"hal_board.c",0x1c1,
              sStack184);
  }
  if (2 < (int)sStack184) goto LAB_2303990c;
  memcpy(local_c4,format,sStack184);
  local_c4[2] = 0;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN))
  {
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] pwr_mode is %s\r\n",TVar3,&DAT_2306e4ac,"hal_board.c",0x1c5,
              local_c4);
  }
  memset(&local_b0,0,0xe);
  memset(local_a0,0,0xe);
  sVar5 = strlen((char *)local_c4);
  pbVar14 = local_c4;
  iStack220 = 0;
  iVar8 = 0;
  do {
    if ((int)sVar5 <= iVar8) break;
    bVar2 = *pbVar14;
    if (bVar2 == 0x46) {
LAB_2303949e:
      local_b4 = 0;
      __src = fdt_getprop((void *)ble_tx_power,nodeoffset,"pwr_offset",(int *)&local_b4);
      if (local_b4 != 0x38) {
        if (_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) {
          if (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT) {
            if (TrapNetCounter == 0) {
              TVar3 = xTaskGetTickCount();
            }
            else {
              TVar3 = xTaskGetTickCountFromISR();
            }
            bl_printk("[%10u][%s: %s:%4d] pwr_offset NULL. lentmp = %d\r\n",TVar3,&DAT_23078e4c,
                      "hal_board.c",0x15f,local_b4);
          }
          if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) &&
             (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO)) {
            if (TrapNetCounter == 0) {
              TVar3 = xTaskGetTickCount();
            }
            else {
              TVar3 = xTaskGetTickCountFromISR();
            }
            uVar11 = 0x1a0;
            format = "[%10u][%s: %s:%4d] get pwr offset from F(f) failed\r\n";
            goto LAB_230397ec;
          }
        }
        goto LAB_23039762;
      }
      nodeoffset = 0;
      do {
        autoconnect = fdt32_to_cpu(*(fdt32_t *)(nodeoffset * 4 + (int)__src));
        *(undefined *)((int)local_a0 + nodeoffset) = (char)autoconnect;
        nodeoffset = nodeoffset + 1;
      } while (nodeoffset != 0xe);
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] pwr_offset from dtb:\r\n",TVar3,&DAT_2306e4ac,"hal_board.c",
                  0x156);
      }
      log_buf_out("hal_board.c",0x157,local_a0,0xe,LOG_BUF_OUT_DATA_TYPE_HEX);
      psVar12 = local_a0;
      do {
        psVar13 = (size_t *)((int)psVar12 + 1);
        *(char *)psVar12 = *(char *)psVar12 + -10;
        psVar12 = psVar13;
      } while (asStack146 != psVar13);
      if (_fsymc_level_hal_drv < BLOG_LEVEL_WARN) {
        if (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN) {
          if (TrapNetCounter == 0) {
            TVar3 = xTaskGetTickCount();
          }
          else {
            TVar3 = xTaskGetTickCountFromISR();
          }
          bl_printk("[%10u][%s: %s:%4d] pwr_offset from dtb (rebase on %d):\r\n",TVar3,&DAT_2306e4ac
                    ,"hal_board.c",0x15b,10);
        }
        if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) &&
           (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO)) {
          if (TrapNetCounter == 0) {
            TVar3 = xTaskGetTickCount();
          }
          else {
            TVar3 = xTaskGetTickCountFromISR();
          }
          bl_printk("[%10u][%s: %s:%4d] get pwr offset from F(f) ready\r\n",TVar3,"DEBUG ",
                    "hal_board.c",399);
        }
      }
      if (*pbVar14 == 0x42) {
        nodeoffset = 0;
        do {
          *(undefined *)((int)&local_b0 + nodeoffset) = *(undefined *)((int)local_a0 + nodeoffset);
          nodeoffset = nodeoffset + 1;
        } while (nodeoffset != 0xe);
        if ((BLOG_LEVEL_DEBUG < _fsymc_level_hal_drv) ||
           (BLOG_LEVEL_DEBUG < _fsymf_level_hal_drvhal_board)) goto LAB_230398e8;
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        uVar11 = 0x195;
        pcVar10 = "DEBUG ";
        format = "[%10u][%s: %s:%4d] Use pwr offset from F only\r\n";
        goto LAB_230396fa;
      }
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] Use pwr offset from f in incremental mode\r\n",TVar3,"DEBUG ",
                  "hal_board.c",0x199);
      }
      nodeoffset = 0;
      psVar12 = &local_b0;
      do {
        format = (char *)((int)local_a0 + nodeoffset);
        nodeoffset = nodeoffset + 1;
        *(char *)psVar12 = *format + *(char *)psVar12;
        psVar12 = (size_t *)((int)psVar12 + 1);
      } while (nodeoffset != 0xe);
      goto LAB_230398e8;
    }
    if (bVar2 < 0x47) {
      if (bVar2 != 0x42) {
LAB_23039042:
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] ASSERT: %s:%d\r\n",TVar3,&UNK_2307261c,"hal_board.c",0x1a6,
                  "hal_board.c",0x1a6);
        do {
                    // WARNING: Do nothing block with infinite loop
        } while( true );
      }
    }
    else {
      if (bVar2 != 0x62) {
        if (bVar2 != 0x66) goto LAB_23039042;
        goto LAB_2303949e;
      }
    }
    iVar9 = bl_efuse_read_pwroft((int8_t *)local_a0);
    if (iVar9 != 0) {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        uVar11 = 0x186;
        format = "[%10u][%s: %s:%4d] get pwr offset from B(b) failed\r\n";
LAB_230397ec:
        bl_printk(format,TVar3,"DEBUG ","hal_board.c",uVar11);
      }
      goto LAB_23039762;
    }
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
       (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] get pwr offset from B(b) ready\r\n",TVar3,&DAT_2306e4ac,
                "hal_board.c",0x175);
    }
    log_buf_out("hal_board.c",0x176,local_a0,0xe,LOG_BUF_OUT_DATA_TYPE_INT8);
    if (*pbVar14 == 0x42) goto LAB_230396a6;
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) &&
       (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO)) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] Use pwr offset from b in incremental mode\r\n",TVar3,"DEBUG ",
                "hal_board.c",0x180);
    }
    psVar12 = &local_b0;
    do {
      format = (char *)((int)local_a0 + iVar9);
      iVar9 = iVar9 + 1;
      *(char *)psVar12 = *format + *(char *)psVar12;
      psVar12 = (size_t *)((int)psVar12 + 1);
      iStack220 = iVar4;
    } while (iVar9 != 0xe);
LAB_23039762:
    iVar8 = iVar8 + 1;
    pbVar14 = pbVar14 + 1;
  } while (iVar8 != 2);
  if (((iStack220 == 0) && (_fsymc_level_hal_drv < BLOG_LEVEL_WARN)) &&
     (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    uVar11 = 0x1ac;
    pcVar10 = "\x1b[32mINFO  \x1b[0m";
    format = "[%10u][%s: %s:%4d] Using Default pwr offset\r\n";
    goto LAB_230396fa;
  }
LAB_230398e8:
  log_buf_out("hal_board.c",0x1ae,&local_b0,0xe,LOG_BUF_OUT_DATA_TYPE_INT8);
  ble_rf_set_pwr_offset(iStack170);
  phy_powroffset_set((int8_t *)&local_b0);
LAB_2303990c:
  local_b0 = 0;
  nodeoffset = fdt_subnode_offset((void *)ble_tx_power,parentoffset,"ap");
  if (0 < nodeoffset) {
    iVar4 = fdt_stringlist_count((void *)ble_tx_power,nodeoffset,"ssid");
    if ((iVar4 == 1) &&
       (format = fdt_stringlist_get((void *)ble_tx_power,nodeoffset,"ssid",0,(int *)&local_b0),
       local_b0 - 1 < 0x1f)) {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] ap_ssid string[%d] = %s, ap_ssid_len = %d\r\n",TVar3,
                  &DAT_2306e4ac,"hal_board.c",0x213,0,format,local_b0);
      }
      memcpy(local_a0,format,local_b0);
      *(undefined *)((int)local_a0 + local_b0) = 0;
      capin = (uint8_t)local_b0;
    }
    else {
      capin = '\0';
    }
    iVar4 = fdt_stringlist_count((void *)ble_tx_power,nodeoffset,"pwd");
    if ((iVar4 == 1) &&
       (format = fdt_stringlist_get((void *)ble_tx_power,nodeoffset,"pwd",0,(int *)&local_b0),
       local_b0 - 1 < 0x1f)) {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] ap_psk string[%d] = %s, ap_psk_len = %d\r\n",TVar3,
                  &DAT_2306e4ac,"hal_board.c",0x21e,0,format,local_b0);
      }
      memcpy(&local_80,format,local_b0);
      *(undefined *)((int)&local_80 + local_b0) = 0;
      psk_len = (uint8_t)local_b0;
    }
    else {
      psk_len = '\0';
    }
    pfVar15 = (fdt32_t *)fdt_getprop((void *)ble_tx_power,nodeoffset,"ap_channel",(int *)&local_b0);
    if (pfVar15 == (fdt32_t *)0x0) {
      chan = '\0';
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
         (chan = '\0', _fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] ap_channel NULL.\r\n",TVar3,&DAT_23078e4c,"hal_board.c",0x22b)
        ;
        chan = '\0';
      }
    }
    else {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        autoconnect = fdt32_to_cpu(*pfVar15);
        bl_printk("[%10u][%s: %s:%4d] ap_channel = %ld\r\n",TVar3,&DAT_2306e4ac,"hal_board.c",0x227,
                  autoconnect);
      }
      autoconnect = fdt32_to_cpu(*pfVar15);
      chan = (uint8_t)autoconnect;
    }
    bl_wifi_ap_info_set((uint8_t *)local_a0,capin,(uint8_t *)&local_80,psk_len,chan);
  }
  local_b0 = 0;
  parentoffset = fdt_subnode_offset((void *)ble_tx_power,parentoffset,"sta");
  if (0 < parentoffset) {
    nodeoffset = fdt_stringlist_count((void *)ble_tx_power,parentoffset,"ssid");
    if ((nodeoffset == 1) &&
       (format = fdt_stringlist_get((void *)ble_tx_power,parentoffset,"ssid",0,(int *)&local_b0),
       local_b0 - 1 < 0x1f)) {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] [STA] ap_ssid string[%d] = %s, ap_ssid_len = %d\r\n",TVar3,
                  &DAT_2306e4ac,"hal_board.c",0x1df,0,format,local_b0);
      }
      memcpy(local_a0,format,local_b0);
      *(undefined *)((int)local_a0 + local_b0) = 0;
      capin = (uint8_t)local_b0;
    }
    else {
      capin = '\0';
    }
    nodeoffset = fdt_stringlist_count((void *)ble_tx_power,parentoffset,"pwd");
    if ((nodeoffset == 1) &&
       (format = fdt_stringlist_get((void *)ble_tx_power,parentoffset,"pwd",0,(int *)&local_b0),
       local_b0 - 1 < 0x1f)) {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] [STA] ap_psk string[%d] = %s, ap_psk_len = %d\r\n",TVar3,
                  &DAT_2306e4ac,"hal_board.c",0x1ea,0,format,local_b0);
      }
      memcpy(&local_80,format,local_b0);
      *(undefined *)((int)&local_80 + local_b0) = 0;
      psk_len = (uint8_t)local_b0;
    }
    else {
      psk_len = '\0';
    }
    pfVar15 = (fdt32_t *)
              fdt_getprop((void *)ble_tx_power,parentoffset,"auto_connect_enable",(int *)&local_b0);
    autoconnect = 0;
    if (pfVar15 != (fdt32_t *)0x0) {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        autoconnect = fdt32_to_cpu(*pfVar15);
        bl_printk("[%10u][%s: %s:%4d] auto_connect_enable = %ld\r\n",TVar3,&DAT_2306e4ac,
                  "hal_board.c",0x1f2,autoconnect);
      }
      autoconnect = fdt32_to_cpu(*pfVar15);
    }
    bl_wifi_sta_info_set((uint8_t *)local_a0,capin,(uint8_t *)&local_80,psk_len,autoconnect);
  }
  parentoffset = fdt_subnode_offset((void *)ble_tx_power,0,"bluetooth");
  if (((parentoffset < 1) && (_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT)) &&
     (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] bt NULL.\r\n",TVar3,&DAT_23078e4c,"hal_board.c",0x2cd);
  }
  parentoffset = fdt_subnode_offset((void *)ble_tx_power,parentoffset,"brd_rf");
  if (0 < parentoffset) {
    pfVar15 = (fdt32_t *)fdt_getprop((void *)ble_tx_power,parentoffset,"pwr_table_ble",&iStack188);
    ble_tx_power = 0;
    if (pfVar15 != (fdt32_t *)0x0) {
      ble_tx_power = fdt32_to_cpu(*pfVar15);
    }
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
       (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
      if (TrapNetCounter == 0) {
        xTaskGetTickCount();
      }
      else {
        xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] set pwr_table_ble = %ld in dts\r\n",&DAT_2306e4ac,"hal_board.c",
                0x2d9,ble_tx_power);
    }
    ble_controller_set_tx_pwr(ble_tx_power);
  }
  return 0;
LAB_230396a6:
  do {
    *(undefined *)((int)&local_b0 + iVar9) = *(undefined *)((int)local_a0 + iVar9);
    iVar9 = iVar9 + 1;
  } while (iVar9 != 0xe);
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) && (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO))
  {
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    uVar11 = 0x17c;
    pcVar10 = "DEBUG ";
    format = "[%10u][%s: %s:%4d] Use pwr offset from B only\r\n";
LAB_230396fa:
    bl_printk(format,TVar3,pcVar10,"hal_board.c",uVar11);
  }
  goto LAB_230398e8;
}



// WARNING: Control flow encountered bad instruction data

void bl_tsen_adc_get(void)

{
                    // WARNING: Bad instruction - Truncating control flow here
  halt_baddata();
}



int hal_wifi_start_firmware_task(void)

{
  StackType_t wifi_fw_stack [1536];
  StaticTask_t wifi_fw_task;
  
  xTaskCreateStatic(wifi_main,"fw",0x600,(void *)0x0,0x1e,(StackType_t *)&ram0x420132b4,
                    (StaticTask_t *)&ram0x42014ab4);
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

int bl_gpio_enable_output(uint8_t pin,uint8_t pullup,uint8_t pulldown)

{
  undefined3 in_register_0000202d;
  undefined3 in_register_00002031;
  uint8_t uStack24;
  uint8_t uStack23;
  uint8_t uStack22;
  uint8_t uStack21;
  GLB_GPIO_Cfg_Type cfg;
  
  cfg._0_2_ = 0x100;
  uStack23 = '\v';
  uStack22 = '\x01';
  if (CONCAT31(in_register_0000202d,pullup) == 0) {
    uStack21 = '\x02';
  }
  else {
    uStack21 = '\0';
  }
  if (CONCAT31(in_register_00002031,pulldown) != 0) {
    uStack21 = '\x01';
  }
  uStack24 = pin;
  GLB_GPIO_Init((GLB_GPIO_Cfg_Type *)&uStack24);
  return 0;
}



int bl_gpio_output_set(uint8_t pin,uint8_t value)

{
  undefined3 in_register_0000202d;
  
  GLB_GPIO_Write(pin,(uint)(CONCAT31(in_register_0000202d,value) != 0));
  return 0;
}



void proc_entry_looprt(void *pvParameters)

{
  bloop_run(&looprt);
  do {
    puts("--->>> Error terminated looprt\r\n");
    vTaskDelay(1000);
  } while( true );
}



void looprt_evt_notify_async(uint task,uint32_t evt_map)

{
  bloop_evt_set_async(&looprt,task,evt_map);
  return;
}



void looprt_evt_status_dump(void)

{
  bloop_status_dump(&looprt);
  return;
}



int looprt_start(StackType_t *proc_stack_looprt,int stack_count,StaticTask_t *proc_task_looprt)

{
  bloop_init(&looprt);
  bloop_handler_register(&looprt,&bloop_handler_sys,0x1f);
  looprt_evt_status_dump();
  xTaskCreateStatic(proc_entry_looprt,"bloop_rt",stack_count,(void *)0x0,0x1a,proc_stack_looprt,
                    proc_task_looprt);
  bloop_wait_startup(&looprt);
  return 0;
}



int looprt_handler_register(loop_evt_handler *handler,int priority)

{
  int iVar1;
  
  if (looprt.looper != (TaskHandle_t)0x0) {
    iVar1 = bloop_handler_register(&looprt,handler,priority);
    return iVar1;
  }
  return -1;
}



int looprt_timer_register(loop_timer *timer)

{
  bloop_timer_register(&looprt,timer);
  return 0;
}



void _cb_led_trigger(loop_ctx *loop,loop_timer *timer,void *arg)

{
  TickType_t TVar1;
  undefined *puVar2;
  
  bl_gpio_output_set(*(uint8_t *)((int)arg + 0x30),*(int *)((int)arg + 0x38) != 0);
  if ((_fsymc_level_loopset < BLOG_LEVEL_INFO) &&
     (_fsymf_level_loopsetloopset_led < BLOG_LEVEL_INFO)) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    if (*(int *)((int)arg + 0x38) == 0) {
      puVar2 = &DAT_230799ec;
    }
    else {
      puVar2 = &DAT_230799e8;
    }
    bl_printk("[%10u][%s: %s:%4d] [LED] [CB] Set pin %d to %s\r\n",TVar1,"DEBUG ","loopset_led.c",
              0x95,*(undefined4 *)((int)arg + 0x30),puVar2);
  }
  *(uint *)((int)arg + 0x38) = (uint)(*(int *)((int)arg + 0x38) == 0);
  return;
}



int _led_bloop_msg(loop_ctx *loop,loop_evt_handler *handler,loop_msg *msg)

{
  TickType_t TVar1;
  
  if ((_fsymc_level_loopset < BLOG_LEVEL_INFO) &&
     (_fsymf_level_loopsetloopset_led < BLOG_LEVEL_INFO)) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk(
              "[%10u][%s: %s:%4d] [LED] [MSG] called with msg info\r\n    priority %u\r\n    dst %u\r\n    msgid %u\r\n    src %u\r\n    arg1 %p\r\n    arg2 %p\r\n"
              ,TVar1,"DEBUG ","loopset_led.c",0x78,(uint)*(byte *)&msg->u,
              (uint)*(byte *)((int)&msg->u + 1),(uint)*(byte *)((int)&msg->u + 2));
    return 0;
  }
  return 0;
}



int _led_bloop_evt(loop_ctx *loop,loop_evt_handler *handler,uint32_t *bitmap_evt,
                  uint32_t *evt_type_map)

{
  char **ppcVar1;
  uint uVar2;
  TickType_t TVar3;
  char *pcVar4;
  undefined *puVar5;
  char *pcVar6;
  char **ppcVar7;
  char **ppcVar8;
  
  uVar2 = *evt_type_map;
  do {
    if ((uVar2 & 1) == 0) {
      if ((uVar2 & 2) == 0) {
        if (uVar2 != 0) {
          printf("[ASSERT] [ERR] %s:%d\r\n","loopset_led.c",0x5e);
          do {
                    // WARNING: Do nothing block with infinite loop
          } while( true );
        }
        break;
      }
      pcVar6 = handler[1].name;
      ppcVar7 = (char **)0x0;
      ppcVar1 = *(char ***)(pcVar6 + 0xc);
      if (ppcVar1 != (char **)0x0) {
        ppcVar7 = (char **)ppcVar1[1];
      }
      while (ppcVar8 = ppcVar7, ppcVar1 != (char **)(pcVar6 + 8)) {
        if ((_fsymc_level_loopset < BLOG_LEVEL_WARN) &&
           (_fsymf_level_loopsetloopset_led < BLOG_LEVEL_WARN)) {
          if (TrapNetCounter == 0) {
            TVar3 = xTaskGetTickCount();
          }
          else {
            TVar3 = xTaskGetTickCountFromISR(loop);
          }
          puVar5 = &DAT_230799e8;
          if (ppcVar1[0xd] == (char *)0x0) {
            puVar5 = &DAT_230799ec;
          }
          pcVar4 = "Hearbeat";
          if (ppcVar1[0xb] == (char *)0x0) {
            pcVar4 = "Blink";
          }
          bl_printk("[%10u][%s: %s:%4d] [LED] New Trigger: PIN %d, active level %s, type %s\r\n",
                    TVar3,&DAT_2306e4ac,"loopset_led.c",0x4b,ppcVar1[0xc],puVar5,pcVar4);
        }
        loop = (loop_ctx *)looprt_timer_register((loop_timer *)(ppcVar1 + 2));
        ppcVar7 = (char **)ppcVar1[1];
        pcVar4 = *ppcVar1;
        *(char ***)(pcVar4 + 4) = ppcVar7;
        *ppcVar7 = pcVar4;
        ppcVar7 = *(char ***)(pcVar6 + 4);
        *ppcVar1 = pcVar6;
        *(char ***)(ppcVar1 + 1) = ppcVar7;
        *(char ***)(pcVar6 + 4) = ppcVar1;
        *(char ***)ppcVar7 = ppcVar1;
        ppcVar1 = ppcVar8;
        ppcVar7 = (char **)0x0;
        if (ppcVar8 != (char **)0x0) {
          ppcVar7 = (char **)ppcVar8[1];
        }
      }
      uVar2 = uVar2 & 0xfffffffd;
    }
    else {
      uVar2 = uVar2 & 0xfffffffe;
    }
  } while (uVar2 != 0);
  *evt_type_map = 0;
  return 0;
}



int loopset_led_hook_on_looprt(void)

{
  loop_evt_handler_holder _led_bloop_handler_holder;
  int iVar1;
  
  led_ctx.trigger_queue.next = &led_ctx;
  led_ctx.trigger_queue.prev = &led_ctx;
  led_ctx.waiting_queue.next = (utils_dlist_s *)&led_ctx.waiting_queue;
  led_ctx.waiting_queue.prev = (utils_dlist_s *)&led_ctx.waiting_queue;
  iVar1 = looprt_handler_register((loop_evt_handler *)(loop_evt_handler_holder *)&ram0x2307aa38,1);
  return iVar1;
}



void loopset_led_trigger(int pin,uint timeon_ms)

{
  utils_dlist_s **ppuVar1;
  loop_timer *timer;
  utils_dlist_s *__s;
  TickType_t TVar2;
  
  __s = (utils_dlist_s *)pvPortMalloc(0x3c);
  if (__s == (utils_dlist_s *)0x0) {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] ASSERT: %s:%d\r\n",TVar2,&UNK_2307261c,"loopset_led.c",0x9e,
              "loopset_led.c",0x9e);
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  memset(__s,0,0x3c);
  timer = (loop_timer *)(__s + 1);
  *(int *)&__s[6].prev = pin;
  bloop_timer_init(timer,0);
  bloop_timer_repeat_enable(timer);
  bloop_timer_configure(timer,timeon_ms,_cb_led_trigger,__s,1,1);
  bl_gpio_enable_output((uint8_t)pin,'\0','\0');
  vTaskEnterCritical();
  __s->prev = (utils_dlist_s *)0x42014fbc;
  __s->next = led_ctx.waiting_queue.next;
  ppuVar1 = &(led_ctx.waiting_queue.next)->prev;
  led_ctx.waiting_queue.next = __s;
  *ppuVar1 = __s;
  vTaskExitCritical();
  looprt_evt_notify_async(1,2);
  return;
}



err_t netifapi_do_netif_add(tcpip_api_call_data *m)

{
  err_t eVar1;
  netif *pnVar2;
  
  pnVar2 = netif_add(*(netif **)(m + 1),(ip4_addr_t *)m[1].sem,*(ip4_addr_t **)(m + 2),
                     (ip4_addr_t *)m[2].sem,*(void **)(m + 3),(netif_init_fn_conflict *)m[3].sem,
                     *(netif_input_fn **)(m + 4));
  if (pnVar2 == (netif *)0x0) {
    eVar1 = -0xc;
  }
  else {
    eVar1 = '\0';
  }
  return eVar1;
}



err_t netifapi_do_netif_set_addr(tcpip_api_call_data *m)

{
  netif_set_addr(*(netif **)(m + 1),(ip4_addr_t *)m[1].sem,*(ip4_addr_t **)(m + 2),
                 (ip4_addr_t *)m[2].sem);
  return '\0';
}



err_t netifapi_do_netif_common(tcpip_api_call_data *m)

{
  err_t eVar1;
  
  if (*(code **)(m + 2) != (code *)0x0) {
                    // WARNING: Could not recover jumptable at 0x2303a45c. Too many branches
                    // WARNING: Treating indirect jump as call
    eVar1 = (**(code **)(m + 2))();
    return eVar1;
  }
  (*(code *)m[1].sem)(*(undefined4 *)(m + 1),m[1].sem);
  return '\0';
}



// WARNING: Could not reconcile some variable overlaps

err_t netifapi_netif_add(netif *netif,ip4_addr_t *ipaddr,ip4_addr_t *netmask,ip4_addr_t *gw,
                        void *state,netif_init_fn init,netif_input_fn *input)

{
  err_t eVar1;
  undefined auStack52 [4];
  netifapi_msg msg;
  
  if (ipaddr == (ip4_addr_t *)0x0) {
    ipaddr = (ip4_addr_t *)&ip_addr_any;
  }
  if (netmask == (ip4_addr_t *)0x0) {
    netmask = (ip4_addr_t *)&ip_addr_any;
  }
  if (gw == (ip4_addr_t *)0x0) {
    gw = (ip4_addr_t *)&ip_addr_any;
  }
  msg.call.sem = (sys_sem_t)netif;
  msg.netif = (netif *)ipaddr;
  msg.msg._0_4_ = netmask;
  msg.msg._4_4_ = gw;
  msg.msg._8_4_ = state;
  msg.msg._12_4_ = init;
  msg.msg._16_4_ = input;
  eVar1 = tcpip_api_call(netifapi_do_netif_add,(tcpip_api_call_data *)auStack52);
  return eVar1;
}



// WARNING: Could not reconcile some variable overlaps

err_t netifapi_netif_set_addr(netif *netif,ip4_addr_t *ipaddr,ip4_addr_t *netmask,ip4_addr_t *gw)

{
  err_t eVar1;
  undefined auStack52 [4];
  netifapi_msg msg;
  
  if (ipaddr == (ip4_addr_t *)0x0) {
    ipaddr = (ip4_addr_t *)&ip_addr_any;
  }
  if (netmask == (ip4_addr_t *)0x0) {
    netmask = (ip4_addr_t *)&ip_addr_any;
  }
  if (gw == (ip4_addr_t *)0x0) {
    gw = (ip4_addr_t *)&ip_addr_any;
  }
  msg.call.sem = (sys_sem_t)netif;
  msg.netif = (netif *)ipaddr;
  msg.msg._0_4_ = netmask;
  msg.msg._4_4_ = gw;
  eVar1 = tcpip_api_call(netifapi_do_netif_set_addr,(tcpip_api_call_data *)auStack52);
  return eVar1;
}



// WARNING: Could not reconcile some variable overlaps

err_t netifapi_netif_common(netif *netif,netifapi_void_fn voidfunc,netifapi_errt_fn errtfunc)

{
  err_t eVar1;
  undefined auStack52 [4];
  netifapi_msg msg;
  
  msg.call.sem = (sys_sem_t)netif;
  msg.netif = (netif *)voidfunc;
  msg.msg._0_4_ = errtfunc;
  eVar1 = tcpip_api_call(netifapi_do_netif_common,(tcpip_api_call_data *)auStack52);
  return eVar1;
}



void tcpip_thread(void *arg)

{
  byte *mem;
  undefined uVar1;
  memp_t type;
  u32_t timeout;
  int iVar2;
  undefined *puVar3;
  byte *pbStack36;
  tcpip_msg *msg;
  
  if (tcpip_init_done != (tcpip_init_done_fn)0x0) {
    (*tcpip_init_done)(tcpip_init_done_arg);
  }
switchD_2303a564_caseD_5:
  do {
    while (timeout = sys_timeouts_sleeptime(), timeout != 0xffffffff) {
      if ((timeout != 0) &&
         (timeout = sys_arch_mbox_fetch(&tcpip_mbox,&pbStack36,timeout), timeout != 0xffffffff))
      goto LAB_2303a552;
      sys_check_timeouts();
    }
    sys_arch_mbox_fetch(&tcpip_mbox,&pbStack36,0);
LAB_2303a552:
    mem = pbStack36;
  } while (pbStack36 == (byte *)0x0);
  switch(*pbStack36) {
  case 0:
  case 4:
    (**(code **)(pbStack36 + 4))(*(undefined4 *)(pbStack36 + 8),*(code **)(pbStack36 + 4));
    goto switchD_2303a564_caseD_5;
  case 1:
    puVar3 = *(undefined **)(pbStack36 + 8);
    uVar1 = (**(code **)(pbStack36 + 4))(puVar3,*(code **)(pbStack36 + 4));
    *puVar3 = uVar1;
    sys_sem_signal((sys_mutex_t *)*(sys_mutex_t *)(mem + 0xc));
    goto switchD_2303a564_caseD_5;
  case 2:
    iVar2 = (**(code **)(pbStack36 + 0xc))
                      (*(undefined4 *)(pbStack36 + 4),*(undefined4 *)(pbStack36 + 8),
                       *(code **)(pbStack36 + 0xc));
    if (iVar2 != 0) {
      pbuf_free(*(pbuf **)(mem + 4));
    }
    type = MEMP_TCPIP_MSG_INPKT;
    break;
  case 3:
    (**(code **)(pbStack36 + 4))(*(undefined4 *)(pbStack36 + 8),*(code **)(pbStack36 + 4));
    type = MEMP_TCPIP_MSG_API;
    break;
  default:
    goto switchD_2303a564_caseD_5;
  }
  memp_free(type,mem);
  goto switchD_2303a564_caseD_5;
}



err_t tcpip_inpkt(pbuf *p,netif *inp,netif_input_fn *input_fn)

{
  err_t eVar1;
  undefined *msg;
  undefined3 extraout_var;
  
  sys_mbox_valid(&tcpip_mbox);
  msg = (undefined *)memp_malloc(MEMP_TCPIP_MSG_INPKT);
  if (msg == (undefined *)0x0) {
    printf("[LWIP] NO TCP MSG\r\n");
  }
  else {
    *(netif **)(msg + 8) = inp;
    *msg = 2;
    *(pbuf **)(msg + 4) = p;
    *(netif_input_fn **)(msg + 0xc) = input_fn;
    eVar1 = sys_mbox_trypost(&tcpip_mbox,msg);
    if (CONCAT31(extraout_var,eVar1) == 0) {
      return eVar1;
    }
    printf("[LWIP] NO MBOX\r\n");
    memp_free(MEMP_TCPIP_MSG_INPKT,msg);
  }
  return -1;
}



err_t tcpip_input(pbuf *p,netif *inp)

{
  err_t eVar1;
  code *input_fn;
  
  if ((inp->flags & 0x18) == 0) {
    input_fn = ip4_input;
  }
  else {
    input_fn = ethernet_input;
  }
  eVar1 = tcpip_inpkt(p,inp,input_fn);
  return eVar1;
}



err_t tcpip_try_callback(tcpip_callback_fn function,void *ctx)

{
  err_t eVar1;
  undefined *msg;
  undefined3 extraout_var;
  
  sys_mbox_valid(&tcpip_mbox);
  msg = (undefined *)memp_malloc(MEMP_TCPIP_MSG_API);
  if (msg != (undefined *)0x0) {
    *(void **)(msg + 8) = ctx;
    *msg = 3;
    *(tcpip_callback_fn *)(msg + 4) = function;
    eVar1 = sys_mbox_trypost(&tcpip_mbox,msg);
    if (CONCAT31(extraout_var,eVar1) == 0) {
      return eVar1;
    }
    memp_free(MEMP_TCPIP_MSG_API,msg);
  }
  return -1;
}



// WARNING: Could not reconcile some variable overlaps

err_t tcpip_api_call(tcpip_api_call_fn *fn,tcpip_api_call_data *call)

{
  sys_sem_t *sem;
  err_t eVar1;
  undefined3 extraout_var;
  undefined local_30 [4];
  tcpip_msg msg;
  
  sem = &call->sem;
  eVar1 = sys_sem_new(sem,'\0');
  if (CONCAT31(extraout_var,eVar1) == 0) {
    sys_mbox_valid(&tcpip_mbox);
    local_30[0] = 1;
    msg._0_4_ = fn;
    msg.msg._0_4_ = call;
    msg.msg._4_4_ = sem;
    sys_mbox_post(&tcpip_mbox,local_30);
    sys_arch_sem_wait(msg.msg._4_4_,0);
    sys_sem_free(sem);
    eVar1 = call->err;
  }
  return eVar1;
}



void tcpip_init(tcpip_init_done_fn initfunc,void *arg)

{
  lwip_init();
  tcpip_init_done = initfunc;
  tcpip_init_done_arg = arg;
  sys_mbox_new(&tcpip_mbox,0x32);
  sys_thread_new("TCP/IP",tcpip_thread,(void *)0x0,4000,0x1e);
  return;
}



u16_t lwip_htons(u16_t n)

{
  undefined2 in_register_0000202a;
  
  return (u16_t)((ushort)(CONCAT22(in_register_0000202a,n) >> 8) | n << 8);
}



u32_t lwip_htonl(u32_t n)

{
  return n >> 8 & 0xff00 | n << 0x18 | n >> 0x18 | (n & 0xff00) << 8;
}



void dns_call_found(u8_t idx,ip_addr_t *addr)

{
  undefined3 in_register_00002029;
  int iVar1;
  
  iVar1 = CONCAT31(in_register_00002029,idx);
  if (dns_requests[iVar1].found != (dns_found_callback *)0x0) {
    (*dns_requests[iVar1].found)(dns_table[iVar1].name,addr,dns_requests[iVar1].arg);
  }
  dns_requests[iVar1].found = (dns_found_callback *)0x0;
  return;
}



// WARNING: Variable defined which should be unmapped: hdr

err_t dns_send(u8_t idx)

{
  u8_t *dataptr;
  u8_t *puVar1;
  err_t eVar2;
  undefined3 in_register_00002029;
  int iVar3;
  size_t sVar4;
  pbuf *buf;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  undefined4 local_40;
  dns_query qry;
  dns_hdr hdr;
  
  iVar3 = CONCAT31(in_register_00002029,idx);
  if (dns_servers[dns_table[iVar3].server_idx].addr == 0) {
    dns_call_found(idx,(ip_addr_t *)0x0);
    eVar2 = '\0';
    dns_table[iVar3].state = '\0';
  }
  else {
    sVar4 = strlen(dns_table[iVar3].name);
    buf = pbuf_alloc(PBUF_TRANSPORT,(u16_t)((sVar4 + 0x12) * 0x10000 >> 0x10),PBUF_RAM);
    eVar2 = -1;
    if (buf != (pbuf *)0x0) {
      memset(&qry,0,0xc);
      qry.type = lwip_htons(dns_table[iVar3].txid);
      qry.cls._0_1_ = 1;
      puVar1 = &dns_table[iVar3].seqno;
      pbuf_take(buf,&qry,0xc);
      uVar6 = 0xc;
      do {
        dataptr = puVar1 + 1;
        uVar5 = 0;
        puVar1 = dataptr;
        while ((*puVar1 != '.' && (*puVar1 != '\0'))) {
          uVar5 = uVar5 + 1 & 0xff;
          puVar1 = puVar1 + 1;
        }
        if (0xfffe < uVar6 + uVar5) {
          pbuf_free(buf);
          return -6;
        }
        pbuf_put_at(buf,(u16_t)uVar6,(u8_t)uVar5);
        pbuf_take_at(buf,dataptr,(u16_t)((uint)((int)(puVar1 + -(int)dataptr) * 0x10000) >> 0x10),
                     (u16_t)((uVar6 + 1) * 0x10000 >> 0x10));
        uVar7 = uVar6 + uVar5 & 0xffff;
        uVar5 = uVar7 + 1;
        uVar6 = uVar5 & 0xffff;
      } while (*puVar1 != '\0');
      pbuf_put_at(buf,(u16_t)(uVar5 * 0x10000 >> 0x10),'\0');
      local_40 = 0x1000100;
      pbuf_take_at(buf,&local_40,4,(u16_t)((uVar7 + 2) * 0x10000 >> 0x10));
      eVar2 = udp_sendto(dns_pcbs,buf,dns_servers + dns_table[iVar3].server_idx,0x35);
      pbuf_free(buf);
    }
  }
  return eVar2;
}



void dns_check_entry(u8_t i)

{
  undefined3 in_register_00002029;
  int iVar1;
  u8_t uVar2;
  u16_t uVar3;
  uint uVar4;
  uint uVar5;
  u32_t uVar6;
  dns_table_entry_conflict *pdVar7;
  
  iVar1 = CONCAT31(in_register_00002029,i);
  uVar2 = dns_table[iVar1].state;
  if (uVar2 != '\x02') {
    if (uVar2 != '\x03') {
      if (uVar2 != '\x01') {
        return;
      }
      uVar4 = (uint)dns_txid;
      do {
        uVar5 = uVar4 + 1;
        uVar4 = uVar5 & 0xffff;
        pdVar7 = dns_table;
        while ((pdVar7->state != '\x02' || ((uint)pdVar7->txid != uVar4))) {
          pdVar7 = pdVar7 + 1;
          if (pdVar7 == (dns_table_entry_conflict *)arp_table) {
            uVar3 = (u16_t)(uVar5 * 0x10000 >> 0x10);
            dns_txid = uVar3;
            *(undefined2 *)&dns_table[iVar1].state = 2;
            dns_table[iVar1].txid = uVar3;
            *(undefined2 *)&dns_table[iVar1].tmr = 1;
            goto LAB_2303a9e4;
          }
        }
      } while( true );
    }
    uVar6 = dns_table[iVar1].ttl;
    if ((uVar6 != 0) && (uVar6 = uVar6 - 1, dns_table[iVar1].ttl = uVar6, uVar6 != 0)) {
      return;
    }
LAB_2303aa40:
    dns_table[iVar1].state = '\0';
    return;
  }
  uVar2 = dns_table[iVar1].tmr + -1;
  dns_table[iVar1].tmr = uVar2;
  if (uVar2 != '\0') {
    return;
  }
  uVar2 = dns_table[iVar1].retries + '\x01';
  dns_table[iVar1].retries = uVar2;
  if (uVar2 == '\x04') {
    if ((dns_table[iVar1].server_idx != '\0') || (dns_servers[1] == 0)) {
      dns_call_found(i,(ip_addr_t *)0x0);
      goto LAB_2303aa40;
    }
    dns_table[iVar1].server_idx = '\x01';
    *(undefined2 *)&dns_table[iVar1].tmr = 1;
  }
  else {
    dns_table[iVar1].tmr = uVar2;
  }
LAB_2303a9e4:
  dns_send(i);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void dns_recv(void *arg,udp_pcb *pcb,pbuf *p,ip_addr_t *addr,u16_t port)

{
  u8_t i;
  uint uVar1;
  u16_t uVar2;
  u16_t uVar3;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  undefined2 extraout_var_02;
  uint uVar4;
  int iVar5;
  undefined2 extraout_var_03;
  uint uVar6;
  undefined2 extraout_var_04;
  undefined2 extraout_var_05;
  u32_t uVar7;
  undefined2 extraout_var_06;
  dns_table_entry_conflict *pdVar8;
  byte *pbVar9;
  int iVar10;
  uint uVar11;
  byte *pbVar12;
  short sStack96;
  short sStack94;
  dns_query qry;
  ip4_addr_t ip4addr;
  dns_hdr hdr;
  dns_answer ans;
  
  if (0xf < p->tot_len) {
    uVar2 = pbuf_copy_partial(p,&ip4addr,0xc,0);
    uVar1 = CONCAT22(extraout_var,uVar2);
    if (uVar1 == 0xc) {
      iVar10 = 0;
      uVar2 = lwip_htons((u16_t)ip4addr.addr);
      pdVar8 = dns_table;
      do {
        i = (u8_t)iVar10;
        if ((pdVar8->state == '\x02') && ((uint)pdVar8->txid == CONCAT22(extraout_var_00,uVar2))) {
          uVar2 = lwip_htons(hdr.id);
          uVar3 = lwip_htons(hdr._2_2_);
          uVar11 = CONCAT22(extraout_var_02,uVar3);
          if ((ip4addr.addr._2_1_ < '\0') &&
             ((CONCAT22(extraout_var_01,uVar2) == 1 &&
              (addr->addr == dns_servers[dns_table[iVar10].server_idx].addr)))) {
            pbVar12 = (byte *)dns_table[iVar10].name;
            goto LAB_2303ab38;
          }
          break;
        }
        iVar10 = iVar10 + 1;
        pdVar8 = pdVar8 + 1;
      } while (iVar10 != 4);
    }
  }
  goto ignore_packet;
  while( true ) {
    pbVar9 = pbVar12 + uVar4;
    while( true ) {
      uVar1 = uVar1 + 1 & 0xffff;
      if (pbVar12 == pbVar9) break;
      uVar4 = pbuf_try_get_at(p,(u16_t)uVar1);
      if ((int)uVar4 < 0) goto ignore_packet;
      uVar6 = (uint)*pbVar12;
      if ((_ctype_[uVar6 + 1] & 3) == 1) {
        uVar6 = uVar6 + 0x20;
      }
      uVar4 = uVar4 & 0xff;
      if ((_ctype_[uVar4 + 1] & 3) == 1) {
        uVar4 = uVar4 + 0x20;
      }
      if ((uVar6 != uVar4) || (uVar1 == 0xffff)) goto ignore_packet;
      pbVar12 = pbVar12 + 1;
    }
    pbVar12 = pbVar12 + 1;
    iVar5 = pbuf_try_get_at(p,(u16_t)uVar1);
    if (iVar5 < 0) goto ignore_packet;
    if (iVar5 == 0) break;
LAB_2303ab38:
    uVar4 = pbuf_try_get_at(p,(u16_t)uVar1);
    if ((((int)uVar4 < 0) || (uVar1 == 0xffff)) || ((uVar4 & 0xc0) == 0xc0)) goto ignore_packet;
  }
  if (uVar1 != 0xffff) {
    uVar4 = uVar1 + 1 & 0xffff;
    if (((uVar4 != 0xffff) &&
        (uVar2 = pbuf_copy_partial(p,&sStack96,4,(u16_t)((uVar1 + 1) * 0x10000 >> 0x10)),
        CONCAT22(extraout_var_03,uVar2) == 4)) &&
       ((sStack94 == 0x100 && ((sStack96 == 0x100 && (uVar4 < 0xfffc)))))) {
      if ((ip4addr.addr._3_1_ & 0xf) == 0) {
        uVar1 = uVar1 + 5;
        while ((uVar1 = uVar1 & 0xffff, uVar11 != 0 && (uVar1 < p->tot_len))) {
          do {
            uVar4 = uVar1 + 1 & 0xffff;
            uVar6 = pbuf_try_get_at(p,(u16_t)uVar1);
            if (((int)uVar6 < 0) || (uVar4 == 0)) goto ignore_packet;
            if ((uVar6 & 0xc0) == 0xc0) break;
            uVar6 = uVar6 + uVar4;
            if ((int)(uint)p->tot_len <= (int)uVar6) goto ignore_packet;
            uVar1 = uVar6 & 0xffff;
            iVar5 = pbuf_try_get_at(p,(u16_t)(uVar6 * 0x10000 >> 0x10));
            if (iVar5 < 0) goto ignore_packet;
            uVar4 = uVar1;
          } while (iVar5 != 0);
          if (uVar4 == 0xffff) goto ignore_packet;
          uVar1 = uVar4 + 1 & 0xffff;
          if (((uVar1 == 0xffff) ||
              (uVar2 = pbuf_copy_partial(p,&hdr.numauthrr,10,(u16_t)((uVar4 + 1) * 0x10000 >> 0x10))
              , CONCAT22(extraout_var_04,uVar2) != 10)) || (0xfff5 < uVar1)) goto ignore_packet;
          uVar1 = uVar4 + 0xb & 0xffff;
          if (((hdr.numextrarr == 0x100) && (hdr.numauthrr == 0x100)) && ((u16_t)ans.ttl == 0x400))
          {
            uVar2 = pbuf_copy_partial(p,&qry,4,(u16_t)((uVar4 + 0xb) * 0x10000 >> 0x10));
            if (CONCAT22(extraout_var_05,uVar2) == 4) {
              *(dns_query *)&dns_table[iVar10].ipaddr = qry;
              pbuf_free(p);
              uVar7 = lwip_htonl(ans._0_4_);
              dns_table[iVar10].state = '\x03';
              if (uVar7 < 0x93a81) {
                dns_table[iVar10].ttl = uVar7;
              }
              else {
                dns_table[iVar10].ttl = 0x93a80;
              }
              dns_call_found(i,&dns_table[iVar10].ipaddr);
              if (dns_table[iVar10].ttl != 0) {
                return;
              }
              if (dns_table[iVar10].state != '\x03') {
                return;
              }
              dns_table[iVar10].state = '\0';
              return;
            }
            goto ignore_packet;
          }
          uVar2 = lwip_htons((u16_t)ans.ttl);
          if (0xffff < (int)(CONCAT22(extraout_var_06,uVar2) + uVar1)) goto ignore_packet;
          uVar2 = lwip_htons((u16_t)ans.ttl);
          uVar1 = uVar2 + uVar1;
          uVar11 = uVar11 - 1 & 0xffff;
        }
      }
      else {
        if ((dns_table[iVar10].server_idx == '\0') && (dns_servers[1] != 0)) {
          *(undefined2 *)&dns_table[iVar10].tmr = 0x301;
          dns_check_entry(i);
          goto ignore_packet;
        }
      }
      pbuf_free(p);
      dns_call_found(i,(ip_addr_t *)0x0);
      dns_table[iVar10].state = '\0';
      return;
    }
  }
ignore_packet:
  pbuf_free(p);
  return;
}



void dns_init(void)

{
  if (dns_pcbs == (udp_pcb *)0x0) {
    dns_pcbs = udp_new_ip_type();
    udp_bind(dns_pcbs,&ip_addr_any,0);
    udp_recv(dns_pcbs,dns_recv,(void *)0x0);
    return;
  }
  return;
}



void dns_setserver(u8_t numdns,ip_addr_t *dnsserver)

{
  undefined3 in_register_00002029;
  u32_t uVar1;
  
  if (CONCAT31(in_register_00002029,numdns) < 2) {
    if (dnsserver == (ip_addr_t *)0x0) {
      uVar1 = 0;
    }
    else {
      uVar1 = dnsserver->addr;
    }
    dns_servers[CONCAT31(in_register_00002029,numdns)].addr = uVar1;
  }
  return;
}



ip_addr_t * dns_getserver(u8_t numdns)

{
  undefined3 in_register_00002029;
  
  if (CONCAT31(in_register_00002029,numdns) < 2) {
    return dns_servers + CONCAT31(in_register_00002029,numdns);
  }
  return &ip_addr_any;
}



void dns_tmr(void)

{
  dns_check_entry('\0');
  dns_check_entry('\x01');
  dns_check_entry('\x02');
  dns_check_entry('\x03');
  return;
}



void lwip_init(void)

{
  stats_init();
  sys_init();
  mem_init();
  memp_init();
  netif_init();
  udp_init();
  tcp_init();
  igmp_init();
  dns_init();
  sys_timeouts_init();
  return;
}



void dhcp_set_state(dhcp *dhcp,u8_t new_state)

{
  undefined3 in_register_0000202d;
  
  if ((uint)dhcp->state != CONCAT31(in_register_0000202d,new_state)) {
    dhcp->state = new_state;
    dhcp->tries = '\0';
    dhcp->request_timeout = 0;
  }
  return;
}



u16_t dhcp_option_short(u16_t options_out_len,u8_t *options,u16_t value)

{
  undefined2 in_register_0000202a;
  int iVar1;
  
  iVar1 = CONCAT22(in_register_0000202a,options_out_len);
  options[iVar1] = (u8_t)(value >> 8);
  options[iVar1 + 1U & 0xffff] = (u8_t)value;
  return (u16_t)((uint)((iVar1 + 2) * 0x10000) >> 0x10);
}



u16_t dhcp_option_long(u16_t options_out_len,u8_t *options,u32_t value)

{
  undefined2 in_register_0000202a;
  int iVar1;
  
  iVar1 = CONCAT22(in_register_0000202a,options_out_len);
  options[iVar1] = (u8_t)(value >> 0x18);
  options[iVar1 + 1U & 0xffff] = (u8_t)(value >> 0x10);
  options[iVar1 + 2U & 0xffff] = (u8_t)(value >> 8);
  options[iVar1 + 3U & 0xffff] = (u8_t)value;
  return (u16_t)((uint)((iVar1 + 4) * 0x10000) >> 0x10);
}



pbuf * dhcp_create_msg(netif *netif,dhcp *dhcp,u8_t message_type,u16_t *options_out_len)

{
  u8_t uVar1;
  u32_t xid;
  undefined *__s;
  u32_t uVar2;
  undefined3 in_register_00002031;
  int iVar3;
  u8_t *puVar4;
  u8_t *puVar5;
  pbuf *ppVar6;
  
  iVar3 = CONCAT31(in_register_00002031,message_type);
  if (((netif == (netif *)0x0) || (dhcp == (dhcp *)0x0)) ||
     (ppVar6 = pbuf_alloc(PBUF_TRANSPORT,0x134,PBUF_RAM), ppVar6 == (pbuf *)0x0)) {
    ppVar6 = (pbuf *)0x0;
  }
  else {
    if ((iVar3 != 3) || (dhcp->state == '\x03')) {
      if (dhcp->tries == '\0') {
        xid = bl_rand();
      }
      dhcp->xid = xid;
    }
    __s = (undefined *)ppVar6->payload;
    memset(__s,0,0x134);
    *__s = 1;
    __s[1] = 1;
    __s[2] = netif->hwaddr_len;
    uVar2 = lwip_htonl(dhcp->xid);
    __s[4] = (char)uVar2;
    __s[5] = (char)(uVar2 >> 8);
    __s[6] = (char)(uVar2 >> 0x10);
    __s[7] = (char)(uVar2 >> 0x18);
    if (((iVar3 == 4) || ((iVar3 - 7U & 0xff) < 2)) ||
       ((iVar3 == 3 && ((byte)(dhcp->state - 4) < 2)))) {
      uVar2 = (netif->ip_addr).addr;
      __s[0xc] = (char)uVar2;
      __s[0xd] = (char)(uVar2 >> 8);
      __s[0xe] = (char)(uVar2 >> 0x10);
      __s[0xf] = (char)(uVar2 >> 0x18);
    }
    puVar5 = netif->hwaddr;
    puVar4 = __s + 0x1c;
    do {
      uVar1 = *puVar5;
      puVar5 = puVar5 + 1;
      *puVar4 = uVar1;
      puVar4 = puVar4 + 1;
    } while (puVar5 != &netif->hwaddr_len);
    __s[0xec] = 99;
    __s[0xef] = 99;
    __s[0xed] = 0x82;
    __s[0xf0] = 0x35;
    __s[0xf1] = 1;
    __s[0xee] = 0x53;
    __s[0xf2] = message_type;
    *options_out_len = 3;
  }
  return ppVar6;
}



void dhcp_option_trailer(u16_t options_out_len,u8_t *options,pbuf *p_out)

{
  undefined2 in_register_0000202a;
  uint uVar1;
  
  uVar1 = CONCAT22(in_register_0000202a,options_out_len) + 1U & 0xffff;
  options[CONCAT22(in_register_0000202a,options_out_len)] = -1;
  options = options + uVar1;
  while (uVar1 < 0x44) {
    *options = '\0';
    uVar1 = uVar1 + 1 & 0xffff;
    options = options + 1;
  }
  pbuf_realloc(p_out,(u16_t)((uVar1 + 0xf0) * 0x10000 >> 0x10));
  return;
}



err_t dhcp_discover(netif *netif)

{
  u8_t *options;
  dhcp *dhcp;
  pbuf *p_out;
  undefined2 extraout_var;
  uint uVar1;
  int iVar2;
  u16_t auStack34 [2];
  u16_t options_out_len;
  
  dhcp = (dhcp *)netif->client_data[0];
  (dhcp->offered_ip_addr).addr = 0;
  dhcp_set_state(dhcp,'\x06');
  p_out = dhcp_create_msg(netif,dhcp,'\x01',auStack34);
  if (p_out != (pbuf *)0x0) {
    uVar1 = (uint)auStack34[0];
    options = (u8_t *)((int)p_out->payload + 0xf0);
    options[uVar1] = '9';
    options[uVar1 + 1 & 0xffff] = '\x02';
    auStack34[0] = (u16_t)((uVar1 + 2) * 0x10000 >> 0x10);
    auStack34[0] = dhcp_option_short(auStack34[0],options,netif->mtu);
    options[CONCAT22(extraout_var,auStack34[0])] = '7';
    options[CONCAT22(extraout_var,auStack34[0]) + 1U & 0xffff] = '\x04';
    auStack34[0] = auStack34[0] + 2;
    iVar2 = 0;
    do {
      options[(uint)auStack34[0]] = "\x01\x03\x1c\x06"[iVar2];
      auStack34[0] = (u16_t)(((uint)auStack34[0] + 1) * 0x10000 >> 0x10);
      iVar2 = iVar2 + 1;
    } while (iVar2 != 4);
    dhcp_option_trailer(auStack34[0],options,p_out);
    udp_sendto_if_src(dhcp_pcb,p_out,&ip_addr_broadcast,0x43,netif,&ip_addr_any);
    pbuf_free(p_out);
  }
  if (dhcp->tries != -1) {
    dhcp->tries = dhcp->tries + '\x01';
  }
  if (dhcp->tries < 6) {
    uVar1 = (uint)((1 << ((uint)dhcp->tries & 0x1f)) * 0x3e80000) >> 0x10;
  }
  else {
    uVar1 = 60000;
  }
  dhcp->request_timeout = (u16_t)((int)(uVar1 + 499) / 500);
  return '\0';
}



void dhcp_check(netif *netif)

{
  dhcp *dhcp;
  
  dhcp = (dhcp *)netif->client_data[0];
  dhcp_set_state(dhcp,'\b');
  etharp_query(netif,&dhcp->offered_ip_addr,(pbuf *)0x0);
  if (dhcp->tries != -1) {
    dhcp->tries = dhcp->tries + '\x01';
  }
  dhcp->request_timeout = 1;
  return;
}



// WARNING: Type propagation algorithm not settling

void dhcp_bind(netif *netif)

{
  byte bVar1;
  dhcp *dhcp;
  u16_t uVar2;
  uint uVar3;
  int iVar4;
  ip4_addr_t iStack24;
  ip4_addr_t sn_mask;
  ip4_addr_t gw_addr;
  
  if (netif == (netif *)0x0) {
    return;
  }
  dhcp = (dhcp *)netif->client_data[0];
  if (dhcp == (dhcp *)0x0) {
    return;
  }
  dhcp->lease_used = 0;
  if (dhcp->offered_t0_lease != 0xffffffff) {
    uVar3 = dhcp->offered_t0_lease + 0x1e;
    if (uVar3 < 0x3c0000) {
      uVar3 = uVar3 / 0x3c;
      uVar2 = (u16_t)uVar3;
      if (uVar3 == 0) {
        dhcp->t0_timeout = 1;
        goto LAB_2303b27c;
      }
    }
    else {
      uVar2 = 0xffff;
    }
    dhcp->t0_timeout = uVar2;
  }
LAB_2303b27c:
  if (dhcp->offered_t1_renew != 0xffffffff) {
    uVar3 = dhcp->offered_t1_renew + 0x1e;
    if (uVar3 < 0x3c0000) {
      uVar3 = uVar3 / 0x3c;
      uVar2 = (u16_t)uVar3;
      if (uVar3 != 0) goto LAB_2303b29e;
      dhcp->t1_timeout = 1;
    }
    else {
      uVar2 = 0xffff;
LAB_2303b29e:
      dhcp->t1_timeout = uVar2;
    }
    dhcp->t1_renew_time = dhcp->t1_timeout;
  }
  if (dhcp->offered_t2_rebind == 0xffffffff) goto LAB_2303b2d8;
  uVar3 = dhcp->offered_t2_rebind + 0x1e;
  if (uVar3 < 0x3c0000) {
    uVar3 = uVar3 / 0x3c;
    uVar2 = (u16_t)uVar3;
    if (uVar3 != 0) goto LAB_2303b2cc;
    dhcp->t2_timeout = 1;
  }
  else {
    uVar2 = 0xffff;
LAB_2303b2cc:
    dhcp->t2_timeout = uVar2;
  }
  dhcp->t2_rebind_time = dhcp->t2_timeout;
LAB_2303b2d8:
  if ((dhcp->t2_timeout <= dhcp->t1_timeout) && (dhcp->t2_timeout != 0)) {
    dhcp->t1_timeout = 0;
  }
  if (dhcp->subnet_mask_given == '\0') {
    bVar1 = *(byte *)&(dhcp->offered_ip_addr).addr;
    if ((char)bVar1 < '\0') {
      if (bVar1 < 0xc0) {
        iVar4 = 0x10000;
      }
      else {
        iVar4 = 0x1000000;
      }
      iStack24 = (ip4_addr_t)(iVar4 - 1);
    }
    else {
      iStack24 = (ip4_addr_t)0xff;
    }
  }
  else {
    iStack24 = (ip4_addr_t)(dhcp->offered_sn_mask).addr;
  }
  sn_mask = (dhcp->offered_gw_addr).addr;
  if ((ip4_addr_t)sn_mask == (ip4_addr_t)0x0) {
    sn_mask = (dhcp->offered_ip_addr).addr & (uint)iStack24 | 0x1000000;
  }
  dhcp_set_state(dhcp,'\n');
  netif_set_addr(netif,&dhcp->offered_ip_addr,&iStack24,&sn_mask);
  return;
}



err_t dhcp_inc_pcb_refcount(void)

{
  udp_pcb *pcb;
  
  if (dhcp_pcb_refcount == '\0') {
    pcb = udp_new();
    if (pcb == (udp_pcb *)0x0) {
      dhcp_pcb = pcb;
      return -1;
    }
    dhcp_pcb = pcb;
    pcb->so_options = pcb->so_options | 0x20;
    udp_bind(pcb,&ip_addr_any,0x44);
    udp_connect(dhcp_pcb,&ip_addr_any,0x43);
    udp_recv(dhcp_pcb,dhcp_recv,(void *)0x0);
  }
  dhcp_pcb_refcount = dhcp_pcb_refcount + '\x01';
  return '\0';
}



u16_t dhcp_option_hostname(u16_t options_out_len,u8_t *options)

{
  undefined2 in_register_0000202a;
  int iVar1;
  size_t sVar2;
  u8_t **in_a2;
  u8_t *puVar3;
  u8_t *puVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  
  iVar1 = CONCAT22(in_register_0000202a,options_out_len);
  if ((*in_a2 != (u8_t *)0x0) && (sVar2 = strlen((char *)*in_a2), sVar2 != 0)) {
    puVar3 = *in_a2;
    uVar6 = 0x41U - iVar1;
    if (sVar2 < 0x41U - iVar1) {
      uVar6 = sVar2;
    }
    options[iVar1] = '\f';
    uVar5 = iVar1 + 2U & 0xffff;
    options[iVar1 + 1U & 0xffff] = (u8_t)uVar6;
    puVar4 = puVar3;
    uVar7 = uVar5;
    while (puVar4 != puVar3 + uVar6) {
      options[uVar7] = *puVar4;
      uVar7 = uVar7 + 1 & 0xffff;
      puVar4 = puVar4 + 1;
    }
    options_out_len = (short)uVar5 + (short)uVar6;
  }
  return options_out_len;
}



err_t dhcp_reboot(netif *netif)

{
  u8_t *options;
  dhcp *dhcp;
  err_t eVar1;
  u16_t options_out_len_00;
  pbuf *p_out;
  undefined2 extraout_var;
  u32_t value;
  undefined2 extraout_var_00;
  uint uVar2;
  int iVar3;
  u16_t auStack34 [2];
  u16_t options_out_len;
  
  dhcp = (dhcp *)netif->client_data[0];
  dhcp_set_state(dhcp,'\x03');
  p_out = dhcp_create_msg(netif,dhcp,'\x03',auStack34);
  eVar1 = -1;
  if (p_out != (pbuf *)0x0) {
    uVar2 = (uint)auStack34[0];
    options = (u8_t *)((int)p_out->payload + 0xf0);
    options[uVar2] = '9';
    options[uVar2 + 1 & 0xffff] = '\x02';
    auStack34[0] = (u16_t)((uVar2 + 2) * 0x10000 >> 0x10);
    options_out_len_00 = dhcp_option_short(auStack34[0],options,0x240);
    iVar3 = CONCAT22(extraout_var,options_out_len_00);
    options[iVar3] = '2';
    options[iVar3 + 1U & 0xffff] = '\x04';
    options_out_len_00 = (u16_t)((uint)((iVar3 + 2) * 0x10000) >> 0x10);
    auStack34[0] = options_out_len_00;
    value = lwip_htonl((dhcp->offered_ip_addr).addr);
    auStack34[0] = dhcp_option_long(options_out_len_00,options,value);
    options[CONCAT22(extraout_var_00,auStack34[0])] = '7';
    options[CONCAT22(extraout_var_00,auStack34[0]) + 1U & 0xffff] = '\x04';
    auStack34[0] = auStack34[0] + 2;
    iVar3 = 0;
    do {
      options[(uint)auStack34[0]] = "\x01\x03\x1c\x06"[iVar3];
      auStack34[0] = (u16_t)(((uint)auStack34[0] + 1) * 0x10000 >> 0x10);
      iVar3 = iVar3 + 1;
    } while (iVar3 != 4);
    auStack34[0] = dhcp_option_hostname(auStack34[0],options);
    dhcp_option_trailer(auStack34[0],options,p_out);
    eVar1 = udp_sendto_if(dhcp_pcb,p_out,&ip_addr_broadcast,0x43,netif);
    pbuf_free(p_out);
  }
  if (dhcp->tries != -1) {
    dhcp->tries = dhcp->tries + '\x01';
  }
  if (dhcp->tries < 10) {
    uVar2 = (uint)dhcp->tries * 0x3e80000 >> 0x10;
  }
  else {
    uVar2 = 10000;
  }
  dhcp->request_timeout = (u16_t)((int)(uVar2 + 499) / 500);
  return eVar1;
}



err_t dhcp_select(netif *netif)

{
  u8_t *options;
  dhcp *dhcp;
  err_t eVar1;
  u16_t options_out_len_00;
  pbuf *p_out;
  undefined2 extraout_var;
  u32_t value;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  uint uVar2;
  int iVar3;
  u16_t auStack34 [2];
  u16_t options_out_len;
  
  eVar1 = -0x10;
  if (netif != (netif *)0x0) {
    dhcp = (dhcp *)netif->client_data[0];
    eVar1 = -6;
    if (dhcp != (dhcp *)0x0) {
      dhcp_set_state(dhcp,'\x01');
      p_out = dhcp_create_msg(netif,dhcp,'\x03',auStack34);
      eVar1 = -1;
      if (p_out != (pbuf *)0x0) {
        uVar2 = (uint)auStack34[0];
        options = (u8_t *)((int)p_out->payload + 0xf0);
        options[uVar2] = '9';
        options[uVar2 + 1 & 0xffff] = '\x02';
        auStack34[0] = (u16_t)((uVar2 + 2) * 0x10000 >> 0x10);
        options_out_len_00 = dhcp_option_short(auStack34[0],options,netif->mtu);
        iVar3 = CONCAT22(extraout_var,options_out_len_00);
        options[iVar3] = '2';
        options[iVar3 + 1U & 0xffff] = '\x04';
        options_out_len_00 = (u16_t)((uint)((iVar3 + 2) * 0x10000) >> 0x10);
        auStack34[0] = options_out_len_00;
        value = lwip_htonl((dhcp->offered_ip_addr).addr);
        options_out_len_00 = dhcp_option_long(options_out_len_00,options,value);
        iVar3 = CONCAT22(extraout_var_00,options_out_len_00);
        options[iVar3] = '6';
        options[iVar3 + 1U & 0xffff] = '\x04';
        options_out_len_00 = (u16_t)((uint)((iVar3 + 2) * 0x10000) >> 0x10);
        auStack34[0] = options_out_len_00;
        value = lwip_htonl((dhcp->server_ip_addr).addr);
        auStack34[0] = dhcp_option_long(options_out_len_00,options,value);
        options[CONCAT22(extraout_var_01,auStack34[0])] = '7';
        options[CONCAT22(extraout_var_01,auStack34[0]) + 1U & 0xffff] = '\x04';
        auStack34[0] = auStack34[0] + 2;
        iVar3 = 0;
        do {
          options[(uint)auStack34[0]] = "\x01\x03\x1c\x06"[iVar3];
          auStack34[0] = (u16_t)(((uint)auStack34[0] + 1) * 0x10000 >> 0x10);
          iVar3 = iVar3 + 1;
        } while (iVar3 != 4);
        auStack34[0] = dhcp_option_hostname(auStack34[0],options);
        dhcp_option_trailer(auStack34[0],options,p_out);
        eVar1 = udp_sendto_if_src(dhcp_pcb,p_out,&ip_addr_broadcast,0x43,netif,&ip_addr_any);
        pbuf_free(p_out);
      }
      if (dhcp->tries != -1) {
        dhcp->tries = dhcp->tries + '\x01';
      }
      if (dhcp->tries < 6) {
        uVar2 = (uint)((1 << ((uint)dhcp->tries & 0x1f)) * 0x3e80000) >> 0x10;
      }
      else {
        uVar2 = 60000;
      }
      dhcp->request_timeout = (u16_t)((int)(uVar2 + 499) / 500);
    }
  }
  return eVar1;
}



void dhcp_dec_pcb_refcount(void)

{
  dhcp_pcb_refcount = dhcp_pcb_refcount + -1;
  if (dhcp_pcb_refcount == '\0') {
    udp_remove(dhcp_pcb);
    dhcp_pcb = (udp_pcb *)0x0;
    return;
  }
  return;
}



void dhcp_handle_ack(dhcp_msg *msg_in)

{
  u8_t uVar1;
  u32_t uVar2;
  int in_a1;
  uint uVar3;
  ip_addr_t iStack20;
  ip_addr_t dns_addr;
  
  uVar1 = dhcp_rx_options_given[3];
  *(undefined4 *)(msg_in->chaddr + 4) = 0;
  *(undefined4 *)(msg_in->chaddr + 8) = 0;
  if (uVar1 != '\0') {
    *(u32_t *)(msg_in->chaddr + 0xc) = dhcp_rx_options_val[3];
  }
  uVar3 = dhcp_rx_options_val[4];
  if (dhcp_rx_options_given[4] == '\0') {
    uVar3 = *(uint *)(msg_in->chaddr + 0xc) >> 1;
  }
  *(uint *)msg_in->sname = uVar3;
  uVar3 = dhcp_rx_options_val[5];
  if (dhcp_rx_options_given[5] == '\0') {
    uVar3 = (uint)(*(int *)(msg_in->chaddr + 0xc) * 7) >> 3;
  }
  *(uint *)(msg_in->sname + 4) = uVar3;
  *(undefined4 *)msg_in->chaddr = *(undefined4 *)(in_a1 + 0x10);
  if (dhcp_rx_options_given[6] == '\0') {
    *(undefined *)((int)&msg_in->xid + 3) = 0;
  }
  else {
    uVar2 = lwip_htonl(dhcp_rx_options_val[6]);
    *(u32_t *)(msg_in->chaddr + 4) = uVar2;
    *(undefined *)((int)&msg_in->xid + 3) = 1;
  }
  if (dhcp_rx_options_given[7] != '\0') {
    uVar2 = lwip_htonl(dhcp_rx_options_val[7]);
    *(u32_t *)(msg_in->chaddr + 8) = uVar2;
  }
  if (dhcp_rx_options_given[8] != '\0') {
    iStack20 = (ip_addr_t)lwip_htonl(dhcp_rx_options_val[8]);
    dns_setserver('\0',&iStack20);
    if (dhcp_rx_options_given[9] != '\0') {
      iStack20 = (ip_addr_t)lwip_htonl(dhcp_rx_options_val[9]);
      dns_setserver('\x01',&iStack20);
    }
  }
  return;
}



void dhcp_recv(void *arg,udp_pcb *pcb,pbuf *p,ip_addr_t *addr,u16_t port)

{
  byte bVar1;
  byte bVar2;
  bool bVar3;
  pbuf **pppVar4;
  netif *netif;
  uint uVar5;
  void *pvVar6;
  u16_t uVar7;
  u32_t uVar8;
  undefined2 extraout_var;
  void *pvVar9;
  uint uVar10;
  char *pcVar11;
  uint uVar12;
  u8_t *puVar13;
  u32_t *puVar14;
  pbuf *buf;
  uint uVar15;
  uint uVar16;
  int iVar17;
  uint uVar18;
  void *pvStack96;
  u32_t uStack68;
  u32_t value;
  
  netif = ip_data.current_input_netif;
  puVar14 = (u32_t *)(ip_data.current_input_netif)->client_data[0];
  if ((((puVar14 != (u32_t *)0x0) && (*(char *)(puVar14 + 1) != '\0')) && (0x2b < p->len)) &&
     (pcVar11 = (char *)p->payload, *pcVar11 == '\x02')) {
    uVar16 = 0;
    do {
      if (((uint)(ip_data.current_input_netif)->hwaddr_len <= (uVar16 & 0xff)) || (uVar16 == 6)) {
        uVar8 = lwip_htonl(*(u32_t *)(pcVar11 + 4));
        if ((uVar8 == *puVar14) && (memset(dhcp_rx_options_given,0,10), 0x2b < p->len)) {
          uVar16 = (uint)p->tot_len;
          bVar3 = false;
          uVar18 = 0xf0;
          buf = p;
          goto LAB_2303b9b2;
        }
        break;
      }
      puVar13 = (ip_data.current_input_netif)->hwaddr + uVar16;
      iVar17 = uVar16 + 0x1c;
      uVar16 = uVar16 + 1;
    } while (pcVar11[iVar17] == *puVar13);
  }
free_pbuf_and_return:
  pbuf_free(p);
  return;
LAB_2303b9b2:
  do {
    uVar12 = (uint)buf->len;
    if (uVar18 < uVar12) {
      pvStack96 = buf->payload;
      uVar12 = uVar18;
LAB_2303bbf4:
      if (uVar16 <= uVar12) goto LAB_2303bc0a;
      bVar2 = *(byte *)((int)pvStack96 + uVar12);
      if (bVar2 == 0xff) goto LAB_2303bc0a;
      uVar15 = uVar12 + 2 & 0xffff;
      if (uVar15 < uVar12) break;
      if (uVar12 + 1 < (uint)buf->len) {
        bVar1 = ((byte *)((int)pvStack96 + uVar12))[1];
LAB_2303ba48:
        uVar10 = (uint)bVar1;
        if (bVar2 == 0x33) {
          if (bVar1 != 4) break;
          uVar5 = 4;
          iVar17 = 3;
        }
        else {
          if (bVar2 < 0x34) {
            if (bVar2 == 1) {
              if (bVar1 == 4) {
                uVar5 = 4;
                iVar17 = 6;
                goto LAB_2303bace;
              }
              break;
            }
            if (bVar2 == 0) goto LAB_2303bbba;
            if (bVar2 != 3) goto LAB_2303ba66;
            if (uVar10 <= bVar2) break;
            iVar17 = 7;
            uVar5 = 4;
          }
          else {
            if (bVar2 == 0x36) {
LAB_2303bba0:
              if (uVar10 != 4) break;
              uVar5 = 4;
              iVar17 = 2;
            }
            else {
              if (bVar2 < 0x37) {
                if (bVar2 == 0x34) goto LAB_2303bb8a;
LAB_2303ba98:
                if (bVar2 == 0x35) {
                  if (uVar10 != 1) break;
                  uVar5 = 1;
                  iVar17 = 1;
                }
                else {
LAB_2303ba6a:
                  iVar17 = -1;
                  uVar5 = 0;
                }
              }
              else {
                if (bVar2 == 0x3a) goto LAB_2303bbae;
LAB_2303bab4:
                if (bVar2 != 0x3b) goto LAB_2303ba6a;
                if (uVar10 != 4) break;
                uVar5 = 4;
                iVar17 = 5;
              }
            }
          }
        }
      }
      else {
        if (buf->next != (pbuf *)0x0) {
          bVar1 = *(byte *)buf->next->payload;
          goto LAB_2303ba48;
        }
        if (bVar2 == 0x33) break;
        if (bVar2 < 0x34) {
          if (bVar2 == 1) break;
          if (bVar2 != 0) {
            if (bVar2 != 3) {
              uVar10 = 0;
LAB_2303ba66:
              if (bVar2 != 6) goto LAB_2303ba6a;
              if ((uVar10 & 3) == 0) {
                uVar5 = uVar10;
                if (8 < uVar10) {
                  uVar5 = 8;
                }
                if (uVar5 <= uVar10) {
                  iVar17 = 8;
                  goto LAB_2303bace;
                }
              }
            }
            break;
          }
LAB_2303bbba:
          uVar12 = uVar12 + 1 & 0xffff;
          goto LAB_2303bbc2;
        }
        if (bVar2 == 0x36) {
          uVar10 = 0;
          goto LAB_2303bba0;
        }
        if (bVar2 < 0x37) {
          if (bVar2 != 0x34) {
            uVar10 = 0;
            goto LAB_2303ba98;
          }
          uVar10 = 0;
LAB_2303bb8a:
          if ((uVar10 != 1) || (uVar18 != 0xf0)) break;
          uVar5 = 1;
          iVar17 = 0;
        }
        else {
          if (bVar2 != 0x3a) {
            uVar10 = 0;
            goto LAB_2303bab4;
          }
          uVar10 = 0;
LAB_2303bbae:
          if (uVar10 != 4) break;
          uVar5 = 4;
          iVar17 = 4;
        }
      }
LAB_2303bace:
      if (0xfffd < uVar10 + uVar12) break;
      uVar12 = uVar10 + uVar15 & 0xffff;
      if (uVar5 != 0) {
        uStack68 = 0;
        puVar13 = dhcp_rx_options_given + iVar17;
        while (*puVar13 == '\0') {
          uVar10 = uVar5;
          if (4 < uVar5) {
            uVar10 = 4;
          }
          uVar7 = pbuf_copy_partial(buf,&uStack68,(u16_t)uVar10,(u16_t)uVar15);
          if (uVar10 != CONCAT22(extraout_var,uVar7)) goto free_pbuf_and_return;
          if (uVar5 < 5) {
            if (uVar5 == 4) {
              uStack68 = lwip_htonl(uStack68);
            }
            else {
              if (uVar5 != 1) goto free_pbuf_and_return;
              uStack68 = uStack68 & 0xff;
            }
            dhcp_rx_options_given[iVar17] = '\x01';
            dhcp_rx_options_val[iVar17] = uStack68;
            break;
          }
          if ((uVar5 & 3) != 0) goto free_pbuf_and_return;
          *puVar13 = '\x01';
          uVar8 = lwip_htonl(uStack68);
          dhcp_rx_options_val[iVar17] = uVar8;
          uVar10 = uVar15 + 4 & 0xffff;
          uVar5 = uVar5 - 4 & 0xff;
          puVar13 = puVar13 + 1;
          if (uVar10 < uVar15) goto free_pbuf_and_return;
          iVar17 = iVar17 + 1;
          uVar15 = uVar10;
        }
      }
LAB_2303bbc2:
      uVar15 = (uint)buf->len;
      if (uVar15 <= uVar12) {
        uVar12 = uVar12 - uVar15 & 0xffff;
        uVar16 = uVar16 - uVar15 & 0xffff;
        if ((uVar16 <= uVar12) || (buf = buf->next, buf == (pbuf *)0x0)) break;
        pvStack96 = buf->payload;
      }
      goto LAB_2303bbf4;
    }
    pppVar4 = &buf->next;
    uVar18 = uVar18 - uVar12 & 0xffff;
    uVar16 = uVar16 - uVar12 & 0xffff;
    buf = *pppVar4;
  } while (*pppVar4 != (pbuf *)0x0);
  goto free_pbuf_and_return;
LAB_2303bc0a:
  if (dhcp_rx_options_given[0] != '\0') {
    dhcp_rx_options_given[0] = '\0';
    if (dhcp_rx_options_val[0] == 1) {
LAB_2303bcbe:
      uVar16 = 0xec;
      uVar18 = 0x6c;
      buf = p;
      goto LAB_2303b9b2;
    }
    if (dhcp_rx_options_val[0] == 2) goto LAB_2303bca8;
    if (dhcp_rx_options_val[0] == 3) {
      bVar3 = true;
      goto LAB_2303bcbe;
    }
  }
  if (!bVar3) {
    if (dhcp_rx_options_given[1] == '\0') goto free_pbuf_and_return;
    pvVar9 = p->payload;
    if ((char)dhcp_rx_options_val[1] != '\x05') {
      if ((char)dhcp_rx_options_val[1] == '\x06') {
        if (((byte)(*(char *)((int)puVar14 + 5) - 3U) < 3) ||
           (*(char *)((int)puVar14 + 5) == '\x01')) {
          dhcp_set_state((dhcp *)netif->client_data[0],'\f');
          netif_set_addr(netif,(ip4_addr_t *)&ip_addr_any,(ip4_addr_t *)&ip_addr_any,
                         (ip4_addr_t *)&ip_addr_any);
          dhcp_discover(netif);
        }
      }
      else {
        if ((((char)dhcp_rx_options_val[1] == '\x02') && (*(char *)((int)puVar14 + 5) == '\x06')) &&
           (dhcp_rx_options_given[2] != '\0')) {
          pvVar6 = netif->client_data[0];
          *(undefined2 *)((int)pvVar6 + 8) = 0;
          uVar8 = lwip_htonl(dhcp_rx_options_val[2]);
          *(u32_t *)((int)pvVar6 + 0x18) = uVar8;
          *(undefined4 *)((int)pvVar6 + 0x1c) = *(undefined4 *)((int)pvVar9 + 0x10);
          dhcp_select(netif);
        }
      }
      goto free_pbuf_and_return;
    }
    if (*(char *)((int)puVar14 + 5) == '\x01') {
      dhcp_handle_ack((dhcp_msg *)netif->client_data[0]);
      if ((netif->flags & 8) != 0) {
        dhcp_check(netif);
        goto free_pbuf_and_return;
      }
    }
    else {
      if (2 < (byte)(*(char *)((int)puVar14 + 5) - 3U)) goto free_pbuf_and_return;
      dhcp_handle_ack((dhcp_msg *)netif->client_data[0]);
    }
    dhcp_bind(netif);
    goto free_pbuf_and_return;
  }
LAB_2303bca8:
  bVar3 = false;
  uVar16 = 0x6c;
  uVar18 = 0x2c;
  buf = p;
  goto LAB_2303b9b2;
}



void dhcp_network_changed(netif *netif)

{
  byte bVar1;
  void *pvVar2;
  
  pvVar2 = netif->client_data[0];
  if (pvVar2 == (void *)0x0) {
    return;
  }
  bVar1 = *(byte *)((int)pvVar2 + 5);
  if (bVar1 < 6) {
    if (2 < bVar1) {
LAB_2303bdee:
      *(undefined *)((int)pvVar2 + 6) = 0;
      dhcp_reboot(netif);
      return;
    }
    if (bVar1 == 0) {
      return;
    }
  }
  else {
    if (bVar1 == 10) goto LAB_2303bdee;
  }
  *(undefined *)((int)pvVar2 + 6) = 0;
  dhcp_discover(netif);
  return;
}



void dhcp_arp_reply(netif *netif,ip4_addr_t *addr)

{
  dhcp *dhcp;
  u8_t *options;
  pbuf *p_out;
  u32_t value;
  uint uVar1;
  u16_t options_out_len_00;
  u16_t auStack34 [2];
  u16_t options_out_len;
  
  if (netif != (netif *)0x0) {
    dhcp = (dhcp *)netif->client_data[0];
    if (((dhcp != (dhcp *)0x0) && (dhcp->state == '\b')) &&
       (addr->addr == (dhcp->offered_ip_addr).addr)) {
      dhcp_set_state(dhcp,'\f');
      p_out = dhcp_create_msg(netif,dhcp,'\x04',auStack34);
      if (p_out != (pbuf *)0x0) {
        uVar1 = (uint)auStack34[0];
        options = (u8_t *)((int)p_out->payload + 0xf0);
        options[uVar1] = '2';
        options[uVar1 + 1 & 0xffff] = '\x04';
        options_out_len_00 = (u16_t)((uVar1 + 2) * 0x10000 >> 0x10);
        auStack34[0] = options_out_len_00;
        value = lwip_htonl((dhcp->offered_ip_addr).addr);
        auStack34[0] = dhcp_option_long(options_out_len_00,options,value);
        dhcp_option_trailer(auStack34[0],options,p_out);
        udp_sendto_if_src(dhcp_pcb,p_out,&ip_addr_broadcast,0x43,netif,&ip_addr_any);
        pbuf_free(p_out);
      }
      if (dhcp->tries != -1) {
        dhcp->tries = dhcp->tries + '\x01';
      }
      dhcp->request_timeout = 0x14;
    }
    return;
  }
  return;
}



err_t dhcp_renew(netif *netif)

{
  u8_t *options;
  dhcp *dhcp;
  err_t eVar1;
  pbuf *p_out;
  undefined2 extraout_var;
  uint uVar2;
  int iVar3;
  u16_t auStack34 [2];
  u16_t options_out_len;
  
  dhcp = (dhcp *)netif->client_data[0];
  dhcp_set_state(dhcp,'\x05');
  p_out = dhcp_create_msg(netif,dhcp,'\x03',auStack34);
  eVar1 = -1;
  if (p_out != (pbuf *)0x0) {
    uVar2 = (uint)auStack34[0];
    options = (u8_t *)((int)p_out->payload + 0xf0);
    options[uVar2] = '9';
    options[uVar2 + 1 & 0xffff] = '\x02';
    auStack34[0] = (u16_t)((uVar2 + 2) * 0x10000 >> 0x10);
    auStack34[0] = dhcp_option_short(auStack34[0],options,netif->mtu);
    options[CONCAT22(extraout_var,auStack34[0])] = '7';
    options[CONCAT22(extraout_var,auStack34[0]) + 1U & 0xffff] = '\x04';
    auStack34[0] = auStack34[0] + 2;
    iVar3 = 0;
    do {
      options[(uint)auStack34[0]] = "\x01\x03\x1c\x06"[iVar3];
      auStack34[0] = (u16_t)(((uint)auStack34[0] + 1) * 0x10000 >> 0x10);
      iVar3 = iVar3 + 1;
    } while (iVar3 != 4);
    auStack34[0] = dhcp_option_hostname(auStack34[0],options);
    dhcp_option_trailer(auStack34[0],options,p_out);
    eVar1 = udp_sendto_if(dhcp_pcb,p_out,&dhcp->server_ip_addr,0x43,netif);
    pbuf_free(p_out);
  }
  if (dhcp->tries != -1) {
    dhcp->tries = dhcp->tries + '\x01';
  }
  if (dhcp->tries < 10) {
    uVar2 = (uint)dhcp->tries * 0x7d00000 >> 0x10;
  }
  else {
    uVar2 = 20000;
  }
  dhcp->request_timeout = (u16_t)((int)(uVar2 + 499) / 500);
  return eVar1;
}



u8_t dhcp_supplied_address(netif *netif)

{
  byte bVar1;
  bool bVar2;
  
  if ((netif != (netif *)0x0) && (netif->client_data[0] != (void *)0x0)) {
    bVar1 = *(byte *)((int)netif->client_data[0] + 5);
    bVar2 = true;
    if (bVar1 != 10) {
      bVar2 = (uint)bVar1 - 4 < 2;
    }
    return (u8_t)bVar2;
  }
  return '\0';
}



// WARNING: Type propagation algorithm not settling
// WARNING: Could not reconcile some variable overlaps

void dhcp_release_and_stop(netif *netif)

{
  dhcp *dhcp;
  u8_t uVar1;
  undefined3 extraout_var;
  pbuf *p_out;
  u32_t value;
  uint uVar2;
  u8_t *options;
  u16_t options_out_len_00;
  u16_t uStack38;
  u16_t options_out_len;
  ip_addr_t n;
  ip_addr_t server_ip_addr;
  
  dhcp = (dhcp *)netif->client_data[0];
  if ((dhcp != (dhcp *)0x0) && (dhcp->state != '\0')) {
    n = (ip_addr_t)(dhcp->server_ip_addr).addr;
    (dhcp->offered_ip_addr).addr = 0;
    (dhcp->server_ip_addr).addr = 0;
    (dhcp->offered_sn_mask).addr = 0;
    (dhcp->offered_gw_addr).addr = 0;
    dhcp->offered_t2_rebind = 0;
    dhcp->offered_t1_renew = 0;
    dhcp->offered_t0_lease = 0;
    dhcp->t1_renew_time = 0;
    *(undefined4 *)&dhcp->t2_rebind_time = 0;
    dhcp->t0_timeout = 0;
    uVar1 = dhcp_supplied_address(netif);
    if ((CONCAT31(extraout_var,uVar1) != 0) &&
       (p_out = dhcp_create_msg(netif,dhcp,'\a',&uStack38), p_out != (pbuf *)0x0)) {
      uVar2 = (uint)uStack38;
      options = (u8_t *)((int)p_out->payload + 0xf0);
      options[uVar2] = '6';
      options[uVar2 + 1 & 0xffff] = '\x04';
      options_out_len_00 = (u16_t)((uVar2 + 2) * 0x10000 >> 0x10);
      uStack38 = options_out_len_00;
      value = lwip_htonl((u32_t)n);
      uStack38 = dhcp_option_long(options_out_len_00,options,value);
      dhcp_option_trailer(uStack38,options,p_out);
      udp_sendto_if(dhcp_pcb,p_out,(ip_addr_t *)&stack0xffffffdc,0x43,netif);
      pbuf_free(p_out);
    }
    netif_set_addr(netif,(ip4_addr_t *)&ip_addr_any,(ip4_addr_t *)&ip_addr_any,
                   (ip4_addr_t *)&ip_addr_any);
    dhcp_set_state(dhcp,'\0');
    if (dhcp->pcb_allocated != '\0') {
      dhcp_dec_pcb_refcount();
      dhcp->pcb_allocated = '\0';
    }
  }
  return;
}



err_t dhcp_start(netif *netif)

{
  err_t eVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  dhcp *dhcp;
  
  if (netif == (netif *)0x0) {
    return -0x10;
  }
  if ((netif->flags & 1) == 0) {
    return -0x10;
  }
  dhcp = (dhcp *)netif->client_data[0];
  if (0x23f < netif->mtu) {
    if (dhcp == (dhcp *)0x0) {
      dhcp = (dhcp *)mem_malloc(0x34);
      if (dhcp == (dhcp *)0x0) {
        return -1;
      }
      *(dhcp **)netif->client_data = dhcp;
    }
    else {
      if (dhcp->pcb_allocated != '\0') {
        dhcp_dec_pcb_refcount();
      }
    }
    memset(dhcp,0,0x34);
    eVar1 = dhcp_inc_pcb_refcount();
    if (CONCAT31(extraout_var,eVar1) == 0) {
      dhcp->pcb_allocated = '\x01';
      if ((netif->flags & 4) == 0) {
        dhcp_set_state(dhcp,'\x02');
        return eVar1;
      }
      eVar1 = dhcp_discover(netif);
      if (CONCAT31(extraout_var_00,eVar1) == 0) {
        return eVar1;
      }
      dhcp_release_and_stop(netif);
    }
  }
  return -1;
}



void dhcp_coarse_tmr(void)

{
  short sVar1;
  netif *netif;
  dhcp *dhcp;
  pbuf *p_out;
  undefined2 extraout_var;
  uint uVar2;
  void *pvVar3;
  int iVar4;
  u8_t *options;
  u16_t auStack50 [2];
  u16_t options_out_len;
  
  netif = netif_list;
  while (netif != (netif *)0x0) {
    pvVar3 = netif->client_data[0];
    if ((pvVar3 != (void *)0x0) && (*(char *)((int)pvVar3 + 5) != '\0')) {
      if ((*(ushort *)((int)pvVar3 + 0x14) == 0) ||
         (uVar2 = (uint)*(ushort *)((int)pvVar3 + 0x12) + 1,
         *(undefined2 *)((int)pvVar3 + 0x12) = (short)(uVar2 * 0x10000 >> 0x10),
         (uint)*(ushort *)((int)pvVar3 + 0x14) != (uVar2 & 0xffff))) {
        sVar1 = *(short *)((int)pvVar3 + 0x10);
        if ((sVar1 == 0) || (*(short *)((int)pvVar3 + 0x10) = sVar1 + -1, sVar1 != 1)) {
          sVar1 = *(short *)((int)pvVar3 + 0xe);
          if ((sVar1 != 0) && (*(short *)((int)pvVar3 + 0xe) = sVar1 + -1, sVar1 == 1)) {
            pvVar3 = netif->client_data[0];
            if (((*(byte *)((int)pvVar3 + 5) & 0xfb) == 1) || (*(byte *)((int)pvVar3 + 5) == 10)) {
              dhcp_renew(netif);
              iVar4 = (uint)*(ushort *)((int)pvVar3 + 0xc) - (uint)*(ushort *)((int)pvVar3 + 0x12);
              if (1 < iVar4) {
                *(undefined2 *)((int)pvVar3 + 0xe) = (short)(iVar4 >> 1);
              }
            }
          }
        }
        else {
          dhcp = (dhcp *)netif->client_data[0];
          if ((dhcp->state < 0xb) && ((0x432U >> ((uint)dhcp->state & 0x1f) & 1) != 0)) {
            dhcp_set_state(dhcp,'\x04');
            p_out = dhcp_create_msg(netif,dhcp,'\x03',auStack50);
            if (p_out != (pbuf *)0x0) {
              uVar2 = (uint)auStack50[0];
              options = (u8_t *)((int)p_out->payload + 0xf0);
              options[uVar2] = '9';
              options[uVar2 + 1 & 0xffff] = '\x02';
              auStack50[0] = (u16_t)((uVar2 + 2) * 0x10000 >> 0x10);
              auStack50[0] = dhcp_option_short(auStack50[0],options,netif->mtu);
              options[CONCAT22(extraout_var,auStack50[0])] = '7';
              options[CONCAT22(extraout_var,auStack50[0]) + 1U & 0xffff] = '\x04';
              auStack50[0] = auStack50[0] + 2;
              iVar4 = 0;
              do {
                options[(uint)auStack50[0]] = "\x01\x03\x1c\x06"[iVar4];
                auStack50[0] = (u16_t)(((uint)auStack50[0] + 1) * 0x10000 >> 0x10);
                iVar4 = iVar4 + 1;
              } while (iVar4 != 4);
              auStack50[0] = dhcp_option_hostname(auStack50[0],options);
              dhcp_option_trailer(auStack50[0],options,p_out);
              udp_sendto_if(dhcp_pcb,p_out,&ip_addr_broadcast,0x43,netif);
              pbuf_free(p_out);
            }
            if (dhcp->tries != -1) {
              dhcp->tries = dhcp->tries + '\x01';
            }
            uVar2 = 10000;
            if (dhcp->tries < 10) {
              uVar2 = (uint)dhcp->tries * 0x3e80000 >> 0x10;
            }
            dhcp->request_timeout = (u16_t)((int)(uVar2 + 499) / 500);
            iVar4 = (uint)dhcp->t0_timeout - (uint)dhcp->lease_used;
            if (1 < iVar4) {
              dhcp->t2_rebind_time = (u16_t)(iVar4 >> 1);
            }
          }
        }
      }
      else {
        dhcp_release_and_stop(netif);
        dhcp_start(netif);
      }
    }
    netif = netif->next;
  }
  return;
}



void dhcp_fine_tmr(void)

{
  char cVar1;
  ushort uVar2;
  netif *netif;
  void *pvVar3;
  
  netif = netif_list;
  do {
    if (netif == (netif *)0x0) {
      return;
    }
    pvVar3 = netif->client_data[0];
    if (pvVar3 != (void *)0x0) {
      uVar2 = *(ushort *)((int)pvVar3 + 8);
      if (uVar2 < 2) {
        if (uVar2 == 1) {
          *(undefined2 *)((int)pvVar3 + 8) = 0;
          pvVar3 = netif->client_data[0];
          cVar1 = *(char *)((int)pvVar3 + 5);
          if ((cVar1 == '\f') || (cVar1 == '\x06')) {
LAB_2303c45c:
            dhcp_discover(netif);
          }
          else {
            if (cVar1 == '\x01') {
              if (*(byte *)((int)pvVar3 + 6) < 6) {
                dhcp_select(netif);
              }
              else {
                dhcp_release_and_stop(netif);
                dhcp_start(netif);
              }
            }
            else {
              if (cVar1 == '\b') {
                if (*(byte *)((int)pvVar3 + 6) < 2) {
                  dhcp_check(netif);
                }
                else {
                  dhcp_bind(netif);
                }
              }
              else {
                if (cVar1 == '\x03') {
                  if (1 < *(byte *)((int)pvVar3 + 6)) goto LAB_2303c45c;
                  dhcp_reboot(netif);
                }
              }
            }
          }
        }
      }
      else {
        *(short *)((int)pvVar3 + 8) = uVar2 - 1;
      }
    }
    netif = netif->next;
  } while( true );
}



// WARNING: Type propagation algorithm not settling

void dhcp_stop(netif *netif)

{
  dhcp *dhcp;
  u8_t uVar1;
  undefined3 extraout_var;
  pbuf *p_out;
  u32_t value;
  uint uVar2;
  u8_t *options;
  u16_t options_out_len;
  u16_t uStack38;
  ip_addr_t aiStack36 [3];
  
  dhcp = (dhcp *)netif->client_data[0];
  if ((dhcp != (dhcp *)0x0) && (dhcp->state != '\0')) {
    aiStack36[0] = (ip_addr_t)(dhcp->server_ip_addr).addr;
    (dhcp->offered_ip_addr).addr = 0;
    (dhcp->server_ip_addr).addr = 0;
    (dhcp->offered_sn_mask).addr = 0;
    (dhcp->offered_gw_addr).addr = 0;
    dhcp->offered_t2_rebind = 0;
    dhcp->offered_t1_renew = 0;
    dhcp->offered_t0_lease = 0;
    dhcp->t1_renew_time = 0;
    *(undefined4 *)&dhcp->t2_rebind_time = 0;
    dhcp->t0_timeout = 0;
    uVar1 = dhcp_supplied_address(netif);
    if ((CONCAT31(extraout_var,uVar1) != 0) &&
       (p_out = dhcp_create_msg(netif,dhcp,'\a',&uStack38), p_out != (pbuf *)0x0)) {
      uVar2 = (uint)uStack38;
      options = (u8_t *)((int)p_out->payload + 0xf0);
      options[uVar2] = '6';
      options[uVar2 + 1 & 0xffff] = '\x04';
      options_out_len = (u16_t)((uVar2 + 2) * 0x10000 >> 0x10);
      uStack38 = options_out_len;
      value = lwip_htonl((u32_t)aiStack36[0]);
      uStack38 = dhcp_option_long(options_out_len,options,value);
      dhcp_option_trailer(uStack38,options,p_out);
      udp_sendto_if(dhcp_pcb,p_out,aiStack36,0x43,netif);
      pbuf_free(p_out);
    }
    netif_set_addr(netif,(ip4_addr_t *)&ip_addr_any,(ip4_addr_t *)&ip_addr_any,
                   (ip4_addr_t *)&ip_addr_any);
    dhcp_set_state(dhcp,'\0');
    if (dhcp->pcb_allocated != '\0') {
      dhcp_dec_pcb_refcount();
      dhcp->pcb_allocated = '\0';
    }
  }
  return;
}



void etharp_free_entry(int i)

{
  pbuf *p;
  
  p = arp_table[i].q;
  if (p != (pbuf *)0x0) {
    pbuf_free(p);
    arp_table[i].q = (pbuf *)0x0;
  }
  arp_table[i].state = '\0';
  return;
}



s16_t etharp_find_entry(ip4_addr_t *ipaddr,u8_t flags,netif *netif)

{
  ushort uVar1;
  ushort uVar2;
  int iVar3;
  int iVar4;
  int i;
  undefined3 in_register_0000202d;
  etharp_entry *peVar5;
  int iVar6;
  s16_t sVar7;
  int iVar8;
  uint uVar9;
  int iVar10;
  ushort uVar11;
  ushort uVar12;
  
  peVar5 = arp_table;
  uVar2 = 0;
  uVar12 = 0;
  uVar11 = 0;
  iVar3 = 10;
  iVar8 = 0;
  iVar10 = 10;
  iVar4 = 10;
  iVar6 = 10;
  do {
    i = iVar6;
    if (iVar6 == 10) {
      i = iVar8;
    }
    if (peVar5->state != '\0') {
      if ((ipaddr != (ip4_addr_t *)0x0) && (ipaddr->addr == (peVar5->ipaddr).addr)) {
        if (netif == (netif *)0x0) {
          return (s16_t)iVar8;
        }
        if (peVar5->netif == netif) {
          return (s16_t)iVar8;
        }
      }
      uVar1 = peVar5->ctime;
      if (peVar5->state == '\x01') {
        if (peVar5->q == (pbuf *)0x0) {
          i = iVar6;
          if (uVar12 <= uVar1) {
            iVar4 = iVar8;
            uVar12 = uVar1;
          }
        }
        else {
          i = iVar6;
          if (uVar11 <= uVar1) {
            iVar3 = iVar8;
            uVar11 = uVar1;
          }
        }
      }
      else {
        i = iVar6;
        if (uVar2 <= uVar1) {
          iVar10 = iVar8;
          uVar2 = uVar1;
        }
      }
    }
    uVar9 = iVar8 + 1U & 0xffff;
    peVar5 = peVar5 + 1;
    iVar8 = (int)(short)uVar9;
    iVar6 = i;
    if (uVar9 == 10) {
      sVar7 = -1;
      if (CONCAT31(in_register_0000202d,flags) == 1) {
        if (i == 10) {
          i = iVar10;
          if (((iVar10 == 10) && (i = iVar4, iVar4 == 10)) && (i = iVar3, iVar3 == 10)) {
            return -1;
          }
          etharp_free_entry(i);
        }
        sVar7 = (s16_t)i;
        if (ipaddr != (ip4_addr_t *)0x0) {
          arp_table[i].ipaddr.addr = ipaddr->addr;
        }
        arp_table[i].ctime = 0;
        arp_table[i].netif = netif;
      }
      return sVar7;
    }
  } while( true );
}



err_t etharp_raw(netif *netif,eth_addr *ethsrc_addr,eth_addr *ethdst_addr,eth_addr *hwsrc_addr,
                ip4_addr_t *ipsrc_addr,eth_addr *hwdst_addr,ip4_addr_t *ipdst_addr,u16_t opcode)

{
  undefined *puVar1;
  err_t eVar2;
  u16_t uVar3;
  pbuf *p;
  
  p = pbuf_alloc(PBUF_LINK,0x1c,PBUF_RAM);
  if (p == (pbuf *)0x0) {
    eVar2 = -1;
    lwip_stats.etharp.memerr = lwip_stats.etharp.memerr + 1;
  }
  else {
    puVar1 = (undefined *)p->payload;
    uVar3 = lwip_htons(opcode);
    puVar1[6] = (char)uVar3;
    puVar1[7] = (char)(uVar3 >> 8);
    memcpy(puVar1 + 8,hwsrc_addr,6);
    memcpy(puVar1 + 0x12,hwdst_addr,6);
    memcpy(puVar1 + 0xe,ipsrc_addr,4);
    memcpy(puVar1 + 0x18,ipdst_addr,4);
    puVar1[1] = 1;
    puVar1[2] = 8;
    puVar1[4] = 6;
    puVar1[5] = 4;
    *puVar1 = 0;
    puVar1[3] = 0;
    ethernet_output(netif,p,ethsrc_addr,ethdst_addr,0x806);
    lwip_stats.etharp.xmit = lwip_stats.etharp.xmit + 1;
    pbuf_free(p);
    eVar2 = '\0';
  }
  return eVar2;
}



void etharp_cleanup_netif(netif *netif)

{
  etharp_entry *peVar1;
  int i;
  
  peVar1 = arp_table;
  i = 0;
  do {
    if ((peVar1->state != '\0') && (peVar1->netif == netif)) {
      etharp_free_entry(i);
    }
    i = i + 1;
    peVar1 = peVar1 + 1;
  } while (i != 10);
  return;
}



// WARNING: Type propagation algorithm not settling

void etharp_input(pbuf *p,netif *netif)

{
  bool bVar1;
  short *psVar2;
  u8_t uVar3;
  s16_t sVar4;
  undefined3 extraout_var;
  short extraout_var_00;
  ip4_addr_t iVar5;
  eth_addr *dst;
  u8_t flags;
  pbuf *p_00;
  ip4_addr_t iStack56;
  ip4_addr_t sipaddr;
  ip4_addr_t dipaddr;
  
  if (netif != (netif *)0x0) {
    psVar2 = (short *)p->payload;
    if ((((*psVar2 == 0x100) && (*(char *)(psVar2 + 2) == '\x06')) &&
        (*(char *)((int)psVar2 + 5) == '\x04')) && (psVar2[1] == 8)) {
      lwip_stats.etharp.recv = lwip_stats.etharp.recv + 1;
      memcpy(&iStack56,psVar2 + 7,4);
      memcpy(&sipaddr,psVar2 + 0xc,4);
      iVar5 = (ip4_addr_t)(netif->ip_addr).addr;
      dst = (eth_addr *)(psVar2 + 4);
      if ((iVar5 == (ip4_addr_t)0x0) || (iVar5 != (ip4_addr_t)sipaddr)) {
        bVar1 = false;
        flags = '\x02';
      }
      else {
        bVar1 = true;
        flags = '\x01';
      }
      if (((iStack56 != (ip4_addr_t)0x0) &&
          (uVar3 = ip4_addr_isbroadcast_u32((u32_t)iStack56,netif),
          CONCAT31(extraout_var,uVar3) == 0)) && (((uint)iStack56 & 0xf0) != 0xe0)) {
        sVar4 = etharp_find_entry(&iStack56,flags,netif);
        _sVar4 = CONCAT22(extraout_var_00,sVar4);
        if (-1 < extraout_var_00) {
          arp_table[_sVar4].state = '\x02';
          arp_table[_sVar4].netif = netif;
          memcpy(&arp_table[_sVar4].ethaddr,dst,6);
          p_00 = arp_table[_sVar4].q;
          arp_table[_sVar4].ctime = 0;
          if (p_00 != (pbuf *)0x0) {
            arp_table[_sVar4].q = (pbuf *)0x0;
            ethernet_output(netif,p_00,(eth_addr *)netif->hwaddr,dst,0x800);
            pbuf_free(p_00);
          }
        }
      }
      if (psVar2[3] == 0x100) {
        if (bVar1) {
          etharp_raw(netif,(eth_addr *)netif->hwaddr,dst,(eth_addr *)netif->hwaddr,
                     (ip4_addr_t *)&netif->ip_addr,dst,&iStack56,2);
        }
      }
      else {
        if (psVar2[3] == 0x200) {
          dhcp_arp_reply(netif,&iStack56);
        }
        else {
          lwip_stats.etharp.err = lwip_stats.etharp.err + 1;
        }
      }
    }
    else {
      lwip_stats.etharp.proterr = lwip_stats.etharp.proterr + 1;
      lwip_stats.etharp.drop = lwip_stats.etharp.drop + 1;
    }
    pbuf_free(p);
    return;
  }
  return;
}



err_t etharp_request(netif *netif,ip4_addr_t *ipaddr)

{
  err_t eVar1;
  
  eVar1 = etharp_raw(netif,(eth_addr *)netif->hwaddr,&ethbroadcast,(eth_addr *)netif->hwaddr,
                     (ip4_addr_t *)&netif->ip_addr,&ethzero,ipaddr,1);
  return eVar1;
}



void etharp_tmr(void)

{
  u8_t uVar1;
  etharp_entry *peVar2;
  int i;
  uint uVar3;
  uint uVar4;
  
  peVar2 = arp_table;
  i = 0;
  do {
    uVar1 = peVar2->state;
    if (uVar1 != '\0') {
      uVar3 = (uint)peVar2->ctime + 1;
      uVar4 = uVar3 & 0xffff;
      peVar2->ctime = (u16_t)(uVar3 * 0x10000 >> 0x10);
      if (uVar4 < 300) {
        if (uVar1 == '\x01') {
          if (4 < uVar4) goto LAB_2303c930;
          etharp_request(peVar2->netif,&peVar2->ipaddr);
        }
        else {
          if (uVar1 == '\x03') {
            peVar2->state = '\x04';
          }
          else {
            if (uVar1 == '\x04') {
              peVar2->state = '\x02';
            }
          }
        }
      }
      else {
LAB_2303c930:
        etharp_free_entry(i);
      }
    }
    i = i + 1;
    peVar2 = peVar2 + 1;
    if (i == 10) {
      return;
    }
  } while( true );
}



err_t etharp_output_to_arp_index(netif *netif,pbuf *q,netif_addr_idx_t arp_idx)

{
  err_t eVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 in_register_00002031;
  int iVar2;
  eth_addr *ethsrc_addr;
  
  iVar2 = CONCAT31(in_register_00002031,arp_idx);
  ethsrc_addr = (eth_addr *)netif->hwaddr;
  if (arp_table[iVar2].state == '\x02') {
    if (arp_table[iVar2].ctime < 0x11d) {
      if (arp_table[iVar2].ctime < 0x10e) goto LAB_2303c9c8;
      eVar1 = etharp_raw(netif,ethsrc_addr,&arp_table[iVar2].ethaddr,ethsrc_addr,
                         (ip4_addr_t *)&netif->ip_addr,&ethzero,&arp_table[iVar2].ipaddr,1);
      _eVar1 = CONCAT31(extraout_var_00,eVar1);
    }
    else {
      eVar1 = etharp_request(netif,&arp_table[iVar2].ipaddr);
      _eVar1 = CONCAT31(extraout_var,eVar1);
    }
    if (_eVar1 == 0) {
      arp_table[iVar2].state = '\x03';
    }
  }
LAB_2303c9c8:
  eVar1 = ethernet_output(netif,q,ethsrc_addr,&arp_table[iVar2].ethaddr,0x800);
  return eVar1;
}



err_t etharp_query(netif *netif,ip4_addr_t *ipaddr,pbuf *q)

{
  pbuf **pppVar1;
  u8_t uVar2;
  err_t eVar3;
  ushort uVar4;
  undefined3 extraout_var;
  short extraout_var_00;
  pbuf *ppVar5;
  uint uVar6;
  
  uVar2 = ip4_addr_isbroadcast_u32(ipaddr->addr,netif);
  if (((CONCAT31(extraout_var,uVar2) != 0) || ((ipaddr->addr & 0xf0) == 0xe0)) ||
     (ipaddr->addr == 0)) {
    return -0x10;
  }
  uVar4 = etharp_find_entry(ipaddr,'\x01',netif);
  if (extraout_var_00 < 0) {
    if (q != (pbuf *)0x0) {
      lwip_stats.etharp.memerr = lwip_stats.etharp.memerr + 1;
    }
    return (err_t)uVar4;
  }
  uVar6 = (uint)uVar4 & 0xff;
  if (arp_table[uVar6].state == '\0') {
    arp_table[uVar6].state = '\x01';
    arp_table[uVar6].netif = netif;
  }
  else {
    eVar3 = -1;
    if (q != (pbuf *)0x0) goto LAB_2303caa6;
  }
  eVar3 = etharp_request(netif,ipaddr);
  if (q == (pbuf *)0x0) {
    return eVar3;
  }
LAB_2303caa6:
  if (1 < arp_table[uVar6].state) {
    etharp_cached_entry = (netif_addr_idx_t)uVar6;
    eVar3 = ethernet_output(netif,q,(eth_addr *)netif->hwaddr,&arp_table[uVar6].ethaddr,0x800);
    return eVar3;
  }
  ppVar5 = q;
  if (arp_table[uVar6].state == 1) {
    do {
      if ((ppVar5->type_internal & 0x40) != 0) {
        q = pbuf_clone(PBUF_LINK,PBUF_RAM,q);
        if (q == (pbuf *)0x0) {
          lwip_stats.etharp.memerr = lwip_stats.etharp.memerr + 1;
          return -1;
        }
        goto LAB_2303cb0c;
      }
      pppVar1 = &ppVar5->next;
      ppVar5 = *pppVar1;
    } while (*pppVar1 != (pbuf *)0x0);
    pbuf_ref(q);
LAB_2303cb0c:
    if (arp_table[uVar6].q != (pbuf *)0x0) {
      pbuf_free(arp_table[uVar6].q);
    }
    arp_table[uVar6].q = q;
    eVar3 = '\0';
  }
  return eVar3;
}



// WARNING: Variable defined which should be unmapped: mcastaddr

err_t etharp_output(netif *netif,pbuf *q,ip4_addr_t *ipaddr)

{
  netif_addr_idx_t nVar1;
  u8_t uVar2;
  err_t eVar3;
  undefined3 extraout_var;
  eth_addr *dst;
  uint uVar4;
  uint uVar5;
  etharp_entry *peVar6;
  undefined2 uStack24;
  u8_t uStack22;
  byte bStack21;
  eth_addr mcastaddr;
  
  uVar2 = ip4_addr_isbroadcast_u32(ipaddr->addr,netif);
  uVar4 = CONCAT31(extraout_var,uVar2);
  if (uVar4 == 0) {
    uVar5 = ipaddr->addr;
    if ((uVar5 & 0xf0) != 0xe0) {
      if (((((netif->ip_addr).addr ^ uVar5) & (netif->netmask).addr) != 0) &&
         ((uVar5 & 0xffff) != 0xfea9)) {
        if ((netif->gw).addr == 0) {
          return -4;
        }
        ipaddr = (ip4_addr_t *)&netif->gw;
      }
      uVar5 = (uint)etharp_cached_entry;
      peVar6 = arp_table;
      if (((arp_table[uVar5].state < 2) || (arp_table[uVar5].netif != netif)) ||
         (ipaddr->addr != arp_table[uVar5].ipaddr.addr)) {
        while (((peVar6->state < 2 || (peVar6->netif != netif)) ||
               (nVar1 = (netif_addr_idx_t)uVar4, ipaddr->addr != (peVar6->ipaddr).addr))) {
          uVar4 = uVar4 + 1 & 0xff;
          peVar6 = peVar6 + 1;
          if (uVar4 == 10) {
            eVar3 = etharp_query(netif,ipaddr,q);
            return eVar3;
          }
        }
      }
      else {
        lwip_stats.etharp.cachehit = lwip_stats.etharp.cachehit + 1;
        nVar1 = etharp_cached_entry;
      }
      etharp_cached_entry = nVar1;
      eVar3 = etharp_output_to_arp_index(netif,q,etharp_cached_entry);
      return eVar3;
    }
    uStack24 = 1;
    uStack22 = '^';
    dst = (eth_addr *)&uStack24;
    bStack21 = *(byte *)((int)&ipaddr->addr + 1) & 0x7f;
    mcastaddr.addr[0] = *(u8_t *)((int)&ipaddr->addr + 2);
    mcastaddr.addr[1] = *(u8_t *)((int)&ipaddr->addr + 3);
  }
  else {
    dst = &ethbroadcast;
  }
  eVar3 = ethernet_output(netif,q,(eth_addr *)netif->hwaddr,dst,0x800);
  return eVar3;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void igmp_send(netif *netif,igmp_group *group,u8_t type)

{
  u8_t *dataptr;
  u16_t uVar1;
  pbuf *p;
  undefined3 in_register_00002031;
  ip4_addr_t *dest;
  u8_t uVar2;
  u8_t uVar3;
  u8_t uVar4;
  u32_t uVar5;
  ip4_addr_t iStack40;
  ip4_addr_t src;
  u16_t ra [2];
  
  iStack40 = (ip4_addr_t)0;
  p = pbuf_alloc(PBUF_TRANSPORT,8,PBUF_RAM);
  if (p == (pbuf *)0x0) {
    lwip_stats.igmp.memerr = lwip_stats.igmp.memerr + 1;
  }
  else {
    iStack40 = (ip4_addr_t)(netif->ip_addr).addr;
    uVar5 = (group->group_address).addr;
    dataptr = (u8_t *)p->payload;
    uVar4 = (u8_t)(uVar5 >> 0x18);
    uVar2 = (u8_t)(uVar5 >> 8);
    uVar3 = (u8_t)(uVar5 >> 0x10);
    if (CONCAT31(in_register_00002031,type) == 0x16) {
      dataptr[7] = uVar4;
      dataptr[4] = (u8_t)uVar5;
      dataptr[5] = uVar2;
      dataptr[6] = uVar3;
      dest = &group->group_address;
      group->last_reporter_flag = '\x01';
    }
    else {
      dataptr[4] = (u8_t)uVar5;
      dataptr[5] = uVar2;
      dataptr[6] = uVar3;
      dataptr[7] = uVar4;
      dest = &allrouters;
    }
    *dataptr = type;
    dataptr[1] = '\0';
    dataptr[2] = '\0';
    dataptr[3] = '\0';
    uVar1 = inet_chksum(dataptr,8);
    dataptr[2] = (u8_t)uVar1;
    dataptr[3] = (u8_t)(uVar1 >> 8);
    src = 0x494;
    lwip_stats.igmp.xmit = lwip_stats.igmp.xmit + 1;
    ip4_output_if_opt(p,&iStack40,dest,'\x01','\0','\x02',netif,&src,_DAT_00000010);
    pbuf_free(p);
  }
  return;
}



void igmp_delaying_member(igmp_group *group,u8_t maxresp)

{
  uint uVar1;
  undefined3 in_register_0000202d;
  uint uVar2;
  
  uVar2 = CONCAT31(in_register_0000202d,maxresp);
  if ((group->group_state != '\x02') &&
     ((group->group_state != '\x01' || ((group->timer != 0 && (group->timer <= uVar2)))))) {
    return;
  }
  if (2 < uVar2) {
    uVar1 = bl_rand();
    group->timer = (u16_t)(uVar1 % uVar2);
    if (uVar1 % uVar2 != 0) goto LAB_2303cdba;
  }
  group->timer = 1;
LAB_2303cdba:
  group->group_state = '\x01';
  return;
}



void igmp_init(void)

{
  allrouters = 0x20000e0;
  allsystems = 0x10000e0;
  return;
}



err_t igmp_stop(netif *netif)

{
  void **mem;
  void *pvVar1;
  
  mem = (void **)netif->client_data[1];
  netif->client_data[1] = (void *)0x0;
  while (mem != (void **)0x0) {
    pvVar1 = *mem;
    if (netif->igmp_mac_filter != (netif_igmp_mac_filter_fn *)0x0) {
      (*netif->igmp_mac_filter)(netif,(ip4_addr_t *)(mem + 1),NETIF_DEL_MAC_FILTER);
    }
    memp_free(MEMP_IGMP_GROUP,mem);
    mem = (void **)pvVar1;
  }
  return '\0';
}



// WARNING: Type propagation algorithm not settling

void igmp_report_groups(netif *netif)

{
  igmp_group *group;
  
  if ((igmp_group *)netif->client_data[1] != (igmp_group *)0x0) {
    group = ((igmp_group *)netif->client_data[1])->next;
    while (group != (igmp_group *)0x0) {
      igmp_delaying_member(group,'\x05');
      group = group->next;
    }
    return;
  }
  return;
}



igmp_group * igmp_lookfor_group(netif *ifp,ip4_addr_t *addr)

{
  igmp_group *piVar1;
  
  piVar1 = (igmp_group *)ifp->client_data[1];
  while ((piVar1 != (igmp_group *)0x0 && ((piVar1->group_address).addr != addr->addr))) {
    piVar1 = piVar1->next;
  }
  return piVar1;
}



// WARNING: Type propagation algorithm not settling

igmp_group * igmp_lookup_group(netif *ifp,ip4_addr_t *addr)

{
  igmp_group *piVar1;
  igmp_group *piVar2;
  u32_t uVar3;
  
  piVar2 = igmp_lookfor_group(ifp,addr);
  if (piVar2 == (igmp_group *)0x0) {
    piVar1 = (igmp_group *)ifp->client_data[1];
    piVar2 = (igmp_group *)memp_malloc(MEMP_IGMP_GROUP);
    if (piVar2 != (igmp_group *)0x0) {
      uVar3 = 0;
      if (addr != (ip4_addr_t *)0x0) {
        uVar3 = addr->addr;
      }
      (piVar2->group_address).addr = uVar3;
      *(undefined4 *)&piVar2->last_reporter_flag = 0;
      piVar2->use = '\0';
      if (piVar1 == (igmp_group *)0x0) {
        piVar2->next = (igmp_group *)0x0;
        *(igmp_group **)(ifp->client_data + 1) = piVar2;
      }
      else {
        piVar2->next = piVar1->next;
        piVar1->next = piVar2;
      }
    }
  }
  return piVar2;
}



err_t igmp_start(netif *netif)

{
  err_t eVar1;
  igmp_group *piVar2;
  
  piVar2 = igmp_lookup_group(netif,&allsystems);
  if (piVar2 == (igmp_group *)0x0) {
    eVar1 = -1;
  }
  else {
    piVar2->group_state = '\x02';
    piVar2->use = piVar2->use + '\x01';
    eVar1 = '\0';
    if (netif->igmp_mac_filter != (netif_igmp_mac_filter_fn *)0x0) {
      (*netif->igmp_mac_filter)(netif,&allsystems,NETIF_ADD_MAC_FILTER);
      eVar1 = '\0';
    }
  }
  return eVar1;
}



// WARNING: Type propagation algorithm not settling

void igmp_input(pbuf *p,netif *inp,ip4_addr_t *dest)

{
  ip4_addr_t iVar1;
  char *dataptr;
  u16_t uVar2;
  undefined2 extraout_var;
  igmp_group *group;
  ip4_addr_t iStack36;
  ip4_addr_t groupaddr;
  
  lwip_stats.igmp.recv = lwip_stats.igmp.recv + 1;
  if (p->len < 8) {
    pbuf_free(p);
    lwip_stats.igmp.lenerr = lwip_stats.igmp.lenerr + 1;
    return;
  }
  dataptr = (char *)p->payload;
  uVar2 = inet_chksum(dataptr,p->len);
  if (CONCAT22(extraout_var,uVar2) != 0) {
    pbuf_free(p);
    lwip_stats.igmp.chkerr = lwip_stats.igmp.chkerr + 1;
    return;
  }
  group = igmp_lookfor_group(inp,dest);
  if (group == (igmp_group *)0x0) {
    pbuf_free(p);
    lwip_stats.igmp.drop = lwip_stats.igmp.drop + 1;
    return;
  }
  if (*dataptr == '\x11') {
    iVar1 = (ip4_addr_t)((ip4_addr_t *)(dataptr + 4))->addr;
    if (dest->addr == allsystems) {
      if (iVar1 == (ip4_addr_t)0x0) {
        if (dataptr[1] == '\0') {
          lwip_stats.igmp.rx_v1 = lwip_stats.igmp.rx_v1 + 1;
          dataptr[1] = '\n';
        }
        else {
          lwip_stats.igmp.rx_general = lwip_stats.igmp.rx_general + 1;
        }
        if ((igmp_group *)inp->client_data[1] != (igmp_group *)0x0) {
          group = ((igmp_group *)inp->client_data[1])->next;
          while (group != (igmp_group *)0x0) {
            igmp_delaying_member(group,dataptr[1]);
            group = group->next;
          }
        }
        goto LAB_2303d002;
      }
      iStack36 = iVar1;
      group = igmp_lookfor_group(inp,&iStack36);
      if (group == (igmp_group *)0x0) {
        lwip_stats.igmp.drop = lwip_stats.igmp.drop + 1;
        goto LAB_2303d002;
      }
    }
    else {
      if (iVar1 == (ip4_addr_t)0x0) goto LAB_2303cfa4;
    }
    lwip_stats.igmp.rx_group = lwip_stats.igmp.rx_group + 1;
    igmp_delaying_member(group,dataptr[1]);
  }
  else {
    if (*dataptr == '\x16') {
      lwip_stats.igmp.rx_report = lwip_stats.igmp.rx_report + 1;
      if (group->group_state == '\x01') {
        *(undefined4 *)&group->last_reporter_flag = 0x200;
      }
      goto LAB_2303d002;
    }
LAB_2303cfa4:
    lwip_stats.igmp.proterr = lwip_stats.igmp.proterr + 1;
  }
LAB_2303d002:
  pbuf_free(p);
  return;
}



void igmp_tmr(void)

{
  igmp_group *group;
  netif *netif;
  uint uVar1;
  
  netif = netif_list;
  while (netif != (netif *)0x0) {
    group = (igmp_group *)netif->client_data[1];
    while (group != (igmp_group *)0x0) {
      if ((((group->timer != 0) &&
           (uVar1 = (uint)group->timer - 1, group->timer = (u16_t)(uVar1 * 0x10000 >> 0x10),
           (uVar1 & 0xffff) == 0)) && (group->group_state == '\x01')) &&
         ((group->group_address).addr != allsystems)) {
        group->group_state = '\x02';
        lwip_stats.igmp.tx_report = lwip_stats.igmp.tx_report + 1;
        igmp_send(netif,group,'\x16');
      }
      group = group->next;
    }
    netif = netif->next;
  }
  return;
}



int ip4_input_accept(netif *netif)

{
  u8_t uVar1;
  int iVar2;
  undefined3 extraout_var;
  u32_t uVar3;
  
  if ((netif->flags & 1) == 0) {
    return 0;
  }
  uVar3 = (netif->ip_addr).addr;
  iVar2 = 0;
  if (uVar3 != 0) {
    iVar2 = 1;
    if (uVar3 != ip_data.current_iphdr_dest) {
      uVar1 = ip4_addr_isbroadcast_u32(ip_data.current_iphdr_dest,netif);
      return (uint)(CONCAT31(extraout_var,uVar1) != 0);
    }
  }
  return iVar2;
}



netif * ip4_route(ip4_addr_t *dest)

{
  byte bVar1;
  netif *pnVar2;
  netif *pnVar3;
  uint uVar4;
  uint uVar5;
  
  uVar5 = dest->addr;
  pnVar2 = netif_list;
  if (((uVar5 & 0xf0) != 0xe0) ||
     (pnVar3 = ip4_default_multicast_netif, ip4_default_multicast_netif == (netif *)0x0)) {
    while (pnVar2 != (netif *)0x0) {
      bVar1 = pnVar2->flags;
      if ((((bVar1 & 1) != 0) && ((bVar1 >> 2 & 1) != 0)) &&
         (uVar4 = (pnVar2->ip_addr).addr, uVar4 != 0)) {
        if (((uVar4 ^ uVar5) & (pnVar2->netmask).addr) == 0) {
          return pnVar2;
        }
        if (((bVar1 & 2) == 0) && (uVar5 == (pnVar2->gw).addr)) {
          return pnVar2;
        }
      }
      pnVar2 = pnVar2->next;
    }
    if (((netif_default == (netif *)0x0) || ((netif_default->flags & 5) != 5)) ||
       (((netif_default->ip_addr).addr == 0 || (pnVar3 = netif_default, (uVar5 & 0xff) == 0x7f)))) {
      lwip_stats.ip.rterr = lwip_stats.ip.rterr + 1;
      return (netif *)0x0;
    }
  }
  return pnVar3;
}



err_t ip4_input(pbuf *p,netif *inp)

{
  byte bVar1;
  uint uVar2;
  u8_t uVar3;
  raw_input_state_t rVar4;
  u16_t new_len;
  undefined2 extraout_var_02;
  undefined2 extraout_var_03;
  igmp_group *piVar5;
  undefined3 extraout_var;
  int iVar6;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  ip_hdr *dataptr;
  netif *netif;
  uint uVar7;
  
  lwip_stats.ip.recv = lwip_stats.ip.recv + 1;
  dataptr = (ip_hdr *)p->payload;
  bVar1 = dataptr->_v_hl;
  if (bVar1 >> 4 != 4) {
    pbuf_free(p);
    lwip_stats.ip.drop = lwip_stats.ip.drop + 1;
    lwip_stats.ip.err = lwip_stats.ip.err + 1;
    return '\0';
  }
  new_len = lwip_htons(dataptr->_len);
  uVar7 = (uint)bVar1 & 0xf;
  uVar2 = (uVar7 << 0x12) >> 0x10;
  if (CONCAT22(extraout_var_02,new_len) < (uint)p->tot_len) {
    pbuf_realloc(p,new_len);
  }
  if (((p->len < uVar2) || ((uint)p->tot_len < CONCAT22(extraout_var_02,new_len))) || (uVar2 < 0x14)
     ) {
    pbuf_free(p);
    lwip_stats.ip.lenerr = lwip_stats.ip.lenerr + 1;
    goto LAB_2303d27e;
  }
  new_len = inet_chksum(dataptr,(u16_t)((uVar7 << 0x12) >> 0x10));
  if (CONCAT22(extraout_var_03,new_len) != 0) {
    pbuf_free(p);
    lwip_stats.ip.chkerr = lwip_stats.ip.chkerr + 1;
    goto LAB_2303d27e;
  }
  ip_data.current_iphdr_dest = (dataptr->dest).addr;
  ip_data.current_iphdr_src = (dataptr->src).addr;
  netif = inp;
  if ((ip_data.current_iphdr_dest & 0xf0) == 0xe0) {
    if (((inp->flags & 0x20) == 0) ||
       (piVar5 = igmp_lookfor_group(inp,(ip4_addr_t *)&ip_data.current_iphdr_dest),
       piVar5 == (igmp_group *)0x0)) goto LAB_2303d304;
    if ((ip_data.current_iphdr_dest != 0x10000e0) || (ip_data.current_iphdr_src != 0))
    goto LAB_2303d334;
  }
  else {
    iVar6 = ip4_input_accept(inp);
    if (iVar6 == 0) {
      netif = netif_list;
      if ((char)ip_data.current_iphdr_dest.addr != '\x7f') {
        while (netif != (netif *)0x0) {
          if ((netif != inp) && (iVar6 = ip4_input_accept(netif), iVar6 != 0)) goto LAB_2303d334;
          netif = netif->next;
        }
      }
    }
    else {
      if (inp != (netif *)0x0) goto LAB_2303d334;
    }
LAB_2303d304:
    if ((dataptr->_proto != '\x11') || (netif = inp, (&dataptr->_len)[uVar7 * 2] != 0x4400)) {
      netif = (netif *)0x0;
LAB_2303d334:
      if ((ip_data.current_iphdr_src != 0) &&
         ((uVar3 = ip4_addr_isbroadcast_u32(ip_data.current_iphdr_src,inp),
          CONCAT31(extraout_var,uVar3) != 0 || ((ip_data.current_iphdr_src & 0xf0) == 0xe0)))) {
        pbuf_free(p);
        goto LAB_2303d27e;
      }
    }
    if (netif == (netif *)0x0) {
      lwip_stats.ip.drop = lwip_stats.ip.drop + 1;
      pbuf_free(p);
      return '\0';
    }
  }
  if (((uint)*(byte *)&dataptr->_offset & 0x3f | (uint)*(byte *)((int)&dataptr->_offset + 1) << 8)
      == 0) {
    ip_data.current_ip_header_tot_len = (u16_t)(((uint)dataptr->_v_hl & 0xf) << 2);
    ip_data.current_netif = netif;
    ip_data.current_input_netif = inp;
    ip_data.current_ip4_header = dataptr;
    rVar4 = raw_input(p,inp);
    if (CONCAT31(extraout_var_00,rVar4) != 1) {
      pbuf_remove_header(p,uVar7 * 4);
      bVar1 = dataptr->_proto;
      if (bVar1 == 2) {
        igmp_input(p,inp,(ip4_addr_t *)&ip_data.current_iphdr_dest);
      }
      else {
        if (bVar1 < 3) {
          if (bVar1 == 1) {
            icmp_input(p,inp);
            ip_data.current_netif = (netif *)0x0;
            ip_data.current_input_netif = (netif *)0x0;
            ip_data.current_ip4_header = (ip_hdr *)0x0;
            ip_data.current_ip_header_tot_len = 0;
            ip_data.current_iphdr_src = 0;
            ip_data.current_iphdr_dest = 0;
            return '\0';
          }
        }
        else {
          if (bVar1 == 6) {
            tcp_input(p,inp);
            ip_data.current_netif = (netif *)0x0;
            ip_data.current_input_netif = (netif *)0x0;
            ip_data.current_ip4_header = (ip_hdr *)0x0;
            ip_data.current_ip_header_tot_len = 0;
            ip_data.current_iphdr_src = 0;
            ip_data.current_iphdr_dest = 0;
            return '\0';
          }
          if (bVar1 == 0x11) {
            udp_input(p,inp);
            ip_data.current_netif = (netif *)0x0;
            ip_data.current_input_netif = (netif *)0x0;
            ip_data.current_ip4_header = (ip_hdr *)0x0;
            ip_data.current_ip_header_tot_len = 0;
            ip_data.current_iphdr_src = 0;
            ip_data.current_iphdr_dest = 0;
            return '\0';
          }
        }
        if (CONCAT31(extraout_var_00,rVar4) != 2) {
          uVar3 = ip4_addr_isbroadcast_u32(ip_data.current_iphdr_dest,netif);
          if ((CONCAT31(extraout_var_01,uVar3) == 0) &&
             ((ip_data.current_iphdr_dest & 0xf0) != 0xe0)) {
            pbuf_header_force(p,(s16_t)(uVar7 * 4));
            icmp_dest_unreach(p,ICMP_DUR_PROTO);
          }
          lwip_stats.ip.proterr = lwip_stats.ip.proterr + 1;
          lwip_stats.ip.drop = lwip_stats.ip.drop + 1;
        }
        pbuf_free(p);
      }
    }
    ip_data.current_netif = (netif *)0x0;
    ip_data.current_input_netif = (netif *)0x0;
    ip_data.current_ip4_header = (ip_hdr *)0x0;
    ip_data.current_ip_header_tot_len = 0;
    ip_data.current_iphdr_src = 0;
    ip_data.current_iphdr_dest = 0;
    return '\0';
  }
  pbuf_free(p);
  lwip_stats.ip.opterr = lwip_stats.ip.opterr + 1;
LAB_2303d27e:
  lwip_stats.ip.drop = lwip_stats.ip.drop + 1;
  return '\0';
}



// WARNING: Type propagation algorithm not settling

err_t ip4_output_if_opt_src
                (pbuf *p,ip4_addr_t *src,ip4_addr_t *dest,u8_t ttl,u8_t tos,u8_t proto,netif *netif,
                void *ip_options,u16_t optlen)

{
  uint header_size_increment;
  undefined *puVar1;
  uint uVar2;
  u8_t uVar3;
  err_t eVar4;
  u16_t uVar5;
  u16_t n;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined2 extraout_var_01;
  undefined2 extraout_var_02;
  undefined3 in_register_00002035;
  undefined3 in_register_00002039;
  int iVar6;
  undefined3 in_register_0000203d;
  int iVar7;
  uint uVar8;
  uint __n;
  int iVar9;
  ushort in_stack_00000000;
  ip4_addr_t iStack52;
  ip4_addr_t dest_addr;
  
  __n = (uint)in_stack_00000000;
  if (dest == (ip4_addr_t *)0x0) {
    if (0x13 < p->len) {
      dest = &iStack52;
      iStack52 = (ip4_addr_t)((ip4_addr_t *)((int)p->payload + 0x10))->addr;
      goto LAB_2303d6b6;
    }
  }
  else {
    if (in_stack_00000000 == 0) {
      uVar2 = 0x14;
      iVar9 = 0;
    }
    else {
      if (0x28 < in_stack_00000000) {
        lwip_stats.ip.err = lwip_stats.ip.err + 1;
        return -6;
      }
      header_size_increment = __n + 3 & 0xfffc;
      uVar3 = pbuf_add_header(p,header_size_increment);
      uVar2 = header_size_increment + 0x14 & 0xffff;
      if (CONCAT31(extraout_var,uVar3) != 0) goto LAB_2303d54c;
      memcpy(p->payload,ip_options,__n);
      if (__n < header_size_increment) {
        memset((void *)((int)p->payload + __n),0,header_size_increment - __n);
      }
      iVar7 = 0;
      iVar9 = 0;
      do {
        iVar6 = iVar7 * 2;
        iVar7 = iVar7 + 1;
        iVar9 = iVar9 + (uint)*(ushort *)(iVar6 + (int)p->payload);
      } while (iVar7 < (int)(header_size_increment >> 1));
    }
    uVar3 = pbuf_add_header(p,0x14);
    if (CONCAT31(extraout_var_00,uVar3) == 0) {
      puVar1 = (undefined *)p->payload;
      puVar1[8] = ttl;
      puVar1[9] = proto;
      header_size_increment = dest->addr;
      uVar8 = CONCAT31(in_register_00002035,ttl) << 8 | CONCAT31(in_register_0000203d,proto);
      puVar1[0x10] = (char)header_size_increment;
      puVar1[0x11] = (char)(header_size_increment >> 8);
      puVar1[0x12] = (char)(header_size_increment >> 0x10);
      __n = uVar2 >> 2 & 0xff | 0x40;
      *puVar1 = (char)__n;
      __n = __n << 8 | CONCAT31(in_register_00002039,tos);
      puVar1[0x13] = (char)(header_size_increment >> 0x18);
      puVar1[1] = tos;
      uVar5 = lwip_htons(p->tot_len);
      puVar1[2] = (char)uVar5;
      n = ip_id;
      puVar1[3] = (char)(uVar5 >> 8);
      puVar1[6] = 0;
      puVar1[7] = 0;
      n = lwip_htons(n);
      puVar1[5] = (char)(n >> 8);
      puVar1[4] = (char)n;
      ip_id = ip_id + 1;
      if (src == (ip4_addr_t *)0x0) {
        uVar2 = 0;
      }
      else {
        uVar2 = src->addr;
      }
      puVar1[0xf] = (char)(uVar2 >> 0x18);
      puVar1[0xc] = (char)uVar2;
      puVar1[0xd] = (char)(uVar2 >> 8);
      __n = (uVar2 & 0xffff) +
            CONCAT22(extraout_var_02,n) +
            (((int)__n >> 8 | __n << 8) & 0xffff) +
            ((uVar8 << 8 | (int)uVar8 >> 8) & 0xffff) +
            (header_size_increment & 0xffff) + (header_size_increment >> 0x10) + iVar9 +
            CONCAT22(extraout_var_01,uVar5) + (uVar2 >> 0x10);
      puVar1[0xe] = (char)(uVar2 >> 0x10);
      __n = (__n & 0xffff) + (__n >> 0x10);
      __n = ~((__n >> 0x10) + __n);
      puVar1[10] = (char)__n;
      puVar1[0xb] = (char)(__n >> 8);
LAB_2303d6b6:
      lwip_stats.ip.xmit = lwip_stats.ip.xmit + 1;
      eVar4 = (*netif->output)(netif,p,dest);
      return eVar4;
    }
  }
LAB_2303d54c:
  lwip_stats.ip.err = lwip_stats.ip.err + 1;
  return -2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

err_t ip4_output_if_opt(pbuf *p,ip4_addr_t *src,ip4_addr_t *dest,u8_t ttl,u8_t tos,u8_t proto,
                       netif *netif,void *ip_options,u16_t optlen)

{
  err_t eVar1;
  
  if ((dest != (ip4_addr_t *)0x0) && ((src == (ip4_addr_t *)0x0 || (src->addr == 0)))) {
    src = (ip4_addr_t *)&netif->ip_addr;
  }
  eVar1 = ip4_output_if_opt_src(p,src,dest,ttl,tos,proto,netif,ip_options,optlen);
  return eVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

err_t ip4_output_if(pbuf *p,ip4_addr_t *src,ip4_addr_t *dest,u8_t ttl,u8_t tos,u8_t proto,
                   netif *netif)

{
  err_t eVar1;
  
  eVar1 = ip4_output_if_opt(p,src,dest,ttl,tos,proto,netif,(void *)0x0,_DAT_00000010);
  return eVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

err_t ip4_output_if_src(pbuf *p,ip4_addr_t *src,ip4_addr_t *dest,u8_t ttl,u8_t tos,u8_t proto,
                       netif *netif)

{
  err_t eVar1;
  
  eVar1 = ip4_output_if_opt_src(p,src,dest,ttl,tos,proto,netif,(void *)0x0,_DAT_00000010);
  return eVar1;
}



u8_t ip4_addr_isbroadcast_u32(u32_t addr,netif *netif)

{
  byte bVar1;
  uint uVar2;
  uint uVar3;
  
  if (addr - 1 < 0xfffffffe) {
    bVar1 = netif->flags & 2;
    if ((netif->flags & 2) != 0) {
      uVar3 = (netif->ip_addr).addr;
      bVar1 = 0;
      if ((uVar3 != addr) && (uVar2 = (netif->netmask).addr, ((uVar3 ^ addr) & uVar2) == 0)) {
        uVar2 = ~uVar2;
        return (u8_t)((uVar2 & addr) == uVar2);
      }
    }
  }
  else {
    bVar1 = 1;
  }
  return (u8_t)bVar1;
}



int ip4addr_aton(char *cp,ip4_addr_t *addr)

{
  byte bVar1;
  int iVar2;
  u32_t n;
  u32_t *puVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;
  u32_t uStack32;
  u32_t parts [4];
  
  bVar1 = *cp;
  puVar3 = &uStack32;
LAB_2303d7b2:
  uVar5 = (uint)bVar1;
  if ((_ctype_[uVar5 + 1] & 4) == 0) {
    return 0;
  }
  iVar6 = 10;
  if (bVar1 == 0x30) {
    uVar5 = (uint)(byte)cp[1];
    if ((uVar5 & 0xdf) == 0x58) {
      uVar5 = (uint)(byte)cp[2];
      iVar6 = 0x10;
      cp = cp + 2;
    }
    else {
      cp = cp + 1;
      iVar6 = 8;
    }
  }
  n = 0;
  do {
    bVar1 = _ctype_[uVar5 + 1];
    if ((bVar1 & 4) == 0) {
      if ((iVar6 != 0x10) || ((bVar1 & 0x44) == 0)) break;
      iVar2 = 0x61;
      if ((bVar1 & 3) != 2) {
        iVar2 = 0x41;
      }
      n = n << 4 | (uVar5 + 10) - iVar2;
    }
    else {
      n = (iVar6 * n + uVar5) - 0x30;
    }
    uVar5 = (uint)(byte)cp[1];
    cp = cp + 1;
  } while( true );
  if (uVar5 == 0x2e) {
    if (puVar3 == parts + 2) {
      return 0;
    }
    *puVar3 = n;
    bVar1 = cp[1];
    cp = cp + 1;
    puVar3 = puVar3 + 1;
    goto LAB_2303d7b2;
  }
  if ((uVar5 != 0) && ((bVar1 & 8) == 0)) {
    return 0;
  }
  iVar6 = (int)((int)puVar3 - (int)&uStack32) >> 2;
  iVar2 = iVar6 + 1;
  if (iVar2 == 2) {
    if (0xffffff < n) {
      return 0;
    }
    if (0xff < uStack32) {
      return 0;
    }
    uVar5 = uStack32 << 0x18;
  }
  else {
    if (iVar2 < 3) {
      if (iVar6 == -1) {
        return 0;
      }
      goto LAB_2303d860;
    }
    if (iVar2 == 3) {
      if (0xffff < n) {
        return 0;
      }
      if (0xff < uStack32) {
        return 0;
      }
      if (0xff < parts[0]) {
        return 0;
      }
      uVar5 = uStack32 << 0x18;
      uVar4 = parts[0] << 0x10;
    }
    else {
      if (iVar2 != 4) goto LAB_2303d860;
      if (0xff < n) {
        return 0;
      }
      if (0xff < uStack32) {
        return 0;
      }
      if (0xff < parts[0]) {
        return 0;
      }
      if (0xff < parts[1]) {
        return 0;
      }
      uVar5 = uStack32 << 0x18 | parts[0] << 0x10;
      uVar4 = parts[1] << 8;
    }
    uVar5 = uVar5 | uVar4;
  }
  n = n | uVar5;
LAB_2303d860:
  if (addr != (ip4_addr_t *)0x0) {
    n = lwip_htonl(n);
    addr->addr = n;
    return 1;
  }
  return 1;
}



u32_t ipaddr_addr(char *cp)

{
  int iVar1;
  ip4_addr_t iStack20;
  ip4_addr_t val;
  
  iVar1 = ip4addr_aton(cp,&iStack20);
  if (iVar1 == 0) {
    iStack20 = (ip4_addr_t)0xffffffff;
  }
  return (u32_t)iStack20;
}



// WARNING: Could not reconcile some variable overlaps

char * ip4addr_ntoa_r(ip4_addr_t *addr,char *buf,int buflen)

{
  bool bVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  byte *pbVar5;
  uint uVar6;
  char *pcVar7;
  uint uVar8;
  uint uVar9;
  char *pcVar10;
  u32_t s_addr;
  char local_8 [4];
  char inv [3];
  
  _inv = addr->addr;
  iVar3 = 0;
  pbVar5 = (byte *)inv;
  pcVar10 = buf;
  while( true ) {
    uVar2 = 0;
    uVar9 = (uint)*pbVar5;
    do {
      uVar8 = uVar2;
      uVar6 = uVar9 / 10;
      local_8[uVar8] = (char)(uVar9 % 10) + '0';
      bVar1 = 9 < uVar9;
      uVar2 = uVar8 + 1 & 0xff;
      uVar9 = uVar6;
    } while (bVar1);
    *pbVar5 = (byte)uVar6;
    iVar4 = iVar3;
    pcVar7 = pcVar10;
    while (iVar3 = iVar4 + 1, uVar8 != 0xff) {
      if (buflen <= iVar4) {
        return (char *)0x0;
      }
      *pcVar7 = local_8[uVar8];
      iVar4 = iVar3;
      pcVar7 = pcVar7 + 1;
      uVar8 = uVar8 - 1 & 0xff;
    }
    if (buflen <= iVar4) break;
    *pcVar7 = '.';
    pbVar5 = pbVar5 + 1;
    pcVar10 = pcVar7 + 1;
    if (pbVar5 == (byte *)register0x00002008) {
      *pcVar7 = '\0';
      return buf;
    }
  }
  return (char *)0x0;
}



char * ip4addr_ntoa(ip4_addr_t *addr)

{
  char str [16];
  char *pcVar1;
  
  pcVar1 = ip4addr_ntoa_r(addr,(char *)&ram0x42015514,0x10);
  return pcVar1;
}



void mem_init(void)

{
  ram = ram_heap;
  ram_heap._0_4_ = 0x2000;
  ram_heap[4] = '\0';
  ram_end = (mem *)(ram_heap + 0x2000);
  ram_heap._8192_4_ = 0x20002000;
  ram_heap[8196] = '\x01';
  lfree = (mem *)ram_heap;
  lwip_stats.mem.avail = 0x2000;
  sys_mutex_new(&mem_mutex);
  return;
}



void mem_free(uint param_1)

{
  ushort uVar1;
  ushort uVar2;
  short sVar3;
  u8_t *puVar4;
  mem *pmVar5;
  mem *pmVar6;
  mem *pmVar7;
  uint uVar8;
  mem *pmVar9;
  
  if (param_1 == 0) {
    return;
  }
  if ((((param_1 & 3) == 0) && (pmVar6 = (mem *)(param_1 - 8), ram <= pmVar6)) &&
     ((mem *)(param_1 + 0xc) <= ram_end)) {
    sys_mutex_lock(&mem_mutex);
    pmVar5 = ram_end;
    puVar4 = ram;
    pmVar9 = lfree;
    if (*(char *)(param_1 - 4) != '\0') {
      uVar1 = *(ushort *)(param_1 - 8);
      if ((uVar1 < 0x2001) && (uVar2 = *(ushort *)(param_1 - 6), uVar2 < 0x2001)) {
        pmVar7 = (mem *)((int)pmVar6 - (int)ram);
        uVar8 = (uint)pmVar7 & 0xffff;
        if ((uVar8 == (uint)uVar2) || ((uint)*(ushort *)(ram + (uint)uVar2) == uVar8)) {
          if (((mem *)(ram + uVar1) == ram_end) || ((uint)((mem *)(ram + uVar1))->prev == uVar8)) {
            *(undefined *)(param_1 - 4) = 0;
            if (pmVar6 < pmVar9) {
              lfree = pmVar6;
            }
            sVar3 = (short)((uint)((int)pmVar7 * 0x10000) >> 0x10);
            lwip_stats.mem.used = (lwip_stats.mem.used - uVar1) + sVar3;
            pmVar9 = (mem *)(puVar4 + *(ushort *)(param_1 - 8));
            if (((pmVar6 != pmVar9) && (pmVar9->used == '\0')) && (pmVar5 != pmVar9)) {
              if (pmVar9 == lfree) {
                lfree = pmVar6;
              }
              *(mem_size_t *)(param_1 - 8) = pmVar9->next;
              if (pmVar9->next != 0x2000) {
                *(short *)(puVar4 + (uint)pmVar9->next + 2) = sVar3;
              }
            }
            uVar1 = *(ushort *)(param_1 - 6);
            pmVar9 = (mem *)(puVar4 + uVar1);
            if ((pmVar6 != pmVar9) && (pmVar9->used == '\0')) {
              if (pmVar6 == lfree) {
                lfree = pmVar9;
              }
              pmVar9->next = *(mem_size_t *)(param_1 - 8);
              if (*(ushort *)(param_1 - 8) != 0x2000) {
                *(ushort *)(puVar4 + (uint)*(ushort *)(param_1 - 8) + 2) = uVar1;
              }
            }
            sys_mutex_unlock(&mem_mutex);
            return;
          }
        }
      }
    }
    sys_mutex_unlock(&mem_mutex);
  }
  sys_arch_protect();
  lwip_stats.mem.illegal = lwip_stats.mem.illegal + 1;
  sys_arch_unprotect();
  return;
}



mem * mem_trim(mem *param_1,uint param_2)

{
  mem_size_t mVar1;
  short sVar2;
  u8_t *puVar3;
  uint uVar4;
  mem_size_t mVar5;
  uint uVar6;
  uint uVar7;
  mem *pmVar8;
  mem *pmVar9;
  undefined2 uVar10;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  
  uVar4 = param_2 + 3 & 0xfffc;
  if (uVar4 < 0xc) {
    uVar4 = 0xc;
  }
  else {
    if (0x2000 < uVar4) {
      return (mem *)0;
    }
  }
  if (uVar4 < param_2) {
    return (mem *)0;
  }
  if ((param_1 < ram) || (ram_end <= param_1)) {
    sys_arch_protect();
    lwip_stats.mem.illegal = lwip_stats.mem.illegal + 1;
    sys_arch_unprotect();
    return param_1;
  }
  uVar6 = (int)param_1 + (-8 - (int)ram);
  uVar11 = (uint)*(ushort *)&param_1[-2].used - 8;
  uVar7 = uVar6 & 0xffff;
  uVar12 = uVar11 & 0xffff;
  uVar13 = uVar12 - uVar7 & 0xffff;
  if (uVar13 < uVar4) {
    return (mem *)0;
  }
  if (uVar13 == uVar4) {
    return param_1;
  }
  sys_mutex_lock(&mem_mutex);
  puVar3 = ram;
  pmVar8 = (mem *)(ram + *(ushort *)&param_1[-2].used);
  mVar5 = (mem_size_t)uVar7;
  if (pmVar8->used == '\0') {
    uVar6 = uVar7 + 8 + uVar4;
    mVar1 = pmVar8->next;
    pmVar9 = (mem *)(ram + (uVar6 & 0xffff));
    if (lfree == pmVar8) {
      lfree = pmVar9;
    }
    pmVar9->used = '\0';
    pmVar9->next = mVar1;
    pmVar9->prev = mVar5;
    uVar10 = (undefined2)(uVar6 * 0x10000 >> 0x10);
    *(undefined2 *)&param_1[-2].used = uVar10;
    if (pmVar9->next != 0x2000) {
      *(undefined2 *)(puVar3 + (uint)pmVar9->next + 2) = uVar10;
    }
    sVar2 = (mVar5 - (short)uVar12) + lwip_stats.mem.used;
  }
  else {
    if (uVar13 < uVar4 + 0x14) goto LAB_2303dc84;
    uVar7 = uVar7 + 8 + uVar4;
    pmVar8 = (mem *)(ram + (uVar7 & 0xffff));
    if (pmVar8 < lfree) {
      lfree = pmVar8;
    }
    pmVar8->used = '\0';
    mVar1 = *(mem_size_t *)&param_1[-2].used;
    pmVar8->prev = mVar5;
    pmVar8->next = mVar1;
    uVar10 = (undefined2)(uVar7 * 0x10000 >> 0x10);
    *(undefined2 *)&param_1[-2].used = uVar10;
    if (pmVar8->next != 0x2000) {
      *(undefined2 *)(puVar3 + (uint)pmVar8->next + 2) = uVar10;
    }
    sVar2 = ((short)(uVar6 * 0x10000 >> 0x10) - (short)(uVar11 * 0x10000 >> 0x10)) +
            lwip_stats.mem.used;
  }
  lwip_stats.mem.used = (short)uVar4 + sVar2;
LAB_2303dc84:
  sys_mutex_unlock(&mem_mutex);
  return param_1;
}



mem_size_t * mem_malloc(uint param_1)

{
  ushort uVar1;
  u8_t *puVar2;
  mem_size_t *pmVar3;
  mem *pmVar4;
  uint uVar5;
  uint uVar6;
  ushort *puVar7;
  mem_size_t mVar8;
  uint uVar9;
  uint uVar10;
  mem *pmVar11;
  
  if (param_1 == 0) {
LAB_2303dd76:
    pmVar3 = (mem_size_t *)0x0;
  }
  else {
    uVar5 = param_1 + 3 & 0xfffc;
    if (uVar5 < 0xc) {
      uVar5 = 0xc;
    }
    else {
      if (0x2000 < uVar5) {
        return (mem_size_t *)0;
      }
    }
    pmVar3 = (mem_size_t *)0x0;
    if (param_1 <= uVar5) {
      sys_mutex_lock(&mem_mutex);
      puVar2 = ram;
      pmVar11 = lfree;
      uVar9 = (uint)((int)lfree - (int)ram) & 0xffff;
      do {
        uVar10 = uVar9;
        if (0x2000 - uVar5 <= uVar10) {
          lwip_stats.mem.err = lwip_stats.mem.err + 1;
          sys_mutex_unlock(&mem_mutex);
          goto LAB_2303dd76;
        }
        pmVar4 = (mem *)(ram + uVar10);
        uVar9 = (uint)pmVar4->next;
      } while ((pmVar4->used != '\0') || (uVar6 = (-8 - uVar10) + uVar9, uVar6 < uVar5));
      if (uVar6 < uVar5 + 0x14) {
        pmVar4->used = '\x01';
        uVar10 = (uVar9 + lwip_stats.mem.used) - uVar10;
        lwip_stats.mem.used = (mem_size_t)(uVar10 * 0x10000 >> 0x10);
        if ((uint)lwip_stats.mem.max < (uVar10 & 0xffff)) {
          lwip_stats.mem.max = lwip_stats.mem.used;
        }
      }
      else {
        uVar9 = uVar5 + 8 + uVar10;
        puVar7 = (ushort *)(ram + (uVar9 & 0xffff));
        *(undefined *)(puVar7 + 2) = 0;
        uVar1 = pmVar4->next;
        puVar7[1] = (ushort)uVar10;
        *puVar7 = uVar1;
        mVar8 = (mem_size_t)(uVar9 * 0x10000 >> 0x10);
        pmVar4->next = mVar8;
        pmVar4->used = '\x01';
        if (*puVar7 != 0x2000) {
          *(mem_size_t *)(puVar2 + (uint)*puVar7 + 2) = mVar8;
        }
        uVar5 = uVar5 + (uint)lwip_stats.mem.used + 8;
        lwip_stats.mem.used = (mem_size_t)(uVar5 * 0x10000 >> 0x10);
        if ((uint)lwip_stats.mem.max < (uVar5 & 0xffff)) {
          lwip_stats.mem.max = lwip_stats.mem.used;
        }
      }
      if (pmVar11 == pmVar4) {
        while ((lfree = pmVar11, pmVar11->used != '\0' && (ram_end != pmVar11))) {
          pmVar11 = (mem *)(puVar2 + pmVar11->next);
        }
      }
      sys_mutex_unlock(&mem_mutex);
      pmVar3 = &pmVar4[1].prev;
    }
  }
  return pmVar3;
}



// WARNING: Type propagation algorithm not settling

void * do_memp_malloc_pool(memp_desc *desc)

{
  memp mVar1;
  sys_prot_t sVar2;
  stats_mem *psVar3;
  
  sVar2 = sys_arch_protect();
  mVar1 = (memp)((memp *)desc->tab)->next;
  if (mVar1 == (memp)0x0) {
    desc->stats->err = desc->stats->err + 1;
  }
  else {
    *(memp *)&((memp *)desc->tab)->next = *(memp *)mVar1;
    desc->stats->used = desc->stats->used + 1;
    psVar3 = desc->stats;
    if (psVar3->max < psVar3->used) {
      psVar3->max = psVar3->used;
    }
  }
  sys_arch_unprotect(sVar2);
  return (void *)mVar1;
}



// WARNING: Type propagation algorithm not settling

void memp_init_pool(memp_desc *desc)

{
  int iVar1;
  memp mVar2;
  
  iVar1 = 0;
  *desc->tab = (memp *)0x0;
  mVar2 = (memp)((uint)(desc->base + 3) & 0xfffffffc);
  while (iVar1 < (int)(uint)desc->num) {
    iVar1 = iVar1 + 1;
    *(memp **)mVar2 = ((memp *)desc->tab)->next;
    *(memp *)&((memp *)desc->tab)->next = mVar2;
    mVar2 = (memp)((int)mVar2 + (uint)desc->size);
  }
  desc->stats->avail = desc->num;
  return;
}



void memp_init(void)

{
  stats_ *psVar1;
  int iVar2;
  memp_desc *desc;
  
  iVar2 = 0;
  psVar1 = &lwip_stats;
  do {
    desc = *(memp_desc **)((int)memp_pools + iVar2);
    iVar2 = iVar2 + 4;
    memp_init_pool(desc);
    psVar1->memp[0] = desc->stats;
    psVar1 = (stats_ *)&(psVar1->link).fw;
  } while (iVar2 != 0x3c);
  return;
}



void * memp_malloc(memp_t type)

{
  undefined3 in_register_00002029;
  void *pvVar1;
  
  if (CONCAT31(in_register_00002029,type) < 0xf) {
    pvVar1 = do_memp_malloc_pool(memp_pools[CONCAT31(in_register_00002029,type)]);
    return pvVar1;
  }
  return (void *)0x0;
}



void memp_free(memp_t type,void *mem)

{
  memp_desc *pmVar1;
  undefined3 in_register_00002029;
  
  if ((CONCAT31(in_register_00002029,type) < 0xf) && (mem != (void *)0x0)) {
    pmVar1 = memp_pools[CONCAT31(in_register_00002029,type)];
    sys_arch_protect();
    pmVar1->stats->used = pmVar1->stats->used - 1;
    *(memp **)mem = *pmVar1->tab;
    *pmVar1->tab = mem;
    sys_arch_unprotect();
    return;
  }
  return;
}



err_t netif_null_output_ip4(netif *netif,pbuf *p,ip4_addr_t *ipaddr)

{
  return -0xc;
}



void netif_issue_reports(netif *netif,u8_t report_type)

{
  if (((netif->flags & 5) != 5) || ((report_type & 1) == 0)) {
    return;
  }
  if ((netif->ip_addr).addr != 0) {
    if ((netif->flags & 8) != 0) {
      etharp_request(netif,(ip4_addr_t *)&netif->ip_addr);
    }
    if ((netif->flags & 0x20) != 0) {
      igmp_report_groups(netif);
      return;
    }
  }
  return;
}



// WARNING: Variable defined which should be unmapped: new_addr
// WARNING: Type propagation algorithm not settling

int netif_do_set_ipaddr(netif *netif,ip4_addr_t *ipaddr,ip_addr_t *old_addr)

{
  ip_addr_t iVar1;
  ip_addr_t iStack20;
  ip_addr_t new_addr;
  
  iVar1 = (ip_addr_t)(netif->ip_addr).addr;
  iStack20 = (ip_addr_t)ipaddr->addr;
  if (iStack20 != iVar1) {
    *(ip_addr_t *)&old_addr->addr = iVar1;
    tcp_netif_ip_addr_changed(old_addr,&iStack20);
    udp_netif_ip_addr_changed(old_addr,&iStack20);
    raw_netif_ip_addr_changed(old_addr,&iStack20);
    (netif->ip_addr).addr = ipaddr->addr;
    netif_issue_reports(netif,'\x01');
    if (netif->status_callback != (netif_status_callback_fn *)0x0) {
      (*netif->status_callback)(netif);
    }
    return 1;
  }
  return 0;
}



void netif_init(void)

{
  return;
}



void netif_set_ipaddr(netif *netif,ip4_addr_t *ipaddr)

{
  ip_addr_t iStack20;
  ip_addr_t old_addr;
  
  if (netif != (netif *)0x0) {
    if (ipaddr == (ip4_addr_t *)0x0) {
      ipaddr = (ip4_addr_t *)&ip_addr_any;
    }
    netif_do_set_ipaddr(netif,ipaddr,&iStack20);
    return;
  }
  return;
}



void netif_set_netmask(netif *netif,ip4_addr_t *netmask)

{
  if (netif != (netif *)0x0) {
    if (netmask == (ip4_addr_t *)0x0) {
      netmask = (ip4_addr_t *)&ip_addr_any;
    }
    if (netmask->addr != (netif->netmask).addr) {
      (netif->netmask).addr = netmask->addr;
    }
  }
  return;
}



void netif_set_gw(netif *netif,ip4_addr_t *gw)

{
  if (netif != (netif *)0x0) {
    if (gw == (ip4_addr_t *)0x0) {
      gw = (ip4_addr_t *)&ip_addr_any;
    }
    if (gw->addr != (netif->gw).addr) {
      (netif->gw).addr = gw->addr;
    }
  }
  return;
}



// WARNING: Variable defined which should be unmapped: old_addr

void netif_set_addr(netif *netif,ip4_addr_t *ipaddr,ip4_addr_t *netmask,ip4_addr_t *gw)

{
  bool bVar1;
  ip_addr_t iStack20;
  ip_addr_t old_addr;
  
  if (ipaddr == (ip4_addr_t *)0x0) {
    ipaddr = (ip4_addr_t *)&ip_addr_any;
  }
  if (netmask == (ip4_addr_t *)0x0) {
    netmask = (ip4_addr_t *)&ip_addr_any;
  }
  if (gw == (ip4_addr_t *)0x0) {
    gw = (ip4_addr_t *)&ip_addr_any;
  }
  bVar1 = ipaddr->addr == 0;
  if (bVar1) {
    netif_do_set_ipaddr(netif,ipaddr,&iStack20);
  }
  if (netmask->addr != (netif->netmask).addr) {
    (netif->netmask).addr = netmask->addr;
  }
  if (gw->addr != (netif->gw).addr) {
    (netif->gw).addr = gw->addr;
  }
  if (!bVar1) {
    netif_do_set_ipaddr(netif,ipaddr,&iStack20);
  }
  return;
}



netif * netif_add(netif *netif,ip4_addr_t *ipaddr,ip4_addr_t *netmask,ip4_addr_t *gw,void *state,
                 netif_init_fn_conflict *init,netif_input_fn *input)

{
  u8_t uVar1;
  err_t eVar2;
  undefined3 extraout_var;
  netif *pnVar3;
  
  if ((netif != (netif *)0x0) && (init != (netif_init_fn_conflict *)0x0)) {
    if (ipaddr == (ip4_addr_t *)0x0) {
      ipaddr = (ip4_addr_t *)&ip_addr_any;
    }
    if (netmask == (ip4_addr_t *)0x0) {
      netmask = (ip4_addr_t *)&ip_addr_any;
    }
    if (gw == (ip4_addr_t *)0x0) {
      gw = (ip4_addr_t *)&ip_addr_any;
    }
    netif->output = netif_null_output_ip4;
    (netif->ip_addr).addr = 0;
    (netif->netmask).addr = 0;
    (netif->gw).addr = 0;
    netif->mtu = 0;
    netif->flags = '\0';
    memset(netif->client_data,0,0xc);
    netif->state = state;
    uVar1 = netif_num;
    netif->input = input;
    netif->num = uVar1;
    netif->status_callback = (netif_status_callback_fn *)0x0;
    netif->link_callback = (netif_status_callback_fn *)0x0;
    netif->igmp_mac_filter = (netif_igmp_mac_filter_fn *)0x0;
    netif_set_addr(netif,ipaddr,netmask,gw);
    eVar2 = (*init)(netif);
    if (CONCAT31(extraout_var,eVar2) == 0) {
      do {
        if (netif->num == -1) {
          netif->num = '\0';
        }
        uVar1 = netif->num;
        pnVar3 = netif_list;
        while( true ) {
          if (pnVar3 == (netif *)0x0) {
            netif_num = '\0';
            if (uVar1 != -2) {
              netif_num = uVar1 + '\x01';
            }
            netif->next = netif_list;
            if ((netif->flags & 0x20) == 0) {
              netif_list = netif;
              return netif;
            }
            netif_list = netif;
            igmp_start(netif);
            return netif;
          }
          if (pnVar3->num == uVar1) break;
          pnVar3 = pnVar3->next;
        }
        netif->num = uVar1 + '\x01';
      } while( true );
    }
  }
  return (netif *)0x0;
}



void netif_set_default(netif *netif)

{
  netif_default = netif;
  return;
}



void netif_set_up(netif *netif)

{
  if (netif == (netif *)0x0) {
    return;
  }
  if ((netif->flags & 1) == 0) {
    netif->flags = netif->flags | 1;
    if (netif->status_callback != (netif_status_callback_fn *)0x0) {
      (*netif->status_callback)(netif);
    }
    netif_issue_reports(netif,'\x03');
    return;
  }
  return;
}



void netif_set_down(netif *netif)

{
  byte bVar1;
  
  if (netif == (netif *)0x0) {
    return;
  }
  bVar1 = netif->flags;
  if ((bVar1 & 1) != 0) {
    netif->flags = bVar1 & 0xfe;
    if ((bVar1 & 8) != 0) {
      etharp_cleanup_netif(netif);
    }
    if (netif->status_callback != (netif_status_callback_fn *)0x0) {
                    // WARNING: Could not recover jumptable at 0x2303e28a. Too many branches
                    // WARNING: Treating indirect jump as call
      (*netif->status_callback)(netif);
      return;
    }
  }
  return;
}



void netif_remove(netif *netif)

{
  netif *pnVar1;
  ip_addr_t *old_addr;
  netif *pnVar2;
  
  if (netif == (netif *)0x0) {
    return;
  }
  if ((netif->ip_addr).addr != 0) {
    old_addr = &netif->ip_addr;
    tcp_netif_ip_addr_changed(old_addr,(ip_addr_t *)0x0);
    udp_netif_ip_addr_changed(old_addr,(ip_addr_t *)0x0);
    raw_netif_ip_addr_changed(old_addr,(ip_addr_t *)0x0);
  }
  if ((netif->flags & 0x20) != 0) {
    igmp_stop(netif);
  }
  if ((netif->flags & 1) != 0) {
    netif_set_down(netif);
  }
  if (netif_default == netif) {
    netif_default = (netif *)0x0;
  }
  pnVar1 = netif_list;
  if (netif_list == netif) {
    netif_list = netif->next;
  }
  else {
    do {
      pnVar2 = pnVar1;
      if (pnVar2 == (netif *)0x0) {
        return;
      }
      pnVar1 = pnVar2->next;
    } while (pnVar2->next != netif);
    pnVar2->next = netif->next;
  }
  return;
}



void netif_set_status_callback(netif *netif,netif_status_callback_fn *status_callback)

{
  if (netif != (netif *)0x0) {
    netif->status_callback = status_callback;
  }
  return;
}



void netif_set_link_up(netif *netif)

{
  if (netif == (netif *)0x0) {
    return;
  }
  if ((netif->flags & 4) == 0) {
    netif->flags = netif->flags | 4;
    dhcp_network_changed(netif);
    netif_issue_reports(netif,'\x03');
    if (netif->link_callback != (netif_status_callback_fn *)0x0) {
                    // WARNING: Could not recover jumptable at 0x2303e35c. Too many branches
                    // WARNING: Treating indirect jump as call
      (*netif->link_callback)(netif);
      return;
    }
  }
  return;
}



// WARNING: Exceeded maximum restarts with more pending

void netif_set_link_down(netif *netif)

{
  if (netif != (netif *)0x0) {
    if ((netif->flags & 4) != 0) {
      netif->flags = netif->flags & 0xfb;
      if (netif->link_callback != (netif_status_callback_fn *)0x0) {
                    // WARNING: Could not recover jumptable at 0x2303e382. Too many branches
                    // WARNING: Treating indirect jump as call
        (*netif->link_callback)();
        return;
      }
    }
  }
  return;
}



netif * netif_get_by_index(u8_t idx)

{
  undefined3 in_register_00002029;
  netif *pnVar1;
  netif *pnVar2;
  
  pnVar1 = netif_list;
  pnVar2 = (netif *)0x0;
  if (CONCAT31(in_register_00002029,idx) != 0) {
    while ((pnVar2 = pnVar1, pnVar1 != (netif *)0x0 &&
           (((uint)pnVar1->num + 1 & 0xff) != CONCAT31(in_register_00002029,idx)))) {
      pnVar1 = pnVar1->next;
    }
  }
  return pnVar2;
}



pbuf * pbuf_skip_const(pbuf *in,u16_t in_offset,u16_t *out_offset)

{
  pbuf *ppVar1;
  undefined2 in_register_0000202e;
  
  if ((in != (pbuf *)0x0) && ((uint)in->len <= CONCAT22(in_register_0000202e,in_offset))) {
    ppVar1 = pbuf_skip_const(in->next,(u16_t)((CONCAT22(in_register_0000202e,in_offset) -
                                              (uint)in->len) * 0x10000 >> 0x10),out_offset);
    return ppVar1;
  }
  if (out_offset != (u16_t *)0x0) {
    *out_offset = in_offset;
  }
  return in;
}



void pbuf_free_ooseq_callback(void *arg)

{
  tcp_pcb *pcb;
  
  sys_arch_protect();
  pbuf_free_ooseq_pending = '\0';
  sys_arch_unprotect();
  pcb = tcp_active_pcbs;
  while( true ) {
    if (pcb == (tcp_pcb *)0x0) {
      return;
    }
    if (pcb->ooseq != (tcp_seg *)0x0) break;
    pcb = pcb->next;
  }
  tcp_free_ooseq(pcb);
  return;
}



u8_t pbuf_add_header_impl(pbuf *p,size_t header_size_increment,u8_t force)

{
  u8_t uVar1;
  pbuf *ppVar2;
  undefined3 in_register_00002031;
  uint uVar3;
  
  if (p == (pbuf *)0x0) {
    uVar1 = '\x01';
  }
  else {
    uVar1 = '\x01';
    if ((header_size_increment < 0x10000) && (uVar1 = '\0', header_size_increment != 0)) {
      uVar3 = (uint)p->tot_len + (header_size_increment & 0xffff);
      uVar1 = '\x01';
      if ((header_size_increment & 0xffff) <= (uVar3 & 0xffff)) {
        if ((char)p->type_internal < '\0') {
          ppVar2 = (pbuf *)((int)p->payload - header_size_increment);
          if (ppVar2 < p + 1) {
            return '\x01';
          }
        }
        else {
          if (CONCAT31(in_register_00002031,force) == 0) {
            return '\x01';
          }
          ppVar2 = (pbuf *)((int)p->payload - header_size_increment);
        }
        *(pbuf **)&p->payload = ppVar2;
        p->tot_len = (u16_t)(uVar3 * 0x10000 >> 0x10);
        p->len = (short)header_size_increment + p->len;
        return '\0';
      }
    }
  }
  return uVar1;
}



pbuf * pbuf_alloc_reference(void *payload,u16_t length,pbuf_type type)

{
  pbuf *ppVar1;
  
  ppVar1 = (pbuf *)memp_malloc(MEMP_PBUF);
  if (ppVar1 != (pbuf *)0x0) {
    ppVar1->next = (pbuf *)0x0;
    ppVar1->payload = payload;
    ppVar1->tot_len = length;
    ppVar1->len = length;
    ppVar1->type_internal = (u8_t)type;
    ppVar1->flags = '\0';
    *(undefined2 *)&ppVar1->ref = 1;
  }
  return ppVar1;
}



pbuf * pbuf_alloced_custom(pbuf_layer l,u16_t length,pbuf_type type,pbuf_custom *p,void *payload_mem
                          ,u16_t payload_mem_len)

{
  undefined3 in_register_00002029;
  uint uVar1;
  undefined2 in_register_0000202e;
  undefined2 in_register_0000203e;
  
  uVar1 = CONCAT31(in_register_00002029,l) + 3U & 0xfffffffc;
  if (CONCAT22(in_register_0000202e,length) + uVar1 <=
      CONCAT22(in_register_0000203e,payload_mem_len)) {
    if (payload_mem != (void *)0x0) {
      payload_mem = (void *)((int)payload_mem + uVar1);
    }
    (p->pbuf).flags = '\x02';
    (p->pbuf).next = (pbuf *)0x0;
    (p->pbuf).payload = payload_mem;
    (p->pbuf).tot_len = length;
    (p->pbuf).len = length;
    (p->pbuf).type_internal = (u8_t)type;
    *(undefined2 *)&(p->pbuf).ref = 1;
    return (pbuf *)p;
  }
  return (pbuf *)0x0;
}



u8_t pbuf_add_header(pbuf *p,size_t header_size_increment)

{
  u8_t uVar1;
  
  uVar1 = pbuf_add_header_impl(p,header_size_increment,'\0');
  return uVar1;
}



u8_t pbuf_remove_header(pbuf *p,size_t header_size_decrement)

{
  u8_t uVar1;
  
  if (p == (pbuf *)0x0) {
    uVar1 = '\x01';
  }
  else {
    uVar1 = '\x01';
    if ((header_size_decrement < 0x10000) && (uVar1 = '\0', header_size_decrement != 0)) {
      uVar1 = '\x01';
      if ((header_size_decrement & 0xffff) <= (uint)p->len) {
        p->len = p->len - (short)header_size_decrement;
        p->payload = (void *)(header_size_decrement + (int)p->payload);
        p->tot_len = p->tot_len - (short)header_size_decrement;
        return '\0';
      }
    }
  }
  return uVar1;
}



u8_t pbuf_header(pbuf *p,s16_t header_size_increment)

{
  u8_t uVar1;
  short in_register_0000202e;
  
  if (in_register_0000202e < 0) {
    uVar1 = pbuf_remove_header(p,-CONCAT22(in_register_0000202e,header_size_increment));
    return uVar1;
  }
  uVar1 = pbuf_add_header_impl(p,CONCAT22(in_register_0000202e,header_size_increment),'\0');
  return uVar1;
}



u8_t pbuf_header_force(pbuf *p,s16_t header_size_increment)

{
  u8_t uVar1;
  short in_register_0000202e;
  
  if (in_register_0000202e < 0) {
    uVar1 = pbuf_remove_header(p,-CONCAT22(in_register_0000202e,header_size_increment));
    return uVar1;
  }
  uVar1 = pbuf_add_header_impl(p,CONCAT22(in_register_0000202e,header_size_increment),'\x01');
  return uVar1;
}



u8_t pbuf_free(pbuf *p)

{
  u8_t uVar1;
  u8_t uVar2;
  pbuf *ppVar3;
  memp_t type;
  byte bVar4;
  
  uVar1 = '\0';
  if (p != (pbuf *)0x0) {
    uVar1 = '\0';
    do {
      sys_arch_protect();
      uVar2 = p->ref + -1;
      p->ref = uVar2;
      sys_arch_unprotect();
      if (uVar2 != '\0') {
        return uVar1;
      }
      ppVar3 = p->next;
      if ((p->flags & 2) == 0) {
        type = MEMP_PBUF_POOL;
        bVar4 = p->type_internal & 0xf;
        if (bVar4 != 2) {
          if (bVar4 != 1) {
            if ((p->type_internal & 0xf) == 0) {
              mem_free(p);
            }
            goto LAB_2303e57c;
          }
          type = MEMP_PBUF;
        }
        memp_free(type,p);
      }
      else {
        (*(code *)p[1].next)(p,p[1].next);
      }
LAB_2303e57c:
      uVar1 = uVar1 + '\x01';
      p = ppVar3;
    } while (ppVar3 != (pbuf *)0x0);
  }
  return uVar1;
}



pbuf * pbuf_alloc(pbuf_layer layer,u16_t length,pbuf_type type)

{
  u8_t uVar1;
  uint uVar2;
  uint uVar3;
  pbuf *ppVar4;
  err_t eVar5;
  undefined3 in_register_00002029;
  pbuf *p;
  pbuf *ppVar6;
  undefined3 extraout_var;
  undefined2 in_register_0000202e;
  undefined2 in_register_00002032;
  uint uVar7;
  pbuf *ppVar8;
  
  uVar7 = CONCAT22(in_register_00002032,type);
  uVar3 = CONCAT22(in_register_0000202e,length);
  if (uVar7 != 0x41) {
    if (uVar7 < 0x42) {
      if (uVar7 == 1) goto LAB_2303e662;
    }
    else {
      uVar2 = CONCAT31(in_register_00002029,layer) & 0xffff;
      if (uVar7 == 0x182) {
        p = (pbuf *)0x0;
        ppVar8 = (pbuf *)0x0;
        while (ppVar6 = (pbuf *)memp_malloc(MEMP_PBUF_POOL), ppVar6 != (pbuf *)0x0) {
          uVar7 = 0x2f8 - (uVar2 + 3 & 0xfffffffc);
          if (uVar3 < (uVar7 & 0xffff)) {
            uVar7 = uVar3;
          }
          ppVar6->next = (pbuf *)0x0;
          ppVar6->payload = (void *)((int)&ppVar6[1].next + uVar2 + 3 & 0xfffffffc);
          ppVar6->tot_len = (u16_t)uVar3;
          ppVar6->len = (u16_t)uVar7;
          *(undefined4 *)&ppVar6->type_internal = 0x10082;
          ppVar4 = ppVar6;
          if (p != (pbuf *)0x0) {
            ppVar8->next = ppVar6;
            ppVar4 = p;
          }
          uVar3 = uVar3 - (uVar7 & 0xffff) & 0xffff;
          uVar2 = 0;
          p = ppVar4;
          ppVar8 = ppVar6;
          if (uVar3 == 0) {
            return ppVar4;
          }
        }
        sys_arch_protect();
        uVar1 = pbuf_free_ooseq_pending;
        pbuf_free_ooseq_pending = '\x01';
        sys_arch_unprotect();
        if ((uVar1 == '\0') &&
           (eVar5 = tcpip_try_callback(pbuf_free_ooseq_callback,(void *)0x0),
           CONCAT31(extraout_var,eVar5) != 0)) {
          sys_arch_protect();
          pbuf_free_ooseq_pending = '\0';
          sys_arch_unprotect();
        }
        if (p != (pbuf *)0x0) {
          pbuf_free(p);
        }
      }
      else {
        if (uVar7 == 0x280) {
          uVar7 = uVar3 + 3 & 0xfffffffc;
          uVar3 = (uVar2 + 3 & 0xfffffffc) + uVar7 & 0xffff;
          if ((uVar7 <= uVar3) && (uVar7 <= (uVar3 + 0x10 & 0xffff))) {
            p = (pbuf *)mem_malloc();
            if (p == (pbuf *)0x0) {
              return (pbuf *)0x0;
            }
            p->next = (pbuf *)0x0;
            p->payload = (void *)((int)&p[1].next + CONCAT31(in_register_00002029,layer) + 3 &
                                 0xfffffffc);
            p->tot_len = length;
            p->len = length;
            *(undefined4 *)&p->type_internal = 0x10080;
            return p;
          }
        }
      }
    }
    return (pbuf *)0x0;
  }
LAB_2303e662:
  p = pbuf_alloc_reference((void *)0x0,length,type);
  return p;
}



void pbuf_realloc(pbuf *p,u16_t new_len)

{
  ushort uVar1;
  uint uVar2;
  undefined2 in_register_0000202e;
  uint uVar3;
  
  uVar2 = CONCAT22(in_register_0000202e,new_len);
  uVar1 = p->tot_len;
  if (uVar2 < uVar1) {
    while (uVar3 = (uint)p->len, uVar3 < uVar2) {
      p->tot_len = p->tot_len + (new_len - uVar1);
      uVar2 = uVar2 - uVar3 & 0xffff;
      p = p->next;
    }
    if ((((p->type_internal & 0xf) == 0) && (uVar3 != uVar2)) && ((p->flags & 2) == 0)) {
      p = (pbuf *)mem_trim(p,(int)p->payload + (uVar2 - (int)p) & 0xffff);
    }
    p->len = (u16_t)uVar2;
    p->tot_len = (u16_t)uVar2;
    if (p->next != (pbuf *)0x0) {
      pbuf_free(p->next);
    }
    p->next = (pbuf *)0x0;
    return;
  }
  return;
}



u16_t pbuf_clen(pbuf *p)

{
  u16_t uVar1;
  
  uVar1 = 0;
  while (p != (pbuf *)0x0) {
    uVar1 = uVar1 + 1;
    p = p->next;
  }
  return uVar1;
}



void pbuf_ref(pbuf *p)

{
  if (p != (pbuf *)0x0) {
    sys_arch_protect();
    p->ref = p->ref + '\x01';
    sys_arch_unprotect();
    return;
  }
  return;
}



void pbuf_cat(pbuf *h,pbuf *t)

{
  pbuf *ppVar1;
  
  if (h != (pbuf *)0x0) {
    if (t == (pbuf *)0x0) {
      return;
    }
    do {
      ppVar1 = h;
      ppVar1->tot_len = (u16_t)(((uint)ppVar1->tot_len + (uint)t->tot_len) * 0x10000 >> 0x10);
      h = ppVar1->next;
    } while (ppVar1->next != (pbuf *)0x0);
    ppVar1->next = t;
  }
  return;
}



void pbuf_chain(pbuf *h,pbuf *t)

{
  pbuf_cat(h,t);
  pbuf_ref(t);
  return;
}



err_t pbuf_copy(pbuf *p_to,pbuf *p_from)

{
  err_t eVar1;
  uint uVar2;
  uint __n;
  uint uVar3;
  uint uVar4;
  
  if (p_to == (pbuf *)0x0) {
    return -0x10;
  }
  if ((p_from == (pbuf *)0x0) || (p_to->tot_len < p_from->tot_len)) {
LAB_2303e86a:
    eVar1 = -0x10;
  }
  else {
    uVar4 = 0;
    uVar3 = 0;
    do {
      __n = p_to->len - uVar3;
      uVar2 = p_from->len - uVar4;
      if (uVar2 < __n) {
        __n = uVar2;
      }
      memcpy((void *)((int)p_to->payload + uVar3),(void *)((int)p_from->payload + uVar4),__n);
      uVar4 = uVar4 + __n;
      uVar3 = uVar3 + __n;
      if (p_from->len <= uVar4) {
        p_from = p_from->next;
        uVar4 = 0;
      }
      if (uVar3 == (uint)p_to->len) {
        p_to = p_to->next;
        if (p_to == (pbuf *)0x0) {
          if (p_from == (pbuf *)0x0) {
            return '\0';
          }
          goto LAB_2303e86a;
        }
        uVar3 = 0;
      }
      if ((((p_from != (pbuf *)0x0) && (p_from->len == p_from->tot_len)) &&
          (p_from->next != (pbuf *)0x0)) ||
         ((p_to->len == p_to->tot_len && (p_to->next != (pbuf *)0x0)))) {
        return -6;
      }
    } while (p_from != (pbuf *)0x0);
    eVar1 = '\0';
  }
  return eVar1;
}



u16_t pbuf_copy_partial(pbuf *buf,void *dataptr,u16_t len,u16_t offset)

{
  u16_t uVar1;
  uint uVar2;
  uint uVar3;
  uint __n;
  undefined2 in_register_00002032;
  undefined2 in_register_00002036;
  uint uVar4;
  
  uVar4 = CONCAT22(in_register_00002036,offset);
  uVar3 = CONCAT22(in_register_00002032,len);
  uVar1 = 0;
  if (buf != (pbuf *)0x0) {
    uVar2 = 0;
    uVar1 = 0;
    if (dataptr != (void *)0x0) {
      while ((uVar1 = (u16_t)uVar2, uVar3 != 0 && (buf != (pbuf *)0x0))) {
        __n = (uint)buf->len;
        if ((uVar4 == 0) || (uVar4 < __n)) {
          __n = __n - uVar4 & 0xffff;
          if (uVar3 < __n) {
            __n = uVar3;
          }
          __n = __n & 0xffff;
          memcpy((void *)((int)dataptr + uVar2),(void *)((int)buf->payload + uVar4),__n);
          uVar2 = uVar2 + __n & 0xffff;
          uVar3 = uVar3 - __n & 0xffff;
          uVar4 = 0;
        }
        else {
          uVar4 = uVar4 - __n & 0xffff;
        }
        buf = buf->next;
      }
    }
  }
  return uVar1;
}



err_t pbuf_take(pbuf *buf,void *dataptr,u16_t len)

{
  uint uVar1;
  err_t eVar2;
  undefined2 in_register_00002032;
  uint __n;
  int iVar3;
  
  uVar1 = CONCAT22(in_register_00002032,len);
  if (buf != (pbuf *)0x0) {
    eVar2 = -0x10;
    if (dataptr != (void *)0x0) {
      eVar2 = -1;
      iVar3 = 0;
      if (uVar1 <= buf->tot_len) {
        while (uVar1 != 0) {
          __n = (uint)buf->len;
          if (uVar1 < (uint)buf->len) {
            __n = uVar1;
          }
          memcpy(buf->payload,(void *)((int)dataptr + iVar3),__n);
          buf = buf->next;
          uVar1 = uVar1 - __n;
          iVar3 = iVar3 + __n;
        }
        eVar2 = '\0';
      }
    }
    return eVar2;
  }
  return -0x10;
}



err_t pbuf_take_at(pbuf *buf,void *dataptr,u16_t len,u16_t offset)

{
  err_t eVar1;
  pbuf *ppVar2;
  undefined2 in_register_00002032;
  size_t sVar3;
  uint uVar4;
  uint uVar5;
  size_t __n;
  u16_t auStack34 [2];
  u16_t target_offset;
  
  sVar3 = CONCAT22(in_register_00002032,len);
  ppVar2 = pbuf_skip_const(buf,offset,auStack34);
  if (ppVar2 == (pbuf *)0x0) {
    eVar1 = -1;
  }
  else {
    uVar4 = (uint)auStack34[0];
    eVar1 = -1;
    if ((int)(uVar4 + sVar3) <= (int)(uint)ppVar2->tot_len) {
      uVar5 = ppVar2->len - uVar4;
      __n = sVar3;
      if ((int)uVar5 < (int)sVar3) {
        __n = uVar5 & 0xffff;
      }
      memcpy((void *)((int)ppVar2->payload + uVar4),dataptr,__n);
      eVar1 = '\0';
      if ((sVar3 - __n & 0xffff) != 0) {
        eVar1 = pbuf_take(ppVar2->next,(void *)((int)dataptr + __n),
                          (u16_t)((sVar3 - __n) * 0x10000 >> 0x10));
      }
    }
  }
  return eVar1;
}



pbuf * pbuf_clone(pbuf_layer layer,pbuf_type type,pbuf *p)

{
  pbuf *p_to;
  
  p_to = pbuf_alloc(layer,p->tot_len,type);
  if (p_to != (pbuf *)0x0) {
    pbuf_copy(p_to,p);
  }
  return p_to;
}



int pbuf_try_get_at(pbuf *p,u16_t offset)

{
  pbuf *ppVar1;
  uint uVar2;
  u16_t auStack18 [2];
  u16_t q_idx;
  
  ppVar1 = pbuf_skip_const(p,offset,auStack18);
  uVar2 = 0xffffffff;
  if (ppVar1 != (pbuf *)0x0) {
    uVar2 = 0xffffffff;
    if ((uint)auStack18[0] < (uint)ppVar1->len) {
      uVar2 = (uint)*(byte *)((int)ppVar1->payload + (uint)auStack18[0]);
    }
  }
  return uVar2;
}



void pbuf_put_at(pbuf *p,u16_t offset,u8_t data)

{
  pbuf *ppVar1;
  u16_t auStack18 [2];
  u16_t q_idx;
  
  ppVar1 = pbuf_skip_const(p,offset,auStack18);
  if ((ppVar1 != (pbuf *)0x0) && ((uint)auStack18[0] < (uint)ppVar1->len)) {
    *(u8_t *)((int)ppVar1->payload + (uint)auStack18[0]) = data;
  }
  return;
}



raw_input_state_t raw_input(pbuf *p,netif *inp)

{
  u8_t uVar1;
  raw_pcb *prVar2;
  raw_pcb *prVar3;
  u8_t uVar4;
  raw_input_state_t rVar5;
  u8_t uVar6;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  u32_t uVar7;
  raw_pcb *prVar8;
  
  uVar4 = ip4_addr_isbroadcast_u32(ip_data.current_iphdr_dest,ip_data.current_netif);
  uVar1 = *(u8_t *)((int)p->payload + 9);
  rVar5 = RAW_INPUT_NONE;
  prVar2 = raw_pcbs;
  prVar8 = (raw_pcb *)0x0;
  do {
    prVar3 = prVar2;
    if (prVar3 == (raw_pcb *)0x0) {
      return rVar5;
    }
    if ((prVar3->protocol == uVar1) &&
       ((prVar3->netif_idx == '\0' ||
        (prVar3->netif_idx == (u8_t)((ip_data.current_input_netif)->num + '\x01'))))) {
      uVar7 = (prVar3->local_ip).addr;
      if (CONCAT31(extraout_var,uVar4) == 0) {
        if ((uVar7 == 0) || (ip_data.current_iphdr_dest == uVar7)) goto LAB_2303eafa;
      }
      else {
        if (uVar7 == 0) {
LAB_2303eafa:
          if ((((prVar3->flags & 1) == 0) || ((prVar3->remote_ip).addr == ip_data.current_iphdr_src)
              ) && (prVar3->recv != (raw_recv_fn *)0x0)) {
            uVar6 = (*prVar3->recv)(prVar3->recv_arg,prVar3,p,(ip_addr_t *)0x4201a7a4);
            if (CONCAT31(extraout_var_00,uVar6) != 0) {
              if (prVar8 == (raw_pcb *)0x0) {
                return RAW_INPUT_EATEN;
              }
              prVar8->next = prVar3->next;
              prVar3->next = raw_pcbs;
              raw_pcbs = prVar3;
              return RAW_INPUT_EATEN;
            }
            rVar5 = RAW_INPUT_DELIVERED;
          }
        }
      }
    }
    prVar2 = prVar3->next;
    prVar8 = prVar3;
  } while( true );
}



void raw_netif_ip_addr_changed(ip_addr_t *old_addr,ip_addr_t *new_addr)

{
  raw_pcb *prVar1;
  
  if ((((old_addr != (ip_addr_t *)0x0) && (old_addr->addr != 0)) && (new_addr != (ip_addr_t *)0x0))
     && (prVar1 = raw_pcbs, new_addr->addr != 0)) {
    while (prVar1 != (raw_pcb *)0x0) {
      if ((prVar1->local_ip).addr == old_addr->addr) {
        (prVar1->local_ip).addr = new_addr->addr;
      }
      prVar1 = prVar1->next;
    }
  }
  return;
}



void stats_init(void)

{
  return;
}



err_t tcp_close_shutdown_fin(tcp_pcb *pcb)

{
  err_t eVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  tcp_state tVar2;
  
  tVar2 = pcb->state;
  if (tVar2 != ESTABLISHED) {
    if (tVar2 == CLOSE_WAIT) {
      eVar1 = tcp_send_fin(pcb);
      _eVar1 = CONCAT31(extraout_var_00,eVar1);
      if (_eVar1 != 0) goto LAB_2303ebd0;
      tVar2 = LAST_ACK;
      goto LAB_2303ebae;
    }
    if (tVar2 != SYN_RCVD) {
      return '\0';
    }
  }
  eVar1 = tcp_send_fin(pcb);
  _eVar1 = CONCAT31(extraout_var,eVar1);
  if (_eVar1 != 0) {
LAB_2303ebd0:
    if (_eVar1 == -1) {
      pcb->flags = pcb->flags | 8;
      return '\0';
    }
    return (err_t)_eVar1;
  }
  tVar2 = FIN_WAIT_1;
LAB_2303ebae:
  pcb->state = tVar2;
  tcp_output(pcb);
  return '\0';
}



void tcp_init(void)

{
  uint uVar1;
  
  uVar1 = bl_rand();
  tcp_port = (u16_t)(((uVar1 & 0x3fff) - 0x4000) * 0x10000 >> 0x10);
  printf("-------------------->>>>>>>> LWIP tcp_port %u\r\n");
  return;
}



void tcp_free(tcp_pcb *pcb)

{
  memp_free(MEMP_TCP_PCB,pcb);
  return;
}



u32_t tcp_update_rcv_ann_wnd(tcp_pcb *pcb)

{
  u32_t uVar1;
  u32_t uVar2;
  u32_t uVar3;
  uint uVar4;
  
  uVar3 = pcb->rcv_ann_right_edge;
  uVar2 = pcb->rcv_nxt;
  uVar4 = (uint)pcb->mss;
  uVar1 = (pcb->rcv_wnd - uVar3) + uVar2;
  if (0x408 < pcb->mss) {
    uVar4 = 0x408;
  }
  if (-1 < (int)(uVar1 - uVar4)) {
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
    return uVar1;
  }
  if ((int)(uVar2 - uVar3) < 1) {
    pcb->rcv_ann_wnd = (short)uVar3 - (short)uVar2;
  }
  else {
    pcb->rcv_ann_wnd = 0;
  }
  return 0;
}



void tcp_recved(tcp_pcb *pcb,u16_t len)

{
  u32_t uVar1;
  tcpwnd_size_t tVar2;
  
  if (pcb == (tcp_pcb *)0x0) {
    return;
  }
  tVar2 = len + pcb->rcv_wnd;
  if ((0x810 < tVar2) || (tVar2 < pcb->rcv_wnd)) {
    tVar2 = 0x810;
  }
  pcb->rcv_wnd = tVar2;
  uVar1 = tcp_update_rcv_ann_wnd(pcb);
  if (0x407 < uVar1) {
    pcb->flags = pcb->flags | 2;
    tcp_output(pcb);
    return;
  }
  return;
}



void tcp_seg_free(tcp_seg *seg)

{
  if (seg == (tcp_seg *)0x0) {
    return;
  }
  if (seg->p != (pbuf *)0x0) {
    pbuf_free(seg->p);
  }
  memp_free(MEMP_TCP_SEG,seg);
  return;
}



void tcp_segs_free(tcp_seg *seg)

{
  tcp_seg *ptVar1;
  
  if (seg != (tcp_seg *)0x0) {
    do {
      ptVar1 = seg->next;
      tcp_seg_free(seg);
      seg = ptVar1;
    } while (ptVar1 != (tcp_seg *)0x0);
    return;
  }
  return;
}



tcp_seg * tcp_seg_copy(tcp_seg *seg)

{
  tcp_seg *__dest;
  
  __dest = (tcp_seg *)memp_malloc(MEMP_TCP_SEG);
  if (__dest != (tcp_seg *)0x0) {
    memcpy(__dest,seg,0x14);
    pbuf_ref(__dest->p);
  }
  return __dest;
}



u32_t tcp_next_iss(tcp_pcb *pcb)

{
  u32_t iss;
  
  return iss + tcp_ticks;
}



u16_t tcp_eff_send_mss_netif(u16_t sendmss,netif *outif,ip_addr_t *dest)

{
  ushort uVar1;
  u16_t uVar2;
  undefined2 in_register_0000202a;
  uint uVar3;
  
  uVar2 = sendmss;
  if (outif != (netif *)0x0) {
    uVar1 = outif->mtu;
    if (((uVar1 != 0) && (uVar2 = 0, 0x28 < uVar1)) &&
       (uVar3 = (uint)uVar1 - 0x28 & 0xffff, uVar2 = (u16_t)uVar3,
       CONCAT22(in_register_0000202a,sendmss) < uVar3)) {
      uVar2 = sendmss;
    }
  }
  return uVar2;
}



void tcp_free_ooseq(tcp_pcb *pcb)

{
  if (pcb->ooseq != (tcp_seg *)0x0) {
    tcp_segs_free(pcb->ooseq);
    pcb->ooseq = (tcp_seg *)0x0;
    return;
  }
  return;
}



void tcp_pcb_purge(tcp_pcb *pcb)

{
  if (((pcb != (tcp_pcb *)0x0) && (LISTEN < pcb->state)) && (pcb->state != TIME_WAIT)) {
    if (pcb->refused_data != (pbuf *)0x0) {
      pbuf_free(pcb->refused_data);
      pcb->refused_data = (pbuf *)0x0;
    }
    if (pcb->ooseq != (tcp_seg *)0x0) {
      tcp_free_ooseq(pcb);
    }
    pcb->rtime = -1;
    tcp_segs_free(pcb->unsent);
    tcp_segs_free(pcb->unacked);
    pcb->unsent = (tcp_seg *)0x0;
    pcb->unacked = (tcp_seg *)0x0;
    pcb->unsent_oversize = 0;
    return;
  }
  return;
}



void tcp_pcb_remove(tcp_pcb **pcblist,tcp_pcb *pcb)

{
  tcp_pcb *ptVar1;
  tcp_pcb *ptVar2;
  
  ptVar1 = *pcblist;
  if (*pcblist == pcb) {
    *pcblist = pcb->next;
  }
  else {
    do {
      ptVar2 = ptVar1;
      if (ptVar2 == (tcp_pcb *)0x0) goto LAB_2303edf0;
      ptVar1 = ptVar2->next;
    } while (ptVar2->next != pcb);
    ptVar2->next = pcb->next;
  }
LAB_2303edf0:
  pcb->next = (tcp_pcb *)0x0;
  tcp_pcb_purge(pcb);
  if (((pcb->state != TIME_WAIT) && (pcb->state != LISTEN)) && ((pcb->flags & 1) != 0)) {
    pcb->flags = pcb->flags | 2;
    tcp_output(pcb);
  }
  pcb->state = CLOSED;
  pcb->local_port = 0;
  return;
}



void tcp_abandon(tcp_pcb *pcb,int reset)

{
  tcp_pcb *ptVar1;
  u16_t uVar2;
  tcp_pcb *ptVar3;
  tcp_err_fn *UNRECOVERED_JUMPTABLE;
  void *pvVar4;
  u32_t seqno;
  u32_t ackno;
  
  if (pcb == (tcp_pcb *)0x0) {
    return;
  }
  if (pcb->state == TIME_WAIT) {
    tcp_pcb_remove(&tcp_tw_pcbs,pcb);
    tcp_free(pcb);
    return;
  }
  seqno = pcb->snd_nxt;
  ackno = pcb->rcv_nxt;
  UNRECOVERED_JUMPTABLE = pcb->errf;
  pvVar4 = pcb->callback_arg;
  uVar2 = pcb->local_port;
  if (pcb->state == CLOSED) {
    reset = 0;
    if (uVar2 != 0) {
      ptVar1 = tcp_bound_pcbs;
      if (tcp_bound_pcbs == pcb) {
        tcp_bound_pcbs = pcb->next;
      }
      else {
        do {
          ptVar3 = ptVar1;
          if (ptVar3 == (tcp_pcb *)0x0) goto LAB_2303eeb6;
          ptVar1 = ptVar3->next;
        } while (ptVar3->next != pcb);
        ptVar3->next = pcb->next;
      }
LAB_2303eeb6:
      pcb->next = (tcp_pcb *)0x0;
      uVar2 = 0;
      reset = 0;
    }
  }
  else {
    tcp_pcb_remove(&tcp_active_pcbs,pcb);
    tcp_active_pcbs_changed = '\x01';
  }
  if (pcb->unacked != (tcp_seg *)0x0) {
    tcp_segs_free(pcb->unacked);
  }
  if (pcb->unsent != (tcp_seg *)0x0) {
    tcp_segs_free(pcb->unsent);
  }
  if (pcb->ooseq != (tcp_seg *)0x0) {
    tcp_segs_free(pcb->ooseq);
  }
  if (reset != 0) {
    tcp_rst(pcb,seqno,ackno,(ip_addr_t *)pcb,&pcb->remote_ip,uVar2,pcb->remote_port);
  }
  tcp_free(pcb);
  if (UNRECOVERED_JUMPTABLE == (tcp_err_fn *)0x0) {
    return;
  }
                    // WARNING: Could not recover jumptable at 0x2303ef12. Too many branches
                    // WARNING: Treating indirect jump as call
  (*UNRECOVERED_JUMPTABLE)(pvVar4,-0xd);
  return;
}



void tcp_abort(tcp_pcb *pcb)

{
  tcp_abandon(pcb,1);
  return;
}



void tcp_netif_ip_addr_changed_pcblist(tcp_pcb *pcb_list)

{
  tcp_pcb *in_a1;
  tcp_pcb *pcb;
  
  while (pcb = in_a1, pcb != (tcp_pcb *)0x0) {
    in_a1 = pcb->next;
    if ((pcb->local_ip).addr == (pcb_list->local_ip).addr) {
      tcp_abort(pcb);
    }
  }
  return;
}



void tcp_netif_ip_addr_changed(ip_addr_t *old_addr,ip_addr_t *new_addr)

{
  u32_t *puVar1;
  
  if (old_addr == (ip_addr_t *)0x0) {
    return;
  }
  if (old_addr->addr != 0) {
    tcp_netif_ip_addr_changed_pcblist((tcp_pcb *)old_addr);
    tcp_netif_ip_addr_changed_pcblist((tcp_pcb *)old_addr);
    if ((new_addr != (ip_addr_t *)0x0) && (puVar1 = tcp_listen_pcbs, new_addr->addr != 0)) {
      while (puVar1 != (u32_t *)0x0) {
        if (*puVar1 == old_addr->addr) {
          *puVar1 = new_addr->addr;
        }
        puVar1 = (u32_t *)puVar1[3];
      }
    }
  }
  return;
}



void tcp_kill_state(tcp_state state)

{
  undefined3 in_register_00002029;
  uint uVar1;
  tcp_pcb *pcb;
  uint uVar2;
  tcp_pcb *ptVar3;
  
  uVar1 = 0;
  pcb = (tcp_pcb *)0x0;
  ptVar3 = tcp_active_pcbs;
  while (ptVar3 != (tcp_pcb *)0x0) {
    if (((uint)ptVar3->state == CONCAT31(in_register_00002029,state)) &&
       (uVar2 = tcp_ticks - ptVar3->tmr, uVar1 <= uVar2)) {
      uVar1 = uVar2;
      pcb = ptVar3;
    }
    ptVar3 = ptVar3->next;
  }
  if (pcb != (tcp_pcb *)0x0) {
    tcp_abandon(pcb,0);
    return;
  }
  return;
}



tcp_pcb * tcp_alloc(u8_t prio)

{
  u32_t uVar1;
  tcp_pcb *pcb;
  undefined3 in_register_00002029;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  tcp_pcb *ptVar5;
  int iVar6;
  
  iVar6 = CONCAT31(in_register_00002029,prio);
  pcb = (tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
  ptVar5 = tcp_active_pcbs;
  if (pcb != (tcp_pcb *)0x0) goto LAB_2303f0e6;
  while (pcb = ptVar5, pcb != (tcp_pcb *)0x0) {
    ptVar5 = pcb->next;
    if ((pcb->flags & 8) != 0) {
      pcb->flags = pcb->flags & 0xfff7;
      tcp_close_shutdown_fin(pcb);
    }
  }
  uVar3 = 0;
  ptVar5 = tcp_tw_pcbs;
  while (ptVar5 != (tcp_pcb *)0x0) {
    uVar4 = tcp_ticks - ptVar5->tmr;
    if (uVar3 <= uVar4) {
      pcb = ptVar5;
      uVar3 = uVar4;
    }
    ptVar5 = ptVar5->next;
  }
  if (pcb != (tcp_pcb *)0x0) {
    tcp_abort(pcb);
  }
  pcb = (tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
  if (pcb == (tcp_pcb *)0x0) {
    tcp_kill_state(LAST_ACK);
    pcb = (tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    if (pcb == (tcp_pcb *)0x0) {
      tcp_kill_state(CLOSING);
      pcb = (tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
      if (pcb == (tcp_pcb *)0x0) {
        if ((char)prio < '\0') {
          iVar6 = 0x7f;
LAB_2303f1a8:
          uVar3 = iVar6 - 1U & 0xff;
          uVar4 = 0;
          ptVar5 = tcp_active_pcbs;
          while (ptVar5 != (tcp_pcb *)0x0) {
            uVar2 = (uint)ptVar5->prio;
            if ((uVar2 < uVar3) || ((uVar2 == uVar3 && (uVar4 <= tcp_ticks - ptVar5->tmr)))) {
              uVar4 = tcp_ticks - ptVar5->tmr;
              pcb = ptVar5;
              uVar3 = uVar2;
            }
            ptVar5 = ptVar5->next;
          }
          if (pcb != (tcp_pcb *)0x0) {
            tcp_abort(pcb);
          }
        }
        else {
          if (iVar6 != 0) goto LAB_2303f1a8;
        }
        pcb = (tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
        if (pcb == (tcp_pcb *)0x0) {
          return (tcp_pcb *)0x0;
        }
        lwip_stats.memp[2]->err = lwip_stats.memp[2]->err - 1;
      }
      lwip_stats.memp[2]->err = lwip_stats.memp[2]->err - 1;
    }
    lwip_stats.memp[2]->err = lwip_stats.memp[2]->err - 1;
  }
  lwip_stats.memp[2]->err = lwip_stats.memp[2]->err - 1;
LAB_2303f0e6:
  memset(pcb,0,0xa4);
  pcb->snd_buf = 0x1580;
  *(undefined4 *)&pcb->rcv_wnd = 0x8100810;
  pcb->ttl = -1;
  pcb->rto = 6;
  pcb->sv = 6;
  *(undefined4 *)&pcb->rtime = 0x218ffff;
  uVar1 = tcp_ticks;
  pcb->prio = prio;
  pcb->tmr = uVar1;
  pcb->last_timer = tcp_timer_ctr;
  *(undefined4 *)&pcb->cwnd = 0x15800001;
  pcb->recv = tcp_recv_null;
  pcb->keep_idle = 7200000;
  pcb->keep_intvl = 75000;
  pcb->keep_cnt = 9;
  return pcb;
}



err_t tcp_close_shutdown(tcp_pcb *pcb,u8_t rst_on_unacked_data)

{
  tcp_state tVar1;
  err_t eVar2;
  undefined3 in_register_0000202d;
  tcp_pcb *ptVar3;
  tcp_pcb *ptVar4;
  tcp_pcb ***ppptVar5;
  
  tVar1 = pcb->state;
  if (((CONCAT31(in_register_0000202d,rst_on_unacked_data) == 0) ||
      ((tVar1 != ESTABLISHED && (tVar1 != CLOSE_WAIT)))) ||
     ((pcb->refused_data == (pbuf *)0x0 && (pcb->rcv_wnd == 0x810)))) {
    if (tVar1 == LISTEN) {
      ppptVar5 = tcp_pcb_lists;
      do {
        ptVar3 = *ppptVar5[1];
        while (ptVar3 != (tcp_pcb *)0x0) {
          if (pcb == (tcp_pcb *)ptVar3->listener) {
            ptVar3->listener = (tcp_pcb_listen *)0x0;
          }
          ptVar3 = ptVar3->next;
        }
        ppptVar5 = ppptVar5 + 1;
      } while (ppptVar5 != (tcp_pcb ***)0x2307acb4);
      tcp_pcb_remove((tcp_pcb **)&tcp_listen_pcbs,pcb);
      memp_free(MEMP_TCP_PCB_LISTEN,pcb);
      return '\0';
    }
    if (tVar1 == CLOSED) {
      if (pcb->local_port != 0) {
        ptVar3 = tcp_bound_pcbs;
        if (tcp_bound_pcbs == pcb) {
          tcp_bound_pcbs = pcb->next;
        }
        else {
          do {
            ptVar4 = ptVar3;
            if (ptVar4 == (tcp_pcb *)0x0) goto LAB_2303f2b6;
            ptVar3 = ptVar4->next;
          } while (ptVar4->next != pcb);
          ptVar4->next = pcb->next;
        }
LAB_2303f2b6:
        pcb->next = (tcp_pcb *)0x0;
      }
    }
    else {
      if (tVar1 != SYN_SENT) {
        eVar2 = tcp_close_shutdown_fin(pcb);
        return eVar2;
      }
      tcp_pcb_remove(&tcp_active_pcbs,pcb);
      tcp_active_pcbs_changed = '\x01';
    }
  }
  else {
    tcp_rst(pcb,pcb->snd_nxt,pcb->rcv_nxt,(ip_addr_t *)pcb,&pcb->remote_ip,pcb->local_port,
            pcb->remote_port);
    tcp_pcb_purge(pcb);
    ptVar3 = tcp_active_pcbs;
    if (tcp_active_pcbs == pcb) {
      tcp_active_pcbs = pcb->next;
    }
    else {
      do {
        ptVar4 = ptVar3;
        if (ptVar4 == (tcp_pcb *)0x0) goto LAB_2303f248;
        ptVar3 = ptVar4->next;
      } while (ptVar4->next != pcb);
      ptVar4->next = pcb->next;
    }
LAB_2303f248:
    ptVar3 = tcp_input_pcb;
    tcp_active_pcbs_changed = '\x01';
    pcb->next = (tcp_pcb *)0x0;
    if (ptVar3 == pcb) {
      tcp_trigger_input_pcb_close();
      return '\0';
    }
  }
  tcp_free(pcb);
  return '\0';
}



err_t tcp_close(tcp_pcb *pcb)

{
  err_t eVar1;
  
  if (pcb != (tcp_pcb *)0x0) {
    if (pcb->state != LISTEN) {
      pcb->flags = pcb->flags | 0x10;
    }
    eVar1 = tcp_close_shutdown(pcb,'\x01');
    return eVar1;
  }
  return -0x10;
}



err_t tcp_recv_null(void *arg,tcp_pcb *pcb,pbuf *p,err_t err)

{
  err_t eVar1;
  undefined3 in_register_00002035;
  
  if (pcb == (tcp_pcb *)0x0) {
    return -0x10;
  }
  if (p != (pbuf *)0x0) {
    tcp_recved(pcb,p->tot_len);
    pbuf_free(p);
    return '\0';
  }
  if (CONCAT31(in_register_00002035,err) == 0) {
    eVar1 = tcp_close(pcb);
    return eVar1;
  }
  return '\0';
}



err_t tcp_process_refused_data(tcp_pcb *pcb)

{
  byte bVar1;
  err_t eVar2;
  err_t eVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  pbuf *p;
  
  if (pcb == (tcp_pcb *)0x0) {
    return -0x10;
  }
  p = pcb->refused_data;
  bVar1 = p->flags;
  pcb->refused_data = (pbuf *)0x0;
  if (pcb->recv == (tcp_recv_fn *)0x0) {
    eVar2 = tcp_recv_null((void *)0x0,pcb,p,'\0');
    _eVar2 = CONCAT31(extraout_var_01,eVar2);
  }
  else {
    eVar2 = (*pcb->recv)(pcb->callback_arg,pcb,p,'\0');
    _eVar2 = CONCAT31(extraout_var,eVar2);
  }
  eVar2 = (err_t)_eVar2;
  if (_eVar2 == 0) {
    if ((bVar1 & 0x20) == 0) {
      return eVar2;
    }
    if (pcb->rcv_wnd != 0x810) {
      pcb->rcv_wnd = pcb->rcv_wnd + 1;
    }
    if (pcb->recv == (tcp_recv_fn *)0x0) {
      return eVar2;
    }
    eVar3 = (*pcb->recv)(pcb->callback_arg,pcb,(pbuf *)0x0,'\0');
    if (CONCAT31(extraout_var_00,eVar3) != -0xd) {
      return eVar2;
    }
  }
  else {
    if (_eVar2 != -0xd) {
      pcb->refused_data = p;
      return -5;
    }
  }
  return -0xd;
}



void tcp_fasttmr(void)

{
  tcp_pcb *pcb;
  tcp_pcb *ptVar1;
  
  tcp_timer_ctr = tcp_timer_ctr + '\x01';
  pcb = tcp_active_pcbs;
  while( true ) {
    if (pcb == (tcp_pcb *)0x0) {
      return;
    }
    if (pcb->last_timer == tcp_timer_ctr) break;
    pcb->last_timer = tcp_timer_ctr;
    if ((pcb->flags & 1) != 0) {
      pcb->flags = pcb->flags | 2;
      tcp_output(pcb);
      pcb->flags = pcb->flags & 0xfffc;
    }
    if ((pcb->flags & 8) != 0) {
      pcb->flags = pcb->flags & 0xfff7;
      tcp_close_shutdown_fin(pcb);
    }
    ptVar1 = pcb->next;
    if (pcb->refused_data == (pbuf *)0x0) goto LAB_2303f4ac;
    tcp_active_pcbs_changed = '\0';
    tcp_process_refused_data(pcb);
    pcb = tcp_active_pcbs;
    if (tcp_active_pcbs_changed == '\0') {
LAB_2303f4ac:
      pcb = ptVar1;
    }
  }
  ptVar1 = pcb->next;
  goto LAB_2303f4ac;
}



void tcp_slowtmr(void)

{
  tcp_state tVar1;
  short sVar2;
  tcp_pcb *pcb;
  uint uVar3;
  tcp_err_fn *ptVar4;
  err_t eVar5;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  uint uVar6;
  byte bVar7;
  uint uVar8;
  u32_t uVar9;
  byte bVar10;
  s16_t sVar11;
  void *pvVar12;
  tcp_pcb *ptVar13;
  tcp_pcb *pcb_00;
  
  tcp_ticks = tcp_ticks + 1;
  tcp_timer_ctr = tcp_timer_ctr + '\x01';
  do {
    pcb_00 = tcp_active_pcbs;
    ptVar13 = (tcp_pcb *)0x0;
LAB_2303f51a:
    do {
      while( true ) {
        pcb = pcb_00;
        pcb_00 = tcp_tw_pcbs;
        if (pcb == (tcp_pcb *)0x0) {
          while (pcb_00 != (tcp_pcb *)0x0) {
            if (tcp_ticks - pcb_00->tmr < 0xf1) {
              pcb = pcb_00;
              pcb_00 = pcb_00->next;
            }
            else {
              tcp_pcb_purge(pcb_00);
              ptVar13 = pcb_00->next;
              if (pcb != (tcp_pcb *)0x0) {
                pcb->next = pcb_00->next;
                ptVar13 = tcp_tw_pcbs;
              }
              tcp_tw_pcbs = ptVar13;
              ptVar13 = pcb_00->next;
              tcp_free(pcb_00);
              pcb_00 = ptVar13;
            }
          }
          return;
        }
        if (pcb->last_timer != tcp_timer_ctr) break;
        pcb_00 = pcb->next;
        ptVar13 = pcb;
      }
      pcb->last_timer = tcp_timer_ctr;
      if (pcb->state == SYN_SENT) {
        bVar7 = 5;
      }
      else {
        bVar7 = 0xb;
      }
      uVar3 = 1;
      if (pcb->nrtx <= bVar7) {
        uVar3 = (uint)pcb->persist_backoff;
        if (pcb->persist_backoff == 0) {
          sVar2 = pcb->rtime;
          if (sVar2 < 0) {
LAB_2303f770:
            if (pcb->rtime < pcb->rto) goto LAB_2303f5ca;
          }
          else {
            if (sVar2 != 0x7fff) {
              pcb->rtime = sVar2 + 1;
              goto LAB_2303f770;
            }
          }
          eVar5 = tcp_rexmit_rto_prepare(pcb);
          if ((CONCAT31(extraout_var_02,eVar5) == 0) ||
             ((pcb->unacked == (tcp_seg *)0x0 && (pcb->unsent != (tcp_seg *)0x0)))) {
            if (pcb->state != SYN_SENT) {
              uVar6 = (uint)pcb->nrtx;
              if (0xc < pcb->nrtx) {
                uVar6 = 0xc;
              }
              _sVar11 = ((int)pcb->sa >> 3) + (int)pcb->sv <<
                        ((uint)"\x01\x02\x03\x04\x05\x06\a\a\a\a\a\a\a"[uVar6] & 0x1f);
              sVar11 = (s16_t)_sVar11;
              if (0x7ffe < _sVar11) {
                sVar11 = 0x7fff;
              }
              pcb->rto = sVar11;
            }
            pcb->rtime = 0;
            uVar6 = (uint)pcb->snd_wnd;
            if ((uint)pcb->cwnd < (uint)pcb->snd_wnd) {
              uVar6 = (uint)pcb->cwnd;
            }
            uVar8 = (uint)pcb->mss << 0x11;
            pcb->ssthresh = (tcpwnd_size_t)(uVar6 >> 1);
            if (uVar6 >> 1 < uVar8 >> 0x10) {
              pcb->ssthresh = (tcpwnd_size_t)(uVar8 >> 0x10);
            }
            pcb->cwnd = pcb->mss;
            pcb->bytes_acked = 0;
            tcp_rexmit_rto_commit(pcb);
            goto LAB_2303f5cc;
          }
        }
        else {
          if (0xb < pcb->persist_probe) {
            uVar3 = 1;
            goto LAB_2303f5cc;
          }
          bVar7 = *(byte *)((int)&ip_addr_broadcast.addr + uVar3 + 3);
          if ((bVar7 <= pcb->persist_cnt) ||
             (bVar10 = pcb->persist_cnt + 1, pcb->persist_cnt = bVar10, bVar7 <= bVar10)) {
            if (pcb->snd_wnd == 0) {
              eVar5 = tcp_zero_window_probe(pcb);
              if (CONCAT31(extraout_var_01,eVar5) == 0) goto LAB_2303f6ba;
            }
            else {
              eVar5 = tcp_split_unsent_seg(pcb,pcb->snd_wnd);
              if ((CONCAT31(extraout_var,eVar5) != 0) ||
                 (eVar5 = tcp_output(pcb), CONCAT31(extraout_var_00,eVar5) != 0)) {
LAB_2303f6ba:
                pcb->persist_cnt = '\0';
                if (pcb->persist_backoff < 7) {
                  pcb->persist_backoff = pcb->persist_backoff + 1;
                }
              }
            }
          }
        }
LAB_2303f5ca:
        uVar3 = 0;
      }
LAB_2303f5cc:
      tVar1 = pcb->state;
      if (((tVar1 == FIN_WAIT_2) && ((pcb->flags & 0x10) != 0)) && (0x28 < tcp_ticks - pcb->tmr)) {
        uVar3 = uVar3 + 1 & 0xff;
      }
      bVar7 = pcb->so_options & 8;
      if (((pcb->so_options & 8) != 0) &&
         ((tVar1 == ESTABLISHED || (bVar7 = 0, tVar1 == CLOSE_WAIT)))) {
        uVar6 = tcp_ticks - pcb->tmr;
        if ((pcb->keep_intvl * pcb->keep_cnt + pcb->keep_idle) / 500 < uVar6) {
          uVar3 = uVar3 + 1 & 0xff;
          bVar7 = 1;
        }
        else {
          bVar7 = 0;
          if ((((uint)pcb->keep_cnt_sent * pcb->keep_intvl + pcb->keep_idle) / 500 < uVar6) &&
             (eVar5 = tcp_keepalive(pcb), bVar7 = 0, CONCAT31(extraout_var_03,eVar5) == 0)) {
            pcb->keep_cnt_sent = pcb->keep_cnt_sent + '\x01';
          }
        }
      }
      if ((pcb->ooseq != (tcp_seg *)0x0) && ((uint)((int)pcb->rto * 6) <= tcp_ticks - pcb->tmr)) {
        tcp_free_ooseq(pcb);
      }
      tVar1 = pcb->state;
      if (tVar1 == SYN_RCVD) {
        if (0x28 < tcp_ticks - pcb->tmr) {
          uVar3 = uVar3 + 1 & 0xff;
        }
LAB_2303f67c:
        if (uVar3 == 0) {
          pcb_00 = pcb->next;
          bVar7 = pcb->polltmr + 1;
          pcb->polltmr = bVar7;
          ptVar13 = pcb;
          if (pcb->pollinterval <= bVar7) {
            pcb->polltmr = '\0';
            tcp_active_pcbs_changed = '\0';
            if (pcb->poll != (tcp_poll_fn *)0x0) {
              eVar5 = (*pcb->poll)(pcb->callback_arg,pcb);
              if (tcp_active_pcbs_changed != '\0') break;
              if (CONCAT31(extraout_var_04,eVar5) != 0) goto LAB_2303f51a;
            }
            tcp_output(pcb);
          }
          goto LAB_2303f51a;
        }
      }
      else {
        if (tVar1 == LAST_ACK) {
          uVar9 = pcb->tmr;
          uVar6 = 0xf0;
        }
        else {
          if ((tVar1 != FIN_WAIT_1) && (tVar1 != CLOSING)) goto LAB_2303f67c;
          uVar9 = pcb->tmr;
          uVar6 = 10;
        }
        if (tcp_ticks - uVar9 <= uVar6) goto LAB_2303f67c;
      }
      ptVar4 = pcb->errf;
      tcp_pcb_purge(pcb);
      pcb_00 = pcb->next;
      if (ptVar13 != (tcp_pcb *)0x0) {
        ptVar13->next = pcb->next;
        pcb_00 = tcp_active_pcbs;
      }
      tcp_active_pcbs = pcb_00;
      if (bVar7 != 0) {
        tcp_rst(pcb,pcb->snd_nxt,pcb->rcv_nxt,(ip_addr_t *)pcb,&pcb->remote_ip,pcb->local_port,
                pcb->remote_port);
      }
      pvVar12 = pcb->callback_arg;
      pcb_00 = pcb->next;
      tcp_free(pcb);
      tcp_active_pcbs_changed = '\0';
    } while ((ptVar4 == (tcp_err_fn *)0x0) ||
            ((*ptVar4)(pvVar12,-0xd), tcp_active_pcbs_changed == '\0'));
  } while( true );
}



void tcp_tmr(void)

{
  tcp_fasttmr();
  tcp_timer = tcp_timer + 1;
  if ((tcp_timer & 1) != 0) {
    tcp_slowtmr();
    return;
  }
  return;
}



u8_t tcp_get_next_optbyte(void)

{
  uint uVar1;
  
  uVar1 = (uint)tcp_optidx;
  if ((tcphdr_opt2 != (u8_t *)0x0) && (tcphdr_opt1len <= uVar1)) {
    tcp_optidx = tcp_optidx + 1;
    return tcphdr_opt2[uVar1 - tcphdr_opt1len & 0xff];
  }
  tcp_optidx = tcp_optidx + 1;
  return *(u8_t *)((int)&tcphdr[1].src + uVar1);
}



void tcp_oos_insert_segment(tcp_seg *cseg,tcp_seg *next)

{
  u32_t uVar1;
  ushort uVar2;
  tcp_seg *ptVar3;
  u16_t new_len;
  int iVar4;
  tcp_hdr *ptVar5;
  
  new_len = lwip_htons(cseg->tcphdr->_hdrlen_rsvd_flags);
  if ((new_len & 1) == 0) {
    do {
      iVar4 = cseg->len + seqno;
      uVar1 = next->tcphdr->seqno;
      if ((int)(iVar4 - (next->len + uVar1)) < 0) {
        if (0 < (int)(iVar4 - uVar1)) {
          new_len = (u16_t)((uVar1 - seqno) * 0x10000 >> 0x10);
          cseg->len = new_len;
          pbuf_realloc(cseg->p,new_len);
        }
        goto LAB_2303f96e;
      }
      new_len = lwip_htons(next->tcphdr->_hdrlen_rsvd_flags);
      if ((new_len & 1) != 0) {
        uVar2 = cseg->tcphdr->_hdrlen_rsvd_flags;
        new_len = lwip_htons(1);
        ptVar5 = cseg->tcphdr;
        uVar2 = new_len | uVar2;
        *(char *)&ptVar5->_hdrlen_rsvd_flags = (char)uVar2;
        *(undefined *)((int)&ptVar5->_hdrlen_rsvd_flags + 1) = (char)((uint)uVar2 >> 8);
      }
      ptVar3 = next->next;
      tcp_seg_free(next);
      next = ptVar3;
    } while (ptVar3 != (tcp_seg *)0x0);
  }
  else {
    tcp_segs_free(next);
  }
  next = (tcp_seg *)0x0;
LAB_2303f96e:
  cseg->next = next;
  return;
}



void tcp_parseopt(undefined2 *param_1)

{
  uint uVar1;
  u8_t uVar2;
  byte bVar3;
  undefined2 uVar4;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  
  tcp_optidx = 0;
  while( true ) {
    while( true ) {
      do {
        uVar1 = (uint)tcphdr_optlen;
        if (uVar1 <= tcp_optidx) {
          return;
        }
        uVar2 = tcp_get_next_optbyte();
      } while (CONCAT31(extraout_var,uVar2) == 1);
      if (uVar2 == '\0') {
        return;
      }
      if (CONCAT31(extraout_var,uVar2) == 2) break;
      uVar2 = tcp_get_next_optbyte();
      if (CONCAT31(extraout_var_02,uVar2) < 2) {
        return;
      }
      tcp_optidx = (tcp_optidx - 2) + (short)CONCAT31(extraout_var_02,uVar2);
    }
    uVar2 = tcp_get_next_optbyte();
    if (CONCAT31(extraout_var_00,uVar2) != 4) {
      return;
    }
    if (uVar1 <= (uint)tcp_optidx + 1) break;
    bVar3 = tcp_get_next_optbyte();
    uVar2 = tcp_get_next_optbyte();
    uVar1 = CONCAT31(extraout_var_01,uVar2) & 0xffff | ((uint)bVar3 << 0x18) >> 0x10;
    uVar4 = (undefined2)uVar1;
    if (0x2af < (uVar1 - 1 & 0xffff)) {
      uVar4 = 0x2b0;
    }
    *param_1 = uVar4;
  }
  return;
}



int tcp_input_delayed_close(tcp_pcb *pcb)

{
  if ((recv_flags & 0x10) != 0) {
    if (((pcb->flags & 0x10) == 0) && (pcb->errf != (tcp_err_fn *)0x0)) {
      (*pcb->errf)(pcb->callback_arg,-0xf);
    }
    tcp_pcb_remove(&tcp_active_pcbs,pcb);
    tcp_free(pcb);
    return 1;
  }
  return 0;
}



tcp_seg * tcp_free_acked_segments(tcp_seg *seg_list)

{
  ushort uVar1;
  tcp_seg *ptVar2;
  u16_t uVar3;
  u32_t uVar4;
  tcp_seg *in_a1;
  
  while( true ) {
    if (in_a1 == (tcp_seg *)0x0) {
      return (tcp_seg *)0x0;
    }
    uVar4 = lwip_htonl(in_a1->tcphdr->seqno);
    uVar1 = in_a1->len;
    uVar3 = lwip_htons(in_a1->tcphdr->_hdrlen_rsvd_flags);
    if (0 < (int)((uVar1 - ackno) + uVar4 + (uint)((uVar3 & 3) != 0))) break;
    ptVar2 = in_a1->next;
    uVar3 = pbuf_clen(in_a1->p);
    *(u16_t *)&seg_list->next = *(short *)&seg_list->next - uVar3;
    recv_acked = in_a1->len + recv_acked;
    tcp_seg_free(in_a1);
    in_a1 = ptVar2;
  }
  return in_a1;
}



void tcp_receive(tcp_pcb *pcb)

{
  ushort n;
  ushort uVar1;
  short sVar2;
  tcp_seg *cseg;
  tcp_seg *next;
  u16_t new_len;
  u16_t uVar3;
  int iVar4;
  u32_t uVar5;
  pbuf *p;
  u32_t uVar6;
  uint header_size_decrement;
  u32_t uVar7;
  uint uVar8;
  tcp_hdr *ptVar9;
  tcpwnd_size_t tVar10;
  short sVar11;
  tcpflags_t tVar12;
  uint uVar13;
  uint uVar14;
  tcp_seg *ptVar15;
  
  uVar5 = seqno;
  uVar7 = ackno;
  if ((flags & 0x10) != 0) {
    n = pcb->snd_wnd;
    uVar6 = pcb->snd_wl2;
    if ((((int)(pcb->snd_wl1 - seqno) < 0) ||
        ((pcb->snd_wl1 == seqno && ((int)(uVar6 - ackno) < 0)))) ||
       ((uVar6 == ackno && ((uint)n < (uint)tcphdr->wnd)))) {
      uVar1 = tcphdr->wnd;
      pcb->snd_wnd = uVar1;
      if (pcb->snd_wnd_max < uVar1) {
        pcb->snd_wnd_max = uVar1;
      }
      pcb->snd_wl1 = uVar5;
      pcb->snd_wl2 = uVar7;
    }
    uVar13 = uVar7 - pcb->lastack;
    if ((int)uVar13 < 1) {
      if ((((tcplen == 0) && ((uint)pcb->snd_wnd + pcb->snd_wl2 == (uint)n + uVar6)) &&
          (-1 < pcb->rtime)) && (pcb->lastack == uVar7)) {
        if (pcb->dupacks != -1) {
          pcb->dupacks = pcb->dupacks + '\x01';
        }
        if (pcb->dupacks < 4) {
          if (pcb->dupacks != 3) goto LAB_2303fca8;
        }
        else {
          tVar10 = pcb->mss + pcb->cwnd;
          if (tVar10 < pcb->cwnd) {
            tVar10 = 0xffff;
          }
          pcb->cwnd = tVar10;
        }
        tcp_rexmit_fast(pcb);
      }
      else {
        pcb->dupacks = '\0';
      }
    }
    else {
      if ((int)(uVar7 - pcb->snd_nxt) < 1) {
        if ((pcb->flags & 4) != 0) {
          pcb->flags = pcb->flags & 0xfffb;
          pcb->bytes_acked = 0;
          pcb->cwnd = pcb->ssthresh;
        }
        pcb->lastack = uVar7;
        pcb->rto = (pcb->sa >> 3) + pcb->sv;
        *(undefined2 *)&pcb->nrtx = 0;
        if (SYN_RCVD < pcb->state) {
          header_size_decrement = (uint)pcb->cwnd;
          uVar13 = uVar13 & 0xffff;
          if (header_size_decrement < pcb->ssthresh) {
            uVar8 = ((uint)((pcb->flags & 0x800) == 0) + 1) * (uint)pcb->mss;
            if (uVar13 < (uVar8 & 0xffff)) {
              uVar8 = uVar13;
            }
          }
          else {
            uVar13 = uVar13 + pcb->bytes_acked;
            uVar8 = uVar13 & 0xffff;
            sVar11 = (short)uVar8;
            if (uVar8 < pcb->bytes_acked) {
              sVar11 = -1;
            }
            else {
              if (uVar8 < header_size_decrement) {
                pcb->bytes_acked = (tcpwnd_size_t)(uVar13 * 0x10000 >> 0x10);
                goto LAB_23040004;
              }
            }
            pcb->bytes_acked = sVar11 - pcb->cwnd;
            uVar8 = (uint)pcb->mss;
          }
          uVar13 = header_size_decrement + uVar8 & 0xffff;
          tVar10 = (tcpwnd_size_t)uVar13;
          if (uVar13 < header_size_decrement) {
            tVar10 = 0xffff;
          }
          pcb->cwnd = tVar10;
        }
LAB_23040004:
        cseg = tcp_free_acked_segments((tcp_seg *)&pcb->snd_queuelen);
        pcb->unacked = cseg;
        cseg = tcp_free_acked_segments((tcp_seg *)&pcb->snd_queuelen);
        ptVar15 = pcb->unacked;
        pcb->unsent = cseg;
        pcb->polltmr = '\0';
        pcb->rtime = -(ushort)(ptVar15 == (tcp_seg *)0x0);
        if (cseg == (tcp_seg *)0x0) {
          pcb->unsent_oversize = 0;
        }
        pcb->snd_buf = pcb->snd_buf + recv_acked;
        if ((int)((uint)pcb->flags << 0x14) < 0) {
          if (ptVar15 == (tcp_seg *)0x0) {
            if (cseg != (tcp_seg *)0x0) {
              uVar7 = pcb->rto_end;
              ptVar9 = cseg->tcphdr;
              goto LAB_23040080;
            }
          }
          else {
            uVar7 = pcb->rto_end;
            ptVar9 = ptVar15->tcphdr;
LAB_23040080:
            uVar5 = lwip_htonl(ptVar9->seqno);
            if (0 < (int)(uVar7 - uVar5)) goto LAB_2303fca8;
          }
          pcb->flags = pcb->flags & 0xf7ff;
        }
      }
      else {
        tcp_send_empty_ack(pcb);
      }
    }
LAB_2303fca8:
    if ((pcb->rttest != 0) && ((int)(pcb->rtseq - ackno) < 0)) {
      uVar8 = (uint)(ushort)tcp_ticks;
      header_size_decrement = pcb->rttest & 0xffff;
      uVar13 = (int)pcb->sa >> 3 & 0xffff;
      uVar14 = (uVar8 - header_size_decrement) - uVar13 & 0xffff;
      iVar4 = (int)(short)uVar14;
      sVar11 = (short)((uVar14 + (int)pcb->sa) * 0x10000 >> 0x10);
      pcb->sa = sVar11;
      if (iVar4 < 0) {
        iVar4 = (int)(((header_size_decrement - uVar8) + uVar13) * 0x10000) >> 0x10;
      }
      pcb->rttest = 0;
      sVar2 = (short)((uint)((((int)pcb->sv - ((int)pcb->sv >> 2)) + iVar4) * 0x10000) >> 0x10);
      pcb->sv = sVar2;
      pcb->rto = (sVar11 >> 3) + sVar2;
    }
  }
  uVar7 = pcb->rcv_nxt;
  if ((tcplen == 0) || (FIN_WAIT_2 < pcb->state)) {
    if ((-1 < (int)(seqno - uVar7)) && ((int)(((seqno + 1) - uVar7) - (uint)pcb->rcv_wnd) < 1)) {
      return;
    }
    tVar12 = pcb->flags;
  }
  else {
    uVar13 = uVar7 - seqno;
    if (((int)(uVar13 - 1) < 0) || (0 < (int)(((1 - seqno) - (uint)tcplen) + uVar7))) {
      if ((int)(seqno - uVar7) < 0) {
        pcb->flags = pcb->flags | 2;
      }
    }
    else {
      header_size_decrement = uVar13 & 0xffff;
      inseg.len = inseg.len - (short)(uVar13 * 0x10000 >> 0x10);
      iVar4 = (inseg.p)->tot_len - header_size_decrement;
      p = inseg.p;
      while (n = p->len, n < header_size_decrement) {
        p->tot_len = (u16_t)((uint)(iVar4 * 0x10000) >> 0x10);
        p->len = 0;
        header_size_decrement = header_size_decrement - n & 0xffff;
        p = p->next;
      }
      pbuf_remove_header(p,header_size_decrement);
      ptVar9 = inseg.tcphdr;
      uVar7 = pcb->rcv_nxt;
      seqno = uVar7;
      *(char *)&(inseg.tcphdr)->seqno = (char)uVar7;
      *(undefined *)((int)&ptVar9->seqno + 1) = (char)(uVar7 >> 8);
      *(undefined *)((int)&ptVar9->seqno + 2) = (char)(uVar7 >> 0x10);
      *(undefined *)((int)&ptVar9->seqno + 3) = (char)(uVar7 >> 0x18);
    }
    uVar7 = pcb->rcv_nxt;
    if (((int)(seqno - uVar7) < 0) || (0 < (int)(((seqno + 1) - uVar7) - (uint)pcb->rcv_wnd))) {
LAB_23040308:
      tcp_send_empty_ack(pcb);
      return;
    }
    if (seqno != uVar7) {
      cseg = pcb->ooseq;
      ptVar15 = (tcp_seg *)0x0;
      if (pcb->ooseq == (tcp_seg *)0x0) {
        cseg = tcp_seg_copy(&inseg);
        pcb->ooseq = cseg;
      }
      else {
        do {
          next = cseg;
          uVar7 = next->tcphdr->seqno;
          if (seqno == uVar7) {
            if ((next->len < inseg.len) && (cseg = tcp_seg_copy(&inseg), cseg != (tcp_seg *)0x0)) {
              if (ptVar15 == (tcp_seg *)0x0) {
                pcb->ooseq = cseg;
              }
              else {
                ptVar15->next = cseg;
              }
LAB_2304036e:
              tcp_oos_insert_segment(cseg,next);
            }
            goto LAB_23040308;
          }
          if (ptVar15 == (tcp_seg *)0x0) {
            if ((int)(seqno - uVar7) < 0) {
              cseg = tcp_seg_copy(&inseg);
              if (cseg != (tcp_seg *)0x0) {
                pcb->ooseq = cseg;
                goto LAB_2304036e;
              }
              goto LAB_23040308;
            }
          }
          else {
            if ((-1 < (int)((seqno - 1) - ptVar15->tcphdr->seqno)) &&
               ((int)((seqno + 1) - uVar7) < 1)) {
              cseg = tcp_seg_copy(&inseg);
              if (cseg != (tcp_seg *)0x0) {
                uVar7 = ptVar15->tcphdr->seqno;
                if (0 < (int)((ptVar15->len + uVar7) - seqno)) {
                  new_len = (u16_t)((seqno - uVar7) * 0x10000 >> 0x10);
                  ptVar15->len = new_len;
                  pbuf_realloc(ptVar15->p,new_len);
                }
                ptVar15->next = cseg;
                goto LAB_2304036e;
              }
              goto LAB_23040308;
            }
          }
          cseg = next->next;
          ptVar15 = next;
        } while (next->next != (tcp_seg *)0x0);
        if ((0 < (int)(seqno - uVar7)) &&
           (new_len = lwip_htons(next->tcphdr->_hdrlen_rsvd_flags), (new_len & 1) == 0)) {
          cseg = tcp_seg_copy(&inseg);
          next->next = cseg;
          if (cseg != (tcp_seg *)0x0) {
            uVar7 = next->tcphdr->seqno;
            if (0 < (int)((next->len + uVar7) - seqno)) {
              new_len = (u16_t)((seqno - uVar7) * 0x10000 >> 0x10);
              next->len = new_len;
              pbuf_realloc(next->p,new_len);
            }
            if (0 < (int)(((tcplen + seqno) - pcb->rcv_nxt) - (uint)pcb->rcv_wnd)) {
              new_len = lwip_htons(next->next->tcphdr->_hdrlen_rsvd_flags);
              if ((new_len & 1) != 0) {
                n = next->next->tcphdr->_hdrlen_rsvd_flags;
                new_len = lwip_htons(n);
                new_len = lwip_htons(new_len & 0x3e);
                ptVar9 = next->next->tcphdr;
                uVar13 = (uint)n & 0xffffc0ff | (uint)new_len;
                *(char *)&ptVar9->_hdrlen_rsvd_flags = (char)uVar13;
                *(undefined *)((int)&ptVar9->_hdrlen_rsvd_flags + 1) = (char)(uVar13 >> 8);
              }
              next->next->len = (pcb->rcv_wnd - (short)seqno) + (short)pcb->rcv_nxt;
              pbuf_realloc(next->next->p,next->next->len);
              new_len = next->next->len;
              uVar3 = lwip_htons(next->next->tcphdr->_hdrlen_rsvd_flags);
              tcplen = new_len + ((uVar3 & 3) != 0);
            }
          }
        }
      }
      goto LAB_23040308;
    }
    uVar13 = (uint)inseg.len;
    new_len = lwip_htons((inseg.tcphdr)->_hdrlen_rsvd_flags);
    uVar13 = ((new_len & 3) != 0) + uVar13;
    tcplen = (u16_t)(uVar13 * 0x10000 >> 0x10);
    if ((uint)pcb->rcv_wnd < (uVar13 & 0xffff)) {
      new_len = lwip_htons((inseg.tcphdr)->_hdrlen_rsvd_flags);
      if ((new_len & 1) != 0) {
        n = (inseg.tcphdr)->_hdrlen_rsvd_flags;
        new_len = lwip_htons(n);
        new_len = lwip_htons(new_len & 0x3e);
        ptVar9 = inseg.tcphdr;
        uVar13 = (uint)n & 0xffffc0ff | (uint)new_len;
        *(char *)&(inseg.tcphdr)->_hdrlen_rsvd_flags = (char)uVar13;
        *(undefined *)((int)&ptVar9->_hdrlen_rsvd_flags + 1) = (char)(uVar13 >> 8);
      }
      inseg.len = pcb->rcv_wnd;
      new_len = lwip_htons((inseg.tcphdr)->_hdrlen_rsvd_flags);
      if ((new_len & 2) != 0) {
        inseg.len = inseg.len - 1;
      }
      pbuf_realloc(inseg.p,inseg.len);
      new_len = inseg.len;
      uVar3 = lwip_htons((inseg.tcphdr)->_hdrlen_rsvd_flags);
      tcplen = new_len + ((uVar3 & 3) != 0);
    }
    if (pcb->ooseq != (tcp_seg *)0x0) {
      new_len = lwip_htons((inseg.tcphdr)->_hdrlen_rsvd_flags);
      if ((new_len & 1) == 0) {
        cseg = pcb->ooseq;
        while (cseg != (tcp_seg *)0x0) {
          uVar7 = cseg->tcphdr->seqno;
          if ((int)((tcplen + seqno) - (cseg->len + uVar7)) < 0) {
            if (0 < (int)((tcplen + seqno) - uVar7)) {
              inseg.len = (short)uVar7 - (short)seqno;
              new_len = lwip_htons((inseg.tcphdr)->_hdrlen_rsvd_flags);
              if ((new_len & 2) != 0) {
                inseg.len = inseg.len - 1;
              }
              pbuf_realloc(inseg.p,inseg.len);
              new_len = inseg.len;
              uVar3 = lwip_htons((inseg.tcphdr)->_hdrlen_rsvd_flags);
              tcplen = new_len + ((uVar3 & 3) != 0);
            }
            break;
          }
          new_len = lwip_htons(cseg->tcphdr->_hdrlen_rsvd_flags);
          if (((new_len & 1) != 0) &&
             (new_len = lwip_htons((inseg.tcphdr)->_hdrlen_rsvd_flags), (new_len & 2) == 0)) {
            n = (inseg.tcphdr)->_hdrlen_rsvd_flags;
            new_len = lwip_htons(1);
            ptVar9 = inseg.tcphdr;
            n = n | new_len;
            *(char *)&(inseg.tcphdr)->_hdrlen_rsvd_flags = (char)n;
            *(undefined *)((int)&ptVar9->_hdrlen_rsvd_flags + 1) = (char)((uint)n >> 8);
            new_len = inseg.len;
            uVar3 = lwip_htons((inseg.tcphdr)->_hdrlen_rsvd_flags);
            tcplen = new_len + ((uVar3 & 3) != 0);
          }
          ptVar15 = cseg->next;
          tcp_seg_free(cseg);
          cseg = ptVar15;
        }
        pcb->ooseq = cseg;
      }
      else {
        while (cseg = pcb->ooseq, cseg != (tcp_seg *)0x0) {
          pcb->ooseq = cseg->next;
          tcp_seg_free(cseg);
        }
      }
    }
    tVar10 = pcb->rcv_wnd - tcplen;
    pcb->rcv_nxt = seqno + tcplen;
    pcb->rcv_wnd = tVar10;
    tcp_update_rcv_ann_wnd(pcb);
    if ((inseg.p)->tot_len != 0) {
      recv_data = inseg.p;
      inseg.p = (pbuf *)0x0;
    }
    new_len = lwip_htons((inseg.tcphdr)->_hdrlen_rsvd_flags);
    if ((new_len & 1) != 0) {
      recv_flags = recv_flags | 0x20;
    }
    while (cseg = pcb->ooseq, cseg != (tcp_seg *)0x0) {
      uVar7 = cseg->tcphdr->seqno;
      if (uVar7 != pcb->rcv_nxt) break;
      n = cseg->len;
      seqno = uVar7;
      new_len = lwip_htons(cseg->tcphdr->_hdrlen_rsvd_flags);
      pcb->rcv_nxt = (uint)((new_len & 3) != 0) + (uint)n + pcb->rcv_nxt;
      lwip_htons(cseg->tcphdr->_hdrlen_rsvd_flags);
      new_len = cseg->len;
      uVar3 = lwip_htons(cseg->tcphdr->_hdrlen_rsvd_flags);
      pcb->rcv_wnd = pcb->rcv_wnd - (((uVar3 & 3) != 0) + new_len);
      tcp_update_rcv_ann_wnd(pcb);
      p = cseg->p;
      if (p->tot_len != 0) {
        if (recv_data != (pbuf *)0x0) {
          pbuf_cat(recv_data,p);
          p = recv_data;
        }
        recv_data = p;
        cseg->p = (pbuf *)0x0;
      }
      new_len = lwip_htons(cseg->tcphdr->_hdrlen_rsvd_flags);
      if (((new_len & 1) != 0) && (recv_flags = recv_flags | 0x20, pcb->state == ESTABLISHED)) {
        pcb->state = CLOSE_WAIT;
      }
      pcb->ooseq = cseg->next;
      tcp_seg_free(cseg);
    }
    n = pcb->flags;
    if ((n & 1) == 0) {
      tVar12 = n | 1;
      goto LAB_230402d6;
    }
    tVar12 = n & 0xfffe;
  }
  tVar12 = tVar12 | 2;
LAB_230402d6:
  pcb->flags = tVar12;
  return;
}



// WARNING: Restarted to delay deadcode elimination for space: ram

void tcp_input(pbuf *p,netif *inp)

{
  ushort uVar1;
  u16_t uVar2;
  byte bVar3;
  tcp_hdr *ptVar4;
  tcp_hdr *ptVar5;
  tcp_pcb *ptVar6;
  u8_t uVar7;
  err_t eVar8;
  u16_t sendmss;
  tcpwnd_size_t tVar9;
  undefined3 extraout_var;
  undefined2 extraout_var_08;
  undefined2 extraout_var_09;
  undefined3 extraout_var_00;
  tcp_pcb *pcb;
  u32_t uVar10;
  netif *outif;
  undefined3 extraout_var_01;
  undefined2 extraout_var_10;
  tcp_seg *seg;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  undefined3 extraout_var_05;
  undefined3 extraout_var_06;
  undefined3 extraout_var_07;
  uint header_size_decrement;
  u32_t ackno;
  int iVar11;
  tcp_state tVar12;
  u16_t uVar13;
  tcpflags_t tVar14;
  uint uVar15;
  void *pvVar16;
  tcp_accept_fn paVar17;
  uint uVar18;
  tcp_pcb *ptVar19;
  pbuf *p_00;
  u16_t remote_port;
  tcp_pcb *ptVar20;
  tcp_pcb *pcb_00;
  
  lwip_stats.tcp.recv = lwip_stats.tcp.recv + 1;
  tcphdr = (tcp_hdr *)p->payload;
  if (p->len < 0x14) goto LAB_230405b0;
  uVar7 = ip4_addr_isbroadcast_u32(ip_data.current_iphdr_dest,ip_data.current_netif);
  if ((CONCAT31(extraout_var,uVar7) == 0) && ((ip_data.current_iphdr_dest & 0xf0) != 0xe0)) {
    sendmss = ip_chksum_pseudo(p,'\x06',p->tot_len,(ip4_addr_t *)&ip_data.current_iphdr_src,
                               (ip4_addr_t *)&ip_data.current_iphdr_dest);
    if (CONCAT22(extraout_var_08,sendmss) == 0) {
      sendmss = lwip_htons(tcphdr->_hdrlen_rsvd_flags);
      header_size_decrement = CONCAT22(extraout_var_09,sendmss) >> 10 & 0xfc;
      if ((0x13 < header_size_decrement) && (header_size_decrement <= p->tot_len)) {
        tcphdr_optlen = (u16_t)((header_size_decrement - 0x14) * 0x10000 >> 0x10);
        tcphdr_opt2 = (u8_t *)0x0;
        if (p->len < header_size_decrement) {
          pbuf_remove_header(p,0x14);
          sendmss = tcphdr_optlen;
          uVar1 = p->len;
          header_size_decrement = (uint)tcphdr_optlen;
          tcphdr_opt1len = uVar1;
          pbuf_remove_header(p,(uint)uVar1);
          p_00 = p->next;
          header_size_decrement = header_size_decrement - (uint)uVar1 & 0xffff;
          if (p_00->len < header_size_decrement) goto LAB_230405b0;
          tcphdr_opt2 = (u8_t *)p_00->payload;
          pbuf_remove_header(p_00,header_size_decrement);
          p->tot_len = (uVar1 + p->tot_len) - sendmss;
        }
        else {
          tcphdr_opt1len = tcphdr_optlen;
          pbuf_remove_header(p,header_size_decrement);
        }
        ptVar4 = tcphdr;
        sendmss = lwip_htons(tcphdr->src);
        *(char *)&ptVar4->src = (char)sendmss;
        *(undefined *)((int)&ptVar4->src + 1) = (char)(sendmss >> 8);
        ptVar4 = tcphdr;
        sendmss = lwip_htons(tcphdr->dest);
        *(char *)&ptVar4->dest = (char)sendmss;
        *(undefined *)((int)&ptVar4->dest + 1) = (char)(sendmss >> 8);
        ptVar4 = tcphdr;
        seqno = lwip_htonl(tcphdr->seqno);
        *(undefined *)((int)&ptVar4->seqno + 1) = (char)(seqno >> 8);
        *(undefined *)((int)&ptVar4->seqno + 2) = (char)(seqno >> 0x10);
        *(char *)&ptVar4->seqno = (char)seqno;
        *(undefined *)((int)&ptVar4->seqno + 3) = (char)(seqno >> 0x18);
        ptVar4 = tcphdr;
        ackno = lwip_htonl(tcphdr->ackno);
        *(undefined *)((int)&ptVar4->ackno + 1) = (char)(ackno >> 8);
        *(undefined *)((int)&ptVar4->ackno + 2) = (char)(ackno >> 0x10);
        *(char *)&ptVar4->ackno = (char)ackno;
        *(undefined *)((int)&ptVar4->ackno + 3) = (char)(ackno >> 0x18);
        ptVar4 = tcphdr;
        sendmss = lwip_htons(tcphdr->wnd);
        ptVar5 = tcphdr;
        *(char *)&ptVar4->wnd = (char)sendmss;
        *(undefined *)((int)&ptVar4->wnd + 1) = (char)(sendmss >> 8);
        sendmss = lwip_htons(ptVar5->_hdrlen_rsvd_flags);
        ptVar19 = tcp_active_pcbs;
        ptVar6 = tcp_listen_pcbs;
        ptVar4 = tcphdr;
        flags = (byte)sendmss & 0x3f;
        tcplen = p->tot_len;
        header_size_decrement = (uint)tcplen;
        if (((sendmss & 3) == 0) ||
           (uVar15 = header_size_decrement + 1, tcplen = (u16_t)(uVar15 * 0x10000 >> 0x10),
           header_size_decrement <= (uVar15 & 0xffff))) {
          uVar2 = tcplen;
          pcb = tcp_active_pcbs;
          ptVar20 = (tcp_pcb *)0x0;
LAB_230407f2:
          pcb_00 = pcb;
          pcb = tcp_tw_pcbs;
          if (pcb_00 == (tcp_pcb *)0x0) goto LAB_23040a58;
          if (((((pcb_00->netif_idx != '\0') &&
                (pcb_00->netif_idx != (u8_t)((ip_data.current_input_netif)->num + '\x01'))) ||
               (pcb_00->remote_port != tcphdr->src)) ||
              ((pcb_00->local_port != tcphdr->dest ||
               ((pcb_00->remote_ip).addr != ip_data.current_iphdr_src)))) ||
             ((pcb_00->local_ip).addr != ip_data.current_iphdr_dest)) goto LAB_2304097e;
          if (ptVar20 == (tcp_pcb *)0x0) {
            lwip_stats.tcp.cachehit = lwip_stats.tcp.cachehit + 1;
          }
          else {
            tcp_active_pcbs = pcb_00;
            ptVar20->next = pcb_00->next;
            pcb_00->next = ptVar19;
          }
          inseg.len = p->tot_len;
          recv_data = (pbuf *)0x0;
          recv_flags = '\0';
          recv_acked = 0;
          inseg.next = (tcp_seg *)0x0;
          inseg.tcphdr = ptVar4;
          inseg.p = p;
          if ((sendmss & 8) != 0) {
            p->flags = p->flags | 1;
          }
          if ((pcb_00->refused_data != (pbuf *)0x0) &&
             ((eVar8 = tcp_process_refused_data(pcb_00), CONCAT31(extraout_var_00,eVar8) == -0xd ||
              ((pcb_00->refused_data != (pbuf *)0x0 && (tcplen != 0)))))) {
            if (pcb_00->rcv_ann_wnd == 0) {
              tcp_send_empty_ack(pcb_00);
            }
            lwip_stats.tcp.drop = lwip_stats.tcp.drop + 1;
            goto aborted;
          }
          uVar7 = flags;
          tcp_input_pcb = pcb_00;
          if ((flags & 4) != 0) {
            if (pcb_00->state == SYN_SENT) {
              if (pcb_00->snd_nxt != ackno) goto switchD_23040d14_caseD_8;
            }
            else {
              if (pcb_00->rcv_nxt != seqno) {
                iVar11 = seqno - pcb_00->rcv_nxt;
                if ((-1 < iVar11) && ((int)(iVar11 - (uint)pcb_00->rcv_wnd) < 1)) goto LAB_23040ca0;
                goto switchD_23040d14_caseD_8;
              }
            }
            recv_flags = recv_flags | 8;
            tVar14 = pcb_00->flags & 0xfffe;
LAB_23040c5a:
            pcb_00->flags = tVar14;
            goto switchD_23040d14_caseD_8;
          }
          bVar3 = flags & 2;
          tVar14 = pcb_00->flags;
          if (((flags & 2) != 0) && (1 < (byte)(pcb_00->state + ~LISTEN))) {
LAB_23040cc2:
            tVar14 = tVar14 | 2;
            goto LAB_23040c5a;
          }
          if ((tVar14 & 0x10) == 0) {
            pcb_00->tmr = tcp_ticks;
          }
          *(undefined2 *)&pcb_00->persist_probe = 0;
          if (tcphdr_optlen != 0) {
            tcp_parseopt(&pcb_00->mss);
          }
          ackno = seqno;
          switch((uint)pcb_00->state - 2 & 0xff) {
          case 0:
            if (((uVar7 & 0x12) != 0x12) || (uVar10 = pcb_00->lastack + 1, uVar10 != ackno)) {
              if (((uVar7 & 0x10) != 0) &&
                 (tcp_rst(pcb_00,ackno,seqno + tcplen,&ip_data.current_iphdr_dest,
                          &ip_data.current_iphdr_src,tcphdr->dest,tcphdr->src), pcb_00->nrtx < 6)) {
                pcb_00->rtime = 0;
                tcp_rexmit_rto(pcb_00);
              }
              goto switchD_23040d14_caseD_8;
            }
            pcb_00->lastack = uVar10;
            uVar10 = ackno + 1;
            pcb_00->rcv_nxt = uVar10;
            pcb_00->rcv_ann_right_edge = uVar10;
            sendmss = pcb_00->mss;
            uVar2 = tcphdr->wnd;
            pcb_00->snd_wl1 = ackno - 1;
            pcb_00->snd_wnd = uVar2;
            pcb_00->snd_wnd_max = uVar2;
            pcb_00->state = ESTABLISHED;
            outif = ip4_route((ip4_addr_t *)&pcb_00->remote_ip);
            sendmss = tcp_eff_send_mss_netif
                                (sendmss,outif,(ip_addr_t *)(ip4_addr_t *)&pcb_00->remote_ip);
            iVar11 = CONCAT22(extraout_var_10,sendmss);
            uVar15 = iVar11 << 1;
            pcb_00->mss = sendmss;
            tVar9 = 0x111c;
            header_size_decrement = uVar15;
            if (uVar15 < 0x111c) {
              header_size_decrement = 0x111c;
            }
            if ((uint)(iVar11 << 2) < header_size_decrement) {
              tVar9 = (tcpwnd_size_t)((uint)(iVar11 << 0x12) >> 0x10);
            }
            else {
              if (0x111c < uVar15) {
                tVar9 = (tcpwnd_size_t)((uint)(iVar11 << 0x11) >> 0x10);
              }
            }
            pcb_00->cwnd = tVar9;
            seg = pcb_00->unacked;
            pcb_00->snd_queuelen = pcb_00->snd_queuelen - 1;
            if (seg == (tcp_seg *)0x0) {
              seg = pcb_00->unsent;
              pcb_00->unsent = seg->next;
            }
            else {
              pcb_00->unacked = seg->next;
            }
            tcp_seg_free(seg);
            if (pcb_00->unacked == (tcp_seg *)0x0) {
              pcb_00->rtime = -1;
            }
            else {
              pcb_00->rtime = 0;
              pcb_00->nrtx = '\0';
            }
            if ((pcb_00->connected == (tcp_connected_fn)0x0) ||
               (eVar8 = (*pcb_00->connected)(pcb_00->callback_arg,pcb_00,'\0'),
               CONCAT31(extraout_var_02,eVar8) != -0xd)) {
LAB_23040ca0:
              tVar14 = pcb_00->flags;
              goto LAB_23040cc2;
            }
            goto aborted;
          case 1:
            if ((uVar7 & 0x10) == 0) {
              if ((bVar3 != 0) && (pcb_00->rcv_nxt - 1 == seqno)) {
                tcp_rexmit(pcb_00);
              }
              goto switchD_23040d14_caseD_8;
            }
            if (((int)((ackno - 1) - pcb_00->lastack) < 0) || (0 < (int)(ackno - pcb_00->snd_nxt)))
            {
              tcp_rst(pcb_00,ackno,seqno + tcplen,&ip_data.current_iphdr_dest,
                      &ip_data.current_iphdr_src,tcphdr->dest,tcphdr->src);
              goto switchD_23040d14_caseD_8;
            }
            pcb_00->state = ESTABLISHED;
            if ((pcb_00->listener == (tcp_pcb_listen *)0x0) ||
               (paVar17 = pcb_00->listener->accept, paVar17 == (tcp_accept_fn)0x0))
            goto LAB_23040e74;
            eVar8 = (*paVar17)(pcb_00->callback_arg,pcb_00,'\0');
            if (CONCAT31(extraout_var_03,eVar8) != 0) {
              if (CONCAT31(extraout_var_03,eVar8) == -0xd) goto aborted;
              goto LAB_23040e74;
            }
            tcp_receive(pcb_00);
            if (recv_acked != 0) {
              recv_acked = recv_acked - 1;
            }
            uVar18 = (uint)pcb_00->mss;
            uVar15 = uVar18 << 1;
            tVar9 = 0x111c;
            header_size_decrement = uVar15;
            if (uVar15 < 0x111c) {
              header_size_decrement = 0x111c;
            }
            if (uVar18 << 2 < header_size_decrement) {
              tVar9 = (tcpwnd_size_t)((uVar18 << 0x12) >> 0x10);
            }
            else {
              if (0x111c < uVar15) {
                tVar9 = (tcpwnd_size_t)((uVar18 << 0x11) >> 0x10);
              }
            }
            pcb_00->cwnd = tVar9;
            break;
          case 2:
          case 5:
            tcp_receive(pcb_00);
            break;
          case 3:
            tcp_receive(pcb_00);
            if ((recv_flags & 0x20) != 0) {
              if ((((flags & 0x10) == 0) || (pcb_00->snd_nxt != ackno)) ||
                 (pcb_00->unsent != (tcp_seg *)0x0)) {
                pcb_00->flags = pcb_00->flags | 2;
                tVar12 = CLOSING;
                goto LAB_23040ee6;
              }
              pcb_00->flags = pcb_00->flags | 2;
              tcp_pcb_purge(pcb_00);
              ptVar6 = tcp_active_pcbs;
              if (pcb_00 == tcp_active_pcbs) goto LAB_23040f92;
              goto LAB_23040fa8;
            }
            if ((((flags & 0x10) == 0) || (pcb_00->snd_nxt != ackno)) ||
               (pcb_00->unsent != (tcp_seg *)0x0)) goto switchD_23040d14_caseD_8;
            tVar12 = FIN_WAIT_2;
            goto LAB_23040ee6;
          case 4:
            tcp_receive(pcb_00);
            if ((recv_flags & 0x20) == 0) goto switchD_23040d14_caseD_8;
            pcb_00->flags = pcb_00->flags | 2;
            tcp_pcb_purge(pcb_00);
            ptVar6 = tcp_active_pcbs;
            if (pcb_00 == tcp_active_pcbs) goto LAB_23040f92;
            goto LAB_23041024;
          case 6:
            tcp_receive(pcb_00);
            if ((((flags & 0x10) == 0) || (pcb_00->snd_nxt != ackno)) ||
               (pcb_00->unsent != (tcp_seg *)0x0)) goto switchD_23040d14_caseD_8;
            tcp_pcb_purge(pcb_00);
            ptVar6 = tcp_active_pcbs;
            if (pcb_00 != tcp_active_pcbs) goto LAB_2304105e;
LAB_23040f92:
            tcp_active_pcbs = pcb_00->next;
            goto LAB_23040faa;
          case 7:
            tcp_receive(pcb_00);
            if ((((flags & 0x10) != 0) && (pcb_00->snd_nxt == ackno)) &&
               (pcb_00->unsent == (tcp_seg *)0x0)) {
              recv_flags = recv_flags | 0x10;
            }
          default:
            goto switchD_23040d14_caseD_8;
          }
          if ((recv_flags & 0x20) == 0) goto switchD_23040d14_caseD_8;
          pcb_00->flags = pcb_00->flags | 2;
          tVar12 = CLOSE_WAIT;
LAB_23040ee6:
          pcb_00->state = tVar12;
          goto switchD_23040d14_caseD_8;
        }
      }
LAB_230405b0:
      lwip_stats.tcp.lenerr = lwip_stats.tcp.lenerr + 1;
    }
    else {
      lwip_stats.tcp.chkerr = lwip_stats.tcp.chkerr + 1;
    }
  }
  else {
    lwip_stats.tcp.proterr = lwip_stats.tcp.proterr + 1;
  }
  lwip_stats.tcp.drop = lwip_stats.tcp.drop + 1;
LAB_23040a34:
  pbuf_free(p);
  return;
LAB_23040a58:
  if (pcb == (tcp_pcb *)0x0) goto code_r0x23040a5a;
  if ((((pcb->netif_idx == '\0') ||
       (pcb->netif_idx == (u8_t)((ip_data.current_input_netif)->num + '\x01'))) &&
      ((remote_port = pcb->remote_port, remote_port == tcphdr->src &&
       ((uVar13 = pcb->local_port, uVar13 == tcphdr->dest &&
        (ip_data.current_iphdr_src == (pcb->remote_ip).addr)))))) &&
     (ip_data.current_iphdr_dest == (pcb->local_ip).addr)) {
    if ((sendmss & 4) != 0) goto LAB_23040a34;
    if ((sendmss & 2) == 0) {
      if ((sendmss & 1) != 0) {
        pcb->tmr = tcp_ticks;
      }
    }
    else {
      iVar11 = seqno - pcb->rcv_nxt;
      if ((-1 < iVar11) && ((int)(iVar11 - (uint)pcb->rcv_wnd) < 1)) {
        ackno = tcplen + seqno;
        goto LAB_23040a0e;
      }
    }
    if (uVar2 == 0) goto LAB_23040a34;
    pcb->flags = pcb->flags | 2;
    goto LAB_23040a30;
  }
  pcb = pcb->next;
  goto LAB_23040a58;
code_r0x23040a5a:
  ptVar20 = (tcp_pcb *)0x0;
  pcb_00 = (tcp_pcb *)0x0;
  ptVar19 = tcp_listen_pcbs;
  while (ptVar19 != (tcp_pcb *)0x0) {
    if (((ptVar19->netif_idx == '\0') ||
        (ptVar19->netif_idx == (u8_t)((ip_data.current_input_netif)->num + '\x01'))) &&
       (ptVar19->local_port == tcphdr->dest)) {
      ackno = (ptVar19->local_ip).addr;
      if (ip_data.current_iphdr_dest == ackno) goto LAB_23040ab6;
      if (ackno == 0) {
        ptVar20 = ptVar19;
        pcb_00 = pcb;
      }
    }
    pcb = ptVar19;
    ptVar19 = ptVar19->next;
  }
  pcb = pcb_00;
  ptVar19 = ptVar20;
  if (ptVar20 == (tcp_pcb *)0x0) {
    sendmss = lwip_htons(tcphdr->_hdrlen_rsvd_flags);
    if ((sendmss & 4) != 0) goto LAB_23040a34;
    lwip_stats.tcp.proterr = lwip_stats.tcp.proterr + 1;
    lwip_stats.tcp.drop = lwip_stats.tcp.drop + 1;
    remote_port = tcphdr->src;
    uVar13 = tcphdr->dest;
    ackno = seqno + tcplen;
    pcb = (tcp_pcb *)0x0;
  }
  else {
LAB_23040ab6:
    if (pcb == (tcp_pcb *)0x0) {
      lwip_stats.tcp.cachehit = lwip_stats.tcp.cachehit + 1;
    }
    else {
      tcp_listen_pcbs = ptVar19;
      pcb->next = ptVar19->next;
      ptVar19->next = ptVar6;
    }
    if ((sendmss & 4) != 0) goto LAB_23040a34;
    if ((sendmss & 0x10) == 0) {
      if ((sendmss & 2) != 0) {
        pcb = tcp_alloc(ptVar19->prio);
        ptVar4 = tcphdr;
        if (pcb == (tcp_pcb *)0x0) {
          lwip_stats.tcp.memerr = lwip_stats.tcp.memerr + 1;
          if (*(code **)&ptVar19->remote_port != (code *)0x0) {
            (**(code **)&ptVar19->remote_port)(ptVar19->callback_arg,0,0xffffffff);
          }
        }
        else {
          (pcb->local_ip).addr = ip_data.current_iphdr_dest;
          (pcb->remote_ip).addr = ip_data.current_iphdr_src;
          pcb->local_port = ptVar19->local_port;
          pcb->remote_port = ptVar4->src;
          pcb->state = SYN_RCVD;
          ackno = seqno + 1;
          pcb->rcv_nxt = ackno;
          pcb->rcv_ann_right_edge = ackno;
          uVar10 = tcp_next_iss(pcb);
          ackno = seqno;
          pcb->snd_wl2 = uVar10;
          pcb->snd_nxt = uVar10;
          pcb->lastack = uVar10;
          pcb->snd_lbb = uVar10;
          pcb->snd_wl1 = ackno - 1;
          pvVar16 = ptVar19->callback_arg;
          *(tcp_pcb **)&pcb->listener = ptVar19;
          pcb->callback_arg = pvVar16;
          pcb->so_options = ptVar19->so_options & 0xc;
          pcb->netif_idx = ptVar19->netif_idx;
          ptVar6 = pcb;
          pcb->next = tcp_active_pcbs;
          tcp_active_pcbs = ptVar6;
          tcp_timer_needed();
          tcp_active_pcbs_changed = '\x01';
          if (tcphdr_optlen != 0) {
            tcp_parseopt(&pcb->mss);
          }
          uVar2 = tcphdr->wnd;
          sendmss = pcb->mss;
          pcb->snd_wnd = uVar2;
          pcb->snd_wnd_max = uVar2;
          outif = ip4_route((ip4_addr_t *)&pcb->remote_ip);
          sendmss = tcp_eff_send_mss_netif(sendmss,outif,(ip_addr_t *)(ip4_addr_t *)&pcb->remote_ip)
          ;
          pcb->mss = sendmss;
          eVar8 = tcp_enqueue_flags(pcb,'\x12');
          if (CONCAT31(extraout_var_01,eVar8) == 0) {
LAB_23040a30:
            tcp_output(pcb);
          }
          else {
            tcp_abandon(pcb,0);
          }
        }
      }
      goto LAB_23040a34;
    }
    remote_port = tcphdr->src;
    uVar13 = tcphdr->dest;
    ackno = seqno + tcplen;
    pcb = ptVar19;
  }
LAB_23040a0e:
  tcp_rst(pcb,ackno,ackno,&ip_data.current_iphdr_dest,&ip_data.current_iphdr_src,uVar13,remote_port)
  ;
  goto LAB_23040a34;
LAB_2304097e:
  pcb = pcb_00->next;
  ptVar20 = pcb_00;
  goto LAB_230407f2;
  while (ptVar6 = ptVar19->next, pcb_00 != ptVar19->next) {
LAB_2304105e:
    ptVar19 = ptVar6;
    if (ptVar19 == (tcp_pcb *)0x0) goto LAB_23040faa;
  }
  goto LAB_23040fa0;
  while (ptVar6 = ptVar19->next, pcb_00 != ptVar19->next) {
LAB_23041024:
    ptVar19 = ptVar6;
    if (ptVar19 == (tcp_pcb *)0x0) goto LAB_23040faa;
  }
  goto LAB_23040fa0;
  while (ptVar6 = ptVar19->next, pcb_00 != ptVar19->next) {
LAB_23040fa8:
    ptVar19 = ptVar6;
    if (ptVar19 == (tcp_pcb *)0x0) goto LAB_23040faa;
  }
LAB_23040fa0:
  ptVar19->next = pcb_00->next;
LAB_23040faa:
  tcp_active_pcbs_changed = '\x01';
  pcb_00->state = TIME_WAIT;
  ptVar6 = pcb_00;
  pcb_00->next = tcp_tw_pcbs;
  tcp_tw_pcbs = ptVar6;
  tcp_timer_needed();
switchD_23040d14_caseD_8:
  if ((recv_flags & 8) == 0) {
    if (recv_acked != 0) {
      if ((pcb_00->sent != (tcp_sent_fn *)0x0) &&
         (eVar8 = (*pcb_00->sent)(pcb_00->callback_arg,pcb_00,recv_acked),
         CONCAT31(extraout_var_04,eVar8) == -0xd)) goto aborted;
      recv_acked = 0;
    }
    iVar11 = tcp_input_delayed_close(pcb_00);
    if (iVar11 == 0) {
      if (recv_data != (pbuf *)0x0) {
        if ((pcb_00->flags & 0x10) != 0) {
          pbuf_free(recv_data);
LAB_23040e74:
          tcp_abort(pcb_00);
          goto aborted;
        }
        if (pcb_00->recv == (tcp_recv_fn *)0x0) {
          eVar8 = tcp_recv_null((void *)0x0,pcb_00,recv_data,'\0');
          iVar11 = CONCAT31(extraout_var_06,eVar8);
        }
        else {
          eVar8 = (*pcb_00->recv)(pcb_00->callback_arg,pcb_00,recv_data,'\0');
          iVar11 = CONCAT31(extraout_var_05,eVar8);
        }
        if (iVar11 == -0xd) goto aborted;
        if (iVar11 != 0) {
          pcb_00->refused_data = recv_data;
        }
      }
      if ((recv_flags & 0x20) != 0) {
        p_00 = pcb_00->refused_data;
        if (p_00 == (pbuf *)0x0) {
          if (pcb_00->rcv_wnd != 0x810) {
            pcb_00->rcv_wnd = pcb_00->rcv_wnd + 1;
          }
          if ((pcb_00->recv != (tcp_recv_fn *)0x0) &&
             (eVar8 = (*pcb_00->recv)(pcb_00->callback_arg,pcb_00,(pbuf *)0x0,'\0'),
             CONCAT31(extraout_var_07,eVar8) == -0xd)) goto aborted;
        }
        else {
          p_00->flags = p_00->flags | 0x20;
        }
      }
      tcp_input_pcb = (tcp_pcb *)0x0;
      iVar11 = tcp_input_delayed_close(pcb_00);
      if (iVar11 == 0) {
        tcp_output(pcb_00);
      }
    }
  }
  else {
    if (pcb_00->errf != (tcp_err_fn *)0x0) {
      (*pcb_00->errf)(pcb_00->callback_arg,-0xe);
    }
    tcp_pcb_remove(&tcp_active_pcbs,pcb_00);
    tcp_free(pcb_00);
  }
aborted:
  tcp_input_pcb = (tcp_pcb *)0x0;
  recv_data = (pbuf *)0x0;
  if (inseg.p != (pbuf *)0x0) {
    pbuf_free(inseg.p);
    inseg.p = (pbuf *)0x0;
  }
  return;
}



void tcp_trigger_input_pcb_close(void)

{
  recv_flags = recv_flags | 0x10;
  return;
}



void tcp_seg_add_chksum(u16_t chksum,u16_t len,u16_t *seg_chksum,u8_t *seg_chksum_swapped)

{
  ushort uVar1;
  undefined2 in_register_0000202a;
  uint uVar2;
  
  uVar2 = CONCAT22(in_register_0000202a,chksum) + (uint)*seg_chksum;
  uVar2 = uVar2 + (uVar2 >> 0x10) & 0xffff;
  uVar1 = (ushort)uVar2;
  if ((len & 1) != 0) {
    *seg_chksum_swapped = '\x01' - *seg_chksum_swapped;
    uVar1 = (ushort)(uVar2 >> 8) | (ushort)(uVar2 << 8);
  }
  *seg_chksum = uVar1;
  return;
}



tcp_seg * tcp_create_segment(tcp_pcb *pcb,pbuf *p,u8_t hdrflags,u32_t seqno,u8_t optflags)

{
  tcp_seg *seg;
  u8_t uVar1;
  u16_t uVar2;
  undefined3 extraout_var;
  u32_t uVar3;
  undefined3 in_register_00002031;
  tcp_hdr *ptVar4;
  
  seg = (tcp_seg *)memp_malloc(MEMP_TCP_SEG);
  if (seg == (tcp_seg *)0x0) {
    pbuf_free(p);
  }
  else {
    seg->flags = optflags;
    seg->next = (tcp_seg *)0x0;
    seg->p = p;
    uVar2 = p->tot_len;
    seg->chksum = 0;
    seg->len = uVar2 + ((ushort)optflags & 1) * -4;
    seg->chksum_swapped = '\0';
    uVar1 = pbuf_add_header(p,0x14);
    if (CONCAT31(extraout_var,uVar1) == 0) {
      ptVar4 = (tcp_hdr *)seg->p->payload;
      seg->tcphdr = ptVar4;
      uVar2 = lwip_htons(pcb->local_port);
      *(char *)&ptVar4->src = (char)uVar2;
      *(undefined *)((int)&ptVar4->src + 1) = (char)(uVar2 >> 8);
      ptVar4 = seg->tcphdr;
      uVar2 = lwip_htons(pcb->remote_port);
      *(char *)&ptVar4->dest = (char)uVar2;
      *(undefined *)((int)&ptVar4->dest + 1) = (char)(uVar2 >> 8);
      ptVar4 = seg->tcphdr;
      uVar3 = lwip_htonl(seqno);
      *(char *)&ptVar4->seqno = (char)uVar3;
      *(undefined *)((int)&ptVar4->seqno + 1) = (char)(uVar3 >> 8);
      *(undefined *)((int)&ptVar4->seqno + 3) = (char)(uVar3 >> 0x18);
      *(undefined *)((int)&ptVar4->seqno + 2) = (char)(uVar3 >> 0x10);
      ptVar4 = seg->tcphdr;
      uVar2 = lwip_htons((((ushort)optflags & 1) + 5) * 0x1000 |
                         (ushort)CONCAT31(in_register_00002031,hdrflags));
      *(char *)&ptVar4->_hdrlen_rsvd_flags = (char)uVar2;
      *(undefined *)((int)&ptVar4->_hdrlen_rsvd_flags + 1) = (char)(uVar2 >> 8);
      ptVar4 = seg->tcphdr;
      *(undefined *)&ptVar4->urgp = 0;
      *(undefined *)((int)&ptVar4->urgp + 1) = 0;
    }
    else {
      lwip_stats.tcp.err = lwip_stats.tcp.err + 1;
      tcp_seg_free(seg);
      seg = (tcp_seg *)0x0;
    }
  }
  return seg;
}



pbuf * tcp_output_alloc_header_common
                 (u32_t ackno,u16_t datalen,u32_t seqno_be,u16_t src_port,u16_t dst_port,u8_t flags,
                 u16_t wnd)

{
  undefined *puVar1;
  u16_t uVar2;
  pbuf *ppVar3;
  u32_t uVar4;
  undefined2 in_register_0000202e;
  undefined3 in_register_0000203d;
  
  ppVar3 = pbuf_alloc(PBUF_IP,(u16_t)((uint)((CONCAT22(in_register_0000202e,datalen) + 0x14) *
                                            0x10000) >> 0x10),PBUF_RAM);
  if (ppVar3 != (pbuf *)0x0) {
    puVar1 = (undefined *)ppVar3->payload;
    uVar2 = lwip_htons(src_port);
    *puVar1 = (char)uVar2;
    puVar1[1] = (char)(uVar2 >> 8);
    uVar2 = lwip_htons(dst_port);
    puVar1[2] = (char)uVar2;
    puVar1[4] = (char)seqno_be;
    puVar1[5] = (char)(seqno_be >> 8);
    puVar1[3] = (char)(uVar2 >> 8);
    puVar1[6] = (char)(seqno_be >> 0x10);
    puVar1[7] = (char)(seqno_be >> 0x18);
    uVar4 = lwip_htonl(ackno);
    puVar1[8] = (char)uVar4;
    puVar1[9] = (char)(uVar4 >> 8);
    puVar1[0xb] = (char)(uVar4 >> 0x18);
    puVar1[10] = (char)(uVar4 >> 0x10);
    uVar2 = lwip_htons((ushort)CONCAT31(in_register_0000203d,flags) | 0x5000);
    puVar1[0xc] = (char)uVar2;
    puVar1[0xd] = (char)(uVar2 >> 8);
    uVar2 = lwip_htons(wnd);
    puVar1[0xe] = (char)uVar2;
    puVar1[0xf] = (char)(uVar2 >> 8);
    puVar1[0x10] = 0;
    puVar1[0x11] = 0;
    puVar1[0x12] = 0;
    puVar1[0x13] = 0;
  }
  return ppVar3;
}



pbuf * tcp_output_alloc_header(tcp_pcb *pcb,u16_t datalen,u32_t seqno_be)

{
  pbuf *ppVar1;
  
  ppVar1 = tcp_output_alloc_header_common
                     (pcb->rcv_nxt,datalen,seqno_be,pcb->local_port,pcb->remote_port,'\x10',
                      pcb->rcv_ann_wnd);
  if (ppVar1 != (pbuf *)0x0) {
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + (uint)pcb->rcv_ann_wnd;
  }
  return ppVar1;
}



err_t tcp_output_control_segment(tcp_pcb *pcb,pbuf *p,ip_addr_t *src,ip_addr_t *dst)

{
  err_t eVar1;
  u16_t uVar2;
  netif *netif;
  u8_t ttl;
  u8_t tos;
  void *pvVar3;
  
  if ((pcb == (tcp_pcb *)0x0) || (pcb->netif_idx == '\0')) {
    netif = ip4_route((ip4_addr_t *)dst);
  }
  else {
    netif = netif_get_by_index(pcb->netif_idx);
  }
  eVar1 = -4;
  if (netif != (netif *)0x0) {
    pvVar3 = p->payload;
    uVar2 = ip_chksum_pseudo(p,'\x06',p->tot_len,(ip4_addr_t *)src,(ip4_addr_t *)dst);
    *(undefined *)((int)pvVar3 + 0x10) = (char)uVar2;
    *(undefined *)((int)pvVar3 + 0x11) = (char)(uVar2 >> 8);
    if (pcb == (tcp_pcb *)0x0) {
      tos = '\0';
      ttl = -1;
    }
    else {
      ttl = pcb->ttl;
      tos = pcb->tos;
    }
    lwip_stats.tcp.xmit = lwip_stats.tcp.xmit + 1;
    eVar1 = ip4_output_if(p,(ip4_addr_t *)src,(ip4_addr_t *)dst,ttl,tos,'\x06',netif);
  }
  pbuf_free(p);
  return eVar1;
}



err_t tcp_split_unsent_seg(tcp_pcb *pcb,u16_t split)

{
  byte bVar1;
  ushort *puVar2;
  ushort uVar3;
  tcp_seg *ptVar4;
  uint uVar5;
  u16_t len;
  u16_t uVar6;
  pbuf *p;
  undefined2 extraout_var;
  u32_t uVar7;
  tcp_seg *ptVar8;
  undefined2 in_register_0000202e;
  byte hdrflags;
  tcp_hdr *ptVar9;
  int iVar10;
  uint uVar11;
  uint uVar12;
  u8_t uStack51;
  u16_t uStack50;
  u8_t chksum_swapped;
  u16_t chksum;
  
  uVar5 = CONCAT22(in_register_0000202e,split);
  ptVar4 = pcb->unsent;
  uStack50 = 0;
  uStack51 = '\0';
  if (ptVar4 != (tcp_seg *)0x0) {
    if (uVar5 == 0) {
      return -6;
    }
    uVar11 = (uint)ptVar4->len;
    if (uVar11 <= uVar5) {
      return '\0';
    }
    bVar1 = ptVar4->flags;
    iVar10 = ((uint)bVar1 & 1) * 4;
    uVar12 = uVar11 - uVar5 & 0xffff;
    p = pbuf_alloc(PBUF_TRANSPORT,(u16_t)((uVar12 + iVar10) * 0x10000 >> 0x10),PBUF_RAM);
    if ((p != (pbuf *)0x0) &&
       (len = pbuf_copy_partial(ptVar4->p,(void *)((int)p->payload + iVar10),
                                (u16_t)((uVar11 - uVar5) * 0x10000 >> 0x10),
                                (u16_t)((((uint)ptVar4->p->tot_len - (uint)ptVar4->len) + uVar5) *
                                        0x10000 >> 0x10)), CONCAT22(extraout_var,len) == uVar12)) {
      uVar6 = inet_chksum((void *)((int)p->payload + iVar10),len);
      tcp_seg_add_chksum(~uVar6,len,&uStack50,&uStack51);
      len = lwip_htons(ptVar4->tcphdr->_hdrlen_rsvd_flags);
      hdrflags = (byte)len & 8;
      if ((len & 8) == 0) {
        len = len & 0x3f;
      }
      else {
        len = len & 0x37;
        hdrflags = 8;
      }
      if ((len & 1) != 0) {
        len = len & 0xfe;
        hdrflags = hdrflags | 1;
      }
      uVar7 = lwip_htonl(ptVar4->tcphdr->seqno);
      ptVar8 = tcp_create_segment(pcb,p,hdrflags,uVar5 + uVar7,bVar1 & 0xfb);
      if (ptVar8 != (tcp_seg *)0x0) {
        ptVar8->chksum = uStack50;
        ptVar8->chksum_swapped = uStack51;
        ptVar8->flags = ptVar8->flags | 4;
        uVar6 = pbuf_clen(ptVar4->p);
        pcb->snd_queuelen = pcb->snd_queuelen - uVar6;
        pbuf_realloc(ptVar4->p,
                     (u16_t)(((uint)ptVar4->p->tot_len + (uVar5 - uVar11 & 0xffff)) * 0x10000 >>
                            0x10));
        ptVar4->len = (short)((uVar5 - uVar11) * 0x10000 >> 0x10) + ptVar4->len;
        uVar3 = ptVar4->tcphdr->_hdrlen_rsvd_flags;
        len = lwip_htons(len);
        ptVar9 = ptVar4->tcphdr;
        uVar3 = uVar3 | len;
        *(char *)&ptVar9->_hdrlen_rsvd_flags = (char)uVar3;
        *(undefined *)((int)&ptVar9->_hdrlen_rsvd_flags + 1) = (char)((uint)uVar3 >> 8);
        len = pbuf_clen(ptVar4->p);
        pcb->snd_queuelen = len + pcb->snd_queuelen;
        p = ptVar4->p;
        ptVar4->chksum = 0;
        ptVar4->chksum_swapped = '\0';
        uVar5 = (uint)p->tot_len - (uint)ptVar4->len;
        while( true ) {
          uVar5 = uVar5 & 0xffff;
          puVar2 = &p->len;
          if (uVar5 <= *puVar2) break;
          p = p->next;
          uVar5 = uVar5 - *puVar2;
          if (p == (pbuf *)0x0) goto LAB_230416fa;
        }
        do {
          len = inet_chksum((void *)((int)p->payload + uVar5),
                            (u16_t)((p->len - uVar5) * 0x10000 >> 0x10));
          tcp_seg_add_chksum(~len,(u16_t)((p->len - uVar5) * 0x10000 >> 0x10),&ptVar4->chksum,
                             &ptVar4->chksum_swapped);
          p = p->next;
          uVar5 = 0;
        } while (p != (pbuf *)0x0);
LAB_230416fa:
        len = pbuf_clen(ptVar8->p);
        pcb->snd_queuelen = len + pcb->snd_queuelen;
        ptVar8->next = ptVar4->next;
        ptVar4->next = ptVar8;
        ptVar4 = ptVar8->next;
        if (ptVar4 != (tcp_seg *)0x0) {
          return '\0';
        }
        pcb->unsent_oversize = 0;
        return (err_t)ptVar4;
      }
    }
    lwip_stats.tcp.memerr = lwip_stats.tcp.memerr + 1;
    if (p != (pbuf *)0x0) {
      pbuf_free(p);
    }
  }
  return -1;
}



err_t tcp_enqueue_flags(tcp_pcb *pcb,u8_t flags)

{
  err_t eVar1;
  u16_t uVar2;
  pbuf *p;
  tcp_seg *ptVar3;
  uint uVar4;
  tcp_seg *ptVar5;
  tcp_seg *ptVar6;
  
  uVar4 = ((uint)flags & 2) >> 1;
  p = pbuf_alloc(PBUF_TRANSPORT,(u16_t)(uVar4 << 2),PBUF_RAM);
  if ((p == (pbuf *)0x0) ||
     (ptVar3 = tcp_create_segment(pcb,p,flags,pcb->snd_lbb,(u8_t)uVar4), ptVar3 == (tcp_seg *)0x0))
  {
    eVar1 = -1;
    pcb->flags = pcb->flags | 0x80;
    lwip_stats.tcp.memerr = lwip_stats.tcp.memerr + 1;
  }
  else {
    ptVar5 = pcb->unsent;
    if (pcb->unsent == (tcp_seg *)0x0) {
      pcb->unsent = ptVar3;
    }
    else {
      do {
        ptVar6 = ptVar5;
        ptVar5 = ptVar6->next;
      } while (ptVar5 != (tcp_seg *)0x0);
      ptVar6->next = ptVar3;
    }
    pcb->unsent_oversize = 0;
    if ((flags & 3) != 0) {
      pcb->snd_lbb = pcb->snd_lbb + 1;
    }
    if ((flags & 1) != 0) {
      pcb->flags = pcb->flags | 0x20;
    }
    uVar2 = pbuf_clen(ptVar3->p);
    pcb->snd_queuelen = uVar2 + pcb->snd_queuelen;
    eVar1 = '\0';
  }
  return eVar1;
}



err_t tcp_send_fin(tcp_pcb *pcb)

{
  ushort uVar1;
  tcp_seg *ptVar2;
  tcp_seg *ptVar3;
  err_t eVar4;
  u16_t uVar5;
  tcp_hdr *ptVar6;
  
  ptVar2 = pcb->unsent;
  if (pcb->unsent != (tcp_seg *)0x0) {
    do {
      ptVar3 = ptVar2;
      ptVar2 = ptVar3->next;
    } while (ptVar3->next != (tcp_seg *)0x0);
    uVar5 = lwip_htons(ptVar3->tcphdr->_hdrlen_rsvd_flags);
    if ((uVar5 & 7) == 0) {
      uVar1 = ptVar3->tcphdr->_hdrlen_rsvd_flags;
      uVar5 = lwip_htons(1);
      ptVar6 = ptVar3->tcphdr;
      uVar1 = uVar5 | uVar1;
      *(char *)&ptVar6->_hdrlen_rsvd_flags = (char)uVar1;
      *(undefined *)((int)&ptVar6->_hdrlen_rsvd_flags + 1) = (char)((uint)uVar1 >> 8);
      pcb->flags = pcb->flags | 0x20;
      return '\0';
    }
  }
  eVar4 = tcp_enqueue_flags(pcb,'\x01');
  return eVar4;
}



err_t tcp_rexmit_rto_prepare(tcp_pcb *pcb)

{
  u8_t uVar1;
  ushort uVar2;
  tcp_seg *ptVar3;
  u16_t uVar4;
  u32_t uVar5;
  tcp_seg *ptVar6;
  
  ptVar3 = pcb->unacked;
  if (pcb->unacked != (tcp_seg *)0x0) {
    do {
      uVar1 = ptVar3->p->ref;
      if (ptVar3->next == (tcp_seg *)0x0) {
        if (uVar1 != '\x01') {
          return -6;
        }
        ptVar3->next = pcb->unsent;
        ptVar6 = pcb->unacked;
        pcb->unacked = (tcp_seg *)0x0;
        pcb->unsent = ptVar6;
        pcb->flags = pcb->flags | 0x800;
        uVar5 = lwip_htonl(ptVar3->tcphdr->seqno);
        uVar2 = ptVar3->len;
        uVar4 = lwip_htons(ptVar3->tcphdr->_hdrlen_rsvd_flags);
        pcb->rto_end = (uint)((uVar4 & 3) != 0) + uVar5 + uVar2;
        pcb->rttest = 0;
        return '\0';
      }
      ptVar3 = ptVar3->next;
    } while (uVar1 == '\x01');
  }
  return -6;
}



err_t tcp_rexmit(tcp_pcb *pcb)

{
  tcp_seg *ptVar1;
  u32_t uVar2;
  u32_t uVar3;
  err_t eVar4;
  tcp_seg *ptVar5;
  
  ptVar1 = pcb->unacked;
  eVar4 = -6;
  if ((ptVar1 != (tcp_seg *)0x0) && (eVar4 = -6, ptVar1->p->ref == '\x01')) {
    ptVar5 = (tcp_seg *)&pcb->unsent;
    pcb->unacked = ptVar1->next;
    while (ptVar5->next != (tcp_seg *)0x0) {
      uVar2 = lwip_htonl(ptVar5->next->tcphdr->seqno);
      uVar3 = lwip_htonl(ptVar1->tcphdr->seqno);
      if (-1 < (int)(uVar2 - uVar3)) break;
      ptVar5 = ptVar5->next;
    }
    ptVar1->next = ptVar5->next;
    ptVar5->next = ptVar1;
    if (ptVar1->next == (tcp_seg *)0x0) {
      pcb->unsent_oversize = 0;
    }
    if (pcb->nrtx != -1) {
      pcb->nrtx = pcb->nrtx + '\x01';
    }
    pcb->rttest = 0;
    eVar4 = '\0';
  }
  return eVar4;
}



void tcp_rexmit_fast(tcp_pcb *pcb)

{
  err_t eVar1;
  undefined3 extraout_var;
  uint uVar2;
  uint uVar3;
  
  if (pcb->unacked != (tcp_seg *)0x0) {
    if (((pcb->flags & 4) == 0) && (eVar1 = tcp_rexmit(pcb), CONCAT31(extraout_var,eVar1) == 0)) {
      uVar3 = (uint)pcb->snd_wnd;
      if ((uint)pcb->cwnd < (uint)pcb->snd_wnd) {
        uVar3 = (uint)pcb->cwnd;
      }
      pcb->ssthresh = (tcpwnd_size_t)((int)uVar3 >> 1);
      uVar2 = (uint)pcb->mss << 1;
      if ((uint)((int)uVar3 >> 1) < uVar2) {
        pcb->ssthresh = (tcpwnd_size_t)uVar2;
      }
      pcb->rtime = 0;
      pcb->cwnd = pcb->mss * 3 + pcb->ssthresh;
      pcb->flags = pcb->flags | 4;
    }
    return;
  }
  return;
}



void tcp_rst(tcp_pcb *pcb,u32_t seqno,u32_t ackno,ip_addr_t *param_4,ip_addr_t *remote_ip,
            u16_t param_6,u16_t remote_port)

{
  u32_t seqno_be;
  pbuf *p;
  
  seqno_be = lwip_htonl(seqno);
  p = tcp_output_alloc_header_common(ackno,0,seqno_be,param_6,remote_port,'\x14',0x1008);
  if (p != (pbuf *)0x0) {
    tcp_output_control_segment(pcb,p,param_4,remote_ip);
    return;
  }
  return;
}



err_t tcp_send_empty_ack(tcp_pcb *pcb)

{
  err_t eVar1;
  u32_t seqno_be;
  pbuf *p;
  undefined3 extraout_var;
  tcpflags_t tVar2;
  
  seqno_be = lwip_htonl(pcb->snd_nxt);
  p = tcp_output_alloc_header(pcb,0,seqno_be);
  if (p == (pbuf *)0x0) {
    eVar1 = -2;
    pcb->flags = pcb->flags | 3;
  }
  else {
    eVar1 = tcp_output_control_segment(pcb,p,(ip_addr_t *)pcb,&pcb->remote_ip);
    if (CONCAT31(extraout_var,eVar1) == 0) {
      tVar2 = pcb->flags & 0xfffc;
    }
    else {
      tVar2 = pcb->flags | 3;
    }
    pcb->flags = tVar2;
  }
  return eVar1;
}



err_t tcp_output(tcp_pcb *pcb)

{
  ushort uVar1;
  ushort uVar2;
  bool bVar3;
  short sVar4;
  tcp_seg *ptVar5;
  tcp_seg *seg;
  err_t eVar6;
  u16_t proto_len;
  u16_t uVar7;
  netif *outif;
  u32_t uVar8;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  uint uVar9;
  undefined3 extraout_var;
  u32_t uVar10;
  tcp_hdr *ptVar11;
  pbuf *p;
  tcp_seg *ptVar12;
  tcp_seg *ptVar13;
  uint uVar14;
  ip4_addr_t *dest;
  
  if (tcp_input_pcb == pcb) {
    return '\0';
  }
  seg = pcb->unsent;
  if (seg == (tcp_seg *)0x0) {
    uVar1 = pcb->flags;
  }
  else {
    uVar1 = pcb->cwnd;
    uVar2 = pcb->snd_wnd;
    dest = (ip4_addr_t *)&pcb->remote_ip;
    if (pcb->netif_idx == '\0') {
      outif = ip4_route(dest);
    }
    else {
      outif = netif_get_by_index(pcb->netif_idx);
    }
    if (outif == (netif *)0x0) {
      return -4;
    }
    if ((pcb->local_ip).addr == 0) {
      (pcb->local_ip).addr = (outif->ip_addr).addr;
    }
    uVar14 = (uint)uVar1;
    if ((uint)uVar2 < (uint)uVar1) {
      uVar14 = (uint)uVar2;
    }
    uVar8 = lwip_htonl(seg->tcphdr->seqno);
    if (uVar8 + ((uint)seg->len - pcb->lastack) <= uVar14) {
      pcb->persist_backoff = '\0';
      ptVar12 = pcb->unacked;
      ptVar13 = pcb->unacked;
      while (ptVar5 = ptVar12, ptVar5 != (tcp_seg *)0x0) {
        ptVar12 = ptVar5->next;
        ptVar13 = ptVar5;
      }
      do {
        uVar8 = lwip_htonl(seg->tcphdr->seqno);
        if ((uVar14 < (uVar8 - pcb->lastack) + (uint)seg->len) ||
           (((((lwip_htons(seg->tcphdr->_hdrlen_rsvd_flags), pcb->unacked != (tcp_seg *)0x0 &&
               ((pcb->flags & 0x44) == 0)) &&
              ((ptVar12 = pcb->unsent, ptVar12 == (tcp_seg *)0x0 ||
               ((ptVar12->next == (tcp_seg *)0x0 && (ptVar12->len < pcb->mss)))))) &&
             (pcb->snd_buf != 0)) && ((pcb->snd_queuelen < 0x10 && ((pcb->flags & 0xa0) == 0)))))) {
          if (pcb->unsent != (tcp_seg *)0x0) goto output_done;
          break;
        }
        if (pcb->state != SYN_SENT) {
          uVar1 = seg->tcphdr->_hdrlen_rsvd_flags;
          proto_len = lwip_htons(0x10);
          ptVar11 = seg->tcphdr;
          uVar1 = proto_len | uVar1;
          *(char *)&ptVar11->_hdrlen_rsvd_flags = (char)uVar1;
          *(undefined *)((int)&ptVar11->_hdrlen_rsvd_flags + 1) = (char)((uint)uVar1 >> 8);
        }
        if (seg->p->ref == '\x01') {
          ptVar11 = seg->tcphdr;
          uVar8 = lwip_htonl(pcb->rcv_nxt);
          *(char *)&ptVar11->ackno = (char)uVar8;
          *(undefined *)((int)&ptVar11->ackno + 1) = (char)(uVar8 >> 8);
          *(undefined *)((int)&ptVar11->ackno + 2) = (char)(uVar8 >> 0x10);
          *(undefined *)((int)&ptVar11->ackno + 3) = (char)(uVar8 >> 0x18);
          ptVar11 = seg->tcphdr;
          proto_len = lwip_htons(pcb->rcv_ann_wnd);
          *(char *)&ptVar11->wnd = (char)proto_len;
          *(undefined *)((int)&ptVar11->wnd + 1) = (char)(proto_len >> 8);
          pcb->rcv_ann_right_edge = pcb->rcv_nxt + (uint)pcb->rcv_ann_wnd;
          if ((seg->flags & 1) != 0) {
            ptVar11 = seg->tcphdr;
            proto_len = tcp_eff_send_mss_netif(0x2b0,outif,(ip_addr_t *)dest);
            uVar8 = lwip_htonl(CONCAT22(extraout_var_00,proto_len) | 0x2040000);
            *(u32_t *)(ptVar11 + 1) = uVar8;
          }
          if (pcb->rtime < 0) {
            pcb->rtime = 0;
          }
          if (pcb->rttest == 0) {
            pcb->rttest = tcp_ticks;
            uVar8 = lwip_htonl(seg->tcphdr->seqno);
            pcb->rtseq = uVar8;
          }
          p = seg->p;
          sVar4 = (short)((uint)((int)((int)seg->tcphdr - (int)p->payload) * 0x10000) >> 0x10);
          p->len = p->len - sVar4;
          seg->p->tot_len = seg->p->tot_len - sVar4;
          ptVar11 = seg->tcphdr;
          *(tcp_hdr **)&seg->p->payload = ptVar11;
          *(undefined *)&ptVar11->chksum = 0;
          *(undefined *)((int)&ptVar11->chksum + 1) = 0;
          if ((seg->flags & 4) == 0) {
            lwip_htons(seg->tcphdr->_hdrlen_rsvd_flags);
          }
          p = seg->p;
          proto_len = p->tot_len;
          uVar7 = lwip_htons(seg->tcphdr->_hdrlen_rsvd_flags);
          proto_len = ip_chksum_pseudo_partial
                                (p,'\x06',proto_len,
                                 (ushort)(CONCAT22(extraout_var_01,uVar7) >> 10) & 0xfc,
                                 (ip4_addr_t *)pcb,dest);
          bVar3 = seg->chksum_swapped != '\0';
          if (bVar3) {
            seg->chksum_swapped = '\0';
            seg->chksum = seg->chksum >> 8 | seg->chksum << 8;
          }
          ptVar11 = seg->tcphdr;
          uVar9 = (uint)seg->chksum + (~(uint)proto_len & 0xffff);
          uVar9 = ~((uVar9 >> 0x10) + uVar9);
          *(char *)&ptVar11->chksum = (char)uVar9;
          *(undefined *)((int)&ptVar11->chksum + 1) = (char)(uVar9 >> 8);
          lwip_stats.tcp.xmit = lwip_stats.tcp.xmit + 1;
          eVar6 = ip4_output_if(seg->p,(ip4_addr_t *)pcb,dest,pcb->ttl,pcb->tos,'\x06',outif);
          if (bVar3) {
            seg->chksum_swapped = '\x01';
            seg->chksum = seg->chksum >> 8 | seg->chksum << 8;
          }
          if (CONCAT31(extraout_var,eVar6) != 0) {
            pcb->flags = pcb->flags | 0x80;
            return eVar6;
          }
        }
        pcb->unsent = seg->next;
        if (pcb->state != SYN_SENT) {
          pcb->flags = pcb->flags & 0xfffc;
        }
        uVar8 = lwip_htonl(seg->tcphdr->seqno);
        uVar1 = seg->len;
        proto_len = lwip_htons(seg->tcphdr->_hdrlen_rsvd_flags);
        uVar8 = (uint)((proto_len & 3) != 0) + uVar8 + uVar1;
        if ((int)(pcb->snd_nxt - uVar8) < 0) {
          pcb->snd_nxt = uVar8;
        }
        uVar1 = seg->len;
        proto_len = lwip_htons(seg->tcphdr->_hdrlen_rsvd_flags);
        if ((uint)((proto_len & 3) != 0) + (uint)uVar1 == 0) {
          tcp_seg_free(seg);
        }
        else {
          seg->next = (tcp_seg *)0x0;
          if (pcb->unacked == (tcp_seg *)0x0) {
            pcb->unacked = seg;
            ptVar13 = seg;
          }
          else {
            uVar8 = lwip_htonl(seg->tcphdr->seqno);
            uVar10 = lwip_htonl(ptVar13->tcphdr->seqno);
            ptVar12 = (tcp_seg *)&pcb->unacked;
            if ((int)(uVar8 - uVar10) < 0) {
              while (ptVar12->next != (tcp_seg *)0x0) {
                uVar8 = lwip_htonl(ptVar12->next->tcphdr->seqno);
                uVar10 = lwip_htonl(seg->tcphdr->seqno);
                if (-1 < (int)(uVar8 - uVar10)) break;
                ptVar12 = ptVar12->next;
              }
              seg->next = ptVar12->next;
              ptVar12->next = seg;
            }
            else {
              ptVar13->next = seg;
              ptVar13 = seg;
            }
          }
        }
        seg = pcb->unsent;
      } while (seg != (tcp_seg *)0x0);
      pcb->unsent_oversize = 0;
      goto output_done;
    }
    if ((((uint)pcb->snd_wnd == uVar14) && (pcb->unacked == (tcp_seg *)0x0)) &&
       (pcb->persist_backoff == '\0')) {
      *(undefined2 *)&pcb->persist_cnt = 0x100;
      pcb->persist_probe = '\0';
    }
    uVar1 = pcb->flags;
  }
  if ((uVar1 & 2) != 0) {
    eVar6 = tcp_send_empty_ack(pcb);
    return eVar6;
  }
output_done:
  pcb->flags = pcb->flags & 0xff7f;
  return '\0';
}



void tcp_rexmit_rto_commit(tcp_pcb *pcb)

{
  if (pcb->nrtx != -1) {
    pcb->nrtx = pcb->nrtx + '\x01';
  }
  tcp_output(pcb);
  return;
}



void tcp_rexmit_rto(tcp_pcb *pcb)

{
  err_t eVar1;
  undefined3 extraout_var;
  
  eVar1 = tcp_rexmit_rto_prepare(pcb);
  if (CONCAT31(extraout_var,eVar1) == 0) {
    tcp_rexmit_rto_commit(pcb);
    return;
  }
  return;
}



err_t tcp_keepalive(tcp_pcb *pcb)

{
  err_t eVar1;
  u32_t seqno_be;
  pbuf *p;
  
  seqno_be = lwip_htonl(pcb->snd_nxt - 1);
  p = tcp_output_alloc_header(pcb,0,seqno_be);
  if (p != (pbuf *)0x0) {
    eVar1 = tcp_output_control_segment(pcb,p,(ip_addr_t *)pcb,&pcb->remote_ip);
    return eVar1;
  }
  return -1;
}



err_t tcp_zero_window_probe(tcp_pcb *pcb)

{
  ushort uVar1;
  uint uVar2;
  err_t eVar3;
  u16_t uVar4;
  pbuf *p;
  u32_t uVar5;
  tcp_seg *ptVar6;
  void *pvVar7;
  
  ptVar6 = pcb->unsent;
  if (ptVar6 == (tcp_seg *)0x0) {
    eVar3 = '\0';
  }
  else {
    if (pcb->persist_probe != -1) {
      pcb->persist_probe = pcb->persist_probe + '\x01';
    }
    uVar2 = 0;
    uVar4 = lwip_htons(ptVar6->tcphdr->_hdrlen_rsvd_flags);
    if ((uVar4 & 1) != 0) {
      uVar2 = (uint)(ptVar6->len == 0);
    }
    p = tcp_output_alloc_header(pcb,(ushort)uVar2 ^ 1,ptVar6->tcphdr->seqno);
    if (p != (pbuf *)0x0) {
      pvVar7 = p->payload;
      if (uVar2 == 0) {
        pbuf_copy_partial(ptVar6->p,(void *)((int)pvVar7 + 0x14),1,
                          (u16_t)(((uint)ptVar6->p->tot_len - (uint)ptVar6->len) * 0x10000 >> 0x10))
        ;
      }
      else {
        uVar1 = *(ushort *)((int)pvVar7 + 0xc);
        uVar4 = lwip_htons(0x11);
        uVar2 = (int)(short)(uVar1 & 0xc0ff) | (uint)uVar4;
        *(undefined *)((int)pvVar7 + 0xc) = (char)uVar2;
        *(undefined *)((int)pvVar7 + 0xd) = (char)(uVar2 >> 8);
      }
      uVar5 = lwip_htonl(ptVar6->tcphdr->seqno);
      if ((int)(pcb->snd_nxt - (uVar5 + 1)) < 0) {
        pcb->snd_nxt = uVar5 + 1;
      }
      eVar3 = tcp_output_control_segment(pcb,p,(ip_addr_t *)pcb,&pcb->remote_ip);
      return eVar3;
    }
    eVar3 = -1;
  }
  return eVar3;
}



void sys_timeout_abs(u32_t abs_time,sys_timeout_handler *handler,void *arg)

{
  sys_timeo *psVar1;
  sys_timeo *psVar2;
  sys_timeo *psVar3;
  
  psVar1 = (sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
  psVar2 = next_timeout;
  psVar3 = next_timeout;
  if (psVar1 != (sys_timeo *)0x0) {
    psVar1->next = (sys_timeo *)0x0;
    psVar1->h = handler;
    psVar1->arg = arg;
    psVar1->time = abs_time;
    psVar3 = psVar1;
    if (psVar2 != (sys_timeo *)0x0) {
      if ((int)(abs_time - psVar2->time) < 0) {
        psVar1->next = psVar2;
      }
      else {
        do {
          psVar3 = psVar2;
          psVar2 = psVar3->next;
          if (psVar2 == (sys_timeo *)0x0) break;
        } while (-1 < (int)(abs_time - psVar2->time));
        psVar1->next = psVar2;
        psVar3->next = psVar1;
        psVar3 = next_timeout;
      }
    }
  }
  next_timeout = psVar3;
  return;
}



void lwip_cyclic_timer(void *arg)

{
  TickType_t TVar1;
  u32_t abs_time;
  u32_t uVar2;
  
  (**(code **)((int)arg + 4))(*(code **)((int)arg + 4));
  TVar1 = sys_now();
  uVar2 = current_timeout_due_time + *(int *)arg;
  abs_time = TVar1 + *(int *)arg;
  if (-1 < (int)(uVar2 - TVar1)) {
    abs_time = uVar2;
  }
  sys_timeout_abs(abs_time,lwip_cyclic_timer,arg);
  return;
}



void sys_timeout(u32_t msecs,sys_timeout_handler *handler,void *arg)

{
  TickType_t TVar1;
  
  TVar1 = sys_now();
  sys_timeout_abs(TVar1 + msecs,handler,arg);
  return;
}



void tcp_timer_needed(void)

{
  if ((tcpip_tcp_timer_active == 0) &&
     ((tcp_active_pcbs != (tcp_pcb *)0x0 || (tcp_tw_pcbs != (tcp_pcb *)0x0)))) {
    tcpip_tcp_timer_active = 1;
    sys_timeout(0xfa,tcpip_tcp_timer,(void *)0x0);
    return;
  }
  return;
}



void tcpip_tcp_timer(void *arg)

{
  tcp_tmr();
  if ((tcp_active_pcbs == (tcp_pcb *)0x0) && (tcp_tw_pcbs == (tcp_pcb *)0x0)) {
    tcpip_tcp_timer_active = 0;
    return;
  }
  sys_timeout(0xfa,tcpip_tcp_timer,(void *)0x0);
  return;
}



void sys_timeouts_init(void)

{
  u32_t *arg;
  u32_t *puVar1;
  
  arg = &DAT_2307ace0;
  do {
    puVar1 = arg + 2;
    sys_timeout(*arg,lwip_cyclic_timer,arg);
    arg = puVar1;
  } while (puVar1 != (u32_t *)0x2307ad08);
  return;
}



void sys_check_timeouts(void)

{
  sys_timeo *mem;
  sys_timeout_handler *psVar1;
  void *pvVar2;
  TickType_t TVar3;
  
  TVar3 = sys_now();
  while ((mem = next_timeout, next_timeout != (sys_timeo *)0x0 &&
         (-1 < (int)(TVar3 - next_timeout->time)))) {
    psVar1 = next_timeout->h;
    pvVar2 = next_timeout->arg;
    current_timeout_due_time = next_timeout->time;
    next_timeout = next_timeout->next;
    memp_free(MEMP_SYS_TIMEOUT,mem);
    if (psVar1 != (sys_timeout_handler *)0x0) {
      (*psVar1)(pvVar2);
    }
  }
  return;
}



u32_t sys_timeouts_sleeptime(void)

{
  u32_t uVar1;
  TickType_t TVar2;
  
  uVar1 = 0xffffffff;
  if (next_timeout != (sys_timeo *)0x0) {
    TVar2 = sys_now();
    uVar1 = next_timeout->time - TVar2;
    if ((int)uVar1 < 0) {
      uVar1 = 0;
    }
  }
  return uVar1;
}



void udp_init(void)

{
  int iVar1;
  
  iVar1 = bl_rand();
  udp_port = (ushort)((uint)(iVar1 << 0x12) >> 0x12) + 0xc000;
  return;
}



void udp_input(pbuf *p,netif *inp)

{
  udp_pcb *puVar1;
  udp_pcb *puVar2;
  u8_t uVar3;
  u16_t uVar4;
  u16_t uVar5;
  undefined3 extraout_var;
  undefined2 extraout_var_01;
  undefined2 extraout_var_02;
  undefined2 extraout_var_03;
  undefined3 extraout_var_00;
  u32_t uVar6;
  uint uVar7;
  udp_pcb *puVar8;
  udp_pcb *puVar9;
  udp_pcb *puVar10;
  u16_t *puVar11;
  
  lwip_stats.udp.recv = lwip_stats.udp.recv + 1;
  if (p->len < 8) {
    lwip_stats.udp.lenerr = lwip_stats.udp.lenerr + 1;
    lwip_stats.udp.drop = lwip_stats.udp.drop + 1;
  }
  else {
    puVar11 = (u16_t *)p->payload;
    uVar3 = ip4_addr_isbroadcast_u32(ip_data.current_iphdr_dest,ip_data.current_netif);
    _uVar3 = CONCAT31(extraout_var,uVar3);
    uVar4 = lwip_htons(*puVar11);
    uVar5 = lwip_htons(puVar11[1]);
    puVar1 = udp_pcbs;
    puVar9 = (udp_pcb *)0x0;
    puVar2 = udp_pcbs;
    puVar8 = (udp_pcb *)0x0;
    while (puVar10 = puVar2, puVar10 != (udp_pcb *)0x0) {
      if (((uint)puVar10->local_port == CONCAT22(extraout_var_02,uVar5)) &&
         ((puVar10->netif_idx == '\0' ||
          (puVar10->netif_idx == (u8_t)((ip_data.current_input_netif)->num + '\x01'))))) {
        uVar7 = (puVar10->local_ip).addr;
        if (_uVar3 == 0) {
          if ((uVar7 == 0) || (uVar7 == ip_data.current_iphdr_dest)) goto LAB_230424d8;
        }
        else {
          if ((uVar7 == 0) ||
             ((ip_data.current_iphdr_dest == 0xffffffff ||
              (((uVar7 ^ ip_data.current_iphdr_dest) & (inp->netmask).addr) == 0)))) {
LAB_230424d8:
            if ((puVar10->flags & 4) != 0) goto LAB_2304250e;
            if (puVar9 == (udp_pcb *)0x0) {
LAB_230424fc:
              puVar9 = puVar10;
            }
            else {
              if ((_uVar3 == 0) || (ip_data.current_iphdr_dest != 0xffffffff)) {
                if (uVar7 != 0) goto LAB_230424fc;
              }
              else {
                uVar6 = (inp->ip_addr).addr;
                if (((puVar9->local_ip).addr != uVar6) && (uVar6 == uVar7)) goto LAB_230424fc;
              }
            }
LAB_2304250e:
            if (((uint)puVar10->remote_port == CONCAT22(extraout_var_01,uVar4)) &&
               ((uVar6 = (puVar10->remote_ip).addr, uVar6 == 0 ||
                (uVar6 == ip_data.current_iphdr_src)))) {
              if (puVar8 == (udp_pcb *)0x0) {
                lwip_stats.udp.cachehit = lwip_stats.udp.cachehit + 1;
              }
              else {
                udp_pcbs = puVar10;
                puVar8->next = puVar10->next;
                puVar10->next = puVar1;
              }
              goto LAB_23042532;
            }
          }
        }
      }
      puVar2 = puVar10->next;
      puVar8 = puVar10;
    }
    puVar10 = puVar9;
    if ((puVar9 != (udp_pcb *)0x0) || ((inp->ip_addr).addr == ip_data.current_iphdr_dest)) {
LAB_23042532:
      if ((puVar11[3] == 0) ||
         (uVar5 = ip_chksum_pseudo(p,'\x11',p->tot_len,(ip4_addr_t *)&ip_data.current_iphdr_src,
                                   (ip4_addr_t *)&ip_data.current_iphdr_dest),
         CONCAT22(extraout_var_03,uVar5) == 0)) {
        uVar3 = pbuf_remove_header(p,8);
        if (CONCAT31(extraout_var_00,uVar3) == 0) {
          if (puVar10 != (udp_pcb *)0x0) {
            if (puVar10->recv != (udp_recv_fn *)0x0) {
                    // WARNING: Could not recover jumptable at 0x230425bc. Too many branches
                    // WARNING: Treating indirect jump as call
              (*puVar10->recv)(puVar10->recv_arg,puVar10,p,(ip_addr_t *)0x4201a7a4,uVar4);
              return;
            }
            goto LAB_23042414;
          }
          if ((_uVar3 == 0) && ((ip_data.current_iphdr_dest & 0xf0) != 0xe0)) {
            pbuf_header_force(p,(s16_t)(((uint)ip_data.current_ip_header_tot_len + 8) * 0x10000 >>
                                       0x10));
            icmp_dest_unreach(p,ICMP_DUR_PORT);
          }
          lwip_stats.udp.proterr = lwip_stats.udp.proterr + 1;
        }
      }
      else {
        lwip_stats.udp.chkerr = lwip_stats.udp.chkerr + 1;
      }
      lwip_stats.udp.drop = lwip_stats.udp.drop + 1;
    }
  }
LAB_23042414:
  pbuf_free(p);
  return;
}



err_t udp_bind(udp_pcb *pcb,ip_addr_t *ipaddr,u16_t port)

{
  bool bVar1;
  err_t eVar2;
  undefined2 in_register_00002032;
  u32_t uVar3;
  udp_pcb *puVar4;
  short sVar5;
  
  if (ipaddr == (ip_addr_t *)0x0) {
    ipaddr = &ip_addr_any;
  }
  eVar2 = -0x10;
  puVar4 = udp_pcbs;
  if (pcb != (udp_pcb *)0x0) {
    while (puVar4 != (udp_pcb *)0x0) {
      if (puVar4 == pcb) {
        bVar1 = true;
        goto LAB_23042614;
      }
      puVar4 = puVar4->next;
    }
    bVar1 = false;
LAB_23042614:
    puVar4 = udp_pcbs;
    if (CONCAT22(in_register_00002032,port) == 0) {
      sVar5 = 0x4000;
      do {
        puVar4 = udp_pcbs;
        if (udp_port == 0xffff) {
          port = 0xc000;
        }
        else {
          port = udp_port + 1;
        }
        while( true ) {
          udp_port = port;
          if (puVar4 == (udp_pcb *)0x0) goto LAB_2304263c;
          if (puVar4->local_port == port) break;
          puVar4 = puVar4->next;
        }
        sVar5 = sVar5 + -1;
        if (sVar5 == 0) {
          return -8;
        }
      } while( true );
    }
    while (puVar4 != (udp_pcb *)0x0) {
      if ((puVar4 != pcb) &&
         ((((pcb->so_options & 4) == 0 || ((puVar4->so_options & 4) == 0)) &&
          ((uint)puVar4->local_port == CONCAT22(in_register_00002032,port))))) {
        uVar3 = (puVar4->local_ip).addr;
        if (uVar3 == ipaddr->addr) {
          return -8;
        }
        if (ipaddr->addr == 0) {
          return -8;
        }
        if (uVar3 == 0) {
          return -8;
        }
      }
      puVar4 = puVar4->next;
    }
LAB_2304263c:
    uVar3 = ipaddr->addr;
    pcb->local_port = port;
    (pcb->local_ip).addr = uVar3;
    if (!bVar1) {
      puVar4 = pcb;
      pcb->next = udp_pcbs;
      udp_pcbs = puVar4;
    }
    eVar2 = '\0';
  }
  return eVar2;
}



err_t udp_sendto_if_src_chksum
                (udp_pcb *pcb,pbuf *p,ip_addr_t *dst_ip,u16_t dst_port,netif *netif,u8_t have_chksum
                ,u16_t chksum,ip_addr_t *src_ip)

{
  u8_t ttl;
  err_t eVar1;
  u16_t uVar2;
  undefined2 uVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  pbuf *h;
  undefined2 extraout_var_01;
  uint uVar4;
  undefined2 extraout_var_02;
  undefined3 in_register_0000203d;
  undefined *puVar5;
  
  if (pcb == (udp_pcb *)0x0) {
    return -0x10;
  }
  if (p == (pbuf *)0x0) {
    return -0x10;
  }
  if (dst_ip == (ip_addr_t *)0x0) {
    return -0x10;
  }
  if (src_ip == (ip_addr_t *)0x0) {
    return -0x10;
  }
  if (netif == (netif *)0x0) {
    return -0x10;
  }
  if ((pcb->local_port == 0) &&
     (eVar1 = udp_bind(pcb,(ip_addr_t *)pcb,0), CONCAT31(extraout_var,eVar1) != 0)) {
    return eVar1;
  }
  if (p->tot_len < 0xfff8) {
    ttl = pbuf_add_header(p,8);
    h = p;
    if (CONCAT31(extraout_var_00,ttl) != 0) {
      h = pbuf_alloc(PBUF_IP,8,PBUF_RAM);
      if (h == (pbuf *)0x0) goto LAB_23042702;
      if (p->tot_len != 0) {
        pbuf_chain(h,p);
      }
    }
    puVar5 = (undefined *)h->payload;
    uVar2 = lwip_htons(pcb->local_port);
    *puVar5 = (char)uVar2;
    puVar5[1] = (char)(uVar2 >> 8);
    uVar2 = lwip_htons(dst_port);
    puVar5[2] = (char)uVar2;
    puVar5[3] = (char)(uVar2 >> 8);
    puVar5[6] = 0;
    puVar5[7] = 0;
    if (((pcb->flags & 8) != 0) && ((dst_ip->addr & 0xf0) == 0xe0)) {
      h->flags = h->flags | 4;
    }
    uVar2 = lwip_htons(h->tot_len);
    puVar5[4] = (char)uVar2;
    puVar5[5] = (char)(uVar2 >> 8);
    if ((pcb->flags & 1) == 0) {
      if (CONCAT31(in_register_0000203d,have_chksum) == 0) {
        uVar2 = ip_chksum_pseudo(h,'\x11',h->tot_len,(ip4_addr_t *)src_ip,(ip4_addr_t *)dst_ip);
        uVar4 = CONCAT22(extraout_var_02,uVar2);
      }
      else {
        uVar2 = ip_chksum_pseudo_partial
                          (h,'\x11',h->tot_len,8,(ip4_addr_t *)src_ip,(ip4_addr_t *)dst_ip);
        uVar4 = CONCAT22(extraout_var_01,uVar2) + (~(uint)chksum & 0xffff);
        uVar4 = uVar4 + (uVar4 >> 0x10) & 0xffff;
      }
      uVar3 = (undefined2)uVar4;
      if (uVar4 == 0) {
        uVar3 = 0xffff;
      }
      puVar5[6] = (char)uVar3;
      puVar5[7] = (char)((ushort)uVar3 >> 8);
    }
    if ((dst_ip->addr & 0xf0) == 0xe0) {
      ttl = pcb->mcast_ttl;
    }
    else {
      ttl = pcb->ttl;
    }
    eVar1 = ip4_output_if_src(h,(ip4_addr_t *)src_ip,(ip4_addr_t *)dst_ip,ttl,pcb->tos,'\x11',netif)
    ;
    if (h != p) {
      pbuf_free(h);
    }
    lwip_stats.udp.xmit = lwip_stats.udp.xmit + 1;
  }
  else {
LAB_23042702:
    eVar1 = -1;
  }
  return eVar1;
}



err_t udp_sendto_if_chksum
                (udp_pcb *pcb,pbuf *p,ip_addr_t *dst_ip,u16_t dst_port,netif *netif,u8_t have_chksum
                ,u16_t chksum)

{
  err_t eVar1;
  uint uVar2;
  udp_pcb *src_ip;
  
  if ((((pcb != (udp_pcb *)0x0) && (p != (pbuf *)0x0)) && (dst_ip != (ip_addr_t *)0x0)) &&
     (netif != (netif *)0x0)) {
    uVar2 = (pcb->local_ip).addr;
    if ((uVar2 == 0) || ((uVar2 & 0xf0) == 0xe0)) {
      src_ip = (udp_pcb *)&netif->ip_addr;
    }
    else {
      src_ip = pcb;
      if (uVar2 != (netif->ip_addr).addr) {
        return -4;
      }
    }
    eVar1 = udp_sendto_if_src_chksum
                      (pcb,p,dst_ip,dst_port,netif,have_chksum,chksum,(ip_addr_t *)src_ip);
    return eVar1;
  }
  return -0x10;
}



err_t udp_sendto_chksum(udp_pcb *pcb,pbuf *p,ip_addr_t *dst_ip,u16_t dst_port,u8_t have_chksum,
                       u16_t chksum)

{
  err_t eVar1;
  netif *netif;
  u32_t uVar2;
  
  if (((pcb == (udp_pcb *)0x0) || (p == (pbuf *)0x0)) || (dst_ip == (ip_addr_t *)0x0)) {
    return -0x10;
  }
  if (pcb->netif_idx == '\0') {
    if ((dst_ip->addr & 0xf0) == 0xe0) {
      if (pcb->mcast_ifindex == '\0') {
        uVar2 = (pcb->mcast_ip4).addr;
        if ((uVar2 == 0) || (uVar2 == 0xffffffff)) goto LAB_230428f6;
        netif = ip4_route(&pcb->mcast_ip4);
      }
      else {
        netif = netif_get_by_index(pcb->mcast_ifindex);
      }
      if (netif != (netif *)0x0) goto LAB_2304290a;
    }
LAB_230428f6:
    netif = ip4_route((ip4_addr_t *)dst_ip);
  }
  else {
    netif = netif_get_by_index(pcb->netif_idx);
  }
  if (netif == (netif *)0x0) {
    lwip_stats.udp.rterr = lwip_stats.udp.rterr + 1;
    return -4;
  }
LAB_2304290a:
  eVar1 = udp_sendto_if_chksum(pcb,p,dst_ip,dst_port,netif,have_chksum,chksum);
  return eVar1;
}



err_t udp_sendto(udp_pcb *pcb,pbuf *p,ip_addr_t *dst_ip,u16_t dst_port)

{
  err_t eVar1;
  
  eVar1 = udp_sendto_chksum(pcb,p,dst_ip,dst_port,'\0',0);
  return eVar1;
}



err_t udp_sendto_if(udp_pcb *pcb,pbuf *p,ip_addr_t *dst_ip,u16_t dst_port,netif *netif)

{
  err_t eVar1;
  
  eVar1 = udp_sendto_if_chksum(pcb,p,dst_ip,dst_port,netif,'\0',0);
  return eVar1;
}



err_t udp_sendto_if_src(udp_pcb *pcb,pbuf *p,ip_addr_t *dst_ip,u16_t dst_port,netif *netif,
                       ip_addr_t *src_ip)

{
  err_t eVar1;
  
  eVar1 = udp_sendto_if_src_chksum(pcb,p,dst_ip,dst_port,netif,'\0',0,src_ip);
  return eVar1;
}



err_t udp_connect(udp_pcb *pcb,ip_addr_t *ipaddr,u16_t port)

{
  err_t eVar1;
  undefined3 extraout_var;
  udp_pcb *puVar2;
  u32_t uVar3;
  
  if ((pcb == (udp_pcb *)0x0) || (ipaddr == (ip_addr_t *)0x0)) {
    return -0x10;
  }
  if ((pcb->local_port != 0) ||
     (eVar1 = udp_bind(pcb,(ip_addr_t *)pcb,0), CONCAT31(extraout_var,eVar1) == 0)) {
    uVar3 = ipaddr->addr;
    pcb->remote_port = port;
    (pcb->remote_ip).addr = uVar3;
    pcb->flags = pcb->flags | 4;
    puVar2 = udp_pcbs;
    while (puVar2 != (udp_pcb *)0x0) {
      if (puVar2 == pcb) goto LAB_230429a6;
      puVar2 = puVar2->next;
    }
    pcb->next = udp_pcbs;
    udp_pcbs = pcb;
LAB_230429a6:
    eVar1 = '\0';
  }
  return eVar1;
}



void udp_recv(udp_pcb *pcb,udp_recv_fn *recv,void *recv_arg)

{
  if (pcb != (udp_pcb *)0x0) {
    pcb->recv = recv;
    pcb->recv_arg = recv_arg;
  }
  return;
}



void udp_remove(udp_pcb *pcb)

{
  udp_pcb *puVar1;
  udp_pcb *puVar2;
  
  if (pcb == (udp_pcb *)0x0) {
    return;
  }
  puVar1 = udp_pcbs;
  if (udp_pcbs == pcb) {
    udp_pcbs = pcb->next;
  }
  else {
    do {
      puVar2 = puVar1;
      if ((puVar2 == (udp_pcb *)0x0) || (puVar1 = puVar2->next, puVar1 == (udp_pcb *)0x0))
      goto LAB_230429ee;
    } while (puVar1 != pcb);
    puVar2->next = pcb->next;
  }
LAB_230429ee:
  memp_free(MEMP_UDP_PCB,pcb);
  return;
}



udp_pcb * udp_new(void)

{
  udp_pcb *__s;
  
  __s = (udp_pcb *)memp_malloc(MEMP_UDP_PCB);
  if (__s != (udp_pcb *)0x0) {
    memset(__s,0,0x28);
    __s->ttl = -1;
    __s->mcast_ttl = -1;
  }
  return __s;
}



udp_pcb * udp_new_ip_type(void)

{
  udp_pcb *__s;
  
  __s = (udp_pcb *)memp_malloc(MEMP_UDP_PCB);
  if (__s != (udp_pcb *)0x0) {
    memset(__s,0,0x28);
    __s->ttl = -1;
    __s->mcast_ttl = -1;
  }
  return __s;
}



void udp_netif_ip_addr_changed(ip_addr_t *old_addr,ip_addr_t *new_addr)

{
  udp_pcb *puVar1;
  
  if ((((old_addr != (ip_addr_t *)0x0) && (old_addr->addr != 0)) && (new_addr != (ip_addr_t *)0x0))
     && (puVar1 = udp_pcbs, new_addr->addr != 0)) {
    while (puVar1 != (udp_pcb *)0x0) {
      if ((puVar1->local_ip).addr == old_addr->addr) {
        (puVar1->local_ip).addr = new_addr->addr;
      }
      puVar1 = puVar1->next;
    }
  }
  return;
}



err_t ethernet_input(pbuf *p,netif *netif)

{
  short sVar1;
  u8_t uVar2;
  byte *__s1;
  undefined3 extraout_var;
  int iVar3;
  undefined3 extraout_var_00;
  byte bVar4;
  
  if (p->len < 0xf) {
LAB_23042a78:
    lwip_stats.etharp.proterr = lwip_stats.etharp.proterr + 1;
  }
  else {
    if (p->if_idx == '\0') {
      p->if_idx = netif->num + '\x01';
    }
    __s1 = (byte *)p->payload;
    sVar1 = *(short *)(__s1 + 0xc);
    if ((*__s1 & 1) != 0) {
      if (*__s1 == 1) {
        if ((__s1[1] == 0) && (__s1[2] == 0x5e)) {
          bVar4 = p->flags | 0x10;
LAB_23042ad6:
          p->flags = bVar4;
        }
      }
      else {
        iVar3 = memcmp(__s1,&ethbroadcast,6);
        if (iVar3 == 0) {
          bVar4 = p->flags | 8;
          goto LAB_23042ad6;
        }
      }
    }
    if (sVar1 == 8) {
      if (((netif->flags & 8) != 0) &&
         (uVar2 = pbuf_remove_header(p,0xe), CONCAT31(extraout_var_00,uVar2) == 0)) {
        ip4_input(p,netif);
        return '\0';
      }
      goto free_and_return;
    }
    if (sVar1 != 0x608) goto LAB_23042a78;
    if ((netif->flags & 8) == 0) goto free_and_return;
    uVar2 = pbuf_remove_header(p,0xe);
    if (CONCAT31(extraout_var,uVar2) == 0) {
      etharp_input(p,netif);
      return '\0';
    }
    lwip_stats.etharp.lenerr = lwip_stats.etharp.lenerr + 1;
  }
  lwip_stats.etharp.drop = lwip_stats.etharp.drop + 1;
free_and_return:
  pbuf_free(p);
  return '\0';
}



err_t ethernet_output(netif *netif,pbuf *p,eth_addr *src,eth_addr *dst,u16_t eth_type)

{
  void *__dest;
  u8_t uVar1;
  err_t eVar2;
  u16_t uVar3;
  undefined3 extraout_var;
  
  uVar3 = lwip_htons(eth_type);
  uVar1 = pbuf_add_header(p,0xe);
  if (CONCAT31(extraout_var,uVar1) == 0) {
    __dest = p->payload;
    *(undefined *)((int)__dest + 0xc) = (char)uVar3;
    *(undefined *)((int)__dest + 0xd) = (char)(uVar3 >> 8);
    memcpy(__dest,dst,6);
    memcpy((void *)((int)__dest + 6),src,6);
                    // WARNING: Could not recover jumptable at 0x23042bce. Too many branches
                    // WARNING: Treating indirect jump as call
    eVar2 = (*netif->linkoutput)(netif,p);
    return eVar2;
  }
  lwip_stats.link.lenerr = lwip_stats.link.lenerr + 1;
  return -2;
}



err_t sys_mbox_new(sys_mbox_t *mbox,int size)

{
  QueueHandle_t pQVar1;
  u16_t uVar2;
  
  pQVar1 = xQueueGenericCreate(0x32,4,'\0');
  *(QueueHandle_t *)mbox = pQVar1;
  uVar2 = (u16_t)(((uint)lwip_stats.sys.mbox.used + 1) * 0x10000 >> 0x10);
  if ((uint)lwip_stats.sys.mbox.max < ((uint)lwip_stats.sys.mbox.used + 1 & 0xffff)) {
    lwip_stats.sys.mbox.max = uVar2;
  }
  lwip_stats.sys.mbox.used = uVar2;
  return (err_t)-(*mbox == (sys_mbox_t)0x0);
}



void sys_mbox_post(sys_mbox_t *mbox,void *data)

{
  BaseType_t BVar1;
  void *apvStack20 [2];
  
  apvStack20[0] = data;
  do {
    BVar1 = xQueueGenericSend((QueueHandle_t)*mbox,apvStack20,0xffffffff,0);
  } while (BVar1 != 1);
  return;
}



err_t sys_mbox_trypost(sys_mbox_t *mbox,void *msg)

{
  err_t eVar1;
  BaseType_t BVar2;
  void *apvStack20 [4];
  
  apvStack20[0] = msg;
  BVar2 = xQueueGenericSend((QueueHandle_t)*mbox,apvStack20,0,0);
  if (BVar2 == 1) {
    eVar1 = '\0';
  }
  else {
    eVar1 = -1;
    lwip_stats.sys.mbox.err = lwip_stats.sys.mbox.err + 1;
  }
  return eVar1;
}



u32_t sys_arch_mbox_fetch(sys_mbox_t *mbox,void **msg,u32_t timeout)

{
  TickType_t TVar1;
  BaseType_t BVar2;
  TickType_t TVar3;
  void *local_24;
  void *dummyptr;
  
  TVar1 = xTaskGetTickCount();
  if (msg == (void **)0x0) {
    msg = &local_24;
  }
  if (timeout == 0) {
    do {
      BVar2 = xQueueReceive((QueueHandle_t)*mbox,msg,0xffffffff);
    } while (BVar2 != 1);
  }
  else {
    BVar2 = xQueueReceive((QueueHandle_t)*mbox,msg,timeout);
    if (BVar2 != 1) {
      *msg = (void *)0x0;
      return 0xffffffff;
    }
  }
  TVar3 = xTaskGetTickCount();
  return TVar3 - TVar1;
}



uint sys_mbox_valid(int *param_1)

{
  return (uint)(*param_1 != 0);
}



err_t sys_sem_new(sys_sem_t *sem,u8_t count)

{
  err_t eVar1;
  QueueHandle_t xQueue;
  undefined3 in_register_0000202d;
  uint uVar2;
  
  xQueue = xQueueGenericCreate(1,0,'\x03');
  *(QueueHandle_t *)sem = xQueue;
  if (xQueue != (QueueHandle_t)0x0) {
    xQueueGenericSend(xQueue,(void *)0x0,0,0);
  }
  if ((QueueHandle_t)*sem == (QueueHandle_t)0x0) {
    lwip_stats.sys.sem.err = lwip_stats.sys.sem.err + 1;
    eVar1 = -1;
  }
  else {
    if (CONCAT31(in_register_0000202d,count) == 0) {
      xQueueSemaphoreTake((QueueHandle_t)*sem,1);
    }
    uVar2 = (uint)lwip_stats.sys.sem.used;
    lwip_stats.sys.sem.used = (u16_t)((uVar2 + 1) * 0x10000 >> 0x10);
    eVar1 = '\0';
    if ((uint)lwip_stats.sys.sem.max < (uVar2 + 1 & 0xffff)) {
      eVar1 = '\0';
      lwip_stats.sys.sem.max = lwip_stats.sys.sem.used;
    }
  }
  return eVar1;
}



u32_t sys_arch_sem_wait(sys_sem_t *sem,u32_t timeout)

{
  TickType_t TVar1;
  BaseType_t BVar2;
  TickType_t TVar3;
  
  TVar1 = xTaskGetTickCount();
  if (timeout == 0) {
    do {
      BVar2 = xQueueSemaphoreTake((QueueHandle_t)*sem,0xffffffff);
    } while (BVar2 != 1);
  }
  else {
    BVar2 = xQueueSemaphoreTake((QueueHandle_t)*sem,timeout);
    if (BVar2 != 1) {
      return 0xffffffff;
    }
  }
  TVar3 = xTaskGetTickCount();
  return TVar3 - TVar1;
}



void sys_sem_free(sys_sem_t *sem)

{
  lwip_stats.sys.sem.used = lwip_stats.sys.sem.used - 1;
  vQueueDelete((QueueHandle_t)*sem);
  return;
}



void sys_init(void)

{
  s_nextthread = 0;
  return;
}



err_t sys_mutex_new(sys_mutex_t *mutex)

{
  err_t eVar1;
  QueueHandle_t pQVar2;
  uint uVar3;
  
  pQVar2 = xQueueCreateMutex('\x01');
  *(QueueHandle_t *)mutex = pQVar2;
  if (pQVar2 == (QueueHandle_t)0x0) {
    lwip_stats.sys.mutex.err = lwip_stats.sys.mutex.err + 1;
    eVar1 = -1;
  }
  else {
    uVar3 = (uint)lwip_stats.sys.mutex.used;
    lwip_stats.sys.mutex.used = (u16_t)((uVar3 + 1) * 0x10000 >> 0x10);
    eVar1 = '\0';
    if ((uint)lwip_stats.sys.mutex.max < (uVar3 + 1 & 0xffff)) {
      eVar1 = '\0';
      lwip_stats.sys.mutex.max = lwip_stats.sys.mutex.used;
    }
  }
  return eVar1;
}



void sys_mutex_lock(sys_mutex_t *mutex)

{
  sys_arch_sem_wait((sys_sem_t *)mutex,0);
  return;
}



void sys_mutex_unlock(sys_mutex_t *mutex)

{
  xQueueGenericSend((QueueHandle_t)*mutex,(void *)0x0,0,0);
  return;
}



void sys_sem_signal(sys_mutex_t *mutex)

{
  xQueueGenericSend((QueueHandle_t)*mutex,(void *)0x0,0,0);
  return;
}



sys_thread_t sys_thread_new(char *name,lwip_thread_fn *thread,void *arg,int stacksize,int prio)

{
  BaseType_t BVar1;
  TaskHandle_t ptStack20;
  TaskHandle_t CreatedTask;
  
  if (s_nextthread < 6) {
    BVar1 = xTaskCreate((TaskFunction_t *)thread,name,(uint16_t)stacksize,arg,prio,&ptStack20);
    if (BVar1 != 1) {
      ptStack20 = (sys_thread_t)0x0;
    }
    return ptStack20;
  }
  return (sys_thread_t)0x0;
}



sys_prot_t sys_arch_protect(void)

{
  vTaskEnterCritical();
  return 1;
}



void sys_arch_unprotect(void)

{
  if ((xSchedulerRunning != 0) && (pxCurrentTCB->uxCriticalNesting != 0)) {
    vTaskExitCritical();
    return;
  }
  return;
}



TickType_t sys_now(void)

{
  return xTickCount;
}



u16_t lwip_standard_chksum(void *dataptr,int len)

{
  byte bVar1;
  ushort uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;
  u16_t t;
  ushort uStack2;
  
  uStack2 = 0;
  uVar3 = (uint)dataptr & 1;
  if ((uVar3 != 0) && (0 < len)) {
    bVar1 = *(byte *)dataptr;
    len = len + -1;
    dataptr = (void *)((int)dataptr + 1);
    uStack2 = (ushort)bVar1 << 8;
  }
  uVar5 = (uint)dataptr & 3;
  if ((uVar5 != 0) && (uVar5 = 0, 1 < len)) {
    uVar5 = (uint)*(ushort *)dataptr;
    len = len + -2;
    dataptr = (void *)((int)dataptr + 2);
  }
  while (7 < len) {
    uVar4 = *(int *)dataptr + uVar5;
    if (uVar4 < uVar5) {
      uVar4 = uVar4 + 1;
    }
    uVar5 = ((int *)dataptr)[1] + uVar4;
    if (uVar5 < uVar4) {
      uVar5 = uVar5 + 1;
    }
    len = len + -8;
    dataptr = (int *)dataptr + 2;
  }
  iVar6 = (uVar5 & 0xffff) + (uVar5 >> 0x10);
  while (1 < len) {
    len = len + -2;
    iVar6 = iVar6 + (uint)*(ushort *)dataptr;
    dataptr = (int *)((int)dataptr + 2);
  }
  if (len == 1) {
    uStack2 = uStack2 | *(byte *)dataptr;
  }
  uVar5 = ((uint)uStack2 + iVar6 >> 0x10) + ((uint)uStack2 + iVar6 & 0xffff);
  iVar6 = (uVar5 >> 0x10) + (uVar5 & 0xffff);
  uVar2 = (ushort)iVar6;
  if (uVar3 != 0) {
    uVar2 = (ushort)((uint)iVar6 >> 8) & 0xff | uVar2 * 0x100;
  }
  return (u16_t)uVar2;
}



u16_t inet_chksum_pseudo(pbuf *p,u8_t proto,u16_t proto_len,ip4_addr_t *src,ip4_addr_t *dest)

{
  bool bVar1;
  int iVar2;
  u16_t uVar3;
  u16_t uVar4;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  undefined3 in_register_0000202d;
  uint uVar5;
  
  uVar5 = (src->addr >> 0x10) + (dest->addr & 0xffff) + (dest->addr >> 0x10) + (src->addr & 0xffff);
  uVar5 = (uVar5 & 0xffff) + (uVar5 >> 0x10);
  uVar5 = (uVar5 >> 0x10) + (uVar5 & 0xffff);
  bVar1 = false;
  while (p != (pbuf *)0x0) {
    uVar3 = lwip_standard_chksum(p->payload,(uint)p->len);
    uVar5 = uVar5 + CONCAT22(extraout_var_01,uVar3);
    uVar5 = (uVar5 & 0xffff) + (uVar5 >> 0x10);
    if ((p->len & 1) != 0) {
      bVar1 = (bool)(bVar1 ^ 1);
      uVar5 = uVar5 >> 8 & 0xff | uVar5 * 0x100 & 0xffff;
    }
    p = p->next;
  }
  if (bVar1) {
    uVar5 = uVar5 >> 8 & 0xff | (uVar5 & 0xff) << 8;
  }
  uVar3 = lwip_htons((u16_t)CONCAT31(in_register_0000202d,proto));
  uVar4 = lwip_htons(proto_len);
  uVar5 = uVar5 + CONCAT22(extraout_var_00,uVar4) + CONCAT22(extraout_var,uVar3);
  iVar2 = (uVar5 & 0xffff) + (uVar5 >> 0x10);
  return (u16_t)~((short)iVar2 + (short)((uint)iVar2 >> 0x10));
}



u16_t ip_chksum_pseudo(pbuf *p,u8_t proto,u16_t proto_len,ip4_addr_t *src,ip4_addr_t *dest)

{
  bool bVar1;
  int iVar2;
  u16_t uVar3;
  u16_t uVar4;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  undefined3 in_register_0000202d;
  uint uVar5;
  
  uVar5 = (src->addr >> 0x10) + (dest->addr & 0xffff) + (dest->addr >> 0x10) + (src->addr & 0xffff);
  uVar5 = (uVar5 & 0xffff) + (uVar5 >> 0x10);
  uVar5 = (uVar5 >> 0x10) + (uVar5 & 0xffff);
  bVar1 = false;
  while (p != (pbuf *)0x0) {
    uVar3 = lwip_standard_chksum(p->payload,(uint)p->len);
    uVar5 = uVar5 + CONCAT22(extraout_var_01,uVar3);
    uVar5 = (uVar5 & 0xffff) + (uVar5 >> 0x10);
    if ((p->len & 1) != 0) {
      bVar1 = (bool)(bVar1 ^ 1);
      uVar5 = uVar5 >> 8 & 0xff | uVar5 * 0x100 & 0xffff;
    }
    p = p->next;
  }
  if (bVar1) {
    uVar5 = uVar5 >> 8 & 0xff | (uVar5 & 0xff) << 8;
  }
  uVar3 = lwip_htons((u16_t)CONCAT31(in_register_0000202d,proto));
  uVar4 = lwip_htons(proto_len);
  uVar5 = uVar5 + CONCAT22(extraout_var_00,uVar4) + CONCAT22(extraout_var,uVar3);
  iVar2 = (uVar5 & 0xffff) + (uVar5 >> 0x10);
  return (u16_t)~((short)iVar2 + (short)((uint)iVar2 >> 0x10));
}



u16_t inet_chksum_pseudo_partial
                (pbuf *p,u8_t proto,u16_t proto_len,u16_t chksum_len,ip4_addr_t *src,
                ip4_addr_t *dest)

{
  bool bVar1;
  int iVar2;
  u16_t uVar3;
  u16_t uVar4;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  undefined3 in_register_0000202d;
  undefined2 in_register_00002036;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  
  uVar5 = CONCAT22(in_register_00002036,chksum_len);
  uVar6 = (src->addr >> 0x10) + (dest->addr & 0xffff) + (dest->addr >> 0x10) + (src->addr & 0xffff);
  uVar6 = (uVar6 & 0xffff) + (uVar6 >> 0x10);
  uVar6 = (uVar6 >> 0x10) + (uVar6 & 0xffff);
  bVar1 = false;
  while ((p != (pbuf *)0x0 && (uVar5 != 0))) {
    uVar7 = (uint)p->len;
    if (uVar5 < (uint)p->len) {
      uVar7 = uVar5;
    }
    uVar3 = lwip_standard_chksum(p->payload,uVar7 & 0xffff);
    uVar6 = uVar6 + CONCAT22(extraout_var_01,uVar3);
    uVar6 = (uVar6 & 0xffff) + (uVar6 >> 0x10);
    uVar5 = uVar5 - (uVar7 & 0xffff) & 0xffff;
    if ((p->len & 1) != 0) {
      bVar1 = (bool)(bVar1 ^ 1);
      uVar6 = uVar6 >> 8 & 0xff | uVar6 * 0x100 & 0xffff;
    }
    p = p->next;
  }
  if (bVar1) {
    uVar6 = uVar6 >> 8 & 0xff | (uVar6 & 0xff) << 8;
  }
  uVar3 = lwip_htons((u16_t)CONCAT31(in_register_0000202d,proto));
  uVar4 = lwip_htons(proto_len);
  uVar6 = uVar6 + CONCAT22(extraout_var_00,uVar4) + CONCAT22(extraout_var,uVar3);
  iVar2 = (uVar6 & 0xffff) + (uVar6 >> 0x10);
  return (u16_t)~((short)iVar2 + (short)((uint)iVar2 >> 0x10));
}



u16_t ip_chksum_pseudo_partial
                (pbuf *p,u8_t proto,u16_t proto_len,u16_t chksum_len,ip4_addr_t *src,
                ip4_addr_t *dest)

{
  bool bVar1;
  int iVar2;
  u16_t uVar3;
  u16_t uVar4;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  undefined3 in_register_0000202d;
  uint uVar5;
  undefined2 in_register_00002036;
  uint uVar6;
  uint uVar7;
  
  uVar5 = CONCAT22(in_register_00002036,chksum_len);
  uVar6 = (src->addr >> 0x10) + (dest->addr & 0xffff) + (dest->addr >> 0x10) + (src->addr & 0xffff);
  uVar6 = (uVar6 & 0xffff) + (uVar6 >> 0x10);
  uVar6 = (uVar6 >> 0x10) + (uVar6 & 0xffff);
  bVar1 = false;
  while ((p != (pbuf *)0x0 && (uVar5 != 0))) {
    uVar7 = (uint)p->len;
    if (uVar5 < (uint)p->len) {
      uVar7 = uVar5;
    }
    uVar3 = lwip_standard_chksum(p->payload,uVar7 & 0xffff);
    uVar6 = uVar6 + CONCAT22(extraout_var_01,uVar3);
    uVar6 = (uVar6 & 0xffff) + (uVar6 >> 0x10);
    uVar5 = uVar5 - (uVar7 & 0xffff) & 0xffff;
    if ((p->len & 1) != 0) {
      bVar1 = (bool)(bVar1 ^ 1);
      uVar6 = uVar6 >> 8 & 0xff | uVar6 * 0x100 & 0xffff;
    }
    p = p->next;
  }
  if (bVar1) {
    uVar6 = uVar6 >> 8 & 0xff | (uVar6 & 0xff) << 8;
  }
  uVar3 = lwip_htons((u16_t)CONCAT31(in_register_0000202d,proto));
  uVar4 = lwip_htons(proto_len);
  uVar6 = uVar6 + CONCAT22(extraout_var_00,uVar4) + CONCAT22(extraout_var,uVar3);
  iVar2 = (uVar6 & 0xffff) + (uVar6 >> 0x10);
  return (u16_t)~((short)iVar2 + (short)((uint)iVar2 >> 0x10));
}



u16_t inet_chksum(void *dataptr,u16_t len)

{
  u16_t uVar1;
  undefined2 in_register_0000202e;
  
  uVar1 = lwip_standard_chksum(dataptr,CONCAT22(in_register_0000202e,len));
  return ~uVar1;
}



u16_t inet_chksum_pbuf(pbuf *p)

{
  bool bVar1;
  ushort uVar2;
  uint uVar3;
  u16_t uVar4;
  undefined2 extraout_var;
  
  bVar1 = false;
  uVar3 = 0;
  while (uVar2 = (ushort)uVar3, p != (pbuf *)0x0) {
    uVar4 = lwip_standard_chksum(p->payload,(uint)p->len);
    uVar3 = uVar3 + CONCAT22(extraout_var,uVar4);
    uVar3 = (uVar3 & 0xffff) + (uVar3 >> 0x10);
    if ((p->len & 1) != 0) {
      bVar1 = (bool)(bVar1 ^ 1);
      uVar3 = uVar3 >> 8 & 0xff | uVar3 * 0x100 & 0xffff;
    }
    p = p->next;
  }
  if (bVar1) {
    uVar2 = (ushort)(uVar3 >> 8) & 0xff | (ushort)((uVar3 & 0xff) << 8);
  }
  return (u16_t)~uVar2;
}



void icmp_input(pbuf *p,netif *inp)

{
  ip_hdr *__src;
  u32_t uVar1;
  uint uVar2;
  uint __n;
  void *dataptr;
  u8_t uVar3;
  err_t eVar4;
  u16_t uVar5;
  undefined3 extraout_var;
  undefined2 extraout_var_05;
  undefined3 extraout_var_00;
  pbuf *p_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  uint uVar6;
  short sVar7;
  undefined *puVar8;
  
  __src = ip_data.current_ip4_header;
  lwip_stats.icmp.recv = lwip_stats.icmp.recv + 1;
  uVar2 = (uint)(ip_data.current_ip4_header)->_v_hl & 0xf;
  __n = uVar2 * 4;
  if ((__n < 0x14) || (p->len < 4)) {
lenerr:
    pbuf_free(p);
    lwip_stats.icmp.lenerr = lwip_stats.icmp.lenerr + 1;
  }
  else {
    if (*(char *)p->payload == '\0') goto LAB_2304339a;
    if (*(char *)p->payload != '\b') {
      lwip_stats.icmp.proterr = lwip_stats.icmp.proterr + 1;
      lwip_stats.icmp.drop = lwip_stats.icmp.drop + 1;
      goto LAB_2304339a;
    }
    if (((ip_data.current_iphdr_dest & 0xf0) != 0xe0) &&
       (uVar3 = ip4_addr_isbroadcast_u32(ip_data.current_iphdr_dest,ip_data.current_netif),
       CONCAT31(extraout_var,uVar3) == 0)) {
      if (p->tot_len < 8) goto lenerr;
      uVar5 = inet_chksum_pbuf(p);
      if (CONCAT22(extraout_var_05,uVar5) != 0) {
        pbuf_free(p);
        lwip_stats.icmp.chkerr = lwip_stats.icmp.chkerr + 1;
        return;
      }
      uVar2 = uVar2 << 0x12;
      uVar3 = pbuf_add_header(p,__n + 0x8e);
      if (CONCAT31(extraout_var_00,uVar3) == 0) {
        uVar3 = pbuf_remove_header(p,__n + 0x8e);
        if (CONCAT31(extraout_var_04,uVar3) == 0) {
LAB_230432e2:
          puVar8 = (undefined *)p->payload;
          uVar3 = pbuf_add_header(p,__n);
          uVar1 = ip_data.current_iphdr_dest;
          if (CONCAT31(extraout_var_03,uVar3) == 0) {
            dataptr = p->payload;
            *(undefined *)((int)dataptr + 0xc) = (char)ip_data.current_iphdr_dest;
            *(undefined *)((int)dataptr + 0xd) = (char)(uVar1 >> 8);
            *(undefined *)((int)dataptr + 0xe) = (char)(uVar1 >> 0x10);
            *(undefined *)((int)dataptr + 0xf) = (char)(uVar1 >> 0x18);
            uVar1 = ip_data.current_iphdr_src;
            *(undefined *)((int)dataptr + 0x10) = (char)ip_data.current_iphdr_src;
            *(undefined *)((int)dataptr + 0x11) = (char)(uVar1 >> 8);
            *(undefined *)((int)dataptr + 0x12) = (char)(uVar1 >> 0x10);
            *(undefined *)((int)dataptr + 0x13) = (char)(uVar1 >> 0x18);
            *puVar8 = 0;
            if (*(ushort *)(puVar8 + 2) < 0xfff8) {
              sVar7 = 8;
            }
            else {
              sVar7 = 9;
            }
            sVar7 = *(ushort *)(puVar8 + 2) + sVar7;
            puVar8[2] = (char)sVar7;
            puVar8[3] = (char)((ushort)sVar7 >> 8);
            *(undefined *)((int)dataptr + 8) = 0xff;
            *(undefined *)((int)dataptr + 10) = 0;
            *(undefined *)((int)dataptr + 0xb) = 0;
            uVar5 = inet_chksum(dataptr,(u16_t)(uVar2 >> 0x10));
            *(undefined *)((int)dataptr + 10) = (char)uVar5;
            *(undefined *)((int)dataptr + 0xb) = (char)(uVar5 >> 8);
            lwip_stats.icmp.xmit = lwip_stats.icmp.xmit + 1;
            ip4_output_if(p,(ip4_addr_t *)&ip_data.current_iphdr_dest,(ip4_addr_t *)0x0,-1,'\0',
                          '\x01',inp);
          }
LAB_2304339a:
          pbuf_free(p);
          return;
        }
      }
      else {
        uVar6 = (uint)p->tot_len + (uVar2 >> 0x10);
        if (((uint)p->tot_len <= (uVar6 & 0xffff)) &&
           (p_00 = pbuf_alloc(PBUF_LINK,(u16_t)(uVar6 * 0x10000 >> 0x10),PBUF_RAM),
           p_00 != (pbuf *)0x0)) {
          if (__n + 8 <= (uint)p_00->len) {
            memcpy(p_00->payload,__src,__n);
            uVar3 = pbuf_remove_header(p_00,__n);
            if ((CONCAT31(extraout_var_01,uVar3) == 0) &&
               (eVar4 = pbuf_copy(p_00,p), CONCAT31(extraout_var_02,eVar4) == 0)) {
              pbuf_free(p);
              p = p_00;
              goto LAB_230432e2;
            }
          }
          pbuf_free(p_00);
        }
      }
    }
    pbuf_free(p);
    lwip_stats.icmp.err = lwip_stats.icmp.err + 1;
  }
  return;
}



// WARNING: Type propagation algorithm not settling

void icmp_dest_unreach(pbuf *p,icmp_dur_type t)

{
  undefined *dataptr;
  u16_t uVar1;
  pbuf *p_00;
  netif *netif;
  void *pvVar2;
  ip4_addr_t iStack36;
  ip4_addr_t iphdr_src;
  
  p_00 = pbuf_alloc(PBUF_IP,0x24,PBUF_RAM);
  if (p_00 != (pbuf *)0x0) {
    dataptr = (undefined *)p_00->payload;
    pvVar2 = p->payload;
    *dataptr = 3;
    dataptr[1] = t;
    dataptr[4] = 0;
    dataptr[5] = 0;
    dataptr[6] = 0;
    dataptr[7] = 0;
    memcpy((void *)((int)p_00->payload + 8),p->payload,0x1c);
    iStack36 = (ip4_addr_t)((ip4_addr_t *)((int)pvVar2 + 0xc))->addr;
    netif = ip4_route(&iStack36);
    if (netif != (netif *)0x0) {
      dataptr[2] = 0;
      dataptr[3] = 0;
      uVar1 = inet_chksum(dataptr,p_00->len);
      dataptr[2] = (char)uVar1;
      dataptr[3] = (char)(uVar1 >> 8);
      lwip_stats.icmp.xmit = lwip_stats.icmp.xmit + 1;
      ip4_output_if(p_00,(ip4_addr_t *)0x0,&iStack36,-1,'\0','\x01',netif);
    }
    pbuf_free(p_00);
  }
  return;
}



u8_t * dhcp_server_option_find(u8_t *buf,u16_t len,u8_t option)

{
  undefined2 in_register_0000202e;
  byte *pbVar1;
  undefined3 in_register_00002031;
  
  pbVar1 = buf + CONCAT22(in_register_0000202e,len);
  while ((buf < pbVar1 && (*buf != 0xff))) {
    if ((uint)*buf == CONCAT31(in_register_00002031,option)) {
      return buf;
    }
    buf = buf + (uint)buf[1] + 2;
  }
  return (u8_t *)0x0;
}



// WARNING: Type propagation algorithm not settling

dhcp_client_node * dhcp_client_find_by_ip(uint8_t *ip)

{
  dhcp_client_node *pdVar1;
  void *in_a1;
  ip4_addr_t iStack20;
  uint32_t ipval;
  
  memcpy(&iStack20,in_a1,4);
  pdVar1 = *(dhcp_client_node **)ip;
  while ((pdVar1 != (dhcp_client_node *)0x0 && (iStack20 != (ip4_addr_t)(pdVar1->ipaddr).addr))) {
    pdVar1 = pdVar1->next;
  }
  return pdVar1;
}



// WARNING: Type propagation algorithm not settling

void dhcp_server_recv(void *arg,udp_pcb *pcb,pbuf *p,ip_addr_t *recv_addr,u16_t port)

{
  byte bVar1;
  u8_t uVar2;
  char *pcVar3;
  pbuf *p_to;
  u8_t *puVar4;
  u32_t n;
  u32_t uVar5;
  int iVar6;
  u16_t len;
  undefined4 *puVar7;
  dhcp_client_node *pdVar8;
  undefined4 *puVar9;
  undefined4 *puVar10;
  u8_t *buf;
  ip_addr_t iStack56;
  ip_addr_t addr;
  u32_t tmp;
  
  iStack56 = (ip_addr_t)recv_addr->addr;
  if (((p->len < 0x2c) || (p_to = pbuf_alloc(PBUF_TRANSPORT,0x5dc,PBUF_RAM), p_to == (pbuf *)0x0))
     || (p_to->tot_len < p->tot_len)) goto LAB_2304353a;
  pbuf_copy(p_to,p);
  pbuf_free(p);
  pcVar3 = (char *)p_to->payload;
  p = p_to;
  if (((*pcVar3 != '\x01') || (*(int *)(pcVar3 + 0xec) != 0x63538263)) ||
     (bVar1 = pcVar3[2], 6 < bVar1)) goto LAB_2304353a;
  buf = (u8_t *)(pcVar3 + 0xf0);
  len = (u16_t)(((uint)p_to->tot_len - 0xf0) * 0x10000 >> 0x10);
  puVar4 = dhcp_server_option_find(buf,len,'5');
  if (puVar4 == (u8_t *)0x0) goto LAB_2304353a;
  uVar2 = puVar4[2];
  if (uVar2 == '\x01') {
    pdVar8 = *(dhcp_client_node **)((int)arg + 0xc);
    while (pdVar8 != (dhcp_client_node *)0x0) {
      iVar6 = memcmp(pdVar8->chaddr,pcVar3 + 0x1c,(uint)bVar1);
      if (iVar6 == 0) goto LAB_2304368e;
      pdVar8 = pdVar8->next;
    }
    puVar4 = dhcp_server_option_find(buf,len,'2');
    if ((puVar4 == (u8_t *)0x0) ||
       (pdVar8 = dhcp_client_find_by_ip((uint8_t *)((int)arg + 0xc)),
       pdVar8 == (dhcp_client_node *)0x0)) {
      while (pdVar8 = dhcp_client_find_by_ip((uint8_t *)((int)arg + 0xc)),
            pdVar8 != (dhcp_client_node *)0x0) {
        n = lwip_htonl(*(u32_t *)((int)arg + 0x18));
        n = n + 1;
        uVar5 = lwip_htonl(*(u32_t *)((int)arg + 0x14));
        if (uVar5 < n) {
          n = lwip_htonl(*(u32_t *)((int)arg + 0x10));
        }
        uVar5 = lwip_htonl(n);
        *(u32_t *)((int)arg + 0x18) = uVar5;
      }
      pdVar8 = (dhcp_client_node *)mem_malloc(0x14);
      if (pdVar8 == (dhcp_client_node *)0x0) goto LAB_2304353a;
      memcpy(pdVar8->chaddr,pcVar3 + 0x1c,(uint)(byte)pcVar3[2]);
      (pdVar8->ipaddr).addr = *(u32_t *)((int)arg + 0x18);
      pdVar8->next = *(dhcp_client_node **)((int)arg + 0xc);
      *(dhcp_client_node **)((int)arg + 0xc) = pdVar8;
    }
LAB_2304368e:
    pdVar8->lease_end = 0x80510100;
    *pcVar3 = '\x02';
    pcVar3[3] = '\0';
    pcVar3[8] = '\0';
    pcVar3[9] = '\0';
    memcpy(pcVar3 + 0x14,(void *)(*(int *)((int)arg + 4) + 4),4);
    pcVar3[0xed] = -0x7e;
    pcVar3[0xec] = 'c';
    pcVar3[0xef] = 'c';
    pcVar3[0x2c] = '\0';
    pcVar3[0x6c] = '\0';
    pcVar3[0xee] = 'S';
    memcpy(pcVar3 + 0x10,&pdVar8->ipaddr,4);
    pcVar3[0xf0] = '5';
    pcVar3[0xf1] = '\x01';
    pcVar3[0xf2] = '\x02';
LAB_230436fe:
    pcVar3[0xf3] = '6';
    pcVar3[0xf4] = '\x04';
    memcpy(pcVar3 + 0xf5,(void *)(*(int *)((int)arg + 4) + 4),4);
    pcVar3[0xf9] = '3';
    pcVar3[0xfa] = '\x04';
    addr = 0x15180;
    memcpy(pcVar3 + 0xfb,&addr,4);
    pcVar3[0xff] = '\x01';
    pcVar3[0x100] = '\x04';
    memcpy(pcVar3 + 0x101,(void *)(*(int *)((int)arg + 4) + 8),4);
    pcVar3[0x105] = '\x06';
    pcVar3[0x106] = '\x04';
    memcpy(pcVar3 + 0x107,(void *)(*(int *)((int)arg + 4) + 4),4);
    pcVar3[0x10b] = '\x03';
    pcVar3[0x10c] = '\x04';
    memcpy(pcVar3 + 0x10d,(void *)(*(int *)((int)arg + 4) + 4),4);
    pcVar3[0x111] = -1;
    if (0x112 < p_to->tot_len) {
      len = 0x112;
LAB_23043796:
      pbuf_realloc(p_to,len);
    }
  }
  else {
    if (uVar2 != '\x03') {
      if (uVar2 == '\a') {
        puVar7 = *(undefined4 **)((int)arg + 0xc);
        puVar10 = (undefined4 *)0x0;
        while (puVar9 = puVar7, puVar9 != (undefined4 *)0x0) {
          iVar6 = memcmp(puVar9 + 1,pcVar3 + 0x1c,(uint)(byte)pcVar3[2]);
          puVar7 = (undefined4 *)*puVar9;
          if (iVar6 == 0) {
            if (*(undefined4 **)((int)arg + 0xc) == puVar9) {
              *(undefined4 **)((int)arg + 0xc) = puVar7;
            }
            else {
              *(undefined4 **)puVar10 = puVar7;
            }
            mem_free(puVar9);
            break;
          }
          puVar7 = (undefined4 *)*puVar7;
          puVar10 = puVar9;
        }
      }
      goto LAB_2304353a;
    }
    pdVar8 = *(dhcp_client_node **)((int)arg + 0xc);
    while (pdVar8 != (dhcp_client_node *)0x0) {
      iVar6 = memcmp(pdVar8->chaddr,pcVar3 + 0x1c,(uint)bVar1);
      if (iVar6 == 0) goto LAB_230438f0;
      pdVar8 = pdVar8->next;
    }
    puVar4 = dhcp_server_option_find(buf,len,'2');
    if ((puVar4 != (u8_t *)0x0) &&
       (pdVar8 = dhcp_client_find_by_ip((uint8_t *)((int)arg + 0xc)),
       pdVar8 != (dhcp_client_node *)0x0)) {
      iVar6 = memcmp(pdVar8->chaddr,pcVar3 + 0x1c,(uint)(byte)pcVar3[2]);
      if (iVar6 == 0) {
LAB_230438f0:
        pdVar8->lease_end = 0x80510100;
        *pcVar3 = '\x02';
        pcVar3[3] = '\0';
        pcVar3[8] = '\0';
        pcVar3[9] = '\0';
        memcpy(pcVar3 + 0x14,(void *)(*(int *)((int)arg + 4) + 4),4);
        pcVar3[0xed] = -0x7e;
        pcVar3[0xec] = 'c';
        pcVar3[0xef] = 'c';
        pcVar3[0x2c] = '\0';
        pcVar3[0x6c] = '\0';
        pcVar3[0xee] = 'S';
        memcpy(pcVar3 + 0x10,&pdVar8->ipaddr,4);
        pcVar3[0xf0] = '5';
        pcVar3[0xf1] = '\x01';
        pcVar3[0xf2] = '\x05';
        goto LAB_230436fe;
      }
      puts("IP Found, but MAC address is NOT the same\r\n");
    }
    *pcVar3 = '\x02';
    pcVar3[3] = '\0';
    pcVar3[8] = '\0';
    pcVar3[9] = '\0';
    memcpy(pcVar3 + 0x14,(void *)(*(int *)((int)arg + 4) + 4),4);
    pcVar3[0xed] = -0x7e;
    pcVar3[0xee] = 'S';
    pcVar3[0xec] = 'c';
    pcVar3[0xef] = 'c';
    pcVar3[0x2c] = '\0';
    pcVar3[0x6c] = '\0';
    memset(pcVar3 + 0x10,0,4);
    pcVar3[0xf0] = '5';
    pcVar3[0xf1] = '\x01';
    pcVar3[0xf2] = '\x06';
    pcVar3[0xf3] = '6';
    pcVar3[0xf4] = '\x04';
    memcpy(pcVar3 + 0xf5,(void *)(*(int *)((int)arg + 4) + 4),4);
    pcVar3[0xf9] = -1;
    if (0xfa < p_to->tot_len) {
      len = 0xfa;
      goto LAB_23043796;
    }
  }
  iStack56 = (ip_addr_t)0xffffffff;
  udp_sendto_if(pcb,p_to,&iStack56,port,*(netif **)((int)arg + 4));
LAB_2304353a:
  pbuf_free(p);
  return;
}



err_t dhcp_server_start(netif *netif,ip4_addr_t *start,ip4_addr_t *end)

{
  udp_pcb *puVar1;
  dhcp_server *__s;
  
  __s = lw_dhcp_server;
  while (__s != (dhcp_server *)0x0) {
    if (__s->netif == netif) {
      (__s->start).addr = start->addr;
      (__s->end).addr = end->addr;
      (__s->current).addr = start->addr;
      return '\0';
    }
    __s = __s->next;
  }
  __s = (dhcp_server *)mem_malloc(0x1c);
  if (__s != (dhcp_server *)0x0) {
    memset(__s,0,0x1c);
    __s->netif = netif;
    __s->node_list = (dhcp_client_node *)0x0;
    __s->next = lw_dhcp_server;
    lw_dhcp_server = __s;
    (__s->start).addr = start->addr;
    (__s->end).addr = end->addr;
    (__s->current).addr = start->addr;
    puVar1 = udp_new();
    __s->pcb = puVar1;
    if (puVar1 != (udp_pcb *)0x0) {
      puVar1->so_options = puVar1->so_options | 0x20;
      udp_bind(__s->pcb,&ip_addr_any,0x43);
      udp_recv(__s->pcb,dhcp_server_recv,__s);
      return '\0';
    }
  }
  return -1;
}



err_t dhcp_server_stop(netif *netif)

{
  dhcp_server *pdVar1;
  
  pdVar1 = lw_dhcp_server;
  while( true ) {
    if (pdVar1 == (dhcp_server *)0x0) {
      printf("[DHCP] [DHCPD] CRITICAL: no dhcp_server instance found\r\n");
      return -6;
    }
    if (pdVar1->netif == netif) break;
    pdVar1 = pdVar1->next;
  }
  if (pdVar1->pcb != (udp_pcb *)0x0) {
    udp_remove(pdVar1->pcb);
  }
  lw_dhcp_server = (dhcp_server *)0x0;
  mem_free(pdVar1);
  return '\0';
}



void dhcpd_start(netif *netif)

{
  err_t eVar1;
  char *fmt;
  undefined3 extraout_var;
  ip4_addr_t *piVar2;
  ip4_addr_t iStack60;
  ip4_addr_t ip_start;
  ip4_addr_t ip_end;
  char str_tmp [20];
  
  dhcp_stop(netif);
  set_if(netif,"192.168.169.1","0.0.0.0","255.255.255.0");
  netif_set_up(netif);
  memcpy(&ip_end,"192.168.169.1",0xe);
  fmt = strchr((char *)&ip_end,0x2e);
  if (((fmt == (char *)0x0) || (fmt = strchr(fmt + 1,0x2e), fmt == (char *)0x0)) ||
     (fmt = strchr(fmt + 1,0x2e), fmt == (char *)0x0)) {
    piVar2 = &ip_end;
    fmt = "[DHCP] DHCPD_SERVER_IP: %s error!\r\n";
  }
  else {
    sprintf(fmt + 1,"%d",2);
    ip4addr_aton((char *)&ip_end,&iStack60);
    printf("[DHCP] ip_start: [%s]\r\n",&ip_end);
    sprintf(fmt + 1,"%d",0xfe);
    ip4addr_aton((char *)&ip_end,&ip_start);
    printf("[DHCP] ip_start: [%s]\r\n",&ip_end);
    eVar1 = dhcp_server_start(netif,&iStack60,&ip_start);
    piVar2 = (ip4_addr_t *)CONCAT31(extraout_var,eVar1);
    if (piVar2 == (ip4_addr_t *)0x0) {
      return;
    }
    fmt = "[DHCP] dhcp_server_start res: %d.\r\n";
  }
  printf(fmt,piVar2);
  return;
}



int dirent_type(void *addr)

{
  int iVar1;
  byte bVar2;
  
  bVar2 = *(byte *)((int)addr + 3) & 7;
  if ((*(byte *)((int)addr + 3) & 7) == 0) {
    iVar1 = 0;
  }
  else {
    iVar1 = 2;
    if ((bVar2 != 2) && (iVar1 = 3, bVar2 == 1)) {
      return 1;
    }
  }
  return iVar1;
}



uint32_t dirent_hardfh(void *addr)

{
  uint uVar1;
  
  uVar1 = *(uint *)addr;
  return uVar1 << 0x18 | uVar1 >> 0x18 & 0xfffffff0 | (uVar1 & 0xff00) << 8 | uVar1 >> 8 & 0xff00;
}



uint32_t dirent_childaddr(void *addr)

{
  uint uVar1;
  
  uVar1 = *(uint *)((int)addr + 4);
  return uVar1 << 0x18 | uVar1 >> 0x18 & 0xfffffff0 | (uVar1 & 0xff00) << 8 | uVar1 >> 8 & 0xff00;
}



uint32_t dirent_size(void *addr)

{
  uint uVar1;
  
  uVar1 = *(uint *)((int)addr + 8);
  return uVar1 << 0x18 | uVar1 >> 0x18 | (uVar1 & 0xff00) << 8 | uVar1 >> 8 & 0xff00;
}



int romfs_close(file_t *fp)

{
  fp->f_arg = (void *)0x0;
  fp->offset = 0;
  return -1;
}



int romfs_ioctl(file_t *fp,int cmd,ulong arg)

{
  size_t sVar1;
  uint32_t uVar2;
  int iVar3;
  void *pvVar4;
  
  iVar3 = -2;
  if (((fp != (file_t *)0x0) && (arg != 0)) && (iVar3 = -3, cmd == 1)) {
    pvVar4 = fp->f_arg;
    sVar1 = strlen((char *)((int)pvVar4 + 0x10));
    *(size_t *)arg = (sVar1 + 0x10 & 0xfffffff0) + 0x10 + (int)pvVar4;
    uVar2 = dirent_size(fp->f_arg);
    *(uint32_t *)(arg + 4) = uVar2;
    return 0;
  }
  return iVar3;
}



ssize_t romfs_read(file_t *fp,char *buf,size_t length)

{
  size_t sVar1;
  uint32_t uVar2;
  uint uVar3;
  void *__src;
  
  __src = fp->f_arg;
  sVar1 = strlen((char *)((int)__src + 0x10));
  uVar2 = dirent_size(fp->f_arg);
  uVar3 = fp->offset;
  if (uVar3 < uVar2) {
    __src = (void *)((sVar1 + 0x10 & 0xfffffff0) + 0x10 + uVar3 + (int)__src);
    if (uVar3 + length < uVar2) {
      memcpy(buf,__src,length);
      fp->offset = fp->offset + length;
    }
    else {
      length = uVar2 - uVar3;
      memcpy(buf,__src,length);
      fp->offset = uVar2;
    }
  }
  else {
    length = 0;
  }
  return length;
}



undefined4 file_info(char *param_1,char **param_2,char **param_3)

{
  char *addr;
  char *pcVar1;
  char *pcVar2;
  size_t __n;
  int iVar3;
  uint32_t uVar4;
  TickType_t TVar5;
  
  addr = *param_2;
  pcVar1 = *param_3;
  __n = strlen(param_1);
  if (__n < 0x41) {
    if (romfs_root == addr) {
      __n = strlen(addr + 0x10);
      addr = addr + (__n + 0x10 & 0xfffffff0) + 0x50;
    }
    do {
      iVar3 = dirent_type(addr);
      if (iVar3 == 1) {
        __n = strlen(param_1);
        iVar3 = memcmp(param_1,addr + 0x10,__n);
        if ((iVar3 == 0) && (__n = strlen(param_1), addr[__n + 0x10] == '\0')) {
          uVar4 = dirent_hardfh(addr);
          pcVar2 = romfs_root;
          if (uVar4 == 0) goto LAB_23043d60;
LAB_23043d5e:
          pcVar1 = pcVar2 + uVar4;
LAB_23043d60:
          *param_2 = addr;
          *param_3 = pcVar1;
          return 0;
        }
      }
      else {
        if (iVar3 == 2) {
          __n = strlen(param_1);
          iVar3 = memcmp(param_1,addr + 0x10,__n);
          if ((iVar3 == 0) && (__n = strlen(param_1), pcVar2 = romfs_root, addr[__n + 0x10] == '\0')
             ) {
            uVar4 = dirent_hardfh(addr);
            goto LAB_23043d5e;
          }
        }
        else {
          if (iVar3 != 0) {
            if (TrapNetCounter == 0) {
              TVar5 = xTaskGetTickCount();
            }
            else {
              TVar5 = xTaskGetTickCountFromISR();
            }
            iVar3 = dirent_type(addr);
            bl_printk("[%10u][%s: %s:%4d] addr_start = %p, dirent_type(addr_start) = %d\r\n",TVar5,
                      &DAT_23078e4c,"bl_romfs.c",0xe6,addr,iVar3);
            log_buf_out("bl_romfs.c",0xe7,addr,8,LOG_BUF_OUT_DATA_TYPE_HEX);
            if (TrapNetCounter == 0) {
              xTaskGetTickCount();
            }
            else {
              xTaskGetTickCountFromISR();
            }
            bl_printk("[%10u][%s: %s:%4d] unknow the dirent_type.\r\n",&DAT_23078e4c,"bl_romfs.c",
                      0xe8);
            return 0xffffffff;
          }
        }
      }
      pcVar2 = romfs_root;
      uVar4 = dirent_hardfh(addr);
      addr = pcVar2 + uVar4;
    } while (addr < pcVar1);
    if (TrapNetCounter == 0) {
      xTaskGetTickCount();
    }
    else {
      xTaskGetTickCountFromISR();
    }
    bl_printk(
              "[%10u][%s: %s:%4d] start >= end, not found path = %s, addr_start = %p, addr_end = %p\r\n"
              ,&DAT_230781b4,"bl_romfs.c",0xef,param_1,addr,pcVar1);
  }
  return 0xffffffff;
}



int romfs_closedir(file_t *fp,aos_dir_t *dir)

{
  if (dir != (aos_dir_t *)0x0) {
    aos_free(dir);
    return 0;
  }
  return -1;
}



off_t romfs_lseek(file_t *fp,off_t off,int whence)

{
  size_t sVar1;
  uint32_t uVar2;
  
  if (fp == (file_t *)0x0) {
    return -1;
  }
  uVar2 = dirent_size(fp->f_arg);
  if (whence == 0) {
    if (off < 0) {
      printf("not support whence.\r\n");
      return -2;
    }
  }
  else {
    if (whence == 2) {
      sVar1 = uVar2;
      if (0 < off) {
        printf("not support whence.\r\n");
        return -3;
      }
    }
    else {
      if (whence != 1) {
        printf("not support whence.\r\n");
        return -4;
      }
      sVar1 = fp->offset;
    }
    off = off + sVar1;
    if (off < 0) goto LAB_23043efe;
  }
  if ((uint)off <= uVar2) {
    fp->offset = off;
    return off;
  }
LAB_23043efe:
  printf("not support whence.\r\n");
  return -5;
}



aos_dirent_t * romfs_readdir(file_t *fp,aos_dir_t *dir)

{
  uint32_t uVar1;
  int iVar2;
  char *pcVar3;
  uint uVar4;
  void *addr;
  void *addr_00;
  
  if (dir == (aos_dir_t *)0x0) {
    return (aos_dirent_t *)0x0;
  }
LAB_23043f6a:
  do {
    pcVar3 = romfs_root;
    if ((void *)dir[2].dd_vfs_fd == (void *)0x0) {
      dir[2].dd_vfs_fd = dir[1].dd_vfs_fd;
    }
    else {
      addr_00 = (void *)dir[1].dd_rsv;
      if (addr_00 <= (void *)dir[2].dd_vfs_fd) {
        return (aos_dirent_t *)0x0;
      }
      while( true ) {
        addr = (void *)dir[2].dd_vfs_fd;
        if (addr_00 <= addr) {
          return (aos_dirent_t *)0x0;
        }
        uVar1 = dirent_hardfh(addr);
        if (uVar1 == 0) break;
        if (addr == (void *)0x0) {
          return (aos_dirent_t *)0x0;
        }
        iVar2 = dirent_type(addr);
        if (iVar2 - 1U < 2) break;
        *(char **)&dir[2].dd_vfs_fd = pcVar3 + uVar1;
      }
    }
    strncpy((char *)((int)&dir[3].dd_vfs_fd + 1),(char *)(dir[2].dd_vfs_fd + 0x10),0x40);
    addr_00 = (void *)dir[2].dd_vfs_fd;
    *(undefined *)((int)&dir[0xb].dd_vfs_fd + 1) = 0;
    uVar1 = dirent_hardfh(addr_00);
    if (uVar1 == 0) {
      pcVar3 = (char *)dir[1].dd_rsv;
    }
    else {
      pcVar3 = romfs_root + uVar1;
    }
    *(char **)&dir[2].dd_vfs_fd = pcVar3;
    uVar4 = dir[3].dd_vfs_fd & 0xffff00;
    if (uVar4 == 0x2e2e00) {
      if (*(char *)((int)&dir[3].dd_vfs_fd + 3) != '\0') goto LAB_23043fa0;
      goto LAB_23043f6a;
    }
    if (uVar4 != 0x2e00) {
LAB_23043fa0:
      return (aos_dirent_t *)&dir[2].dd_rsv;
    }
  } while( true );
}



uint32_t dirent_file(char *path,void **p_addr_start_input,void **p_addr_end_input)

{
  bool bVar1;
  char *pcVar2;
  size_t __n;
  size_t sVar3;
  int iVar4;
  TickType_t TVar5;
  char *format;
  char *pcVar6;
  uint32_t uVar7;
  undefined4 uVar8;
  uint uVar9;
  char *pcStack124;
  char *addr_start;
  char *addr_end;
  char name [65];
  
  __n = strlen(path);
  sVar3 = strlen("/romfs");
  if (sVar3 <= __n) {
    __n = strlen("/romfs");
    iVar4 = memcmp(path,"/romfs",__n);
    if (iVar4 == 0) {
      __n = strlen("/romfs");
      path = path + __n;
      if (*path == '/') {
        path = path + 1;
LAB_230440c0:
        bVar1 = false;
        uVar9 = *(uint *)(romfs_root + 8);
        pcStack124 = romfs_root;
        addr_start = romfs_root +
                     (uVar9 >> 8 & 0xff00 | uVar9 << 0x18 | uVar9 >> 0x18 | (uVar9 & 0xff00) << 8);
        do {
          if (*path == '\0') {
LAB_23044216:
            *(char **)p_addr_start_input = pcStack124;
            *(char **)p_addr_end_input = addr_start;
            return 0;
          }
          pcVar6 = strchr(path,0x2f);
          pcVar2 = pcStack124;
          format = romfs_root;
          if (bVar1) {
            uVar7 = dirent_childaddr(pcStack124);
            pcStack124 = format + uVar7;
            if (pcVar2 == pcStack124) {
              return 0xfffffffe;
            }
          }
          if (pcVar6 == (char *)0x0) {
            __n = strlen(path);
            if (0x40 < __n) {
              if (TrapNetCounter == 0) {
                TVar5 = xTaskGetTickCount();
              }
              else {
                TVar5 = xTaskGetTickCountFromISR();
              }
              uVar8 = 0x138;
              format = "[%10u][%s: %s:%4d] name too long!\r\n";
              goto LAB_2304407e;
            }
            iVar4 = file_info(path,&pcStack124,&addr_start);
            if (iVar4 != 0) {
              if (TrapNetCounter == 0) {
                TVar5 = xTaskGetTickCount();
              }
              else {
                TVar5 = xTaskGetTickCountFromISR();
              }
              bl_printk(
                        "[%10u][%s: %s:%4d] file info error, p_name = %s, addr_start = %p, addr_end = %p\r\n"
                        ,TVar5,&DAT_230781b4,"bl_romfs.c",0x13c,path,pcStack124,addr_start);
              return 0xffffffff;
            }
            goto LAB_23044216;
          }
          memset(&addr_end,0,0x41);
          memcpy(&addr_end,path,(size_t)(pcVar6 + -(int)path));
          iVar4 = file_info(&addr_end,&pcStack124,&addr_start);
          if (iVar4 != 0) {
            if (TrapNetCounter == 0) {
              TVar5 = xTaskGetTickCount();
            }
            else {
              TVar5 = xTaskGetTickCountFromISR();
            }
            uVar8 = 0x147;
            format = "[%10u][%s: %s:%4d] file info error.\r\n";
            goto LAB_2304407e;
          }
          path = pcVar6 + 1;
          bVar1 = true;
        } while( true );
      }
      if (*path == '\0') goto LAB_230440c0;
      if (TrapNetCounter == 0) {
        TVar5 = xTaskGetTickCount();
      }
      else {
        TVar5 = xTaskGetTickCountFromISR();
      }
      uVar8 = 0x11a;
    }
    else {
      if (TrapNetCounter == 0) {
        TVar5 = xTaskGetTickCount();
      }
      else {
        TVar5 = xTaskGetTickCountFromISR();
      }
      uVar8 = 0x115;
    }
    format = "[%10u][%s: %s:%4d] not support path.\r\n";
LAB_2304407e:
    bl_printk(format,TVar5,&DAT_23078e4c,"bl_romfs.c",uVar8);
  }
  return 0xffffffff;
}



// WARNING: Variable defined which should be unmapped: end_addr

aos_dir_t * romfs_opendir(file_t *fp,char *path)

{
  char *pcVar1;
  TickType_t TVar2;
  aos_dir_t *__s;
  uint32_t uVar3;
  size_t sVar4;
  char *pcStack24;
  char *start_addr;
  char *end_addr;
  
  if (romfs_root == (char *)0x0) {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] romfs_root is null.\r\n",TVar2,&DAT_23078e4c,"bl_romfs.c",0x20d);
    return (aos_dir_t *)0x0;
  }
  __s = (aos_dir_t *)aos_malloc(0x5d);
  if (__s != (aos_dir_t *)0x0) {
    memset(__s,0,0x5d);
    uVar3 = dirent_file(path,&pcStack24,&start_addr);
    pcVar1 = romfs_root;
    if (uVar3 == 0) {
      if (pcStack24 == romfs_root) {
        sVar4 = strlen(pcStack24 + 0x10);
        *(char **)&__s[1].dd_vfs_fd = pcStack24 + (sVar4 + 0x10 & 0xfffffff0) + 0x50;
      }
      else {
        uVar3 = dirent_childaddr(pcStack24);
        if (uVar3 == 0) {
          return (aos_dir_t *)0x0;
        }
        *(char **)&__s[1].dd_vfs_fd = pcVar1 + uVar3;
      }
      __s[2].dd_vfs_fd = 0;
      *(char **)&__s[1].dd_rsv = start_addr;
      return __s;
    }
    aos_free(__s);
  }
  return (aos_dir_t *)0x0;
}



// WARNING: Variable defined which should be unmapped: end_addr

int romfs_stat(file_t *fp,char *path,stat *st)

{
  char *addr;
  uint32_t uVar1;
  TickType_t TVar2;
  int iVar3;
  uint32_t uVar4;
  mode_t mVar5;
  char *pcStack24;
  char *start_addr;
  char *end_addr;
  
  pcStack24 = (char *)0x0;
  start_addr = (char *)0x0;
  uVar1 = dirent_file(path,&pcStack24,&start_addr);
  addr = pcStack24;
  if (uVar1 == 0) {
    if (pcStack24 == romfs_root) {
      st->st_size = 0;
    }
    else {
      iVar3 = dirent_type(pcStack24);
      if (iVar3 == 1) {
        st->st_size = 0;
        mVar5 = 0x4000;
      }
      else {
        if (iVar3 != 2) {
          if (TrapNetCounter == 0) {
            TVar2 = xTaskGetTickCount();
          }
          else {
            TVar2 = xTaskGetTickCountFromISR();
          }
          bl_printk("[%10u][%s: %s:%4d] dirent_type err.\r\n",TVar2,&DAT_230781b4,"bl_romfs.c",0x1fa
                   );
          return -2;
        }
        uVar4 = dirent_size(addr);
        st->st_size = uVar4;
        mVar5 = 0x8000;
      }
      st->st_mode = mVar5;
    }
  }
  else {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] dirent_file res = %d\r\n",TVar2,&DAT_230781b4,"bl_romfs.c",0x1ea,
              uVar1);
    uVar1 = 0xffffffff;
  }
  return uVar1;
}



int romfs_open(file_t *fp,char *path,int flags)

{
  bool bVar1;
  char cVar2;
  TickType_t TVar3;
  char *format;
  size_t sVar4;
  size_t __n;
  int iVar5;
  uint32_t uVar6;
  undefined4 uVar7;
  size_t unaff_s4;
  void *pvStack40;
  char *start_addr;
  char *end_addr;
  
  if (romfs_root == (char *)0x0) {
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    uVar7 = 0x162;
    format = "[%10u][%s: %s:%4d] romfs_root is null.\r\n";
  }
  else {
    sVar4 = strlen(path);
    __n = strlen("/romfs");
    iVar5 = strncmp(path,"/romfs",__n);
    if (iVar5 == 0) {
      __n = 0;
      do {
        if (sVar4 == __n) {
          uVar6 = dirent_file(path,&pvStack40,&start_addr);
          if (uVar6 != 0) {
            return -2;
          }
          fp->offset = 0;
          fp->f_arg = pvStack40;
          return 0;
        }
        cVar2 = path[__n];
        if (0x19 < (byte)(cVar2 + 0x9fU)) {
          if (((byte)(cVar2 + 0xbfU) < 0x1a) || ((byte)(cVar2 - 0x30U) < 10)) {
            if (cVar2 == '/') goto LAB_23044576;
          }
          else {
            if (cVar2 == '/') {
LAB_23044576:
              if (__n == 0) {
                unaff_s4 = 0;
              }
              else {
                bVar1 = __n == unaff_s4;
                unaff_s4 = __n;
                if (bVar1) {
                  if (TrapNetCounter == 0) {
                    TVar3 = xTaskGetTickCount();
                  }
                  else {
                    TVar3 = xTaskGetTickCountFromISR();
                  }
                  uVar7 = 0x73;
                  format = "[%10u][%s: %s:%4d] format error.\r\n";
                  goto LAB_230444bc;
                }
              }
            }
            else {
              if ((cVar2 != '_') && (1 < (byte)(cVar2 - 0x2dU))) {
                if (TrapNetCounter == 0) {
                  TVar3 = xTaskGetTickCount();
                }
                else {
                  TVar3 = xTaskGetTickCountFromISR();
                }
                bl_printk("[%10u][%s: %s:%4d] is_path_ch. i = %d\r\n",TVar3,&DAT_23078e4c,
                          "bl_romfs.c",0x69,__n);
                goto LAB_23044548;
              }
            }
          }
        }
        __n = __n + 1;
      } while( true );
    }
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    uVar7 = 0x61;
    format = "[%10u][%s: %s:%4d] format is error.\r\n";
LAB_230444bc:
    bl_printk(format,TVar3,&DAT_23078e4c,"bl_romfs.c",uVar7);
LAB_23044548:
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    uVar7 = 0x168;
    format = "[%10u][%s: %s:%4d] path format is error.\r\n";
  }
  bl_printk(format,TVar3,&DAT_23078e4c,"bl_romfs.c",uVar7);
  return -1;
}



// WARNING: Variable defined which should be unmapped: info

int romfs_register(void)

{
  uint __s1;
  int iVar1;
  TickType_t TVar2;
  char *format;
  size_t __n;
  undefined4 uVar3;
  undefined auStack44 [4];
  bl_mtd_info_t info;
  
  iVar1 = bl_mtd_open("media",&handle_romfs,2);
  if (iVar1 == 0) {
    memset(auStack44,0,0x1c);
    bl_mtd_info(handle_romfs,(bl_mtd_info_t *)auStack44);
    __s1 = info.size;
    if ((void *)info.size == (void *)0x0) {
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      uVar3 = 0x8d;
      format = "[%10u][%s: %s:%4d] romfs has no XIP-Addr\r\n";
    }
    else {
      __n = strlen("-rom1fs-");
      iVar1 = memcmp((void *)__s1,"-rom1fs-",__n);
      if (iVar1 == 0) {
        romfs_root = (char *)info.size;
        log_buf_out("bl_romfs.c",0x98,(void *)info.size,0x40,LOG_BUF_OUT_DATA_TYPE_HEX);
        iVar1 = aos_register_fs("/romfs",&romfs_ops,(void *)0x0);
        return iVar1;
      }
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      uVar3 = 0x92;
      format = "[%10u][%s: %s:%4d] romfs magic is NOT correct\r\n";
    }
    bl_printk(format,TVar2,&DAT_23078e4c,"bl_romfs.c",uVar3);
  }
  else {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [EF] [PART] [XIP] error when get romfs partition %d\r\n",TVar2,
              &DAT_23078e4c,"bl_romfs.c",0x86,iVar1);
  }
  return -1;
}



char * utils_bin2hex(char *dst,void *src,size_t count)

{
  char cVar1;
  byte *pbVar2;
  char *pcVar3;
  
  pbVar2 = (byte *)src;
  pcVar3 = dst;
  while (pbVar2 != (byte *)((int)src + count)) {
    cVar1 = "0123456789ABCDEF"[(uint)*pbVar2 & 0xf];
    *pcVar3 = "0123456789ABCDEF"[*pbVar2 >> 4];
    pcVar3[1] = cVar1;
    pbVar2 = pbVar2 + 1;
    pcVar3 = pcVar3 + 2;
  }
  return dst + count * 2;
}



int utils_dns_domain_get(uint8_t *records,uint8_t *buf,int *len)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  
  iVar6 = *len;
  uVar3 = (uint)*records;
  iVar2 = 1;
  iVar5 = 0;
  while ((iVar4 = iVar5, iVar1 = iVar2, uVar3 != 0 && (0 < iVar6))) {
    uVar3 = uVar3 - 1;
    buf[iVar4] = records[iVar1];
    iVar2 = iVar1 + 1;
    iVar5 = iVar4 + 1;
    iVar6 = iVar6 + -1;
    if ((uVar3 == 0) && (iVar6 != 0)) {
      buf[iVar5] = '.';
      uVar3 = (uint)records[iVar2];
      iVar2 = iVar1 + 2;
      iVar5 = iVar4 + 2;
    }
  }
  *len = iVar4;
  return 0;
}



void utils_list_init(utils_list *list)

{
  list->first = (utils_list_hdr *)0x0;
  list->last = (utils_list_hdr *)0x0;
  return;
}



void utils_list_push_back(utils_list *list,utils_list_hdr *list_hdr)

{
  if (list->first == (utils_list_hdr *)0x0) {
    list->first = list_hdr;
  }
  else {
    list->last->next = list_hdr;
  }
  list->last = list_hdr;
  list_hdr->next = (utils_list_hdr *)0x0;
  return;
}



utils_list_hdr * utils_list_pop_front(utils_list *list)

{
  utils_list_hdr *puVar1;
  
  puVar1 = list->first;
  if (puVar1 != (utils_list_hdr *)0x0) {
    list->first = puVar1->next;
  }
  return puVar1;
}



void utils_hexdump(void *mem,uint len)

{
  uint uVar1;
  int iVar2;
  uint c;
  int iVar3;
  uint uVar4;
  uint uVar5;
  
  iVar2 = 0;
  if ((len & 0xf) != 0) {
    iVar2 = 0x10 - (len & 0xf);
  }
  uVar4 = 0;
  while (uVar1 = uVar4, iVar2 + len != uVar1) {
    if ((uVar1 & 0xf) == 0) {
      printf("0x%06x: ",uVar1);
    }
    if (uVar1 < len) {
      printf("%02x ",(uint)*(byte *)((int)mem + uVar1));
    }
    else {
      printf("   ");
    }
    uVar4 = uVar1 + 1;
    if ((uVar1 & 0xf) == 0xf) {
      uVar5 = uVar1 - 0xf;
      iVar3 = 0x11;
      if (uVar4 < uVar5) {
        iVar3 = 1;
      }
      while (uVar5 != (uVar1 - 0x10) + iVar3) {
        c = 0x20;
        if ((uVar5 < len) && (c = (uint)*(byte *)((int)mem + uVar5), (_ctype_[c + 1] & 0x97) == 0))
        {
          c = 0x2e;
        }
        bl_putchar(c);
        uVar5 = uVar5 + 1;
      }
      puts("\r\n");
    }
  }
  return;
}



int utils_getopt_init(getopt_env_t *env,int opterr)

{
  if (env != (getopt_env_t *)0x0) {
    env->optarg = (char *)0x0;
    env->optind = 1;
    env->opterr = opterr;
    env->optopt = 0;
    env->__optpos = 0;
    return 0;
  }
  return -1;
}



int utils_getopt(getopt_env_t *env,int argc,char **argv,char *optstring)

{
  byte bVar1;
  byte bVar2;
  int iVar3;
  uint uVar4;
  char **ppcVar5;
  int iVar6;
  byte *pbVar7;
  char *pcVar8;
  byte *pbVar9;
  
  if (env == (getopt_env_t *)0x0) {
    return -1;
  }
  iVar6 = env->optind;
  if (argc <= iVar6) {
    return -1;
  }
  ppcVar5 = argv + iVar6;
  pcVar8 = *ppcVar5;
  if (pcVar8 == (char *)0x0) {
    return -1;
  }
  if (*pcVar8 != '-') {
    if (*optstring == '-') {
      env->optind = iVar6 + 1;
      env->optarg = *ppcVar5;
      return 1;
    }
    return -1;
  }
  if (pcVar8[1] == '\0') {
    return -1;
  }
  if ((pcVar8[1] == '-') && (pcVar8[2] == '\0')) {
    env->optind = iVar6 + 1;
    return -1;
  }
  if (env->__optpos == 0) {
    env->__optpos = 1;
  }
  pbVar9 = (byte *)(*ppcVar5 + env->__optpos);
  bVar1 = *pbVar9;
  uVar4 = (uint)bVar1;
  iVar3 = (uint)(bVar1 != 0) + env->__optpos;
  env->__optpos = iVar3;
  if ((*ppcVar5)[iVar3] == '\0') {
    env->optind = iVar6 + 1;
    env->__optpos = 0;
  }
  if ((*optstring - 0x2bU & 0xfd) == 0) {
    optstring = optstring + 1;
  }
  iVar6 = 0;
  do {
    iVar3 = iVar6 + 1;
    pbVar7 = (byte *)(optstring + iVar6);
    bVar2 = *pbVar7;
    if (bVar2 == 0) {
      if (bVar1 == 0) goto LAB_230449a2;
      goto LAB_23044984;
    }
    iVar6 = iVar3;
  } while (uVar4 != (uint)bVar2);
  if (bVar1 == 0x3a) {
LAB_23044984:
    env->optopt = uVar4;
    if (*optstring == ':') {
      return 0x3f;
    }
    if (env->opterr == 0) {
      return 0x3f;
    }
    bVar1 = *pbVar9;
    pcVar8 = *argv;
    iVar6 = 500;
  }
  else {
LAB_230449a2:
    if (optstring[iVar3] != ':') {
      return uVar4;
    }
    env->optarg = (char *)0x0;
    iVar6 = env->__optpos;
    if ((pbVar7[2] != 0x3a) || (iVar6 != 0)) {
      iVar3 = env->optind;
      env->optind = iVar3 + 1;
      pcVar8 = argv[iVar3];
      env->__optpos = 0;
      env->optarg = pcVar8 + iVar6;
    }
    if (env->optind <= argc) {
      return uVar4;
    }
    env->optopt = uVar4;
    if (*optstring == ':') {
      return 0x3a;
    }
    if (env->opterr == 0) {
      return 0x3f;
    }
    bVar1 = *pbVar9;
    pcVar8 = *argv;
    iVar6 = 0x214;
  }
  printf("[%10u][%s: %s:%4d] format error.\r\n" + iVar6 + 8,pcVar8,(uint)bVar1);
  return 0x3f;
}



int params_filter(uint32_t *r)

{
  int *in_a1;
  int iVar1;
  uint uVar2;
  int iVar3;
  
  iVar1 = 10;
  if ((*(char *)r == '0') && ((*(byte *)((int)r + 1) & 0xdf) == 0x58)) {
    r = (uint32_t *)((int)r + 2);
    iVar1 = 0x10;
  }
  iVar3 = 0;
  do {
    uVar2 = (uint)*(byte *)r;
    if (*(byte *)r == 0) {
      *in_a1 = iVar3;
      return 0;
    }
    iVar3 = iVar3 * iVar1;
    if ((uVar2 - 0x30 & 0xff) < 10) {
      iVar3 = iVar3 + -0x30;
LAB_23044a64:
      iVar3 = iVar3 + uVar2;
    }
    else {
      if (iVar1 == 10) {
        return -1;
      }
      if (iVar1 == 0x10) {
        if ((uVar2 - 0x61 & 0xff) < 6) {
          iVar3 = iVar3 + -0x57;
        }
        else {
          if (5 < (uVar2 - 0x41 & 0xff)) goto LAB_23044a66;
          uVar2 = uVar2 - 0x37;
        }
        goto LAB_23044a64;
      }
    }
LAB_23044a66:
    r = (uint32_t *)((int)r + 1);
  } while( true );
}



void get_bytearray_from_string(char **params,uint8_t *result,int array_size)

{
  int iVar1;
  long lVar2;
  char acStack36 [2];
  undefined uStack34;
  char rand [3];
  
  iVar1 = 0;
  while (iVar1 < array_size) {
    strncpy(acStack36,*params,2);
    uStack34 = 0;
    lVar2 = strtol(acStack36,(char **)0x0,0x10);
    result[iVar1] = (uint8_t)lVar2;
    iVar1 = iVar1 + 1;
    *params = *params + 2;
  }
  return;
}



void get_uint8_from_string(char **params,uint8_t *result)

{
  uint32_t p;
  
  params_filter((uint32_t *)*params);
  *result = '\0';
  return;
}



void get_uint16_from_string(char **params,uint16_t *result)

{
  uint32_t p;
  
  params_filter((uint32_t *)*params);
  *result = 0;
  return;
}



int utils_tlv_bl_pack_auto(uint32_t *buf,int buf_sz,uint16_t type,void *arg1)

{
  undefined2 in_register_00002032;
  uint32_t uVar1;
  int iVar2;
  
  if (CONCAT22(in_register_00002032,type) == 1) {
    uVar1 = (uint32_t)*(byte *)arg1;
  }
  else {
    if (CONCAT22(in_register_00002032,type) != 7) {
      return -2;
    }
    uVar1 = *(uint32_t *)arg1;
  }
  iVar2 = -1;
  if (3 < buf_sz) {
    *buf = uVar1;
    iVar2 = 4;
  }
  return iVar2;
}



int utils_tlv_bl_unpack_auto(uint32_t *buf,int buf_sz,uint16_t type,void *arg1)

{
  int iVar1;
  undefined2 in_register_00002032;
  bool bVar2;
  uint32_t uVar3;
  
  if (CONCAT22(in_register_00002032,type) == 1) {
    if (buf_sz < 4) {
      bVar2 = true;
      iVar1 = -1;
    }
    else {
      iVar1 = 4;
      bVar2 = *buf != 0;
    }
    *(bool *)arg1 = bVar2;
    return iVar1;
  }
  if (CONCAT22(in_register_00002032,type) != 7) {
    return -2;
  }
  if (buf_sz < 4) {
    uVar3 = 0;
    iVar1 = -1;
  }
  else {
    uVar3 = *buf;
    iVar1 = 4;
  }
  *(uint32_t *)arg1 = uVar3;
  return iVar1;
}



int aos_register_driver(char *path,file_ops_t *ops,void *arg)

{
  BaseType_t BVar1;
  int iVar2;
  inode_t *piStack36;
  inode_t *node;
  
  piStack36 = (inode_t *)0x0;
  BVar1 = xQueueSemaphoreTake((QueueHandle_t)g_vfs_mutex,0xffffffff);
  if (BVar1 == 1) {
    iVar2 = inode_reserve(path,&piStack36);
    if (iVar2 == 0) {
      *(file_ops_t **)&piStack36->ops = ops;
      piStack36->type = '\x01';
      piStack36->i_arg = arg;
    }
    BVar1 = xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
    if (BVar1 == 1) {
      return iVar2;
    }
    if (piStack36->i_name != (char *)0x0) {
      vPortFree(piStack36->i_name);
    }
    memset(piStack36,0,0x14);
  }
  return -1;
}



int aos_register_fs(char *path,fs_ops_t *ops,void *arg)

{
  BaseType_t BVar1;
  int iVar2;
  inode_t *piStack36;
  inode_t *node;
  
  piStack36 = (inode_t *)0x0;
  BVar1 = xQueueSemaphoreTake((QueueHandle_t)g_vfs_mutex,0xffffffff);
  if (BVar1 == 1) {
    iVar2 = inode_reserve(path,&piStack36);
    if (iVar2 == 0) {
      *(fs_ops_t **)&piStack36->ops = ops;
      piStack36->type = '\x03';
      piStack36->i_arg = arg;
    }
    BVar1 = xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
    if (BVar1 == 1) {
      return iVar2;
    }
    if (piStack36->i_name != (char *)0x0) {
      vPortFree(piStack36->i_name);
    }
    memset(piStack36,0,0x14);
  }
  return -1;
}



int vfs_uart_open(inode_t *inode,file_t *fp)

{
  uart_dev_t *uart;
  int iVar1;
  StreamBufferHandle_t pSVar2;
  int32_t iVar3;
  inode_t *piVar4;
  
  if ((fp == (file_t *)0x0) || (piVar4 = fp->node, piVar4 == (inode_t *)0x0)) {
    iVar1 = -0x16;
  }
  else {
    iVar1 = 0;
    if (piVar4->refs == '\x01') {
      uart = (uart_dev_t *)piVar4->i_arg;
      aos_mutex_new((aos_mutex_t *)&uart->mutex);
      pSVar2 = xStreamBufferGenericCreate(uart->rx_buf_size,1,0);
      *(StreamBufferHandle_t *)&uart->rx_ringbuf_handle = pSVar2;
      pSVar2 = xStreamBufferGenericCreate(uart->tx_buf_size,1,0);
      *(StreamBufferHandle_t *)&uart->tx_ringbuf_handle = pSVar2;
      if ((uart->rx_ringbuf_handle != (void *)0x0) && (pSVar2 != (StreamBufferHandle_t)0x0)) {
        hal_uart_notify_register(uart,UART_TX_INT,__uart_tx_irq);
        hal_uart_notify_register(uart,UART_RX_INT,__uart_rx_irq);
        iVar3 = hal_uart_init(uart);
        return iVar3;
      }
      return -0x16;
    }
  }
  return iVar1;
}



void __uart_rx_irq(void *p_arg)

{
  uint32_t uStack88;
  uint32_t length;
  BaseType_t xHigherPriorityTaskWoken;
  uint8_t tmp_buf [64];
  
  uStack88 = 0;
  length = 0;
  hal_uart_recv_II((uart_dev_t *)p_arg,&xHigherPriorityTaskWoken,0x40,&uStack88,0);
  if (uStack88 != 0) {
    xStreamBufferSendFromISR
              (*(StreamBufferHandle_t *)((int)p_arg + 0x10),&xHigherPriorityTaskWoken,uStack88,
               (BaseType_t *)&length);
    if (length != 0) {
      vTaskSwitchContext();
    }
  }
  if (*(int *)((int)p_arg + 0x24) != 0) {
    *(ushort *)(*(int *)((int)p_arg + 0x28) + 6) = *(ushort *)(*(int *)((int)p_arg + 0x28) + 6) | 1;
    (**(code **)((int)p_arg + 0x24))
              (*(undefined4 *)((int)p_arg + 0x28),*(undefined4 *)((int)p_arg + 0x2c),
               *(code **)((int)p_arg + 0x24));
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

void __uart_tx_irq(void *p_arg)

{
  size_t sVar1;
  undefined uStack21;
  uint8_t ch;
  int iStack20;
  BaseType_t xHigherPriorityTaskWoken;
  
  iStack20 = 0;
  sVar1 = xStreamBufferReceiveFromISR
                    (*(StreamBufferHandle_t *)((int)p_arg + 0x14),&uStack21,1,
                     (BaseType_t *)&stack0xffffffec);
  if (iStack20 != 0) {
    vTaskSwitchContext();
  }
  if (sVar1 == 1) {
    hal_uart_send((uart_dev_t *)p_arg,&uStack21,1,0);
  }
  else {
    hal_uart_send_trigger_off((uart_dev_t *)p_arg);
  }
  return;
}



int vfs_uart_close(file_t *fp)

{
  uart_dev_t *uart;
  int32_t iVar1;
  inode_t *piVar2;
  
  if ((fp == (file_t *)0x0) || (piVar2 = fp->node, piVar2 == (inode_t *)0x0)) {
    return -0x16;
  }
  if (piVar2->refs != '\x01') {
    return 0;
  }
  uart = (uart_dev_t *)piVar2->i_arg;
  if (uart != (uart_dev_t *)0x0) {
    aos_mutex_free((aos_mutex_t *)&uart->mutex);
    vStreamBufferDelete((StreamBufferHandle_t)uart->rx_ringbuf_handle);
    vStreamBufferDelete((StreamBufferHandle_t)uart->tx_ringbuf_handle);
    iVar1 = hal_uart_finalize(uart);
    return iVar1;
  }
  return -0x16;
}



ssize_t vfs_uart_read(file_t *fp,void *buf,size_t nbytes)

{
  size_t sVar1;
  TickType_t xTicksToWait;
  size_t sVar2;
  void *pvVar3;
  
  sVar1 = 0xffffffea;
  if (fp != (file_t *)0x0) {
    sVar1 = 0xffffffea;
    if (((fp->node != (inode_t *)0x0) && (pvVar3 = fp->node->i_arg, nbytes != 0)) &&
       (pvVar3 != (void *)0x0)) {
      aos_mutex_lock((aos_mutex_t *)((int)pvVar3 + 0x20),0xffffffff);
      sVar1 = 0;
      xTicksToWait = -(uint)(*(char *)((int)pvVar3 + 0x34) == '\x01');
      do {
        sVar2 = xStreamBufferReceive
                          (*(StreamBufferHandle_t *)((int)pvVar3 + 0x10),(void *)((int)buf + sVar1),
                           nbytes - sVar1,xTicksToWait);
        sVar1 = sVar1 + sVar2;
        if (sVar1 == nbytes) break;
      } while (xTicksToWait != 0);
      aos_mutex_unlock((aos_mutex_t *)((int)pvVar3 + 0x20));
    }
  }
  return sVar1;
}



ssize_t vfs_uart_write(file_t *fp,void *buf,size_t nbytes)

{
  size_t sVar1;
  uart_dev_t *uart;
  
  sVar1 = 0xffffffea;
  if (fp != (file_t *)0x0) {
    sVar1 = 0xffffffea;
    if (((fp->node != (inode_t *)0x0) &&
        (uart = (uart_dev_t *)fp->node->i_arg, uart != (uart_dev_t *)0x0)) &&
       (sVar1 = xStreamBufferSend((StreamBufferHandle_t)uart->tx_ringbuf_handle,buf,nbytes,0),
       0 < (int)sVar1)) {
      hal_uart_send_trigger(uart);
    }
  }
  return sVar1;
}



int vfs_uart_poll(file_t *fp,_Bool setup,poll_notify_t *notify,pollfd *fd,void *opa)

{
  void *pvVar1;
  BaseType_t BVar2;
  undefined3 in_register_0000202d;
  
  pvVar1 = fp->node->i_arg;
  aos_mutex_lock((aos_mutex_t *)((int)pvVar1 + 0x20),0xffffffff);
  if (CONCAT31(in_register_0000202d,setup) == 0) {
    vTaskEnterCritical();
    *(undefined4 *)((int)pvVar1 + 0x24) = 0;
    *(undefined4 *)((int)pvVar1 + 0x2c) = 0;
    vTaskExitCritical();
  }
  else {
    vTaskEnterCritical();
    *(poll_notify_t **)((int)pvVar1 + 0x24) = notify;
    *(pollfd **)((int)pvVar1 + 0x28) = fd;
    *(void **)((int)pvVar1 + 0x2c) = opa;
    vTaskExitCritical();
    BVar2 = xStreamBufferIsEmpty(*(StreamBufferHandle_t *)((int)pvVar1 + 0x10));
    if (BVar2 != 1) {
      *(ushort *)(*(int *)((int)pvVar1 + 0x28) + 6) =
           *(ushort *)(*(int *)((int)pvVar1 + 0x28) + 6) | 1;
      (*notify)(fd,opa);
    }
  }
  aos_mutex_unlock((aos_mutex_t *)((int)pvVar1 + 0x20));
  return 0;
}



int vfs_uart_sync(file_t *fp)

{
  uart_dev_t *uart;
  int iVar1;
  
  if (fp == (file_t *)0x0) {
    return -0x16;
  }
  iVar1 = -0x16;
  if (fp->node != (inode_t *)0x0) {
    uart = (uart_dev_t *)fp->node->i_arg;
    if (uart != (uart_dev_t *)0x0) {
      aos_mutex_lock((aos_mutex_t *)&uart->mutex,0xffffffff);
      hal_uart_send_flush(uart,0);
      aos_mutex_unlock((aos_mutex_t *)&uart->mutex);
      iVar1 = 0;
    }
    return iVar1;
  }
  return iVar1;
}



int uart_ioctl_cmd_waimode(uart_dev_t *uart_dev,int cmd,ulong arg)

{
  int iVar1;
  size_t sVar2;
  uint uVar3;
  int iVar4;
  
  iVar1 = -0x16;
  if (arg != 0) {
    iVar4 = *(int *)(arg + 4);
    uVar3 = *(int *)(arg + 8) * 1000;
    iVar1 = 0;
    do {
      sVar2 = xStreamBufferReceive
                        ((StreamBufferHandle_t)uart_dev->rx_ringbuf_handle,
                         (void *)(*(int *)arg + iVar1),iVar4 - iVar1,uVar3 / 1000);
      iVar1 = iVar1 + sVar2;
      if (iVar4 == iVar1) {
        return iVar1;
      }
      if (uVar3 < 1000) {
        return iVar1;
      }
    } while ((cmd != 4) || (iVar1 < 1));
  }
  return iVar1;
}



int uart_ioctl_cmd_setconfig(uart_dev_t *uart_dev,ulong arg)

{
  hal_uart_parity_t parity;
  
  if (arg != 0) {
    parity = *(hal_uart_parity_t *)(arg + 4);
    if ((parity != ODD_PARITY) && (parity != EVEN_PARITY)) {
      parity = NO_PARITY;
    }
    hal_uart_setconfig(uart_dev,*(uint32_t *)arg,parity);
    return 0;
  }
  return -0x16;
}



int vfs_uart_ioctl(file_t *fp,int cmd,ulong arg)

{
  int iVar1;
  uart_dev_t *uart_dev;
  uint8_t uVar2;
  
  if (fp == (file_t *)0x0) {
    return -0x16;
  }
  iVar1 = -0x16;
  if (fp->node == (inode_t *)0x0) {
    return -0x16;
  }
  uart_dev = (uart_dev_t *)fp->node->i_arg;
  if (uart_dev == (uart_dev_t *)0x0) {
    return -0x16;
  }
  aos_mutex_lock((aos_mutex_t *)&uart_dev->mutex,0xffffffff);
  switch(cmd) {
  case 2:
    hal_uart_send_flush(uart_dev,0);
    break;
  case 3:
    hal_uart_setbaud(uart_dev,arg);
    break;
  case 4:
  case 5:
    iVar1 = uart_ioctl_cmd_waimode(uart_dev,cmd,arg);
    goto switchD_23045074_caseD_7;
  case 6:
    uVar2 = '\x01';
    goto LAB_230450b8;
  case 7:
    uVar2 = '\x02';
LAB_230450b8:
    uart_dev->read_block_flag = uVar2;
    break;
  case 8:
    iVar1 = uart_ioctl_cmd_setconfig(uart_dev,arg);
  default:
    goto switchD_23045074_caseD_7;
  }
  iVar1 = -1;
switchD_23045074_caseD_7:
  aos_mutex_unlock((aos_mutex_t *)&uart_dev->mutex);
  return iVar1;
}



BL_Err_Type UART_Init(UART_ID_Type uartId,UART_CFG_Type *uartCfg)

{
  UART_Parity_Type UVar1;
  undefined3 in_register_00002029;
  uint *puVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  
  puVar2 = (uint *)uartAddr[CONCAT31(in_register_00002029,uartId)];
  uVar5 = uartCfg->uartClk / uartCfg->baudRate;
  if (4 < ((uartCfg->uartClk * 10) / uartCfg->baudRate) % 10) {
    uVar5 = uVar5 + 1;
  }
  puVar2[2] = uVar5 - 1 & 0xffff | (uVar5 - 1) * 0x10000;
  UVar1 = uartCfg->parity;
  uVar5 = *puVar2;
  uVar6 = puVar2[1];
  if (UVar1 == UART_PARITY_ODD) {
    uVar5 = uVar5 | 0x30;
    uVar6 = uVar6 | 0x30;
  }
  else {
    if (UVar1 == UART_PARITY_NONE) {
      uVar5 = uVar5 & 0xffffffef;
      uVar6 = uVar6 & 0xffffffef;
    }
    else {
      if (UVar1 == UART_PARITY_EVEN) {
        uVar5 = uVar5 & 0xffffffdf | 0x10;
        uVar6 = uVar6 & 0xffffffdf | 0x10;
      }
    }
  }
  uVar3 = ((uint)uartCfg->dataBits + 4) * 0x100;
  uVar4 = uVar5 & 0xfffff8ff | uVar3;
  uVar3 = uVar6 & 0xfffff8ff | uVar3;
  uVar5 = ((uint)uartCfg->stopBits + 1) * 0x1000;
  uVar6 = uVar4 & 0xffffcffd | uVar5;
  if (uartCfg->ctsFlowControl == ENABLE) {
    uVar6 = uVar4 & 0xffffcfff | uVar5 | 2;
  }
  if (uartCfg->rxDeglitch == ENABLE) {
    uVar3 = uVar3 | 0x800;
  }
  else {
    uVar3 = uVar3 & 0xfffff7ff;
  }
  uVar5 = uVar3 & 0xfffffffd;
  if (uartCfg->rtsSoftwareControl == ENABLE) {
    uVar5 = uVar3 | 2;
  }
  *puVar2 = uVar6;
  puVar2[1] = uVar5;
  uVar5 = puVar2[3] & 0xfffffffe;
  if (uartCfg->byteBitInverse == UART_MSB_FIRST) {
    uVar5 = puVar2[3] | 1;
  }
  puVar2[3] = uVar5;
  return SUCCESS;
}



BL_Err_Type UART_FifoConfig(UART_ID_Type uartId,UART_FifoCfg_Type *fifoCfg)

{
  undefined3 in_register_00002029;
  uint32_t uVar1;
  uint uVar2;
  uint uVar3;
  
  uVar1 = uartAddr[CONCAT31(in_register_00002029,uartId)];
  *(uint *)(uVar1 + 0x84) =
       (((uint)fifoCfg->txFifoDmaThreshold - 1) * 0x10000 | *(uint *)(uVar1 + 0x84) & 0xffe0ffff) &
       0xe0ffffff | ((uint)fifoCfg->rxFifoDmaThreshold - 1) * 0x1000000;
  uVar3 = *(uint *)(uVar1 + 0x80) & 0xfffffffe;
  if (fifoCfg->txFifoDmaEnable == ENABLE) {
    uVar3 = *(uint *)(uVar1 + 0x80) | 1;
  }
  uVar2 = uVar3 & 0xfffffffd;
  if (fifoCfg->rxFifoDmaEnable == ENABLE) {
    uVar2 = uVar3 | 2;
  }
  *(uint *)(uVar1 + 0x80) = uVar2;
  return SUCCESS;
}



BL_Err_Type UART_Enable(UART_ID_Type uartId,UART_Direction_Type direct)

{
  undefined3 in_register_00002029;
  uint *puVar1;
  
  puVar1 = (uint *)uartAddr[CONCAT31(in_register_00002029,uartId)];
  if ((direct & ~UART_TXRX) == UART_TX) {
    *puVar1 = *puVar1 | 1;
  }
  if ((byte)(direct + ~UART_TX) < 2) {
    puVar1[1] = puVar1[1] | 1;
  }
  return SUCCESS;
}



BL_Err_Type UART_Disable(UART_ID_Type uartId,UART_Direction_Type direct)

{
  undefined3 in_register_00002029;
  uint *puVar1;
  
  puVar1 = (uint *)uartAddr[CONCAT31(in_register_00002029,uartId)];
  if ((direct & ~UART_TXRX) == UART_TX) {
    *puVar1 = *puVar1 & 0xfffffffe;
  }
  if ((byte)(direct + ~UART_TX) < 2) {
    puVar1[1] = puVar1[1] & 0xfffffffe;
  }
  return SUCCESS;
}



BL_Err_Type UART_SetRxTimeoutValue(UART_ID_Type uartId,uint8_t time)

{
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  
  *(uint *)(uartAddr[CONCAT31(in_register_00002029,uartId)] + 0x18) =
       CONCAT31(in_register_0000202d,time) - 1U |
       *(uint *)(uartAddr[CONCAT31(in_register_00002029,uartId)] + 0x18) & 0xffffff00;
  return SUCCESS;
}



BL_Err_Type UART_TxFreeRun(UART_ID_Type uartId,BL_Fun_Type txFreeRun)

{
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  uint uVar1;
  
  uVar1 = *(uint *)uartAddr[CONCAT31(in_register_00002029,uartId)];
  if (CONCAT31(in_register_0000202d,txFreeRun) == 1) {
    uVar1 = uVar1 | 4;
  }
  else {
    uVar1 = uVar1 & 0xfffffffb;
  }
  *(uint *)uartAddr[CONCAT31(in_register_00002029,uartId)] = uVar1;
  return SUCCESS;
}



BL_Err_Type UART_IntMask(UART_ID_Type uartId,UART_INT_Type intType,BL_Mask_Type intMask)

{
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  uint uVar1;
  undefined3 in_register_00002031;
  uint uVar2;
  
  uVar2 = *(uint *)(uartAddr[CONCAT31(in_register_00002029,uartId)] + 0x24);
  if (CONCAT31(in_register_0000202d,intType) == 8) {
    uVar1 = 0;
    if (CONCAT31(in_register_00002031,intMask) == 1) {
      uVar1 = uVar2 | 0xff;
    }
  }
  else {
    uVar1 = 1 << ((uint)intType & 0x1f);
    if (CONCAT31(in_register_00002031,intMask) == 1) {
      uVar1 = uVar1 | uVar2;
    }
    else {
      uVar1 = ~uVar1 & uVar2;
    }
  }
  *(uint *)(uartAddr[CONCAT31(in_register_00002029,uartId)] + 0x24) = uVar1;
  return SUCCESS;
}



uint8_t UART_GetTxFifoCount(UART_ID_Type uartId)

{
  undefined3 in_register_00002029;
  
  return (uint8_t)((byte)*(undefined4 *)(uartAddr[CONCAT31(in_register_00002029,uartId)] + 0x84) &
                  0x3f);
}



BL_Err_Type UART_SendData(UART_ID_Type uartId,uint8_t *data,uint32_t len)

{
  int iVar1;
  uint uVar2;
  uint8_t uVar3;
  undefined3 in_register_00002029;
  undefined3 extraout_var;
  uint8_t *puVar4;
  uint32_t uVar5;
  
  uVar5 = uartAddr[CONCAT31(in_register_00002029,uartId)];
  iVar1 = 160000;
  uVar2 = 0;
  do {
    while( true ) {
      if (len <= uVar2) {
        return SUCCESS;
      }
      uVar3 = UART_GetTxFifoCount(uartId);
      if (CONCAT31(extraout_var,uVar3) == 0) break;
      puVar4 = data + uVar2;
      uVar2 = uVar2 + 1;
      iVar1 = 160000;
      *(uint8_t *)(uVar5 + 0x88) = *puVar4;
    }
    iVar1 = iVar1 + -1;
  } while (iVar1 != 0);
  return TIMEOUT;
}



uint8_t UART_GetRxFifoCount(UART_ID_Type uartId)

{
  undefined3 in_register_00002029;
  
  return (uint8_t)((byte)((uint)*(undefined4 *)
                                 (uartAddr[CONCAT31(in_register_00002029,uartId)] + 0x84) >> 8) &
                  0x3f);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ADC_Reset(void)

{
  _DAT_4000f90c = _DAT_4000f90c & 0xfffffffb;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ADC_Enable(void)

{
  _DAT_4000f90c = _DAT_4000f90c | 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ADC_Disable(void)

{
  _DAT_4000f90c = _DAT_4000f90c & 0xfffffffe;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ADC_Channel_Config(ADC_Chan_Type posCh,ADC_Chan_Type negCh,BL_Fun_Type contEn)

{
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  undefined3 in_register_00002031;
  
  _DAT_4000f90c =
       CONCAT31(in_register_00002029,posCh) << 8 | _DAT_4000f90c & 0xffffe007 |
       CONCAT31(in_register_0000202d,negCh) << 3;
  _DAT_4000f910 =
       (CONCAT31(in_register_00002031,contEn) << 1 | _DAT_4000f910 & 0xfffffffd) & 0xfdffffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ADC_Start(void)

{
  _DAT_4000f90c = _DAT_4000f90c & 0xfffffffd;
  BL602_Delay_US(100);
  _DAT_4000f90c = _DAT_4000f90c | 2;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ADC_FIFO_Cfg(ADC_FIFO_Cfg_Type *fifoCfg)

{
  _DAT_40002000 =
       (uint)fifoCfg->fifoThreshold << 0x16 | _DAT_40002000 & 0xff3ffffe | (uint)fifoCfg->dmaEn | 2;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t ADC_Get_FIFO_Count(void)

{
  return (uint8_t)((byte)((uint)_DAT_40002000 >> 0x10) & 0x3f);
}



// WARNING: Control flow encountered bad instruction data

void ADC_Parse_Result(uint32_t *orgVal,uint32_t len,ADC_Result_Type *result)

{
                    // WARNING: Bad instruction - Truncating control flow here
  halt_baddata();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ADC_Tsen_Init(ADC_TSEN_MOD_Type tsenMod)

{
  undefined3 in_register_00002029;
  
  _DAT_4000f90c = _DAT_4000f90c & 0x87ffffff | 0xc0000;
  _DAT_4000f910 = _DAT_4000f910 | 0x4000000;
  _DAT_4000f914 =
       (_DAT_4000f914 & 0xfc3ffdf | CONCAT31(in_register_00002029,tsenMod) << 5) & 0xffffa07f |
       0x20000140;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ADC_SET_TSVBE_LOW(void)

{
  _DAT_4000f914 = _DAT_4000f914 & 0x7fffffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ADC_SET_TSVBE_HIGH(void)

{
  _DAT_4000f914 = _DAT_4000f914 | 0x80000000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t TSEN_Get_V_Error(void)

{
  BL_Fun_Type BVar1;
  uint8_t uVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  uint uVar3;
  uint32_t uStack44;
  uint32_t regVal;
  ADC_Result_Type result;
  
  uStack44 = 0;
  _DAT_40002000 = _DAT_40002000 | 2;
  ADC_SET_TSVBE_LOW();
  ADC_Start();
  do {
    uVar2 = ADC_Get_FIFO_Count();
    BVar1 = adcGainCoeffCal.adcGainCoeffEnable;
  } while (CONCAT31(extraout_var,uVar2) == 0);
  uStack44 = _DAT_40002004;
  adcGainCoeffCal.adcGainCoeffEnable = DISABLE;
  ADC_Parse_Result(&uStack44,1,(ADC_Result_Type *)&regVal);
  uVar3 = (uint)regVal._2_2_;
  _DAT_40002000 = _DAT_40002000 | 2;
  adcGainCoeffCal.adcGainCoeffEnable = BVar1;
  ADC_SET_TSVBE_HIGH();
  ADC_Start();
  do {
    uVar2 = ADC_Get_FIFO_Count();
    BVar1 = adcGainCoeffCal.adcGainCoeffEnable;
  } while (CONCAT31(extraout_var_00,uVar2) == 0);
  uStack44 = _DAT_40002004;
  adcGainCoeffCal.adcGainCoeffEnable = DISABLE;
  ADC_Parse_Result(&uStack44,1,(ADC_Result_Type *)&regVal);
  adcGainCoeffCal.adcGainCoeffEnable = BVar1;
  return uVar3 - regVal._2_2_;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

float TSEN_Get_Temp(uint32_t tsen_offset)

{
  BL_Fun_Type BVar1;
  uint8_t uVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  uint32_t *orgVal;
  SFtype SVar3;
  undefined4 uVar4;
  uint32_t uStack44;
  uint32_t regVal;
  ADC_Result_Type result;
  
  uStack44 = 0;
  _DAT_40002000 = _DAT_40002000 | 2;
  uVar4 = ADC_SET_TSVBE_LOW();
  ADC_Start(uVar4);
  do {
    uVar2 = ADC_Get_FIFO_Count();
    BVar1 = adcGainCoeffCal.adcGainCoeffEnable;
  } while (CONCAT31(extraout_var,uVar2) == 0);
  uStack44 = _DAT_40002004;
  adcGainCoeffCal.adcGainCoeffEnable = DISABLE;
  ADC_Parse_Result(&uStack44,1,(ADC_Result_Type *)&regVal);
  _DAT_40002000 = _DAT_40002000 | 2;
  adcGainCoeffCal.adcGainCoeffEnable = BVar1;
  uVar4 = ADC_SET_TSVBE_HIGH();
  ADC_Start(uVar4);
  do {
    uVar2 = ADC_Get_FIFO_Count();
    BVar1 = adcGainCoeffCal.adcGainCoeffEnable;
  } while (CONCAT31(extraout_var_00,uVar2) == 0);
  orgVal = &uStack44;
  uStack44 = _DAT_40002004;
  adcGainCoeffCal.adcGainCoeffEnable = DISABLE;
  ADC_Parse_Result(orgVal,1,(ADC_Result_Type *)&regVal);
  adcGainCoeffCal.adcGainCoeffEnable = BVar1;
  __extendsfdf2((SFtype)orgVal);
  __divdf3();
  SVar3 = __truncdfsf2();
  return (float)SVar3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ADC_Init(ADC_CFG_Type *cfg)

{
  uint uVar1;
  uint uVar2;
  
  _DAT_4000f910 =
       (uint)cfg->resWidth << 2 |
       ((uint)cfg->clkDiv << 0x12 |
        (uint)cfg->v11Sel << 0x1b | (uint)cfg->v18Sel << 0x1d | _DAT_4000f910 & 0x8001fffe |
       (uint)cfg->offsetCalibEn) & 0xffffffe3;
  if ((cfg->gain1 | cfg->gain2) == 0) {
    uVar1 = 0xfffe1fff;
    uVar2 = 0x8000;
  }
  else {
    uVar1 = 0xfffe3fff;
    uVar2 = 0x12000;
  }
  _DAT_4000f914 =
       ((uint)cfg->biasSel << 0x11 |
       (uint)cfg->gain2 << 0x16 | (uint)cfg->gain1 << 0x19 | _DAT_4000f914 & 0x803dffff) & uVar1 &
       0xffffe073 | uVar2 | (uint)cfg->vcm << 7 | (uint)cfg->vref << 3 | 0x1000 |
       (uint)cfg->inputMode << 2;
  _DAT_4000f938 = (int)cfg->offsetCalibVal | _DAT_4000f938 & 0xffff0000;
                    // WARNING: Treating indirect jump as call
  ADC_Gain_Trim();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type Sec_Eng_SHA256_Update(SEC_Eng_SHA256_Ctx *shaCtx,uint8_t *input,uint32_t len)

{
  byte bVar1;
  uint uVar2;
  int iVar3;
  uint n;
  uint32_t *psrc;
  uint uVar4;
  
  uVar2 = _DAT_40004000;
  iVar3 = 16000000;
  do {
    iVar3 = iVar3 + -1;
    if (iVar3 == 0) {
      return TIMEOUT;
    }
  } while ((_DAT_40004000 & 1) != 0);
  bVar1 = shaCtx->shaFeed;
  uVar4 = shaCtx->total[0] & 0x3f;
  n = shaCtx->total[0] + len;
  shaCtx->total[0] = n;
  if (n < len) {
    shaCtx->total[1] = shaCtx->total[1] + 1;
  }
  if ((uVar4 != 0) && (n = 0x40 - uVar4, n <= len)) {
    BL602_MemCpy_Fast((void *)((int)shaCtx->shaBuf + uVar4),input,n);
    _DAT_40004004 = shaCtx->shaBuf;
    _DAT_40004000 = (uint)bVar1 << 6 | uVar2 & 0xffbf | 0x10002;
    len = (len - 0x40) + uVar4;
    shaCtx->shaFeed = '\x01';
    input = input + n;
    uVar4 = 0;
  }
  psrc = (uint32_t *)input;
  if (0x3f < len) {
    iVar3 = 16000000;
    do {
      iVar3 = iVar3 + -1;
      if (iVar3 == 0) {
        return TIMEOUT;
      }
    } while ((_DAT_40004000 & 1) != 0);
    _DAT_40004000 = (len >> 6) << 0x10 | (uint)shaCtx->shaFeed << 6 | _DAT_40004000 & 0xffbf | 2;
    psrc = (uint32_t *)((int)input + (len & 0xffffffc0));
    _DAT_40004004 = (uint32_t *)input;
    shaCtx->shaFeed = '\x01';
  }
  if ((len & 0x3f) != 0) {
    iVar3 = 16000000;
    do {
      iVar3 = iVar3 + -1;
      if (iVar3 == 0) {
        return TIMEOUT;
      }
    } while ((_DAT_40004000 & 1) != 0);
    BL602_MemCpy_Fast((void *)((int)shaCtx->shaBuf + uVar4),psrc,len & 0x3f);
  }
  iVar3 = 16000000;
  do {
    iVar3 = iVar3 + -1;
    if (iVar3 == 0) {
      return TIMEOUT;
    }
  } while ((_DAT_40004000 & 1) != 0);
  return SUCCESS;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_SHA256_Init(SEC_Eng_SHA256_Ctx *shaCtx,SEC_ENG_SHA_ID_Type shaNo,
                        SEC_ENG_SHA_Type shaType,uint32_t *shaTmpBuf,uint32_t *padding)

{
  undefined3 in_register_00002031;
  
  _DAT_40004000 = CONCAT31(in_register_00002031,shaType) << 2 | _DAT_40004000 & 0xffffffe3;
  memset(shaCtx,0,0x14);
  shaCtx->shaPadding = padding;
  shaCtx->shaBuf = shaTmpBuf;
  BL602_MemSet(padding,'\0',0x40);
                    // WARNING: Treating indirect jump as call
  BL602_MemSet(shaCtx->shaPadding,-0x80,1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_SHA_Start(SEC_ENG_SHA_ID_Type shaNo)

{
  _DAT_40004000 = _DAT_40004000 & 0xffffffbf | 0x20;
  return;
}



BL_Err_Type
Sec_Eng_SHA256_Update
          (SEC_Eng_SHA256_Ctx *shaCtx,SEC_ENG_SHA_ID_Type shaNo,uint8_t *input,uint32_t len)

{
  BL_Err_Type BVar1;
  
  if (len != 0) {
    BVar1 = Sec_Eng_SHA256_Update(shaCtx,input,len);
    return BVar1;
  }
  return SUCCESS;
}



// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
Sec_Eng_SHA256_Finish(SEC_Eng_SHA256_Ctx *shaCtx,SEC_ENG_SHA_ID_Type shaNo,uint8_t *hash)

{
  undefined4 uVar1;
  uint uVar2;
  int iVar3;
  uint uVar4;
  undefined uStack24;
  undefined uStack23;
  ushort uStack22;
  uint8_t msgLen [8];
  
  iVar3 = 16000000;
  do {
    iVar3 = iVar3 + -1;
    if (iVar3 == 0) {
      return TIMEOUT;
    }
  } while ((_DAT_40004000 & 1) != 0);
  uVar2 = shaCtx->total[0];
  uVar4 = shaCtx->total[1] << 3;
  uStack24 = (undefined)(uVar4 >> 0x18);
  uStack23 = (undefined)(uVar4 >> 0x10);
  uStack22 = (ushort)((uVar4 | uVar2 >> 0x1d) << 8) | (ushort)(uVar4 >> 8) & 0xff;
  msgLen[0] = (uint8_t)((uVar2 << 3) >> 0x18);
  msgLen[1] = (uint8_t)((uVar2 << 3) >> 0x10);
  msgLen._2_2_ = (ushort)((uVar2 << 0x13) >> 0x18) | (ushort)(uVar2 << 0xb);
  if ((uVar2 & 0x3f) < 0x38) {
    iVar3 = 0x38;
  }
  else {
    iVar3 = 0x78;
  }
  Sec_Eng_SHA256_Update(shaCtx,shaNo,(uint8_t *)shaCtx->shaPadding,iVar3 - (uVar2 & 0x3f));
  iVar3 = 16000000;
  do {
    iVar3 = iVar3 + -1;
    if (iVar3 == 0) {
      return TIMEOUT;
    }
  } while ((_DAT_40004000 & 1) != 0);
  BL602_MemCpy_Fast(shaCtx->shaPadding,&uStack24,8);
  Sec_Eng_SHA256_Update(shaCtx,(uint8_t *)shaCtx->shaPadding,8);
  uVar1 = _DAT_40004010;
  iVar3 = 16000000;
  do {
    iVar3 = iVar3 + -1;
    if (iVar3 == 0) {
      return TIMEOUT;
    }
  } while ((_DAT_40004000 & 1) != 0);
  uVar2 = _DAT_40004000 >> 2;
  *hash = (uint8_t)_DAT_40004010;
  hash[1] = (uint8_t)((uint)uVar1 >> 8);
  hash[2] = (uint8_t)((uint)uVar1 >> 0x10);
  hash[3] = (uint8_t)((uint)uVar1 >> 0x18);
  uVar1 = _DAT_40004014;
  hash[4] = (uint8_t)_DAT_40004014;
  hash[5] = (uint8_t)((uint)uVar1 >> 8);
  hash[6] = (uint8_t)((uint)uVar1 >> 0x10);
  hash[7] = (uint8_t)((uint)uVar1 >> 0x18);
  uVar1 = _DAT_40004018;
  hash[8] = (uint8_t)_DAT_40004018;
  hash[9] = (uint8_t)((uint)uVar1 >> 8);
  hash[10] = (uint8_t)((uint)uVar1 >> 0x10);
  hash[0xb] = (uint8_t)((uint)uVar1 >> 0x18);
  uVar1 = _DAT_4000401c;
  hash[0xc] = (uint8_t)_DAT_4000401c;
  hash[0xd] = (uint8_t)((uint)uVar1 >> 8);
  hash[0xe] = (uint8_t)((uint)uVar1 >> 0x10);
  hash[0xf] = (uint8_t)((uint)uVar1 >> 0x18);
  uVar1 = _DAT_40004020;
  hash[0x10] = (uint8_t)_DAT_40004020;
  hash[0x11] = (uint8_t)((uint)uVar1 >> 8);
  hash[0x13] = (uint8_t)((uint)uVar1 >> 0x18);
  hash[0x12] = (uint8_t)((uint)uVar1 >> 0x10);
  uVar1 = _DAT_40004024;
  if ((uVar2 & 6) == 0) {
    hash[0x14] = (uint8_t)_DAT_40004024;
    hash[0x15] = (uint8_t)((uint)uVar1 >> 8);
    hash[0x16] = (uint8_t)((uint)uVar1 >> 0x10);
    hash[0x17] = (uint8_t)((uint)uVar1 >> 0x18);
    uVar1 = _DAT_40004028;
    hash[0x18] = (uint8_t)_DAT_40004028;
    hash[0x19] = (uint8_t)((uint)uVar1 >> 8);
    hash[0x1a] = (uint8_t)((uint)uVar1 >> 0x10);
    hash[0x1b] = (uint8_t)((uint)uVar1 >> 0x18);
    uVar1 = _DAT_4000402c;
    if ((uVar2 & 7) == 0) {
      hash[0x1c] = (uint8_t)_DAT_4000402c;
      hash[0x1d] = (uint8_t)((uint)uVar1 >> 8);
      hash[0x1e] = (uint8_t)((uint)uVar1 >> 0x10);
      hash[0x1f] = (uint8_t)((uint)uVar1 >> 0x18);
    }
  }
  _DAT_40004000 = _DAT_40004000 & 0xffffff9f;
  return SUCCESS;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void DMA_Enable(void)

{
  _DAT_4000c030 = _DAT_4000c030 | 1;
  return;
}



void DMA_Channel_Enable(uint8_t ch)

{
  undefined3 in_register_00002029;
  uint *puVar1;
  
  puVar1 = (uint *)(CONCAT31(in_register_00002029,ch) * 0x100 + 0x4000c110);
  *puVar1 = *puVar1 | 1;
  return;
}



void DMA_LLI_Init(uint8_t ch,DMA_LLI_Cfg_Type *lliCfg)

{
  undefined3 in_register_00002029;
  uint *puVar1;
  
  puVar1 = (uint *)(CONCAT31(in_register_00002029,ch) * 0x100 + 0x4000c110);
  *puVar1 = (uint)lliCfg->dir << 0xb | *puVar1 & 0xffffc001 | (uint)lliCfg->dstPeriph << 6 |
            (uint)lliCfg->srcPeriph << 1;
  return;
}



void DMA_LLI_Update(uint8_t ch,uint32_t LLI)

{
  undefined3 in_register_00002029;
  
                    // WARNING: Treating indirect jump as call
  BL602_MemCpy4((uint32_t *)(CONCAT31(in_register_00002029,ch) * 0x100 + 0x4000c100),(uint32_t *)LLI
                ,4);
  return;
}



void DMA_IntMask(uint8_t ch,DMA_INT_Type intType,BL_Mask_Type intMask)

{
  undefined3 in_register_00002029;
  int iVar1;
  uint *puVar2;
  undefined3 in_register_0000202d;
  int iVar3;
  undefined3 in_register_00002031;
  int iVar4;
  uint uVar5;
  uint uVar6;
  
  iVar4 = CONCAT31(in_register_00002031,intMask);
  iVar3 = CONCAT31(in_register_0000202d,intType);
  iVar1 = CONCAT31(in_register_00002029,ch) * 0x100;
  if (iVar3 == 1) {
    puVar2 = (uint *)(iVar1 + 0x4000c110);
    uVar6 = *puVar2;
    if (iVar4 == 0) {
      uVar6 = uVar6 & 0xffffbfff;
      goto LAB_23045ebe;
    }
    uVar5 = 0x4000;
  }
  else {
    if (iVar3 == 0) {
      uVar6 = *(uint *)(iVar1 + 0x4000c110);
      iVar3 = -0x8000;
      if (iVar4 != 0) {
        uVar5 = 0x8000;
        goto LAB_23045e9e;
      }
    }
    else {
      if (iVar3 != 2) {
        return;
      }
      uVar6 = *(uint *)(iVar1 + 0x4000c110);
      if (iVar4 != 0) {
        uVar5 = 0xc000;
LAB_23045e9e:
        puVar2 = (uint *)(iVar1 + 0x4000c10c);
        *(uint *)(iVar1 + 0x4000c110) = uVar6 | uVar5;
        uVar6 = *puVar2 & 0x7fffffff;
        goto LAB_23045ebe;
      }
      iVar3 = -0xc000;
    }
    puVar2 = (uint *)(iVar1 + 0x4000c10c);
    *(uint *)(iVar1 + 0x4000c110) = uVar6 & iVar3 - 1U;
    uVar6 = *puVar2;
    uVar5 = 0x80000000;
  }
  uVar6 = uVar6 | uVar5;
LAB_23045ebe:
  *puVar2 = uVar6;
  return;
}



void Default_Handler(void)

{
  bflb_platform_printf("Default_Handler\r\n");
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_Set_UART_CLK(uint8_t enable,HBN_UART_CLK_Type clkSel,uint8_t div)

{
  undefined3 in_register_00002029;
  undefined3 in_register_00002031;
  uint uVar1;
  
  _DAT_40000008 = CONCAT31(in_register_00002031,div) | _DAT_40000008 & 0xffffffe8;
  HBN_Set_UART_CLK_Sel(clkSel);
  uVar1 = _DAT_40000008 | 0x10;
  if (CONCAT31(in_register_00002029,enable) == 0) {
    uVar1 = _DAT_40000008 & 0xffffffef;
  }
  _DAT_40000008 = uVar1;
  return SUCCESS;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_Set_EM_Sel(GLB_EM_Type emType)

{
  undefined3 in_register_00002029;
  
  _DAT_4000007c = CONCAT31(in_register_00002029,emType) | _DAT_4000007c & 0xfffffff0;
  return SUCCESS;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_Set_ADC_CLK(uint8_t enable,GLB_ADC_CLK_Type clkSel,uint8_t div)

{
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  undefined3 in_register_00002031;
  uint uVar1;
  
  uVar1 = (CONCAT31(in_register_00002031,div) | _DAT_400000a4 & 0xfffffec0) & 0xffffff7f |
          CONCAT31(in_register_0000202d,clkSel) << 7;
  _DAT_400000a4 = uVar1 & 0xfffffeff;
  if (CONCAT31(in_register_00002029,enable) != 0) {
    _DAT_400000a4 = uVar1 | 0x100;
  }
  return SUCCESS;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_UART_Fun_Sel(GLB_UART_SIG_Type sig,GLB_UART_SIG_FUN_Type fun)

{
  undefined3 in_register_0000202d;
  
  _DAT_400000c0 =
       ~(0xf << (((uint)sig & 7) << 2)) & _DAT_400000c0 |
       CONCAT31(in_register_0000202d,fun) << (((uint)sig & 7) << 2);
  return SUCCESS;
}



BL_Err_Type GLB_GPIO_Write(GLB_GPIO_Type gpioPin,uint32_t val)

{
  undefined3 in_register_00002029;
  uint uVar1;
  uint uVar2;
  uint *puVar3;
  
  puVar3 = (uint *)((CONCAT31(in_register_00002029,gpioPin) >> 5) * 4 + 0x40000188);
  uVar2 = *puVar3;
  uVar1 = 1 << ((uint)gpioPin & 0x1f);
  if (val == 0) {
    uVar1 = ~uVar1 & uVar2;
  }
  else {
    uVar1 = uVar1 | uVar2;
  }
  *puVar3 = uVar1;
  return SUCCESS;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Set_UART_CLK_Sel(HBN_UART_CLK_Type clkSel)

{
  undefined3 in_register_00002029;
  
  _DAT_4000f030 = CONCAT31(in_register_00002029,clkSel) << 2 | _DAT_4000f030 & 0xfffffffb;
  return SUCCESS;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Get_RTC_Timer_Val(uint32_t *valLow,uint32_t *valHigh)

{
  _DAT_4000f010 = _DAT_4000f010 & 0x7fffffff;
  *valLow = _DAT_4000f00c;
  *valHigh = _DAT_4000f010 & 0xff;
  return SUCCESS;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Aon_Pad_IeSmt_Cfg(uint8_t padCfg)

{
  undefined3 in_register_00002029;
  
  _DAT_4000f014 = CONCAT31(in_register_00002029,padCfg) << 8 | _DAT_4000f014 & 0xfffffeff;
  return SUCCESS;
}



uint32_t EF_Ctrl_Get_Byte_Zero_Cnt(uint8_t val)

{
  undefined3 in_register_00002029;
  uint32_t uVar1;
  uint uVar2;
  
  uVar2 = 0;
  uVar1 = 0;
  do {
    if ((CONCAT31(in_register_00002029,val) >> (uVar2 & 0x1f) & 1U) == 0) {
      uVar1 = uVar1 + 1;
    }
    uVar2 = uVar2 + 1;
  } while (uVar2 != 8);
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type EF_Ctrl_Read_MAC_Address(uint8_t *mac)

{
  uint8_t uVar1;
  undefined4 uVar2;
  uint uVar3;
  BL_Err_Type BVar4;
  uint32_t uVar5;
  uint8_t *puVar6;
  uint8_t *puVar7;
  uint8_t *puVar8;
  int iVar9;
  uint uVar10;
  
  EF_Ctrl_Load_Efuse_R0();
  uVar2 = _DAT_40007014;
  uVar10 = 0;
  iVar9 = 0;
  *mac = (uint8_t)_DAT_40007014;
  mac[1] = (uint8_t)((uint)uVar2 >> 8);
  mac[3] = (uint8_t)((uint)uVar2 >> 0x18);
  mac[2] = (uint8_t)((uint)uVar2 >> 0x10);
  uVar3 = _DAT_40007018;
  mac[4] = (uint8_t)_DAT_40007018;
  mac[5] = (uint8_t)(uVar3 >> 8);
  do {
    puVar7 = mac + iVar9;
    iVar9 = iVar9 + 1;
    uVar5 = EF_Ctrl_Get_Byte_Zero_Cnt(*puVar7);
    uVar10 = uVar10 + uVar5;
  } while (iVar9 != 6);
  BVar4 = ERROR;
  if (((uVar3 >> 0x10 ^ uVar10) & 0x3f) == 0) {
    puVar6 = mac + 2;
    puVar7 = mac + 5;
    do {
      uVar1 = *mac;
      puVar8 = puVar7 + -1;
      *mac = *puVar7;
      *puVar7 = uVar1;
      mac = mac + 1;
      puVar7 = puVar8;
    } while (puVar8 != puVar6);
    BVar4 = SUCCESS;
  }
  return BVar4;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t EF_Ctrl_Is_MAC_Address_Slot_Empty(uint8_t slot,uint8_t reload)

{
  undefined3 in_register_00002029;
  int iVar1;
  undefined3 in_register_0000202d;
  int iVar2;
  uint uVar3;
  uint uVar4;
  
  iVar2 = CONCAT31(in_register_0000202d,reload);
  iVar1 = CONCAT31(in_register_00002029,slot);
  if (iVar1 == 0) {
    EF_Ctrl_Sw_AHB_Clk_0();
    uVar3 = _DAT_40007014;
    uVar4 = _DAT_40007018;
    if (iVar2 != 0) {
      EF_Ctrl_Load_Efuse_R0();
      uVar3 = _DAT_40007014;
      uVar4 = _DAT_40007018;
    }
  }
  else {
    if (iVar1 == 1) {
      EF_Ctrl_Sw_AHB_Clk_0();
      uVar3 = _DAT_4000706c;
      uVar4 = _DAT_40007070;
      if (iVar2 != 0) {
        EF_Ctrl_Load_Efuse_R0();
        uVar3 = _DAT_4000706c;
        uVar4 = _DAT_40007070;
      }
    }
    else {
      if (iVar1 != 2) {
        return '\0';
      }
      EF_Ctrl_Sw_AHB_Clk_0();
      uVar3 = _DAT_40007004;
      uVar4 = _DAT_40007008;
      if (iVar2 != 0) {
        EF_Ctrl_Load_Efuse_R0();
        uVar3 = _DAT_40007004;
        uVar4 = _DAT_40007008;
      }
    }
  }
  if ((uVar4 & 0x3fffff | uVar3) != 0) {
    return '\0';
  }
  return '\x01';
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type EF_Ctrl_Read_MAC_Address_Opt(uint8_t slot,uint8_t *mac,uint8_t reload)

{
  uint8_t uVar1;
  uint uVar2;
  BL_Err_Type BVar3;
  undefined3 in_register_00002029;
  uint32_t uVar4;
  undefined3 in_register_00002031;
  uint8_t *puVar5;
  undefined4 uVar6;
  uint8_t *puVar7;
  uint8_t *puVar8;
  int iVar9;
  uint uVar10;
  
  uVar10 = CONCAT31(in_register_00002029,slot);
  if (2 < uVar10) {
    return ERROR;
  }
  if (CONCAT31(in_register_00002031,reload) == 0) {
LAB_23046190:
    uVar6 = _DAT_40007014;
    if ((uVar10 == 0) || (uVar6 = _DAT_4000706c, uVar10 == 1)) goto LAB_23046198;
  }
  else {
    if (uVar10 != 2) {
      EF_Ctrl_Load_Efuse_R0();
      goto LAB_23046190;
    }
    EF_Ctrl_Load_Efuse_R0();
  }
  uVar6 = _DAT_40007004;
LAB_23046198:
  *mac = (uint8_t)uVar6;
  mac[1] = (uint8_t)((uint)uVar6 >> 8);
  mac[2] = (uint8_t)((uint)uVar6 >> 0x10);
  mac[3] = (uint8_t)((uint)uVar6 >> 0x18);
  uVar2 = _DAT_40007018;
  if ((uVar10 != 0) && (uVar2 = _DAT_40007008, uVar10 == 1)) {
    uVar2 = _DAT_40007070;
  }
  mac[4] = (uint8_t)uVar2;
  mac[5] = (uint8_t)(uVar2 >> 8);
  uVar10 = 0;
  iVar9 = 0;
  do {
    puVar7 = mac + iVar9;
    iVar9 = iVar9 + 1;
    uVar4 = EF_Ctrl_Get_Byte_Zero_Cnt(*puVar7);
    uVar10 = uVar10 + uVar4;
  } while (iVar9 != 6);
  BVar3 = ERROR;
  if (((uVar2 >> 0x10 ^ uVar10) & 0x3f) == 0) {
    puVar5 = mac + 2;
    puVar7 = mac + 5;
    do {
      uVar1 = *mac;
      puVar8 = puVar7 + -1;
      *mac = *puVar7;
      *puVar7 = uVar1;
      mac = mac + 1;
      puVar7 = puVar8;
    } while (puVar5 != puVar8);
    BVar3 = SUCCESS;
  }
  return BVar3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint EF_Ctrl_Is_CapCode_Slot_Empty(int param_1,int param_2)

{
  uint uVar1;
  
  EF_Ctrl_Sw_AHB_Clk_0();
  if (param_2 != 0) {
    EF_Ctrl_Load_Efuse_R0();
  }
  if (param_1 == 0) {
    uVar1 = _DAT_4000700c >> 2;
  }
  else {
    uVar1 = _DAT_40007070;
    if ((param_1 != 1) && (uVar1 = _DAT_40007008, param_1 != 2)) {
      return 0;
    }
    uVar1 = uVar1 >> 0x16;
  }
  return (uint)((uVar1 & 0xff) == 0);
}



// WARNING: Variable defined which should be unmapped: tmp
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type EF_Ctrl_Read_CapCode_Opt(uint8_t slot,uint8_t *code,uint8_t reload)

{
  uint8_t uVar1;
  undefined3 in_register_00002029;
  uint uVar2;
  undefined3 extraout_var;
  undefined3 in_register_00002031;
  uint uVar3;
  uint32_t tmp;
  
  uVar2 = CONCAT31(in_register_00002029,slot);
  if (2 < uVar2) {
    return ERROR;
  }
  EF_Ctrl_Sw_AHB_Clk_0();
  if (CONCAT31(in_register_00002031,reload) != 0) {
    EF_Ctrl_Load_Efuse_R0();
  }
  if (uVar2 == 0) {
    uVar3 = _DAT_4000700c >> 2;
  }
  else {
    uVar3 = _DAT_40007008;
    if (uVar2 == 1) {
      uVar3 = _DAT_40007070;
    }
    uVar3 = uVar3 >> 0x16;
  }
  if ((uVar3 & 0x80) != 0) {
    uVar1 = EF_Ctrl_Get_Trim_Parity(uVar3 & 0x3f,'\x06');
    if ((uVar3 >> 6 & 1) == CONCAT31(extraout_var,uVar1)) {
      *code = (uint8_t)(uVar3 & 0x3f);
      return SUCCESS;
    }
  }
  return ERROR;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t EF_Ctrl_Is_PowerOffset_Slot_Empty(uint8_t slot,uint8_t reload)

{
  byte bVar1;
  undefined3 in_register_00002029;
  int iVar2;
  undefined3 in_register_0000202d;
  byte bVar3;
  uint uVar4;
  
  iVar2 = CONCAT31(in_register_00002029,slot);
  EF_Ctrl_Sw_AHB_Clk_0();
  if (CONCAT31(in_register_0000202d,reload) != 0) {
    EF_Ctrl_Load_Efuse_R0();
  }
  if (iVar2 == 0) {
    bVar3 = 1;
    uVar4 = _DAT_40007078 >> 0xf;
  }
  else {
    if (iVar2 == 1) {
      bVar3 = (byte)_DAT_4000700c;
      uVar4 = _DAT_40007074 & 0xffff;
    }
    else {
      if (iVar2 != 2) {
        return '\0';
      }
      uVar4 = _DAT_40007074 >> 0x10;
      bVar3 = (byte)(_DAT_4000700c >> 1);
    }
    bVar3 = ~bVar3 & 1;
  }
  bVar1 = 0;
  if (uVar4 == 0) {
    bVar1 = bVar3;
  }
  return (uint8_t)bVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type EF_Ctrl_Read_PowerOffset_Opt(uint8_t slot,int8_t *pwrOffset,uint8_t reload)

{
  uint uVar1;
  int iVar2;
  uint32_t val;
  uint8_t uVar3;
  undefined3 in_register_00002029;
  undefined3 extraout_var;
  uint32_t uVar4;
  undefined3 in_register_00002031;
  byte bVar5;
  uint uVar6;
  undefined4 uVar7;
  
  iVar2 = CONCAT31(in_register_00002029,slot);
  uVar7 = EF_Ctrl_Sw_AHB_Clk_0();
  if (CONCAT31(in_register_00002031,reload) != 0) {
    EF_Ctrl_Load_Efuse_R0(uVar7);
  }
  if (iVar2 == 0) {
    val = (_DAT_40007078 << 1) >> 0x11;
    uVar1 = _DAT_40007078 >> 0x1f;
    uVar6 = _DAT_40007078 >> 0xf;
  }
  else {
    if (iVar2 == 1) {
      val = _DAT_40007074 & 0x7fff;
      uVar1 = _DAT_40007074 >> 0xf & 1;
      uVar6 = _DAT_4000700c;
    }
    else {
      if (iVar2 != 2) {
        return ERROR;
      }
      val = (_DAT_40007074 << 1) >> 0x11;
      uVar1 = _DAT_40007074 >> 0x1f;
      uVar6 = _DAT_4000700c >> 1;
    }
  }
  if (((uVar6 & 1) != 0) &&
     (uVar3 = EF_Ctrl_Get_Trim_Parity(val,'\x0f'), CONCAT31(extraout_var,uVar3) == uVar1)) {
    iVar2 = 0;
    do {
      uVar4 = val;
      __lshrdi3(val);
      bVar5 = (byte)uVar4 & 0x1f;
      if ((uVar4 & 0x10) != 0) {
        bVar5 = bVar5 - 0x20;
      }
      pwrOffset[iVar2] = bVar5;
      iVar2 = iVar2 + 1;
    } while (iVar2 != 3);
    return SUCCESS;
  }
  return ERROR;
}



int8_t mfg_media_read_xtal_capcode(uint8_t *capcode,uint8_t reload)

{
  int8_t iVar1;
  
  if (rf_para_on_flash != '\0') {
    iVar1 = mfg_flash_read_xtal_capcode(capcode,reload);
    return iVar1;
  }
  iVar1 = mfg_efuse_read_xtal_capcode(capcode,reload);
  return iVar1;
}



int8_t mfg_media_read_poweroffset(int8_t *pwrOffset,uint8_t reload)

{
  int8_t iVar1;
  
  if (rf_para_on_flash != '\0') {
    iVar1 = mfg_flash_read_poweroffset(pwrOffset,reload);
    return iVar1;
  }
  iVar1 = mfg_efuse_read_poweroffset(pwrOffset,reload);
  return iVar1;
}



int8_t mfg_media_read_macaddr(uint8_t *mac,uint8_t reload)

{
  int8_t iVar1;
  
  if (rf_para_on_flash != '\0') {
    iVar1 = mfg_flash_read_macaddr(mac,reload);
    return iVar1;
  }
  iVar1 = mfg_efuse_read_macaddr(mac,reload);
  return iVar1;
}



void bflb_platform_usart_dbg_send(uint8_t *data,uint32_t len)

{
  UART_SendData(UART0_ID,data,len);
  return;
}



void bflb_platform_printf(char *fmt,...)

{
  char print_buf [128];
  size_t len;
  undefined4 in_a1;
  undefined4 in_a2;
  undefined4 in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list ap;
  undefined4 uStack28;
  undefined4 uStack24;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  undefined4 uStack8;
  undefined4 uStack4;
  
  if (uart_dbg_disable == '\0') {
    uStack28 = in_a1;
    uStack24 = in_a2;
    uStack20 = in_a3;
    uStack16 = in_a4;
    uStack12 = in_a5;
    uStack8 = in_a6;
    uStack4 = in_a7;
    vsnprintf((char *)&ram0x420155ec,0x7f,fmt,&uStack28);
    len = strlen((char *)0x420155ec);
    bflb_platform_usart_dbg_send((uint8_t *)0x420155ec,len);
  }
  return;
}



// WARNING: Control flow encountered bad instruction data

void Default_Handler_Stub(void)

{
                    // WARNING: Bad instruction - Truncating control flow here
  halt_baddata();
}



int8_t mfg_efuse_read_xtal_capcode(uint8_t *capcode,uint8_t reload)

{
  uint8_t bclkDiv;
  uint8_t hclkDiv;
  BL_Err_Type BVar1;
  int iVar2;
  undefined3 extraout_var;
  undefined3 in_register_0000202d;
  undefined4 uVar3;
  
  uVar3 = CONCAT31(in_register_0000202d,reload);
  bclkDiv = GLB_Get_BCLK_Div();
  hclkDiv = GLB_Get_HCLK_Div();
  HBN_Set_ROOT_CLK_Sel(HBN_ROOT_CLK_XTAL);
  if ((rf_cal_slots < 3) || (iVar2 = EF_Ctrl_Is_CapCode_Slot_Empty(2,uVar3), iVar2 != 0)) {
    if ((rf_cal_slots < 2) || (iVar2 = EF_Ctrl_Is_CapCode_Slot_Empty(1,uVar3), iVar2 != 0)) {
      if ((rf_cal_slots == '\0') || (iVar2 = EF_Ctrl_Is_CapCode_Slot_Empty(0,uVar3), iVar2 != 0)) {
        printf("No written slot found\r\n");
        iVar2 = 1;
        goto LAB_23046628;
      }
    }
    else {
      iVar2 = 1;
    }
  }
  else {
    iVar2 = 2;
  }
  printf("Read slot:%d\r\n",iVar2);
  BVar1 = EF_Ctrl_Read_CapCode_Opt((uint8_t)iVar2,capcode,reload);
  iVar2 = CONCAT31(extraout_var,BVar1);
LAB_23046628:
  GLB_Set_System_CLK_Div(hclkDiv,bclkDiv);
  HBN_Set_ROOT_CLK_Sel(HBN_ROOT_CLK_PLL);
  return (int8_t)-(iVar2 != 0);
}



int8_t mfg_efuse_read_poweroffset(int8_t *pwrOffset,uint8_t reload)

{
  int iVar1;
  uint8_t bclkDiv;
  uint8_t hclkDiv;
  uint8_t uVar2;
  BL_Err_Type BVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  int iVar4;
  int iVar5;
  int8_t iStack36;
  char cStack35;
  char cStack34;
  int8_t pwrOffsetTmp [3];
  
  bclkDiv = GLB_Get_BCLK_Div();
  hclkDiv = GLB_Get_HCLK_Div();
  HBN_Set_ROOT_CLK_Sel(HBN_ROOT_CLK_XTAL);
  if ((rf_cal_slots < 3) ||
     (uVar2 = EF_Ctrl_Is_PowerOffset_Slot_Empty('\x02',reload), CONCAT31(extraout_var_00,uVar2) != 0
     )) {
    if ((rf_cal_slots < 2) ||
       (uVar2 = EF_Ctrl_Is_PowerOffset_Slot_Empty('\x01',reload), CONCAT31(extraout_var,uVar2) != 0)
       ) {
      if (rf_cal_slots != '\0') {
        uVar2 = EF_Ctrl_Is_PowerOffset_Slot_Empty('\0',reload);
        iVar1 = CONCAT31(extraout_var_01,uVar2);
        if (iVar1 == 0) goto LAB_230466e2;
      }
      printf("No written slot found\r\n");
      iVar1 = 1;
      goto LAB_23046804;
    }
    iVar1 = 1;
  }
  else {
    iVar1 = 2;
  }
LAB_230466e2:
  printf("Read slot:%d\r\n",iVar1);
  BVar3 = EF_Ctrl_Read_PowerOffset_Opt((uint8_t)iVar1,&iStack36,reload);
  iVar1 = CONCAT31(extraout_var_02,BVar3);
  memset(pwrOffset,0,0xe);
  *pwrOffset = iStack36;
  pwrOffset[6] = cStack35;
  pwrOffset[0xc] = cStack34;
  iVar4 = (((int)cStack35 - (int)iStack36) * 100) / 6;
  pwrOffset[2] = (char)((iVar4 + 0x19) / 0x32) + iStack36;
  pwrOffset[3] = (char)((iVar4 * 3 + 0x32) / 100) + iStack36;
  pwrOffset[4] = (char)((iVar4 * 4 + 0x32) / 100) + iStack36;
  pwrOffset[1] = (char)((iVar4 + 0x32) / 100) + iStack36;
  iVar5 = (((int)cStack34 - (int)cStack35) * 100) / 6;
  pwrOffset[5] = (char)((iVar4 * 5 + 0x32) / 100) + iStack36;
  pwrOffset[8] = (char)((iVar5 + 0x19) / 0x32) + cStack35;
  pwrOffset[0xb] = (char)((iVar5 * 5 + 0x32) / 100) + cStack35;
  pwrOffset[9] = (char)((iVar5 * 3 + 0x32) / 100) + cStack35;
  pwrOffset[7] = (char)((iVar5 + 0x32) / 100) + cStack35;
  pwrOffset[10] = (char)((iVar5 * 4 + 0x32) / 100) + cStack35;
  pwrOffset[0xd] = (char)((iVar5 * 7 + 0x32) / 100) + cStack35;
LAB_23046804:
  GLB_Set_System_CLK_Div(hclkDiv,bclkDiv);
  HBN_Set_ROOT_CLK_Sel(HBN_ROOT_CLK_PLL);
  return (int8_t)-(iVar1 != 0);
}



int8_t mfg_efuse_read_macaddr(uint8_t *mac,uint8_t reload)

{
  int iVar1;
  uint8_t bclkDiv;
  uint8_t hclkDiv;
  uint8_t uVar2;
  BL_Err_Type BVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  
  bclkDiv = GLB_Get_BCLK_Div();
  hclkDiv = GLB_Get_HCLK_Div();
  HBN_Set_ROOT_CLK_Sel(HBN_ROOT_CLK_XTAL);
  if ((rf_cal_slots < 3) ||
     (uVar2 = EF_Ctrl_Is_MAC_Address_Slot_Empty('\x02',reload), CONCAT31(extraout_var_00,uVar2) != 0
     )) {
    if ((rf_cal_slots < 2) ||
       (uVar2 = EF_Ctrl_Is_MAC_Address_Slot_Empty('\x01',reload), CONCAT31(extraout_var,uVar2) != 0)
       ) {
      if (rf_cal_slots != '\0') {
        uVar2 = EF_Ctrl_Is_MAC_Address_Slot_Empty('\0',reload);
        iVar1 = CONCAT31(extraout_var_01,uVar2);
        if (iVar1 == 0) goto LAB_230468bc;
      }
      printf("No written slot found\r\n");
      iVar1 = 1;
      goto LAB_230468d6;
    }
    iVar1 = 1;
  }
  else {
    iVar1 = 2;
  }
LAB_230468bc:
  printf("Read slot:%d\r\n",iVar1);
  BVar3 = EF_Ctrl_Read_MAC_Address_Opt((uint8_t)iVar1,mac,reload);
  iVar1 = CONCAT31(extraout_var_02,BVar3);
LAB_230468d6:
  GLB_Set_System_CLK_Div(hclkDiv,bclkDiv);
  HBN_Set_ROOT_CLK_Sel(HBN_ROOT_CLK_PLL);
  return (int8_t)-(iVar1 != 0);
}


/*
Unable to decompile 'mfg_flash_read'
Cause: Exception while decompiling 23046908: Decompiler process died

*/


int8_t mfg_flash_read_xtal_capcode(uint8_t *capcode,uint8_t reload)

{
  uint32_t uVar1;
  int8_t iVar2;
  undefined3 extraout_var;
  uint32_t uVar3;
  undefined3 in_register_0000202d;
  
  if ((((CONCAT31(in_register_0000202d,reload) == 0) ||
       (iVar2 = mfg_flash_read(), CONCAT31(extraout_var,iVar2) == 0)) &&
      (uVar1 = rf_para.crc32, rf_para.magic == 0x41)) &&
     ((uVar3 = BFLB_Soft_CRC32(&rf_para.capcode_valid,0x10), uVar1 == uVar3 &&
      (rf_para.capcode_valid == 'Z')))) {
    iVar2 = '\0';
    *capcode = rf_para.capcode;
  }
  else {
    iVar2 = -1;
  }
  return iVar2;
}



int8_t mfg_flash_read_poweroffset(int8_t *pwrOffset,uint8_t reload)

{
  int8_t iVar1;
  int8_t iVar2;
  uint32_t uVar3;
  int8_t iVar4;
  undefined3 extraout_var;
  uint32_t uVar5;
  undefined3 in_register_0000202d;
  int iVar6;
  int iVar7;
  int iVar8;
  
  if ((((CONCAT31(in_register_0000202d,reload) == 0) ||
       (iVar4 = mfg_flash_read(), CONCAT31(extraout_var,iVar4) == 0)) &&
      (uVar3 = rf_para.crc32, rf_para.magic == 0x41)) &&
     ((uVar5 = BFLB_Soft_CRC32(&rf_para.capcode_valid,0x10), uVar3 == uVar5 &&
      (rf_para.poweroffset_valid == 'Z')))) {
    memset(pwrOffset,0,0xe);
    iVar2 = rf_para.poweroffset[2];
    iVar1 = rf_para.poweroffset[1];
    iVar4 = rf_para.poweroffset[0];
    iVar8 = (int)rf_para.poweroffset[1];
    iVar6 = (int)rf_para.poweroffset[0];
    iVar7 = (int)rf_para.poweroffset[2];
    *pwrOffset = rf_para.poweroffset[0];
    pwrOffset[6] = iVar1;
    pwrOffset[0xc] = iVar2;
    iVar6 = ((iVar8 - iVar6) * 100) / 6;
    pwrOffset[2] = (char)((iVar6 + 0x19) / 0x32) + iVar4;
    pwrOffset[3] = (char)((iVar6 * 3 + 0x32) / 100) + iVar4;
    pwrOffset[4] = (char)((iVar6 * 4 + 0x32) / 100) + iVar4;
    pwrOffset[1] = (char)((iVar6 + 0x32) / 100) + iVar4;
    iVar7 = ((iVar7 - iVar8) * 100) / 6;
    pwrOffset[5] = iVar4 + (char)((iVar6 * 5 + 0x32) / 100);
    pwrOffset[8] = (char)((iVar7 + 0x19) / 0x32) + iVar1;
    pwrOffset[10] = (char)((iVar7 * 4 + 0x32) / 100) + iVar1;
    pwrOffset[7] = (char)((iVar7 + 0x32) / 100) + iVar1;
    pwrOffset[9] = (char)((iVar7 * 3 + 0x32) / 100) + iVar1;
    pwrOffset[0xb] = (char)((iVar7 * 5 + 0x32) / 100) + iVar1;
    iVar4 = '\0';
    pwrOffset[0xd] = (char)((iVar7 * 7 + 0x32) / 100) + iVar1;
  }
  else {
    iVar4 = -1;
  }
  return iVar4;
}



int8_t mfg_flash_read_macaddr(uint8_t *mac,uint8_t reload)

{
  uint32_t uVar1;
  int8_t iVar2;
  undefined3 extraout_var;
  uint32_t uVar3;
  undefined3 in_register_0000202d;
  
  if ((CONCAT31(in_register_0000202d,reload) == 0) ||
     (iVar2 = mfg_flash_read(), CONCAT31(extraout_var,iVar2) == 0)) {
    uVar1 = rf_para.crc32;
    if ((rf_para.magic == 0x41) &&
       ((uVar3 = BFLB_Soft_CRC32(&rf_para.capcode_valid,0x10), uVar1 == uVar3 &&
        (rf_para.mac_valid == 'Z')))) {
      memcpy(mac,rf_para.mac,6);
      return '\0';
    }
  }
  else {
    printf("mfg_flash_read fail\r\n");
  }
  return -1;
}



void hal_mib_dump(void)

{
  puts("---------- hal_mib_dump ----------\r\n");
  printf("machw_mib nx_rd_fifo_overflow_count is %u\r\n");
  puts("\r\n");
  return;
}



int mm_monitor_channel_req_handler
              (ke_msg_id_t msgid,mm_monitor_channel_req *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  uint16_t prim20_freq;
  undefined4 *puVar1;
  uint32_t uVar2;
  uint16_t center1_freq;
  
  puVar1 = (undefined4 *)ke_msg_alloc(0x5f,src_id,dest_id,0x28);
  center1_freq = (uint16_t)param->freq;
  *puVar1 = 1;
  puVar1[3] = 0x11111111;
  puVar1[4] = 0x22222222;
  puVar1[5] = 0x33333333;
  puVar1[6] = 0x44444444;
  puVar1[7] = 0x55555555;
  puVar1[8] = 0x66666666;
  puVar1[2] = 0;
  puVar1[9] = 0x77777777;
  uVar2 = param->freq;
  puVar1[1] = uVar2;
  prim20_freq = (uint16_t)uVar2;
  if ((param->use_40Mhz != 0) && (center1_freq = prim20_freq + 10, param->higher_band == 0)) {
    center1_freq = prim20_freq - 10;
  }
  phy_set_channel('\0',param->use_40Mhz != 0,prim20_freq,center1_freq,0,'\0');
  *puVar1 = 0;
  ke_msg_send(puVar1);
  return 0;
}



int mm_monitor_enable_req_handler
              (ke_msg_id_t msgid,mm_monitor_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  undefined4 *puVar1;
  u32_l local_50;
  phy_cfg_tag config;
  
  puVar1 = (undefined4 *)ke_msg_alloc(0x5d,src_id,dest_id,0x28);
  *puVar1 = 1;
  puVar1[3] = 0x11111111;
  puVar1[4] = 0x22222222;
  puVar1[5] = 0x33333333;
  puVar1[6] = 0x44444444;
  puVar1[7] = 0x55555555;
  puVar1[8] = 0x66666666;
  puVar1[2] = 0;
  puVar1[9] = 0x77777777;
  puVar1[1] = param->enable;
  memset(&local_50,0,0x40);
  local_50 = 0;
  phy_init((phy_cfg_tag *)&local_50);
  phy_set_channel('\0','\0',0x985,0x985,0,'\0');
  mm_active();
  *puVar1 = 0;
  ke_msg_send(puVar1);
  return 0;
}



int mm_cfg_rssi_req_handler
              (ke_msg_id_t msgid,mm_cfg_rssi_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  byte bVar1;
  uint uVar2;
  
  uVar2 = (uint)param->vif_index;
  if (vif_info_tab[uVar2].type != '\0') {
    assert_err("vif_entry->type == VIF_STA","module",0x8fe);
  }
  vif_info_tab[uVar2].u[0x1a] = param->rssi_thold;
  bVar1 = param->rssi_hyst;
  vif_info_tab[uVar2].u[0x1c] = 0;
  vif_info_tab[uVar2].u[0x1b] = bVar1;
  return 0;
}



int mm_set_ps_options_req_handler
              (ke_msg_id_t msgid,mm_set_ps_options_req *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  uint uVar1;
  
  uVar1 = (uint)param->vif_index;
  if (vif_info_tab[uVar1].type != '\0') {
    assert_err("vif_entry->type == VIF_STA","module",0x815);
  }
  *(uint16_t *)vif_info_tab[uVar1].u = param->listen_interval;
  *(_Bool *)(vif_info_tab[uVar1].u + 2) = param->dont_listen_bc_mc;
  ke_msg_send_basic(0x4c,src_id,dest_id);
  return 0;
}



int mm_tim_update_req_handler
              (ke_msg_id_t msgid,mm_tim_update_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  mm_tim_update(param);
  return 1;
}



int mm_bcn_change_req_handler
              (ke_msg_id_t msgid,mm_bcn_change_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  mm_bcn_change(param);
  return 1;
}



int mm_remain_on_channel_req_handler
              (ke_msg_id_t msgid,mm_remain_on_channel_req *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  uint8_t uVar1;
  uint8_t uVar2;
  uint8_t *puVar3;
  undefined2 in_register_00002036;
  
  uVar2 = chan_roc_req(param,src_id);
  if (CONCAT22(in_register_00002036,src_id) != 0) {
    puVar3 = (uint8_t *)ke_msg_alloc(0x47,src_id,dest_id,3);
    uVar1 = param->op_code;
    puVar3[1] = uVar2;
    *puVar3 = uVar1;
    puVar3[2] = '\x04';
    ke_msg_send();
  }
  return 0;
}



int mm_sta_del_req_handler
              (ke_msg_id_t msgid,mm_sta_del_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  mm_sta_del(param->sta_idx);
  ke_msg_send_basic(0xd,src_id,dest_id);
  return 0;
}



int mm_sta_add_req_handler
              (ke_msg_id_t msgid,mm_sta_add_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint8_t uVar1;
  uint8_t *puVar2;
  
  puVar2 = (uint8_t *)ke_msg_alloc(0xb,src_id,dest_id,3);
  uVar1 = mm_sta_add(param,puVar2 + 1,puVar2 + 2);
  *puVar2 = uVar1;
  ke_msg_send(puVar2);
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int mm_key_del_req_handler
              (ke_msg_id_t msgid,mm_key_del_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  if ((_DAT_44b000d8 >> 0x18) + 1 < (uint)param->hw_key_idx) {
    assert_err("param->hw_key_idx <= MM_SEC_MAX_KEY_NBR","module",0x56e);
  }
  mm_sec_machwkey_del(param->hw_key_idx);
  ke_msg_send_basic(0x27,src_id,dest_id);
  return 0;
}



int mm_key_add_req_handler
              (ke_msg_id_t msgid,mm_key_add_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint8_t uVar1;
  undefined *puVar2;
  
  puVar2 = (undefined *)ke_msg_alloc(0x25,src_id,dest_id,2);
  if (3 < param->key_idx) {
    assert_err("param->key_idx < MAC_DEFAULT_KEY_COUNT","module",0x53d);
  }
  if (0x20 < (param->key).length) {
    assert_err("param->key.length <= MAC_SEC_KEY_LEN","module",0x541);
  }
  if (5 < param->cipher_suite) {
    assert_err("param->cipher_suite <= MAC_RSNIE_CIPHER_AES_CMAC","module",0x544);
  }
  uVar1 = mm_sec_machwkey_wr(param);
  puVar2[1] = uVar1;
  *puVar2 = 0;
  ke_msg_send(puVar2);
  return 0;
}



int mm_set_power_req_handler
              (ke_msg_id_t msgid,mm_set_power_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint uVar1;
  uint8_t *idx;
  
  uVar1 = (uint)param->inst_nbr;
  idx = (uint8_t *)ke_msg_alloc(0x2f,src_id,dest_id,2);
  vif_info_tab[uVar1].user_tx_power = param->power;
  idx[1] = vif_info_tab[uVar1].tx_power;
  vif_info_tab[uVar1].tx_power = '\x7f';
  tpc_update_vif_tx_power(vif_info_tab + uVar1,(int8_t *)(idx + 1),idx);
  ke_msg_send(idx);
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int mm_set_idle_req_handler
              (ke_msg_id_t msgid,mm_set_idle_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  int iVar1;
  ke_state_t kVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  
  kVar2 = ke_state_get(dest_id);
  if (CONCAT31(extraout_var,kVar2) == 3) {
LAB_2304706e:
    iVar1 = 2;
  }
  else {
    mm_env.host_idle = param->hw_idle;
    if (mm_env.host_idle == '\0') {
      kVar2 = ke_state_get(dest_id);
      if (CONCAT31(extraout_var_01,kVar2) == 2) goto LAB_2304706e;
      mm_active();
    }
    else {
      kVar2 = ke_state_get(dest_id);
      if (CONCAT31(extraout_var_00,kVar2) != 0) {
        if (CONCAT31(extraout_var_00,kVar2) == 2) {
          return 2;
        }
        hal_machw_idle_req();
        ke_state_set(dest_id,2);
        return 2;
      }
      if ((_DAT_44b00038 & 0xf) != 0) {
        assert_err("blmac_current_state_getf() == HW_IDLE","module",0x47d);
      }
      mm_env._18_2_ = 0;
    }
    ke_msg_send_basic(0x23,src_id,dest_id);
    iVar1 = 0;
  }
  return iVar1;
}


/*
Unable to decompile 'mm_reset_req_handler'
Cause: Exception while decompiling 230470f6: Decompiler process died

*/


// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int mm_version_req_handler(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  undefined4 *puVar1;
  
  puVar1 = (undefined4 *)ke_msg_alloc(5,src_id,dest_id,0x18);
  *puVar1 = 0x5040000;
  puVar1[1] = _DAT_44b00004;
  puVar1[2] = _DAT_44b00008;
  phy_get_version(puVar1 + 3,puVar1 + 4);
  puVar1[5] = 0x89df;
  ke_msg_send(puVar1);
  return 0;
}



int mm_start_req_handler
              (ke_msg_id_t msgid,mm_start_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined3 extraout_var;
  
  kVar1 = ke_state_get(dest_id);
  if (CONCAT31(extraout_var,kVar1) != 0) {
    assert_err("ke_state_get(dest_id) == MM_IDLE","module",0x135);
  }
  phy_init((phy_cfg_tag *)param);
  phy_set_channel('\0','\0',0x96c,0x96c,0,'\0');
  tpc_update_tx_power('\x10');
  ps_env.uapsd_timeout = param->uapsd_timeout * 1000;
  mm_env.lp_clk_accuracy = param->lp_clk_accuracy;
  ke_msg_send_basic(3,src_id,dest_id);
  mm_active();
  hal_machw_idle_req();
  ke_state_set(dest_id,2);
  return 0;
}



// WARNING: Type propagation algorithm not settling

int mm_set_ps_mode_req_handler
              (ke_msg_id_t msgid,mm_set_ps_mode_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  vif_info_tag *vif_entry;
  
  vif_entry = (vif_info_tag *)vif_mgmt_env.used_list.first;
  if (param->new_state == '\x03') {
    while (vif_entry != (vif_info_tag *)0x0) {
      if ((vif_entry->type == '\0') && (vif_entry->active != false)) {
        ps_polling_frame(vif_entry);
      }
      vif_entry = *(vif_info_tag **)&vif_entry->list_hdr;
    }
    ke_msg_send_basic(0x32,ps_env.taskid,0);
  }
  else {
    ps_set_mode(param->new_state,src_id);
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int mm_force_idle_req_handler
              (ke_msg_id_t msgid,mm_force_idle_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  int iVar1;
  ke_state_t kVar2;
  undefined3 extraout_var;
  
  kVar2 = ke_state_get(dest_id);
  if (CONCAT31(extraout_var,kVar2) == 0) {
    if ((_DAT_44b00038 & 0xf) != 0) {
      assert_err("blmac_current_state_getf() == HW_IDLE","module",0x4c0);
    }
    ke_state_set(dest_id,3);
    iVar1 = 0;
    (*param->cb)(param->cb);
  }
  else {
    iVar1 = 2;
    if (CONCAT31(extraout_var,kVar2) != 2) {
      hal_machw_idle_req();
      ke_state_set(dest_id,2);
    }
  }
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int mm_hw_config_handler(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  char cVar1;
  byte bVar2;
  _Bool _Var3;
  uint8_t uVar4;
  uint16_t uVar5;
  uint32_t uVar6;
  uint32_t uVar7;
  int iVar8;
  ke_state_t kVar9;
  uint8_t uVar10;
  ke_msg_id_t id;
  undefined2 in_register_0000202a;
  undefined3 extraout_var;
  uint8_t *puVar11;
  uint32_t uVar12;
  uint32_t uVar13;
  uint uVar14;
  uint uVar15;
  uint uVar16;
  
  uVar16 = CONCAT22(in_register_0000202a,msgid);
  kVar9 = ke_state_get(dest_id);
  if (CONCAT31(extraout_var,kVar9) != 0) {
    if (1 < (CONCAT31(extraout_var,kVar9) - 2U & 0xffff)) {
      mm_env.prev_hw_state = (byte)_DAT_44b00038 & 0xf;
      mm_env.prev_mm_state = ke_state_get(dest_id);
      hal_machw_idle_req();
      ke_state_set(dest_id,2);
    }
    return 2;
  }
  if ((_DAT_44b00038 & 0xf) != 0) {
    assert_err("blmac_current_state_getf() == HW_IDLE","module",0x77b);
  }
  iVar8 = DAT_4201e2f0;
  if (uVar16 == 0x16) {
    (&mm_env.rx_filter_lmac_enable)[(uint)*(byte *)((int)param + 5) + 4] = *(uint32_t *)param;
    if ((iVar8 != 0) && (*(char *)(iVar8 + 4) == *(char *)((int)param + 5))) {
      _DAT_44b000dc = 0x10;
    }
    id = 0x17;
LAB_2304748e:
    ke_msg_send_basic(id,src_id,dest_id);
  }
  else {
    if (0x16 < uVar16) {
      if (uVar16 == 0x1e) {
        uVar16 = (uint)*(byte *)((int)param + 3);
        if (vif_info_tab[uVar16].type == '\0') {
          if (*(char *)((int)param + 2) == '\0') {
            mm_timer_clear(&vif_info_tab[uVar16].tbtt_timer);
          }
          else {
            uVar14 = (uint)vif_info_tab[uVar16].u[4];
            mm_timer_set(&vif_info_tab[uVar16].tbtt_timer,
                         _DAT_44b00120 + sta_info_tab[uVar14].bcn_int);
            uVar5 = *(uint16_t *)param;
            uVar12 = sta_info_tab[uVar14].bcn_int;
            *(undefined2 *)vif_info_tab[uVar16].u = 0;
            sta_info_tab[uVar14].aid = uVar5;
            uVar15 = (uint)mm_env.lp_clk_accuracy;
            vif_info_tab[uVar16].u[2] = 0;
            sta_info_tab[uVar14].drift = (uint16_t)(((uVar15 + 0x14) * uVar12) / 1000000);
            iVar8 = _DAT_44b00120;
            vif_info_tab[uVar16].u[0x18] = 0;
            *(undefined4 *)(vif_info_tab[uVar16].u + 0x14) = 0;
            *(int *)(vif_info_tab[uVar16].u + 8) = iVar8;
            vif_info_tab[uVar16].prevent_sleep = vif_info_tab[uVar16].prevent_sleep | 1;
            *(int *)(vif_info_tab[uVar16].u + 0x10) = _DAT_44b00120;
            chan_bcn_detect_start(vif_info_tab + uVar16);
          }
        }
        _Var3 = *(_Bool *)((int)param + 2);
        vif_info_tab[uVar16].active = _Var3;
        if (_Var3 != false) {
          _DAT_44b00200 = vif_info_tab[uVar16].txq_params[3];
          _DAT_44b00204 = vif_info_tab[uVar16].txq_params[3];
          _DAT_44b00208 = vif_info_tab[uVar16].txq_params[3];
          _DAT_44b0020c = vif_info_tab[uVar16].txq_params[3];
          mm_env_max_ampdu_duration_set();
        }
        id = 0x1f;
      }
      else {
        if (uVar16 < 0x1f) {
          if (uVar16 == 0x1a) {
            uVar16 = (uint)*(byte *)((int)param + 6);
            vif_info_tab[0].txq_params[uVar16 * 0x176 + (uint)*(byte *)((int)param + 5)] =
                 *(uint32_t *)param;
            if (vif_info_tab[uVar16].active != false) {
              cVar1 = *(char *)((int)param + 5);
              uVar13 = *(uint32_t *)param;
              uVar12 = _DAT_44b00200;
              uVar6 = uVar13;
              uVar7 = _DAT_44b00208;
              if (((cVar1 != '\x01') && (uVar12 = uVar13, uVar6 = _DAT_44b00204, cVar1 != '\0')) &&
                 (uVar12 = _DAT_44b00200, uVar7 = uVar13, cVar1 != '\x02')) {
                uVar7 = _DAT_44b00208;
                _DAT_44b0020c = uVar13;
              }
              _DAT_44b00208 = uVar7;
              _DAT_44b00204 = uVar6;
              _DAT_44b00200 = uVar12;
              mm_env_max_ampdu_duration_set();
            }
            if (vif_info_tab[uVar16].type == '\0') {
              ps_uapsd_set(vif_info_tab + uVar16,*(uint8_t *)((int)param + 5),
                           *(_Bool *)((int)param + 4));
            }
            id = 0x1b;
          }
          else {
            if (uVar16 == 0x1c) {
              bVar2 = *(byte *)param;
              if (((uint)bVar2 << 0xe & 0x3e0000) != 0) {
                assert_err("(((uint32_t)abgnmode << 14) & ~((uint32_t)0x0001C000)) == 0","module",
                           0x834);
              }
              _DAT_44b0004c = _DAT_44b0004c & 0xfffe3fff | (uint)bVar2 << 0xe;
              id = 0x1d;
            }
            else {
              if (uVar16 != 0x18) goto LAB_23047348;
              memcpy(&vif_info_tab[*(byte *)((int)param + 6)].bssid,param,6);
              if ((uint)vif_mgmt_env.vif_sta_cnt + (uint)vif_mgmt_env.vif_ap_cnt == 1) {
                _DAT_44b00020 = *(undefined4 *)param;
                _DAT_44b00024 = (uint)*(ushort *)((int)param + 4);
              }
              id = 0x19;
            }
          }
        }
        else {
          if (uVar16 == 0x28) {
            uVar10 = '\x05';
            if (*(char *)param != '\0') {
              uVar10 = '\0';
              _DAT_44b00054 = _DAT_44b00054 | 0x80;
            }
            puVar11 = (uint8_t *)ke_msg_alloc(0x29,src_id,dest_id,3);
            *puVar11 = *(uint8_t *)((int)param + 1);
            uVar4 = *(uint8_t *)((int)param + 2);
            puVar11[2] = uVar10;
            puVar11[1] = uVar4;
            goto LAB_230473a4;
          }
          if (uVar16 == 0x3b) {
            chan_ctxt_update((mm_chan_ctxt_update_req *)param);
            id = 0x3c;
          }
          else {
            if (uVar16 != 0x20) goto LAB_23047348;
            id = 0x21;
            _DAT_44b000e8 =
                 (uint)*(byte *)param * (_DAT_44b000e4 & 0xff) * 0x100 | (uint)*(byte *)param;
          }
        }
      }
      goto LAB_2304748e;
    }
    if (uVar16 == 0xe) {
      mm_env.rx_filter_umac = *(uint32_t *)param;
      _DAT_44b00060 = mm_env.rx_filter_umac | mm_env.rx_filter_lmac_enable;
      id = 0xf;
      goto LAB_2304748e;
    }
    if (0xe < uVar16) {
      if (uVar16 == 0x12) {
        _DAT_44b00090 = (uint)*(byte *)param | _DAT_44b00090 & 0xffffff00 | 0x80000000;
        id = 0x13;
      }
      else {
        if (uVar16 != 0x14) {
          if (uVar16 != 0x10) goto LAB_23047348;
          puVar11 = (uint8_t *)ke_msg_alloc(0x11,src_id,dest_id,2);
          if (*(uint8_t *)((int)param + 8) != '\0') {
            phy_set_channel(*(uint8_t *)param,*(uint8_t *)((int)param + 1),
                            *(uint16_t *)((int)param + 2),*(uint16_t *)((int)param + 4),
                            *(uint16_t *)((int)param + 6),*(uint8_t *)((int)param + 8));
          }
          goto LAB_230473a4;
        }
        uVar16 = (uint)*(byte *)((int)param + 2);
        if (vif_info_tab[uVar16].type == '\0') {
          sta_info_tab[vif_info_tab[uVar16].u[4]].bcn_int = (uint)*(ushort *)param << 10;
        }
        else {
          vif_mgmt_set_ap_bcn_int(vif_info_tab + uVar16,*(ushort *)param);
        }
        id = 0x15;
      }
      goto LAB_2304748e;
    }
    if (uVar16 != 6) {
      if (uVar16 != 8) {
LAB_23047348:
        assert_err("0","module",0x7ae);
        iVar8 = 2;
        goto LAB_23047494;
      }
      if (*(byte *)param < 2) {
        vif_mgmt_unregister(*(byte *)param);
      }
      if (vif_mgmt_env.used_list.first == (co_list_hdr *)0x0) {
        hal_machw_monitor_mode();
      }
      id = 9;
      goto LAB_2304748e;
    }
    puVar11 = (uint8_t *)ke_msg_alloc(7,src_id,dest_id,2);
    uVar10 = vif_mgmt_register((mac_addr_conflict38 *)((int)param + 1),*(uint8_t *)param,
                               *(_Bool *)((int)param + 7),puVar11 + 1);
    *puVar11 = uVar10;
LAB_230473a4:
    ke_msg_send(puVar11);
  }
  iVar8 = 0;
LAB_23047494:
  uVar16 = (uint)mm_env.prev_hw_state;
  if ((uVar16 << 4 & 0xffffff0f) != 0) {
    assert_err("(((uint32_t)nextstate << 4) & ~((uint32_t)0x000000F0)) == 0","module",0x5b9);
  }
  _DAT_44b00038 = uVar16 << 4;
  ke_state_set(dest_id,(ushort)mm_env.prev_mm_state);
  return iVar8;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int bl60x_edca_get(int ac,uint8_t *aifs,uint8_t *cwmin,uint8_t *cwmax,uint16_t *txop)

{
  uint uVar1;
  uint uVar2;
  
  uVar1 = _DAT_44b00200;
  uVar2 = _DAT_44b00204;
  if (ac != 1) {
    if (ac < 2) {
      if (ac == 0) {
        *txop = (uint16_t)(_DAT_44b00200 >> 0xc);
        *cwmax = (byte)(uVar1 >> 8) & 0xf;
        *cwmin = (byte)(uVar1 >> 4) & 0xf;
        *aifs = (byte)uVar1 & 0xf;
        return 0;
      }
    }
    else {
      uVar2 = _DAT_44b00208;
      if ((ac == 2) || (uVar2 = _DAT_44b0020c, ac == 3)) goto LAB_2304786c;
    }
    return -1;
  }
LAB_2304786c:
  *txop = (uint16_t)(uVar2 >> 0xc);
  *cwmax = (byte)(uVar2 >> 8) & 0xf;
  *cwmin = (byte)(uVar2 >> 4) & 0xf;
  *aifs = (byte)uVar2 & 0xf;
  return 0;
}


/*
Unable to decompile 'mm_timer_hw_set'
Cause: Exception while decompiling 2304789c: Decompiler process died

*/


_Bool cmp_abs_time(co_list_hdr *timerA,co_list_hdr *timerB)

{
  return SUB41((uint)((int)timerA[3].next - (int)timerB[3].next) >> 0x1f,0);
}



void mm_timer_init(void)

{
  co_list_init((co_list *)&mm_timer_env);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_timer_set(mm_timer_tag *timer,uint32_t value)

{
  bool bVar1;
  
  if ((int)(value - _DAT_44b00120) < 0) {
    puts("\r\n-------------------[FW] Timer is past due to flash operation. Try to fix\r\n");
    value = _DAT_44b00120 + 3000;
  }
  bVar1 = timer != (mm_timer_tag *)mm_timer_env.prog.first;
  if (bVar1) {
    co_list_extract((co_list *)&mm_timer_env,(co_list_hdr *)timer);
  }
  else {
    co_list_pop_front((co_list *)&mm_timer_env);
  }
  timer->time = value;
  co_list_insert((co_list *)&mm_timer_env,(co_list_hdr *)timer,cmp_abs_time);
  if ((!bVar1) || (timer == (mm_timer_tag *)mm_timer_env.prog.first)) {
    mm_timer_hw_set(mm_timer_env.prog.first);
  }
  if ((int)(value - _DAT_44b00120) < 0) {
    ke_evt_set(0x8000000);
    return;
  }
  return;
}



void mm_timer_clear(mm_timer_tag *timer)

{
  if (timer == (mm_timer_tag *)mm_timer_env.prog.first) {
    co_list_pop_front((co_list *)&mm_timer_env);
    mm_timer_hw_set(mm_timer_env.prog.first);
    return;
  }
  co_list_extract((co_list *)&mm_timer_env,(co_list_hdr *)timer);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_timer_schedule(int dummy)

{
  co_list_hdr *pcVar1;
  
  while( true ) {
    ke_evt_clear(0x8000000);
    pcVar1 = mm_timer_env.prog.first;
    if (mm_timer_env.prog.first == (co_list_hdr *)0x0) {
      mm_timer_hw_set(0);
      return;
    }
    if ((-1 < (int)mm_timer_env.prog.first[3].next + (-0x32 - _DAT_44b00120)) &&
       (mm_timer_hw_set(mm_timer_env.prog.first), -1 < (int)((int)pcVar1[3].next - _DAT_44b00120)))
    break;
    co_list_pop_front((co_list *)&mm_timer_env);
    if (pcVar1[1].next == (co_list_hdr *)0x0) {
      assert_err("timer->cb","module",0xde);
    }
    (*(code *)pcVar1[1].next)(pcVar1[2].next,pcVar1[1].next);
  }
  return;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ps_uapsd_timer_handle(void *env)

{
  vif_info_tag *p_vif_entry;
  _Bool _Var1;
  undefined3 extraout_var;
  int iVar2;
  
  iVar2 = 0;
  p_vif_entry = (vif_info_tag *)vif_mgmt_env.used_list.first;
  while (p_vif_entry != (vif_info_tag *)0x0) {
    if (((p_vif_entry->type == '\0') && (p_vif_entry->active != false)) &&
       (*(char *)((int)p_vif_entry->u + 0xc) != '\0')) {
      _Var1 = chan_is_on_channel(p_vif_entry);
      __Var1 = CONCAT31(extraout_var,_Var1);
      if ((__Var1 != 0) &&
         (iVar2 = __Var1,
         (int)(((ps_env.uapsd_timeout >> 1) - _DAT_44b00120) + *(int *)((int)p_vif_entry->u + 8)) <
         0)) {
        p_vif_entry->prevent_sleep = p_vif_entry->prevent_sleep | 8;
        txl_frame_send_qosnull_frame
                  (*(uint8_t *)((int)p_vif_entry->u + 4),7,(cfm_func_ptr *)0x0,(void *)0x0);
        *(int *)((int)p_vif_entry->u + 8) = _DAT_44b00120;
      }
    }
    p_vif_entry = *(vif_info_tag **)&p_vif_entry->list_hdr;
  }
  if (iVar2 != 0) {
    mm_timer_set(&ps_env.uapsd_timer,_DAT_44b00120 + ps_env.uapsd_timeout);
    return;
  }
  ps_env.uapsd_tmr_on = false;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void blmac_pwr_mgt_setf(uint8_t pwrmgt)

{
  undefined3 in_register_00002029;
  
  _DAT_44b0004c = CONCAT31(in_register_00002029,pwrmgt) << 2 | _DAT_44b0004c & 0xfffffffb;
  return;
}



// WARNING: Type propagation algorithm not settling

void ps_dpsm_update(_Bool pause)

{
  vif_info_tag *p_vif_entry;
  _Bool _Var1;
  undefined3 in_register_00002029;
  undefined3 extraout_var;
  code *UNRECOVERED_JUMPTABLE;
  
  if (CONCAT31(in_register_00002029,pause) == 0) {
    ps_env.dpsm_state = ps_env.dpsm_state | 4;
    ps_env.prevent_sleep = ps_env.prevent_sleep & 0xfffffff7;
    UNRECOVERED_JUMPTABLE = ps_enable_cfm;
  }
  else {
    ps_env.dpsm_state = ps_env.dpsm_state | 2;
    ps_env.prevent_sleep = ps_env.prevent_sleep | 8;
    UNRECOVERED_JUMPTABLE = ps_disable_cfm;
  }
  blmac_pwr_mgt_setf(pause ^ 1);
  ps_env.cfm_cnt = '\0';
  p_vif_entry = (vif_info_tag *)vif_mgmt_env.used_list.first;
  while (p_vif_entry != (vif_info_tag *)0x0) {
    if (((p_vif_entry->type == '\0') && (p_vif_entry->active != false)) &&
       (_Var1 = chan_is_on_channel(p_vif_entry), CONCAT31(extraout_var,_Var1) != 0)) {
      *(undefined *)((int)p_vif_entry->u + 3) = 0;
      ps_env.cfm_cnt = ps_env.cfm_cnt + '\x01';
      txl_frame_send_null_frame
                (*(uint8_t *)((int)p_vif_entry->u + 4),UNRECOVERED_JUMPTABLE,p_vif_entry);
    }
    p_vif_entry = *(vif_info_tag **)&p_vif_entry->list_hdr;
  }
  if (ps_env.cfm_cnt == '\0') {
                    // WARNING: Could not recover jumptable at 0x23047ba6. Too many branches
                    // WARNING: Treating indirect jump as call
    (*UNRECOVERED_JUMPTABLE)((void *)0x0,0x800000);
    return;
  }
  return;
}



uint8_t ps_send_pspoll(vif_info_tag *vif_entry)

{
  ushort uVar1;
  txl_frame_desc_tag *frame;
  tx_hw_desc *ptVar2;
  txl_buffer_tag *ptVar3;
  uint uVar4;
  char acStack40 [4];
  phy_channel_info phy_info;
  
  uVar4 = (uint)vif_entry->u[4];
  phy_get_channel((phy_channel_info *)acStack40,'\0');
  frame = txl_frame_get((uint)(acStack40[0] != '\0'),0x10);
  if (frame != (txl_frame_desc_tag *)0x0) {
    tpc_update_frame_tx_power(vif_entry,frame);
    ptVar3 = (frame->txdesc).lmac.buffer;
    *(undefined *)&ptVar3[1].length = 0xa4;
    *(undefined *)((int)&ptVar3[1].length + 1) = 0;
    uVar1 = sta_info_tab[uVar4].aid;
    *(undefined *)((int)&ptVar3[1].length + 2) = (char)uVar1;
    *(byte *)((int)&ptVar3[1].length + 3) = (byte)((uint)uVar1 >> 8) | 0xc0;
    memcpy(&ptVar3[1].lenheader,&sta_info_tab[uVar4].mac_addr,6);
    memcpy((void *)((int)&ptVar3[1].lenpad + 2),&vif_entry->mac_addr,6);
    ptVar2 = (frame->txdesc).lmac.hw_desc;
    (ptVar2->thd).macctrlinfo2 = (ptVar2->thd).macctrlinfo2 | 0x10000053;
    (frame->txdesc).host.vif_idx = sta_info_tab[uVar4].inst_nbr;
    (frame->txdesc).host.staid = sta_info_tab[uVar4].staid;
    txl_frame_push(frame,'\x03');
  }
  return (uint8_t)(frame == (txl_frame_desc_tag *)0x0);
}



void ps_init(void)

{
  memset(&ps_env,0,0x28);
  ps_env.uapsd_timer.cb = ps_uapsd_timer_handle;
  return;
}



// WARNING: Type propagation algorithm not settling

void ps_set_mode(uint8_t mode,ke_task_id_t taskid)

{
  vif_info_tag *p_vif_entry;
  _Bool _Var1;
  undefined3 in_register_00002029;
  undefined3 extraout_var;
  code *UNRECOVERED_JUMPTABLE;
  
  ps_env.taskid = taskid;
  if (((ps_env.dpsm_state & 1) == 0) || ((ps_env.dpsm_state & 6) == 0)) {
    if (CONCAT31(in_register_00002029,mode) == 0) {
      ps_env.dpsm_state = '\0';
      UNRECOVERED_JUMPTABLE = ps_disable_cfm;
      blmac_pwr_mgt_setf(mode);
    }
    else {
      if (CONCAT31(in_register_00002029,mode) == 2) {
        ps_env.dpsm_state = ps_env.dpsm_state | 1;
      }
      blmac_pwr_mgt_setf('\x01');
      UNRECOVERED_JUMPTABLE = ps_enable_cfm;
    }
    ps_env.cfm_cnt = '\0';
    ps_env.uapsd_on = false;
    p_vif_entry = (vif_info_tag *)vif_mgmt_env.used_list.first;
    while (p_vif_entry != (vif_info_tag *)0x0) {
      if (((p_vif_entry->type == '\0') && (p_vif_entry->active != false)) &&
         (_Var1 = chan_is_on_channel(p_vif_entry), CONCAT31(extraout_var,_Var1) != 0)) {
        *(undefined *)((int)p_vif_entry->u + 3) = 0;
        ps_env.cfm_cnt = ps_env.cfm_cnt + '\x01';
        if (*(char *)((int)p_vif_entry->u + 0xc) != '\0') {
          ps_env.uapsd_on = true;
        }
        txl_frame_send_null_frame
                  (*(uint8_t *)((int)p_vif_entry->u + 4),UNRECOVERED_JUMPTABLE,p_vif_entry);
      }
      p_vif_entry = *(vif_info_tag **)&p_vif_entry->list_hdr;
    }
    if (ps_env.cfm_cnt == '\0') {
                    // WARNING: Could not recover jumptable at 0x23047d74. Too many branches
                    // WARNING: Treating indirect jump as call
      (*UNRECOVERED_JUMPTABLE)((void *)0x0,0x800000);
      return;
    }
  }
  else {
    ps_env.dpsm_state = ps_env.dpsm_state | 0x10;
    ps_env.next_mode = mode;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ps_enable_cfm(void *env,uint32_t status)

{
  co_list_hdr cVar1;
  char cVar2;
  
  if (-1 < (int)(status << 8)) {
    cVar2 = *(char *)((int)env + 0x5f) + '\x01';
    *(char *)((int)env + 0x5f) = cVar2;
    if (cVar2 != '\x03') {
      txl_frame_send_null_frame(*(uint8_t *)((int)env + 0x60),ps_enable_cfm,env);
      return;
    }
    mm_send_connection_loss_ind((vif_info_tag *)env);
  }
  cVar1 = (co_list_hdr)vif_mgmt_env.used_list.first;
  if ((ps_env.cfm_cnt == '\0') || (ps_env.cfm_cnt = ps_env.cfm_cnt + -1, ps_env.cfm_cnt == '\0')) {
    if (ps_env.uapsd_on != false) {
      mm_timer_set(&ps_env.uapsd_timer,_DAT_44b00120 + ps_env.uapsd_timeout);
      ps_env.uapsd_tmr_on = true;
      while (cVar1 != (co_list_hdr)0x0) {
        if (((*(char *)((int)cVar1 + 0x56) == '\0') &&
            (*(char *)&((co_list_hdr *)((int)cVar1 + 0x58))->next != '\0')) &&
           (*(char *)&((co_list_hdr *)((int)cVar1 + 0x68))->next != '\0')) {
          ((co_list_hdr *)((int)cVar1 + 4))->next =
               (co_list_hdr *)((uint)((co_list_hdr *)((int)cVar1 + 4))->next & 0xfffffff7);
        }
        cVar1 = *(co_list_hdr *)cVar1;
      }
    }
    if ((ps_env.dpsm_state & 5) == 5) {
      ps_env.dpsm_state = ps_env.dpsm_state & 0xf3;
    }
    else {
      ps_env.ps_on = true;
      ke_msg_send_basic(0x32,ps_env.taskid,0);
    }
    if ((ps_env.dpsm_state & 0x10) != 0) {
      ps_env.dpsm_state = ps_env.dpsm_state & 0xef;
      ps_set_mode(ps_env.next_mode,ps_env.taskid);
      return;
    }
  }
  return;
}



void ps_disable_cfm(void *env,uint32_t status)

{
  char cVar1;
  
  if (-1 < (int)(status << 8)) {
    cVar1 = *(char *)((int)env + 0x5f) + '\x01';
    *(char *)((int)env + 0x5f) = cVar1;
    if (cVar1 != '\x03') {
      txl_frame_send_null_frame(*(uint8_t *)((int)env + 0x60),ps_disable_cfm,env);
      return;
    }
    mm_send_connection_loss_ind((vif_info_tag *)env);
  }
  if ((ps_env.cfm_cnt == '\0') || (ps_env.cfm_cnt = ps_env.cfm_cnt + -1, ps_env.cfm_cnt == '\0')) {
    mm_timer_clear(&ps_env.uapsd_timer);
    ps_env.uapsd_tmr_on = false;
    if ((ps_env.dpsm_state & 3) == 3) {
      ps_env.dpsm_state = ps_env.dpsm_state & 0xfd | 8;
    }
    else {
      ps_env.ps_on = false;
      ke_msg_send_basic(0x32,ps_env.taskid,0);
    }
    if ((ps_env.dpsm_state & 0x10) != 0) {
      ps_env.dpsm_state = ps_env.dpsm_state & 0xef;
      ps_set_mode(ps_env.next_mode,ps_env.taskid);
      return;
    }
  }
  return;
}



uint8_t ps_polling_frame(vif_info_tag *vif_entry)

{
  ushort uVar1;
  txl_frame_desc_tag *frame;
  tx_hw_desc *ptVar2;
  txl_buffer_tag *ptVar3;
  uint uVar4;
  char acStack40 [16];
  
  uVar4 = (uint)vif_entry->u[4];
  phy_get_channel((phy_channel_info *)acStack40,'\0');
  frame = txl_frame_get((uint)(acStack40[0] != '\0'),0x10);
  if (frame != (txl_frame_desc_tag *)0x0) {
    tpc_update_frame_tx_power(vif_entry,frame);
    ptVar3 = (frame->txdesc).lmac.buffer;
    *(undefined *)&ptVar3[1].length = 0xa4;
    *(undefined *)((int)&ptVar3[1].length + 1) = 0;
    uVar1 = sta_info_tab[uVar4].aid;
    *(undefined *)((int)&ptVar3[1].length + 2) = (char)uVar1;
    *(byte *)((int)&ptVar3[1].length + 3) = (byte)((uint)uVar1 >> 8) | 0xc0;
    memcpy(&ptVar3[1].lenheader,&sta_info_tab[uVar4].mac_addr,6);
    memcpy((void *)((int)&ptVar3[1].lenpad + 2),&vif_entry->mac_addr,6);
    ptVar2 = (frame->txdesc).lmac.hw_desc;
    (ptVar2->thd).macctrlinfo2 = (ptVar2->thd).macctrlinfo2 | 0x10000053;
    (frame->txdesc).host.vif_idx = sta_info_tab[uVar4].inst_nbr;
    (frame->txdesc).host.staid = sta_info_tab[uVar4].staid;
    txl_frame_push(frame,'\x03');
  }
  return (uint8_t)(frame == (txl_frame_desc_tag *)0x0);
}



void ps_check_beacon(int param_1,vif_info_tag *param_2)

{
  ushort uVar1;
  _Bool _Var2;
  uint8_t uVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  uint uVar4;
  uint uVar5;
  uint32_t uVar6;
  byte bVar7;
  
  _Var2 = ps_env.ps_on;
  uVar1 = sta_info_tab[param_2->u[4]].aid;
  uVar5 = param_2->prevent_sleep;
  uVar4 = uVar5 & 0xfffffffe;
  param_2->prevent_sleep = uVar4;
  if (((_Var2 == false) || ((ps_env.dpsm_state & 8) != 0)) || (param_1 == 0)) {
    return;
  }
  if (param_2->u[2] == 0) {
    if ((*(byte *)(param_1 + 4) & 1) == 0) {
      param_2->prevent_sleep = uVar5 & 0xfffffffc;
    }
    else {
      param_2->prevent_sleep = uVar4 | 2;
    }
  }
  uVar5 = (uint)(uVar1 >> 3);
  uVar4 = (uint)*(byte *)(param_1 + 4) & 0xfe;
  bVar7 = param_2->u[0xc] & 0xf;
  if (((uVar4 <= uVar5) && (uVar5 <= ((uint)*(byte *)(param_1 + 1) - 4) + uVar4)) &&
     (((uint)*(byte *)(((uVar5 + param_1) - uVar4) + 5) & 1 << ((uint)uVar1 & 7)) != 0)) {
    if (bVar7 == 0xf) {
      uVar3 = txl_frame_send_qosnull_frame(param_2->u[4],7,(cfm_func_ptr *)0x0,(void *)0x0);
      if (CONCAT31(extraout_var,uVar3) != 0) {
        return;
      }
      uVar6 = param_2->prevent_sleep | 8;
    }
    else {
      uVar3 = ps_send_pspoll(param_2);
      if (CONCAT31(extraout_var_00,uVar3) != 0) {
        return;
      }
      uVar6 = param_2->prevent_sleep | 4;
    }
    param_2->prevent_sleep = uVar6;
    return;
  }
  if (bVar7 == 0xf) {
    uVar6 = param_2->prevent_sleep & 0xfffffff7;
  }
  else {
    uVar6 = param_2->prevent_sleep & 0xfffffffb;
  }
  param_2->prevent_sleep = uVar6;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ps_check_frame(uint8_t *frame,uint32_t statinfo,vif_info_tag *vif_entry)

{
  byte bVar1;
  uint uVar2;
  uint8_t uVar3;
  undefined3 extraout_var;
  uint32_t uVar4;
  _Bool _Var5;
  
  _Var5 = ps_env.uapsd_on;
  if (ps_env.ps_on == false) {
    return;
  }
  uVar2 = (uint)*(ushort *)frame;
  if ((frame[4] & 1) != 0) {
    if (((int)(uVar2 << 0x12) < 0) && (vif_entry->u[2] == 0)) {
      return;
    }
    uVar4 = vif_entry->prevent_sleep & 0xfffffffd;
LAB_230480b4:
    vif_entry->prevent_sleep = uVar4;
    return;
  }
  if ((statinfo & 0x200) != 0) {
    return;
  }
  if (ps_env.uapsd_on != false) {
    if ((uVar2 & 0x88) == 0x88) {
      if ((uVar2 & 0x300) == 0x300) {
        bVar1 = frame[0x1e];
      }
      else {
        bVar1 = frame[0x18];
      }
      if ((vif_entry->u[0xc] >> ((uint)"\x01"[(uint)bVar1 & 7] & 0x1f) & 1) != 0) {
        *(undefined4 *)(vif_entry->u + 8) = _DAT_44b00120;
        if ((bVar1 & 0x10) == 0) {
          return;
        }
        uVar4 = vif_entry->prevent_sleep & 0xfffffff7;
        goto LAB_230480b4;
      }
    }
    else {
      if (((*(ushort *)frame & 0xc) == 0) && ((vif_entry->u[0xc] & 8) != 0)) {
        *(undefined4 *)(vif_entry->u + 8) = _DAT_44b00120;
        goto LAB_2304814e;
      }
    }
    _Var5 = false;
  }
LAB_2304814e:
  td_pck_ps_ind(vif_entry->index,true);
  if ((_Var5 == false) &&
     ((-1 < (int)(uVar2 << 0x12) ||
      (((ps_env.dpsm_state & 8) == 0 &&
       (uVar3 = ps_send_pspoll(vif_entry), CONCAT31(extraout_var,uVar3) != 0)))))) {
    vif_entry->prevent_sleep = vif_entry->prevent_sleep & 0xfffffffb;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ps_check_tx_frame(uint8_t staid,uint8_t tid)

{
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  uint uVar1;
  
  if ((((ps_env.ps_on != false) && (CONCAT31(in_register_00002029,staid) != 0xff)) &&
      (CONCAT31(in_register_0000202d,tid) != 0xff)) &&
     ((uVar1 = (uint)sta_info_tab[CONCAT31(in_register_00002029,staid)].inst_nbr,
      vif_info_tab[uVar1].type == '\0' && (vif_info_tab[uVar1].active != false)))) {
    if ((vif_info_tab[uVar1].u[0xc] >> ((uint)"\x01"[CONCAT31(in_register_0000202d,tid)] & 0x1f) & 1
        ) != 0) {
      vif_info_tab[uVar1].prevent_sleep = vif_info_tab[uVar1].prevent_sleep | 8;
      *(undefined4 *)(vif_info_tab[uVar1].u + 8) = _DAT_44b00120;
      return;
    }
    td_pck_ps_ind(vif_info_tab[uVar1].index,false);
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ps_uapsd_set(vif_info_tag *vif_entry,uint8_t hw_queue,_Bool uapsd)

{
  byte bVar1;
  undefined3 in_register_00002031;
  
  bVar1 = (byte)(1 << ((uint)hw_queue & 0x1f));
  if (CONCAT31(in_register_00002031,uapsd) == 0) {
    vif_entry->u[0xc] = vif_entry->u[0xc] & ~bVar1;
  }
  else {
    vif_entry->u[0xc] = vif_entry->u[0xc] | bVar1;
    if ((ps_env.ps_on != false) && (ps_env.uapsd_tmr_on == false)) {
      ps_env.uapsd_on = true;
      mm_timer_set(&ps_env.uapsd_timer,_DAT_44b00120 + ps_env.uapsd_timeout);
      ps_env.uapsd_tmr_on = true;
    }
  }
  return;
}



void ps_traffic_status_update(uint8_t vif_index,uint8_t new_status)

{
  _Bool pause;
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  char cVar1;
  co_list_hdr cVar2;
  
  if (((ps_env.ps_on != false) && ((ps_env.dpsm_state & 1) != 0)) && ((ps_env.dpsm_state & 6) == 0))
  {
    cVar2 = (co_list_hdr)vif_mgmt_env.used_list.first;
    if (CONCAT31(in_register_0000202d,new_status) == 0) {
      while (cVar2 != (co_list_hdr)0x0) {
        if ((((uint)*(byte *)((int)cVar2 + 0x57) != CONCAT31(in_register_00002029,vif_index)) &&
            (cVar1 = *(char *)&((co_list_hdr *)((int)cVar2 + 0x58))->next, cVar1 != '\0')) &&
           ((*(char *)((int)cVar2 + 0x56) == '\0' &&
            ((td_env[(uint)*(byte *)((int)cVar2 + 0x57)].status & 0xc) != 0)))) goto LAB_230482ae;
        cVar2 = *(co_list_hdr *)cVar2;
      }
      cVar1 = '\0';
LAB_230482ae:
      if (cVar1 == '\0') {
        if ((ps_env.dpsm_state & 8) == 0) {
          return;
        }
        pause = false;
        goto LAB_230482b6;
      }
    }
    pause = true;
    if ((ps_env.dpsm_state & 8) == 0) {
LAB_230482b6:
      ps_dpsm_update(pause);
      return;
    }
  }
  return;
}



void mm_ps_change_ind(uint8_t sta_idx,uint8_t ps_state)

{
  undefined3 in_register_00002029;
  uint8_t *puVar1;
  
  puVar1 = (uint8_t *)ke_msg_alloc(0x49,0xd,0,2);
  sta_info_tab[CONCAT31(in_register_00002029,sta_idx)].ps_state = ps_state;
  *puVar1 = sta_idx;
  puVar1[1] = ps_state;
  ke_msg_send();
  return;
}



void rxl_mpdu_transfer(rx_swdesc *swdesc)

{
  rx_pbd *prVar1;
  rx_pbd *prVar2;
  rx_pbd *prVar3;
  rx_dmadesc *prVar4;
  
  prVar4 = swdesc->dma_hdrdesc;
  prVar1 = (rx_pbd *)(prVar4->hd).first_pbd_ptr;
  phy_get_channel(&prVar4->phy_info,'\0');
  prVar4->payl_offset = mac_payload_offset;
  swdesc->pbd_count = '\0';
  prVar3 = (rx_pbd *)0x0;
  do {
    prVar2 = prVar1;
    if ((prVar2->bufstatinfo & 1) != 0) {
      swdesc->spare_pbd = prVar2;
      swdesc->last_pbd = prVar3;
      return;
    }
    prVar1 = (rx_pbd *)prVar2->next;
    swdesc->pbd_count = swdesc->pbd_count + '\x01';
    prVar3 = prVar2;
  } while (prVar1 != (rx_pbd *)0x0);
  assert_rec("pd != NULL","module",0xb4);
  return;
}



void rxl_init(void)

{
  rxl_hwdesc_init(1);
  rx_swdesc_init();
  co_list_init((co_list *)&rxl_cntrl_env);
  rxu_cntrl_init();
  return;
}



void rxl_cntrl_dump(void)

{
  uint32_t uVar1;
  co_list_hdr cVar2;
  
  uVar1 = co_list_cnt((co_list *)&rxl_cntrl_env);
  cVar2 = (co_list_hdr)rxl_cntrl_env.ready.first;
  if (uVar1 != 0) {
    while (cVar2 != (co_list_hdr)0x0) {
      cVar2 = *(co_list_hdr *)cVar2;
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rxl_timer_int_handler(void)

{
  rx_hd *prVar1;
  rx_dmadesc *desc;
  char *condition;
  rx_swdesc *list_hdr;
  int line;
  uint32_t uVar2;
  
  _DAT_44b0807c = 0xa0000;
  do {
    while( true ) {
      if ((rxl_cntrl_env.first == (rx_dmadesc *)0x0) ||
         (-1 < (int)(((rxl_cntrl_env.first)->hd).statinfo << 0x11))) {
        if (rxl_cntrl_env.ready.first != (co_list_hdr *)0x0) {
          ke_evt_set(0x40000);
          return;
        }
        return;
      }
      list_hdr = ((rxl_cntrl_env.first)->hd).swdesc;
      prVar1 = &(rxl_cntrl_env.first)->hd;
      desc = list_hdr->dma_hdrdesc;
      rxl_cntrl_env.first = (rx_dmadesc *)((rxl_cntrl_env.first)->hd).next;
      list_hdr->pd = (rx_payloaddesc *)prVar1->first_pbd_ptr;
      uVar2 = (desc->hd).first_pbd_ptr;
      if ((desc->hd).frmlen == 0) break;
      if (uVar2 == 0) {
        line = 0xd8;
        condition = "pd != NULL";
LAB_2304844e:
        assert_rec(condition,"module",line);
      }
      else {
        co_list_push_back((co_list *)&rxl_cntrl_env,(co_list_hdr *)list_hdr);
      }
    }
    if (uVar2 != 0) {
      line = 0xfa;
      condition = "dma_hdrdesc->hd.first_pbd_ptr == 0";
      goto LAB_2304844e;
    }
    list_hdr->spare_pbd = (rx_pbd *)0x0;
    list_hdr->last_pbd = (rx_pbd *)0x0;
    rxl_hd_append(desc);
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rxl_timeout_int_handler(void)

{
  _DAT_44b0808c = _DAT_44b0808c & 0xffffffbf;
  return;
}



void rxl_dma_int_handler(void)

{
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rxl_dma_evt(int dummy)

{
  ke_evt_clear(0x100000);
  _DAT_44a00020 = 0x20;
  return;
}



void rxl_frame_release(rx_swdesc *swdesc)

{
  rxl_pd_append((rx_pbd *)(swdesc->dma_hdrdesc->hd).first_pbd_ptr,swdesc->last_pbd,swdesc->spare_pbd
               );
  rxl_hd_append(swdesc->dma_hdrdesc);
  return;
}



void rxl_mpdu_free(rx_swdesc *swdesc)

{
  ushort uVar1;
  rx_pbd *prVar2;
  rx_pbd *prVar3;
  rx_pbd *prVar4;
  
  prVar2 = (rx_pbd *)(swdesc->dma_hdrdesc->hd).first_pbd_ptr;
  vTaskEnterCritical();
  swdesc->use_in_tcpip = '\0';
  swdesc->dma_hdrdesc->use_in_tcpip = 0;
  prVar4 = (rx_pbd *)0x0;
  do {
    prVar3 = prVar2;
    uVar1 = prVar3->bufstatinfo;
    prVar3[1].upattern = 0;
    if ((uVar1 & 1) != 0) {
      swdesc->spare_pbd = prVar3;
      swdesc->last_pbd = prVar4;
      rxl_frame_release(swdesc);
      vTaskExitCritical();
      return;
    }
    prVar2 = (rx_pbd *)prVar3->next;
    prVar4 = prVar3;
  } while ((rx_pbd *)prVar3->next != (rx_pbd *)0x0);
  assert_rec("pd != NULL","module",0x397);
  return;
}


/*
Unable to decompile 'rxl_cntrl_evt'
Cause: Exception while decompiling 23048552: Decompiler process died

*/


void bl60x_firmwre_mpdu_free(void *swdesc_ptr)

{
  rx_swdesc *swdesc;
  
  vTaskEnterCritical();
  rxl_cntrl_env.packet_stack_cnt =
       rxl_cntrl_env.packet_stack_cnt - *(byte *)((int)swdesc_ptr + 0x1d);
  vTaskExitCritical();
  rxl_mpdu_free((rx_swdesc *)swdesc_ptr);
  return;
}



void rxl_reset(void)

{
  rxl_hwdesc_init(0);
  co_list_init((co_list *)&rxl_cntrl_env);
  co_list_init((co_list *)&swdesc);
  return;
}



void rxl_hwdesc_dump(void)

{
  rx_dmadesc *prVar1;
  rx_payloaddesc *prVar2;
  int iVar3;
  int iVar4;
  uint32_t uVar5;
  
  puts("---------- rxl_hwdesc_dump -------\r\n");
  printf("rx_dma_hdrdesc: %d\r\n",0xd);
  iVar3 = 0;
  prVar1 = rx_dma_hdrdesc;
  do {
    printf("  [%2d]@%08lx: upatternrx %08lx next %08lx first_pbd_ptr %08lx, swdesc %p\r\n",iVar3,
           prVar1,(prVar1->hd).upatternrx,(prVar1->hd).next,(prVar1->hd).first_pbd_ptr,
           (prVar1->hd).swdesc);
    iVar3 = iVar3 + 1;
    printf(
           "    datastartptr %08lx dataendptr %08lx, headerctrlinfo %08lx frmlen %4u ampdu_stat_info %04x\r\n"
           ,(prVar1->hd).datastartptr,(prVar1->hd).dataendptr,(prVar1->hd).headerctrlinfo,
           (uint)(prVar1->hd).frmlen,(uint)(prVar1->hd).ampdu_stat_info);
    printf(
           "    tsflo %08lx tsfhi %08lx recvec1b %08lx recvec1c %08lx recvec1d %08lx recvec2a %08lx recvec2b %08lx statinfo %08lx\r\n"
           ,(prVar1->hd).tsflo,(prVar1->hd).tsfhi,(prVar1->hd).recvec1b,(prVar1->hd).recvec1c,
           (prVar1->hd).recvec1d,(prVar1->hd).recvec2a,(prVar1->hd).recvec2b);
    prVar1 = prVar1 + 1;
  } while (iVar3 != 0xd);
  printf("rx_payload_desc: %d\r\n",0xd);
  iVar3 = 0;
  prVar2 = rx_payload_desc;
  do {
    uVar5 = (prVar2->pbd).dataendptr;
    iVar4 = 0;
    if (uVar5 != 0) {
      iVar4 = (uVar5 + 1) - (prVar2->pbd).datastartptr;
    }
    iVar3 = iVar3 + 1;
    printf(
           "  [%2d]@%08lx %3lu Bytes: upatternrx %08lx next %08lx datastartptr %08lx dataendptr %08lx bufstatinfo %04x reserved %04X\r\n"
           ,prVar2,iVar4,(prVar2->pbd).upattern,(prVar2->pbd).next);
    prVar2 = prVar2 + 1;
  } while (iVar3 != 0xd);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rxl_hwdesc_init(int init)

{
  rx_dmadesc *prVar1;
  rx_dmadesc *prVar2;
  txl_buffer_control *ptVar3;
  txl_buffer_control *ptVar4;
  txl_buffer_control *ptVar5;
  int iVar6;
  uint32_t *puVar7;
  int iVar8;
  txl_buffer_control *ptVar9;
  rx_dmadesc *prVar10;
  rx_dmadesc *prVar11;
  rx_dmadesc *prVar12;
  rx_dmadesc *prVar13;
  txl_buffer_control *ptVar14;
  txl_buffer_control *ptVar15;
  
  vTaskEnterCritical();
  prVar13 = (rx_dmadesc *)0x0;
  iVar6 = 0;
  iVar8 = 0;
  prVar1 = (rx_dmadesc *)0x0;
  prVar10 = rx_dma_hdrdesc;
  prVar11 = (rx_dmadesc *)0x0;
  do {
    prVar2 = prVar10;
    prVar10 = prVar2 + 1;
    prVar12 = prVar11;
    if ((init == 0) && (prVar2->use_in_tcpip == 1)) {
      prVar2 = prVar1;
      if (prVar1 != (rx_dmadesc *)0x0) {
        (prVar1->hd).next = 0;
      }
    }
    else {
      if (prVar1 != (rx_dmadesc *)0x0) {
        *(rx_dmadesc **)&(prVar1->hd).next = prVar2;
      }
      (prVar2->hd).datastartptr = 0;
      (prVar2->hd).dataendptr = 0;
      (prVar2->hd).upatternrx = 0xbaadf00d;
      (prVar2->hd).statinfo = 0;
      (prVar2->hd).headerctrlinfo = 0;
      *(rx_dmadesc **)&(prVar2->hd).next = prVar10;
      (prVar2->hd).first_pbd_ptr = 0;
      (prVar2->hd).swdesc = rx_swdesc_tab + iVar8;
      (prVar2->hd).frmlen = 0;
      prVar12 = prVar2;
      if ((iVar6 != 0) && (prVar12 = prVar11, iVar6 == 1)) {
        prVar13 = prVar2;
      }
      iVar6 = iVar6 + 1;
    }
    iVar8 = iVar8 + 1;
    prVar1 = prVar2;
    prVar11 = prVar12;
  } while (iVar8 != 0xd);
  if (iVar6 < 4) {
    printf("No enough DESC %d(%d)\r\n",0xd);
  }
  if (prVar2 != (rx_dmadesc *)0x0) {
    (prVar2->hd).next = 0;
  }
  _DAT_44b08180 = 0x4000000;
  puVar7 = rx_payload_desc_buffer;
  ptVar9 = (txl_buffer_control *)0x0;
  iVar6 = 0;
  ptVar3 = (txl_buffer_control *)0x0;
  ptVar5 = (txl_buffer_control *)rx_payload_desc;
  ptVar14 = (txl_buffer_control *)0x0;
  _DAT_44b081b8 = prVar13;
  do {
    ptVar4 = ptVar5;
    ptVar5 = (txl_buffer_control *)&ptVar4->mac_control_info;
    ptVar15 = ptVar14;
    if ((init == 0) && (*(int *)(ptVar4->field_0 + 0x14) == 1)) {
      ptVar4 = ptVar3;
      if (ptVar3 != (txl_buffer_control *)0x0) {
        *(undefined4 *)ptVar3->field_0 = 0;
      }
    }
    else {
      if (ptVar3 != (txl_buffer_control *)0x0) {
        *(txl_buffer_control **)ptVar3->field_0 = ptVar4;
      }
      *(txl_buffer_control **)ptVar4->field_0 = ptVar5;
      *(undefined4 *)ptVar4->field_0 = 0xc0dedbad;
      *(undefined2 *)ptVar4->field_0 = 0;
      *(uint32_t **)ptVar4->field_0 = puVar7;
      *(int *)ptVar4->field_0 = (int)puVar7 + 0x34f;
      *(uint32_t **)(ptVar4->field_0 + 0x18) = puVar7;
      ptVar15 = ptVar4;
      if ((iVar6 != 0) && (ptVar15 = ptVar14, iVar6 == 1)) {
        ptVar9 = ptVar4;
      }
      iVar6 = iVar6 + 1;
    }
    puVar7 = puVar7 + 0xd4;
    ptVar3 = ptVar4;
    ptVar14 = ptVar15;
  } while (ptVar5 != txl_buffer_control_desc_bcmc);
  if (iVar6 < 4) {
    printf("No enough PBD DESC, %d(%d)\r\n",0xd);
  }
  *(undefined4 *)ptVar4->field_0 = 0;
  _DAT_44b08180 = 0x8000000;
  _DAT_44b081bc = ptVar9;
  if ((((prVar12 == (rx_dmadesc *)0x0) || (prVar13 == (rx_dmadesc *)0x0)) ||
      (prVar2 == (rx_dmadesc *)0x0)) ||
     ((ptVar15 == (txl_buffer_control *)0x0 || (ptVar9 == (txl_buffer_control *)0x0)))) {
    printf("%p:%p%p vs %p:%p:%p\r\n",prVar12,prVar13,prVar2,ptVar15,ptVar4);
  }
  rxl_cntrl_env.first = prVar13;
  rxl_cntrl_env.last = prVar2;
  rxl_cntrl_env.free = prVar12;
  rx_hwdesc_env.last = (rx_pbd *)ptVar4;
  rx_hwdesc_env.free = (rx_pbd *)ptVar15;
  vTaskExitCritical();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rxl_hd_append(rx_dmadesc *desc)

{
  rx_dmadesc *prVar1;
  
  if (desc == (rx_dmadesc *)0x0) {
    assert_err("desc != NULL","module",0xf9);
  }
  prVar1 = desc;
  if (rxl_cntrl_env.free != _DAT_44b08548) {
    prVar1 = rxl_cntrl_env.free;
    rxl_cntrl_env.free = desc;
  }
  (prVar1->hd).next = 0;
  (prVar1->hd).first_pbd_ptr = 0;
  (prVar1->hd).statinfo = 0;
  (prVar1->hd).frmlen = 0;
  *(rx_dmadesc **)&((rxl_cntrl_env.last)->hd).next = prVar1;
  if (rxl_cntrl_env.first == (rx_dmadesc *)0x0) {
    rxl_cntrl_env.first = prVar1;
  }
  rxl_cntrl_env.last = prVar1;
  _DAT_44b08180 = 0x1000000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rxl_pd_append(rx_pbd *first,rx_pbd *last,rx_pbd *spare)

{
  rx_pbd **pprVar1;
  rx_pbd *prVar2;
  rx_pbd *prVar3;
  rx_pbd *prVar4;
  
  if (spare == (rx_pbd *)0x0) {
    assert_err("spare != NULL","module",0x128);
  }
  prVar4 = rx_hwdesc_env.free;
  if (rx_hwdesc_env.free == _DAT_44b0854c) {
    prVar4 = first;
    if (last == (rx_pbd *)0x0) {
      prVar4 = spare;
    }
    spare->bufstatinfo = 0;
  }
  else {
    prVar2 = rx_hwdesc_env.free;
    prVar3 = spare;
    if (last != (rx_pbd *)0x0) {
      pprVar1 = (rx_pbd **)&(rx_hwdesc_env.free)->next;
      rx_hwdesc_env.free = spare;
      *pprVar1 = first;
      prVar2 = last;
      prVar3 = rx_hwdesc_env.free;
    }
    rx_hwdesc_env.free = prVar3;
    spare = prVar2;
    prVar4->bufstatinfo = 0;
  }
  spare->next = 0;
  *(rx_pbd **)&(rx_hwdesc_env.last)->next = prVar4;
  rx_hwdesc_env.last = spare;
  _DAT_44b08180 = 0x2000000;
  return;
}



void sta_mgmt_entry_init(sta_info_tag *sta_entry)

{
  txdesc *txdesc;
  uint16_t *puVar1;
  
  while ((sta_entry->tx_desc_post).first != (co_list_hdr *)0x0) {
    txdesc = (txdesc *)co_list_pop_front(&sta_entry->tx_desc_post);
    txl_frame_release(txdesc,true);
  }
  memset(sta_entry,0,0x1b0);
  puVar1 = (uint16_t *)&sta_entry->ba_info[0].bam_idx_rx;
  do {
    *(uint8_t *)puVar1 = '\x02';
    *(uint8_t *)((int)puVar1 + 1) = '\x02';
    puVar1 = puVar1 + 6;
  } while (puVar1 != sta_entry->rx_qos_last_seqcntl + 3);
  sta_entry->inst_nbr = -1;
  return;
}



void sta_mgmt_init(void)

{
  sta_info_tag *sta_entry;
  sta_info_tag *psVar1;
  
  co_list_init((co_list *)&sta_info_env);
  sta_entry = sta_info_tab;
  do {
    sta_mgmt_entry_init(sta_entry);
    psVar1 = sta_entry + 1;
    co_list_push_back((co_list *)&sta_info_env,(co_list_hdr *)sta_entry);
    sta_entry = psVar1;
  } while (psVar1 != sta_info_tab + 10);
  sta_mgmt_entry_init(sta_info_tab + 10);
  sta_info_tab[10].pol_tbl.buf_ctrl = txl_buffer_control_desc_bcmc;
  sta_info_tab[10].sta_sec_info.cur_key = &vif_info_tab[0].default_key;
  sta_info_tab[10].inst_nbr = '\0';
  sta_info_tab[10].ctrl_port_state = '\0';
  printf("------ set default key %p, key ptr %p\r\n",0x4201c2b8,vif_info_tab[0].default_key);
  sta_mgmt_entry_init(sta_info_tab + 0xb);
  sta_info_tab[11].inst_nbr = '\x01';
  sta_info_tab[11].pol_tbl.buf_ctrl = txl_buffer_control_desc_bcmc + 1;
  sta_info_tab[11].ctrl_port_state = '\0';
  sta_info_tab[11].sta_sec_info.cur_key = &vif_info_tab[1].default_key;
  printf("------ set default key %p, key ptr %p\r\n",vif_info_tab[1].default_key);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t sta_mgmt_register(mm_sta_add_req *param,uint8_t *sta_idx)

{
  uint8_t uVar1;
  co_list_hdr *list_hdr;
  char *fmt;
  undefined4 uVar2;
  key_info_tag *pkVar3;
  co_list_hdr *pcVar4;
  byte bVar5;
  co_list_hdr *pcVar6;
  co_list_hdr *pcVar7;
  uint uVar8;
  
  uVar8 = (uint)param->inst_nbr;
  list_hdr = co_list_pop_front((co_list *)&sta_info_env);
  if (list_hdr == (co_list_hdr *)0x0) {
    uVar1 = '\x01';
  }
  else {
    memcpy((void *)((int)&list_hdr[7].next + 2),&param->mac_addr,6);
    bVar5 = param->ampdu_spacing_min;
    if (bVar5 < 0x10) {
      bVar5 = 0x10;
    }
    *(byte *)&list_hdr[5].next = bVar5;
    *(uint16_t *)&list_hdr[3].next = param->ampdu_size_max_ht;
    list_hdr[2].next = (co_list_hdr *)param->ampdu_size_max_vht;
    list_hdr[4].next = (co_list_hdr *)param->paid_gid;
    *(uint8_t *)((int)&list_hdr[6].next + 2) = param->inst_nbr;
    *(int8_t *)&list_hdr[9].next = param->rssi;
    list_hdr[10].next = (co_list_hdr *)param->tsflo;
    list_hdr[0xb].next = (co_list_hdr *)param->tsfhi;
    *(uint8_t *)&list_hdr[0xc].next = param->data_rate;
    uVar1 = (char)((int)(list_hdr + -0x10806a02) >> 4) * '\x13';
    *sta_idx = uVar1;
    *(uint8_t *)((int)&list_hdr[6].next + 3) = uVar1;
    list_hdr[1].next = (co_list_hdr *)0x19000;
    *(undefined2 *)&list_hdr[0x62].next = 0xffff;
    pcVar6 = (co_list_hdr *)((int)&list_hdr[0x62].next + 2);
    do {
      *(undefined2 *)&pcVar6->next = 0xffff;
      pcVar6 = (co_list_hdr *)((int)&pcVar6->next + 2);
    } while (pcVar6 != list_hdr + 0x67);
    bVar5 = *sta_idx;
    *(undefined *)((int)&list_hdr[0xc].next + 1) = 0;
    *(txl_buffer_control **)&list_hdr[0x43].next = txl_buffer_control_desc + bVar5;
    if ((vif_info_tab[uVar8].flags & 8) == 0) {
      list_hdr[0x2b].next = (co_list_hdr *)(uVar8 * 0x5d8 + 0x4201c2b8);
      pkVar3 = vif_info_tab[uVar8].default_key;
      uVar2 = 0x10d;
      fmt = "------ %d set default key %p, ptr %p\r\n";
    }
    else {
      pkVar3 = (key_info_tag *)list_hdr[0x2a].next;
      list_hdr[0x2b].next = list_hdr + 0x2a;
      uVar2 = 0x102;
      fmt = "------ %d set default key %p, key ptr %p\r\n";
    }
    printf(fmt,uVar2,pkVar3);
    pcVar6 = _DAT_44b00120;
    pcVar7 = list_hdr + 0x47;
    pcVar4 = _DAT_44b00120 + -250000;
    do {
      pcVar7->next = pcVar6;
      pcVar7[1].next = pcVar4;
      pcVar7 = pcVar7 + 3;
    } while (pcVar7 != list_hdr + 0x62);
    co_list_push_back(&vif_info_tab[uVar8].sta_list,list_hdr);
    *(undefined *)((int)&list_hdr[7].next + 1) = 1;
    uVar1 = '\0';
  }
  return uVar1;
}



void sta_mgmt_unregister(uint8_t sta_idx)

{
  sta_info_tag *sta_entry;
  undefined3 in_register_00002029;
  
  sta_entry = sta_info_tab + CONCAT31(in_register_00002029,sta_idx);
  co_list_extract(&vif_info_tab[sta_info_tab[CONCAT31(in_register_00002029,sta_idx)].inst_nbr].
                   sta_list,(co_list_hdr *)sta_entry);
  sta_mgmt_entry_init(sta_entry);
  co_list_push_back((co_list *)&sta_info_env,(co_list_hdr *)sta_entry);
  return;
}



void sta_mgmt_add_key(mm_key_add_req *param,uint8_t hw_key_idx)

{
  uint8_t uVar1;
  uint uVar2;
  
  uVar2 = (uint)param->sta_idx;
  sta_info_tab[uVar2].sta_sec_info.key_info.hw_key_idx = hw_key_idx;
  sta_info_tab[uVar2].sta_sec_info.key_info.cipher = param->cipher_suite;
  sta_info_tab[uVar2].sta_sec_info.key_info.key_idx = param->key_idx;
  memset(&sta_info_tab[uVar2].sta_sec_info,0,0x48);
  uVar1 = sta_info_tab[uVar2].sta_sec_info.key_info.cipher;
  if (uVar1 == '\x01') {
    *(undefined4 *)&sta_info_tab[uVar2].sta_sec_info.key_info.tx_pn = 0;
    *(undefined4 *)((int)&sta_info_tab[uVar2].sta_sec_info.key_info.tx_pn + 4) = 0;
    *(uint32_t *)sta_info_tab[uVar2].sta_sec_info.key_info.u = (param->key).array[4];
    *(uint32_t *)(sta_info_tab[uVar2].sta_sec_info.key_info.u + 4) = (param->key).array[5];
    *(uint32_t *)(sta_info_tab[uVar2].sta_sec_info.key_info.u + 8) = (param->key).array[6];
    *(uint32_t *)(sta_info_tab[uVar2].sta_sec_info.key_info.u + 0xc) = (param->key).array[7];
  }
  else {
    if ((uVar1 == '\0') || (uVar1 == '\x03')) {
      next = next * 0x41c64e6d + 0x3039;
      *(ulong *)&sta_info_tab[uVar2].sta_sec_info.key_info.tx_pn = next >> 0x10;
      *(undefined4 *)((int)&sta_info_tab[uVar2].sta_sec_info.key_info.tx_pn + 4) = 0;
    }
    else {
      *(undefined4 *)&sta_info_tab[uVar2].sta_sec_info.key_info.tx_pn = 0;
      *(undefined4 *)((int)&sta_info_tab[uVar2].sta_sec_info.key_info.tx_pn + 4) = 0;
    }
  }
  sta_info_tab[uVar2].sta_sec_info.key_info.valid = true;
  *(sta_mgmt_sec_info **)&sta_info_tab[uVar2].sta_sec_info.pairwise_key =
       &sta_info_tab[uVar2].sta_sec_info;
  return;
}



void sta_mgmt_del_key(sta_info_tag *sta)

{
  (sta->sta_sec_info).key_info.valid = false;
  (sta->sta_sec_info).pairwise_key = (key_info_tag *)0x0;
  sta->ctrl_port_state = '\x01';
  return;
}



int sta_mgmt_send_postponed_frame(vif_info_tag *p_vif_entry,sta_info_tag *p_sta_entry,int limit)

{
  uint8_t access_category;
  int iVar1;
  _Bool _Var2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  txdesc *txdesc;
  int iStack36;
  int stop;
  
  iVar1 = 0;
  while( true ) {
    txdesc = (txdesc *)(p_sta_entry->tx_desc_post).first;
    if (txdesc == (txdesc *)0x0) {
      return iVar1;
    }
    iStack36 = 0;
    _Var2 = txl_cntrl_tx_check(p_vif_entry);
    if (CONCAT31(extraout_var,_Var2) == 0) {
      return iVar1;
    }
    _Var2 = apm_tx_int_ps_check(txdesc);
    if (CONCAT31(extraout_var_00,_Var2) == 0) {
      return iVar1;
    }
    txdesc = apm_tx_int_ps_get_postpone(p_vif_entry,p_sta_entry,&iStack36);
    if (iStack36 != 0) break;
    if (txdesc == (txdesc *)0x0) {
      txdesc = (txdesc *)co_list_pop_front(&p_sta_entry->tx_desc_post);
    }
    access_category = (txdesc->host).tid;
    *(undefined *)((int)&txdesc[1].host.packet_addr + 1) = 0;
    iVar1 = iVar1 + 1;
    txl_cntrl_push_int(txdesc,access_category);
    if ((limit != 0) && (iVar1 == limit)) {
      return iVar1;
    }
  }
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void td_timer_end(void *env)

{
  int iVar1;
  bool bVar2;
  undefined *puVar3;
  undefined *puVar4;
  
  iVar1 = _DAT_44b00120;
  if (*(char *)((int)env + 0x23) != '\0') {
    bVar2 = *(int *)((int)env + 0x10) != 0;
    if (*(int *)((int)env + 0x14) != 0) {
      bVar2 = (bool)(bVar2 | 2);
    }
    if (*(int *)((int)env + 0x18) != 0) {
      bVar2 = (bool)(bVar2 | 4);
    }
    if (*(int *)((int)env + 0x1c) != 0) {
      bVar2 = (bool)(bVar2 | 8);
    }
    if (((*(byte *)((int)env + 0x21) ^ bVar2) & 0xc) != 0) {
      if ((bVar2 & 4U) == 0) {
        puVar3 = &UNK_2307ba2c;
      }
      else {
        puVar3 = &UNK_2307ba28;
      }
      if ((bVar2 & 8U) == 0) {
        puVar4 = &UNK_2307ba2c;
      }
      else {
        puVar4 = &UNK_2307ba30;
      }
      printf(&DAT_2307ba34,puVar3,puVar4);
      ps_traffic_status_update(*(uint8_t *)((int)env + 0x20),bVar2 & 0xc);
    }
    *(bool *)((int)env + 0x21) = bVar2;
  }
  *(undefined4 *)((int)env + 0x10) = 0;
  *(undefined4 *)((int)env + 0x14) = 0;
  *(undefined4 *)((int)env + 0x18) = 0;
  *(undefined4 *)((int)env + 0x1c) = 0;
  *(bool *)((int)env + 0x23) = vif_info_tab[*(byte *)((int)env + 0x20)].chan_ctxt == DAT_4201e2f0;
  mm_timer_set((mm_timer_tag *)env,iVar1 + 1000000);
  return;
}



void td_reset(uint8_t vif_index)

{
  td_env_tag *__s;
  undefined3 in_register_00002029;
  int iVar1;
  
  iVar1 = CONCAT31(in_register_00002029,vif_index);
  __s = td_env + iVar1;
  printf(&DAT_2307ba00,iVar1);
  if (td_env[iVar1].is_on != false) {
    mm_timer_clear((mm_timer_tag *)__s);
  }
  memset(__s,0,0x24);
  td_env[iVar1].td_timer.cb = td_timer_end;
  *(td_env_tag **)&td_env[iVar1].td_timer.env = __s;
  td_env[iVar1].vif_index = vif_index;
  return;
}



void td_init(void)

{
  printf(&DAT_2307b9f4);
  td_reset('\0');
  td_reset('\x01');
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void td_start(uint8_t vif_index)

{
  int iVar1;
  undefined3 in_register_00002029;
  int iVar2;
  
  iVar1 = _DAT_44b00120;
  iVar2 = CONCAT31(in_register_00002029,vif_index);
  if (td_env[iVar2].is_on == false) {
    printf(&DAT_2307ba14,iVar2);
    td_env[iVar2].is_on = true;
    mm_timer_set((mm_timer_tag *)(td_env + iVar2),iVar1 + 1000000);
    return;
  }
  return;
}



void td_pck_ind(uint8_t vif_index,uint8_t sta_index,_Bool rx)

{
  undefined3 in_register_00002029;
  int iVar1;
  undefined3 in_register_00002031;
  
  iVar1 = CONCAT31(in_register_00002029,vif_index);
  if (CONCAT31(in_register_00002031,rx) != 0) {
    td_env[iVar1].pck_cnt_rx = td_env[iVar1].pck_cnt_rx + 1;
    return;
  }
  td_env[iVar1].pck_cnt_tx = td_env[iVar1].pck_cnt_tx + 1;
  return;
}



void td_pck_ps_ind(uint8_t vif_index,_Bool rx)

{
  undefined3 in_register_00002029;
  int iVar1;
  undefined3 in_register_0000202d;
  
  iVar1 = CONCAT31(in_register_00002029,vif_index);
  if (CONCAT31(in_register_0000202d,rx) != 0) {
    td_env[iVar1].pck_cnt_rx_ps = td_env[iVar1].pck_cnt_rx_ps + 1;
    return;
  }
  td_env[iVar1].pck_cnt_tx_ps = td_env[iVar1].pck_cnt_tx_ps + 1;
  return;
}



void bl_tpc_update_power_table(int8_t *power_table)

{
  char cVar1;
  int32_t *piVar2;
  char *pcVar3;
  int iStack72;
  int32_t power_os [14];
  
  trpc_update_power((int8_t (*) [8])power_table);
  pcVar3 = power_table + 0x18;
  piVar2 = &iStack72;
  while (pcVar3 != power_table + 0x26) {
    cVar1 = *pcVar3;
    pcVar3 = pcVar3 + 1;
    *piVar2 = (int)cVar1;
    piVar2 = piVar2 + 1;
  }
  rf_pri_update_power_offset(&iStack72);
  return;
}



void bl_tpc_power_table_get(int8_t *power_table_config)

{
  int iVar1;
  
  trpc_power_get(power_table_config);
  iVar1 = 0x18;
  do {
    power_table_config[iVar1] = '\0';
    iVar1 = iVar1 + 1;
  } while (iVar1 != 0x26);
  return;
}



void bl_tpc_update_power_rate_11b(int8_t *power_rate_table)

{
  int8_t *piVar1;
  int8_t *piVar2;
  int iVar3;
  
  iVar3 = 0;
  do {
    piVar1 = power_rate_table + iVar3;
    piVar2 = txpwr_vs_rate_table + iVar3;
    iVar3 = iVar3 + 1;
    *piVar2 = *piVar1;
  } while (iVar3 != 4);
  return;
}



void bl_tpc_update_power_rate_11g(int8_t *power_rate_table)

{
  int8_t *piVar1;
  int iVar2;
  int8_t *piVar3;
  
  iVar2 = 0;
  piVar3 = txpwr_vs_rate_table;
  do {
    piVar1 = power_rate_table + iVar2;
    iVar2 = iVar2 + 1;
    piVar3[8] = *piVar1;
    piVar3 = piVar3 + 1;
  } while (iVar2 != 8);
  return;
}



void bl_tpc_update_power_rate_11n(int8_t *power_rate_table)

{
  int8_t *piVar1;
  int iVar2;
  int8_t *piVar3;
  
  iVar2 = 0;
  piVar3 = txpwr_vs_rate_table;
  do {
    piVar1 = power_rate_table + iVar2;
    iVar2 = iVar2 + 1;
    piVar3[0x10] = *piVar1;
    piVar3 = piVar3 + 1;
  } while (iVar2 != 8);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void tpc_update_tx_power(int8_t pwr)

{
  uint8_t uVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  
  uVar1 = trpc_get_default_power_idx('\x02','\0');
  _DAT_44b000a0 = CONCAT31(extraout_var,uVar1) | _DAT_44b000a0 & 0xffffff00;
  uVar1 = trpc_get_default_power_idx('\0','\0');
  _DAT_44b000a0 = CONCAT31(extraout_var_00,uVar1) << 8 | _DAT_44b000a0 & 0xffff00ff;
  return;
}



// WARNING: Type propagation algorithm not settling

void tpc_update_vif_tx_power(vif_info_tag *vif,int8_t *pwr,uint8_t *idx)

{
  char cVar1;
  char cVar2;
  _Bool _Var3;
  undefined3 extraout_var;
  int *piVar4;
  
  if (*pwr == '\x7f') {
    return;
  }
  cVar1 = vif->tx_power;
  phy_get_rf_gain_idx(pwr,idx);
  cVar2 = *pwr;
  vif->tx_power = cVar2;
  if (vif->user_tx_power < cVar2) {
    *pwr = vif->user_tx_power;
    phy_get_rf_gain_idx(pwr,idx);
  }
  if (*pwr != cVar1) {
    piVar4 = (int *)(vif->sta_list).first;
    while (piVar4 != (int *)0x0) {
      *(byte *)((int)piVar4 + 0x11a) = *(byte *)((int)piVar4 + 0x11a) | 0x10;
      piVar4 = (int *)*piVar4;
    }
    if (vif->chan_ctxt != (chan_ctxt_tag *)0x0) {
      chan_update_tx_power(vif->chan_ctxt);
      _Var3 = chan_is_on_channel(vif);
      if (CONCAT31(extraout_var,_Var3) != 0) {
        tpc_update_tx_power((vif->chan_ctxt->channel).tx_power);
        return;
      }
    }
  }
  return;
}



uint8_t tpc_get_vif_tx_power_vs_rate(uint32_t rate_config)

{
  uint8_t formatmod;
  byte mcs;
  
  mcs = (byte)rate_config & 0x7f;
  if ((rate_config >> 0xb & 7) == 0) {
    formatmod = (uint8_t)(rate_config & 0x7c);
    if ((rate_config & 0x7c) != 0) {
      mcs = mcs - 4;
      formatmod = '\x01';
    }
  }
  else {
    formatmod = '\x02';
  }
  formatmod = trpc_get_default_power_idx(formatmod,mcs);
  return formatmod;
}



void tpc_update_frame_tx_power(vif_info_tag *vif,txl_frame_desc_tag *frame)

{
  uint32_t uVar1;
  uint8_t uVar2;
  undefined3 extraout_var;
  
  uVar1 = (((frame->txdesc).lmac.hw_desc)->thd).policyentryaddr;
  uVar2 = tpc_get_vif_tx_power_vs_rate(*(uint32_t *)(uVar1 + 0x14));
  *(undefined4 *)(uVar1 + 0x24) = CONCAT31(extraout_var,uVar2);
  return;
}



void txl_int_fake_transfer(txdesc *txdesc,uint8_t access_category)

{
  undefined3 in_register_0000202d;
  int iVar1;
  txl_buffer_tag *ptVar2;
  
  ptVar2 = (txdesc->lmac).buffer;
  (ptVar2->tbd).upatterntx = 0xcafefade;
  iVar1 = CONCAT31(in_register_0000202d,access_category) + 0x16;
  ptVar2->txdesc = txdesc;
  if ((&txl_buffer_env.buf_idx[0].free)[iVar1 * 2] == 0) {
    *(txl_buffer_tag **)(&txl_buffer_env.buf_idx[0].free + iVar1 * 2) = ptVar2;
  }
  else {
    *(txl_buffer_tag **)((&txl_buffer_env.buf_idx[0].free_size)[iVar1 * 2] + 0x10) = ptVar2;
  }
  *(txl_buffer_tag **)(&txl_buffer_env.buf_idx[0].free_size + iVar1 * 2) = ptVar2;
  ptVar2->next = (txl_buffer_tag *)0x0;
  return;
}



void blmac_abs_timer_set(int reg_idx,uint32_t value)

{
  if (9 < reg_idx) {
    assert_err("reg_idx <= 9","module",0x26a0);
  }
  *(uint32_t *)((reg_idx + 0x112c004a) * 4) = value;
  return;
}



void txl_machdr_format(uint32_t machdrptr)

{
  uint uVar1;
  
  if ((*(byte *)(machdrptr + 0x16) & 0xf) == 0) {
    txl_cntrl_env.seqnbr = txl_cntrl_env.seqnbr + 1;
  }
  uVar1 = (uint)txl_cntrl_env.seqnbr;
  *(byte *)(machdrptr + 0x16) = (byte)(uVar1 << 4) | *(byte *)(machdrptr + 0x16) & 0xf;
  *(undefined *)(machdrptr + 0x17) = (char)((uVar1 << 4) >> 8);
  return;
}



void txl_cntrl_init(void)

{
  txl_cntrl_env_tag *ptVar1;
  undefined4 uVar2;
  undefined4 *puVar3;
  
  txl_hwdesc_init();
  txl_buffer_init();
  txl_cfm_init();
  txl_frame_init(false);
  memset(&txl_cntrl_env,0,0x58);
  ptVar1 = &txl_cntrl_env;
  puVar3 = (undefined4 *)&DAT_44a00080;
  do {
    co_list_init(&ptVar1->txlist[0].transmitting);
    ptVar1->txlist[0].last_frame_exch = (tx_hd *)0x0;
    uVar2 = *puVar3;
    ptVar1->txlist[0].chk_state = '\0';
    puVar3 = puVar3 + 1;
    ptVar1->txlist[0].bridgedmacnt = (uint16_t)uVar2;
    ptVar1 = (txl_cntrl_env_tag *)(ptVar1->txlist + 1);
  } while (puVar3 != (undefined4 *)0x44a00094);
  txl_cntrl_env.seqnbr = 0;
  return;
}



_Bool txl_cntrl_tx_check(vif_info_tag *p_vif_entry)

{
  _Bool _Var1;
  
  if (txl_cntrl_env.reset == false) {
    _Var1 = chan_is_tx_allowed(p_vif_entry);
    return _Var1;
  }
  return false;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void txl_cntrl_halt_ac(uint8_t access_category)

{
  undefined3 in_register_00002029;
  
  switch(CONCAT31(in_register_00002029,access_category)) {
  case 0:
    _DAT_44b08180 = 0x10000;
    do {
    } while ((_DAT_44b08188 >> 4 & 3) != 0);
    _DAT_44b08184 = 0x10000;
    break;
  case 1:
    _DAT_44b08180 = 0x20000;
    do {
    } while ((_DAT_44b08188 >> 8 & 3) != 0);
    _DAT_44b08184 = 0x20000;
    break;
  case 2:
    _DAT_44b08180 = 0x40000;
    do {
    } while ((_DAT_44b08188 >> 0xc & 3) != 0);
    _DAT_44b08184 = 0x40000;
    break;
  case 3:
    _DAT_44b08180 = 0x80000;
    do {
    } while ((_DAT_44b08188 >> 0x10 & 3) != 0);
    _DAT_44b08184 = 0x80000;
    break;
  case 4:
    _DAT_44b08180 = 0x8000;
    do {
    } while ((_DAT_44b08188 & 3) != 0);
    _DAT_44b08184 = 0x8000;
    break;
  default:
    assert_err("0","module",0x779);
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void txl_cntrl_flush_ac(uint8_t access_category,uint32_t status)

{
  uint uVar1;
  undefined3 in_register_00002029;
  int iVar2;
  uint uVar3;
  
  uVar1 = _DAT_44b0808c;
  iVar2 = CONCAT31(in_register_00002029,access_category);
  uVar3 = 1 << ((uint)access_category & 0x1f);
  txl_cfm_flush(access_category,txl_cfm_env.cfmlist + iVar2,status);
  txl_cfm_flush(access_category,&txl_cntrl_env.txlist[iVar2].transmitting,status);
  txl_cntrl_env.txlist[iVar2].last_frame_exch = (tx_hd *)0x0;
  txl_buffer_reset(iVar2);
  _DAT_44b08088 = uVar3;
  _DAT_44b0808c = ~uVar3 & uVar1;
  return;
}


/*
Unable to decompile 'txl_cntrl_clear_bcn_ac'
Cause: Exception while decompiling 230497b6: Decompiler process died

*/

/*
Unable to decompile 'txl_cntrl_clear_all_ac'
Cause: Exception while decompiling 230497d8: Decompiler process died

*/


void txl_cntrl_inc_pck_cnt(void)

{
  txl_cntrl_env.pck_cnt = txl_cntrl_env.pck_cnt + 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void txl_payload_handle(void)

{
  int iVar1;
  
  while ((_DAT_44a00024 & 0x1f) != 0) {
    iVar1 = __clzsi2(_DAT_44a00024 & 0x1f);
    _DAT_44a00020 = 1 << (0x1fU - iVar1 & 0x1f);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void txl_payload_handle_backup(void)

{
  ushort uVar1;
  uint uVar2;
  uint uVar3;
  txl_buffer_tag *ptVar4;
  char *condition;
  int line;
  byte bVar5;
  uint reg_idx;
  tx_hd *ptVar6;
  undefined *puVar7;
  txdesc *txdesc;
  tx_hd *ptVar8;
  txl_buffer_env_tag *ptVar9;
  txl_cntrl_env_tag *ptVar10;
  uint uVar11;
  tx_hw_desc *ptVar12;
  
  ptVar9 = &txl_buffer_env;
  ptVar10 = &txl_cntrl_env;
  uVar3 = 0;
  while (ptVar4 = ptVar9->list[0].first, ptVar4 == (txl_buffer_tag *)0x0) {
LAB_230498ce:
    uVar3 = uVar3 + 1;
    ptVar9 = (txl_buffer_env_tag *)&ptVar9->buf_idx[0].free_size;
    ptVar10 = (txl_cntrl_env_tag *)(ptVar10->txlist + 1);
    if (uVar3 == 5) {
      return;
    }
  }
  uVar2 = uVar3 & 0xff;
  ptVar9->list[0].first = ptVar4->next;
  uVar11 = 1 << (uVar3 & 0x1f);
  do {
    txdesc = ptVar4->txdesc;
    if ((txdesc->host).packet_addr != 0) {
      if (uVar3 == 4) {
        reg_idx = (uint)(txdesc->host).vif_idx;
        if ((*(byte *)((int)&ptVar4[1].length + 1) >> 5 & 1) == 0) {
          bVar5 = vif_info_tab[reg_idx].u[0x2ea] & 0xfd;
        }
        else {
          bVar5 = vif_info_tab[reg_idx].u[0x2ea] | 2;
        }
        vif_info_tab[reg_idx].u[0x2ea] = bVar5;
      }
      if ((txdesc->host).tid == -1) {
        uVar1 = (txdesc->host).flags;
        if ((((uVar1 & 8) != 0) && ((*(byte *)&ptVar4[1].length & 0xdc) == 0x10)) &&
           (*(short *)((int)&ptVar4[1].dma_desc[0].src + 2) == 0)) {
          (txdesc->host).flags = uVar1 | 0x20;
          rxu_cntrl_monitor_pm((mac_addr_conflict *)&ptVar4[1].lenheader);
        }
        txl_machdr_format((uint32_t)(ptVar4 + 1));
      }
      ptVar4 = (txdesc->lmac).buffer;
      ptVar12 = (txdesc->lmac).hw_desc;
      if (((txdesc->host).flags & 8) == 0) {
        txu_cntrl_tkip_mic_append(txdesc,(uint8_t)uVar2);
        (ptVar12->thd).macctrlinfo1 = (ptVar4->buffer_control).mac_control_info;
      }
      else {
        (ptVar12->thd).macctrlinfo2 = (ptVar12->thd).macctrlinfo2 & 0xff87ffff;
        bVar5 = *(byte *)&ptVar4[1].lenheader;
        (ptVar12->thd).statinfo = 0;
        (ptVar12->thd).macctrlinfo1 = (uint)((bVar5 & 1) == 0) << 9;
      }
      *(txl_buffer_control **)&(ptVar12->thd).policyentryaddr = &ptVar4->buffer_control;
      (ptVar12->thd).phyctrlinfo = (ptVar4->buffer_control).phy_control_info;
    }
    ptVar10->txlist[0].bridgedmacnt = ptVar10->txlist[0].bridgedmacnt + 1;
    ptVar6 = ptVar10->txlist[0].last_frame_exch;
    ptVar8 = &((txdesc->lmac).hw_desc)->thd;
    if (ptVar6 == (tx_hd *)0x0) {
      reg_idx = uVar3;
      if (uVar2 == 2) {
        if ((_DAT_44b08188 >> 0xc & 3) == 2) {
          line = 0x23c;
          condition = "blmac_tx_ac_2_state_getf() != 2";
          goto LAB_23049ac4;
        }
        _DAT_44b08180 = 0x800;
        puVar7 = (undefined *)0x61a80;
        _DAT_44b081a4 = ptVar8;
      }
      else {
        if (2 < uVar2) {
          if (uVar2 == 3) {
            if ((_DAT_44b08188 >> 0x10 & 3) != 2) {
              _DAT_44b08180 = 0x1000;
              _DAT_44b081a8 = ptVar8;
              goto LAB_23049b24;
            }
            line = 0x236;
            condition = "blmac_tx_ac_3_state_getf() != 2";
          }
          else {
            if (uVar2 != 4) goto LAB_23049a72;
            if ((_DAT_44b08188 & 3) != 2) {
              _DAT_44b08180 = 0x100;
              reg_idx = 4;
              puVar7 = (undefined *)0xc350;
              _DAT_44b08198 = ptVar8;
              goto LAB_23049ae0;
            }
            line = 0x22f;
            condition = "blmac_tx_bcn_state_getf() != 2";
          }
LAB_23049ac4:
          assert_rec(condition,"module",line);
          goto LAB_23049a36;
        }
        if (uVar2 == 1) {
          if ((_DAT_44b08188 >> 8 & 3) == 2) {
            line = 0x242;
            condition = "blmac_tx_ac_1_state_getf() != 2";
            goto LAB_23049ac4;
          }
          _DAT_44b08180 = 0x400;
          puVar7 = &DAT_001e8480;
          _DAT_44b081a0 = ptVar8;
        }
        else {
LAB_23049a72:
          if ((_DAT_44b08188 >> 4 & 3) == 2) {
            line = 0x248;
            condition = "blmac_tx_ac_0_state_getf() != 2";
            goto LAB_23049ac4;
          }
          _DAT_44b08180 = 0x200;
          _DAT_44b0819c = ptVar8;
LAB_23049b24:
          puVar7 = (undefined *)0x30d40;
        }
      }
LAB_23049ae0:
      blmac_abs_timer_set(reg_idx,(uint32_t)(puVar7 + _DAT_44b00120));
      _DAT_44b0808c = uVar11 | _DAT_44b0808c;
      _DAT_44b08088 = uVar11;
    }
    else {
      *(tx_hd **)&ptVar6->nextfrmexseq_ptr = ptVar8;
      if (uVar2 == 2) {
        _DAT_44b08180 = 8;
      }
      else {
        if (uVar2 < 3) {
          if (uVar2 == 1) {
            _DAT_44b08180 = 4;
          }
          else {
LAB_230499fe:
            _DAT_44b08180 = 2;
          }
        }
        else {
          if (uVar2 == 3) {
            _DAT_44b08180 = 0x10;
          }
          else {
            if (uVar2 != 4) goto LAB_230499fe;
            _DAT_44b08180 = 1;
          }
        }
      }
    }
LAB_23049a36:
    ptVar4 = ptVar9->list[0].first;
    ptVar10->txlist[0].last_frame_exch = ptVar8;
    if (ptVar4 == (txl_buffer_tag *)0x0) goto LAB_230498ce;
    ptVar9->list[0].first = ptVar4->next;
  } while( true );
}


/*
Unable to decompile 'txl_cntrl_push_int'
Cause: Exception while decompiling 23049baa: Decompiler process died

*/

/*
Unable to decompile 'txl_cntrl_push_int_force'
Cause: Exception while decompiling 23049c7c: Decompiler process died

*/

/*
Unable to decompile 'txl_cntrl_push'
Cause: Exception while decompiling 23049cca: Decompiler process died

*/


// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void txl_transmit_trigger(void)

{
  uint reg_idx;
  uint uVar1;
  int iVar2;
  u32_l status;
  tx_hw_desc *ptVar3;
  uint32_t uVar4;
  txdesc *txdesc;
  co_list *list;
  
  if ((_DAT_44b08078 & 0x7c0) == 0) {
    return;
  }
  iVar2 = __clzsi2(_DAT_44b08078 & 0x7c0);
  reg_idx = 0x19U - iVar2 & 0xff;
  if (4 < reg_idx) {
    assert_err("access_category < NX_TXQ_CNT","module",0x90b);
  }
  _DAT_44b0807c = 1 << (reg_idx + 6 & 0x1f);
  list = &txl_cntrl_env.txlist[reg_idx].transmitting;
  uVar1 = ~(1 << (0x19U - iVar2 & 0x1f));
  while( true ) {
    txdesc = (txdesc *)list->first;
    if (txdesc == (txdesc *)0x0) {
      txl_cntrl_env.txlist[reg_idx].last_frame_exch = (tx_hd *)0x0;
      _DAT_44b0808c = uVar1 & _DAT_44b0808c;
      return;
    }
    ptVar3 = (txdesc->lmac).hw_desc;
    status = (ptVar3->thd).statinfo;
    if (-1 < (int)status) break;
    if (((txdesc->host).packet_addr != 0) && ((txdesc->lmac).buffer != (txl_buffer_tag *)0x0)) {
      (txdesc->lmac).buffer = (txl_buffer_tag *)0x0;
    }
    ptVar3->cfm_ptr->status = status;
    uVar4 = (ptVar3->thd).nextfrmexseq_ptr;
    if (uVar4 == 0) {
      txl_cntrl_env.txlist[reg_idx].last_frame_exch = (tx_hd *)0x0;
      _DAT_44b0808c = _DAT_44b0808c & uVar1;
    }
    else {
      if (-1 < *(int *)(uVar4 + 0x3c)) {
        blmac_abs_timer_set(reg_idx,_DAT_44b00120 + TX_TIMEOUT[reg_idx]);
        return;
      }
    }
    co_list_pop_front(list);
    if ((txdesc->host).packet_addr == 0) {
      txl_frame_cfm(txdesc);
    }
    else {
      txl_cfm_push(txdesc,status,(u8_l)reg_idx);
    }
    blmac_abs_timer_set(reg_idx,_DAT_44b00120 + TX_TIMEOUT[reg_idx]);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void txl_reset(void)

{
  u8_l access_category;
  uint16_t uVar1;
  txl_cntrl_env_tag *ptVar2;
  undefined4 *puVar3;
  undefined4 uVar4;
  uint uVar5;
  co_list *list;
  txl_cfm_env_tag *list_00;
  
  uVar1 = txl_cntrl_env.seqnbr;
  ke_evt_clear(0x1f000);
  do {
  } while ((_DAT_44a00010 & 0xffff) != 0xffff);
  txl_cntrl_env.reset = true;
  list_00 = &txl_cfm_env;
  list = &txl_cntrl_env.txlist[0].transmitting;
  uVar5 = 0;
  do {
    _DAT_44a00020 = 1 << (uVar5 & 0x1f);
    access_category = (u8_l)uVar5;
    txl_cfm_flush(access_category,(co_list *)list_00,0x40000000);
    uVar5 = uVar5 + 1;
    txl_cfm_flush(access_category,list,0x40000000);
    list_00 = (txl_cfm_env_tag *)(list_00->cfmlist + 1);
    list = list + 2;
  } while (uVar5 != 5);
  txl_hwdesc_reset();
  txl_buffer_reinit();
  txl_cfm_init();
  memset(&txl_cntrl_env,0,0x58);
  ptVar2 = &txl_cntrl_env;
  puVar3 = (undefined4 *)&DAT_44a00080;
  txl_cntrl_env.seqnbr = uVar1;
  do {
    co_list_init(&ptVar2->txlist[0].transmitting);
    ptVar2->txlist[0].last_frame_exch = (tx_hd *)0x0;
    uVar4 = *puVar3;
    ptVar2->txlist[0].chk_state = '\0';
    puVar3 = puVar3 + 1;
    ptVar2->txlist[0].bridgedmacnt = (uint16_t)uVar4;
    ptVar2 = (txl_cntrl_env_tag *)(ptVar2->txlist + 1);
  } while (puVar3 != (undefined4 *)0x44a00094);
  return;
}



// WARNING: Type propagation algorithm not settling

void txl_cntrl_env_dump(void)

{
  int iVar1;
  uint32_t uVar2;
  int *piVar3;
  int iVar4;
  int *piVar5;
  co_list *list;
  
  iVar1 = 4;
  do {
    list = (co_list *)((int)&txl_cntrl_env.txlist[0].last_frame_exch + iVar1);
    uVar2 = co_list_cnt(list);
    if (uVar2 != 0) {
      piVar5 = (int *)list->first;
      piVar3 = piVar5;
      while (piVar3 != (int *)0x0) {
        piVar3 = (int *)*piVar3;
      }
      while (piVar5 != (int *)0x0) {
        iVar4 = *(int *)(piVar5[0x1b] + 0x10);
        while (iVar4 != 0) {
          iVar4 = *(int *)(iVar4 + 4);
        }
        piVar5 = (int *)*piVar5;
      }
    }
    iVar1 = iVar1 + 0x10;
  } while (iVar1 != 0x54);
  return;
}



void txl_frame_init_desc(txl_frame_desc_tag *frame,txl_buffer_tag *buffer,tx_hw_desc *hwdesc,
                        txl_buffer_control *bufctrl)

{
  memset(frame,0,0x2d8);
  (hwdesc->thd).upatterntx = 0xcafebabe;
  *(txl_buffer_tag **)&(hwdesc->thd).field_4 = buffer + 1;
  (hwdesc->thd).frmlifetime = 0;
  (hwdesc->thd).optlen[0] = 0;
  (hwdesc->thd).optlen[1] = 0;
  (hwdesc->thd).optlen[2] = 0;
  *(undefined4 *)bufctrl->field_0 = 0xbadcab1e;
  (frame->txdesc).lmac.hw_desc = hwdesc;
  (frame->txdesc).lmac.buffer = buffer;
  (frame->txdesc).umac.buf_control = bufctrl;
  frame->type = '\x01';
  return;
}



// WARNING: Type propagation algorithm not settling

void txl_frame_init(_Bool reset)

{
  tx_hw_desc *ptVar1;
  txl_frame_desc_tag *__s;
  uint8_t uVar2;
  byte bVar3;
  undefined3 in_register_00002029;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  txl_buffer_control *ptVar4;
  uint32_t *puVar5;
  int iVar6;
  
  co_list_init((co_list *)&txl_frame_env);
  co_list_init(&txl_frame_env.desc_done);
  __s = txl_frame_desc;
  ptVar1 = txl_frame_hwdesc_pool;
  puVar5 = txl_frame_pool;
  ptVar4 = txl_frame_buf_ctrl;
  iVar6 = 0;
  do {
    if ((CONCAT31(in_register_00002029,reset) == 0) || ((&__s->type)[1] == '\0')) {
      memset(__s,0,0x2d8);
      (ptVar1->thd).upatterntx = 0xcafebabe;
      (ptVar1->thd).frmlifetime = 0;
      (ptVar1->thd).optlen[0] = 0;
      (ptVar1->thd).optlen[1] = 0;
      (ptVar1->thd).optlen[2] = 0;
      *(undefined4 *)ptVar4->field_0 = 0xbadcab1e;
      *(uint32_t **)&(__s->txdesc).lmac.buffer = puVar5;
      (__s->txdesc).umac.buf_control = ptVar4;
      (__s->txdesc).lmac.hw_desc = ptVar1;
      ptVar1->cfm_ptr = txl_frame_hwdesc_cfms + iVar6;
      *(txl_buffer_tag **)&(ptVar1->thd).field_4 = (txl_buffer_tag *)puVar5 + 1;
      __s->type = '\0';
      co_list_push_back((co_list *)&txl_frame_env,(co_list_hdr *)__s);
    }
    iVar6 = iVar6 + 1;
    __s = __s + 1;
    ptVar1 = ptVar1 + 1;
    puVar5 = (uint32_t *)(((txl_buffer_tag *)puVar5)[1].buffer_control.field_0 + 0x10);
    ptVar4 = ptVar4 + 1;
  } while (iVar6 != 4);
  txl_buffer_control_24G.field_0._0_4_ = 0xbadcab1e;
  txl_buffer_control_24G.mac_control_info = 0;
  txl_buffer_control_24G.phy_control_info = 0;
  uVar2 = phy_get_ntx();
  txl_buffer_control_24G.field_0._4_4_ = CONCAT31(extraout_var,uVar2) << 0xe;
  bVar3 = phy_get_ntx();
  txl_buffer_control_24G.field_0._8_4_ = (1 << ((uint)bVar3 + 1 & 0x1f)) + -1;
  txl_buffer_control_24G.field_0._16_4_ = 0xffff0704;
  txl_buffer_control_24G.field_0._20_4_ = 0x400;
  txl_buffer_control_24G.field_0._12_4_ = 0;
  txl_buffer_control_24G.field_0._24_4_ = 0;
  txl_buffer_control_24G.field_0._28_4_ = 0;
  txl_buffer_control_24G.field_0._32_4_ = 0;
  txl_buffer_control_24G.field_0._40_4_ = 0;
  txl_buffer_control_24G.field_0._44_4_ = 0;
  txl_buffer_control_24G.field_0._48_4_ = 0;
  txl_buffer_control_5G.field_0._0_4_ = 0xbadcab1e;
  txl_buffer_control_5G.mac_control_info = 0;
  txl_buffer_control_5G.phy_control_info = 0;
  uVar2 = phy_get_ntx();
  txl_buffer_control_5G.field_0._4_4_ = CONCAT31(extraout_var_00,uVar2) << 0xe;
  bVar3 = phy_get_ntx();
  txl_buffer_control_5G.field_0._8_4_ = (1 << ((uint)bVar3 + 1 & 0x1f)) + -1;
  txl_buffer_control_5G.field_0._12_4_ = 0;
  txl_buffer_control_5G.field_0._16_4_ = 0xffff0704;
  txl_buffer_control_5G.field_0._20_4_ = iVar6;
  txl_buffer_control_5G.field_0._24_4_ = 0;
  txl_buffer_control_5G.field_0._28_4_ = 0;
  txl_buffer_control_5G.field_0._32_4_ = 0;
  txl_buffer_control_5G.field_0._40_4_ = 0;
  txl_buffer_control_5G.field_0._44_4_ = 0;
  txl_buffer_control_5G.field_0._48_4_ = 0;
  return;
}



// WARNING: Type propagation algorithm not settling

txl_frame_desc_tag * txl_frame_get(int type,int len)

{
  txl_frame_desc_tag *ptVar1;
  tx_hw_desc *ptVar2;
  uint8_t uVar3;
  undefined3 extraout_var;
  uint32_t uVar4;
  uint32_t uVar5;
  txl_buffer_control *__src;
  txl_buffer_control *__dest;
  txl_buffer_tag *ptVar6;
  
  ptVar1 = (txl_frame_desc_tag *)co_list_pop_front((co_list *)&txl_frame_env);
  if (ptVar1 == (txl_frame_desc_tag *)0x0) {
    tx_count = tx_count + 1;
    if (tx_count == 10) {
      tx_count = 0;
      rx_count = 2;
      uVar4 = co_list_cnt((co_list *)&txl_frame_env);
      uVar5 = co_list_cnt(&txl_frame_env.desc_done);
      if ((uVar5 | uVar4) == 0) {
        txl_cntrl_clear_all_ac();
      }
    }
  }
  else {
    if (rx_count == 1) {
      rx_count = 0;
      mac_hw_reset = '\x01';
      vTaskEnterCritical();
      assert_rec("MAC HW RESET include tx and rx","tx rx",0x10b);
      vTaskDelay(200);
      ptVar1 = (txl_frame_desc_tag *)0x0;
      vTaskExitCritical();
    }
    else {
      if (rx_count != 0) {
        rx_count = rx_count - 1;
      }
      ptVar2 = (ptVar1->txdesc).lmac.hw_desc;
      ptVar6 = (ptVar1->txdesc).lmac.buffer;
      (ptVar2->thd).frmlen = len + 4;
      (ptVar2->thd).field_5 = (ptVar2->thd).field_4 + len + -1;
      __dest = &ptVar6->buffer_control;
      if (type == 0) {
        __src = &txl_buffer_control_24G;
      }
      else {
        __src = __dest;
        if (type == 1) {
          __src = &txl_buffer_control_5G;
        }
      }
      memcpy(__dest,__src,0x34);
      uVar3 = tpc_get_vif_tx_power_vs_rate(*(uint32_t *)((ptVar6->buffer_control).field_0 + 0x14));
      *(uint *)((ptVar6->buffer_control).field_0 + 0x24) = CONCAT31(extraout_var,uVar3);
      *(txl_buffer_control **)&(ptVar2->thd).policyentryaddr = __dest;
      (ptVar2->thd).phyctrlinfo = 0;
      (ptVar2->thd).macctrlinfo2 = 0;
      (ptVar2->thd).field_3 = 0;
      (ptVar1->cfm).cfm_func = (cfm_func_ptr *)0x0;
      (ptVar1->cfm).env = (void *)0x0;
    }
  }
  return ptVar1;
}



_Bool txl_frame_push(txl_frame_desc_tag *frame,uint8_t ac)

{
  byte bVar1;
  tx_hw_desc *ptVar2;
  _Bool _Var3;
  
  ptVar2 = (frame->txdesc).lmac.hw_desc;
  if (((ptVar2->thd).field_4 & 1) != 0) {
    assert_err("(thd->datastartptr & 0x01) == 0","module",0x182);
  }
  (ptVar2->thd).nextfrmexseq_ptr = 0;
  (ptVar2->thd).nextmpdudesc_ptr = 0;
  (ptVar2->thd).macctrlinfo2 = (ptVar2->thd).macctrlinfo2 & 0xff87ffff;
  bVar1 = *(byte *)((ptVar2->thd).field_4 + 4);
  (ptVar2->thd).statinfo = 0;
  (ptVar2->thd).macctrlinfo1 = (uint)((bVar1 & 1) == 0) << 9;
  _Var3 = txl_cntrl_push_int((txdesc *)frame,ac);
  return _Var3;
}



_Bool txl_frame_push_force(txl_frame_desc_tag *frame,uint8_t ac)

{
  byte bVar1;
  tx_hw_desc *ptVar2;
  _Bool _Var3;
  
  ptVar2 = (frame->txdesc).lmac.hw_desc;
  if (((ptVar2->thd).field_4 & 1) != 0) {
    assert_err("(thd->datastartptr & 0x01) == 0","module",0x1ad);
  }
  (ptVar2->thd).nextfrmexseq_ptr = 0;
  (ptVar2->thd).nextmpdudesc_ptr = 0;
  (ptVar2->thd).macctrlinfo2 = (ptVar2->thd).macctrlinfo2 & 0xff87ffff;
  bVar1 = *(byte *)((ptVar2->thd).field_4 + 4);
  (ptVar2->thd).statinfo = 0;
  (ptVar2->thd).macctrlinfo1 = (uint)((bVar1 & 1) == 0) << 9;
  _Var3 = txl_cntrl_push_int_force((txdesc *)frame,ac);
  return _Var3;
}



void txl_frame_cfm(txdesc *txdesc)

{
  co_list_push_back(&txl_frame_env.desc_done,(co_list_hdr *)txdesc);
  ke_evt_set(0x20000);
  return;
}



void txl_frame_release(txdesc *txdesc,_Bool postponed)

{
  co_list_hdr *UNRECOVERED_JUMPTABLE;
  undefined3 in_register_0000202d;
  
  if (*(char *)&txdesc[1].host.packet_addr == '\0') {
    co_list_push_back((co_list *)&txl_frame_env,(co_list_hdr *)txdesc);
  }
  if ((CONCAT31(in_register_0000202d,postponed) != 0) &&
     (UNRECOVERED_JUMPTABLE = txdesc[1].list_hdr.next, UNRECOVERED_JUMPTABLE != (co_list_hdr *)0x0))
  {
                    // WARNING: Could not recover jumptable at 0x2304a49c. Too many branches
                    // WARNING: Treating indirect jump as call
    (*(code *)UNRECOVERED_JUMPTABLE)(txdesc[1].host.pbuf_addr,0);
    return;
  }
  return;
}


/*
Unable to decompile 'txl_frame_evt'
Cause: Exception while decompiling 2304a4a8: Decompiler process died

*/


uint8_t txl_frame_send_null_frame(uint8_t sta_idx,cfm_func_ptr *cfm,void *env)

{
  byte bVar1;
  uint8_t uVar2;
  txl_buffer_tag *ptVar3;
  undefined3 in_register_00002029;
  int iVar4;
  txl_frame_desc_tag *frame;
  uint uVar5;
  int iVar6;
  char acStack56 [4];
  phy_channel_info phy_info;
  
  iVar4 = CONCAT31(in_register_00002029,sta_idx);
  bVar1 = sta_info_tab[iVar4].inst_nbr;
  phy_get_channel((phy_channel_info *)acStack56,'\0');
  frame = txl_frame_get((uint)(acStack56[0] != '\0'),0x18);
  if (frame != (txl_frame_desc_tag *)0x0) {
    tpc_update_frame_tx_power(vif_info_tab + bVar1,frame);
    ptVar3 = (frame->txdesc).lmac.buffer;
    *(undefined *)&ptVar3[1].length = 0x48;
    *(undefined *)((int)&ptVar3[1].length + 1) = 1;
    *(undefined *)((int)&ptVar3[1].length + 2) = 0;
    *(undefined *)((int)&ptVar3[1].length + 3) = 0;
    memcpy(&ptVar3[1].lenheader,&sta_info_tab[iVar4].mac_addr,6);
    memcpy((void *)((int)&ptVar3[1].lenpad + 2),&vif_info_tab[bVar1].mac_addr,6);
    memcpy(&ptVar3[1].next,&sta_info_tab[iVar4].mac_addr,6);
    uVar5 = (uint)txl_cntrl_env.seqnbr;
    txl_cntrl_env.seqnbr = (uint16_t)((uVar5 + 1) * 0x10000 >> 0x10);
    iVar6 = (uVar5 + 1) * 0x100000;
    *(undefined *)((int)&ptVar3[1].txdesc + 2) = (char)((uint)iVar6 >> 0x10);
    *(undefined *)((int)&ptVar3[1].txdesc + 3) = (char)((uint)iVar6 >> 0x18);
    (frame->cfm).cfm_func = cfm;
    (frame->cfm).env = env;
    uVar2 = sta_info_tab[iVar4].inst_nbr;
    (frame->txdesc).host.staid = sta_idx;
    (frame->txdesc).host.vif_idx = uVar2;
    txl_frame_push(frame,'\x03');
  }
  return (uint8_t)(frame == (txl_frame_desc_tag *)0x0);
}



// WARNING: Variable defined which should be unmapped: phy_info

uint8_t txl_frame_send_qosnull_frame(uint8_t sta_idx,uint16_t qos,cfm_func_ptr *cfm,void *env)

{
  txl_buffer_tag *ptVar1;
  uint8_t uVar2;
  undefined3 in_register_00002029;
  int iVar3;
  txl_frame_desc_tag *frame;
  mac_addr_conflict *__src;
  uint uVar4;
  char acStack56 [4];
  phy_channel_info phy_info;
  
  iVar3 = CONCAT31(in_register_00002029,sta_idx);
  uVar4 = (uint)sta_info_tab[iVar3].inst_nbr;
  phy_get_channel((phy_channel_info *)acStack56,'\0');
  frame = txl_frame_get((uint)(acStack56[0] != '\0'),0x1a);
  if (frame == (txl_frame_desc_tag *)0x0) {
    uVar2 = '\x01';
  }
  else {
    tpc_update_frame_tx_power(vif_info_tab + uVar4,frame);
    ptVar1 = (frame->txdesc).lmac.buffer;
    *(undefined *)&ptVar1[1].length = 200;
    *(undefined *)((int)&ptVar1[1].length + 1) = 0;
    *(undefined *)((int)&ptVar1[1].length + 2) = 0;
    *(undefined *)((int)&ptVar1[1].length + 3) = 0;
    memcpy(&ptVar1[1].lenheader,&sta_info_tab[iVar3].mac_addr,6);
    __src = &vif_info_tab[uVar4].mac_addr;
    memcpy((void *)((int)&ptVar1[1].lenpad + 2),__src,6);
    uVar2 = vif_info_tab[uVar4].type;
    *(undefined *)&ptVar1[1].length = 200;
    if (uVar2 == '\0') {
      *(undefined *)((int)&ptVar1[1].length + 1) = 1;
      __src = &sta_info_tab[iVar3].mac_addr;
    }
    else {
      *(undefined *)((int)&ptVar1[1].length + 1) = 2;
    }
    memcpy(&ptVar1[1].next,__src,6);
    *(char *)&ptVar1[1].dma_desc[0].src = (char)qos;
    *(undefined *)((int)&ptVar1[1].txdesc + 2) = 0;
    *(undefined *)((int)&ptVar1[1].txdesc + 3) = 0;
    *(undefined *)((int)&ptVar1[1].dma_desc[0].src + 1) = (char)(qos >> 8);
    (frame->cfm).cfm_func = cfm;
    (frame->cfm).env = env;
    uVar2 = sta_info_tab[iVar3].inst_nbr;
    (frame->txdesc).host.staid = sta_idx;
    (frame->txdesc).host.vif_idx = uVar2;
    txl_frame_push(frame,'\x03');
    uVar2 = '\0';
  }
  return uVar2;
}



uint8_t txl_frame_send_eapol_frame
                  (uint8_t sta_idx,cfm_func_ptr *cfm,void *cfm_env,uint8_t *pBuf,uint32_t pBuf_len)

{
  byte bVar1;
  uint8_t uVar2;
  ushort uVar3;
  undefined2 uVar4;
  txl_buffer_tag *ptVar5;
  undefined3 in_register_00002029;
  txl_frame_desc_tag *frame;
  key_info_tag *pkVar6;
  uint32_t uVar7;
  undefined *puVar8;
  int iVar9;
  tx_hw_desc *ptVar10;
  uint16_t uVar11;
  uint uVar12;
  dma_desc *pdVar13;
  uint uVar14;
  dma_desc *unaff_s8;
  mac_addr_conflict *pmVar15;
  mac_addr_conflict *pmVar16;
  uint uVar17;
  int iVar18;
  char acStack88 [4];
  phy_channel_info phy_info;
  mic_calc mic;
  
  iVar18 = CONCAT31(in_register_00002029,sta_idx);
  bVar1 = sta_info_tab[iVar18].inst_nbr;
  uVar17 = (uint)bVar1;
  phy_get_channel((phy_channel_info *)acStack88,'\0');
  frame = txl_frame_get((uint)(acStack88[0] != '\0'),0x100);
  if (frame == (txl_frame_desc_tag *)0x0) {
    return '\0';
  }
  (frame->txdesc).host.vif_idx = bVar1;
  (frame->txdesc).host.staid = sta_idx;
  (frame->txdesc).host.tid = '\0';
  uVar3 = sta_info_tab[iVar18].seq_nbr[0];
  sta_info_tab[iVar18].seq_nbr[0] = (ushort)(((uint)uVar3 + 1) * 0x100000 >> 0x14);
  (frame->txdesc).host.ethertype = 0x8e88;
  (frame->txdesc).host.sn = uVar3;
  pmVar15 = &sta_info_tab[iVar18].mac_addr;
  (frame->txdesc).host.eth_dest_addr.array[0] = pmVar15->array[0];
  (frame->txdesc).host.eth_dest_addr.array[1] = sta_info_tab[iVar18].mac_addr.array[1];
  (frame->txdesc).host.eth_dest_addr.array[2] = sta_info_tab[iVar18].mac_addr.array[2];
  pmVar16 = &vif_info_tab[uVar17].mac_addr;
  (frame->txdesc).host.eth_src_addr.array[0] = pmVar16->array[0];
  (frame->txdesc).host.eth_src_addr.array[1] = vif_info_tab[uVar17].mac_addr.array[1];
  (frame->txdesc).host.eth_src_addr.array[2] = vif_info_tab[uVar17].mac_addr.array[2];
  tpc_update_frame_tx_power(vif_info_tab + uVar17,frame);
  ptVar5 = (frame->txdesc).lmac.buffer;
  if ((vif_info_tab[uVar17].bss_info.valid_flags & 1) == 0) {
    *(undefined *)&ptVar5[1].length = 8;
    uVar14 = (uint)txl_cntrl_env.seqnbr;
    *(undefined *)((int)&ptVar5[1].length + 1) = 0;
    pdVar13 = ptVar5[1].dma_desc;
    txl_cntrl_env.seqnbr = (uint16_t)((uVar14 + 1) * 0x10000 >> 0x10);
    iVar9 = (uVar14 + 1) * 0x100000;
    *(undefined *)((int)&ptVar5[1].txdesc + 2) = (char)((uint)iVar9 >> 0x10);
    *(undefined *)((int)&ptVar5[1].txdesc + 3) = (char)((uint)iVar9 >> 0x18);
    uVar14 = pBuf_len + 0x20;
  }
  else {
    *(undefined *)&ptVar5[1].length = 0x88;
    *(undefined *)((int)&ptVar5[1].length + 1) = 0;
    pdVar13 = (dma_desc *)((int)&ptVar5[1].dma_desc[0].src + 2);
    uVar14 = pBuf_len + 0x22;
    iVar9 = (uint)(frame->txdesc).host.sn << 0x14;
    *(undefined *)((int)&ptVar5[1].txdesc + 2) = (char)((uint)iVar9 >> 0x10);
    *(undefined *)((int)&ptVar5[1].txdesc + 3) = (char)((uint)iVar9 >> 0x18);
    uVar2 = (frame->txdesc).host.tid;
    *(undefined *)((int)&ptVar5[1].dma_desc[0].src + 1) = 0;
    *(uint8_t *)&ptVar5[1].dma_desc[0].src = uVar2;
  }
  if (0x100 < uVar14) {
    assert_err("length<=NX_TXFRAME_LEN","module",0x591);
  }
  uVar4 = *(undefined2 *)&ptVar5[1].length;
  bVar1 = 1;
  if (vif_info_tab[uVar17].type == '\x02') {
    bVar1 = 2;
  }
  *(char *)&ptVar5[1].length = (char)uVar4;
  *(byte *)((int)&ptVar5[1].length + 1) = (byte)((ushort)uVar4 >> 8) | bVar1;
  *(undefined *)((int)&ptVar5[1].length + 2) = 0;
  *(undefined *)((int)&ptVar5[1].length + 3) = 0;
  *(uint16_t *)&ptVar5[1].lenheader = pmVar15->array[0];
  *(uint16_t *)((int)&ptVar5[1].lenheader + 2) = sta_info_tab[iVar18].mac_addr.array[1];
  *(uint16_t *)&ptVar5[1].lenpad = sta_info_tab[iVar18].mac_addr.array[2];
  *(uint16_t *)((int)&ptVar5[1].lenpad + 2) = pmVar16->array[0];
  *(uint16_t *)&ptVar5[1].flags = vif_info_tab[uVar17].mac_addr.array[1];
  *(uint16_t *)((int)&ptVar5[1].flags + 2) = vif_info_tab[uVar17].mac_addr.array[2];
  if (vif_info_tab[uVar17].type == '\x02') {
    *(uint16_t *)&ptVar5[1].next = pmVar16->array[0];
    *(uint16_t *)((int)&ptVar5[1].next + 2) = vif_info_tab[uVar17].mac_addr.array[1];
    uVar11 = vif_info_tab[uVar17].mac_addr.array[2];
  }
  else {
    *(uint16_t *)&ptVar5[1].next = pmVar15->array[0];
    *(uint16_t *)((int)&ptVar5[1].next + 2) = sta_info_tab[iVar18].mac_addr.array[1];
    uVar11 = sta_info_tab[iVar18].mac_addr.array[2];
  }
  *(uint16_t *)&ptVar5[1].txdesc = uVar11;
  iVar18 = 0;
  if ((vif_info_tab[(frame->txdesc).host.vif_idx].type != '\0') ||
     (uVar17 = (uint)(frame->txdesc).host.staid, sta_info_tab[uVar17].ctrl_port_state != '\x02'))
  goto LAB_2304aa3c;
  pkVar6 = *sta_info_tab[uVar17].sta_sec_info.cur_key;
  uVar2 = pkVar6->cipher;
  if (uVar2 == '\x01') {
    uVar17 = *(uint *)&pkVar6->tx_pn + 1;
    *(int *)((int)&pkVar6->tx_pn + 4) =
         (uint)(uVar17 < *(uint *)&pkVar6->tx_pn) + *(int *)((int)&pkVar6->tx_pn + 4);
    *(uint *)&pkVar6->tx_pn = uVar17;
    memcpy((frame->txdesc).host.pn,&pkVar6->tx_pn,6);
    iVar9 = 0xc;
LAB_2304ab94:
    iVar18 = 8;
  }
  else {
    if (uVar2 == '\0') {
LAB_2304a976:
      uVar17 = *(uint *)&pkVar6->tx_pn + 1;
      *(int *)((int)&pkVar6->tx_pn + 4) =
           (uint)(uVar17 < *(uint *)&pkVar6->tx_pn) + *(int *)((int)&pkVar6->tx_pn + 4);
      *(uint *)&pkVar6->tx_pn = uVar17;
      memcpy((frame->txdesc).host.pn,&pkVar6->tx_pn,4);
      iVar9 = 4;
      iVar18 = 4;
    }
    else {
      if (uVar2 == '\x02') {
        uVar17 = *(uint *)&pkVar6->tx_pn + 1;
        *(int *)((int)&pkVar6->tx_pn + 4) =
             (uint)(uVar17 < *(uint *)&pkVar6->tx_pn) + *(int *)((int)&pkVar6->tx_pn + 4);
        *(uint *)&pkVar6->tx_pn = uVar17;
        memcpy((frame->txdesc).host.pn,&pkVar6->tx_pn,6);
        iVar9 = 8;
        goto LAB_2304ab94;
      }
      if (uVar2 == '\x03') goto LAB_2304a976;
      iVar9 = 0;
      iVar18 = 0;
    }
  }
  iVar18 = iVar18 + iVar9;
  if (iVar18 == 0) goto LAB_2304aa3c;
  uVar3 = *(ushort *)&ptVar5[1].length;
  uVar14 = uVar14 + iVar18;
  *(char *)&ptVar5[1].length = (char)uVar3;
  *(byte *)((int)&ptVar5[1].length + 1) = (byte)((uint)uVar3 >> 8) | 0x40;
  uVar17 = (uint)vif_info_tab[(frame->txdesc).host.vif_idx].type;
  if (vif_info_tab[(frame->txdesc).host.vif_idx].type == 0) {
    uVar12 = (uint)(frame->txdesc).host.staid;
    if (sta_info_tab[uVar12].ctrl_port_state == '\x02') {
      pkVar6 = *sta_info_tab[uVar12].sta_sec_info.cur_key;
      uVar7 = (((frame->txdesc).lmac.hw_desc)->thd).policyentryaddr;
      uVar2 = pkVar6->cipher;
      if (uVar2 == '\x01') {
        uVar3 = (frame->txdesc).host.pn[0];
        *(ushort *)&pdVar13->src = uVar3 & 0x7f00 | 0x2000 | uVar3 >> 8;
        uVar3 = (ushort)*(byte *)(frame->txdesc).host.pn | (ushort)pkVar6->key_idx << 0xe;
LAB_2304abec:
        *(ushort *)((int)&pdVar13->src + 2) = uVar3 | 0x2000;
        uVar17 = 8;
        *(uint16_t *)&pdVar13->dest = (frame->txdesc).host.pn[1];
        *(uint16_t *)((int)&pdVar13->dest + 2) = (frame->txdesc).host.pn[2];
      }
      else {
        if (uVar2 == '\0') {
LAB_2304aa0a:
          *(uint16_t *)&pdVar13->src = (frame->txdesc).host.pn[0];
          *(ushort *)((int)&pdVar13->src + 2) =
               (ushort)pkVar6->key_idx << 0xe | (frame->txdesc).host.pn[1];
          uVar17 = 4;
        }
        else {
          if (uVar2 == '\x02') {
            *(uint16_t *)&pdVar13->src = (frame->txdesc).host.pn[0];
            uVar3 = (ushort)pkVar6->key_idx << 0xe;
            goto LAB_2304abec;
          }
          if (uVar2 == '\x03') goto LAB_2304aa0a;
        }
      }
      *(uint *)(uVar7 + 0xc) = *(uint *)(uVar7 + 0xc) & 0xffc00 | (uint)pkVar6->hw_key_idx;
    }
  }
  else {
    uVar17 = 0;
  }
  pdVar13 = (dma_desc *)((int)&pdVar13->src + uVar17);
  unaff_s8 = pdVar13;
LAB_2304aa3c:
  *(undefined2 *)&pdVar13->src = 0xaaaa;
  *(undefined2 *)((int)&pdVar13->src + 2) = 3;
  *(undefined2 *)&pdVar13->dest = 0;
  *(uint16_t *)((int)&pdVar13->dest + 2) = (frame->txdesc).host.ethertype;
  memcpy(&pdVar13->length,pBuf,pBuf_len);
  if ((iVar18 != 0) &&
     (pkVar6 = *sta_info_tab[(frame->txdesc).host.staid].sta_sec_info.cur_key,
     pkVar6->cipher == '\x01')) {
    me_mic_init((mic_calc *)&phy_info.info2,(uint32_t *)pkVar6->u,
                (mac_addr_conflict51 *)&(frame->txdesc).host.eth_dest_addr,
                (mac_addr_conflict51 *)&(frame->txdesc).host.eth_src_addr,(frame->txdesc).host.tid);
    me_mic_calc((mic_calc *)&phy_info.info2,(uint32_t)unaff_s8,pBuf_len + 8);
    me_mic_end((mic_calc *)&phy_info.info2);
    iVar18 = 0;
    do {
      puVar8 = (undefined *)((int)&phy_info.info2 + iVar18);
      iVar9 = iVar18 + pBuf_len + 8;
      iVar18 = iVar18 + 1;
      *(undefined *)((int)&unaff_s8->length + iVar9 + -8) = *puVar8;
    } while (iVar18 != 8);
  }
  ptVar10 = (frame->txdesc).lmac.hw_desc;
  (ptVar10->thd).field_5 = (ptVar10->thd).field_4 + -1 + uVar14;
  (ptVar10->thd).frmlen = uVar14 + 4;
  if (cfm != (cfm_func_ptr *)0x0) {
    (frame->cfm).cfm_func = cfm;
    (frame->cfm).env = cfm_env;
  }
  txl_frame_push(frame,"\x01"[(frame->txdesc).host.tid]);
  return '\0';
}



void txl_frame_dump(void)

{
  uint32_t uVar1;
  co_list_hdr cVar2;
  co_list_hdr cVar3;
  
  uVar1 = co_list_cnt((co_list *)&txl_frame_env);
  cVar2 = (co_list_hdr)txl_frame_env.desc_free.first;
  if (uVar1 != 0) {
    while (cVar3 = (co_list_hdr)txl_frame_env.desc_done.first, cVar2 != (co_list_hdr)0x0) {
      cVar2 = *(co_list_hdr *)cVar2;
    }
    while (cVar3 != (co_list_hdr)0x0) {
      cVar3 = *(co_list_hdr *)cVar3;
    }
  }
  return;
}



void txl_hwdesc_init(void)

{
  return;
}



void txl_hwdesc_reset(void)

{
  return;
}



void vif_mgmt_bcn_to_evt(void *env)

{
  if (*(int *)((int)env + 0x40) != 0) {
    chan_bcn_to_evt((vif_info_tag *)env);
    return;
  }
  return;
}



void vif_mgmt_init(void)

{
  memset(&vif_mgmt_env,0,0x14);
  co_list_init((co_list *)&vif_mgmt_env);
  co_list_init(&vif_mgmt_env.used_list);
  memset(vif_info_tab,0,0x5d8);
  vif_info_tab[0].type = '\x04';
  vif_info_tab[0].tx_power = '\x7f';
  vif_info_tab[0].user_tx_power = '\x7f';
  vif_info_tab[0].tmr_bcn_to.cb = vif_mgmt_bcn_to_evt;
  vif_info_tab[0].tmr_bcn_to.env = vif_info_tab;
  co_list_push_back((co_list *)&vif_mgmt_env,(co_list_hdr *)vif_info_tab);
  memset(vif_info_tab + 1,0,0x5d8);
  vif_info_tab[1].type = '\x04';
  vif_info_tab[1].tx_power = '\x7f';
  vif_info_tab[1].user_tx_power = '\x7f';
  vif_info_tab[1].tmr_bcn_to.cb = vif_mgmt_bcn_to_evt;
  vif_info_tab[1].tmr_bcn_to.env = vif_info_tab + 1;
  co_list_push_back((co_list *)&vif_mgmt_env,(co_list_hdr *)(vif_info_tab + 1));
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t vif_mgmt_register(mac_addr_conflict38 *mac_addr,uint8_t vif_type,_Bool p2p,uint8_t *vif_idx)

{
  uint8_t uVar1;
  vif_info_tag *vif_entry;
  undefined3 in_register_0000202d;
  
  if (vif_mgmt_env.free_list.first == (co_list_hdr *)0x0) {
    uVar1 = '\x01';
  }
  else {
    if (vif_mgmt_env.used_list.first == (co_list_hdr *)0x0) {
      mm_hw_info_set((mac_addr_conflict171 *)mac_addr);
    }
    else {
      if (*(int *)mac_addr->array != _DAT_44b00010) {
        return '\x01';
      }
      if (((mac_addr->array[2] ^ _DAT_44b00014) & ~_DAT_44b0001c) != 0) {
        return '\x01';
      }
      mm_env.rx_filter_lmac_enable = mm_env.rx_filter_lmac_enable | 0x10;
      _DAT_44b00060 = mm_env.rx_filter_lmac_enable | mm_env.rx_filter_umac;
    }
    vif_entry = (vif_info_tag *)co_list_pop_front((co_list *)&vif_mgmt_env);
    vif_entry->type = vif_type;
    memcpy(&vif_entry->mac_addr,mac_addr,6);
    uVar1 = (char)((int)(vif_entry[-0xb4b98].u + 0x2ec) >> 3) * 's';
    vif_entry->txq_params[1] = 0xa43;
    vif_entry->txq_params[2] = 0x5e432;
    vif_entry->index = uVar1;
    vif_entry->txq_params[0] = 0xa47;
    vif_entry->txq_params[3] = 0x2f322;
    vif_entry->chan_ctxt = (chan_ctxt_tag *)0x0;
    (vif_entry->tbtt_switch).vif_index = uVar1;
    if (CONCAT31(in_register_0000202d,vif_type) == 0) {
      *(vif_info_tag **)&(vif_entry->tbtt_timer).env = vif_entry;
      vif_entry->u[0x1d] = 0;
      vif_mgmt_env.vif_sta_cnt = vif_mgmt_env.vif_sta_cnt + '\x01';
      (vif_entry->tbtt_timer).cb = mm_sta_tbtt;
      vif_entry->u[4] = 0xff;
      vif_entry->u[0x1e] = 0;
    }
    else {
      if (CONCAT31(in_register_0000202d,vif_type) == 2) {
        if (vif_mgmt_env.vif_ap_cnt == '\0') {
          mm_hw_ap_info_set();
        }
        vif_mgmt_env.vif_ap_cnt = vif_mgmt_env.vif_ap_cnt + '\x01';
        mm_bcn_init_vif(vif_entry);
      }
    }
    td_start(vif_entry->index);
    *vif_idx = vif_entry->index;
    co_list_push_back(&vif_mgmt_env.used_list,(co_list_hdr *)vif_entry);
    uVar1 = '\0';
  }
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void vif_mgmt_unregister(uint8_t vif_idx)

{
  vif_info_tag *__s;
  undefined3 in_register_00002029;
  int iVar1;
  
  iVar1 = CONCAT31(in_register_00002029,vif_idx);
  __s = vif_info_tab + iVar1;
  co_list_extract(&vif_mgmt_env.used_list,(co_list_hdr *)__s);
  if (vif_info_tab[iVar1].type == '\0') {
    vif_mgmt_env.vif_sta_cnt = vif_mgmt_env.vif_sta_cnt + -1;
  }
  else {
    if (vif_info_tab[iVar1].type == '\x02') {
      vif_mgmt_env.vif_ap_cnt = vif_mgmt_env.vif_ap_cnt + -1;
      if (vif_mgmt_env.vif_ap_cnt == '\0') {
        mm_hw_ap_info_reset();
      }
    }
  }
  if ((uint)vif_mgmt_env.vif_ap_cnt + (uint)vif_mgmt_env.vif_sta_cnt == 1) {
    mm_env.rx_filter_lmac_enable = mm_env.rx_filter_lmac_enable & 0xffffffef;
    _DAT_44b00060 = mm_env.rx_filter_lmac_enable | mm_env.rx_filter_umac;
    _DAT_44b00020 = vif_mgmt_env.used_list.first[0xe].next;
    _DAT_44b00024 = (uint)*(ushort *)&vif_mgmt_env.used_list.first[0xf].next;
  }
  if (vif_info_tab[iVar1].type == '\x02') {
    txl_cntrl_clear_bcn_ac();
  }
  mm_timer_clear(&vif_info_tab[iVar1].tbtt_timer);
  mm_timer_clear(&vif_info_tab[iVar1].tmr_bcn_to);
  td_reset(vif_info_tab[iVar1].index);
  memset(__s,0,0x5d8);
  vif_info_tab[iVar1].type = '\x04';
  vif_info_tab[iVar1].tx_power = '\x7f';
  vif_info_tab[iVar1].user_tx_power = '\x7f';
  vif_info_tab[iVar1].tmr_bcn_to.cb = vif_mgmt_bcn_to_evt;
  *(vif_info_tag **)&vif_info_tab[iVar1].tmr_bcn_to.env = __s;
  co_list_push_back((co_list *)&vif_mgmt_env,(co_list_hdr *)__s);
  return;
}



void vif_mgmt_add_key(mm_key_add_req *param,uint8_t hw_key_idx)

{
  uint8_t uVar1;
  uint uVar2;
  uint uVar3;
  
  uVar3 = (uint)param->inst_nbr;
  uVar2 = (uint)param->key_idx;
  vif_info_tab[uVar3].key_info[uVar2].hw_key_idx = hw_key_idx;
  vif_info_tab[uVar3].key_info[uVar2].cipher = param->cipher_suite;
  vif_info_tab[uVar3].key_info[uVar2].key_idx = param->key_idx;
  memset(vif_info_tab[uVar3].key_info + uVar2,0,0x48);
  uVar1 = vif_info_tab[uVar3].key_info[uVar2].cipher;
  if (uVar1 == '\x01') {
    *(undefined4 *)&vif_info_tab[uVar3].key_info[uVar2].tx_pn = 0;
    *(undefined4 *)((int)&vif_info_tab[uVar3].key_info[uVar2].tx_pn + 4) = 0;
    *(uint32_t *)vif_info_tab[uVar3].key_info[uVar2].u = (param->key).array[4];
    *(uint32_t *)(vif_info_tab[uVar3].key_info[uVar2].u + 4) = (param->key).array[5];
    *(uint32_t *)(vif_info_tab[uVar3].key_info[uVar2].u + 8) = (param->key).array[6];
    *(uint32_t *)(vif_info_tab[uVar3].key_info[uVar2].u + 0xc) = (param->key).array[7];
  }
  else {
    if ((uVar1 == '\0') || (uVar1 == '\x03')) {
      next = next * 0x41c64e6d + 0x3039;
      *(__uint32_t *)&vif_info_tab[uVar3].key_info[uVar2].tx_pn = next >> 0x10;
      *(undefined4 *)((int)&vif_info_tab[uVar3].key_info[uVar2].tx_pn + 4) = 0;
    }
    else {
      *(undefined4 *)&vif_info_tab[uVar3].key_info[uVar2].tx_pn = 0;
      *(undefined4 *)((int)&vif_info_tab[uVar3].key_info[uVar2].tx_pn + 4) = 0;
    }
  }
  vif_info_tab[uVar3].key_info[uVar2].valid = true;
  vif_info_tab[uVar3].default_key = vif_info_tab[uVar3].key_info + uVar2;
  return;
}



void vif_mgmt_del_key(vif_info_tag *vif,uint8_t keyid)

{
  undefined3 in_register_0000202d;
  _Bool *p_Var1;
  int iVar2;
  
  vif->key_info[CONCAT31(in_register_0000202d,keyid)].valid = false;
  if (vif->default_key == vif->key_info + CONCAT31(in_register_0000202d,keyid)) {
    vif->default_key = (key_info_tag *)0x0;
    p_Var1 = &vif->key_info[0].valid;
    iVar2 = 0;
    do {
      if (*p_Var1 != false) {
        vif->default_key = vif->key_info + iVar2;
        return;
      }
      iVar2 = iVar2 + 1;
      p_Var1 = p_Var1 + 0x68;
    } while (iVar2 != 4);
  }
  return;
}



// WARNING: Type propagation algorithm not settling

void vif_mgmt_send_postponed_frame(vif_info_tag *p_vif_entry)

{
  sta_info_tag *p_sta_entry;
  
  p_sta_entry = (sta_info_tag *)(p_vif_entry->sta_list).first;
  while (p_sta_entry != (sta_info_tag *)0x0) {
    sta_mgmt_send_postponed_frame(p_vif_entry,p_sta_entry,0);
    p_sta_entry = *(sta_info_tag **)&p_sta_entry->list_hdr;
  }
  return;
}



// WARNING: Type propagation algorithm not settling

void vif_mgmt_reset(void)

{
  vif_info_tag *p_vif_entry;
  
  p_vif_entry = (vif_info_tag *)vif_mgmt_env.used_list.first;
  while (p_vif_entry != (vif_info_tag *)0x0) {
    vif_mgmt_send_postponed_frame(p_vif_entry);
    p_vif_entry = *(vif_info_tag **)&p_vif_entry->list_hdr;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void vif_mgmt_bcn_to_prog(vif_info_tag *p_vif_entry)

{
  mm_timer_set(&p_vif_entry->tmr_bcn_to,_DAT_44b00120 + 10000);
  return;
}



void vif_mgmt_bcn_recv(vif_info_tag *p_vif_entry)

{
  if (((ps_env.ps_on != false) && ((ps_env.prevent_sleep & 8) == 0)) &&
     (p_vif_entry->prevent_sleep == 0)) {
    mm_timer_clear(&p_vif_entry->tmr_bcn_to);
    vif_mgmt_bcn_to_evt(p_vif_entry);
    return;
  }
  return;
}


/*
Unable to decompile 'vif_mgmt_set_ap_bcn_int'
Cause: Exception while decompiling 2304b1b4: Decompiler process died

*/


// WARNING: Variable defined which should be unmapped: chan_idx
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void vif_mgmt_switch_channel(vif_info_tag *p_vif_entry)

{
  byte bVar1;
  uint16_t freq;
  uint8_t uVar2;
  void *pvVar3;
  scan_chan_tag *psVar4;
  undefined3 extraout_var;
  uint8_t chan_idx_00;
  uint8_t local_11 [4];
  uint8_t chan_idx;
  
  pvVar3 = ke_msg_alloc(0x58,0xd,0,3);
  local_11[0] = -1;
  chan_ctxt_unlink(p_vif_entry->index);
  freq = (p_vif_entry->csa_channel).prim20_freq;
  chan_idx_00 = (uint8_t)freq;
  psVar4 = me_freq_to_chan_ptr((p_vif_entry->csa_channel).band,freq);
  freq = (p_vif_entry->csa_channel).center1_freq;
  (p_vif_entry->bss_info).chan = psVar4;
  (p_vif_entry->bss_info).center_freq1 = freq;
  (p_vif_entry->bss_info).center_freq2 = (p_vif_entry->csa_channel).center2_freq;
  uVar2 = (p_vif_entry->csa_channel).type;
  (p_vif_entry->bss_info).phy_bw = uVar2;
  if (uVar2 == '\x04') {
    uVar2 = '\x03';
  }
  (p_vif_entry->bss_info).bw = uVar2;
  if (psVar4 == (scan_chan_tag *)0x0) {
    ebreak();
  }
  else {
    (p_vif_entry->csa_channel).tx_power = psVar4->tx_power;
    uVar2 = chan_ctxt_add(&p_vif_entry->csa_channel,local_11);
    psVar4 = (scan_chan_tag *)CONCAT31(extraout_var,uVar2);
    *(uint8_t *)((int)pvVar3 + 1) = uVar2;
    *(uint8_t *)((int)pvVar3 + 2) = local_11[0];
    chan_idx_00 = local_11[0];
    if (p_vif_entry->type != '\0') {
      if ((p_vif_entry->type == '\x02') &&
         (p_vif_entry->u[0x2eb] = 0, psVar4 == (scan_chan_tag *)0x0)) {
        chan_ctxt_link(p_vif_entry->index,local_11[0]);
        mm_bcn_env.update_ongoing = true;
      }
      goto LAB_2304b332;
    }
  }
  p_vif_entry->u[0x1d] = 0;
  if (psVar4 == (scan_chan_tag *)0x0) {
    bVar1 = p_vif_entry->u[4];
    chan_ctxt_link(p_vif_entry->index,chan_idx_00);
    mm_timer_clear(&p_vif_entry->tmr_bcn_to);
    mm_timer_set(&p_vif_entry->tbtt_timer,_DAT_44b00120 + sta_info_tab[bVar1].bcn_int);
    p_vif_entry->u[0x18] = 0;
    p_vif_entry->u[0x1e] = 1;
  }
  else {
    mm_send_connection_loss_ind(p_vif_entry);
  }
LAB_2304b332:
  ke_msg_send(pvVar3);
  return;
}



vif_info_tag * vif_mgmt_get_first_ap_inf(void)

{
  co_list_hdr cVar1;
  co_list_hdr cVar2;
  
  cVar1 = (co_list_hdr)vif_mgmt_env.used_list.first;
  cVar2 = (co_list_hdr)0x0;
  if (vif_mgmt_env.vif_ap_cnt != '\0') {
    while ((cVar2 = cVar1, cVar1 != (co_list_hdr)0x0 && (*(char *)((int)cVar1 + 0x56) != '\x02'))) {
      cVar1 = *(co_list_hdr *)cVar1;
    }
  }
  return (vif_info_tag *)cVar2;
}



void me_init(void)

{
  memset(&me_env,0,0x134);
  ke_state_set(5,0);
  scanu_init();
  apm_init();
  sm_init();
  bam_init();
  return;
}



scan_chan_tag * me_freq_to_chan_ptr(uint8_t band,uint16_t freq)

{
  int iVar1;
  byte bVar2;
  ushort *puVar3;
  undefined3 in_register_00002029;
  scan_chan_tag *psVar4;
  undefined2 in_register_0000202e;
  scan_chan_tag *psVar5;
  
  if (CONCAT31(in_register_00002029,band) == 0) {
    iVar1 = -0x714;
    bVar2 = me_env.chan.chan2G4_cnt;
  }
  else {
    iVar1 = -0x6c0;
    bVar2 = me_env.chan.chan5G_cnt;
  }
  psVar5 = (scan_chan_tag *)(ke_mem_heap + iVar1 + 0x290);
  do {
    if (psVar5 == (scan_chan_tag *)(ke_mem_heap + iVar1 + 0x290) + bVar2) {
      return (scan_chan_tag *)0x0;
    }
    psVar4 = psVar5;
    puVar3 = &psVar5->freq;
    psVar5 = psVar5 + 1;
  } while ((uint)*puVar3 != CONCAT22(in_register_0000202e,freq));
  return psVar4;
}



void michael_block(mic_calc *mic_calc_ptr,uint32_t block)

{
  uint uVar1;
  uint uVar2;
  
  uVar1 = block ^ mic_calc_ptr->mic_key_least;
  uVar2 = mic_calc_ptr->mic_key_most ^ (uVar1 >> 0xf | uVar1 << 0x11);
  uVar1 = uVar1 + uVar2;
  uVar2 = (uVar1 >> 8 & 0xff00ff | uVar1 * 0x100 & 0xff00ff00) ^ uVar2;
  uVar1 = uVar1 + uVar2;
  uVar2 = (uVar1 * 8 | uVar1 >> 0x1d) ^ uVar2;
  uVar1 = uVar1 + uVar2;
  uVar2 = (uVar1 >> 2 | uVar1 * 0x40000000) ^ uVar2;
  mic_calc_ptr->mic_key_most = uVar2;
  mic_calc_ptr->mic_key_least = uVar1 + uVar2;
  return;
}



void me_mic_init(mic_calc *mic_calc_ptr,uint32_t *mic_key_ptr,mac_addr_conflict51 *da,
                mac_addr_conflict51 *sa,uint8_t tid)

{
  uint32_t block;
  uint16_t uVar1;
  uint16_t uVar2;
  uint32_t block_00;
  undefined3 in_register_00002039;
  uint32_t uVar3;
  uint32_t block_01;
  
  block = *(uint32_t *)da->array;
  block_01 = (uint)tid & 7;
  uVar1 = sa->array[0];
  uVar2 = da->array[2];
  block_00 = *(uint32_t *)(sa->array + 1);
  if (CONCAT31(in_register_00002039,tid) == 0xff) {
    block_01 = 0;
  }
  mic_calc_ptr->mic_key_least = *mic_key_ptr;
  uVar3 = mic_key_ptr[1];
  mic_calc_ptr->last_m_i = 0;
  mic_calc_ptr->mic_key_most = uVar3;
  mic_calc_ptr->last_m_i_len = '\0';
  michael_block(mic_calc_ptr,block);
  michael_block(mic_calc_ptr,CONCAT22(uVar1,uVar2));
  michael_block(mic_calc_ptr,block_00);
  michael_block(mic_calc_ptr,block_01);
  return;
}



void me_mic_calc(mic_calc *mic_calc_ptr,uint32_t start_ptr,uint32_t data_len)

{
  uint8_t uVar1;
  uint block;
  uint block_00;
  uint uVar2;
  uint uVar3;
  uint *puVar4;
  uint uVar5;
  uint uVar6;
  uint *puVar7;
  uint uVar8;
  
  puVar7 = (uint *)(start_ptr & 0xfffffffc) + 1;
  block = 4 - (start_ptr & 3) & 0xff;
  uVar3 = (uint)mic_calc_ptr->last_m_i_len;
  uVar2 = *(uint *)(start_ptr & 0xfffffffc) >> ((start_ptr & 3) << 3);
  uVar8 = data_len - block;
  if (data_len < block) {
    uVar2 = uVar2 & 0xffffffffU >> ((4 - data_len) * 8 & 0x1f);
    block = data_len & 0xff;
    uVar8 = 0;
  }
  block = block + uVar3;
  block_00 = uVar2 << ((uVar3 & 3) << 3) | mic_calc_ptr->last_m_i;
  uVar6 = block_00;
  if (3 < block) {
    uVar3 = (4 - uVar3) * 8;
    uVar6 = 0;
    if (uVar3 != 0x20) {
      uVar6 = uVar2 >> (uVar3 & 0x1f);
    }
    block = block - 4;
    michael_block(mic_calc_ptr,block_00);
  }
  uVar1 = (uint8_t)block;
  uVar2 = (4 - block) * 8;
  uVar3 = 0;
  puVar4 = puVar7;
  while (uVar8 >> 2 != uVar3) {
    uVar5 = *puVar4;
    puVar4 = puVar4 + 1;
    block_00 = uVar5 << (block << 3 & 0x1f) | uVar6;
    uVar6 = 0;
    if (uVar2 != 0x20) {
      uVar6 = uVar5 >> (uVar2 & 0x1f);
    }
    michael_block(mic_calc_ptr,block_00);
    uVar3 = uVar3 + 1;
  }
  if ((uVar8 & 0xfffffffc) < uVar8) {
    block_00 = (4 - (uVar8 & 3)) * 8;
    uVar3 = 0;
    if (block_00 != 0x20) {
      uVar3 = 0xffffffff >> (block_00 & 0x1f);
    }
    uVar3 = *(uint *)((int)puVar7 + (uVar8 & 0xfffffffc)) & uVar3;
    uVar8 = block + (uVar8 & 3);
    uVar1 = (uint8_t)uVar8;
    block = uVar6 | uVar3 << (block << 3 & 0x1f);
    uVar6 = block;
    if (3 < uVar8) {
      uVar6 = 0;
      if (uVar2 != 0x20) {
        uVar6 = uVar3 >> (uVar2 & 0x1f);
      }
      uVar1 = uVar1 + -4;
      michael_block(mic_calc_ptr,block);
    }
  }
  mic_calc_ptr->last_m_i_len = uVar1;
  mic_calc_ptr->last_m_i = uVar6;
  return;
}



void me_mic_end(mic_calc *mic_calc_ptr)

{
  uint uVar1;
  
  uVar1 = mic_calc_ptr->last_m_i;
  if (3 < mic_calc_ptr->last_m_i_len) {
    assert_err("mic_calc_ptr->last_m_i_len < 4","module",0x13e);
  }
  michael_block(mic_calc_ptr,0x5a << (((uint)mic_calc_ptr->last_m_i_len & 3) << 3) | uVar1);
  michael_block(mic_calc_ptr,0);
  return;
}



uint8_t rxu_cntrl_machdr_len_get(uint16_t frame_cntl)

{
  uint8_t uVar1;
  
  uVar1 = '\x18';
  if ((frame_cntl & 0x300) == 0x300) {
    uVar1 = '\x1e';
  }
  if ((frame_cntl & 0xfc) == 0x88) {
    uVar1 = uVar1 + '\x02';
  }
  if ((short)frame_cntl < 0) {
    uVar1 = uVar1 + '\x04';
  }
  return uVar1;
}



_Bool rxu_cntrl_protected_handle(uint8_t *frame,uint32_t statinfo)

{
  ushort *puVar1;
  uint uVar2;
  vif_info_tag *pvVar3;
  int iVar4;
  
  uVar2 = statinfo & 0x1c;
  puVar1 = (ushort *)(frame + DAT_4201cae8);
  if (uVar2 == 0x18) {
    DAT_4201cae8 = DAT_4201cae8 + 8;
    DAT_4201caf4 = (uint)puVar1[3];
    DAT_4201caf0 = (uint)puVar1[2] << 0x10 | (uint)*(byte *)(puVar1 + 1) |
                   ((uint)*puVar1 & 0xff) << 8;
    DAT_4201cb10 = DAT_4201cb10 | 3;
    if ((statinfo & 0x400) == 0) {
      iVar4 = (uint)DAT_4201cae9 * 0x1b0 + 0x40;
      pvVar3 = (vif_info_tag *)sta_info_tab;
    }
    else {
      iVar4 = (uint)(puVar1[1] >> 0xe) * 0x68 + (uint)DAT_4201caea * 0x5d8 + 0x420;
      pvVar3 = vif_info_tab;
    }
    key = (key_info_tag *)((int)&(pvVar3->list_hdr).next + iVar4);
  }
  else {
    if (uVar2 == 0x1c) {
      if ((statinfo & 0x400) == 0) {
        iVar4 = (uint)DAT_4201cae9 * 0x1b0 + 0x40;
        pvVar3 = (vif_info_tag *)sta_info_tab;
      }
      else {
        iVar4 = (uint)(puVar1[1] >> 0xe) * 0x68 + (uint)DAT_4201caea * 0x5d8 + 0x420;
        pvVar3 = vif_info_tab;
      }
      key = (key_info_tag *)((int)&(pvVar3->list_hdr).next + iVar4);
      DAT_4201cae8 = DAT_4201cae8 + 8;
      DAT_4201caf4 = (uint)puVar1[3];
      DAT_4201caf0 = CONCAT22(puVar1[2],*puVar1);
      DAT_4201cb10 = DAT_4201cb10 | 2;
    }
    else {
      if (uVar2 != 0x14) {
        return false;
      }
      DAT_4201cae8 = DAT_4201cae8 + 4;
    }
  }
  return true;
}


/*
Unable to decompile 'rxu_mpdu_upload_and_indicate'
Cause: Exception while decompiling 2304b7e6: Decompiler process died

*/


undefined4 rxu_mgt_frame_check(rx_swdesc *param_1,uint param_2)

{
  char cVar1;
  ushort length;
  bool bVar2;
  ushort uVar3;
  int8_t iVar4;
  ushort *bcn_addr;
  ushort uVar5;
  _Bool _Var6;
  ke_state_t kVar7;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined2 *puVar8;
  byte sta_idx;
  byte bw;
  uint8_t nss;
  co_list_hdr cVar9;
  char *pcVar10;
  uint uVar11;
  uint uVar12;
  ke_task_id_t dest_id;
  rx_dmadesc *prVar13;
  uint uVar14;
  vif_info_tag *vif;
  int8_t iStack73;
  phy_channel_info apStack72 [2];
  
  sta_idx = (byte)param_2;
  prVar13 = param_1->dma_hdrdesc;
  iStack73 = '\0';
  bcn_addr = *(ushort **)((prVar13->hd).first_pbd_ptr + 0x18);
  length = *bcn_addr;
  if ((length & 0x400) != 0) {
    return 1;
  }
  if ((*(byte *)(bcn_addr + 0xb) & 0xf) != 0) {
    return 1;
  }
  if ((param_2 == 0xff) && (DAT_4201caea = 0xff, ((prVar13->hd).statinfo & 0x600) == 0)) {
    cVar9 = (co_list_hdr)vif_mgmt_env.used_list.first;
    if (((length == 0xb0) || (bVar2 = true, length == 0)) &&
       ((((bVar2 = true, *(char *)(bcn_addr + 2) == *(char *)(bcn_addr + 8) &&
          (*(char *)((int)bcn_addr + 5) == *(char *)((int)bcn_addr + 0x11))) &&
         (*(char *)(bcn_addr + 3) == *(char *)(bcn_addr + 9))) &&
        ((*(char *)((int)bcn_addr + 7) == *(char *)((int)bcn_addr + 0x13) &&
         (*(char *)(bcn_addr + 4) == *(char *)(bcn_addr + 10))))))) {
      bVar2 = *(char *)((int)bcn_addr + 9) != *(char *)((int)bcn_addr + 0x15);
    }
    while (DAT_4201caea = sta_idx, cVar9 != (co_list_hdr)0x0) {
      if (((*(char *)&((co_list_hdr *)((int)cVar9 + 0x50))->next == *(char *)(bcn_addr + 2)) &&
          (*(char *)((int)cVar9 + 0x51) == *(char *)((int)bcn_addr + 5))) &&
         ((*(char *)((int)cVar9 + 0x52) == *(char *)(bcn_addr + 3) &&
          (((*(char *)((int)cVar9 + 0x53) == *(char *)((int)bcn_addr + 7) &&
            (*(char *)&((co_list_hdr *)((int)cVar9 + 0x54))->next == *(char *)(bcn_addr + 4))) &&
           (*(char *)((int)cVar9 + 0x55) == *(char *)((int)bcn_addr + 9))))))) {
        if (*(char *)((int)cVar9 + 0x56) == '\0') {
          if (bVar2) {
LAB_2304ba24:
            DAT_4201caea = *(byte *)((int)cVar9 + 0x57);
            break;
          }
        }
        else {
          if ((*(char *)((int)cVar9 + 0x56) == '\x02') && (!bVar2)) goto LAB_2304ba24;
        }
      }
      cVar9 = *(co_list_hdr *)cVar9;
    }
  }
  phyif_utils_decode((phyif_utils_recvtable_t *)&(prVar13->hd).recvec1a,&iStack73);
  iVar4 = iStack73;
  bw = DAT_4201cae8;
  uVar3 = *bcn_addr;
  uVar14 = (uint)DAT_4201cae8;
  uVar11 = (uint)DAT_4201caea;
  length = (prVar13->hd).frmlen;
  uVar12 = (uint)length;
  if (DAT_4201caea == 0xff) {
    if (param_2 != uVar11) {
      DAT_4201caea = sta_info_tab[param_2].inst_nbr;
      uVar11 = (uint)DAT_4201caea;
      goto LAB_2304ba72;
    }
    nss = '\x04';
    vif = (vif_info_tag *)0x0;
  }
  else {
LAB_2304ba72:
    vif = vif_info_tab + uVar11;
    nss = vif_info_tab[uVar11].type;
  }
  uVar5 = uVar3 & 0xfc;
  if (uVar5 == 0x50) {
    if (vif == (vif_info_tag *)0x0) goto LAB_2304baae;
    bVar2 = true;
    dest_id = 4;
    goto LAB_2304bbce;
  }
  if (uVar5 < 0x51) {
    if (uVar5 == 0x20) {
LAB_2304bafc:
      _Var6 = apm_embedded_enabled(vif);
      if (CONCAT31(extraout_var,_Var6) == 0) {
LAB_2304baae:
        rxu_mpdu_upload_and_indicate(param_1);
        return 1;
      }
LAB_2304bbca:
      bVar2 = true;
      dest_id = 7;
      goto LAB_2304bbce;
    }
    if (uVar5 < 0x21) {
      if ((uVar3 & 0xfc) == 0) goto LAB_2304bafc;
      if (uVar5 != 0x10) goto LAB_2304baae;
    }
    else {
      if (uVar5 != 0x30) {
        if (uVar5 != 0x40) goto LAB_2304baae;
        goto LAB_2304bafc;
      }
    }
    if (nss != '\0') goto LAB_2304baae;
  }
  else {
    if (uVar5 != 0xb0) {
      if (0xb0 < uVar5) {
        if (uVar5 != 0xc0) {
          if ((uVar5 != 0xd0) || (pcVar10 = (char *)((int)bcn_addr + uVar14), param_2 == 0xff))
          goto LAB_2304baae;
          cVar1 = *pcVar10;
          if (cVar1 == '\a') {
            if (pcVar10[1] == '\0') {
              if ((sta_info_tab[param_2].info.capa_flags & 2) == 0) {
                return 0;
              }
              bw = pcVar10[2];
              nss = -1;
              if (1 < bw) {
                return 0;
              }
            }
            else {
              if (pcVar10[1] != '\x01') goto LAB_2304baae;
              if ((sta_info_tab[param_2].info.capa_flags & 2) == 0) {
                return 0;
              }
              nss = -1;
              if ((pcVar10[2] & 1U) != 0) {
                nss = '\0';
              }
              bw = 0xff;
            }
            me_sta_bw_nss_max_upd(sta_idx,bw,nss);
            return 0;
          }
          if (cVar1 == '\b') {
            if ((int)(uVar12 - uVar14) < 4) {
              return 0;
            }
            if ((DAT_4201caea == 0xff) ||
               ((byte)(vif_info_tab[DAT_4201caea].type | pcVar10[1]) != 0)) goto LAB_2304baae;
            dest_id = 6;
          }
          else {
            if (cVar1 != '\x03') goto LAB_2304baae;
            dest_id = 8;
          }
          bVar2 = false;
          goto LAB_2304bbce;
        }
LAB_2304bb22:
        if (param_2 == 0xff) {
          return 0;
        }
        goto LAB_2304bb2c;
      }
      if (uVar5 != 0x80) {
        if (uVar5 != 0xa0) goto LAB_2304baae;
        goto LAB_2304bb22;
      }
      kVar7 = ke_state_get(4);
      bVar2 = CONCAT31(extraout_var_00,kVar7) != 1;
      if (bVar2) {
        dest_id = 0xff;
      }
      else {
        dest_id = 4;
      }
      bVar2 = !bVar2;
      if (param_2 != 0xff) {
        if (vif->active != false) {
          me_beacon_check(DAT_4201caea,length,(uint32_t)bcn_addr);
        }
LAB_2304bba4:
        if (dest_id != 0xff) goto LAB_2304bbce;
        goto LAB_2304baae;
      }
      kVar7 = ke_state_get(4);
      if ((CONCAT31(extraout_var_01,kVar7) == 1) ||
         (_Var6 = apm_embedded_enabled(vif), CONCAT31(extraout_var_02,_Var6) == 0))
      goto LAB_2304bba4;
      goto LAB_2304bbca;
    }
LAB_2304bb2c:
    if (nss != '\0') goto LAB_2304bafc;
  }
  bVar2 = false;
  dest_id = 6;
LAB_2304bbce:
  puVar8 = (undefined2 *)
           ke_msg_alloc(0x2c00,dest_id,0xb,(uint16_t)((uVar12 + 0x1c) * 0x10000 >> 0x10));
  if (puVar8 != (undefined2 *)0x0) {
    phy_get_channel(apStack72,'\0');
    if (!bVar2) {
      if ((bw & 1) != 0) {
        assert_warn("(machdr_length & 0x1) == 0","module",0x64d);
      }
      uVar12 = uVar12 - uVar14 & 0xffff;
      bcn_addr = (ushort *)((int)bcn_addr + uVar14);
    }
    *puVar8 = (short)uVar12;
    uVar11 = 0;
    while (bw = DAT_4201caea, (uVar12 + 3 & 0xfffffffc) != uVar11) {
      *(undefined4 *)((int)puVar8 + uVar11 + 0x1c) = *(undefined4 *)((int)bcn_addr + uVar11);
      uVar11 = uVar11 + 4;
    }
    puVar8[1] = uVar3;
    *(byte *)((int)puVar8 + 7) = sta_idx;
    *(byte *)(puVar8 + 4) = bw;
    *(int8_t *)(puVar8 + 0xd) = iVar4;
    *(int8_t *)((int)puVar8 + 0x19) = iVar4;
    puVar8[2] = (short)(apStack72[0].info1 >> 0x10);
    *(char *)(puVar8 + 3) = (char)apStack72[0].info1;
    *(undefined *)(puVar8 + 0xc) = *(undefined *)((int)&(prVar13->hd).recvec1c + 3);
    if ((dest_id == 7) && ((uVar3 & 0xfc) == 0)) {
      *(uint32_t *)(puVar8 + 8) = (prVar13->hd).tsflo;
      *(uint32_t *)(puVar8 + 10) = (prVar13->hd).tsfhi;
      *(byte *)((int)puVar8 + 0x1b) = (byte)((prVar13->hd).recvec1a >> 0xc) & 0xf;
    }
    ke_msg_send(puVar8);
  }
  return 0;
}



void rxu_cntrl_init(void)

{
  co_list_init((co_list *)&swdesc);
  co_list_init((co_list *)&DAT_4201cb18);
  co_list_init((co_list *)&DAT_4201cb2c);
  co_list_init((co_list *)&DAT_4201cb34);
  DAT_4201cb42 = 0xffff;
  return;
}


/*
Unable to decompile 'rxu_cntrl_frame_handle'
Cause: Exception while decompiling 2304bda8: Decompiler process died

*/


// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rxu_cntrl_monitor_pm(mac_addr_conflict *addr)

{
  if (DAT_4201cb4f == '\0') {
    _DAT_4201cb48 = addr->array[0];
    _DAT_4201cb4a = addr->array[1];
    _DAT_4201cb4c = addr->array[2];
    _DAT_4201cb4e = 0x100;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t rxu_cntrl_get_pm(void)

{
  _DAT_4201cb4e = 0;
  return DAT_4201cb4e;
}



void rxu_cntrl_evt(int dummy)

{
  ke_evt_clear(0x80000);
  if (swdesc != (rx_swdesc *)0x0) {
    ke_evt_set(0x20000000);
    return;
  }
  return;
}



// WARNING: Variable defined which should be unmapped: pkt

void rxu_swdesc_upload_evt(int arg)

{
  rx_swdesc *swdesc;
  uint uVar1;
  int iVar2;
  uint32_t uVar3;
  uint32_t *puVar4;
  uint32_t *puVar5;
  uint32_t uVar6;
  uint32_t local_48;
  wifi_pkt pkt;
  
  ke_evt_clear(0x20000000);
  swdesc = (rx_swdesc *)co_list_pop_front((co_list *)&swdesc);
  while (swdesc != (rx_swdesc *)0x0) {
    uVar1 = (uint)(swdesc->dma_hdrdesc->hd).frmlen;
    memset(&local_48,0,0x28);
    puVar4 = (uint32_t *)&local_48;
    uVar6 = (swdesc->dma_hdrdesc->hd).first_pbd_ptr;
    puVar5 = puVar4;
    while ((uVar1 != 0 && (puVar5 != pkt.pkt + 3))) {
      swdesc->pbd_count = swdesc->pbd_count + '\x01';
      uVar3 = *(uint32_t *)(uVar6 + 8);
      *puVar5 = uVar3;
      *(short *)(puVar4 + 8) = ((short)*(undefined4 *)(uVar6 + 0xc) + 1) - (short)uVar3;
      puVar5[4] = uVar6 + 0x1c;
      *(undefined4 *)(uVar6 + 0x14) = 1;
      if (uVar1 < 0x350) {
        uVar1 = 0;
      }
      else {
        uVar1 = uVar1 - 0x350;
      }
      uVar6 = *(uint32_t *)(uVar6 + 4);
      puVar5 = puVar5 + 1;
      puVar4 = (uint32_t *)((int)puVar4 + 2);
    }
    swdesc->use_in_tcpip = '\x01';
    swdesc->dma_hdrdesc->use_in_tcpip = 1;
    iVar2 = tcpip_stack_input(swdesc,swdesc->status,&(swdesc->dma_hdrdesc->hd).frmlen,
                              swdesc->dma_hdrdesc->payl_offset,(wifi_pkt *)&local_48);
    if (iVar2 == 0) {
      vTaskEnterCritical();
      rxl_cntrl_env.packet_stack_cnt = rxl_cntrl_env.packet_stack_cnt + swdesc->pbd_count;
      vTaskExitCritical();
    }
    else {
      rxl_mpdu_free(swdesc);
    }
    swdesc = (rx_swdesc *)co_list_pop_front((co_list *)&swdesc);
  }
  return;
}



void scanu_confirm(uint8_t status)

{
  uint8_t *puVar1;
  uint8_t *puVar2;
  
  if (scanu_env.joining == false) {
    puVar2 = (uint8_t *)ke_msg_alloc(0x1001,scanu_env.src_id,4,1);
    puVar1 = (uint8_t *)0x0;
  }
  else {
    puVar2 = (uint8_t *)ke_msg_alloc(0x1003,scanu_env.src_id,4,1);
    puVar1 = (uint8_t *)ke_msg_alloc(0x1003,0xd,4,1);
  }
  *puVar2 = status;
  ke_msg_free(&scanu_env.param[-1].add_ies);
  scanu_env.param = (scanu_start_req *)0x0;
  ke_msg_send(puVar2);
  if (puVar1 != (uint8_t *)0x0) {
    *puVar1 = status;
    ke_msg_send(puVar1);
  }
  ke_state_set(4,0);
  return;
}



void scanu_raw_send_cfm(uint8_t status,ke_task_id_t dst_id)

{
  undefined3 in_register_00002029;
  undefined4 *puVar1;
  
  puVar1 = (undefined4 *)ke_msg_alloc(0x1006,dst_id,4,4);
  *puVar1 = CONCAT31(in_register_00002029,status);
  ke_msg_send();
  return;
}



void scanu_init(void)

{
  ke_state_set(4,0);
  memset(&scanu_env,0,0x194);
  scanu_env.dma_desc.dma_desc = &scanu_add_ie;
  scanu_env.dma_desc.cb = scanu_dma_cb;
  scanu_env.dma_desc.env = (void *)0x0;
  scanu_add_ie.dma_desc.dest = 0x42045ddc;
  return;
}



mac_scan_result * scanu_find_result(mac_addr_conflict *bssid_ptr,_Bool allocate)

{
  undefined3 in_register_0000202d;
  mac_scan_result *pmVar1;
  
  pmVar1 = scanu_env.scan_result;
  do {
    if (pmVar1->valid_flag == false) {
      if (CONCAT31(in_register_0000202d,allocate) != 0) {
        return pmVar1;
      }
    }
    else {
      if ((((*(char *)(pmVar1->bssid).array == *(char *)bssid_ptr->array) &&
           (*(char *)((int)(pmVar1->bssid).array + 1) == *(char *)((int)bssid_ptr->array + 1))) &&
          (*(char *)((pmVar1->bssid).array + 1) == *(char *)(bssid_ptr->array + 1))) &&
         (((*(char *)((int)(pmVar1->bssid).array + 3) == *(char *)((int)bssid_ptr->array + 3) &&
           (*(char *)((pmVar1->bssid).array + 2) == *(char *)(bssid_ptr->array + 2))) &&
          (*(char *)((int)(pmVar1->bssid).array + 5) == *(char *)((int)bssid_ptr->array + 5))))) {
        return pmVar1;
      }
    }
    pmVar1 = pmVar1 + 1;
    if (pmVar1 == (mac_scan_result *)&scanu_env.src_id) {
      return (mac_scan_result *)0x0;
    }
  } while( true );
}



// WARNING: Restarted to delay deadcode elimination for space: ram

undefined4 scanu_frame_handler(ushort *param_1)

{
  undefined uVar1;
  u8_l uVar2;
  uint8_t band;
  _Bool _Var3;
  ushort uVar4;
  scanu_start_req *psVar5;
  sm_connect_req *psVar6;
  ke_state_t kVar7;
  uchar uVar8;
  uint16_t uVar9;
  int iVar10;
  undefined3 extraout_var;
  mac_scan_result *pmVar11;
  scan_chan_tag *psVar12;
  void *__src;
  byte bVar13;
  uint16_t freq;
  uint __n;
  undefined *puVar14;
  u8_l *puVar15;
  undefined *puVar16;
  u8_l *puVar17;
  SecurityMode_t *security_mode;
  char cVar18;
  uint uVar19;
  uint uVar20;
  mac_bss_info *bss;
  int iVar21;
  Cipher_t_conflict *mcstCipher;
  Cipher_t_conflict *mcstCipher_00;
  Cipher_t_conflict *ucstCipher;
  u32_l uVar22;
  mac_ssid *pmVar23;
  uint uVar24;
  ushort *buffer;
  uint8_t *rsn_ie;
  mac_rateset *mac_rate_set_ptr;
  Cipher_t_conflict *ucstCipher_00;
  undefined uStack100;
  undefined local_63 [47];
  
  psVar5 = scanu_env.param;
  buffer = param_1 + 0x20;
  uVar24 = (uint)(scanu_env.param)->vif_idx;
  iVar10 = mac_ie_find(buffer,(uint)*param_1 - 0x24 & 0xffff,0);
  if (iVar10 != 0) {
    bVar13 = *(byte *)(iVar10 + 1);
    uVar19 = (uint)bVar13;
    if (bVar13 < 0x21) {
      if (bVar13 == 0) goto LAB_2304c988;
    }
    else {
      uVar19 = 0x20;
    }
    puVar14 = (undefined *)(iVar10 + 2);
    if (*(char *)(iVar10 + 2) != '\0') {
      uStack100 = (undefined)uVar19;
      puVar16 = &uStack100;
      uVar20 = uVar19;
      while( true ) {
        uVar20 = uVar20 - 1;
        puVar16 = puVar16 + 1;
        if (uVar20 == 0xffffffff) break;
        uVar1 = *puVar14;
        puVar14 = puVar14 + 1;
        *puVar16 = uVar1;
      }
      local_63[uVar19] = 0;
    }
  }
LAB_2304c988:
  kVar7 = ke_state_get(4);
  if (((CONCAT31(extraout_var,kVar7) != 1) ||
      (pmVar11 = scanu_find_result((mac_addr_conflict *)(param_1 + 0x16),true),
      pmVar11 == (mac_scan_result *)0x0)) ||
     ((((byte)scanu_env.bssid.array[0] & 1) == 0 &&
      (((((*(byte *)(param_1 + 0x16) != (byte)scanu_env.bssid.array[0] ||
          (*(char *)((int)param_1 + 0x2d) != scanu_env.bssid.array[0]._1_1_)) ||
         (*(char *)(param_1 + 0x17) != (char)scanu_env.bssid.array[1])) ||
        ((*(char *)((int)param_1 + 0x2f) != scanu_env.bssid.array[1]._1_1_ ||
         (*(char *)(param_1 + 0x18) != (char)scanu_env.bssid.array[2])))) ||
       (*(char *)((int)param_1 + 0x31) != scanu_env.bssid.array[2]._1_1_)))))) goto LAB_2304d0be;
  (pmVar11->bssid).array[0] = param_1[0x16];
  (pmVar11->bssid).array[1] = param_1[0x17];
  (pmVar11->bssid).array[2] = param_1[0x18];
  pmVar11->beacon_period = param_1[0x1e];
  uVar4 = param_1[0x1f];
  pmVar11->cap_info = uVar4;
  freq = uVar4 & 1;
  if ((uVar4 & 1) == 0) {
    freq = 2;
  }
  pmVar11->bsstype = freq;
  uVar4 = *param_1;
  uVar19 = (uint)uVar4 - 0x24 & 0xffff;
  iVar10 = mac_ie_find(buffer,uVar19,0);
  if (iVar10 == 0) {
    (pmVar11->ssid).length = '\0';
  }
  else {
    bVar13 = *(byte *)(iVar10 + 1);
    uVar20 = (uint)bVar13;
    if (bVar13 < 0x21) {
      if (bVar13 == 0) goto LAB_2304ca5c;
    }
    else {
      uVar20 = 0x20;
    }
    puVar17 = (u8_l *)(iVar10 + 2);
    if (*(char *)(iVar10 + 2) != '\0') {
      (pmVar11->ssid).length = (u8_l)uVar20;
      puVar15 = (pmVar11->ssid).array;
      while (uVar20 = uVar20 - 1, uVar20 != 0xffffffff) {
        uVar2 = *puVar17;
        puVar17 = puVar17 + 1;
        *puVar15 = uVar2;
        puVar15 = puVar15 + 1;
      }
    }
  }
LAB_2304ca5c:
  pmVar11->ppm_rel = *(int8_t *)(param_1 + 0xd);
  pmVar11->ppm_abs = *(int8_t *)((int)param_1 + 0x19);
  if (psVar5->ssid_cnt != '\0') {
    uVar20 = 0;
    pmVar23 = psVar5->ssid;
    while ((int)uVar20 < (int)(uint)psVar5->ssid_cnt) {
      if (pmVar23->length == 0) goto LAB_2304cafa;
      __n = (uint)(pmVar11->ssid).length;
      if ((__n == (uint)pmVar23->length) &&
         (iVar10 = memcmp(pmVar23->array,(pmVar11->ssid).array,__n), iVar10 == 0)) break;
      uVar20 = uVar20 + 1;
      pmVar23 = pmVar23 + 1;
    }
    if ((uint)psVar5->ssid_cnt == uVar20) goto LAB_2304d0be;
  }
LAB_2304cafa:
  iVar10 = mac_ie_find(buffer,uVar19,3);
  if (iVar10 == 0) {
    if (pmVar11->rssi < *(char *)(param_1 + 0xc)) {
      psVar12 = me_freq_to_chan_ptr(*(uint8_t *)(param_1 + 3),param_1[2]);
      pmVar11->chan = psVar12;
      cVar18 = *(char *)(param_1 + 0xc);
      goto LAB_2304cb4a;
    }
  }
  else {
    bVar13 = *(byte *)(iVar10 + 2);
    band = *(uint8_t *)(param_1 + 3);
    if (band == '\0') {
      if ((uint)bVar13 - 1 < 0xe) {
        if (bVar13 == 0xe) {
          freq = 0x9b4;
        }
        else {
          freq = (ushort)bVar13 * 5 + 0x967;
        }
      }
      else {
LAB_2304cfa8:
        freq = 0xffff;
      }
    }
    else {
      if ((band != '\x01') || (0xa4 < (uint)bVar13 - 1)) goto LAB_2304cfa8;
      freq = (ushort)bVar13 * 5 + 5000;
    }
    psVar12 = me_freq_to_chan_ptr(band,freq);
    pmVar11->chan = psVar12;
    cVar18 = *(char *)(param_1 + 0xc);
    if (pmVar11->rssi < cVar18) {
LAB_2304cb4a:
      pmVar11->rssi = cVar18;
    }
  }
  if (scanu_env.joining != false) {
    bss = &vif_info_tab[uVar24].bss_info;
    vif_info_tab[uVar24].bss_info.bsstype = pmVar11->bsstype;
    mac_rate_set_ptr = &vif_info_tab[uVar24].bss_info.rate_set;
    *(undefined4 *)vif_info_tab[uVar24].bss_info.bssid.array = *(undefined4 *)(pmVar11->bssid).array
    ;
    vif_info_tab[uVar24].bss_info.bssid.array[2] = (pmVar11->bssid).array[2];
    vif_info_tab[uVar24].bss_info.cap_info = pmVar11->cap_info;
    vif_info_tab[uVar24].bss_info.beacon_period = pmVar11->beacon_period;
    memcpy(&vif_info_tab[uVar24].bss_info.ssid,&pmVar11->ssid,0x22);
    psVar12 = pmVar11->chan;
    vif_info_tab[uVar24].bss_info.valid_flags = 0;
    vif_info_tab[uVar24].bss_info.chan = psVar12;
    vif_info_tab[uVar24].bss_info.ppm_rel = pmVar11->ppm_rel;
    vif_info_tab[uVar24].bss_info.ppm_abs = pmVar11->ppm_abs;
    freq = (uint16_t)(((uint)uVar4 - 0x24) * 0x10000 >> 0x10);
    me_extract_rate_set((uint32_t)buffer,freq,mac_rate_set_ptr);
    if (pmVar11->chan->band == '\0') {
      uVar9 = me_legacy_rate_bitfield_build(mac_rate_set_ptr,true);
      if ((uVar9 & 0xf) == 0) {
        vif_info_tab[uVar24].bss_info.high_11b_rate = '\x01';
      }
      else {
        iVar10 = __clzsi2((uint)uVar9 & 0xf);
        vif_info_tab[uVar24].bss_info.high_11b_rate = '\x1f' - (char)iVar10;
      }
    }
    iVar10 = mac_vsie_find(buffer,uVar19,&DAT_2307bbfc,5);
    if (iVar10 == 0) {
      vif_info_tab[uVar24].bss_info.edca_param.ac_param[0] = 0xa43;
      vif_info_tab[uVar24].bss_info.edca_param.ac_param[1] = 0xa43;
      vif_info_tab[uVar24].bss_info.edca_param.ac_param[2] = 0xa43;
      vif_info_tab[uVar24].bss_info.edca_param.ac_param[3] = 0xa43;
    }
    else {
      vif_info_tab[uVar24].bss_info.edca_param.qos_info = *(uint8_t *)(iVar10 + 8);
      vif_info_tab[uVar24].bss_info.cap_info = vif_info_tab[uVar24].bss_info.cap_info | 0x200;
      uVar20 = *(uint *)(iVar10 + 10);
      bVar13 = (byte)(uVar20 >> 3) & 2;
      vif_info_tab[uVar24].bss_info.edca_param.acm = bVar13;
      vif_info_tab[uVar24].bss_info.edca_param.ac_param[1] = uVar20 & 0xf | (uVar20 >> 8) << 4;
      uVar20 = *(uint *)(iVar10 + 0xe);
      bVar13 = (byte)(uVar20 >> 4) & 1 | bVar13;
      vif_info_tab[uVar24].bss_info.edca_param.acm = bVar13;
      vif_info_tab[uVar24].bss_info.edca_param.ac_param[0] = uVar20 & 0xf | (uVar20 >> 8) << 4;
      uVar20 = *(uint *)(iVar10 + 0x12);
      bVar13 = bVar13 | (byte)(uVar20 >> 2) & 4;
      vif_info_tab[uVar24].bss_info.edca_param.acm = bVar13;
      vif_info_tab[uVar24].bss_info.edca_param.ac_param[2] = uVar20 & 0xf | (uVar20 >> 8) << 4;
      uVar20 = *(uint *)(iVar10 + 0x16);
      vif_info_tab[uVar24].bss_info.edca_param.acm = bVar13 | (byte)(uVar20 >> 1) & 8;
      __n = vif_info_tab[uVar24].bss_info.valid_flags;
      vif_info_tab[uVar24].bss_info.edca_param.ac_param[3] = uVar20 & 0xf | (uVar20 >> 8) << 4;
      vif_info_tab[uVar24].bss_info.valid_flags = __n | 1;
    }
    uVar20 = 0;
    if (me_env.ht_supported != false) {
      uVar20 = vif_info_tab[uVar24].bss_info.valid_flags & 1;
      if (uVar20 != 0) {
        iVar10 = mac_ie_find(buffer,uVar19,0x2d);
        if (iVar10 != 0) {
          vif_info_tab[uVar24].bss_info.ht_cap.ht_capa_info = *(u16_l *)(iVar10 + 2);
          vif_info_tab[uVar24].bss_info.ht_cap.a_mpdu_param = *(u8_l *)(iVar10 + 4);
          iVar21 = 0;
          do {
            vif_info_tab[uVar24].bss_info.ht_cap.mcs_rate[iVar21] = *(u8_l *)(iVar10 + 5 + iVar21);
            iVar21 = iVar21 + 1;
          } while (iVar21 != 0x10);
          vif_info_tab[uVar24].bss_info.ht_cap.ht_extended_capa = *(u16_l *)(iVar10 + 0x15);
          vif_info_tab[uVar24].bss_info.ht_cap.tx_beamforming_capa =
               (uint)*(ushort *)(iVar10 + 0x17);
          vif_info_tab[uVar24].bss_info.ht_cap.asel_capa = *(u8_l *)(iVar10 + 0x1b);
          vif_info_tab[uVar24].bss_info.valid_flags = vif_info_tab[uVar24].bss_info.valid_flags | 2;
        }
        uVar20 = mac_ie_find(buffer,uVar19,0x3d);
      }
    }
    _Var3 = (sm_env.connect_param)->is_supplicant_enabled;
    vif_info_tab[uVar24].bss_info.is_supplicant_enabled = _Var3;
    if ((_Var3 != false) && (-1 < (int)vif_info_tab[uVar24].bss_info.valid_flags)) {
      security_mode = &vif_info_tab[uVar24].bss_info.wpa_wpa2_wep;
      memset(security_mode,0,2);
      mcstCipher = &vif_info_tab[uVar24].bss_info.rsn_mcstCipher;
      ucstCipher_00 = &vif_info_tab[uVar24].bss_info.rsn_ucstCipher;
      memset(mcstCipher,0,1);
      memset(ucstCipher_00,0,1);
      mcstCipher_00 = &vif_info_tab[uVar24].bss_info.wpa_mcstCipher;
      memset(mcstCipher_00,0,1);
      ucstCipher = &vif_info_tab[uVar24].bss_info.wpa_ucstCipher;
      memset(ucstCipher,0,1);
      vif_info_tab[uVar24].bss_info.rsn_wpa_ie_len = '\0';
      vif_info_tab[uVar24].bss_info.is_pmf_required = false;
      vif_info_tab[uVar24].bss_info.is_wpa2_prefered = false;
      __src = (void *)mac_ie_find(buffer,uVar19,0x30);
      rsn_ie = vif_info_tab[uVar24].bss_info.rsn_wpa_ie;
      if (__src != (void *)0x0) {
        __n = (uint)*(byte *)((int)__src + 1) + 2 & 0xff;
        vif_info_tab[uVar24].bss_info.rsn_wpa_ie_len = (uint8_t)__n;
        memcpy(rsn_ie,__src,__n);
        uVar8 = process_rsn_ie(rsn_ie,mcstCipher,ucstCipher_00,
                               &vif_info_tab[uVar24].bss_info.is_pmf_required,security_mode,
                               *(_Bool *)(uVar24 * 0x5d8 + 0x4201c0e8));
        __n = *(uint *)&vif_info_tab[uVar24].bss_info.wpa_ucstCipher;
        vif_info_tab[uVar24].bss_info.rsn_wpa_ie_len = uVar8;
        printf("wpa2/wpa3 pairwise ccmp:%d,tkip:%d,wep104:%d,wep:40:%d\r\n",__n >> 0x13 & 1,
               __n >> 0x12 & 1,__n >> 0x11 & 1,__n >> 0x10 & 1);
        __n = *(uint *)&vif_info_tab[uVar24].bss_info.wpa_ucstCipher;
        printf("wpa2/wpa3 group ccmp:%d,tkip:%d,wep104:%d,wep:40:%d\r\n",__n >> 0xb & 1,
               __n >> 10 & 1,__n >> 9 & 1,__n >> 8 & 1);
        printf("wpa2/wpa3 is_pmf_required:%d\r\n",
               (uint)vif_info_tab[uVar24].bss_info.is_pmf_required);
      }
      __src = (void *)mac_vsie_find(buffer,uVar19,&DAT_2307bc04,4);
      if (__src != (void *)0x0) {
        *(byte *)&vif_info_tab[uVar24].bss_info.wpa_wpa2_wep =
             *(byte *)&vif_info_tab[uVar24].bss_info.wpa_wpa2_wep | 8;
        if (vif_info_tab[uVar24].bss_info.rsn_wpa_ie_len == '\0') {
          __n = (uint)*(byte *)((int)__src + 1) + 2 & 0xff;
          vif_info_tab[uVar24].bss_info.rsn_wpa_ie_len = (uint8_t)__n;
          memcpy(rsn_ie,__src,__n);
          uVar8 = process_wpa_ie(rsn_ie,mcstCipher_00,ucstCipher);
          vif_info_tab[uVar24].bss_info.rsn_wpa_ie_len = uVar8;
        }
      }
      psVar6 = sm_env.connect_param;
      (sm_env.connect_param)->flags = 0;
      if ((*(uint *)&vif_info_tab[uVar24].bss_info.is_supplicant_enabled & 0x12800) == 0) {
        if ((vif_info_tab[uVar24].bss_info.cap_info & 0x10) == 0) {
          uVar22 = 2;
          goto LAB_2304cf7a;
        }
        *(byte *)&vif_info_tab[uVar24].bss_info.wpa_wpa2_wep =
             *(byte *)&vif_info_tab[uVar24].bss_info.wpa_wpa2_wep | 2;
        psVar6->auth_type = '\x01';
      }
      else {
        uVar22 = 9;
LAB_2304cf7a:
        psVar6->flags = uVar22;
      }
      memcpy(psVar6->ie_buf,rsn_ie,(uint)vif_info_tab[uVar24].bss_info.rsn_wpa_ie_len);
      (sm_env.connect_param)->ie_len = (ushort)vif_info_tab[uVar24].bss_info.rsn_wpa_ie_len;
      __n = *(uint *)&vif_info_tab[uVar24].bss_info.is_supplicant_enabled;
      printf("AP Security mode: wep:%d,wpa:%d,wpa2:%d,wpa3:%d\r\n",__n >> 9 & 1,__n >> 0xb & 1,
             __n >> 0xd & 1,__n >> 0x10 & 1);
    }
    me_bw_check(uVar20,0,bss);
    me_extract_power_constraint((uint32_t)buffer,freq,bss);
    me_extract_country_reg(buffer,uVar19,bss);
    me_extract_mobility_domain((uint32_t)buffer,freq,bss);
    vif_info_tab[uVar24].bss_info.valid_flags =
         vif_info_tab[uVar24].bss_info.valid_flags | 0x80000000;
  }
  if (pmVar11->valid_flag == false) {
    scanu_env.result_cnt = scanu_env.result_cnt + 1;
  }
  if (psVar5->ssid_cnt != '\0') {
    pmVar11->valid_flag = true;
  }
LAB_2304d0be:
  ke_msg_forward_and_change_id(param_1,0x1004,0xd,4);
  return 1;
}



mac_scan_result * scanu_search_by_bssid(mac_addr_conflict *bssid)

{
  mac_scan_result *pmVar1;
  
  pmVar1 = scanu_find_result(bssid,false);
  return pmVar1;
}



mac_scan_result * scanu_search_by_ssid(mac_ssid *ssid,int *idx)

{
  scanu_env_tag_conflict *psVar1;
  int iVar2;
  int iVar3;
  mac_scan_result *pmVar4;
  int8_t iVar5;
  
  pmVar4 = (mac_scan_result *)0x0;
  if (ssid->length != '\0') {
    psVar1 = &scanu_env;
    iVar3 = 0;
    pmVar4 = (mac_scan_result *)0x0;
    iVar5 = -0x80;
    do {
      if (psVar1->scan_result[0].valid_flag == false) {
        return pmVar4;
      }
      if (((iVar5 < psVar1->scan_result[0].rssi) &&
          ((uint)ssid->length == (uint)psVar1->scan_result[0].ssid.length)) &&
         (iVar2 = memcmp(psVar1->scan_result[0].ssid.array,ssid->array,(uint)ssid->length),
         iVar2 == 0)) {
        iVar5 = psVar1->scan_result[0].rssi;
        pmVar4 = psVar1->scan_result;
        *idx = iVar3;
      }
      iVar3 = iVar3 + 1;
      psVar1 = (scanu_env_tag_conflict *)(psVar1->scan_result[0].ssid.array + 0x19);
    } while (iVar3 != 6);
  }
  return pmVar4;
}



void scanu_rm_exist_ssid(mac_ssid *ssid,int index)

{
  int iVar1;
  
  if ((index < 0) || (ssid == (mac_ssid *)0x0)) {
    return;
  }
  if (((scanu_env.scan_result[index].valid_flag != false) &&
      ((uint)ssid->length == (uint)scanu_env.scan_result[index].ssid.length)) &&
     (iVar1 = memcmp(scanu_env.scan_result[index].ssid.array,ssid->array,(uint)ssid->length),
     iVar1 == 0)) {
    memset(scanu_env.scan_result + index,0,0x38);
    return;
  }
  return;
}



void scanu_scan_next(void)

{
  byte bVar1;
  int iVar2;
  scanu_start_req *psVar3;
  uint uVar4;
  void *pvVar5;
  uint uVar6;
  uint8_t *puVar7;
  undefined *puVar8;
  undefined *puVar9;
  uint32_t *puVar10;
  u8_l *puVar11;
  me_env_tag *pmVar12;
  short sVar13;
  int iVar14;
  undefined *puVar15;
  int iVar16;
  scanu_add_ie_tag *psVar17;
  uint8_t *puVar18;
  uint uVar19;
  int iVar20;
  int iVar21;
  
  psVar3 = scanu_env.param;
  while( true ) {
    if (1 < scanu_env.band) {
      scanu_confirm('\0');
      return;
    }
    uVar19 = 0;
    puVar11 = &(scanu_env.param)->chan[0].band;
    while ((int)uVar19 < (int)(uint)(scanu_env.param)->chan_cnt) {
      if (*puVar11 == scanu_env.band) goto LAB_2304d238;
      uVar19 = uVar19 + 1;
      puVar11 = puVar11 + 6;
    }
    if ((uint)(scanu_env.param)->chan_cnt != uVar19) break;
    scanu_env.band = scanu_env.band + '\x01';
  }
LAB_2304d238:
  pvVar5 = ke_msg_alloc(0x800,2,4,0x154);
  *(u8_l *)((int)pvVar5 + 0x14e) = psVar3->vif_idx;
  *(undefined4 *)((int)pvVar5 + 0x140) = *(undefined4 *)(psVar3->bssid).array;
  *(undefined2 *)((int)pvVar5 + 0x144) = *(undefined2 *)((psVar3->bssid).array + 4);
  *(u8_l *)((int)pvVar5 + 0x150) = psVar3->ssid_cnt;
  *(_Bool *)((int)pvVar5 + 0x151) = psVar3->no_cck;
  while ((int)uVar19 < (int)(uint)psVar3->chan_cnt) {
    if (*(uint8_t *)(&psVar3->chan[uVar19].freq + 1) == scanu_env.band) {
      bVar1 = *(byte *)((int)pvVar5 + 0x14f);
      memcpy((void *)((uint)bVar1 * 6 + (int)pvVar5),psVar3->chan + uVar19,6);
      *(char *)((int)pvVar5 + 0x14f) = bVar1 + 1;
    }
    uVar19 = uVar19 + 1;
  }
  iVar20 = 0xfc;
  iVar21 = 0;
  while (iVar21 < (int)(uint)psVar3->ssid_cnt) {
    memcpy((void *)((int)pvVar5 + iVar20),(void *)((int)&psVar3->chan[0].freq + iVar20),0x22);
    iVar21 = iVar21 + 1;
    iVar20 = iVar20 + 0x22;
  }
  uVar19 = (uint)(scanu_env.param)->add_ie_len;
  puVar10 = scanu_add_ie.buf;
  if (200 < (scanu_env.param)->add_ie_len) {
    uVar19 = 0;
  }
  if ((scanu_env.band == '\x01') || ((scanu_env.param)->no_cck != false)) {
    iVar20 = 4;
    iVar21 = 8;
  }
  else {
    iVar20 = 0;
    iVar21 = 0xc;
  }
  scan_probe_req_ie.buf[0]._0_1_ = 1;
  scan_probe_req_ie.buf[0]._1_1_ = 8;
  iVar14 = 0;
  do {
    iVar16 = iVar20 + iVar14;
    iVar2 = iVar14 + 2;
    iVar14 = iVar14 + 1;
    *(uint8_t *)((int)scan_probe_req_ie.buf + iVar2) = mac_id2rate[iVar16];
  } while (iVar14 != 8);
  puVar15 = (undefined *)((int)scan_probe_req_ie.buf + 10);
  if ((uVar19 != 0) && ((char)scanu_add_ie.buf[0] == '\n')) {
    uVar6 = (uint)scanu_add_ie.buf[0]._1_1_ + 2 & 0xff;
    uVar4 = uVar6;
    psVar17 = &scanu_add_ie;
    while( true ) {
      uVar4 = uVar4 - 1;
      if (uVar4 == 0xffffffff) break;
      *puVar15 = *(undefined *)psVar17->buf;
      psVar17 = (scanu_add_ie_tag *)((int)&(psVar17->dma_desc).src + 1);
      puVar15 = puVar15 + 1;
    }
    puVar15 = (undefined *)((int)scan_probe_req_ie.buf + uVar6 + 10);
    puVar10 = (uint32_t *)((int)scanu_add_ie.buf + uVar6);
    uVar19 = uVar19 - uVar6 & 0xffff;
  }
  if (iVar21 != 8) {
    uVar4 = iVar21 - 8U & 0xff;
    *puVar15 = 0x32;
    puVar15[1] = (char)uVar4;
    iVar20 = uVar4 + 2;
    puVar7 = mac_id2rate;
    puVar18 = puVar15 + 2;
    while( true ) {
      uVar4 = uVar4 - 1;
      if (uVar4 == 0xffffffff) break;
      *puVar18 = puVar7[8];
      puVar7 = puVar7 + 1;
      puVar18 = puVar18 + 1;
    }
    puVar15 = puVar15 + iVar20;
  }
  if (scanu_env.band == '\0') {
    *puVar15 = 3;
    puVar15[1] = 1;
    puVar15 = puVar15 + 3;
  }
  if ((uVar19 != 0) && (*(char *)puVar10 == ';')) {
    uVar4 = 0;
    uVar6 = (uint)*(byte *)((int)puVar10 + 1) + 2 & 0xff;
    while (uVar6 != uVar4) {
      puVar8 = (undefined *)((int)puVar10 + uVar4);
      puVar9 = puVar15 + uVar4;
      uVar4 = uVar4 + 1;
      *puVar9 = *puVar8;
    }
    puVar15 = puVar15 + uVar6;
    puVar10 = (uint32_t *)((int)puVar10 + uVar6);
    uVar19 = uVar19 - uVar6 & 0xffff;
  }
  if (me_env.ht_supported != false) {
    *puVar15 = 0x2d;
    puVar15[1] = 0x1a;
    puVar8 = puVar15 + 0x1c;
    pmVar12 = &me_env;
    puVar15 = puVar15 + 2;
    while (puVar8 != puVar15) {
      *puVar15 = *(undefined *)&(pmVar12->ht_cap).ht_capa_info;
      pmVar12 = (me_env_tag *)((int)&pmVar12->active_vifs + 1);
      puVar15 = puVar15 + 1;
    }
  }
  sVar13 = (short)puVar15;
  if (uVar19 != 0) {
    uVar4 = 0;
    do {
      puVar8 = (undefined *)((int)puVar10 + uVar4);
      puVar9 = puVar15 + uVar4;
      uVar4 = uVar4 + 1;
      *puVar9 = *puVar8;
    } while (uVar19 != uVar4);
    sVar13 = sVar13 + (short)uVar19;
  }
  *(short *)((int)pvVar5 + 0x14c) = sVar13 + -0x5d04;
  *(undefined4 *)((int)pvVar5 + 0x148) = 0;
  ke_msg_send(pvVar5);
  return;
}



void scanu_dma_cb(void)

{
  byte bVar1;
  int iVar2;
  scanu_start_req *psVar3;
  uint uVar4;
  void *pvVar5;
  uint uVar6;
  uint8_t *puVar7;
  undefined *puVar8;
  undefined *puVar9;
  uint32_t *puVar10;
  u8_l *puVar11;
  me_env_tag *pmVar12;
  short sVar13;
  int iVar14;
  undefined *puVar15;
  int iVar16;
  scanu_add_ie_tag *psVar17;
  uint8_t *puVar18;
  uint uVar19;
  int iVar20;
  int iVar21;
  
  psVar3 = scanu_env.param;
  while( true ) {
    if (1 < scanu_env.band) {
      scanu_confirm('\0');
      return;
    }
    uVar19 = 0;
    puVar11 = &(scanu_env.param)->chan[0].band;
    while ((int)uVar19 < (int)(uint)(scanu_env.param)->chan_cnt) {
      if (*puVar11 == scanu_env.band) goto LAB_2304d238;
      uVar19 = uVar19 + 1;
      puVar11 = puVar11 + 6;
    }
    if ((uint)(scanu_env.param)->chan_cnt != uVar19) break;
    scanu_env.band = scanu_env.band + '\x01';
  }
LAB_2304d238:
  pvVar5 = ke_msg_alloc(0x800,2,4,0x154);
  *(u8_l *)((int)pvVar5 + 0x14e) = psVar3->vif_idx;
  *(undefined4 *)((int)pvVar5 + 0x140) = *(undefined4 *)(psVar3->bssid).array;
  *(undefined2 *)((int)pvVar5 + 0x144) = *(undefined2 *)((psVar3->bssid).array + 4);
  *(u8_l *)((int)pvVar5 + 0x150) = psVar3->ssid_cnt;
  *(_Bool *)((int)pvVar5 + 0x151) = psVar3->no_cck;
  while ((int)uVar19 < (int)(uint)psVar3->chan_cnt) {
    if (*(uint8_t *)(&psVar3->chan[uVar19].freq + 1) == scanu_env.band) {
      bVar1 = *(byte *)((int)pvVar5 + 0x14f);
      memcpy((void *)((uint)bVar1 * 6 + (int)pvVar5),psVar3->chan + uVar19,6);
      *(char *)((int)pvVar5 + 0x14f) = bVar1 + 1;
    }
    uVar19 = uVar19 + 1;
  }
  iVar20 = 0xfc;
  iVar21 = 0;
  while (iVar21 < (int)(uint)psVar3->ssid_cnt) {
    memcpy((void *)((int)pvVar5 + iVar20),(void *)((int)&psVar3->chan[0].freq + iVar20),0x22);
    iVar21 = iVar21 + 1;
    iVar20 = iVar20 + 0x22;
  }
  uVar19 = (uint)(scanu_env.param)->add_ie_len;
  puVar10 = scanu_add_ie.buf;
  if (200 < (scanu_env.param)->add_ie_len) {
    uVar19 = 0;
  }
  if ((scanu_env.band == '\x01') || ((scanu_env.param)->no_cck != false)) {
    iVar20 = 4;
    iVar21 = 8;
  }
  else {
    iVar20 = 0;
    iVar21 = 0xc;
  }
  scan_probe_req_ie.buf[0]._0_1_ = 1;
  scan_probe_req_ie.buf[0]._1_1_ = 8;
  iVar14 = 0;
  do {
    iVar16 = iVar20 + iVar14;
    iVar2 = iVar14 + 2;
    iVar14 = iVar14 + 1;
    *(uint8_t *)((int)scan_probe_req_ie.buf + iVar2) = mac_id2rate[iVar16];
  } while (iVar14 != 8);
  puVar15 = (undefined *)((int)scan_probe_req_ie.buf + 10);
  if ((uVar19 != 0) && ((char)scanu_add_ie.buf[0] == '\n')) {
    uVar6 = (uint)scanu_add_ie.buf[0]._1_1_ + 2 & 0xff;
    uVar4 = uVar6;
    psVar17 = &scanu_add_ie;
    while( true ) {
      uVar4 = uVar4 - 1;
      if (uVar4 == 0xffffffff) break;
      *puVar15 = *(undefined *)psVar17->buf;
      psVar17 = (scanu_add_ie_tag *)((int)&(psVar17->dma_desc).src + 1);
      puVar15 = puVar15 + 1;
    }
    puVar15 = (undefined *)((int)scan_probe_req_ie.buf + uVar6 + 10);
    puVar10 = (uint32_t *)((int)scanu_add_ie.buf + uVar6);
    uVar19 = uVar19 - uVar6 & 0xffff;
  }
  if (iVar21 != 8) {
    uVar4 = iVar21 - 8U & 0xff;
    *puVar15 = 0x32;
    puVar15[1] = (char)uVar4;
    iVar20 = uVar4 + 2;
    puVar7 = mac_id2rate;
    puVar18 = puVar15 + 2;
    while( true ) {
      uVar4 = uVar4 - 1;
      if (uVar4 == 0xffffffff) break;
      *puVar18 = puVar7[8];
      puVar7 = puVar7 + 1;
      puVar18 = puVar18 + 1;
    }
    puVar15 = puVar15 + iVar20;
  }
  if (scanu_env.band == '\0') {
    *puVar15 = 3;
    puVar15[1] = 1;
    puVar15 = puVar15 + 3;
  }
  if ((uVar19 != 0) && (*(char *)puVar10 == ';')) {
    uVar4 = 0;
    uVar6 = (uint)*(byte *)((int)puVar10 + 1) + 2 & 0xff;
    while (uVar6 != uVar4) {
      puVar8 = (undefined *)((int)puVar10 + uVar4);
      puVar9 = puVar15 + uVar4;
      uVar4 = uVar4 + 1;
      *puVar9 = *puVar8;
    }
    puVar15 = puVar15 + uVar6;
    puVar10 = (uint32_t *)((int)puVar10 + uVar6);
    uVar19 = uVar19 - uVar6 & 0xffff;
  }
  if (me_env.ht_supported != false) {
    *puVar15 = 0x2d;
    puVar15[1] = 0x1a;
    puVar8 = puVar15 + 0x1c;
    pmVar12 = &me_env;
    puVar15 = puVar15 + 2;
    while (puVar8 != puVar15) {
      *puVar15 = *(undefined *)&(pmVar12->ht_cap).ht_capa_info;
      pmVar12 = (me_env_tag *)((int)&pmVar12->active_vifs + 1);
      puVar15 = puVar15 + 1;
    }
  }
  sVar13 = (short)puVar15;
  if (uVar19 != 0) {
    uVar4 = 0;
    do {
      puVar8 = (undefined *)((int)puVar10 + uVar4);
      puVar9 = puVar15 + uVar4;
      uVar4 = uVar4 + 1;
      *puVar9 = *puVar8;
    } while (uVar19 != uVar4);
    sVar13 = sVar13 + (short)uVar19;
  }
  *(short *)((int)pvVar5 + 0x14c) = sVar13 + -0x5d04;
  *(undefined4 *)((int)pvVar5 + 0x148) = 0;
  ke_msg_send(pvVar5);
  return;
}



void scanu_start(void)

{
  scanu_env_tag_conflict *psVar1;
  
  if (scanu_env.joining == false) {
    psVar1 = &scanu_env;
    do {
      psVar1->scan_result[0].valid_flag = false;
      psVar1->scan_result[0].rssi = -0x80;
      psVar1 = (scanu_env_tag_conflict *)(psVar1->scan_result[0].ssid.array + 0x19);
    } while (psVar1 != (scanu_env_tag_conflict *)0x4201ccac);
    scanu_env.result_cnt = 0;
  }
  ke_state_set(4,1);
  if ((scanu_env.param)->add_ies != 0) {
    if ((scanu_env.param)->add_ie_len < 0xc9) {
      scanu_add_ie.dma_desc.src = (scanu_env.param)->add_ies;
      scanu_add_ie.dma_desc.length = (scanu_env.param)->add_ie_len;
      hal_dma_push(&scanu_env.dma_desc,0);
      return;
    }
  }
  scanu_scan_next();
  return;
}



uint16_t txl_get_seq_ctrl(void)

{
  uint uVar1;
  
  uVar1 = (uint)txl_cntrl_env.seqnbr;
  txl_cntrl_env.seqnbr = (uint16_t)((uVar1 + 1) * 0x10000 >> 0x10);
  return (uint16_t)((uVar1 + 1) * 0x100000 >> 0x10);
}



void sm_delete_resources(vif_info_tag *vif)

{
  undefined *puVar1;
  undefined *puVar2;
  void *pvVar3;
  byte *pbVar4;
  
  puVar1 = (undefined *)ke_msg_alloc(0x1413,5,6,2);
  puVar2 = (undefined *)ke_msg_alloc(0x1411,5,6,2);
  *puVar1 = 0;
  puVar1[1] = vif->index;
  ke_msg_send(puVar1);
  if (vif->active != false) {
    pvVar3 = ke_msg_alloc(0x1e,0,6,4);
    *(undefined *)((int)pvVar3 + 2) = 0;
    *(uint8_t *)((int)pvVar3 + 3) = vif->index;
    ke_msg_send();
  }
  if (vif->u[4] != 0xff) {
    pbVar4 = (byte *)ke_msg_alloc(0xc,0,6,1);
    *pbVar4 = vif->u[4];
    ke_msg_send();
  }
  if (vif->chan_ctxt != (chan_ctxt_tag *)0x0) {
    chan_ctxt_unlink(vif->index);
  }
  *puVar2 = 0;
  puVar2[1] = vif->index;
  ke_msg_send(puVar2);
  (vif->bss_info).valid_flags = 0;
  return;
}



void sm_frame_tx_cfm_handler(void *env,u32_l status)

{
  ke_state_t kVar1;
  undefined3 extraout_var;
  
  kVar1 = ke_state_get(6);
  if (((status & 0x40030000) != 0) && (CONCAT31(extraout_var,kVar1) - 5U < 2)) {
    txl_frame_push((txl_frame_desc_tag *)env,'\x03');
    *(undefined *)((int)env + 0x2d6) = 1;
  }
  return;
}



void sm_init(void)

{
  sm_env.connect_param = (sm_connect_req *)0x0;
  ke_state_set(6,0);
  return;
}



void sm_get_bss_params(mac_addr_conflict67 **bssid,scan_chan_tag **chan)

{
  byte bVar1;
  sm_connect_req *ssid;
  int iVar2;
  int iVar3;
  mac_scan_result *pmVar4;
  mac_addr_conflict *bssid_00;
  mac_addr_conflict *pmVar5;
  int local_34;
  int index;
  
  ssid = sm_env.connect_param;
  *bssid = (mac_addr_conflict67 *)0x0;
  *chan = (scan_chan_tag *)0x0;
  bssid_00 = (mac_addr_conflict *)&ssid->bssid;
  local_34 = -1;
  printf("===start sm_get_bss_params===\r\n");
  iVar2 = 0;
  pmVar5 = bssid_00;
  do {
    iVar3 = iVar2 + 1;
    printf("bssid[%d] = 0x%x\r\n",iVar2,(uint)pmVar5->array[0]);
    pmVar5 = (mac_addr_conflict *)(pmVar5->array + 1);
    iVar2 = iVar3;
  } while (iVar3 != 3);
  bVar1 = (ssid->bssid).array[0];
  if (((bVar1 & 1) == 0) &&
     ((((bVar1 != 0 || ((ssid->bssid).array[1] != '\0')) || ((ssid->bssid).array[2] != '\0')) ||
      ((((ssid->bssid).array[3] != '\0' || ((ssid->bssid).array[4] != '\0')) ||
       ((ssid->bssid).array[5] != '\0')))))) {
    printf("search bssid \r\n ");
    *(mac_addr_conflict **)bssid = bssid_00;
    pmVar4 = scanu_search_by_bssid(bssid_00);
    if (pmVar4 == (mac_scan_result *)0x0) goto LAB_2304d752;
  }
  else {
    printf("search ssid = %s\r\n",(ssid->ssid).array);
    pmVar4 = scanu_search_by_ssid((mac_ssid *)ssid,&local_34);
    printf("result ssid index = %d\r\n",local_34);
    if (pmVar4 == (mac_scan_result *)0x0) {
LAB_2304d752:
      if ((ssid->chan).freq != 0xffff) {
        *chan = &ssid->chan;
      }
      goto LAB_2304d714;
    }
    if (-1 < local_34) {
      *(mac_scan_result **)bssid = pmVar4;
      sm_env.exist_ssid_idx = local_34;
    }
  }
  *chan = pmVar4->chan;
LAB_2304d714:
  printf("===end sm_get_bss_params===\r\n");
  return;
}



// WARNING: Could not reconcile some variable overlaps

void sm_scan_bss(mac_addr_conflict67 *bssid,scan_chan_tag *chan_1)

{
  u8_l uVar1;
  byte bVar2;
  undefined2 uVar3;
  sm_connect_req *__src;
  int iVar4;
  void *__dest;
  void *__src_00;
  undefined2 *puVar5;
  int *piVar6;
  undefined2 local_2c;
  undefined2 uStack42;
  uint8_t chan_cnt [2];
  scan_chan_tag *chan [2];
  
  __src = sm_env.connect_param;
  __dest = ke_msg_alloc(0x1000,4,6,0x154);
  uVar1 = __src->vif_idx;
  *(undefined4 *)((int)__dest + 0x148) = 0;
  *(u8_l *)((int)__dest + 0x14e) = uVar1;
  *(undefined2 *)((int)__dest + 0x14c) = 0;
  memcpy((void *)((int)__dest + 0xfc),__src,0x22);
  *(undefined *)((int)__dest + 0x150) = 1;
  if (bssid == (mac_addr_conflict67 *)0x0) {
    bssid = (mac_addr_conflict67 *)&mac_addr_bcst;
  }
  memcpy((void *)((int)__dest + 0x140),bssid,6);
  uVar3 = me_env.chan._252_2_;
  if (chan_1 == (scan_chan_tag *)0x0) {
    _chan_cnt = 0x4201c8ec;
    *(undefined *)((int)__dest + 0x14f) = 0;
    puVar5 = &local_2c;
    local_2c = uVar3;
    piVar6 = (int *)chan_cnt;
    do {
      iVar4 = 0;
      while (iVar4 < (int)(uint)*(byte *)puVar5) {
        __src_00 = (void *)(iVar4 * 6 + *piVar6);
        if ((*(byte *)((int)__src_00 + 3) & 2) == 0) {
          bVar2 = *(byte *)((int)__dest + 0x14f);
          *(char *)((int)__dest + 0x14f) = bVar2 + 1;
          memcpy((void *)((uint)bVar2 * 6 + (int)__dest),__src_00,6);
        }
        iVar4 = iVar4 + 1;
      }
      puVar5 = (undefined2 *)((int)puVar5 + 1);
      piVar6 = piVar6 + 1;
    } while (puVar5 != &uStack42);
  }
  else {
    memcpy(__dest,chan_1,6);
    *(undefined *)((int)__dest + 0x14f) = 1;
  }
  ke_msg_send(__dest);
  ke_state_set(6,1);
  return;
}



void sm_join_bss(mac_addr_conflict67 *bssid,scan_chan_tag *chan,_Bool passive)

{
  sm_connect_req *__src;
  void *__dest;
  undefined3 in_register_00002031;
  
  __src = sm_env.connect_param;
  __dest = ke_msg_alloc(0x1002,4,6,0x154);
  memcpy(__dest,chan,6);
  *(undefined *)((int)__dest + 0x14f) = 1;
  memcpy((void *)((int)__dest + 0xfc),__src,0x22);
  *(undefined *)((int)__dest + 0x150) = 1;
  *(undefined2 *)((int)__dest + 0x14c) = 0;
  *(undefined4 *)((int)__dest + 0x148) = 0;
  *(u8_l *)((int)__dest + 0x14e) = __src->vif_idx;
  memcpy((void *)((int)__dest + 0x140),bssid,6);
  if (CONCAT31(in_register_00002031,passive) != 0) {
    *(byte *)((int)__dest + 3) = *(byte *)((int)__dest + 3) | 1;
  }
  sm_env.join_passive = passive;
  ke_msg_send(__dest);
  ke_state_set(6,2);
  return;
}



// WARNING: Could not reconcile some variable overlaps

uint8_t sm_add_chan_ctx(uint8_t *p_chan_idx)

{
  uint8_t uVar1;
  scan_chan_tag *psVar2;
  uint uVar3;
  u8_l uStack28;
  uint8_t uStack27;
  u16_l uStack26;
  mm_chan_ctxt_add_req req;
  
  uVar3 = (uint)(sm_env.connect_param)->vif_idx;
  psVar2 = vif_info_tab[uVar3].bss_info.chan;
  uStack27 = vif_info_tab[uVar3].bss_info.phy_bw;
  uStack28 = psVar2->band;
  uStack26 = psVar2->freq;
  req._0_4_ = *(undefined4 *)&vif_info_tab[uVar3].bss_info.center_freq1;
  req.center1_freq._0_1_ = psVar2->tx_power;
  uVar1 = chan_ctxt_add((mm_chan_ctxt_add_req *)&uStack28,p_chan_idx);
  return uVar1;
}



void sm_send_next_bss_param(void)

{
  co_list_hdr *pcVar1;
  
  pcVar1 = co_list_pop_front(&sm_env.bss_config);
  if (pcVar1 == (co_list_hdr *)0x0) {
    assert_err("msg != NULL","module",0x1a0);
  }
  ke_msg_send(pcVar1 + 3);
  return;
}



void sm_set_bss_param(void)

{
  sm_connect_req *psVar1;
  vif_info_tag *pvVar2;
  uint16_t uVar3;
  undefined *puVar4;
  void *__dest;
  undefined4 *puVar5;
  uint16_t *puVar6;
  undefined *puVar7;
  undefined2 extraout_var;
  uint32_t *puVar8;
  bool bVar9;
  uint32_t uVar10;
  uint uVar11;
  int iVar12;
  
  psVar1 = sm_env.connect_param;
  uVar11 = (uint)(sm_env.connect_param)->vif_idx;
  puVar4 = (undefined *)ke_msg_alloc(0x1413,5,6,2);
  __dest = ke_msg_alloc(0x18,0,6,7);
  puVar5 = (undefined4 *)ke_msg_alloc(0x16,0,6,8);
  puVar6 = (uint16_t *)ke_msg_alloc(0x14,0,6,4);
  puVar7 = (undefined *)ke_msg_alloc(0x1411,5,6,2);
  co_list_init(&sm_env.bss_config);
  *puVar4 = 1;
  puVar4[1] = psVar1->vif_idx;
  co_list_push_back(&sm_env.bss_config,(co_list_hdr *)(puVar4 + -0xc));
  pvVar2 = vif_info_tab + uVar11;
  memcpy(__dest,&vif_info_tab[uVar11].bss_info.bssid,6);
  *(u8_l *)((int)__dest + 6) = psVar1->vif_idx;
  co_list_push_back(&sm_env.bss_config,(co_list_hdr *)((int)__dest + -0xc));
  *(u8_l *)((int)puVar5 + 5) = (vif_info_tab[uVar11].bss_info.chan)->band;
  uVar3 = me_legacy_rate_bitfield_build(&vif_info_tab[uVar11].bss_info.rate_set,true);
  *puVar5 = CONCAT22(extraout_var,uVar3);
  *(u8_l *)(puVar5 + 1) = psVar1->vif_idx;
  co_list_push_back(&sm_env.bss_config,(co_list_hdr *)(puVar5 + -3));
  *puVar6 = vif_info_tab[uVar11].bss_info.beacon_period;
  iVar12 = 0;
  *(u8_l *)(puVar6 + 1) = psVar1->vif_idx;
  co_list_push_back(&sm_env.bss_config,(co_list_hdr *)(puVar6 + -6));
  do {
    puVar8 = (uint32_t *)ke_msg_alloc(0x1a,0,6,8);
    uVar10 = (pvVar2->bss_info).edca_param.ac_param[0];
    *(undefined *)((int)puVar8 + 5) = (char)iVar12;
    *puVar8 = uVar10;
    *(u8_l *)((int)puVar8 + 6) = psVar1->vif_idx;
    bVar9 = false;
    if ((ps_env.uapsd_timeout != 0) &&
       ((char)vif_info_tab[uVar11].bss_info.edca_param.qos_info < '\0')) {
      bVar9 = (mac_ac2uapsd[iVar12] & psVar1->uapsd_queues) != 0;
    }
    *(bool *)(puVar8 + 1) = bVar9;
    iVar12 = iVar12 + 1;
    co_list_push_back(&sm_env.bss_config,(co_list_hdr *)(puVar8 + -3));
    pvVar2 = (vif_info_tag *)&pvVar2->prevent_sleep;
  } while (iVar12 != 4);
  *puVar7 = 1;
  puVar7[1] = psVar1->vif_idx;
  co_list_push_back(&sm_env.bss_config,(co_list_hdr *)(puVar7 + -0xc));
  sm_send_next_bss_param();
  ke_state_set(6,4);
  return;
}



void sm_disconnect_process(vif_info_tag *vif,uint16_t reason)

{
  uint16_t *puVar1;
  
  puVar1 = (uint16_t *)ke_msg_alloc(0x1805,0xd,6,4);
  sm_delete_resources(vif);
  *puVar1 = reason;
  *(uint8_t *)(puVar1 + 1) = vif->index;
  if (sm_env.ft_over_ds != false) {
    *(undefined *)((int)puVar1 + 3) = 1;
  }
  ke_msg_send(puVar1);
  return;
}



void sm_deauth_cfm(void *env,u32_l status)

{
  sm_disconnect_process((vif_info_tag *)env,0);
  return;
}



void sm_disconnect(uint8_t vif_index,uint16_t reason_code)

{
  byte bVar1;
  _Bool _Var2;
  uint16_t uVar3;
  undefined3 in_register_00002029;
  int iVar4;
  txl_frame_desc_tag *frame;
  undefined2 extraout_var_00;
  undefined3 extraout_var;
  vif_info_tag *vif;
  tx_hw_desc *ptVar5;
  txl_buffer_tag *ptVar6;
  
  iVar4 = CONCAT31(in_register_00002029,vif_index);
  vif = vif_info_tab + iVar4;
  if ((vif_info_tab[iVar4].type == '\0') && (vif_info_tab[iVar4].active != false)) {
    bVar1 = vif_info_tab[iVar4].u[4];
    ke_state_set(6,8);
    frame = txl_frame_get((uint)((vif_info_tab[iVar4].bss_info.chan)->band != '\0'),0x100);
    if (frame != (txl_frame_desc_tag *)0x0) {
      tpc_update_frame_tx_power(vif,frame);
      ptVar6 = (frame->txdesc).lmac.buffer;
      *(undefined *)&ptVar6[1].length = 0xc0;
      *(undefined *)((int)&ptVar6[1].length + 1) = 0;
      *(undefined *)((int)&ptVar6[1].length + 2) = 0;
      *(undefined *)((int)&ptVar6[1].length + 3) = 0;
      memcpy(&ptVar6[1].lenheader,&sta_info_tab[bVar1].mac_addr,6);
      memcpy((void *)((int)&ptVar6[1].lenpad + 2),&vif_info_tab[iVar4].mac_addr,6);
      memcpy(&ptVar6[1].next,&sta_info_tab[bVar1].mac_addr,6);
      uVar3 = txl_get_seq_ctrl();
      *(undefined *)((int)&ptVar6[1].txdesc + 2) = (char)uVar3;
      *(undefined *)((int)&ptVar6[1].txdesc + 3) = (char)(uVar3 >> 8);
      (frame->cfm).cfm_func = sm_deauth_cfm;
      *(vif_info_tag **)&(frame->cfm).env = vif;
      (frame->txdesc).host.vif_idx = vif_index;
      (frame->txdesc).host.staid = vif_info_tab[iVar4].u[4];
      uVar3 = me_build_deauthenticate((uint32_t)ptVar6[1].dma_desc,reason_code);
      ptVar5 = (frame->txdesc).lmac.hw_desc;
      (ptVar5->thd).frmlen = CONCAT22(extraout_var_00,uVar3) + 0x1c;
      (ptVar5->thd).field_5 = (ptVar5->thd).field_4 + 0x17 + CONCAT22(extraout_var_00,uVar3);
      _Var2 = txl_frame_push(frame,'\x03');
      if (CONCAT31(extraout_var,_Var2) != 0) {
        return;
      }
      vif = (vif_info_tag *)(frame->cfm).env;
    }
    sm_disconnect_process(vif,0);
    return;
  }
  return;
}



void sm_connect_ind(uint16_t status)

{
  sm_connect_req *ssid;
  sm_connect_ind *psVar1;
  int index;
  undefined2 in_register_0000202a;
  uint8_t uVar2;
  uint uVar3;
  chan_ctxt_tag *pcVar4;
  uint uVar5;
  
  index = sm_env.exist_ssid_idx;
  psVar1 = sm_env.connect_ind;
  ssid = sm_env.connect_param;
  uVar5 = (uint)(sm_env.connect_param)->vif_idx;
  (sm_env.connect_ind)->vif_idx = (sm_env.connect_param)->vif_idx;
  memcpy(&psVar1->bssid,&vif_info_tab[uVar5].bss_info.bssid,6);
  psVar1->ap_idx = vif_info_tab[uVar5].u[4];
  printf("ind ix %p, chan_ctxt is %p\r\n",psVar1,vif_info_tab[uVar5].chan_ctxt);
  pcVar4 = vif_info_tab[uVar5].chan_ctxt;
  psVar1->ch_idx = '\0';
  if (pcVar4 == (chan_ctxt_tag *)0x0) {
    psVar1->band = '\0';
    psVar1->center_freq = 0;
    psVar1->center_freq1 = 0;
    psVar1->center_freq2 = 0;
    psVar1->width = '\0';
  }
  else {
    psVar1->band = ((vif_info_tab[uVar5].chan_ctxt)->channel).band;
    psVar1->center_freq = ((vif_info_tab[uVar5].chan_ctxt)->channel).prim20_freq;
    psVar1->center_freq1 = (uint)((vif_info_tab[uVar5].chan_ctxt)->channel).center1_freq;
    psVar1->center_freq2 = (uint)((vif_info_tab[uVar5].chan_ctxt)->channel).center2_freq;
    psVar1->width = ((vif_info_tab[uVar5].chan_ctxt)->channel).type;
  }
  uVar2 = '\0';
  uVar3 = vif_info_tab[uVar5].bss_info.valid_flags & 1;
  psVar1->qos = SUB41(uVar3,0);
  if (uVar3 != 0) {
    uVar2 = vif_info_tab[uVar5].bss_info.edca_param.acm;
  }
  psVar1->acm = uVar2;
  psVar1->roamed = false;
  if (CONCAT22(in_register_0000202a,status) == 0) {
    ke_state_set(6,0);
  }
  else {
    ke_state_set(6,8);
    printf("connect failure, ssid = %s, index = %d\r\n",(ssid->ssid).array,index);
    if (-1 < index) {
      printf("from sm_connect_ind to scanu_rm_exist_ssid\r\n");
      scanu_rm_exist_ssid((mac_ssid *)ssid,index);
      sm_env.exist_ssid_idx = -1;
    }
    sm_delete_resources(vif_info_tab + uVar5);
  }
  ke_msg_free(sm_env.connect_param[-1].phrase_pmk + 0x37);
  sm_env.connect_param = (sm_connect_req *)0x0;
  sm_env.ft_over_ds = false;
  psVar1->status_code = status;
  ke_msg_send(psVar1);
  sm_env.connect_ind = (sm_connect_ind *)0x0;
  return;
}



void sm_supplicant_deauth_cfm(void *env,u32_l status)

{
  if (-1 < (int)(status << 8)) {
    printf("sm deauth frame transmit failure\r\n");
  }
  sm_connect_ind(8);
  return;
}



void sm_auth_send(uint16_t auth_seq,uint32_t *challenge)

{
  byte bVar1;
  sm_connect_req *psVar2;
  txl_buffer_tag *ptVar3;
  uint16_t uVar4;
  undefined2 in_register_0000202a;
  txl_frame_desc_tag *frame;
  undefined2 extraout_var;
  tx_hw_desc *ptVar5;
  uint uVar6;
  int iVar7;
  
  psVar2 = sm_env.connect_param;
  uVar6 = (uint)(sm_env.connect_param)->vif_idx;
  bVar1 = vif_info_tab[uVar6].u[4];
  frame = txl_frame_get((uint)((vif_info_tab[uVar6].bss_info.chan)->band != '\0'),0x100);
  if (frame != (txl_frame_desc_tag *)0x0) {
    tpc_update_frame_tx_power(vif_info_tab + uVar6,frame);
    ptVar3 = (frame->txdesc).lmac.buffer;
    *(undefined *)&ptVar3[1].length = 0xb0;
    *(undefined *)((int)&ptVar3[1].length + 1) = 0;
    *(undefined *)((int)&ptVar3[1].length + 2) = 0;
    *(undefined *)((int)&ptVar3[1].length + 3) = 0;
    memcpy(&ptVar3[1].lenheader,&sta_info_tab[bVar1].mac_addr,6);
    memcpy((void *)((int)&ptVar3[1].lenpad + 2),&vif_info_tab[uVar6].mac_addr,6);
    memcpy(&ptVar3[1].next,&sta_info_tab[bVar1].mac_addr,6);
    uVar4 = txl_get_seq_ctrl();
    *(undefined *)((int)&ptVar3[1].txdesc + 2) = (char)uVar4;
    *(undefined *)((int)&ptVar3[1].txdesc + 3) = (char)(uVar4 >> 8);
    (frame->txdesc).host.vif_idx = vif_info_tab[uVar6].index;
    bVar1 = vif_info_tab[uVar6].u[4];
    (frame->txdesc).umac.head_len = '\0';
    (frame->txdesc).umac.tail_len = '\0';
    (frame->txdesc).host.staid = bVar1;
    iVar7 = 0x18;
    if ((psVar2->auth_type == '\x01') && (CONCAT22(in_register_0000202a,auth_seq) == 3)) {
      txu_cntrl_protect_mgmt_frame((txdesc *)frame,(uint32_t)(ptVar3 + 1),0x18);
      iVar7 = (uint)(frame->txdesc).umac.head_len + 0x18;
    }
    uVar4 = me_build_authenticate
                      ((int)&ptVar3[1].length + iVar7,(ushort)psVar2->auth_type,auth_seq,0,challenge
                      );
    bVar1 = (frame->txdesc).umac.tail_len;
    ptVar5 = (frame->txdesc).lmac.hw_desc;
    *(txl_frame_desc_tag **)&(frame->cfm).env = frame;
    iVar7 = CONCAT22(extraout_var,uVar4) + (uint)bVar1 + iVar7;
    (frame->cfm).cfm_func = sm_frame_tx_cfm_handler;
    (ptVar5->thd).frmlen = iVar7 + 4;
    (ptVar5->thd).field_5 = (ptVar5->thd).field_4 + -1 + iVar7;
    txl_frame_push(frame,'\x03');
    ke_timer_set(0x1806,6,0x32000);
    ke_state_set(6,5);
    return;
  }
  sm_connect_ind(1);
  return;
}



// WARNING: Variable defined which should be unmapped: ie_addr
// WARNING: Could not reconcile some variable overlaps

void sm_assoc_req_send(void)

{
  byte bVar1;
  sm_connect_req *con_par;
  sm_connect_ind *psVar2;
  txl_buffer_tag *ptVar3;
  uint16_t uVar4;
  txl_frame_desc_tag *frame;
  undefined2 extraout_var;
  tx_hw_desc *ptVar5;
  _Bool _Var6;
  sm_connect_ind *psVar7;
  uint uVar8;
  mac_addr_conflict171 *old_ap_addr_ptr;
  uint16_t uStack54;
  uint16_t ie_len;
  uint32_t uStack52;
  u32_l ie_addr;
  
  con_par = sm_env.connect_param;
  uVar8 = (uint)(sm_env.connect_param)->vif_idx;
  bVar1 = vif_info_tab[uVar8].u[4];
  frame = txl_frame_get((uint)((vif_info_tab[uVar8].bss_info.chan)->band != '\0'),0x100);
  psVar2 = sm_env.connect_ind;
  if (frame == (txl_frame_desc_tag *)0x0) {
    sm_connect_ind(4);
  }
  else {
    tpc_update_frame_tx_power(vif_info_tab + uVar8,frame);
    ptVar3 = (frame->txdesc).lmac.buffer;
    old_ap_addr_ptr = (mac_addr_conflict171 *)0x0;
    _Var6 = sm_env.ft_over_ds;
    if (sm_env.ft_over_ds != false) {
      _Var6 = true;
      old_ap_addr_ptr = (mac_addr_conflict171 *)&sm_env.ft_old_bssid;
    }
    *(_Bool *)&ptVar3[1].length = _Var6;
    *(undefined *)((int)&ptVar3[1].length + 1) = 0;
    *(undefined *)((int)&ptVar3[1].length + 2) = 0;
    *(undefined *)((int)&ptVar3[1].length + 3) = 0;
    memcpy(&ptVar3[1].lenheader,&sta_info_tab[bVar1].mac_addr,6);
    memcpy((void *)((int)&ptVar3[1].lenpad + 2),&vif_info_tab[uVar8].mac_addr,6);
    memcpy(&ptVar3[1].next,&sta_info_tab[bVar1].mac_addr,6);
    uVar4 = txl_get_seq_ctrl();
    *(undefined *)((int)&ptVar3[1].txdesc + 2) = (char)uVar4;
    *(undefined *)((int)&ptVar3[1].txdesc + 3) = (char)(uVar4 >> 8);
    uVar4 = me_build_associate_req
                      ((uint32_t)ptVar3[1].dma_desc,&vif_info_tab[uVar8].bss_info,old_ap_addr_ptr,
                       vif_info_tab[uVar8].index,(uint32_t *)&stack0xffffffcc,&uStack54,con_par);
    ptVar5 = (frame->txdesc).lmac.hw_desc;
    (frame->txdesc).host.vif_idx = vif_info_tab[uVar8].index;
    bVar1 = vif_info_tab[uVar8].u[4];
    *(txl_frame_desc_tag **)&(frame->cfm).env = frame;
    (frame->txdesc).host.staid = bVar1;
    (frame->cfm).cfm_func = sm_frame_tx_cfm_handler;
    (ptVar5->thd).field_5 = (ptVar5->thd).field_4 + 0x17 + CONCAT22(extraout_var,uVar4);
    (ptVar5->thd).frmlen = CONCAT22(extraout_var,uVar4) + 0x1c;
    psVar7 = psVar2;
    while (psVar7 != (sm_connect_ind *)((int)&psVar2->status_code + (uint)uStack54)) {
      *(undefined *)psVar7->assoc_ie_buf = *(undefined *)((uStack52 - (int)psVar2) + (int)psVar7);
      psVar7 = (sm_connect_ind *)((int)&psVar7->status_code + 1);
    }
    psVar2->assoc_req_ie_len = uStack54;
    txl_frame_push(frame,'\x03');
    ke_timer_set(0x1806,6,0x32000);
    ke_state_set(6,6);
  }
  return;
}



void sm_assoc_done(uint16_t aid)

{
  sm_connect_req *psVar1;
  uint16_t *puVar2;
  
  psVar1 = sm_env.connect_param;
  puVar2 = (uint16_t *)ke_msg_alloc(0x1e,0,6,4);
  *puVar2 = aid;
  *(undefined *)(puVar2 + 1) = 1;
  *(u8_l *)((int)puVar2 + 3) = psVar1->vif_idx;
  ke_msg_send();
  ke_state_set(6,7);
  return;
}



void sm_auth_handler(rxu_mgt_ind *param)

{
  uint16_t auth_seq;
  uint32_t *challenge;
  
  ke_timer_clear(0x1806,6);
  if (param[1].center_freq != 0) {
    if (((sm_env.connect_param)->auth_type != '\x01') ||
       ((sm_env.connect_param)->is_supplicant_enabled == false)) {
      printf("Authentication failure, Wlan802.11 status code = %d\r\n");
      sm_connect_ind(2);
      return;
    }
    (sm_env.connect_param)->auth_type = '\0';
    challenge = (uint32_t *)0x0;
    auth_seq = 1;
LAB_2304e268:
    sm_auth_send(auth_seq,challenge);
    return;
  }
  if (param[1].length != 0) {
    if (param[1].length != 1) {
      return;
    }
    if (param[1].framectrl != 4) {
      if (param[1].framectrl != 2) {
        sm_connect_ind(3);
        assert_warn("0","module",0x374);
        return;
      }
      if (param->length < 0x88) {
        printf("Drop illegal auth packet length %u\r\n");
        return;
      }
      challenge = (uint32_t *)&param[1].inst_nbr;
      auth_seq = 3;
      goto LAB_2304e268;
    }
  }
  sm_assoc_req_send();
  return;
}



void sm_assoc_rsp_handler(rxu_mgt_ind *param)

{
  uint8_t *puVar1;
  byte bVar2;
  ushort uVar3;
  int iVar4;
  sm_connect_ind *psVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint8_t uStack50;
  int8_t aiStack49 [3];
  uint8_t idx;
  s8_l pwr;
  
  psVar5 = sm_env.connect_ind;
  uVar8 = (uint)(sm_env.connect_param)->vif_idx;
  uStack50 = '\0';
  bVar2 = vif_info_tab[uVar8].u[4];
  ke_timer_clear(0x1806,6);
  uVar6 = (uint)param[1].framectrl;
  if (param[1].framectrl == 0) {
    if (5 < param->length) {
      uVar6 = (uint)param->length - 6 & 0xffff;
    }
    sm_assoc_done((ushort)(((uint)param[1].center_freq << 0x12) >> 0x12));
    me_init_rate(sta_info_tab + bVar2);
    aiStack49[0] = (vif_info_tab[uVar8].bss_info.chan)->tx_power -
                   vif_info_tab[uVar8].bss_info.power_constraint;
    tpc_update_vif_tx_power(vif_info_tab + uVar8,aiStack49,&uStack50);
    uVar3 = psVar5->assoc_req_ie_len;
    uVar7 = 0;
    while (uVar6 != uVar7) {
      puVar1 = &param[1].band + uVar7;
      iVar4 = uVar7 + uVar3;
      uVar7 = uVar7 + 1;
      *(uint8_t *)((int)psVar5->assoc_ie_buf + iVar4) = *puVar1;
    }
    psVar5->assoc_rsp_ie_len = (u16_l)uVar6;
    if ((*(uint *)&vif_info_tab[uVar8].bss_info.is_supplicant_enabled & 0x12a00) != 0) {
      supplicantInitSession
                (&sta_conn_info,(CHAR *)vif_info_tab[uVar8].bss_info.ssid.array,
                 (ushort)vif_info_tab[uVar8].bss_info.ssid.length,
                 (CHAR *)&vif_info_tab[uVar8].bss_info.bssid,(UINT8 *)&vif_info_tab[uVar8].mac_addr)
      ;
    }
  }
  else {
    printf("Association failure, Wlan802.11 status code = %d\r\n",uVar6);
    sm_connect_ind(5);
  }
  return;
}



int sm_deauth_handler(rxu_mgt_ind *param)

{
  byte bVar1;
  ushort reason;
  sm_connect_req *psVar2;
  ke_state_t kVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  
  psVar2 = sm_env.connect_param;
  bVar1 = param->inst_nbr;
  kVar3 = ke_state_get(6);
  if (CONCAT31(extraout_var,kVar3) != 8) {
    kVar3 = ke_state_get(6);
    if (CONCAT31(extraout_var_00,kVar3) == 0) {
      if (vif_info_tab[bVar1].active == false) {
        return 0;
      }
      reason = param[1].length;
      ke_state_set(6,8);
      printf("Deauth by AP, Wlan802.11 reason code = %d\r\n",(uint)reason);
      sm_disconnect_process(vif_info_tab + bVar1,reason);
      return 0;
    }
    if (psVar2->vif_idx == param->inst_nbr) {
      sm_connect_ind(6);
      return 0;
    }
  }
  return 2;
}



void sm_handle_supplicant_result(uint8_t sta_id,uint16_t reason_code)

{
  byte bVar1;
  txl_buffer_tag *ptVar2;
  _Bool _Var3;
  uint16_t status;
  undefined3 in_register_00002029;
  int iVar4;
  txl_frame_desc_tag *frame;
  undefined2 extraout_var_00;
  undefined3 extraout_var;
  undefined2 in_register_0000202e;
  tx_hw_desc *ptVar5;
  uint uVar6;
  
  iVar4 = CONCAT31(in_register_00002029,sta_id);
  bVar1 = sta_info_tab[iVar4].inst_nbr;
  uVar6 = (uint)bVar1;
  if (CONCAT22(in_register_0000202e,reason_code) == 0) {
    sta_info_tab[iVar4].ctrl_port_state = '\x02';
    status = 0;
  }
  else {
    if (CONCAT22(in_register_0000202e,reason_code) == 0xf) {
      printf(
            "4-way handshake timeout failure, wlan 802.11 reason code = %u,                try to transmit deauth frame\r\n"
            );
    }
    frame = txl_frame_get((uint)((vif_info_tab[uVar6].bss_info.chan)->band != '\0'),0x100);
    if (frame == (txl_frame_desc_tag *)0x0) {
      status = 10;
    }
    else {
      tpc_update_frame_tx_power(vif_info_tab + uVar6,frame);
      ptVar2 = (frame->txdesc).lmac.buffer;
      *(undefined *)&ptVar2[1].length = 0xc0;
      *(undefined *)((int)&ptVar2[1].length + 1) = 0;
      *(undefined *)((int)&ptVar2[1].length + 2) = 0;
      *(undefined *)((int)&ptVar2[1].length + 3) = 0;
      memcpy(&ptVar2[1].lenheader,&sta_info_tab[iVar4].mac_addr,6);
      memcpy((void *)((int)&ptVar2[1].lenpad + 2),&vif_info_tab[uVar6].mac_addr,6);
      memcpy(&ptVar2[1].next,&sta_info_tab[iVar4].mac_addr,6);
      status = txl_get_seq_ctrl();
      *(undefined *)((int)&ptVar2[1].txdesc + 2) = (char)status;
      *(undefined *)((int)&ptVar2[1].txdesc + 3) = (char)(status >> 8);
      (frame->cfm).cfm_func = sm_supplicant_deauth_cfm;
      *(vif_info_tag **)&(frame->cfm).env = vif_info_tab + uVar6;
      (frame->txdesc).host.vif_idx = bVar1;
      (frame->txdesc).host.staid = sta_id;
      status = me_build_deauthenticate((uint32_t)ptVar2[1].dma_desc,reason_code);
      ptVar5 = (frame->txdesc).lmac.hw_desc;
      (ptVar5->thd).frmlen = CONCAT22(extraout_var_00,status) + 0x1c;
      (ptVar5->thd).field_5 = (ptVar5->thd).field_4 + 0x17 + CONCAT22(extraout_var_00,status);
      _Var3 = txl_frame_push(frame,'\x03');
      if (CONCAT31(extraout_var,_Var3) != 0) {
        return;
      }
      status = 9;
    }
  }
  sm_connect_ind(status);
  return;
}



undefined2 * txu_cntrl_sec_hdr_append(int param_1,undefined2 *param_2,int param_3)

{
  uint8_t uVar1;
  ushort uVar2;
  undefined2 *puVar3;
  int iVar4;
  key_info_tag *pkVar5;
  
  pkVar5 = *sta_info_tab[*(byte *)(param_1 + 0x30)].sta_sec_info.cur_key;
  if (pkVar5 == (key_info_tag *)0x0) {
    return param_2;
  }
  if (((vif_info_tab[*(byte *)(param_1 + 0x2f)].flags & 2) != 0) &&
     ((uint)sta_info_tab[*(byte *)(param_1 + 0x30)].ctrl_port_ethertype ==
      (((uint)*(ushort *)(param_1 + 0x20) & 0xff) << 8 | (uint)(*(ushort *)(param_1 + 0x20) >> 8))))
  {
    return param_2;
  }
  uVar1 = pkVar5->cipher;
  if (uVar1 == '\x01') {
    param_2[-4] = *(ushort *)(param_1 + 0x22) & 0x7f00 | 0x2000 | *(ushort *)(param_1 + 0x22) >> 8;
    uVar2 = (ushort)*(byte *)(param_1 + 0x22) | (ushort)pkVar5->key_idx << 0xe;
LAB_2304e702:
    puVar3 = param_2 + -4;
    param_2[-3] = uVar2 | 0x2000;
    param_2[-2] = *(undefined2 *)(param_1 + 0x24);
    param_2[-1] = *(undefined2 *)(param_1 + 0x26);
  }
  else {
    if (uVar1 != '\0') {
      if (uVar1 == '\x02') {
        param_2[-4] = *(undefined2 *)(param_1 + 0x22);
        uVar2 = (ushort)pkVar5->key_idx << 0xe;
        goto LAB_2304e702;
      }
      puVar3 = param_2;
      if (uVar1 != '\x03') goto LAB_2304e6b4;
    }
    puVar3 = param_2 + -2;
    *puVar3 = *(undefined2 *)(param_1 + 0x22);
    param_2[-1] = (ushort)pkVar5->key_idx << 0xe | *(ushort *)(param_1 + 0x24);
  }
LAB_2304e6b4:
  if (param_3 == 0) {
    iVar4 = *(int *)(param_1 + 0x68) + 0xf0;
  }
  else {
    iVar4 = *(int *)(param_1 + 0x54);
  }
  *(uint *)(iVar4 + 0xc) = (uint)pkVar5->hw_key_idx | *(uint *)(iVar4 + 0xc) & 0xffc00;
  return puVar3;
}



int txu_cntrl_sechdr_len_compute(txdesc *txdesc,int *tail_len)

{
  byte bVar1;
  uint8_t uVar2;
  ushort uVar3;
  int iVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  key_info_tag *pkVar8;
  
  bVar1 = (txdesc->host).vif_idx;
  pkVar8 = *sta_info_tab[(txdesc->host).staid].sta_sec_info.cur_key;
  *tail_len = 0;
  if (pkVar8 == (key_info_tag *)0x0) {
    return 0;
  }
  if (((vif_info_tab[bVar1].flags & 2) != 0) &&
     (uVar3 = (txdesc->host).ethertype,
     (uint)sta_info_tab[(txdesc->host).staid].ctrl_port_ethertype ==
     (((uint)uVar3 & 0xff) << 8 | (uint)(uVar3 >> 8)))) {
    return 0;
  }
  uVar2 = pkVar8->cipher;
  if (uVar2 == '\x01') {
    iVar4 = 0xc;
LAB_2304e7f8:
    *tail_len = iVar4;
    if (((txdesc->host).flags & 1) == 0) {
      uVar7 = *(uint *)&pkVar8->tx_pn;
      iVar4 = *(int *)((int)&pkVar8->tx_pn + 4);
      uVar6 = uVar7 + 1;
      *(uint *)&pkVar8->tx_pn = uVar6;
      *(int *)((int)&pkVar8->tx_pn + 4) = (uint)(uVar6 < uVar7) + iVar4;
      memcpy((txdesc->host).pn,&pkVar8->tx_pn,6);
    }
    iVar4 = 8;
  }
  else {
    if (uVar2 != '\0') {
      if (uVar2 == '\x02') {
        iVar4 = 8;
        goto LAB_2304e7f8;
      }
      if (uVar2 != '\x03') {
        return 0;
      }
    }
    *tail_len = 4;
    iVar4 = 4;
    if (((txdesc->host).flags & 1) == 0) {
      uVar7 = *(uint *)&pkVar8->tx_pn;
      iVar5 = *(int *)((int)&pkVar8->tx_pn + 4);
      uVar6 = uVar7 + 1;
      *(uint *)&pkVar8->tx_pn = uVar6;
      *(int *)((int)&pkVar8->tx_pn + 4) = (uint)(uVar6 < uVar7) + iVar5;
      memcpy((txdesc->host).pn,&pkVar8->tx_pn,4);
    }
  }
  return iVar4;
}



void txu_cntrl_frame_build(txdesc *txdesc,uint32_t buf)

{
  uint8_t uVar1;
  byte bVar2;
  int iVar3;
  ushort *puVar4;
  ushort *puVar5;
  uint uVar6;
  ushort uVar7;
  ushort uVar8;
  ushort *puVar9;
  uint uVar10;
  key_info_tag *pkVar11;
  
  uVar8 = (txdesc->host).ethertype;
  if (0x5ff < (((uint)uVar8 & 0xff) << 8 | (uint)(uVar8 >> 8))) {
    *(undefined2 *)(buf - 8) = 0xaaaa;
    *(undefined2 *)(buf - 6) = 3;
    *(undefined2 *)(buf - 4) = 0;
    *(uint16_t *)(buf - 2) = (txdesc->host).ethertype;
  }
  iVar3 = txu_cntrl_sec_hdr_append(txdesc,1);
  uVar6 = (uint)(txdesc->host).staid;
  uVar1 = (txdesc->host).tid;
  uVar10 = (uint)(txdesc->host).vif_idx;
  pkVar11 = *sta_info_tab[uVar6].sta_sec_info.cur_key;
  puVar9 = (ushort *)(iVar3 + -0x1a);
  if (uVar1 == -1) {
    puVar9 = (ushort *)(iVar3 + -0x18);
  }
  puVar4 = puVar9 + 0xc;
  puVar5 = (ushort *)0x0;
  if (((txdesc->host).flags & 0x100) != 0) {
    puVar5 = puVar9 + -3;
    puVar9 = puVar5;
  }
  if (uVar1 == -1) {
    *(undefined *)puVar9 = 0;
    *(undefined *)((int)puVar9 + 1) = 0;
    *(undefined *)(puVar9 + 0xb) = 0;
    *(undefined *)((int)puVar9 + 0x17) = 0;
  }
  else {
    *(undefined *)puVar9 = 0x80;
    *(undefined *)((int)puVar9 + 1) = 0;
    *puVar4 = (ushort)(txdesc->host).tid;
    iVar3 = (uint)(txdesc->host).sn << 0x14;
    *(char *)(puVar9 + 0xb) = (char)((uint)iVar3 >> 0x10);
    *(undefined *)((int)puVar9 + 0x17) = (char)((uint)iVar3 >> 0x18);
    if (((txdesc->host).flags & 0x200) != 0) {
      *puVar4 = *puVar4 | 0x10;
    }
  }
  uVar7 = *puVar9;
  *(byte *)puVar9 = (byte)uVar7 | 8;
  *(undefined *)((int)puVar9 + 1) = (char)((uint)uVar7 >> 8);
  uVar8 = (txdesc->host).flags;
  if ((int)((uint)uVar8 << 0x14) < 0) {
    uVar7 = uVar7 & 0xfcff | 8;
LAB_2304e93a:
    *(char *)puVar9 = (char)uVar7;
    *(undefined *)((int)puVar9 + 1) = (char)(uVar7 >> 8);
  }
  else {
    if ((uVar8 & 0x100) != 0) {
      uVar7 = uVar7 | 0x308;
      goto LAB_2304e93a;
    }
    if (vif_info_tab[uVar10].type == '\0') {
      uVar7 = uVar7 | 0x108;
      goto LAB_2304e93a;
    }
    if (vif_info_tab[uVar10].type == '\x02') {
      uVar7 = uVar7 | 0x208;
      goto LAB_2304e93a;
    }
  }
  if (((txdesc->host).flags & 4) != 0) {
    uVar8 = *puVar9;
    *(char *)puVar9 = (char)uVar8;
    *(byte *)((int)puVar9 + 1) = (byte)((uint)uVar8 >> 8) | 0x20;
  }
  puVar9[5] = vif_info_tab[uVar10].mac_addr.array[0];
  puVar9[6] = vif_info_tab[uVar10].mac_addr.array[1];
  puVar9[7] = vif_info_tab[uVar10].mac_addr.array[2];
  bVar2 = *(byte *)((int)puVar9 + 1) & 3;
  if (bVar2 == 1) {
    puVar9[2] = sta_info_tab[uVar6].mac_addr.array[0];
    puVar9[3] = sta_info_tab[uVar6].mac_addr.array[1];
    puVar9[4] = sta_info_tab[uVar6].mac_addr.array[2];
    puVar9[8] = (txdesc->host).eth_dest_addr.array[0];
    puVar9[9] = (txdesc->host).eth_dest_addr.array[1];
    uVar8 = (txdesc->host).eth_dest_addr.array[2];
  }
  else {
    if (bVar2 == 2) {
      puVar9[2] = (txdesc->host).eth_dest_addr.array[0];
      puVar9[3] = (txdesc->host).eth_dest_addr.array[1];
      puVar9[4] = (txdesc->host).eth_dest_addr.array[2];
      puVar9[8] = (txdesc->host).eth_src_addr.array[0];
      puVar9[9] = (txdesc->host).eth_src_addr.array[1];
      uVar8 = (txdesc->host).eth_src_addr.array[2];
    }
    else {
      if (bVar2 != 0) {
        puVar5[2] = sta_info_tab[uVar6].mac_addr.array[0];
        puVar5[3] = sta_info_tab[uVar6].mac_addr.array[1];
        puVar5[4] = sta_info_tab[uVar6].mac_addr.array[2];
        puVar5[8] = (txdesc->host).eth_dest_addr.array[0];
        puVar5[9] = (txdesc->host).eth_dest_addr.array[1];
        puVar5[10] = (txdesc->host).eth_dest_addr.array[2];
        puVar5[0xc] = (txdesc->host).eth_src_addr.array[0];
        puVar5[0xd] = (txdesc->host).eth_src_addr.array[1];
        puVar5[0xe] = (txdesc->host).eth_src_addr.array[2];
        goto LAB_2304e9de;
      }
      puVar9[2] = (txdesc->host).eth_dest_addr.array[0];
      puVar9[3] = (txdesc->host).eth_dest_addr.array[1];
      puVar9[4] = (txdesc->host).eth_dest_addr.array[2];
      puVar9[8] = vif_info_tab[uVar10].bss_info.bssid.array[0];
      puVar9[9] = vif_info_tab[uVar10].bss_info.bssid.array[1];
      uVar8 = vif_info_tab[uVar10].bss_info.bssid.array[2];
    }
  }
  puVar9[10] = uVar8;
LAB_2304e9de:
  if ((pkVar11 != (key_info_tag *)0x0) &&
     (((vif_info_tab[uVar10].flags & 2) == 0 ||
      (uVar8 = (txdesc->host).ethertype,
      (uint)sta_info_tab[(txdesc->host).staid].ctrl_port_ethertype !=
      (((uint)uVar8 & 0xff) << 8 | (uint)(uVar8 >> 8)))))) {
    uVar8 = *puVar9;
    *(char *)puVar9 = (char)uVar8;
    *(byte *)((int)puVar9 + 1) = (byte)((uint)uVar8 >> 8) | 0x40;
  }
  return;
}


/*
Unable to decompile 'txu_cntrl_push'
Cause: Exception while decompiling 2304eb44: Decompiler process died

*/


void txu_cntrl_tkip_mic_append(txdesc *txdesc,uint8_t ac)

{
  uint8_t uVar1;
  byte bVar2;
  byte bVar3;
  txl_buffer_tag *ptVar4;
  uint32_t uVar5;
  int iVar6;
  key_info_tag *pkVar7;
  int iVar8;
  tx_pbd *ptVar9;
  undefined *puVar10;
  undefined *puVar11;
  tx_pbd *ptVar12;
  txl_buffer_tag *ptVar13;
  undefined auStack48 [4];
  mic_calc mic;
  
  pkVar7 = *sta_info_tab[(txdesc->host).staid].sta_sec_info.cur_key;
  if (pkVar7 != (key_info_tag *)0x0) {
    uVar1 = pkVar7->cipher;
    ptVar4 = (txdesc->lmac).buffer;
    if (uVar1 != '\x01') {
      if ((uVar1 == '\0') || (uVar1 == '\x03')) {
        ptVar9 = &ptVar4->tbd;
        do {
          ptVar12 = ptVar9;
          ptVar9 = (tx_pbd *)ptVar12->next;
        } while (ptVar9 != (tx_pbd *)0x0);
        *(tx_pbd **)&ptVar12->next = &ptVar4->tkip_mic_icv_pbd;
        *(uint8_t **)&(ptVar4->tkip_mic_icv_pbd).datastartptr = ptVar4->tkip_mic_icv;
        *(uint8_t **)&(ptVar4->tkip_mic_icv_pbd).dataendptr = ptVar4->tkip_mic_icv + 3;
        (ptVar4->tkip_mic_icv_pbd).upatterntx = 0xcafefade;
        (ptVar4->tkip_mic_icv_pbd).bufctrlinfo = 0;
        (ptVar4->tkip_mic_icv_pbd).next = 0;
      }
      return;
    }
    ptVar9 = &ptVar4->tbd;
    do {
      ptVar12 = ptVar9;
      ptVar9 = (tx_pbd *)ptVar12->next;
    } while (ptVar9 != (tx_pbd *)0x0);
    bVar2 = (txdesc->umac).head_len;
    bVar3 = (txdesc->umac).hdr_len_802_2;
    *(tx_pbd **)&ptVar12->next = &ptVar4->tkip_mic_icv_pbd;
    *(uint8_t **)&(ptVar4->tkip_mic_icv_pbd).datastartptr = ptVar4->tkip_mic_icv;
    *(uint8_t **)&(ptVar4->tkip_mic_icv_pbd).dataendptr = ptVar4->tkip_mic_icv + 0xb;
    (ptVar4->tkip_mic_icv_pbd).upatterntx = 0xcafefade;
    (ptVar4->tkip_mic_icv_pbd).bufctrlinfo = 0;
    (ptVar4->tkip_mic_icv_pbd).next = 0;
    ptVar13 = (txdesc->lmac).buffer;
    me_mic_init((mic_calc *)auStack48,(uint32_t *)pkVar7->u,
                (mac_addr_conflict51 *)&(txdesc->host).eth_dest_addr,
                (mac_addr_conflict51 *)&(txdesc->host).eth_src_addr,(txdesc->host).tid);
    me_mic_calc((mic_calc *)auStack48,(int)ptVar4 + (uint)bVar2 + (0x14c - (uint)bVar3),
                (uint)(txdesc->umac).hdr_len_802_2);
    uVar5 = (ptVar13->tbd).next;
    while (uVar5 != 0) {
      iVar6 = *(int *)(uVar5 + 4);
      if (iVar6 == 0) {
        me_mic_end((mic_calc *)auStack48);
        iVar8 = *(int *)(uVar5 + 8);
        do {
          puVar10 = auStack48 + iVar6;
          puVar11 = (undefined *)(iVar8 + iVar6);
          iVar6 = iVar6 + 1;
          *puVar11 = *puVar10;
        } while (iVar6 != 8);
        return;
      }
      me_mic_calc((mic_calc *)auStack48,*(uint32_t *)(uVar5 + 8),
                  (*(int *)(uVar5 + 0xc) + 1) - *(uint32_t *)(uVar5 + 8));
      uVar5 = *(uint32_t *)(uVar5 + 4);
    }
    me_mic_end((mic_calc *)auStack48);
    ebreak();
  }
  return;
}



void txu_cntrl_cfm(txdesc *txdesc)

{
  ushort uVar1;
  tx_cfm_tag *ptVar2;
  uint32_t *puVar3;
  
  puVar3 = (uint32_t *)(txdesc->host).status_addr;
  ptVar2 = ((txdesc->lmac).hw_desc)->cfm_ptr;
  uVar1 = (txdesc->host).flags;
  if ((uVar1 & 8) == 0) {
    if ((uVar1 & 0x200) == 0) goto LAB_2304eeba;
  }
  else {
    if (((uVar1 & 0x20) != 0) && (-1 < (int)(ptVar2->status << 8))) {
      rxu_cntrl_get_pm();
    }
    if (((txdesc->host).flags & 0x200) == 0) goto LAB_2304eeba;
    if ((txdesc->host).staid == -1) {
      assert_err("txdesc->host.staid != INVALID_STA_IDX","module",0x3a9);
    }
    txl_frame_send_qosnull_frame((txdesc->host).staid,0x17,(cfm_func_ptr *)0x0,(void *)0x0);
  }
  sta_info_tab[(txdesc->host).staid].ps_service_period = 0;
LAB_2304eeba:
  ptVar2->status = ptVar2->status | 1;
  *(undefined2 *)&ptVar2->credits = 0x101;
  txdesc[-1].buf[0x6b] = 0;
  *puVar3 = ptVar2->status;
  return;
}



void txu_cntrl_protect_mgmt_frame(txdesc *txdesc,uint32_t frame,uint16_t hdr_len)

{
  byte bVar1;
  ushort uVar2;
  uint uVar3;
  undefined2 in_register_00002032;
  uint uStack20;
  int tail_len;
  
  bVar1 = (txdesc->umac).head_len;
  uVar3 = (uint)bVar1;
  if (bVar1 == 0) {
    uVar3 = txu_cntrl_sechdr_len_compute(txdesc,(int *)&uStack20);
    (txdesc->umac).head_len = (uint8_t)uVar3;
    (txdesc->umac).tail_len = (uint8_t)uStack20;
  }
  else {
    uStack20 = (uint)(txdesc->umac).tail_len;
  }
  uVar2 = *(ushort *)frame;
  *(undefined *)frame = *(undefined *)frame;
  *(byte *)(frame + 1) = (byte)((uint)uVar2 >> 8) | 0x40;
  txu_cntrl_sec_hdr_append(txdesc,CONCAT22(in_register_00002032,hdr_len) + frame + uVar3,0);
  return;
}



int _aid_list_delete(uint8_t *mac)

{
  int iVar1;
  int iVar2;
  apm *paVar3;
  
  paVar3 = &apm_env;
  iVar1 = 0;
  do {
    if (paVar3->aid_list[0].used != '\0') {
      iVar2 = memcmp(paVar3->aid_list,mac,6);
      if (iVar2 == 0) {
        memset(paVar3->aid_list,0,6);
        apm_env.aid_list[iVar1].used = '\0';
        return 0;
      }
    }
    iVar1 = iVar1 + 1;
    paVar3 = (apm *)((int)&(paVar3->bss_config).first + 3);
  } while (iVar1 != 10);
  return -1;
}



void apm_sta_delete(u8_l sta_idx,uint8_t *mac)

{
  u8_l *puVar1;
  u8_l *puVar2;
  
  puVar1 = (u8_l *)ke_msg_alloc(0x1409,5,7,2);
  puVar2 = (u8_l *)ke_msg_alloc(0x1c09,0xd,7,1);
  _aid_list_delete(mac);
  mm_sec_machwkey_del(sta_idx + '\b');
  apm_env.assoc_sta_count = apm_env.assoc_sta_count + -1;
  *puVar2 = sta_idx;
  ke_msg_send(puVar2);
  *puVar1 = sta_idx;
  puVar1[1] = '\0';
  ke_msg_send(puVar1);
  return;
}



void apm_tx_cfm_handler(uint8_t *param_1,int param_2)

{
  if (-1 < param_2 << 8) {
    _aid_list_delete(param_1);
    ke_msg_free(param_1 + -0xc);
    printf("apm mlme assoc rsp send failed:%d,aid:%d\n",(uint)*(ushort *)(param_1 + 0x44));
    apm_env.assoc_sta_count = apm_env.assoc_sta_count + -1;
    return;
  }
  if (*(short *)(param_1 + 0x44) != 0) {
    ke_msg_send();
    return;
  }
  ke_msg_free(param_1 + -0xc);
  return;
}



void apm_init(void)

{
  memset(&apm_env,0,0x60);
  apm_env.aging_sta_idx = '\0';
  apm_env._22_2_ = 0xc00;
  ke_state_set(7,0);
  return;
}



void apm_start_cfm(int param_1)

{
  byte bVar1;
  u16_l uVar2;
  apm_start_req *__src;
  undefined *puVar3;
  void *pvVar4;
  uint uVar5;
  int iVar6;
  
  __src = apm_env.param;
  puVar3 = (undefined *)ke_msg_alloc(0x1c01,0xd,7,4);
  if (param_1 == 0) {
    uVar5 = (uint)__src->vif_idx;
    pvVar4 = ke_msg_alloc(0x1e,0,7,4);
    iVar6 = uVar5 + 10;
    *(undefined *)((int)pvVar4 + 2) = 1;
    *(uint8_t *)((int)pvVar4 + 3) = vif_info_tab[uVar5].index;
    ke_msg_send();
    vif_info_tab[uVar5].flags = __src->flags;
    uVar2 = __src->ctrl_port_ethertype;
    vif_info_tab[uVar5].u[0x2ee] = 0;
    *(u16_l *)(vif_info_tab[uVar5].u + 0x2f0) = uVar2;
    puVar3[2] = (vif_info_tab[uVar5].chan_ctxt)->idx;
    puVar3[3] = __src->vif_idx + '\n';
    memcpy(&sta_info_tab[iVar6].info,__src,0xd);
    sta_info_tab[iVar6].ctrl_port_state = '\x02';
    me_init_bcmc_rate(sta_info_tab + iVar6);
    bVar1 = sta_info_tab[iVar6].pol_tbl.upd_field;
    sta_info_tab[iVar6].mac_addr.array[0] = 1;
    sta_info_tab[iVar6].pol_tbl.upd_field = bVar1 | 0x10;
    sta_info_tab[iVar6].staid = __src->vif_idx + '\n';
  }
  *puVar3 = (char)param_1;
  puVar3[1] = __src->vif_idx;
  ke_timer_set(0x1c0a,7,5000000);
  ke_msg_send(puVar3);
  ke_msg_free(__src[-1].phrase + 0x35);
  apm_env.param = (apm_start_req *)0x0;
  ke_state_set(7,0);
  return;
}



void apm_send_next_bss_param(void)

{
  co_list_hdr *pcVar1;
  
  pcVar1 = co_list_pop_front(&apm_env.bss_config);
  if (pcVar1 == (co_list_hdr *)0x0) {
    assert_err("msg != NULL","module",0xbf);
  }
  ke_msg_send(pcVar1 + 3);
  return;
}



void apm_set_bss_param(void)

{
  byte bVar1;
  apm_start_req *rateset;
  uint16_t uVar2;
  undefined *puVar3;
  void *__dest;
  undefined4 *puVar4;
  u16_l *puVar5;
  undefined *puVar6;
  undefined2 extraout_var;
  
  rateset = apm_env.param;
  bVar1 = (apm_env.param)->vif_idx;
  puVar3 = (undefined *)ke_msg_alloc(0x1413,5,7,2);
  __dest = ke_msg_alloc(0x18,0,7,7);
  puVar4 = (undefined4 *)ke_msg_alloc(0x16,0,7,8);
  puVar5 = (u16_l *)ke_msg_alloc(0x14,0,7,4);
  puVar6 = (undefined *)ke_msg_alloc(0x1411,5,7,2);
  *puVar3 = 1;
  puVar3[1] = vif_info_tab[bVar1].index;
  co_list_push_back(&apm_env.bss_config,(co_list_hdr *)(puVar3 + -0xc));
  memcpy(__dest,&vif_info_tab[bVar1].mac_addr,6);
  *(u8_l *)((int)__dest + 6) = rateset->vif_idx;
  co_list_push_back(&apm_env.bss_config,(co_list_hdr *)((int)__dest + -0xc));
  *(u8_l *)((int)puVar4 + 5) = (rateset->chan).band;
  uVar2 = me_legacy_rate_bitfield_build((mac_rateset *)rateset,true);
  *puVar4 = CONCAT22(extraout_var,uVar2);
  *(u8_l *)(puVar4 + 1) = rateset->vif_idx;
  co_list_push_back(&apm_env.bss_config,(co_list_hdr *)(puVar4 + -3));
  *puVar5 = rateset->bcn_int;
  *(u8_l *)(puVar5 + 1) = rateset->vif_idx;
  co_list_push_back(&apm_env.bss_config,(co_list_hdr *)(puVar5 + -6));
  *puVar6 = 1;
  puVar6[1] = rateset->vif_idx;
  co_list_push_back(&apm_env.bss_config,(co_list_hdr *)(puVar6 + -0xc));
  apm_send_next_bss_param();
  ke_state_set(7,1);
  return;
}



void apm_stop(vif_info_tag *vif)

{
  undefined *puVar1;
  undefined *puVar2;
  void *pvVar3;
  
  puVar1 = (undefined *)ke_msg_alloc(0x1413,5,7,2);
  puVar2 = (undefined *)ke_msg_alloc(0x1411,5,7,2);
  ke_timer_clear(0x1c0a,7);
  *puVar1 = 0;
  puVar1[1] = vif->index;
  ke_msg_send(puVar1);
  if (vif->active != false) {
    pvVar3 = ke_msg_alloc(0x1e,0,7,4);
    *(undefined *)((int)pvVar3 + 2) = 0;
    *(uint8_t *)((int)pvVar3 + 3) = vif->index;
    ke_msg_send();
  }
  if (vif->chan_ctxt != (chan_ctxt_tag *)0x0) {
    chan_ctxt_unlink(vif->index);
  }
  *puVar2 = 0;
  puVar2[1] = vif->index;
  ke_msg_send(puVar2);
  return;
}



_Bool apm_tx_int_ps_check(txdesc *txdesc)

{
  byte bVar1;
  undefined uVar2;
  
  if (vif_info_tab[(txdesc->host).vif_idx].type == '\x02') {
    bVar1 = (txdesc->host).staid;
    uVar2 = 1;
    if (((bVar1 < 0xc) && (sta_info_tab[bVar1].ps_state == '\x01')) &&
       ((sta_info_tab[bVar1].ps_service_period & 3U) == 0)) {
      (txdesc->host).flags = (txdesc->host).flags | 0x1000;
      uVar2 = 0;
    }
  }
  else {
    uVar2 = 1;
  }
  return (_Bool)uVar2;
}



void apm_tx_int_ps_postpone(txdesc *txdesc,sta_info_tag *sta)

{
  byte bVar1;
  sta_ps_traffic sVar2;
  sta_ps_traffic sVar3;
  uint16_t *puVar4;
  
  if ((int)((uint)(txdesc->host).flags << 0x13) < 0) {
    bVar1 = (sta->info).uapsd_queues;
    sVar2 = sta->traffic_avail;
    if ((mac_ac2uapsd[(txdesc->host).tid] & bVar1) == 0) {
      if ((sVar2 & PS_TRAFFIC_INT) != 0) {
        return;
      }
      sVar3 = PS_TRAFFIC_INT;
    }
    else {
      sVar3 = UAPSD_TRAFFIC_INT;
      if ((sVar2 & UAPSD_TRAFFIC_INT) != 0) {
        return;
      }
    }
    sta->traffic_avail = sVar2 | sVar3;
    if (((mac_ac2uapsd[(txdesc->host).tid] & bVar1) == 0) || (bVar1 == 0xf)) {
      puVar4 = (uint16_t *)ke_msg_alloc(0x41,0,5,4);
      *puVar4 = sta->aid;
      *(uint8_t *)((int)puVar4 + 3) = sta->inst_nbr;
      *(undefined *)(puVar4 + 1) = 1;
      ke_msg_send();
      return;
    }
  }
  return;
}



// WARNING: Type propagation algorithm not settling

txdesc * apm_tx_int_ps_get_postpone(vif_info_tag *vif,sta_info_tag *sta,int *stop)

{
  uint8_t uVar1;
  ushort uVar2;
  co_list_hdr cVar3;
  co_list_hdr element;
  uint16_t *puVar4;
  co_list_hdr *pcVar5;
  uint uVar6;
  int *piVar7;
  sta_ps_traffic sVar8;
  sta_ps_traffic sVar9;
  co_list_hdr prev_element;
  
  sVar8 = vif->type;
  if ((sVar8 == PS_TRAFFIC_INT) && (uVar6 = sta->ps_service_period, uVar6 != 0)) {
    sVar9 = PS_TRAFFIC_HOST;
    if ((uVar6 & 1) == 0) {
      sVar9 = UAPSD_TRAFFIC_HOST;
      sVar8 = UAPSD_TRAFFIC_INT;
    }
    if ((sVar8 & sta->traffic_avail) != 0) {
      cVar3 = (co_list_hdr)(sta->tx_desc_post).first;
      prev_element = (co_list_hdr)(co_list_hdr *)0x0;
      while( true ) {
        element = cVar3;
        if (element == (co_list_hdr)0x0) {
          assert_warn("txdesc","module",0x16f);
          *stop = 1;
          return (txdesc *)0x0;
        }
        if (((mac_ac2uapsd[*(byte *)((int)element + 0x2e)] & (sta->info).uapsd_queues) == 0) !=
            (uVar6 == 2)) break;
        cVar3 = *(co_list_hdr *)element;
        prev_element = element;
      }
      co_list_remove(&sta->tx_desc_post,(co_list_hdr *)prev_element,(co_list_hdr *)element);
      *(char *)((int)element + 0x2e) = ((sta->ps_service_period & 8U) != 0) + '\x03';
      if (prev_element == (co_list_hdr)0x0) {
        piVar7 = (int *)(sta->tx_desc_post).first;
      }
      else {
        piVar7 = (int *)((co_list_hdr *)prev_element)->next;
      }
      while (piVar7 != (int *)0x0) {
        if (((mac_ac2uapsd[*(byte *)((int)piVar7 + 0x2e)] & (sta->info).uapsd_queues) == 0) !=
            (sta->ps_service_period == 2)) goto LAB_2304f5ce;
        piVar7 = (int *)*piVar7;
      }
      sVar8 = ~sVar8 & sta->traffic_avail;
      sta->traffic_avail = sVar8;
      if ((sVar8 & sVar9) == 0) {
        puVar4 = (uint16_t *)ke_msg_alloc(0x41,0,5,4);
        *puVar4 = sta->aid;
        uVar1 = sta->inst_nbr;
        *(undefined *)(puVar4 + 1) = 0;
        *(uint8_t *)((int)puVar4 + 3) = uVar1;
        ke_msg_send();
      }
      else {
LAB_2304f5ce:
        pcVar5 = ((co_list_hdr *)((int)element + 0x68))->next;
        uVar2 = *(ushort *)&pcVar5[0x53].next;
        *(char *)&pcVar5[0x53].next = (char)uVar2;
        *(byte *)((int)&pcVar5[0x53].next + 1) = (byte)((uint)uVar2 >> 8) | 0x20;
      }
      return (txdesc *)element;
    }
    *stop = 1;
  }
  else {
    *stop = 0;
  }
  return (txdesc *)0x0;
}



void apm_tx_int_ps_clear(vif_info_tag *vif,u8_l sta_idx)

{
  sta_ps_traffic sVar1;
  uint8_t uVar2;
  uint16_t *puVar3;
  undefined3 in_register_0000202d;
  int iVar4;
  
  iVar4 = CONCAT31(in_register_0000202d,sta_idx);
  if (vif->type != '\x02') {
    return;
  }
  sta_mgmt_send_postponed_frame(vif,sta_info_tab + iVar4,0);
  sVar1 = sta_info_tab[iVar4].traffic_avail;
  if (((sVar1 & (PS_TRAFFIC_INT|UAPSD_TRAFFIC_INT)) != 0) &&
     (sta_info_tab[iVar4].traffic_avail = sVar1 & ~(PS_TRAFFIC_INT|UAPSD_TRAFFIC_INT),
     (sVar1 & ~(PS_TRAFFIC_INT|UAPSD_TRAFFIC_INT)) == 0)) {
    puVar3 = (uint16_t *)ke_msg_alloc(0x41,0,5,4);
    *puVar3 = sta_info_tab[iVar4].aid;
    uVar2 = sta_info_tab[iVar4].inst_nbr;
    *(undefined *)(puVar3 + 1) = 0;
    *(uint8_t *)((int)puVar3 + 3) = uVar2;
    ke_msg_send();
    return;
  }
  return;
}



void apm_sta_fw_delete(u8_l sta_idx)

{
  undefined3 in_register_00002029;
  
  apm_sta_delete(sta_idx,(uint8_t *)&sta_info_tab[CONCAT31(in_register_00002029,sta_idx)].mac_addr);
  return;
}



void apm_sta_add(u8_l sta_idx)

{
  undefined3 in_register_00002029;
  int iVar1;
  uint32_t *puVar2;
  
  iVar1 = CONCAT31(in_register_00002029,sta_idx);
  puVar2 = (uint32_t *)ke_msg_alloc(0x1c08,0xd,7,0x1c);
  sta_info_tab[iVar1].ctrl_port_state = '\x02';
  *puVar2 = sta_info_tab[iVar1].info.capa_flags;
  memcpy(puVar2 + 1,&sta_info_tab[iVar1].mac_addr,6);
  *(uint8_t *)((int)puVar2 + 0xb) = sta_info_tab[iVar1].staid;
  *(uint8_t *)((int)puVar2 + 10) = sta_info_tab[iVar1].inst_nbr;
  *(int8_t *)(puVar2 + 3) = sta_info_tab[iVar1].rssi;
  puVar2[4] = sta_info_tab[iVar1].tsflo;
  puVar2[5] = sta_info_tab[iVar1].tsfhi;
  *(uint8_t *)(puVar2 + 6) = sta_info_tab[iVar1].data_rate;
  ke_msg_send(puVar2);
  return;
}



void apm_send_mlme(vif_info_tag *vif,uint16_t fctl,mac_addr_conflict75 *ra,cfm_func_ptr *cfm_func,
                  void *env,uint16_t status_code)

{
  uint8_t uVar1;
  txl_buffer_tag *ptVar2;
  uint16_t uVar3;
  txl_frame_desc_tag *frame;
  undefined2 in_register_0000202e;
  uint uVar4;
  int iVar5;
  tx_hw_desc *ptVar6;
  
  _uVar3 = CONCAT22(in_register_0000202e,fctl);
  frame = txl_frame_get((uint)(((vif->bss_info).chan)->band != '\0'),0x100);
  if (frame == (txl_frame_desc_tag *)0x0) {
    return;
  }
  ptVar2 = (frame->txdesc).lmac.buffer;
  *(undefined *)((int)&ptVar2[1].length + 1) = (char)(fctl >> 8);
  *(char *)&ptVar2[1].length = (char)fctl;
  *(undefined *)((int)&ptVar2[1].length + 2) = 0;
  *(undefined *)((int)&ptVar2[1].length + 3) = 0;
  memcpy(&ptVar2[1].lenheader,ra,6);
  memcpy((void *)((int)&ptVar2[1].lenpad + 2),&vif->mac_addr,6);
  memcpy(&ptVar2[1].next,&vif->mac_addr,6);
  uVar4 = (uint)txl_cntrl_env.seqnbr;
  txl_cntrl_env.seqnbr = (uint16_t)((uVar4 + 1) * 0x10000 >> 0x10);
  iVar5 = (uVar4 + 1) * 0x100000;
  *(undefined *)((int)&ptVar2[1].txdesc + 2) = (char)((uint)iVar5 >> 0x10);
  *(undefined *)((int)&ptVar2[1].txdesc + 3) = (char)((uint)iVar5 >> 0x18);
  if (_uVar3 == 0xb0) {
    uVar3 = me_build_authenticate((uint32_t)ptVar2[1].dma_desc,0,2,0,(uint32_t *)0x0);
    _uVar3 = (uint)uVar3;
  }
  else {
    if (_uVar3 == 0xc0) {
      uVar3 = me_build_deauthenticate((uint32_t)ptVar2[1].dma_desc,status_code);
      _uVar3 = (uint)uVar3;
    }
    else {
      if (_uVar3 == 0x50) {
        uVar3 = me_build_probe_rsp((uint32_t)ptVar2[1].dma_desc,vif->index);
        _uVar3 = (uint)uVar3;
      }
      else {
        uVar4 = 0x18;
        if ((_uVar3 & 0xffffffdf) != 0x10) goto LAB_2304f826;
        uVar3 = me_build_associate_rsp
                          ((uint32_t)ptVar2[1].dma_desc,vif->index,status_code,(me_sta_add_req *)env
                          );
        _uVar3 = (uint)uVar3;
      }
    }
  }
  uVar4 = _uVar3 + 0x18 & 0xffff;
LAB_2304f826:
  ptVar6 = (frame->txdesc).lmac.hw_desc;
  (ptVar6->thd).frmlen = uVar4 + 4;
  (ptVar6->thd).field_5 = (ptVar6->thd).field_4 + -1 + uVar4;
  uVar1 = vif->index;
  (frame->txdesc).umac.head_len = '\0';
  (frame->txdesc).umac.tail_len = '\0';
  (frame->txdesc).host.vif_idx = uVar1;
  (frame->txdesc).host.staid = -1;
  (frame->cfm).cfm_func = cfm_func;
  (frame->cfm).env = env;
  txl_frame_push(frame,'\x03');
  return;
}



_Bool apm_embedded_enabled(vif_info_tag *vif)

{
  _Bool _Var1;
  
  if (vif != (vif_info_tag *)0x0) {
    _Var1 = false;
    if (vif->type == '\x02') {
      _Var1 = apm_env.apm_emb_enabled;
    }
    return (_Bool)(_Var1 & 1);
  }
  return apm_env.apm_emb_enabled;
}



void apm_bcn_set(void)

{
  byte bVar1;
  apm_start_req *paVar2;
  _Bool _Var3;
  u32_l *puVar4;
  undefined3 extraout_var;
  
  paVar2 = apm_env.param;
  puVar4 = (u32_l *)ke_msg_alloc(0x3f,0,7,(uint16_t)
                                          (((uint)(apm_env.param)->bcn_len + 0xc) * 0x10000 >> 0x10)
                                );
  *puVar4 = paVar2->bcn_addr;
  *(u16_l *)(puVar4 + 1) = paVar2->bcn_len;
  *(u16_l *)((int)puVar4 + 6) = paVar2->tim_oft;
  *(u8_l *)(puVar4 + 2) = paVar2->tim_len;
  bVar1 = paVar2->vif_idx;
  *(byte *)((int)puVar4 + 9) = bVar1;
  _Var3 = apm_embedded_enabled(vif_info_tab + bVar1);
  if (CONCAT31(extraout_var,_Var3) == 0) {
    memcpy(puVar4 + 3,(void *)&paVar2->field_0xa7,(uint)paVar2->bcn_len);
  }
  else {
    memcpy(puVar4 + 3,apm_env.bcn_buf,(uint)paVar2->bcn_len);
    ke_free(apm_env.bcn_buf);
    apm_env.bcn_buf = (uint8_t *)0x0;
  }
  ke_msg_send(puVar4);
  ke_state_set(7,2);
  return;
}



void apm_probe_req_handler(ushort *param_1)

{
  u8_l uVar1;
  ushort uVar2;
  int iVar3;
  vif_info_tag *vif;
  uint __n;
  scan_chan_tag *psVar4;
  int iVar5;
  uint uVar6;
  
  if (*(byte *)(param_1 + 4) == 0xff) {
    vif = vif_mgmt_get_first_ap_inf();
    if (vif == (vif_info_tag *)0x0) {
      return;
    }
  }
  else {
    vif = vif_info_tab + *(byte *)(param_1 + 4);
  }
  iVar3 = mac_ie_find(param_1 + 0x1a,(uint)*param_1 - 0x18 & 0xffff,0);
  if ((iVar3 == 0) || (*(byte *)(iVar3 + 1) == 0)) {
    if (apm_env.hidden_ssid != '\0') {
      return;
    }
  }
  else {
    __n = (uint)(vif->bss_info).ssid.length;
    if (__n != (uint)*(byte *)(iVar3 + 1)) {
      return;
    }
    iVar3 = memcmp((void *)(iVar3 + 2),(vif->bss_info).ssid.array,__n);
    if (iVar3 != 0) {
      return;
    }
  }
  iVar3 = mac_ie_find(param_1 + 0x1a,(uint)*param_1 - 0x18 & 0xffff,3);
  if (iVar3 == 0) goto LAB_2304fa0e;
  psVar4 = (vif->bss_info).chan;
  uVar1 = psVar4->band;
  uVar2 = psVar4->freq;
  __n = (uint)uVar2;
  if (uVar1 == '\0') {
    uVar6 = 0;
    if (((__n - 0x96c & 0xffff) < 0x49) && (uVar6 = 0xe, uVar2 != 0x9b4)) {
      iVar5 = -0x967;
LAB_2304fa84:
      uVar6 = (int)(__n + iVar5) / 5;
    }
  }
  else {
    uVar6 = 0;
    if ((uVar1 == '\x01') && (uVar6 = 0, (__n - 0x138d & 0xffff) < 0x335)) {
      iVar5 = -5000;
      goto LAB_2304fa84;
    }
  }
  if ((uint)*(byte *)(iVar3 + 2) != uVar6) {
    return;
  }
LAB_2304fa0e:
  apm_send_mlme(vif,0x50,(mac_addr_conflict75 *)(param_1 + 0x13),(cfm_func_ptr *)0x0,(void *)0x0,0);
  return;
}



void apm_auth_handler(rxu_mgt_ind *param)

{
  byte bVar1;
  mac_addr_conflict171 *addr;
  u8_l sta_idx;
  undefined3 extraout_var;
  
  bVar1 = param->inst_nbr;
  if (bVar1 != 0xff) {
    addr = (mac_addr_conflict171 *)(param[1].sa + 1);
    sta_idx = hal_machw_search_addr(addr);
    if (CONCAT31(extraout_var,sta_idx) != 0xff) {
      apm_sta_delete(sta_idx,(uint8_t *)addr);
    }
    apm_send_mlme(vif_info_tab + bVar1,0xb0,(mac_addr_conflict75 *)addr,(cfm_func_ptr *)0x0,
                  (void *)0x0,0);
    return;
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

void apm_assoc_req_handler(ushort *param_1,int param_2)

{
  u8_l uVar1;
  IEEEtypes_Addr_t IVar2;
  uint8_t uVar3;
  uint8_t uVar4;
  ushort *puVar5;
  byte bVar6;
  uint16_t status_code;
  IEEEtypes_MacAddr_t *peerMacAddr;
  int iVar7;
  int iVar8;
  undefined2 extraout_var;
  u8_l *puVar9;
  int iVar10;
  uint16_t fctl;
  uint __n;
  mac_rateset *pmVar11;
  IEEEtypes_Addr_t *pIVar12;
  IEEEtypes_Addr_t *pIVar13;
  uint uVar14;
  apm *paVar15;
  mac_addr_conflict75 *ra;
  short sVar16;
  uint uVar17;
  Cipher_t_conflict aCStack84 [4];
  undefined2 uStack80;
  
  uVar17 = (uint)*(byte *)(param_1 + 4);
  if (*(byte *)(param_1 + 4) == 0xff) {
    return;
  }
  peerMacAddr = (IEEEtypes_MacAddr_t *)ke_msg_alloc(0x1407,5,7,0x58);
  ra = (mac_addr_conflict75 *)(param_1 + 0x13);
  memset(peerMacAddr,0,0x58);
  memcpy(peerMacAddr,ra,6);
  (peerMacAddr + 0xc)[1] = *(IEEEtypes_Addr_t *)(param_1 + 4);
  *(undefined4 *)(peerMacAddr + 0xc + 4) = *(undefined4 *)(param_1 + 8);
  *(undefined4 *)(peerMacAddr + 0xd + 2) = *(undefined4 *)(param_1 + 10);
  (peerMacAddr + 0xe)[0] = *(IEEEtypes_Addr_t *)(param_1 + 0xc);
  (peerMacAddr + 0xe)[1] = *(IEEEtypes_Addr_t *)((int)param_1 + 0x1b);
  if (param_2 == 0) {
    puVar5 = param_1 + 0x1c;
    uVar14 = (uint)*param_1 - 0x1c;
  }
  else {
    puVar5 = param_1 + 0x1f;
    uVar14 = (uint)*param_1 - 0x22;
  }
  status_code = 0x33;
  if (param_1[0x1b] <= vif_info_tab[uVar17].bss_info.max_listen_interval) {
    uVar14 = uVar14 & 0xffff;
    iVar7 = mac_ie_find(puVar5,uVar14,0);
    if (((iVar7 == 0) ||
        (__n = (uint)vif_info_tab[uVar17].bss_info.ssid.length, __n != (uint)*(byte *)(iVar7 + 1)))
       || (iVar7 = memcmp((void *)(iVar7 + 2),vif_info_tab[uVar17].bss_info.ssid.array,__n),
          iVar7 != 0)) {
      status_code = 1;
    }
    else {
      iVar8 = mac_ie_find(puVar5,uVar14,1);
      status_code = 0x12;
      if (iVar8 != 0) {
        __n = (uint)*(byte *)(iVar8 + 1);
        puVar9 = (u8_l *)(iVar8 + 2);
        uStack80 = uStack80 & 0xff00 | (ushort)*(byte *)(iVar8 + 1);
        pmVar11 = (mac_rateset *)&uStack80;
        while( true ) {
          __n = __n - 1;
          pmVar11 = (mac_rateset *)pmVar11->array;
          if (__n == 0xffffffff) break;
          uVar1 = *puVar9;
          puVar9 = puVar9 + 1;
          pmVar11->length = uVar1;
        }
        iVar8 = mac_ie_find(puVar5,uVar14,0x32);
        if (iVar8 != 0) {
          bVar6 = *(byte *)(iVar8 + 1);
          __n = 0;
          while ((uint)bVar6 != __n) {
            *(undefined *)((int)&uStack80 + (byte)uStack80 + __n + 1) =
                 *(undefined *)(iVar8 + 2 + __n);
            __n = __n + 1;
          }
          uStack80 = uStack80 & 0xff00 | (ushort)(byte)(bVar6 + (byte)uStack80);
        }
        status_code = me_legacy_rate_bitfield_build((mac_rateset *)&uStack80,false);
        (peerMacAddr + 1)[0] = '\0';
        __n = 0;
        while (__n < vif_info_tab[uVar17].bss_info.rate_set.length) {
          iVar8 = (int)&vif_info_tab[uVar17].list_hdr.next + __n;
          bVar6 = me_rate_translate(*(uint8_t *)(iVar8 + 0x3b1));
          if ((CONCAT22(extraout_var,status_code) >> ((uint)bVar6 & 0x1f) & 1U) == 0) {
            if (*(char *)(iVar8 + 0x3b1) < '\0') {
              status_code = 0x12;
              goto fail;
            }
          }
          else {
            bVar6 = (peerMacAddr + 1)[0];
            (peerMacAddr + 1)[(uint)bVar6 + 1] = *(IEEEtypes_Addr_t *)(iVar8 + 0x3b1);
            (peerMacAddr + 1)[0] = bVar6 + 1;
          }
          __n = __n + 1 & 0xff;
        }
        iVar8 = mac_ie_find(puVar5,uVar14,0x2d);
        if (iVar8 != 0) {
          *(undefined2 *)(peerMacAddr + 3 + 2) = *(undefined2 *)(iVar8 + 2);
          pIVar12 = (IEEEtypes_Addr_t *)(iVar8 + 5);
          (peerMacAddr + 3)[4] = *(IEEEtypes_Addr_t *)(iVar8 + 4);
          pIVar13 = peerMacAddr + 3 + 5;
          while (pIVar13 != peerMacAddr + 6 + 3) {
            IVar2 = *pIVar12;
            pIVar12 = pIVar12 + 1;
            *pIVar13 = IVar2;
            pIVar13 = pIVar13 + 1;
          }
          *(undefined2 *)(peerMacAddr + 6 + 4) = *(undefined2 *)(iVar8 + 0x15);
          *(uint *)(peerMacAddr + 7 + 2) = (uint)*(ushort *)(iVar8 + 0x17);
          (peerMacAddr + 8)[0] = *(IEEEtypes_Addr_t *)(iVar8 + 0x1b);
          *(uint *)(peerMacAddr + 10 + 4) = *(uint *)(peerMacAddr + 10 + 4) | 2;
        }
        iVar8 = mac_vsie_find(puVar5,uVar14,&DAT_2307bf70,4);
        if (iVar8 != 0) {
          bVar6 = *(byte *)(iVar8 + 8);
          *(uint *)(peerMacAddr + 10 + 4) = *(uint *)(peerMacAddr + 10 + 4) | 1;
          (peerMacAddr + 0xb)[4] = bVar6 & 0xf;
          (peerMacAddr + 0xb)[5] = bVar6 >> 4 & 6;
        }
        memset((mac_rateset *)&uStack80,0,2);
        memset(aCStack84,0,1);
        iVar8 = mac_ie_find(puVar5,uVar14,0x30);
        if (iVar8 == 0) {
          iVar8 = mac_vsie_find(puVar5,uVar14,&DAT_2307bf78,4);
          if (iVar8 != 0) {
            uStack80 = uStack80 | 8;
            aCStack84[0] = (Cipher_t_conflict)((byte)aCStack84[0] | 4);
          }
        }
        else {
          uStack80 = uStack80 | 0x20;
          aCStack84[0] = (Cipher_t_conflict)((byte)aCStack84[0] | 8);
        }
        if (uap_conn_info != (cm_ConnectionInfo_t *)0x0) {
          status_code = 0x2e;
          if ((uStack80 & 0x28) == 0) goto fail;
          InitStaKeyInfo(uap_conn_info,(SecurityMode_t *)(mac_rateset *)&uStack80,aCStack84,0,'\0');
          cm_SetPeerAddr(uap_conn_info,(IEEEtypes_MacAddr_t *)0x0,peerMacAddr);
        }
        uVar4 = apm_env.max_sta_supported;
        uVar3 = apm_env.assoc_sta_count;
        *(undefined2 *)(peerMacAddr + 0xb + 2) = 0;
        if (uVar3 < uVar4) {
          paVar15 = &apm_env;
          iVar8 = -1;
          do {
            sVar16 = (short)iVar7;
            if (paVar15->aid_list[0].used == '\0') {
              if (iVar8 == -1) {
                iVar8 = iVar7;
              }
            }
            else {
              iVar10 = memcmp(paVar15->aid_list,ra,6);
              if (iVar10 == 0) {
                apm_env.aid_list[iVar7].used = '\x01';
                goto LAB_2304fea4;
              }
            }
            sVar16 = (short)iVar8;
            iVar7 = iVar7 + 1;
            paVar15 = (apm *)((int)&(paVar15->bss_config).first + 3);
          } while (iVar7 != 10);
          if (iVar8 != -1) {
            memcpy(apm_env.aid_list + iVar8,ra,6);
            apm_env.aid_list[iVar8].used = '\x01';
LAB_2304fea4:
            *(short *)(peerMacAddr + 0xb + 2) = sVar16 + 1;
            apm_env.assoc_sta_count = apm_env.assoc_sta_count + '\x01';
            status_code = 0;
            goto fail;
          }
        }
        status_code = 0x11;
      }
    }
  }
fail:
  fctl = 0x30;
  if (param_2 == 0) {
    fctl = 0x10;
  }
  apm_send_mlme(vif_info_tab + uVar17,fctl,ra,apm_tx_cfm_handler,peerMacAddr,status_code);
  return;
}



void apm_deauth_handler(rxu_mgt_ind *param)

{
  if ((param->inst_nbr != -1) && (param->sta_idx != -1)) {
    apm_sta_delete(param->sta_idx,param[1].sa + 1);
    return;
  }
  return;
}



void apm_disassoc_handler(rxu_mgt_ind *param)

{
  byte bVar1;
  
  bVar1 = param->inst_nbr;
  if ((bVar1 != 0xff) && (param->sta_idx != -1)) {
    apm_sta_delete(param->sta_idx,(uint8_t *)(mac_addr_conflict75 *)(param[1].sa + 1));
    apm_send_mlme(vif_info_tab + bVar1,0xc0,(mac_addr_conflict75 *)(param[1].sa + 1),
                  (cfm_func_ptr *)0x0,(void *)0x0,2);
    return;
  }
  return;
}



void apm_beacon_handler(rxu_mgt_ind *param)

{
  return;
}



void apm_sta_remove(u8_l vif_idx,u8_l sta_idx)

{
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  
  apm_send_mlme(vif_info_tab + CONCAT31(in_register_00002029,vif_idx),0xc0,
                (mac_addr_conflict75 *)
                &sta_info_tab[CONCAT31(in_register_0000202d,sta_idx)].mac_addr,(cfm_func_ptr *)0x0,
                (void *)0x0,2);
  apm_sta_delete(sta_idx,(uint8_t *)
                         (mac_addr_conflict75 *)
                         &sta_info_tab[CONCAT31(in_register_0000202d,sta_idx)].mac_addr);
  return;
}



void co_list_init(co_list *list)

{
  list->first = (co_list_hdr *)0x0;
  list->last = (co_list_hdr *)0x0;
  return;
}



void co_list_push_back(co_list *list,co_list_hdr *list_hdr)

{
  if (list_hdr == (co_list_hdr *)0x0) {
    assert_err("list_hdr != NULL","module",0x47);
  }
  if (list->first == (co_list_hdr *)0x0) {
    list->first = list_hdr;
  }
  else {
    list->last->next = list_hdr;
  }
  list->last = list_hdr;
  list_hdr->next = (co_list_hdr *)0x0;
  return;
}



void co_list_push_front(co_list *list,co_list_hdr *list_hdr)

{
  if (list_hdr == (co_list_hdr *)0x0) {
    assert_err("list_hdr != NULL","module",0x5e);
  }
  if (list->first == (co_list_hdr *)0x0) {
    list->last = list_hdr;
  }
  list_hdr->next = list->first;
  list->first = list_hdr;
  return;
}



co_list_hdr * co_list_pop_front(co_list *list)

{
  co_list_hdr *pcVar1;
  
  pcVar1 = list->first;
  if (pcVar1 != (co_list_hdr *)0x0) {
    list->first = pcVar1->next;
  }
  return pcVar1;
}



// WARNING: Type propagation algorithm not settling

void co_list_extract(co_list *list,co_list_hdr *list_hdr)

{
  co_list_hdr cVar1;
  co_list_hdr cVar2;
  
  if (list == (co_list *)0x0) {
    assert_err("list != NULL","module",0x81);
  }
  cVar1 = (co_list_hdr)list->first;
  if (cVar1 != (co_list_hdr)0x0) {
    if (cVar1 == (co_list_hdr)list_hdr) {
      list->first = list_hdr->next;
    }
    else {
      do {
        cVar2 = cVar1;
        cVar1 = *(co_list_hdr *)cVar2;
        if (cVar1 == (co_list_hdr)0x0) {
          return;
        }
      } while (cVar1 != (co_list_hdr)list_hdr);
      if (list->last == list_hdr) {
        *(co_list_hdr *)&((co_list_hdr *)&list->last)->next = cVar2;
      }
      *(co_list_hdr **)cVar2 = list_hdr->next;
    }
  }
  return;
}



// WARNING: Type propagation algorithm not settling

uint32_t co_list_cnt(co_list *list)

{
  uint32_t uVar1;
  int *piVar2;
  
  piVar2 = (int *)list->first;
  uVar1 = 0;
  while (piVar2 != (int *)0x0) {
    uVar1 = uVar1 + 1;
    piVar2 = (int *)*piVar2;
  }
  return uVar1;
}



// WARNING: Type propagation algorithm not settling

void co_list_insert(co_list *list,co_list_hdr *element,
                   anon_subr__Bool_co_list_hdr_ptr_co_list_hdr_ptr *cmp)

{
  co_list_hdr cVar1;
  co_list_hdr cVar2;
  _Bool _Var3;
  undefined3 extraout_var;
  co_list_hdr cVar4;
  
  cVar1 = (co_list_hdr)list->first;
  cVar4 = (co_list_hdr)(co_list_hdr *)0x0;
  while (cVar2 = cVar1, cVar2 != (co_list_hdr)0x0) {
    _Var3 = (*cmp)(element,(co_list_hdr *)cVar2);
    if (CONCAT31(extraout_var,_Var3) != 0) goto LAB_230500d4;
    cVar1 = *(co_list_hdr *)cVar2;
    cVar4 = cVar2;
  }
  list->last = element;
LAB_230500d4:
  *(co_list_hdr *)&element->next = cVar2;
  if (cVar4 == (co_list_hdr)0x0) {
    list->first = element;
  }
  else {
    ((co_list_hdr *)cVar4)->next = element;
  }
  return;
}



// WARNING: Type propagation algorithm not settling

void co_list_insert_after(co_list *list,co_list_hdr *prev_element,co_list_hdr *element)

{
  co_list_hdr cVar1;
  
  cVar1 = (co_list_hdr)list->first;
  if (prev_element == (co_list_hdr *)0x0) {
    co_list_push_front(list,element);
    return;
  }
  while( true ) {
    if (cVar1 == (co_list_hdr)0x0) {
      return;
    }
    if (cVar1 == (co_list_hdr)prev_element) break;
    cVar1 = *(co_list_hdr *)cVar1;
  }
  element->next = *(co_list_hdr **)cVar1;
  *(co_list_hdr **)cVar1 = element;
  if (element->next != (co_list_hdr *)0x0) {
    return;
  }
  list->last = element;
  return;
}



void co_list_remove(co_list *list,co_list_hdr *prev_element,co_list_hdr *element)

{
  if (list == (co_list *)0x0) {
    assert_err("list != NULL","module",0x168);
  }
  if (prev_element == (co_list_hdr *)0x0) {
    if (element == (co_list_hdr *)0x0) goto LAB_23050178;
LAB_23050192:
    list->first = element->next;
  }
  else {
    if (prev_element->next != element) {
      assert_err("(prev_element == NULL) || (prev_element->next == element)","module",0x169);
    }
    if (element == (co_list_hdr *)0x0) {
LAB_23050178:
      assert_err("element != NULL","module",0x16a);
      if (prev_element == (co_list_hdr *)0x0) goto LAB_23050192;
    }
    prev_element->next = element->next;
    if (list->last == element) {
      list->last = prev_element;
    }
  }
  element->next = (co_list_hdr *)0x0;
  return;
}


/*
Unable to decompile 'ke_evt_set'
Cause: Exception while decompiling 230501a8: Decompiler process died

*/

/*
Unable to decompile 'ke_evt_clear'
Cause: Exception while decompiling 230501c0: Decompiler process died

*/


void bl_event_handle(int param)

{
  ke_evt_clear(0x40000000);
  bl_main_event_handle();
  return;
}


/*
Unable to decompile 'bl_fw_statistic_dump'
Cause: Exception while decompiling 230501f0: Decompiler process died

*/


void bl60x_fw_dump_statistic(int forced)

{
  if (forced != 0) {
    bl_fw_statistic_dump(0);
    return;
  }
  ke_evt_set(0x20);
  return;
}



void ke_evt_schedule(void)

{
  int iVar1;
  evt_ptr_t *peVar2;
  
  while (ke_env.evt_field != 0) {
    iVar1 = __clzsi2(ke_env.evt_field);
    peVar2 = ke_evt_hdlr[iVar1].func;
    if ((0x1a < iVar1) || (peVar2 == (evt_ptr_t *)0x0)) {
      assert_err("(event < KE_EVT_MAX) && ke_evt_hdlr[event].func","module",0xdd);
    }
    (*peVar2)(ke_evt_hdlr[iVar1].param);
  }
  return;
}



void ke_init(void)

{
  ke_env.mblock_first = ke_mem_init();
  ke_env.queue_saved.first = (co_list_hdr *)0x0;
  ke_env.queue_saved.last = (co_list_hdr *)0x0;
  ke_env.queue_sent.first = (co_list_hdr *)0x0;
  ke_env.queue_sent.last = (co_list_hdr *)0x0;
  ke_env.queue_timer.first = (co_list_hdr *)0x0;
  ke_env.queue_timer.last = (co_list_hdr *)0x0;
  ke_evt_clear(0xffffffff);
  return;
}


/*
Unable to decompile 'ke_mem_init'
Cause: Exception while decompiling 230502e8: Decompiler process died

*/

/*
Unable to decompile 'ke_malloc'
Cause: Exception while decompiling 2305030e: Decompiler process died

*/

/*
Unable to decompile 'ke_free'
Cause: Exception while decompiling 230503a2: Decompiler process died

*/


void * ke_msg_alloc(ke_msg_id_t id,ke_task_id_t dest_id,ke_task_id_t src_id,uint16_t param_len)

{
  undefined4 *puVar1;
  undefined2 in_register_00002036;
  
  puVar1 = (undefined4 *)ke_malloc(CONCAT22(in_register_00002036,param_len) + 0xc);
  if (puVar1 == (undefined4 *)0x0) {
    assert_err("msg != NULL","module",0x50);
  }
  *(ke_msg_id_t *)(puVar1 + 1) = id;
  *(ke_task_id_t *)((int)puVar1 + 6) = dest_id;
  *(ke_task_id_t *)(puVar1 + 2) = src_id;
  *(uint16_t *)((int)puVar1 + 10) = param_len;
  *puVar1 = 0;
  memset(puVar1 + 3,0,CONCAT22(in_register_00002036,param_len));
  return puVar1 + 3;
}



void ke_msg_send(int param_1)

{
  if (*(byte *)(param_1 + -6) < 0xf) {
    if (*(byte *)(param_1 + -6) < 0xd) {
      co_list_push_back(&ke_env.queue_sent,(co_list_hdr *)(param_1 + -0xc));
      ke_evt_set(0x1000000);
      return;
    }
  }
  else {
    assert_err("id <= TASK_MAX","module",0xb6);
  }
  bl_rx_e2a_handler((void *)(param_1 + -8));
  ke_free((co_list_hdr *)(param_1 + -0xc));
  return;
}



void ke_msg_send_basic(ke_msg_id_t id,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_msg_alloc(id,dest_id,src_id,0);
  ke_msg_send();
  return;
}



void ke_msg_forward_and_change_id
               (void *param_ptr,ke_msg_id_t msg_id,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  *(ke_msg_id_t *)((int)param_ptr + -8) = msg_id;
  *(ke_task_id_t *)((int)param_ptr + -6) = dest_id;
  *(ke_task_id_t *)((int)param_ptr + -4) = src_id;
  ke_msg_send();
  return;
}


/*
Unable to decompile 'ke_msg_free'
Cause: Exception while decompiling 2305056c: Decompiler process died

*/


_Bool cmp_dest_id(co_list_hdr *msg,u32_l dest_id)

{
  return (_Bool)((uint)*(ushort *)((int)&msg[1].next + 2) == dest_id);
}



_Bool ke_task_local(ke_task_id_t id)

{
  undefined2 in_register_0000202a;
  
  if (0xe < CONCAT22(in_register_0000202a,id)) {
    assert_err("id <= TASK_MAX","module",0xb6);
  }
  return (_Bool)(CONCAT22(in_register_0000202a,id) < 0xd);
}



ke_msg_func_t * ke_handler_search(ke_msg_id_t msg_id,ke_state_handler *state_handler)

{
  undefined2 in_register_0000202a;
  int iVar1;
  
  iVar1 = (uint)state_handler->msg_cnt - 1;
  if (iVar1 == -1) {
    return (ke_msg_func_t *)0x0;
  }
  do {
    if ((uint)state_handler->msg_table[iVar1].id == CONCAT22(in_register_0000202a,msg_id)) {
      if (state_handler->msg_table[iVar1].func == (ke_msg_func_t *)0x0) {
        assert_err("state_handler->msg_table[i].func","module",0xf4);
      }
      return state_handler->msg_table[iVar1].func;
    }
    iVar1 = iVar1 + -1;
  } while (iVar1 != -1);
  return (ke_msg_func_t *)0x0;
}


/*
Unable to decompile 'ke_state_set'
Cause: Exception while decompiling 2305060e: Decompiler process died

*/


ke_state_t ke_state_get(ke_task_id_t id)

{
  uint uVar1;
  _Bool _Var2;
  undefined2 in_register_0000202a;
  undefined3 extraout_var;
  uint uVar3;
  
  uVar1 = (uint)id & 0xff;
  uVar3 = CONCAT22(in_register_0000202a,id) >> 8;
  if (0xd < uVar1) {
    assert_err("type < TASK_MAX","module",0xd7);
  }
  _Var2 = ke_task_local((ke_task_id_t)uVar1);
  if (CONCAT31(extraout_var,_Var2) == 0) {
    assert_err("ke_task_local(type)","module",0xd8);
  }
  if (TASK_DESC[uVar1].idx_max <= uVar3) {
    assert_err("idx < TASK_DESC[type].idx_max","module",0xd9);
  }
  return (ke_state_t)*(undefined2 *)(TASK_DESC[uVar1].state + uVar3 * 2);
}


/*
Unable to decompile 'ke_task_schedule'
Cause: Exception while decompiling 230507a6: Decompiler process died

*/


int ke_msg_discard(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  return 0;
}



int ke_msg_save(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  return 2;
}


/*
Unable to decompile 'ke_timer_hw_set'
Cause: Exception while decompiling 23050914: Decompiler process died

*/


_Bool cmp_abs_time(co_list_hdr *timerA,co_list_hdr *timerB)

{
  return (_Bool)((co_list_hdr *)0x11e1a300 <
                (co_list_hdr *)((int)timerA[2].next - (int)timerB[2].next));
}



_Bool cmp_timer_id(co_list_hdr *timer,uint32_t timer_task)

{
  if ((uint)*(ushort *)&timer[1].next == timer_task >> 0x10) {
    return (_Bool)((uint)*(ushort *)((int)&timer[1].next + 2) == (timer_task & 0xffff));
  }
  return false;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ke_timer_set(ke_msg_id_t timer_id,ke_task_id_t task_id,uint32_t delay)

{
  bool bVar1;
  co_list_hdr *pcVar2;
  undefined2 in_register_0000202a;
  char *condition;
  co_list_hdr *element;
  undefined2 in_register_0000202e;
  int line;
  
  if (delay == 0) {
    line = 0x8c;
    condition = "delay > 0";
  }
  else {
    if (delay < 300000000) goto LAB_230509c2;
    line = 0x8d;
    condition = "delay < KE_TIMER_DELAY_MAX";
  }
  assert_err(condition,"module",line);
LAB_230509c2:
  bVar1 = false;
  if ((ke_env.queue_timer.first != (co_list_hdr *)0x0) &&
     ((uint)*(ushort *)&ke_env.queue_timer.first[1].next == CONCAT22(in_register_0000202a,timer_id))
     ) {
    bVar1 = (uint)*(ushort *)((int)&ke_env.queue_timer.first[1].next + 2) ==
            CONCAT22(in_register_0000202e,task_id);
  }
  element = ke_queue_extract(&ke_env.queue_timer,cmp_timer_id,
                             CONCAT22(in_register_0000202a,timer_id) << 0x10 |
                             CONCAT22(in_register_0000202e,task_id));
  if (element == (co_list_hdr *)0x0) {
    element = (co_list_hdr *)ke_malloc(0xc);
    if (element == (co_list_hdr *)0x0) {
      assert_err("timer","module",0x9d);
    }
    *(ke_msg_id_t *)&element[1].next = timer_id;
    *(ke_task_id_t *)((int)&element[1].next + 2) = task_id;
  }
  pcVar2 = (co_list_hdr *)(delay + _DAT_44b00120);
  element[2].next = pcVar2;
  co_list_insert(&ke_env.queue_timer,element,cmp_abs_time);
  if ((bVar1) || (ke_env.queue_timer.first == element)) {
    ke_timer_hw_set(ke_env.queue_timer.first);
  }
  if ((int)((int)pcVar2 - _DAT_44b00120) < 0) {
    ke_evt_set(0x4000000);
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ke_timer_clear(ke_msg_id_t timer_id,ke_task_id_t task_id)

{
  co_list_hdr *pcVar1;
  undefined2 in_register_0000202a;
  co_list_hdr *mem_ptr;
  undefined2 in_register_0000202e;
  
  mem_ptr = ke_env.queue_timer.first;
  if (ke_env.queue_timer.first == (co_list_hdr *)0x0) {
    return;
  }
  if (((uint)*(ushort *)&ke_env.queue_timer.first[1].next == CONCAT22(in_register_0000202a,timer_id)
      ) && ((uint)*(ushort *)((int)&ke_env.queue_timer.first[1].next + 2) ==
            CONCAT22(in_register_0000202e,task_id))) {
    co_list_pop_front(&ke_env.queue_timer);
    pcVar1 = ke_env.queue_timer.first;
    ke_timer_hw_set(ke_env.queue_timer.first);
    if ((pcVar1 != (co_list_hdr *)0x0) && ((int)((int)pcVar1[2].next - _DAT_44b00120) < 0)) {
      assert_err("!first || !ke_time_past(first->time)","module",0xd7);
    }
  }
  else {
    mem_ptr = ke_queue_extract(&ke_env.queue_timer,cmp_timer_id,
                               CONCAT22(in_register_0000202a,timer_id) << 0x10 |
                               CONCAT22(in_register_0000202e,task_id));
    if (mem_ptr == (co_list_hdr *)0x0) {
      return;
    }
  }
  ke_free(mem_ptr);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ke_timer_schedule(int dummy)

{
  co_list_hdr *mem_ptr;
  
  while( true ) {
    ke_evt_clear(0x4000000);
    mem_ptr = ke_env.queue_timer.first;
    if (ke_env.queue_timer.first == (co_list_hdr *)0x0) {
      ke_timer_hw_set(0);
      return;
    }
    if ((-1 < (int)ke_env.queue_timer.first[2].next + (-0x32 - _DAT_44b00120)) &&
       (ke_timer_hw_set(ke_env.queue_timer.first), -1 < (int)((int)mem_ptr[2].next - _DAT_44b00120))
       ) break;
    mem_ptr = co_list_pop_front(&ke_env.queue_timer);
    ke_msg_send_basic(*(ke_msg_id_t *)&mem_ptr[1].next,*(ke_task_id_t *)((int)&mem_ptr[1].next + 2),
                      0xff);
    ke_free(mem_ptr);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void bl60x_current_time_us(longlong *time_now)

{
  undefined4 uVar1;
  
  uVar1 = _DAT_44b080a8;
  *(undefined4 *)time_now = _DAT_44b080a4;
  *(undefined4 *)((int)time_now + 4) = uVar1;
  return;
}



byte * mac_ie_find(byte *param_1,int param_2,uint param_3)

{
  byte *pbVar1;
  
  pbVar1 = param_1 + param_2;
  while( true ) {
    if (pbVar1 <= param_1) {
      return (byte *)0;
    }
    if ((uint)*param_1 == param_3) break;
    param_1 = param_1 + (uint)param_1[1] + 2;
  }
  return param_1;
}



char * mac_vsie_find(char *param_1,int param_2,int param_3,int param_4)

{
  int iVar1;
  char *pcVar2;
  int iVar3;
  
  pcVar2 = param_1 + param_2;
  while (param_1 < pcVar2) {
    if (*param_1 == -0x23) {
      iVar3 = 0;
      do {
        if (param_4 == iVar3) {
          return param_1;
        }
        iVar1 = iVar3 + 2;
        iVar3 = iVar3 + 1;
      } while (*(char *)(param_3 + iVar3 + -1) == param_1[iVar1]);
    }
    param_1 = param_1 + (uint)(byte)param_1[1] + 2;
  }
  if (param_1 != pcVar2) {
    puts("--->>> addr != end\r\n");
    return (char *)0;
  }
  return (char *)0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BufferDesc_t *
GetTxEAPOLBuffer(cm_ConnectionInfo_t *connPtr,EAPOL_KeyMsg_Tx_t **ppTxEapol,BufferDesc_t *pBufDesc)

{
  char "GetTxEAPOLBuffer" [17];
  void *pvVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"GetTxEAPOLBuffer");
  if (pBufDesc == (BufferDesc_t *)0x0) {
    pBufDesc = (BufferDesc_t *)ke_malloc(0xc);
    if (pBufDesc != (BufferDesc_t *)0x0) {
      memset(pBufDesc,0,0xc);
      pvVar1 = ke_malloc(0x200);
      pBufDesc->Buffer = pvVar1;
      if (pvVar1 != (void *)0x0) goto LAB_23050cd6;
    }
    pBufDesc = (BufferDesc_t *)0x0;
  }
  else {
LAB_23050cd6:
    *(cm_ConnectionInfo_t **)&pBufDesc->intf = connPtr;
    *ppTxEapol = (EAPOL_KeyMsg_Tx_t *)pBufDesc->Buffer;
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c408);
  }
  return pBufDesc;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void UpdateEAPOLWcbLenAndTransmit(BufferDesc_t *pBufDesc,UINT16 frameLen)

{
  char "UpdateEAPOLWcbLenAndTransmit" [29];
  undefined2 in_register_0000202e;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"UpdateEAPOLWcbLenAndTransmit");
  txl_frame_send_eapol_frame
            (*(uint8_t *)(pBufDesc->intf + 1),(cfm_func_ptr *)0x0,(void *)0x0,
             (uint8_t *)((int)pBufDesc->Buffer + 0xe),CONCAT22(in_register_0000202e,frameLen) + 4);
  ke_free(pBufDesc->Buffer);
  ke_free(pBufDesc);
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c430);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BOOLEAN keyMgmtProcessMsgExt(keyMgmtInfoSta_t *pKeyMgmtInfoSta,EAPOL_KeyMsg_t *pKeyMsg)

{
  char "keyMgmtProcessMsgExt" [21];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"keyMgmtProcessMsgExt");
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c450);
  return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void KeyMgmtInitSta(cm_ConnectionInfo_t *connPtr)

{
  char "KeyMgmtInitSta" [15];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmtInitSta");
  KeyMgmtSta_InitSession(&connPtr->suppData->keyMgmtInfoSta);
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c468);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void keyMgmtSta_StartSession(cm_ConnectionInfo_t *connPtr,CHAR *pBssid,UINT8 *pStaAddr)

{
  char "keyMgmtSta_StartSession" [24];
  supplicantData *psVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"keyMgmtSta_StartSession");
  psVar1 = connPtr->suppData;
  *(cm_ConnectionInfo_t **)&(psVar1->keyMgmtInfoSta).connPtr = connPtr;
  memcpy(connPtr->suppData->localStaAddr,pStaAddr,6);
  memcpy(connPtr->suppData->localBssid,pBssid,6);
  keyMgmtSta_StartSession_internal(&psVar1->keyMgmtInfoSta,10000000);
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c514);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void init_customApp_mibs(supplicantData_t *suppData)

{
  char "init_customApp_mibs" [20];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"init_customApp_mibs");
  memset(&suppData->customMIB_RSNStats,0,3);
  memset(&suppData->customMIB_RSNConfig,0,0x1c);
  *(ushort *)&(suppData->customMIB_RSNConfig).wpaType =
       (ushort)(suppData->customMIB_RSNConfig).wpaType | 1;
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c544);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

UINT8 supplicantIsEnabled(void *connectionPtr)

{
  byte bVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantIsEnabled");
  bVar1 = 0;
  if (*(int *)((int)connectionPtr + 8) != 0) {
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"supplicantIsEnabled");
    bVar1 = (byte)((uint)*(undefined4 *)(*(int *)((int)connectionPtr + 8) + 0x34) >> 8) & 1;
  }
  return (UINT8)bVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void supplicantInitSession
               (cm_ConnectionInfo_t *connPtr,CHAR *pSsid,UINT16 len,CHAR *pBssid,UINT8 *pStaAddr)

{
  char "supplicantInitSession" [22];
  UINT8 UVar1;
  undefined3 extraout_var;
  undefined2 in_register_00002032;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantInitSession");
  UVar1 = supplicantIsEnabled(connPtr);
  if (CONCAT31(extraout_var,UVar1) != 0) {
    KeyMgmtInitSta(connPtr);
    memcpy((connPtr->suppData->hashSsId).SsId,pSsid,CONCAT22(in_register_00002032,len));
    (connPtr->suppData->hashSsId).Len = (IEEEtypes_Len_t)len;
    keyMgmtSta_StartSession(connPtr,pBssid,pStaAddr);
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c52c);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void supplicantDisable(cm_ConnectionInfo_t *connPtr)

{
  char "supplicantDisable" [18];
  UINT8 UVar1;
  undefined3 extraout_var;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantDisable");
  UVar1 = supplicantIsEnabled(connPtr);
  if (CONCAT31(extraout_var,UVar1) != 0) {
    mm_timer_clear(&(connPtr->suppData->keyMgmtInfoSta).rsnTimer);
    *(byte *)&connPtr->suppData->customMIB_RSNConfig =
         *(byte *)&connPtr->suppData->customMIB_RSNConfig & 0xfe;
    init_customApp_mibs((supplicantData_t *)connPtr->suppData);
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c56c);
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void supplicantEnable(void *connectionPtr,int security_mode,void *mcstCipher,void *ucstCipher,
                     _Bool is_pmf_required)

{
  char "supplicantEnable" [17];
  int iVar1;
  UINT8 *__src;
  undefined3 in_register_00002039;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantEnable");
  *(byte *)(*(int *)((int)connectionPtr + 8) + 0x35) =
       *(byte *)(*(int *)((int)connectionPtr + 8) + 0x35) | 1;
  if (security_mode - 4U < 3) {
    *(ushort *)(*(int *)((int)connectionPtr + 8) + 0x36) =
         *(ushort *)(*(int *)((int)connectionPtr + 8) + 0x36) | 0x20;
    *(byte *)(*(int *)((int)connectionPtr + 8) + 0x35) =
         *(byte *)(*(int *)((int)connectionPtr + 8) + 0x35) | 4;
    *(ushort *)(*(int *)((int)connectionPtr + 8) + 0x4e) =
         *(ushort *)(*(int *)((int)connectionPtr + 8) + 0x4e) | 1;
    memcpy((void *)(*(int *)((int)connectionPtr + 8) + 0x38),mcstCipher,1);
    memcpy((void *)(*(int *)((int)connectionPtr + 8) + 0x39),ucstCipher,1);
    if (CONCAT31(in_register_00002039,is_pmf_required) == 0) {
      *(undefined *)(*(int *)((int)connectionPtr + 8) + 0x3d) = 2;
    }
    else {
      *(undefined *)(*(int *)((int)connectionPtr + 8) + 0x3d) = 6;
    }
    iVar1 = *(int *)((int)connectionPtr + 8);
    __src = "";
  }
  else {
    if (security_mode != 3) goto LAB_2305118e;
    *(ushort *)(*(int *)((int)connectionPtr + 8) + 0x36) =
         *(ushort *)(*(int *)((int)connectionPtr + 8) + 0x36) | 8;
    memcpy((void *)(*(int *)((int)connectionPtr + 8) + 0x38),mcstCipher,1);
    memcpy((void *)(*(int *)((int)connectionPtr + 8) + 0x39),ucstCipher,1);
    *(undefined *)(*(int *)((int)connectionPtr + 8) + 0x3d) = 2;
    iVar1 = *(int *)((int)connectionPtr + 8);
    __src = "";
  }
  memcpy((void *)(iVar1 + 0x3a),__src,3);
LAB_2305118e:
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c580);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

UINT16 keyMgmtFormatWpaRsnIe
                 (cm_ConnectionInfo_t *connPtr,UINT8 *pos,IEEEtypes_MacAddr_t *pBssid,
                 IEEEtypes_MacAddr_t *pStaAddr,UINT8 *pPmkid,BOOLEAN addPmkid)

{
  char "keyMgmtFormatWpaRsnIe" [22];
  uint16_t uVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"keyMgmtFormatWpaRsnIe");
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c594);
  uVar1 = mm_get_rsn_wpa_ie(connPtr->staId,pos);
  return (UINT16)uVar1;
}



// WARNING: Variable defined which should be unmapped: pTxEapol
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

Status_e GeneratePWKMsg2(BufferDesc_t *pEAPoLBufDesc,UINT8 *pSNonce,UINT8 *pEAPOLMICKey,
                        UINT8 forceKeyDescVersion)

{
  EAPOL_KeyMsg_Tx_t *pEVar1;
  char "GeneratePWKMsg2" [16];
  cm_ConnectionInfo_t *connPtr;
  Status_e SVar2;
  UINT16 frameLen;
  BufferDesc_t *pBufDesc;
  EAPOL_KeyMsg_t *pRxEapol;
  EAPOL_KeyMsg_Tx_t *pEStack36;
  EAPOL_KeyMsg_Tx_t *pTxEapol;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"GeneratePWKMsg2");
  connPtr = (cm_ConnectionInfo_t *)pEAPoLBufDesc->intf;
  pRxEapol = (EAPOL_KeyMsg_t *)pEAPoLBufDesc->Buffer;
  pBufDesc = GetTxEAPOLBuffer(connPtr,&pEStack36,(BufferDesc_t *)0x0);
  if (pBufDesc == (BufferDesc_t *)0x0) {
    SVar2 = FAIL;
  }
  else {
    KeyMgmtSta_PrepareEAPOLFrame
              (pEStack36,pRxEapol,(IEEEtypes_MacAddr_t *)connPtr->suppData->localBssid,
               (IEEEtypes_MacAddr_t *)connPtr->suppData->localStaAddr,pSNonce);
    pEVar1 = pEStack36;
    if ((pEStack36->keyMsg).desc_type != '\x01') {
      frameLen = keyMgmtFormatWpaRsnIe
                           (connPtr,(pEStack36->keyMsg).key_data,
                            (IEEEtypes_MacAddr_t *)connPtr->suppData->localBssid,
                            (IEEEtypes_MacAddr_t *)connPtr->suppData->localStaAddr,(UINT8 *)0x0,0);
      *(char *)&(pEVar1->keyMsg).key_material_len = (char)frameLen;
      *(undefined *)((int)&(pEVar1->keyMsg).key_material_len + 1) = (char)(frameLen >> 8);
    }
    frameLen = KeyMgmtSta_PopulateEAPOLLengthMic(pEStack36,pEAPOLMICKey,'\x01',forceKeyDescVersion);
    UpdateEAPOLWcbLenAndTransmit(pBufDesc,frameLen);
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c478);
    SVar2 = FW_SUCCESS;
  }
  return SVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BOOLEAN KeyMgmtStaHsk_Recvd_PWKMsg1
                  (BufferDesc_t *pEAPoLBufDesc,IEEEtypes_MacAddr_t *sa,IEEEtypes_MacAddr_t *da)

{
  char "KeyMgmtStaHsk_Recvd_PWKMsg1" [28];
  int iVar1;
  int iVar2;
  Status_e SVar3;
  EAPOL_KeyMsg_t *pEVar4;
  BOOLEAN BVar5;
  UINT8 *pPMK;
  undefined3 extraout_var;
  int iVar6;
  keyMgmtInfoSta_t *pKeyMgmtInfoSta;
  BOOLEAN in_fa0;
  
  iVar6 = pEAPoLBufDesc->intf;
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmtStaHsk_Recvd_PWKMsg1");
  iVar1 = *(int *)(iVar6 + 8);
  pKeyMgmtInfoSta = (keyMgmtInfoSta_t *)(iVar1 + 0x54);
  pEVar4 = GetKeyMsgNonceFromEAPOL(pEAPoLBufDesc,pKeyMgmtInfoSta);
  if (pEVar4 == (EAPOL_KeyMsg_t *)0x0) {
LAB_230513aa:
    iVar2 = 0;
  }
  else {
    iVar2 = supplicantAkmIsWpaWpa2((AkmSuite_t *)(*(int *)(iVar6 + 8) + 0x3a));
    if (iVar2 != 0) {
      BVar5 = supplicantAkmIsWpaWpa2Psk((AkmSuite_t *)(*(int *)(iVar6 + 8) + 0x3a));
      if ((BVar5 == 0) ||
         (pPMK = pmkCacheFindPSK((UINT8 *)(*(int *)(iVar6 + 8) + 6),
                                 *(UINT8 *)(*(int *)(iVar6 + 8) + 5)), pPMK == (UINT8 *)0x0))
      goto LAB_230513aa;
      supplicantAkmUsesKdf((AkmSuite_t *)(*(int *)(iVar6 + 8) + 0x3a));
      KeyMgmtSta_DeriveKeys
                (pPMK,da,sa,(UINT8 *)pKeyMgmtInfoSta,(UINT8 *)(iVar1 + 0x74),(UINT8 *)(iVar1 + 0x94)
                 ,(UINT8 *)(iVar1 + 0xa4),(KeyData_t *)(iVar1 + 0x128),in_fa0);
      iVar2 = 1;
    }
    SVar3 = GeneratePWKMsg2(pEAPoLBufDesc,(UINT8 *)(iVar1 + 0x74),(UINT8 *)(iVar1 + 0x94),'\0');
    if (CONCAT31(extraout_var,SVar3) == 0) {
      if (iVar2 == 1) {
        updateApReplayCounter(pKeyMgmtInfoSta,(UINT8 *)pEVar4->replay_cnt);
        *(undefined4 *)(iVar1 + 0xcc) = 0;
      }
    }
    else {
      iVar2 = 0;
    }
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c4a8);
  }
  return iVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void supplicantInit(supplicantData_t *suppData)

{
  char "supplicantInit" [15];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantInit");
  init_customApp_mibs(suppData);
  memset(&suppData->currParams,0xff,4);
  memset(&suppData->keyMgmtInfoSta,0,0x144);
  (suppData->keyMgmtInfoSta).sta_MIC_Error.disableStaAsso = 0;
  (suppData->keyMgmtInfoSta).sta_MIC_Error.MICCounterMeasureEnabled = 1;
  (suppData->keyMgmtInfoSta).sta_MIC_Error.status = NO_MIC_FAILURE;
  KeyMgmtResetCounter(&suppData->keyMgmtInfoSta);
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c5ac);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void allocSupplicantData(void *connectionPtr)

{
  char "allocSupplicantData" [20];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"allocSupplicantData");
  if (*(int *)((int)connectionPtr + 8) == 0) {
    if ((*(char *)connectionPtr == '\0') && (keyMgmt_SuppData[0].inUse == 0)) {
      keyMgmt_SuppData[0].inUse = 1;
      supplicantInit(keyMgmt_SuppData);
      *(undefined4 *)((int)connectionPtr + 8) = 0x420161e4;
    }
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c41c);
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

UINT16 keyMgmtGetKeySize(cm_ConnectionInfo_t *connPtr,UINT8 isPairwise)

{
  char "keyMgmtGetKeySize" [18];
  UINT16 UVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"keyMgmtGetKeySize");
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c5bc);
  UVar1 = keyMgmtGetKeySize_internal(&connPtr->suppData->customMIB_RSNConfig,isPairwise);
  return UVar1;
}



// WARNING: Variable defined which should be unmapped: key_add_req
// WARNING: Could not reconcile some variable overlaps

uint8_t add_key_to_mac(cm_ConnectionInfo_t *connPtr,UINT8 pairwise)

{
  uint32_t uVar1;
  uint32_t uVar2;
  size_t __n;
  uint8_t uVar3;
  UINT16 UVar4;
  apInfo_t *paVar5;
  undefined3 in_register_0000202d;
  int iVar6;
  KeyData_t *__src;
  byte bStack60;
  byte bStack59;
  mm_key_add_req key_add_req;
  
  iVar6 = CONCAT31(in_register_0000202d,pairwise);
  __n = 0x10;
  if (connPtr->conType == '\0') {
    UVar4 = keyMgmtGetKeySize(connPtr,pairwise);
    __n = (uint)UVar4 & 0xff;
  }
  memset(&bStack60,0,0x2c);
  key_add_req.key.array[7]._3_1_ = iVar6 != 0;
  key_add_req.key.array[7]._1_1_ = connPtr->instNbr;
  if (iVar6 == 0) {
    bStack59 = 0xff;
    if (connPtr->conType == '\0') {
      __src = &(connPtr->suppData->keyMgmtInfoSta).GRKey;
      bStack60 = (byte)(connPtr->suppData->keyMgmtInfoSta).GRKey.KeyIndex;
    }
    else {
      paVar5 = cm_GetApInfo(connPtr);
      __src = &(paVar5->bssData).grpKeyData;
      bStack60 = (byte)(paVar5->bssData).grpKeyData.KeyIndex;
    }
  }
  else {
    bStack59 = connPtr->staId;
    if (connPtr->conType == '\0') {
      __src = &(connPtr->suppData->keyMgmtInfoSta).PWKey;
    }
    else {
      __src = (KeyData_t *)((connPtr->TxRxCipherKeyBuf).cipher_key.ckd + 0x20);
    }
  }
  memcpy(&key_add_req.key,__src,__n);
  uVar2 = key_add_req.key.array[6];
  uVar1 = key_add_req.key.array[3];
  key_add_req.key_idx = (uint8_t)__n;
  if (__n == 0x10) {
    key_add_req.key.array[7]._0_1_ = 2;
  }
  else {
    if (__n == 0x20) {
      key_add_req.key.array[7]._0_1_ = 1;
      if (iVar6 != 0) {
        key_add_req.key.array[3] = key_add_req.key.array[5];
        key_add_req.key.array[5] = uVar1;
        key_add_req.key.array[6] = key_add_req.key.array[4];
        key_add_req.key.array[4] = uVar2;
      }
    }
    else {
      if (__n == 0xd) {
        key_add_req.key.array[7]._0_1_ = 3;
      }
      else {
        if (__n == 5) {
          key_add_req.key.array[7]._0_1_ = 0;
        }
        else {
          assert_err("0","module",0x783);
        }
      }
    }
  }
  printf("set key:sta_idx:%d, inst_nbr:%d, key_idx:%d,cipher_suite:%d,key_len:%d\r\n",(uint)bStack59
         ,(uint)key_add_req.key.array[7]._1_1_,(uint)bStack60,(uint)(byte)key_add_req.key.array[7],
         (uint)key_add_req.key_idx);
  uVar3 = mm_sec_machwkey_wr((mm_key_add_req *)&bStack60);
  return uVar3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BufferReturnNotify_t * keyMgmtKeyGroupTxDone(void)

{
  cm_ConnectionInfo_t *connPtr;
  uint8_t uVar1;
  cm_ConnectionInfo_t **in_a0;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"keyMgmtKeyGroupTxDone");
  connPtr = *in_a0;
  if (connPtr->gtkHwKeyId != -1) {
    mm_sec_machwkey_del(connPtr->gtkHwKeyId);
  }
  uVar1 = add_key_to_mac(connPtr,'\0');
  connPtr->gtkHwKeyId = uVar1;
  (connPtr->suppData->keyMgmtInfoSta).RSNDataTrafficEnabled = 1;
  if ((connPtr->suppData->keyMgmtInfoSta).RSNSecured == 0) {
    (connPtr->suppData->keyMgmtInfoSta).RSNSecured = 1;
    sm_handle_supplicant_result(connPtr->staId,0);
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"keyMgmtKeyGroupTxDone");
  return (BufferReturnNotify_t *)0x0;
}



// WARNING: Variable defined which should be unmapped: pTxEapol
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

Status_e GenerateGrpMsg2(BufferDesc_t *pEAPoLBufDesc,keyMgmtInfoSta_t *pKeyMgmtInfoSta)

{
  char "GenerateGrpMsg2" [16];
  UINT16 frameLen_00;
  BufferDesc_t *pBufDesc;
  supplicantData *psVar1;
  cm_ConnectionInfo_t *connPtr;
  EAPOL_KeyMsg_t *pRxEapol;
  UINT16 frameLen;
  EAPOL_KeyMsg_Tx_t *pEStack36;
  EAPOL_KeyMsg_Tx_t *pTxEapol;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"GenerateGrpMsg2");
  connPtr = (cm_ConnectionInfo_t *)pEAPoLBufDesc->intf;
  pRxEapol = (EAPOL_KeyMsg_t *)pEAPoLBufDesc->Buffer;
  pBufDesc = GetTxEAPOLBuffer(connPtr,&pEStack36,(BufferDesc_t *)0x0);
  if (pBufDesc != (BufferDesc_t *)0x0) {
    psVar1 = connPtr->suppData;
    KeyMgmtSta_PrepareEAPOLFrame
              (pEStack36,pRxEapol,(IEEEtypes_MacAddr_t *)psVar1->localBssid,
               (IEEEtypes_MacAddr_t *)psVar1->localStaAddr,(UINT8 *)0x0);
    frameLen_00 = KeyMgmtSta_PopulateEAPOLLengthMic
                            (pEStack36,pKeyMgmtInfoSta->EAPOL_MIC_Key,'\x01','\0');
    keyMgmtKeyGroupTxDone();
    UpdateEAPOLWcbLenAndTransmit(pBufDesc,frameLen_00);
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c498);
  }
  return (Status_e)(pBufDesc == (BufferDesc_t *)0x0);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

EAPOL_KeyMsg_t * KeyMgmtStaHsk_Recvd_GrpMsg1(BufferDesc_t *pEAPoLBufDesc)

{
  char "KeyMgmtStaHsk_Recvd_GrpMsg1" [28];
  keyMgmtInfoSta_t *pKeyMgmtInfoSta;
  Status_e SVar1;
  EAPOL_KeyMsg_t *pEVar2;
  undefined3 extraout_var;
  
  pKeyMgmtInfoSta = (keyMgmtInfoSta_t *)(*(int *)(pEAPoLBufDesc->intf + 8) + 0x54);
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmtStaHsk_Recvd_GrpMsg1");
  pEVar2 = ProcessRxEAPOL_GrpMsg1(pEAPoLBufDesc,pKeyMgmtInfoSta);
  if ((pEVar2 == (EAPOL_KeyMsg_t *)0x0) ||
     (SVar1 = GenerateGrpMsg2(pEAPoLBufDesc,pKeyMgmtInfoSta), CONCAT31(extraout_var,SVar1) != 0)) {
    pEVar2 = (EAPOL_KeyMsg_t *)0x0;
  }
  else {
    updateApReplayCounter(pKeyMgmtInfoSta,(UINT8 *)pEVar2->replay_cnt);
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c4e0);
  }
  return pEVar2;
}



// WARNING: Variable defined which should be unmapped: key_add_req
// WARNING: Could not reconcile some variable overlaps

uint8_t add_mfp_key_to_mac(cm_ConnectionInfo_t *connPtr,UINT8 pairwise)

{
  uint8_t uVar1;
  UINT16 UVar2;
  undefined3 extraout_var;
  undefined3 in_register_0000202d;
  KeyData_t *__src;
  undefined2 uStack60;
  mm_key_add_req key_add_req;
  
  UVar2 = keyMgmtGetKeySize(connPtr,pairwise);
  memset(&uStack60,0,0x2c);
  key_add_req.key.array[7]._1_1_ = connPtr->instNbr;
  key_add_req.key_idx = (uint8_t)((uint)UVar2 & 0xff);
  key_add_req.key.array[7]._0_1_ = 5;
  uStack60 = 0xff04;
  if (CONCAT31(in_register_0000202d,pairwise) == 0) {
    if (connPtr->conType != '\0') goto LAB_23051956;
    __src = &(connPtr->suppData->keyMgmtInfoSta).GRKey;
  }
  else {
    if (connPtr->conType != '\0') goto LAB_23051956;
    __src = &(connPtr->suppData->keyMgmtInfoSta).PWKey;
  }
  memcpy(&key_add_req.key,__src,(uint)UVar2 & 0xff);
LAB_23051956:
  printf("set mfp key:sta_idx:%d, inst_nbr:%d, key_idx:%d,cipher_suite:%d,key_len:%d\r\n",
         (uint)uStack60._1_1_,(uint)key_add_req.key.array[7]._1_1_,(uint)(byte)uStack60,
         (uint)(byte)key_add_req.key.array[7],(uint)key_add_req.key_idx);
  uVar1 = mm_sec_machwkey_wr((mm_key_add_req *)&uStack60);
  printf("mfp hw id: %d\n",CONCAT31(extraout_var,uVar1));
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void keyMgmtPlumbPairwiseKey(cm_ConnectionInfo_t *connPtr)

{
  char "keyMgmtPlumbPairwiseKey" [24];
  uint8_t uVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"keyMgmtPlumbPairwiseKey");
  memcpy(&(connPtr->suppData->keyMgmtInfoSta).PWKey,&(connPtr->suppData->keyMgmtInfoSta).newPWKey,
         0x28);
  uVar1 = add_key_to_mac(connPtr,'\x01');
  connPtr->ptkHwKeyId = uVar1;
  if ((connPtr->suppData->customMIB_RSNConfig).AKM.akmType == AKM_SHA256_PSK) {
    uVar1 = add_mfp_key_to_mac(connPtr,'\x01');
    connPtr->mfpHwKeyId = uVar1;
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c5d0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BufferReturnNotify_t * keyMgmtKeyPairwiseTxDone(void)

{
  cm_ConnectionInfo_t **in_a0;
  cm_ConnectionInfo_t *connPtr;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"keyMgmtKeyPairwiseTxDone");
  connPtr = *in_a0;
  keyMgmtPlumbPairwiseKey(connPtr);
  (connPtr->suppData->keyMgmtInfoSta).pwkHandshakeComplete = 1;
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"keyMgmtKeyPairwiseTxDone");
  return (BufferReturnNotify_t *)0x0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

Status_e GeneratePWKMsg4(BufferDesc_t *pEAPoLBufDesc,keyMgmtInfoSta_t *pKeyMgmtInfoSta,
                        BOOLEAN groupKeyReceived)

{
  char "GeneratePWKMsg4" [16];
  Status_e SVar1;
  UINT16 frameLen;
  BufferDesc_t *pBufDesc;
  supplicantData *psVar2;
  cm_ConnectionInfo_t *connPtr;
  EAPOL_KeyMsg_t *pRxEapol;
  EAPOL_KeyMsg_Tx_t *pEStack52;
  EAPOL_KeyMsg_Tx_t *pTxEapol;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"GeneratePWKMsg4");
  connPtr = (cm_ConnectionInfo_t *)pEAPoLBufDesc->intf;
  pRxEapol = (EAPOL_KeyMsg_t *)pEAPoLBufDesc->Buffer;
  pBufDesc = GetTxEAPOLBuffer(connPtr,&pEStack52,(BufferDesc_t *)0x0);
  if (pBufDesc == (BufferDesc_t *)0x0) {
    SVar1 = FAIL;
  }
  else {
    psVar2 = connPtr->suppData;
    KeyMgmtSta_PrepareEAPOLFrame
              (pEStack52,pRxEapol,(IEEEtypes_MacAddr_t *)psVar2->localBssid,
               (IEEEtypes_MacAddr_t *)psVar2->localStaAddr,(UINT8 *)0x0);
    frameLen = KeyMgmtSta_PopulateEAPOLLengthMic
                         (pEStack52,pKeyMgmtInfoSta->EAPOL_MIC_Key,'\x01','\0');
    UpdateEAPOLWcbLenAndTransmit(pBufDesc,frameLen);
    if (groupKeyReceived == 0) {
      keyMgmtKeyPairwiseTxDone();
    }
    else {
      dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"keyMgmtKeyPairAndGroupTxDone");
      keyMgmtKeyPairwiseTxDone();
      keyMgmtKeyGroupTxDone();
      dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"keyMgmtKeyPairAndGroupTxDone");
    }
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c488);
    SVar1 = FW_SUCCESS;
  }
  return SVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

EAPOL_KeyMsg_t * KeyMgmtStaHsk_Recvd_PWKMsg3(BufferDesc_t *pEAPoLBufDesc)

{
  char "KeyMgmtStaHsk_Recvd_PWKMsg3" [28];
  int iVar1;
  keyMgmtInfoSta_t *pKeyMgmtInfoSta;
  Status_e SVar2;
  EAPOL_KeyMsg_t *pEVar3;
  undefined3 extraout_var;
  
  iVar1 = pEAPoLBufDesc->intf;
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmtStaHsk_Recvd_PWKMsg3");
  pKeyMgmtInfoSta = (keyMgmtInfoSta_t *)(*(int *)(iVar1 + 8) + 0x54);
  pEVar3 = ProcessRxEAPOL_PwkMsg3(pEAPoLBufDesc,pKeyMgmtInfoSta);
  if ((pEVar3 != (EAPOL_KeyMsg_t *)0x0) &&
     (SVar2 = GeneratePWKMsg4(pEAPoLBufDesc,pKeyMgmtInfoSta,(uint)(pEVar3->desc_type == '\x02')),
     CONCAT31(extraout_var,SVar2) == 0)) {
    updateApReplayCounter(pKeyMgmtInfoSta,(UINT8 *)pEVar3->replay_cnt);
    pEVar3 = (EAPOL_KeyMsg_t *)0x0;
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c4c4);
  }
  return pEVar3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ProcessKeyMgmtDataSta(BufferDesc_t *pBufDesc,IEEEtypes_MacAddr_t *sa,IEEEtypes_MacAddr_t *da)

{
  char "ProcessKeyMgmtDataSta" [22];
  void *pvVar1;
  
  pvVar1 = pBufDesc->Buffer;
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"ProcessKeyMgmtDataSta");
  if ((*(byte *)((int)pvVar1 + 6) & 8) == 0) {
    KeyMgmtStaHsk_Recvd_GrpMsg1(pBufDesc);
  }
  else {
    if ((*(byte *)((int)pvVar1 + 5) & 1) == 0) {
      KeyMgmtStaHsk_Recvd_PWKMsg1(pBufDesc,sa,da);
    }
    else {
      KeyMgmtStaHsk_Recvd_PWKMsg3(pBufDesc);
    }
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c4fc);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

UINT8 ProcessEAPoLPkt(BufferDesc_t *bufDesc,IEEEtypes_MacAddr_t *sa,IEEEtypes_MacAddr_t *da)

{
  char "ProcessEAPoLPkt" [16];
  UINT8 UVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"ProcessEAPoLPkt");
  if (*(char *)((int)bufDesc->Buffer + 1) == '\x03') {
    dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"ProcessEAPoLKeyPkt");
    if (*(char *)bufDesc->intf == '\x02') {
      ProcessKeyMgmtDataAp(bufDesc);
    }
    else {
      ProcessKeyMgmtDataSta(bufDesc,sa,da);
    }
    UVar1 = '\x01';
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"ProcessEAPoLKeyPkt");
  }
  else {
    UVar1 = '\0';
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c3f8);
  return UVar1;
}



uchar process_rsn_ie(uint8_t *rsn_ie,Cipher_t_conflict *mcstCipher,Cipher_t_conflict *ucstCipher,
                    _Bool *is_pmf_required,SecurityMode_t *security_mode,_Bool wpa2_prefered)

{
  int iVar1;
  UINT8 *__s2;
  Cipher_t_conflict CVar2;
  undefined3 in_register_0000203d;
  uint uVar3;
  uint8_t *__s1;
  uint8_t *__dest;
  ushort auStack66 [2];
  uint16_t akmp_count;
  
  __s1 = rsn_ie + 0xe;
  __dest = rsn_ie + 10;
  if (*(short *)(rsn_ie + 8) == 2) {
    rsn_ie[9] = '\0';
    rsn_ie[1] = rsn_ie[1] + -4;
    rsn_ie[8] = '\x01';
    iVar1 = memcmp(__s1,"",4);
    if (iVar1 == 0) {
      memcpy(__dest,__s1,4);
    }
    memcpy(__s1,rsn_ie + 0x12,0xc);
  }
  memcpy(auStack66,__s1,2);
  uVar3 = 0;
  while (uVar3 < auStack66[0]) {
    iVar1 = memcmp(__dest + (uVar3 + 1) * 4 + 2,"",4);
    if (iVar1 == 0) {
      *(byte *)security_mode = *(byte *)security_mode | 0x20;
    }
    else {
      iVar1 = memcmp(__dest + (uVar3 + 1) * 4 + 2,"",4);
      if (iVar1 == 0) {
        *(byte *)&security_mode->field_0x1 = *(byte *)&security_mode->field_0x1 | 1;
      }
    }
    uVar3 = uVar3 + 1 & 0xff;
  }
  if (auStack66[0] == 2) {
    rsn_ie[1] = '\x14';
    auStack66[0] = 1;
    memcpy(__s1,auStack66,2);
    __s1 = rsn_ie + 0x14;
    if (CONCAT31(in_register_0000203d,wpa2_prefered) == 0) {
      __s2 = "";
    }
    else {
      __s2 = "";
    }
    iVar1 = memcmp(__s1,__s2,4);
    if (iVar1 == 0) {
      memcpy(rsn_ie + 0x10,__s1,6);
    }
    memcpy(__s1,rsn_ie + 0x18,2);
  }
  if (((*(byte *)&security_mode->field_0x1 & 1) != 0) &&
     (((*(byte *)security_mode & 0x20) == 0 || (CONCAT31(in_register_0000203d,wpa2_prefered) == 0)))
     ) {
    *is_pmf_required = true;
    rsn_ie[0x14] = -0x40;
    rsn_ie[0x16] = '\0';
    rsn_ie[1] = rsn_ie[1] + '\x02';
    rsn_ie[0x17] = '\0';
    memcpy(rsn_ie + 0x18,"",4);
    rsn_ie[1] = rsn_ie[1] + '\x04';
  }
  iVar1 = memcmp(__dest,"",4);
  if (iVar1 == 0) {
    CVar2 = (Cipher_t_conflict)((byte)*ucstCipher | 8);
LAB_23051f04:
    *ucstCipher = CVar2;
  }
  else {
    iVar1 = memcmp(__dest,"",4);
    if (iVar1 == 0) {
      CVar2 = (Cipher_t_conflict)((byte)*ucstCipher | 4);
      goto LAB_23051f04;
    }
  }
  __s1 = rsn_ie + 4;
  iVar1 = memcmp(__s1,"",4);
  if (iVar1 == 0) {
    CVar2 = (Cipher_t_conflict)((byte)*mcstCipher | 8);
  }
  else {
    iVar1 = memcmp(__s1,"",4);
    if (iVar1 == 0) {
      CVar2 = (Cipher_t_conflict)((byte)*mcstCipher | 4);
    }
    else {
      iVar1 = memcmp(__s1,"",4);
      if (iVar1 == 0) {
        CVar2 = (Cipher_t_conflict)((byte)*mcstCipher | 2);
      }
      else {
        iVar1 = memcmp(__s1,"",4);
        if (iVar1 != 0) goto LAB_23051f26;
        CVar2 = (Cipher_t_conflict)((byte)*mcstCipher | 1);
      }
    }
  }
  *mcstCipher = CVar2;
LAB_23051f26:
  return (uchar)(rsn_ie[1] + '\x02');
}



uchar process_wpa_ie(uint8_t *wpa_ie,Cipher_t_conflict *mcstCipher,Cipher_t_conflict *ucstCipher)

{
  int iVar1;
  Cipher_t_conflict CVar2;
  uint8_t *__dest;
  uint8_t *__s1;
  
  __dest = wpa_ie + 0xe;
  if (*(short *)(wpa_ie + 0xc) == 2) {
    wpa_ie[1] = '\x16';
    __s1 = wpa_ie + 0x12;
    wpa_ie[0xc] = '\x01';
    wpa_ie[0xd] = '\0';
    iVar1 = memcmp(__s1,"",4);
    if (iVar1 == 0) {
      memcpy(__dest,__s1,4);
    }
    memcpy(__s1,wpa_ie + 0x16,8);
  }
  iVar1 = memcmp(__dest,"",4);
  if (iVar1 == 0) {
    CVar2 = (Cipher_t_conflict)((byte)*ucstCipher | 8);
LAB_2305208e:
    *ucstCipher = CVar2;
  }
  else {
    iVar1 = memcmp(__dest,"",4);
    if (iVar1 == 0) {
      CVar2 = (Cipher_t_conflict)((byte)*ucstCipher | 4);
      goto LAB_2305208e;
    }
  }
  __dest = wpa_ie + 8;
  iVar1 = memcmp(__dest,"",4);
  if (iVar1 == 0) {
    CVar2 = (Cipher_t_conflict)((byte)*mcstCipher | 8);
  }
  else {
    iVar1 = memcmp(__dest,"",4);
    if (iVar1 == 0) {
      CVar2 = (Cipher_t_conflict)((byte)*mcstCipher | 4);
    }
    else {
      iVar1 = memcmp(__dest,"",4);
      if (iVar1 == 0) {
        CVar2 = (Cipher_t_conflict)((byte)*mcstCipher | 2);
      }
      else {
        iVar1 = memcmp(__dest,"",4);
        if (iVar1 != 0) goto LAB_230520b0;
        CVar2 = (Cipher_t_conflict)((byte)*mcstCipher | 1);
      }
    }
  }
  *mcstCipher = CVar2;
LAB_230520b0:
  return (uchar)(wpa_ie[1] + '\x02');
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void keyMgmtStaRsnSecuredTimeoutHandler(void *env)

{
  char "keyMgmtStaRsnSecuredTimeoutHandler" [35];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"keyMgmtStaRsnSecuredTimeoutHandler");
  if ((env != (void *)0x0) && (*(int *)((int)env + 0x78) == 0)) {
    sm_handle_supplicant_result(*(uint8_t *)(*(int *)((int)env + 0x118) + 1),0xf);
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c950);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void supplicantGenerateRand(UINT8 *dataOut,UINT32 length)

{
  char "supplicantGenerateRand" [23];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantGenerateRand");
  bl_rand_stream(dataOut,length);
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c700);
  return;
}



void ComputeEAPOL_MIC(EAPOL_KeyMsg_t *pKeyMsg,UINT16 data_length,UINT8 *MIC_Key,UINT8 MIC_Key_length
                     ,UINT8 micKeyDescVersion)

{
  undefined2 in_register_0000202e;
  undefined3 in_register_00002035;
  undefined3 in_register_00002039;
  uint uVar1;
  uchar *output;
  int iStack24;
  int len;
  UINT8 *pMicData;
  
  uVar1 = CONCAT31(in_register_00002039,micKeyDescVersion);
  iStack24 = CONCAT22(in_register_0000202e,data_length);
  if (uVar1 == 0) {
    uVar1 = (uint)*(byte *)&(pKeyMsg->key_info).field_0x1 & 7;
  }
  output = pKeyMsg->key_MIC;
  len = (int)pKeyMsg;
  if (uVar1 == 1) {
    Bl_hmac_md5((UINT8 *)pKeyMsg,iStack24,MIC_Key,CONCAT31(in_register_00002035,MIC_Key_length),
                output);
  }
  else {
    if (uVar1 == 2) {
      Bl_hmac_sha1((uchar **)&len,&iStack24,1,MIC_Key,CONCAT31(in_register_00002035,MIC_Key_length),
                   output,0x10);
    }
    else {
      bl_aes_cmac(MIC_Key,(UINT8 *)pKeyMsg,iStack24,output);
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

UINT16 keyMgmtGetKeySize_internal(RSNConfig_t *pRsnConfig,UINT8 isPairwise)

{
  Cipher_t_conflict CVar1;
  char "keyMgmtGetKeySize_internal" [27];
  UINT16 UVar2;
  undefined3 in_register_0000202d;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"keyMgmtGetKeySize_internal");
  if (CONCAT31(in_register_0000202d,isPairwise) == 0) {
    CVar1 = pRsnConfig->mcstCipher;
    UVar2 = 0x10;
    if (((((byte)CVar1 & 8) == 0) && (UVar2 = 0xd, ((byte)CVar1 & 2) == 0)) &&
       (UVar2 = 0x20, ((byte)CVar1 & 1) != 0)) {
      UVar2 = 5;
    }
  }
  else {
    UVar2 = 0x20;
    if (((byte)pRsnConfig->ucstCipher & 8) != 0) {
      UVar2 = 0x10;
    }
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c718);
  return UVar2;
}



// WARNING: Variable defined which should be unmapped: tmpLo
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int isApReplayCounterFresh(keyMgmtInfoSta_t *pKeyMgmtInfoSta,UINT8 *pRxReplayCount)

{
  char "isApReplayCounterFresh" [23];
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uStack24;
  UINT32 tmpHi;
  UINT32 tmpLo;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"isApReplayCounterFresh");
  memcpy(&uStack24,pRxReplayCount,4);
  memcpy(&tmpHi,pRxReplayCount + 4,4);
  uVar3 = uStack24 * 0x1000000 + (uStack24 >> 0x18) + (uStack24 & 0xff00) * 0x100 +
          (uStack24 >> 8 & 0xff00);
  uVar2 = pKeyMgmtInfoSta->apCounterHi;
  uVar1 = 1;
  if ((uVar3 <= uVar2) && (uVar1 = 0, uVar2 == uVar3)) {
    uVar1 = 1;
    uVar4 = tmpHi * 0x1000000 + (tmpHi >> 0x18) + (tmpHi & 0xff00) * 0x100 + (tmpHi >> 8 & 0xff00);
    uVar3 = pKeyMgmtInfoSta->apCounterLo;
    if ((uVar4 <= uVar3) && ((uVar1 = 0, uVar3 == uVar4 && ((uVar2 | uVar3) == 0)))) {
      uVar1 = (uint)(pKeyMgmtInfoSta->apCounterZeroDone == 0);
    }
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c734);
  return uVar1;
}



// WARNING: Variable defined which should be unmapped: tmpLo
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void updateApReplayCounter(keyMgmtInfoSta_t *pKeyMgmtStaInfo,UINT8 *pRxReplayCount)

{
  char "updateApReplayCounter" [22];
  uint uVar1;
  uint uVar2;
  uint uStack24;
  UINT32 tmpHi;
  UINT32 tmpLo;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"updateApReplayCounter");
  memcpy(&uStack24,pRxReplayCount,4);
  memcpy(&tmpHi,pRxReplayCount + 4,4);
  uVar2 = uStack24 * 0x1000000 + (uStack24 >> 0x18) + (uStack24 & 0xff00) * 0x100 +
          (uStack24 >> 8 & 0xff00);
  uVar1 = tmpHi * 0x1000000 + (tmpHi >> 0x18) + (tmpHi & 0xff00) * 0x100 + (tmpHi >> 8 & 0xff00);
  pKeyMgmtStaInfo->apCounterHi = uVar2;
  pKeyMgmtStaInfo->apCounterLo = uVar1;
  if ((uVar2 | uVar1) == 0) {
    pKeyMgmtStaInfo->apCounterZeroDone = 1;
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c74c);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void formEAPOLEthHdr(EAPOL_KeyMsg_Tx_t *pTxEapol,IEEEtypes_MacAddr_t *da,IEEEtypes_MacAddr_t *sa)

{
  char "formEAPOLEthHdr" [16];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"formEAPOLEthHdr");
  memcpy(pTxEapol,da,6);
  memcpy((pTxEapol->ethHdr).sa,sa,6);
  *(undefined *)&(pTxEapol->ethHdr).type = 0x88;
  *(undefined *)((int)&(pTxEapol->ethHdr).type + 1) = 0x8e;
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c764);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BOOLEAN IsEAPOL_MICValid(EAPOL_KeyMsg_t *pKeyMsg,UINT8 *pMICKey)

{
  UINT8 *__src;
  int iVar1;
  undefined auStack48 [4];
  UINT8 msgMIC [16];
  
  __src = pKeyMsg->key_MIC;
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"IsEAPOL_MICValid");
  memcpy(auStack48,__src,0x10);
  memset(__src,0,0x10);
  ComputeEAPOL_MIC(pKeyMsg,(UINT16)(((uint)CONCAT21((pKeyMsg->hdr_8021x).pckt_body_len,
                                                    *(undefined *)
                                                     ((int)&(pKeyMsg->hdr_8021x).pckt_body_len + 1))
                                    + 4) * 0x10000 >> 0x10),pMICKey,'\x10','\0');
  iVar1 = memcmp(__src,auStack48,0x10);
  if (iVar1 == 0) {
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"IsEAPOL_MICValid");
  }
  return (uint)(iVar1 == 0);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

UINT16 KeyMgmtSta_PopulateEAPOLLengthMic
                 (EAPOL_KeyMsg_Tx_t *pTxEapol,UINT8 *pEAPOLMICKey,UINT8 eapolProtocolVersion,
                 UINT8 forceKeyDescVersion)

{
  undefined uVar1;
  ushort uVar2;
  char "KeyMgmtSta_PopulateEAPOLLengthMic" [34];
  UINT16 UVar3;
  uint uVar4;
  
  UVar3 = 0;
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmtSta_PopulateEAPOLLengthMic");
  if (pTxEapol != (EAPOL_KeyMsg_Tx_t *)0x0) {
    uVar1 = *(undefined *)((int)&(pTxEapol->keyMsg).key_material_len + 1);
    uVar2 = (pTxEapol->keyMsg).key_material_len;
    uVar4 = (uint)uVar2 + 0x5f & 0xffff;
    UVar3 = (UINT16)uVar4;
    (pTxEapol->keyMsg).hdr_8021x.pckt_type = IEEE_8021X_PACKET_TYPE_EAPOL_KEY;
    *(char *)&(pTxEapol->keyMsg).hdr_8021x.pckt_body_len = (char)(uVar4 >> 8);
    *(undefined *)((int)&(pTxEapol->keyMsg).hdr_8021x.pckt_body_len + 1) = (char)uVar4;
    *(undefined *)&(pTxEapol->keyMsg).key_material_len = uVar1;
    (pTxEapol->keyMsg).hdr_8021x.protocol_ver = eapolProtocolVersion;
    *(undefined *)((int)&(pTxEapol->keyMsg).key_material_len + 1) =
         (char)((uint)CONCAT21(uVar2,uVar1) >> 8);
    ComputeEAPOL_MIC(&pTxEapol->keyMsg,(UINT16)(((uint)uVar2 + 99) * 0x10000 >> 0x10),pEAPOLMICKey,
                     '\x10',forceKeyDescVersion);
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c788);
  }
  return UVar3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

KDE_t * parseKeyKDE(IEEEtypes_InfoElementHdr_t *pIe)

{
  char "parseKeyKDE" [12];
  int iVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"parseKeyKDE");
  if (((pIe->ElementId != ELEM_ID_VENDOR_SPECIFIC) || (pIe->Len < 8)) ||
     (iVar1 = memcmp(pIe + 1,"",3), iVar1 != 0)) {
    pIe = (IEEEtypes_InfoElementHdr_t *)0x0;
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c7ac);
  }
  return (KDE_t *)pIe;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

KDE_t * parseKeyKDE_DataType(UINT8 *pData,SINT32 dataLen,IEEEtypes_KDEDataType_e KDEDataType)

{
  KDE_t *pKVar1;
  undefined3 in_register_00002031;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"parseKeyKDE_DataType");
  if (pData != (UINT8 *)0x0) {
    while (2 < dataLen) {
      if (((IEEEtypes_InfoElementHdr_t *)pData)->ElementId == ELEM_ID_VENDOR_SPECIFIC) {
        pKVar1 = parseKeyKDE((IEEEtypes_InfoElementHdr_t *)pData);
        if ((pKVar1 != (KDE_t *)0x0) &&
           ((uint)pKVar1->dataType == CONCAT31(in_register_00002031,KDEDataType))) {
          return pKVar1;
        }
        if (((IEEEtypes_InfoElementHdr_t *)pData)->Len == '\0') {
          dataLen = 2;
        }
      }
      dataLen = dataLen + (-2 - (uint)((IEEEtypes_InfoElementHdr_t *)pData)->Len);
      pData = (UINT8 *)(&((IEEEtypes_InfoElementHdr_t *)pData)[1].ElementId +
                       (uint)((IEEEtypes_InfoElementHdr_t *)pData)->Len);
    }
    pData = (UINT8 *)0x0;
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"parseKeyKDE_DataType");
  }
  return (KDE_t *)pData;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

KDE_t * parseKeyDataGTK(UINT8 *pKey,UINT16 len,KeyData_t *pGRKey)

{
  char "parseKeyDataGTK" [16];
  KDE_t *pKVar1;
  undefined2 in_register_0000202e;
  undefined auStack40 [4];
  UINT8 buf [8];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"parseKeyDataGTK");
  pKVar1 = parseKeyKDE_DataType(pKey,CONCAT22(in_register_0000202e,len),KDE_DATA_TYPE_GTK);
  if (pKVar1 != (KDE_t *)0x0) {
    memcpy(pGRKey,&pKVar1[1].length,(uint)pKVar1->length - 6);
    pGRKey->KeyIndex = (ushort)pKVar1->data[0] & 3;
    memcpy(auStack40,pGRKey->TxMICKey,8);
    memcpy(pGRKey->TxMICKey,pGRKey->RxMICKey,8);
    memcpy(pGRKey->RxMICKey,auStack40,8);
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c7d0);
  return pKVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void KeyMgmtSta_ApplyKEK(EAPOL_KeyMsg_t *pKeyMsg,KeyData_t *pGRKey,UINT8 *EAPOL_Encr_Key)

{
  byte bVar1;
  undefined uVar2;
  uint3 uVar3;
  char "KeyMgmtSta_ApplyKEK" [20];
  UINT8 *cipher;
  uint uVar4;
  int iVar5;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmtSta_ApplyKEK");
  bVar1 = pKeyMsg->key_RSC[1];
  cipher = pKeyMsg->key_data;
  pGRKey->TxIV16 = (ushort)bVar1 << 8;
  pGRKey->TxIV16 = CONCAT11(bVar1,pKeyMsg->key_RSC[0]);
  pGRKey->TxIV32 = 0xffffffff;
  uVar2 = *(undefined *)((int)&pKeyMsg->key_material_len + 1);
  uVar3 = CONCAT21(pKeyMsg->key_material_len,uVar2);
  uVar4 = (uint)uVar3 & 0xffff;
  *(undefined *)((int)&pKeyMsg->key_material_len + 1) = (char)(uVar4 >> 8);
  bVar1 = *(byte *)&(pKeyMsg->key_info).field_0x1;
  *(undefined *)&pKeyMsg->key_material_len = uVar2;
  if ((bVar1 & 7) == 1) {
    RC4_Encrypt(EAPOL_Encr_Key,pKeyMsg->EAPOL_key_IV,0x10,cipher,(__uint16_t)uVar3,0x100);
  }
  else {
    BL_AesUnWrap(EAPOL_Encr_Key,'\x02',(uVar4 >> 3) - 1,cipher,(UINT8 *)0x0,cipher);
    iVar5 = (uint)pKeyMsg->key_material_len - 8;
    *(char *)&pKeyMsg->key_material_len = (char)((uint)(iVar5 * 0x10000) >> 0x10);
    *(undefined *)((int)&pKeyMsg->key_material_len + 1) = (char)((uint)iVar5 >> 8);
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c7e0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BOOLEAN KeyMgmtSta_IsRxEAPOLValid(keyMgmtInfoSta_t *pKeyMgmtInfoSta,EAPOL_KeyMsg_t *pKeyMsg)

{
  BOOLEAN BVar1;
  int iVar2;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmtSta_IsRxEAPOLValid");
  if ((((pKeyMgmtInfoSta == (keyMgmtInfoSta_t *)0x0) || (pKeyMsg == (EAPOL_KeyMsg_t *)0x0)) ||
      (iVar2 = isApReplayCounterFresh(pKeyMgmtInfoSta,(UINT8 *)pKeyMsg->replay_cnt), iVar2 == 0)) ||
     (((*(byte *)&pKeyMsg->key_info & 1) != 0 &&
      ((((*(byte *)&(pKeyMsg->key_info).field_0x1 & 8) != 0 &&
        (iVar2 = memcmp(pKeyMsg->key_nonce,pKeyMgmtInfoSta,0x20), iVar2 != 0)) ||
       (BVar1 = IsEAPOL_MICValid(pKeyMsg,pKeyMgmtInfoSta->EAPOL_MIC_Key), BVar1 == 0)))))) {
    BVar1 = 0;
  }
  else {
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"KeyMgmtSta_IsRxEAPOLValid");
    BVar1 = 1;
  }
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void KeyMgmtSta_PrepareEAPOLFrame
               (EAPOL_KeyMsg_Tx_t *pTxEapol,EAPOL_KeyMsg_t *pRxEapol,IEEEtypes_MacAddr_t *da,
               IEEEtypes_MacAddr_t *sa,UINT8 *pSNonce)

{
  byte bVar1;
  byte bVar2;
  UINT32 UVar3;
  char "KeyMgmtSta_PrepareEAPOLFrame" [29];
  byte bVar4;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmtSta_PrepareEAPOLFrame");
  if ((pTxEapol != (EAPOL_KeyMsg_Tx_t *)0x0) && (pRxEapol != (EAPOL_KeyMsg_t *)0x0)) {
    memset(pTxEapol,0,0x72);
    formEAPOLEthHdr(pTxEapol,da,sa);
    (pTxEapol->keyMsg).desc_type = pRxEapol->desc_type;
    bVar4 = *(byte *)&(pRxEapol->key_info).field_0x1 & 8;
    bVar1 = *(byte *)&(pTxEapol->keyMsg).key_info.field_0x1;
    bVar2 = *(byte *)&(pTxEapol->keyMsg).key_info;
    *(byte *)&(pTxEapol->keyMsg).key_info.field_0x1 = bVar1 & 0xf7 | bVar4;
    *(byte *)&(pTxEapol->keyMsg).key_info = bVar2 | 1;
    *(byte *)&(pTxEapol->keyMsg).key_info = bVar2 & 0xfd | 1 | *(byte *)&pRxEapol->key_info & 2;
    UVar3 = pRxEapol->replay_cnt[0];
    *(char *)(pTxEapol->keyMsg).replay_cnt = (char)*(undefined3 *)pRxEapol->replay_cnt;
    *(undefined *)((int)(pTxEapol->keyMsg).replay_cnt + 1) = (char)(UVar3 >> 8);
    *(undefined *)((int)(pTxEapol->keyMsg).replay_cnt + 2) = (char)(UVar3 >> 0x10);
    *(undefined *)((int)(pTxEapol->keyMsg).replay_cnt + 3) = (char)(UVar3 >> 0x18);
    UVar3 = pRxEapol->replay_cnt[1];
    *(char *)((pTxEapol->keyMsg).replay_cnt + 1) = (char)*(undefined3 *)(pRxEapol->replay_cnt + 1);
    *(undefined *)((int)(pTxEapol->keyMsg).replay_cnt + 5) = (char)(UVar3 >> 8);
    *(undefined *)((int)(pTxEapol->keyMsg).replay_cnt + 6) = (char)(UVar3 >> 0x10);
    *(undefined *)((int)(pTxEapol->keyMsg).replay_cnt + 7) = (char)(UVar3 >> 0x18);
    *(byte *)&(pTxEapol->keyMsg).key_info.field_0x1 =
         bVar1 & 0xf0 | bVar4 | *(byte *)&(pRxEapol->key_info).field_0x1 & 7;
    if (pSNonce != (UINT8 *)0x0) {
      memcpy((pTxEapol->keyMsg).key_nonce,pSNonce,0x20);
    }
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c810);
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BOOLEAN supplicantAkmIsWpaWpa2(AkmSuite_t *pAkm)

{
  int iVar1;
  BOOLEAN BVar2;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantAkmIsWpaWpa2");
  iVar1 = memcmp(pAkm,"",3);
  if ((iVar1 == 0) || (iVar1 = memcmp(pAkm,"",3), iVar1 == 0)) {
    BVar2 = 1;
  }
  else {
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"supplicantAkmIsWpaWpa2");
    BVar2 = 0;
  }
  return BVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BOOLEAN supplicantAkmIsWpa2(AkmSuite_t *pAkm)

{
  int iVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantAkmIsWpa2");
  iVar1 = memcmp(pAkm,"",3);
  if (iVar1 != 0) {
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"supplicantAkmIsWpa2");
  }
  return (uint)(iVar1 == 0);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BOOLEAN supplicantAkmIsWpaWpa2Psk(AkmSuite_t *pAkm)

{
  char "supplicantAkmIsWpaWpa2Psk" [26];
  uint uVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantAkmIsWpaWpa2Psk");
  uVar1 = supplicantAkmIsWpaWpa2(pAkm);
  if (uVar1 == 0) {
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c85c);
  }
  else {
    uVar1 = 1;
    if ((pAkm->akmType & 0xfb) != 2) {
      uVar1 = (uint)(pAkm->akmType == AKM_FT_PSK);
    }
  }
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BOOLEAN supplicantAkmUsesKdf(AkmSuite_t *pAkm)

{
  char "supplicantAkmUsesKdf" [21];
  BOOLEAN BVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantAkmUsesKdf");
  BVar1 = supplicantAkmIsWpa2(pAkm);
  if ((BVar1 == 0) || (BVar1 = 1, 3 < (byte)(pAkm->akmType + ~AKM_WPA_MAX))) {
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c878);
    BVar1 = 0;
  }
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void supplicantConstructContext
               (IEEEtypes_MacAddr_t *pAddr1,IEEEtypes_MacAddr_t *pAddr2,UINT8 *pNonce1,
               UINT8 *pNonce2,UINT8 *pContext)

{
  char "supplicantConstructContext" [27];
  int iVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantConstructContext");
  iVar1 = memcmp(pAddr1,pAddr2,6);
  if (iVar1 < 0) {
    memcpy(pContext,pAddr1,6);
    pAddr1 = pAddr2;
  }
  else {
    memcpy(pContext,pAddr2,6);
  }
  memcpy(pContext + 6,pAddr1,6);
  iVar1 = memcmp(pNonce1,pNonce2,0x20);
  if (iVar1 < 0) {
    memcpy(pContext + 0xc,pNonce1,0x20);
    pNonce1 = pNonce2;
  }
  else {
    memcpy(pContext + 0xc,pNonce2,0x20);
  }
  memcpy(pContext + 0x2c,pNonce1,0x20);
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c890);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void KeyMgmt_DerivePTK(IEEEtypes_MacAddr_t *pAddr1,IEEEtypes_MacAddr_t *pAddr2,UINT8 *pNonce1,
                      UINT8 *pNonce2,UINT8 *pPTK,UINT8 *pPMK,BOOLEAN use_kdf)

{
  char "KeyMgmt_DerivePTK" [18];
  UINT8 *pContext;
  
  pContext = pPTK + 200;
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmt_DerivePTK");
  supplicantConstructContext(pAddr1,pAddr2,pNonce1,pNonce2,pContext);
  if (use_kdf == 0) {
    Bl_PRF(pPMK,0x20,(uchar *)"Pairwise key expansion",0x16,pContext,0x4c,pPTK,0x40);
  }
  else {
    bl_sha256_crypto_kdf(pPMK,' ',"Pairwise key expansion",'\x16',pContext,0x4c,pPTK,0x180);
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c8ac);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void KeyMgmtSta_DeriveKeys
               (UINT8 *pPMK,IEEEtypes_MacAddr_t *da,IEEEtypes_MacAddr_t *sa,UINT8 *ANonce,
               UINT8 *SNonce,UINT8 *EAPOL_MIC_Key,UINT8 *EAPOL_Encr_Key,KeyData_t *newPWKey,
               BOOLEAN use_kdf)

{
  char "KeyMgmtSta_DeriveKeys" [22];
  BOOLEAN in_stack_00000000;
  UINT8 aUStack548 [4];
  UINT8 pBuf [500];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmtSta_DeriveKeys");
  if (((pPMK != (UINT8 *)0x0) && (EAPOL_MIC_Key != (UINT8 *)0x0)) && (newPWKey != (KeyData_t *)0x0))
  {
    KeyMgmt_DerivePTK(sa,da,ANonce,SNonce,aUStack548,pPMK,in_stack_00000000);
    memcpy(EAPOL_MIC_Key,aUStack548,0x10);
    memcpy(EAPOL_Encr_Key,pBuf + 0xc,0x10);
    memcpy(newPWKey,pBuf + 0x1c,0x10);
    memcpy(newPWKey->RxMICKey,pBuf + 0x2c,8);
    memcpy(newPWKey->TxMICKey,pBuf + 0x34,8);
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c8c0);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SetEAPOLKeyDescTypeVersion
               (EAPOL_KeyMsg_Tx_t *pTxEapol,BOOLEAN isWPA2,BOOLEAN isKDF,BOOLEAN nonTKIP)

{
  byte bVar1;
  char "SetEAPOLKeyDescTypeVersion" [27];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"SetEAPOLKeyDescTypeVersion");
  bVar1 = *(byte *)&(pTxEapol->keyMsg).key_info.field_0x1;
  (pTxEapol->keyMsg).desc_type = '\x02';
  *(byte *)&(pTxEapol->keyMsg).key_info.field_0x1 = bVar1 & 0xf8 | (isKDF != 0) + 2U;
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c8d8);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

EAPOL_KeyMsg_t *
GetKeyMsgNonceFromEAPOL(BufferDesc_t *pEAPoLBufDesc,keyMgmtInfoSta_t *pKeyMgmtInfoSta)

{
  char "GetKeyMsgNonceFromEAPOL" [24];
  EAPOL_KeyMsg_t *pKeyMsg;
  BOOLEAN BVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"GetKeyMsgNonceFromEAPOL");
  pKeyMsg = (EAPOL_KeyMsg_t *)pEAPoLBufDesc->Buffer;
  BVar1 = KeyMgmtSta_IsRxEAPOLValid(pKeyMgmtInfoSta,pKeyMsg);
  if (BVar1 == 0) {
    pKeyMsg = (EAPOL_KeyMsg_t *)0x0;
  }
  else {
    if ((*(byte *)&pKeyMsg->key_info & 1) == 0) {
      memcpy(pKeyMgmtInfoSta,pKeyMsg->key_nonce,0x20);
      supplicantGenerateRand(pKeyMgmtInfoSta->SNonce,0x20);
    }
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c8f4);
  }
  return pKeyMsg;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

EAPOL_KeyMsg_t *
ProcessRxEAPOL_PwkMsg3(BufferDesc_t *pEAPoLBufDesc,keyMgmtInfoSta_t *pKeyMgmtInfoSta)

{
  char "ProcessRxEAPOL_PwkMsg3" [23];
  EAPOL_KeyMsg_t *pKeyMsg;
  BOOLEAN BVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"ProcessRxEAPOL_PwkMsg3");
  pKeyMsg = GetKeyMsgNonceFromEAPOL(pEAPoLBufDesc,pKeyMgmtInfoSta);
  if (pKeyMsg == (EAPOL_KeyMsg_t *)0x0) {
LAB_23053168:
    pKeyMsg = (EAPOL_KeyMsg_t *)0x0;
  }
  else {
    (pKeyMgmtInfoSta->newPWKey).TxIV16 = 1;
    (pKeyMgmtInfoSta->newPWKey).TxIV32 = 0;
    if ((*(byte *)&pKeyMsg->key_info & 0x10) != 0) {
      mm_timer_clear(&pKeyMgmtInfoSta->rsnTimer);
      KeyMgmtSta_ApplyKEK(pKeyMsg,&pKeyMgmtInfoSta->GRKey,pKeyMgmtInfoSta->EAPOL_Encr_Key);
      BVar1 = keyMgmtProcessMsgExt(pKeyMgmtInfoSta,pKeyMsg);
      if (BVar1 == 0) goto LAB_23053168;
      parseKeyDataGTK(pKeyMsg->key_data,pKeyMsg->key_material_len,&pKeyMgmtInfoSta->GRKey);
    }
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c90c);
  }
  return pKeyMsg;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

EAPOL_KeyMsg_t *
ProcessRxEAPOL_GrpMsg1(BufferDesc_t *pEAPoLBufDesc,keyMgmtInfoSta_t *pKeyMgmtInfoSta)

{
  char "ProcessRxEAPOL_GrpMsg1" [23];
  EAPOL_KeyMsg_t *pKeyMsg;
  BOOLEAN BVar1;
  KeyData_t *pGRKey;
  UINT8 *__src;
  UINT8 *__src_00;
  undefined auStack40 [4];
  UINT8 buf [8];
  
  pKeyMsg = GetKeyMsgNonceFromEAPOL(pEAPoLBufDesc,pKeyMgmtInfoSta);
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"ProcessRxEAPOL_GrpMsg1");
  if (pKeyMsg == (EAPOL_KeyMsg_t *)0x0) {
LAB_23053224:
    pKeyMsg = (EAPOL_KeyMsg_t *)0x0;
  }
  else {
    pGRKey = &pKeyMgmtInfoSta->GRKey;
    KeyMgmtSta_ApplyKEK(pKeyMsg,pGRKey,pKeyMgmtInfoSta->EAPOL_Encr_Key);
    pKeyMgmtInfoSta->RSNDataTrafficEnabled = 1;
    mm_timer_clear(&pKeyMgmtInfoSta->rsnTimer);
    if (pKeyMsg->desc_type == '\x02') {
      parseKeyDataGTK(pKeyMsg->key_data,pKeyMsg->key_material_len,pGRKey);
      BVar1 = keyMgmtProcessMsgExt(pKeyMgmtInfoSta,pKeyMsg);
      if (BVar1 == 0) goto LAB_23053224;
    }
    else {
      memcpy(pGRKey,pKeyMsg->key_data,(uint)pKeyMsg->key_material_len);
      __src_00 = (pKeyMgmtInfoSta->GRKey).TxMICKey;
      memcpy(auStack40,__src_00,8);
      __src = (pKeyMgmtInfoSta->GRKey).RxMICKey;
      memcpy(__src_00,__src,8);
      memcpy(__src,auStack40,8);
      (pKeyMgmtInfoSta->GRKey).KeyIndex = (ushort)(*(byte *)&(pKeyMsg->key_info).field_0x1 >> 4) & 3
      ;
    }
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c924);
  }
  return pKeyMsg;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void KeyMgmtResetCounter(keyMgmtInfoSta_t *pKeyMgmtInfo)

{
  char "KeyMgmtResetCounter" [20];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmtResetCounter");
  if (pKeyMgmtInfo != (keyMgmtInfoSta_t *)0x0) {
    pKeyMgmtInfo->staCounterHi = 0;
    pKeyMgmtInfo->staCounterLo = 0;
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c93c);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void keyMgmtSta_StartSession_internal(keyMgmtInfoSta_t *pKeyMgmtInfoSta,UINT32 expiry)

{
  char "keyMgmtSta_StartSession_internal" [33];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"keyMgmtSta_StartSession_internal");
  if ((pKeyMgmtInfoSta->sta_MIC_Error).disableStaAsso == 0) {
    mm_timer_set(&pKeyMgmtInfoSta->rsnTimer,_DAT_44b00120 + expiry);
  }
  pKeyMgmtInfoSta->apCounterLo = 0;
  pKeyMgmtInfoSta->apCounterHi = 0;
  pKeyMgmtInfoSta->apCounterZeroDone = 0;
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c974);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void KeyMgmtSta_InitSession(keyMgmtInfoSta_t *pKeyMgmtInfoSta)

{
  char "KeyMgmtSta_InitSession" [23];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmtSta_InitSession");
  pKeyMgmtInfoSta->RSNDataTrafficEnabled = 0;
  pKeyMgmtInfoSta->RSNSecured = 0;
  pKeyMgmtInfoSta->pRxDecryptKey = (cipher_key_t *)0x0;
  pKeyMgmtInfoSta->pwkHandshakeComplete = 0;
  (pKeyMgmtInfoSta->rsnTimer).cb = keyMgmtStaRsnSecuredTimeoutHandler;
  *(keyMgmtInfoSta_t **)&(pKeyMgmtInfoSta->rsnTimer).env = pKeyMgmtInfoSta;
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c998);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void bl_sha256_crypto_kdf
               (UINT8 *pKey,UINT8 key_len,char *label,UINT8 label_len,UINT8 *pContext,
               UINT16 context_len,UINT8 *pOutput,UINT16 output_len)

{
  UINT8 *mac;
  undefined3 in_register_0000202d;
  undefined2 in_register_0000203e;
  undefined2 in_register_00002046;
  ushort auStack114 [8];
  ushort uStack98;
  UINT16 i;
  ushort *puStack96;
  UINT8 *vectors [4];
  size_t vectLen [4];
  
  uStack98 = 1;
  mac = pContext + CONCAT22(in_register_0000203e,context_len);
  auStack114[0] = output_len;
  while ((uint)uStack98 <= (CONCAT22(in_register_00002046,output_len) + 0xff >> 8 & 0xffU)) {
    vectors[3] = (UINT8 *)0x2;
    puStack96 = &uStack98;
    vectors[0] = (UINT8 *)label;
    vectors[1] = pContext;
    vectors[2] = (UINT8 *)auStack114;
    hmac_sha256_vector(pKey,CONCAT31(in_register_0000202d,key_len),4,(UINT8 **)&stack0xffffffa0,
                       (size_t *)(vectors + 3),mac);
    mac = mac + 0x20;
    uStack98 = uStack98 + 1;
  }
  memcpy(pOutput,pContext + CONCAT22(in_register_0000203e,context_len),(uint)(auStack114[0] >> 3));
  return;
}



void Bl_F(uchar *digest,uchar *digest1,char *password,uchar *ssid,int ssidlength,int iterations,
         int count,uchar *output)

{
  int iVar1;
  size_t key_len;
  byte *pbVar2;
  uchar *puVar3;
  byte *pbVar4;
  int iVar5;
  int iStack56;
  int tmpLen;
  uchar *pTemp;
  
  key_len = strlen(password);
  iStack56 = ssidlength + 4;
  tmpLen = (int)digest;
  memcpy(digest,ssid,ssidlength);
  puVar3 = digest + ssidlength;
  *puVar3 = (uchar)((uint)count >> 0x18);
  puVar3[1] = (uchar)((uint)count >> 0x10);
  puVar3[2] = (uchar)((uint)count >> 8);
  puVar3[3] = (uchar)count;
  Bl_hmac_sha1((uchar **)&tmpLen,&iStack56,1,(uchar *)password,key_len,digest1,0x14);
  memcpy(output,digest1,0x14);
  iVar1 = 1;
  tmpLen = (int)digest1;
  while (iVar1 < iterations) {
    iStack56 = 0x14;
    Bl_hmac_sha1((uchar **)&tmpLen,&iStack56,1,(uchar *)password,key_len,digest,0x14);
    memcpy(digest1,digest,0x14);
    iVar5 = 0;
    do {
      pbVar2 = output + iVar5;
      pbVar4 = digest + iVar5;
      iVar5 = iVar5 + 1;
      *pbVar2 = *pbVar4 ^ *pbVar2;
    } while (iVar5 != 0x14);
    iVar1 = iVar1 + 1;
  }
  return;
}



int Bl_PasswordHash(char *password,uchar *ssid,int ssidlength,uchar *output)

{
  size_t sVar1;
  int iVar2;
  uchar auStack88 [4];
  uchar digest1 [20];
  uchar digest [36];
  
  sVar1 = strlen(password);
  if (sVar1 < 0x40) {
    iVar2 = -1;
    if (ssidlength < 0x21) {
      Bl_F(digest1 + 0x10,auStack88,password,ssid,ssidlength,0x1000,2,output);
      memcpy(output + 0x14,output,0xc);
      Bl_F(digest1 + 0x10,auStack88,password,ssid,ssidlength,0x1000,1,output);
      iVar2 = 0;
    }
  }
  else {
    iVar2 = -1;
  }
  return iVar2;
}



int bl60x_fw_password_hash(char *password,uchar *ssid,int ssidlength,uchar *output)

{
  size_t sVar1;
  int iVar2;
  uchar auStack88 [20];
  uchar auStack68 [48];
  
  sVar1 = strlen(password);
  if (sVar1 < 0x40) {
    iVar2 = -1;
    if (ssidlength < 0x21) {
      Bl_F(auStack68,auStack88,password,ssid,ssidlength,0x1000,2,output);
      memcpy(output + 0x14,output,0xc);
      Bl_F(auStack68,auStack88,password,ssid,ssidlength,0x1000,1,output);
      iVar2 = 0;
    }
  }
  else {
    iVar2 = -1;
  }
  return iVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

UINT8 * pmkCacheFindPSK(UINT8 *pSsid,UINT8 ssidLen)

{
  char "pmkCacheFindPSK" [16];
  pmkElement_t *pPSK;
  size_t sVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"pmkCacheFindPSK");
  pPSK = pmkCacheFindPSKElement(pSsid,ssidLen);
  if (pPSK == (pmkElement_t *)0x0) {
    if (PSKPassPhrase != '\0') {
      pmkCacheAddPSK(pSsid,ssidLen,(UINT8 *)0x0,'\0');
      pPSK = pmkCacheFindPSKElement(pSsid,ssidLen);
      sVar1 = strlen((char *)PSKPassPhrase);
      pPSK = (pmkElement_t *)pPSK->PMK;
      pmkCacheGeneratePSK(pSsid,ssidLen,PSKPassPhrase,(UINT8)sVar1,(UINT8 *)pPSK);
    }
  }
  else {
    pPSK = (pmkElement_t *)pPSK->PMK;
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c9b0);
  return (UINT8 *)pPSK;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void pmkCacheSetPassphrase(UINT8 *pSsid,UINT8 ssidLen,UINT8 *pPassphrase,UINT8 PassphraseLen)

{
  char "pmkCacheSetPassphrase" [22];
  pmkElement_t *pSsid_00;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"pmkCacheSetPassphrase");
  if (pPassphrase != (UINT8 *)0x0) {
    memcpy(PSKPassPhrase,pPassphrase,0x40);
    pmkCacheAddPSK(pSsid,ssidLen,pPassphrase,PassphraseLen);
    pSsid_00 = pmkCacheFindPSKElement(pSsid,ssidLen);
    pmkCacheGeneratePSK((UINT8 *)pSsid_00,pSsid_00->length,PSKPassPhrase,PassphraseLen,pSsid_00->PMK
                       );
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c9c0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void pmkCacheInit(void)

{
  char "pmkCacheInit" [13];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"pmkCacheInit");
  memset(pmkCache,0,0x86);
  memset(PSKPassPhrase,0,0x40);
  replacementRankMax = '\0';
  dbg_test_print("%dms : Leave: %s\n",0x2307c9d8);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void pmkCacheRomInit(void)

{
  char "pmkCacheRomInit" [16];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"pmkCacheRomInit");
  ramHook_MAX_PMK_CACHE_ENTRIES = 2;
  ramHook_pmkCache = pmkCache;
  ramHook_PSKPassPhrase = PSKPassPhrase;
  dbg_test_print("%dms : Leave: %s\n",0x2307c9e8);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

pmkElement_t * pmkCacheNewElement(void)

{
  char "pmkCacheNewElement" [19];
  uint uVar1;
  pmkElement_t *__s;
  pmkElement_t *ppVar2;
  
  ppVar2 = (pmkElement_t *)0x0;
  uVar1 = 0;
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"pmkCacheNewElement");
  while ((int)uVar1 < ramHook_MAX_PMK_CACHE_ENTRIES) {
    if ((int)replacementRankMax == ramHook_MAX_PMK_CACHE_ENTRIES) {
      ramHook_pmkCache[uVar1].replacementRank = ramHook_pmkCache[uVar1].replacementRank + -1;
    }
    if (ppVar2 == (pmkElement_t *)0x0) {
      __s = ramHook_pmkCache + uVar1;
      if (__s->replacementRank == '\0') {
        memset(__s,0,0x43);
        if (replacementRankMax < ramHook_MAX_PMK_CACHE_ENTRIES) {
          replacementRankMax = replacementRankMax + '\x01';
        }
        ramHook_pmkCache[uVar1].replacementRank = replacementRankMax;
        ppVar2 = __s;
      }
    }
    uVar1 = uVar1 + 1 & 0xff;
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307c9f8);
  return ppVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void pmkCacheUpdateReplacementRank(pmkElement_t *pPMKElement)

{
  char cVar1;
  SINT8 SVar2;
  pmkElement_t *ppVar3;
  SINT32 SVar4;
  char "pmkCacheUpdateReplacementRank" [30];
  uint uVar5;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"pmkCacheUpdateReplacementRank");
  SVar4 = ramHook_MAX_PMK_CACHE_ENTRIES;
  ppVar3 = ramHook_pmkCache;
  SVar2 = replacementRankMax;
  if ((pPMKElement != (pmkElement_t *)0x0) && (pPMKElement->replacementRank != replacementRankMax))
  {
    uVar5 = 0;
    while ((int)uVar5 < SVar4) {
      cVar1 = ppVar3[uVar5].replacementRank;
      if (pPMKElement->replacementRank < cVar1) {
        ppVar3[uVar5].replacementRank = cVar1 + -1;
      }
      uVar5 = uVar5 + 1 & 0xff;
    }
    pPMKElement->replacementRank = SVar2;
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307ca0c);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

pmkElement_t * pmkCacheFindPSKElement(UINT8 *pSsid,UINT8 ssidLen)

{
  char "pmkCacheFindPSKElement" [23];
  uint uVar1;
  pmkElement_t *pPMKElement;
  pmkElement_t *__s1;
  int iVar2;
  undefined3 in_register_0000202d;
  
  pPMKElement = (pmkElement_t *)0x0;
  uVar1 = 0;
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"pmkCacheFindPSKElement");
  while ((int)uVar1 < ramHook_MAX_PMK_CACHE_ENTRIES) {
    __s1 = ramHook_pmkCache + uVar1;
    if (((__s1->replacementRank != '\0') &&
        ((uint)__s1->length == CONCAT31(in_register_0000202d,ssidLen))) &&
       (iVar2 = memcmp(__s1,pSsid,CONCAT31(in_register_0000202d,ssidLen)), iVar2 == 0)) {
      pPMKElement = ramHook_pmkCache + uVar1;
    }
    uVar1 = uVar1 + 1 & 0xff;
  }
  pmkCacheUpdateReplacementRank(pPMKElement);
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307ca2c);
  return pPMKElement;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void pmkCacheAddPSK(UINT8 *pSsid,UINT8 ssidLen,UINT8 *pPSK,UINT8 pPSKLen)

{
  char "pmkCacheAddPSK" [15];
  pmkElement_t *__dest;
  undefined3 in_register_0000202d;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"pmkCacheAddPSK");
  __dest = pmkCacheFindPSKElement(pSsid,ssidLen);
  if (__dest == (pmkElement_t *)0x0) {
    __dest = pmkCacheNewElement();
    memcpy(__dest,pSsid,CONCAT31(in_register_0000202d,ssidLen));
    __dest->length = ssidLen;
  }
  if (pPSK != (UINT8 *)0x0) {
    memcpy(__dest->PMK,pPSK,0x20);
    __dest->psk_length = pPSKLen;
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307ca44);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void pmkCacheDeletePSK(UINT8 *pSsid,UINT8 ssidLen)

{
  char "pmkCacheDeletePSK" [18];
  pmkElement_t *__s;
  
  __s = pmkCacheFindPSKElement(pSsid,ssidLen);
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"pmkCacheDeletePSK");
  if (__s != (pmkElement_t *)0x0) {
    memset(__s,0,0x43);
    replacementRankMax = replacementRankMax + -1;
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307ca54);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

UINT8 pmkCacheGetHexNibble(UINT8 nibble)

{
  undefined3 in_register_00002029;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"pmkCacheGetHexNibble");
  if (CONCAT31(in_register_00002029,nibble) < 0x61) {
    if (CONCAT31(in_register_00002029,nibble) < 0x41) {
      nibble = nibble + -0x30;
      dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"pmkCacheGetHexNibble");
    }
    else {
      nibble = nibble + -0x37;
    }
  }
  else {
    nibble = nibble + -0x57;
  }
  return nibble;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void pmkCacheGeneratePSK(UINT8 *pSsid,UINT8 ssidLen,UINT8 *pPassphrase,UINT8 PassphraseLen,
                        UINT8 *pPSK)

{
  char "pmkCacheGeneratePSK" [20];
  UINT8 UVar1;
  byte bVar2;
  undefined3 in_register_0000202d;
  undefined3 in_register_00002035;
  int iVar3;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"pmkCacheGeneratePSK");
  if ((pPSK != (UINT8 *)0x0) && (pPassphrase != (UINT8 *)0x0)) {
    if (CONCAT31(in_register_00002035,PassphraseLen) - 8U < 0x38) {
      utils_wifi_psk_cal_fast_bin
                ((char *)pPassphrase,pSsid,CONCAT31(in_register_0000202d,ssidLen),pPSK);
    }
    else {
      if (CONCAT31(in_register_00002035,PassphraseLen) == 0x40) {
        iVar3 = 0;
        do {
          UVar1 = pmkCacheGetHexNibble(*pPassphrase);
          bVar2 = pmkCacheGetHexNibble(pPassphrase[1]);
          pPSK[iVar3 >> 1] = bVar2 | UVar1 << 4;
          iVar3 = iVar3 + 2;
          pPassphrase = pPassphrase + 2;
        } while (iVar3 != 0x40);
      }
    }
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307ca80);
  return;
}



void prepare_key(uchar *key_data_ptr,int key_data_len,rc4_key *key)

{
  byte bVar1;
  uchar *puVar2;
  rc4_key *prVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  
  iVar5 = 0;
  do {
    key->state[iVar5] = (uchar)iVar5;
    iVar5 = iVar5 + 1;
  } while (iVar5 != 0x100);
  key->x = '\0';
  key->y = '\0';
  uVar7 = 0;
  uVar4 = 0;
  prVar3 = key;
  do {
    bVar1 = prVar3->state[0];
    puVar2 = prVar3->state;
    uVar6 = (uint)key_data_ptr[uVar4] + (uint)bVar1 + uVar7;
    uVar7 = uVar6 & 0xff;
    prVar3->state[0] = key->state[uVar6 & 0xff];
    key->state[uVar6 & 0xff] = bVar1;
    uVar4 = (int)(uVar4 + 1) % key_data_len & 0xff;
    prVar3 = (rc4_key *)(puVar2 + 1);
  } while ((rc4_key *)&key->x != (rc4_key *)(puVar2 + 1));
  return;
}



void rc4(uchar *buffer_ptr,int buffer_len,int skip,rc4_key *key)

{
  byte bVar1;
  byte bVar2;
  byte *pbVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  byte *pbVar7;
  uint uVar8;
  
  bVar1 = key->x;
  uVar4 = (uint)key->y;
  iVar5 = 0;
  while (uVar8 = (uint)bVar1 + iVar5 & 0xff, iVar5 < skip) {
    bVar2 = key->state[uVar8 + 1 & 0xff];
    uVar4 = uVar4 + bVar2 & 0xff;
    iVar5 = (iVar5 + 1) * 0x10000 >> 0x10;
    key->state[uVar8 + 1 & 0xff] = key->state[uVar4];
    key->state[uVar4] = bVar2;
  }
  iVar5 = 0;
  while (uVar6 = uVar8 + iVar5 & 0xff, iVar5 < buffer_len) {
    pbVar7 = key->state + (uVar6 + 1 & 0xff);
    bVar1 = *pbVar7;
    uVar4 = uVar4 + (uint)bVar1 & 0xff;
    *pbVar7 = key->state[uVar4];
    key->state[uVar4] = bVar1;
    pbVar3 = buffer_ptr + iVar5;
    iVar5 = (iVar5 + 1) * 0x10000 >> 0x10;
    *pbVar3 = key->state[(uint)bVar1 + (uint)*pbVar7 & 0xff] ^ *pbVar3;
  }
  key->x = (uchar)uVar6;
  key->y = (uchar)uVar4;
  return;
}



void RC4_Encrypt(uchar *Encr_Key,uchar *IV,__uint16_t iv_length,uchar *Data,__uint16_t data_length,
                __uint16_t skipBytes)

{
  undefined2 in_register_00002032;
  size_t __n;
  undefined2 in_register_0000203a;
  undefined2 in_register_0000203e;
  uchar auStack64 [4];
  uchar key [32];
  
  __n = CONCAT22(in_register_00002032,iv_length);
  if ((int)(__n + 0x10) < 0x21) {
    memcpy(auStack64,IV,__n);
    memcpy(auStack64 + __n,Encr_Key,0x10);
    prepare_key(auStack64,__n + 0x10,&rc4key);
    rc4(Data,CONCAT22(in_register_0000203a,data_length),CONCAT22(in_register_0000203e,skipBytes),
        &rc4key);
  }
  return;
}



int sha256_compress(sha256_state *md,UINT8 *msgBuf,UINT8 *pScratchMem)

{
  UINT32 *pUVar1;
  UINT32 *pUVar2;
  int iVar3;
  uint uVar4;
  uint *puVar5;
  uint uVar6;
  int *piVar7;
  int *piVar8;
  int iVar9;
  int iVar10;
  uint uVar11;
  int *__dest;
  ushort *puVar12;
  ushort *puVar13;
  uint uVar14;
  uint uVar15;
  uint uVar16;
  
  __dest = (int *)(pScratchMem + 0x100);
  memcpy(__dest,md->state,0x20);
  puVar5 = (uint *)pScratchMem;
  puVar12 = (ushort *)msgBuf;
  do {
    puVar13 = puVar12 + 2;
    *puVar5 = (((uint)(*puVar12 >> 8) | ((uint)*puVar12 & 0xff) << 8) << 8 |
              (uint)*(byte *)(puVar12 + 1)) << 8 | (uint)*(byte *)((int)puVar12 + 3);
    puVar5 = puVar5 + 1;
    puVar12 = puVar13;
  } while (puVar13 != (ushort *)(msgBuf + 0x40));
  piVar7 = (int *)(pScratchMem + 0x40);
  do {
    uVar6 = piVar7[-2];
    uVar4 = piVar7[-0xf];
    piVar8 = piVar7 + 1;
    *piVar7 = ((uVar6 << 0xf | uVar6 >> 0x11) ^ (uVar6 << 0xd | uVar6 >> 0x13) ^ uVar6 >> 10) +
              piVar7[-7] + piVar7[-0x10] +
              ((uVar4 >> 7 | uVar4 << 0x19) ^ (uVar4 << 0xe | uVar4 >> 0x12) ^ uVar4 >> 3);
    piVar7 = piVar8;
  } while (__dest != piVar8);
  iVar3 = 0;
  do {
    uVar4 = *(uint *)(pScratchMem + 0x110);
    uVar14 = *(uint *)(pScratchMem + 0x118);
    uVar15 = *(uint *)(pScratchMem + 0x114);
    uVar6 = *(uint *)(pScratchMem + 0x100);
    iVar9 = *(int *)((int)K + iVar3);
    uVar11 = *(uint *)(pScratchMem + 0x104);
    uVar16 = *(uint *)(pScratchMem + 0x108);
    iVar10 = *(int *)(pScratchMem + iVar3);
    *(uint *)(pScratchMem + 0x114) = uVar4;
    iVar10 = ((uVar4 >> 6 | uVar4 << 0x1a) ^ (uVar4 >> 0xb | uVar4 << 0x15) ^
             (uVar4 << 7 | uVar4 >> 0x19)) + ((uVar14 ^ uVar15) & uVar4 ^ uVar14) +
             *(int *)(pScratchMem + 0x11c) + iVar9 + iVar10;
    *(int *)(pScratchMem + 0x110) = *(int *)(pScratchMem + 0x10c) + iVar10;
    *(uint *)(pScratchMem + 0x104) = uVar6;
    *(uint *)(pScratchMem + 0x11c) = uVar14;
    *(uint *)(pScratchMem + 0x118) = uVar15;
    *(uint *)(pScratchMem + 0x10c) = uVar16;
    *(uint *)(pScratchMem + 0x108) = uVar11;
    *(uint *)(pScratchMem + 0x100) =
         iVar10 + ((uVar6 >> 2 | uVar6 << 0x1e) ^ (uVar6 >> 0xd | uVar6 << 0x13) ^
                  (uVar6 << 10 | uVar6 >> 0x16)) + (uVar6 & uVar11 | (uVar6 | uVar11) & uVar16);
    iVar3 = iVar3 + 4;
  } while (iVar3 != 0x100);
  pUVar1 = md->state;
  do {
    iVar3 = *__dest;
    pUVar2 = pUVar1 + 1;
    __dest = __dest + 1;
    *pUVar1 = *pUVar1 + iVar3;
    pUVar1 = pUVar2;
  } while (&md->curlen != pUVar2);
  return 0;
}



void sha256_init(sha256_state *md)

{
  *(undefined4 *)&md->length = 0;
  md->state[0] = 0x6a09e667;
  md->state[1] = 0xbb67ae85;
  md->state[2] = 0x3c6ef372;
  md->state[3] = 0xa54ff53a;
  md->state[4] = 0x510e527f;
  md->state[5] = 0x9b05688c;
  md->state[6] = 0x1f83d9ab;
  md->curlen = 0;
  *(undefined4 *)((int)&md->length + 4) = 0;
  md->state[7] = 0x5be0cd19;
  return;
}



void sha256_vector(size_t num_elem,UINT8 **addr,size_t *len,UINT8 *mac,UINT8 *pScratchMem)

{
  int iVar1;
  uint uVar2;
  uint __n;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 *puVar5;
  uint uVar6;
  UINT8 *msgBuf;
  UINT8 *pScratchMem_00;
  int iVar7;
  
  pScratchMem_00 = pScratchMem + 0x70;
  sha256_init((sha256_state *)pScratchMem);
  iVar7 = 0;
  do {
    __n = *(uint *)(pScratchMem + 0x28);
    if (iVar7 == num_elem << 2) {
      if (__n < 0x40) {
        uVar2 = __n * 8 + *(uint *)pScratchMem;
        *(uint *)(pScratchMem + 4) =
             (uint)(uVar2 < *(uint *)pScratchMem) + *(int *)(pScratchMem + 4);
        *(uint *)pScratchMem = uVar2;
        *(uint *)(pScratchMem + 0x28) = __n + 1;
        pScratchMem[__n + 0x2c] = -0x80;
        if (0x38 < __n + 1) {
          while (__n = *(uint *)(pScratchMem + 0x28), __n < 0x40) {
            *(uint *)(pScratchMem + 0x28) = __n + 1;
            pScratchMem[__n + 0x2c] = '\0';
          }
          sha256_compress((sha256_state *)pScratchMem,pScratchMem + 0x2c,pScratchMem_00);
          *(undefined4 *)(pScratchMem + 0x28) = 0;
        }
        while (__n = *(uint *)(pScratchMem + 0x28), __n < 0x38) {
          *(uint *)(pScratchMem + 0x28) = __n + 1;
          pScratchMem[__n + 0x2c] = '\0';
        }
        uVar3 = *(undefined4 *)pScratchMem;
        pScratchMem[0x68] = (UINT8)((uint)uVar3 >> 0x18);
        pScratchMem[0x69] = (UINT8)((uint)uVar3 >> 0x10);
        pScratchMem[0x6b] = (UINT8)uVar3;
        uVar4 = *(undefined4 *)(pScratchMem + 4);
        pScratchMem[0x6a] = (UINT8)((uint)uVar3 >> 8);
        pScratchMem[100] = (UINT8)((uint)uVar4 >> 0x18);
        pScratchMem[0x65] = (UINT8)((uint)uVar4 >> 0x10);
        pScratchMem[0x67] = (UINT8)uVar4;
        pScratchMem[0x66] = (UINT8)((uint)uVar4 >> 8);
        sha256_compress((sha256_state *)pScratchMem,pScratchMem + 0x2c,pScratchMem_00);
        puVar5 = (undefined4 *)(pScratchMem + 8);
        do {
          puVar5 = puVar5 + 1;
          uVar3 = *puVar5;
          *mac = (UINT8)((uint)uVar3 >> 0x18);
          mac[1] = (UINT8)((uint)uVar3 >> 0x10);
          mac[2] = (UINT8)((uint)uVar3 >> 8);
          mac[3] = (UINT8)uVar3;
          puVar5 = puVar5;
          mac = mac + 4;
        } while (puVar5 != (undefined4 *)(pScratchMem + 0x28));
      }
      return;
    }
    msgBuf = *(UINT8 **)((int)addr + iVar7);
    uVar2 = *(uint *)((int)len + iVar7);
    if (__n < 0x41) {
      while (iVar1 = *(int *)(pScratchMem + 0x28), uVar2 != 0) {
        if ((iVar1 == 0) && (0x3f < uVar2)) {
          iVar1 = sha256_compress((sha256_state *)pScratchMem,msgBuf,pScratchMem_00);
          if (iVar1 < 0) break;
          uVar6 = *(uint *)pScratchMem;
          msgBuf = msgBuf + 0x40;
          __n = uVar6 + 0x200;
          *(uint *)pScratchMem = __n;
          *(uint *)(pScratchMem + 4) = (uint)(__n < uVar6) + *(int *)(pScratchMem + 4);
          uVar2 = uVar2 - 0x40;
        }
        else {
          __n = 0x40U - iVar1;
          if (uVar2 < 0x40U - iVar1) {
            __n = uVar2;
          }
          memcpy(pScratchMem + 0x2c + iVar1,msgBuf,__n);
          iVar1 = *(int *)(pScratchMem + 0x28);
          msgBuf = msgBuf + __n;
          uVar2 = uVar2 - __n;
          *(uint *)(pScratchMem + 0x28) = iVar1 + __n;
          if (iVar1 + __n == 0x40) {
            iVar1 = sha256_compress((sha256_state *)pScratchMem,pScratchMem + 0x2c,pScratchMem_00);
            if (iVar1 < 0) break;
            uVar6 = *(uint *)pScratchMem;
            *(undefined4 *)(pScratchMem + 0x28) = 0;
            __n = uVar6 + 0x200;
            *(uint *)pScratchMem = __n;
            *(uint *)(pScratchMem + 4) = (uint)(__n < uVar6) + *(int *)(pScratchMem + 4);
          }
        }
      }
    }
    iVar7 = iVar7 + 4;
  } while( true );
}



// WARNING: Variable defined which should be unmapped: pScratchMem

void hmac_sha256_vector(UINT8 *key,size_t key_len,size_t num_elem,UINT8 **addr,size_t *len,
                       UINT8 *mac)

{
  size_t *mac_00;
  UINT8 **ppUVar1;
  size_t **ppsVar2;
  UINT8 **len_00;
  UINT8 **ppUVar3;
  size_t *psVar4;
  int iVar5;
  size_t *psVar6;
  size_t sStack600;
  uint *apuStack596 [4];
  size_t *psStack580;
  UINT8 *_addr [6];
  size_t _len [6];
  UINT8 pScratchMem [500];
  
  mac_00 = (size_t *)(pScratchMem + 0x3c);
  sStack600 = key_len;
  apuStack596[0] = (uint *)key;
  if (0x40 < key_len) {
    apuStack596[0] = (uint *)key;
    sha256_vector(1,(UINT8 **)apuStack596,&sStack600,(UINT8 *)mac_00,pScratchMem + 0x5c);
    sStack600 = 0x20;
    apuStack596[0] = mac_00;
  }
  memset(_len + 5,0,0x40);
  memcpy(_len + 5,apuStack596[0],sStack600);
  psVar6 = _len + 5;
  do {
    psVar4 = psVar6 + 1;
    *psVar6 = *psVar6 ^ 0x36363636;
    psVar6 = psVar4;
  } while (psVar4 != mac_00);
  psStack580 = _len + 5;
  len_00 = _addr + 5;
  _addr[5] = (UINT8 *)0x40;
  iVar5 = 0;
  ppsVar2 = &psStack580;
  ppUVar3 = len_00;
  while( true ) {
    ppsVar2 = ppsVar2 + 1;
    ppUVar3 = ppUVar3 + 1;
    if (iVar5 == num_elem << 2) break;
    *ppsVar2 = *(size_t **)((int)addr + iVar5);
    ppUVar1 = (UINT8 **)((int)len + iVar5);
    iVar5 = iVar5 + 4;
    *ppUVar3 = *ppUVar1;
  }
  sha256_vector(num_elem + 1,(UINT8 **)&psStack580,(size_t *)len_00,mac,pScratchMem + 0x5c);
  memset(_len + 5,0,0x40);
  memcpy(_len + 5,apuStack596[0],sStack600);
  psVar6 = _len + 5;
  do {
    psVar4 = psVar6 + 1;
    *psVar6 = *psVar6 ^ 0x5c5c5c5c;
    psVar6 = psVar4;
  } while (psVar4 != mac_00);
  psStack580 = _len + 5;
  _addr[5] = (UINT8 *)0x40;
  _len[0] = 0x20;
  _addr[0] = mac;
  sha256_vector(2,(UINT8 **)&psStack580,(size_t *)len_00,mac,pScratchMem + 0x5c);
  return;
}



void KeyMgmtInit(cm_ConnectionInfo_t *connPtr)

{
  UINT8 ssidLen;
  apInfo_t *paVar1;
  size_t sVar2;
  UINT8 *pPassphrase;
  
  paVar1 = cm_GetApInfo(connPtr);
  ROM_InitGTK(&(paVar1->bssData).grpKeyData,(paVar1->bssData).GNonce,connPtr->localMacAddr);
  if ((paVar1->bssData).updatePassPhrase == 1) {
    ssidLen = (connPtr->comData).SsIdLen;
    pPassphrase = (paVar1->bssConfig).RsnConfig.PSKPassPhrase;
    sVar2 = strlen((char *)pPassphrase);
    pmkCacheGeneratePSK((UINT8 *)&connPtr->comData,ssidLen,pPassphrase,(UINT8)sVar2,
                        (paVar1->bssConfig).RsnConfig.PSKValue);
    (paVar1->bssData).updatePassPhrase = 0;
  }
  return;
}



BufferDesc_t *
PrepDefaultEapolMsg(cm_ConnectionInfo_t *connPtr,EAPOL_KeyMsg_Tx_t **pTxEapolPtr,
                   BufferDesc_t *pBufDesc)

{
  apSpecificData_t *paVar1;
  apInfo_t *paVar2;
  BufferDesc_t *pBVar3;
  uint nonTKIP;
  EAPOL_KeyMsg_Tx_t *pEStack36;
  EAPOL_KeyMsg_Tx_t *tx_eapol_ptr;
  
  paVar1 = cm_GetApData(connPtr);
  paVar2 = cm_GetApInfo(connPtr);
  pBVar3 = GetTxEAPOLBuffer(connPtr,&pEStack36,pBufDesc);
  if (pBVar3 != (BufferDesc_t *)0x0) {
    memset(pEStack36,0,0x72);
    formEAPOLEthHdr(pEStack36,(IEEEtypes_MacAddr_t *)connPtr->peerMacAddr,
                    (IEEEtypes_MacAddr_t *)connPtr->localMacAddr);
    nonTKIP = 1;
    if (((byte)(paVar1->staData).keyMgmtInfo.rom.staUcstCipher & 8) == 0) {
      nonTKIP = (uint)((byte)(paVar2->bssConfig).RsnConfig.mcstCipher >> 3) & 1;
    }
    SetEAPOLKeyDescTypeVersion
              (pEStack36,*(uint *)&(paVar1->staData).keyMgmtInfo.rom >> 0x15 & 1,0,nonTKIP);
    *pTxEapolPtr = pEStack36;
  }
  return pBVar3;
}



// WARNING: Variable defined which should be unmapped: replay_cnt

Status_e GeneratePWKMsg1(cm_ConnectionInfo_t *connPtr,BufferDesc_t *pBufDesc)

{
  Status_e SVar1;
  apSpecificData_t *paVar2;
  BufferDesc_t *pBufDesc_00;
  uint uVar3;
  uint uVar4;
  UINT32 UVar5;
  EAPOL_KeyMsg_Tx_t *pEStack28;
  EAPOL_KeyMsg_Tx_t *tx_eapol_ptr;
  UINT32 replay_cnt [2];
  
  paVar2 = cm_GetApData(connPtr);
  pBufDesc_00 = PrepDefaultEapolMsg(connPtr,&pEStack28,pBufDesc);
  if (pBufDesc_00 == (BufferDesc_t *)0x0) {
    SVar1 = FAIL;
  }
  else {
    UVar5 = (paVar2->staData).keyMgmtInfo.counterLo + 1;
    (paVar2->staData).keyMgmtInfo.counterLo = UVar5;
    if (UVar5 == 0) {
      (paVar2->staData).keyMgmtInfo.counterHi = (paVar2->staData).keyMgmtInfo.counterHi + 1;
    }
    tx_eapol_ptr = (EAPOL_KeyMsg_Tx_t *)(paVar2->staData).keyMgmtInfo.counterHi;
    supplicantGenerateRand((UINT8 *)&connPtr->TxRxCipherKeyBuf,0x20);
    PopulateKeyMsg(pEStack28,&(paVar2->staData).keyMgmtInfo.rom.staUcstCipher,0x800,
                   (UINT32 *)&tx_eapol_ptr,(UINT8 *)&connPtr->TxRxCipherKeyBuf);
    uVar3 = (uint)(pEStack28->keyMsg).key_material_len + 0x5f;
    uVar4 = uVar3 & 0xffff;
    (pEStack28->keyMsg).hdr_8021x.protocol_ver = (paVar2->staData).keyMgmtInfo.EAPOLProtoVersion;
    (pEStack28->keyMsg).hdr_8021x.pckt_type = IEEE_8021X_PACKET_TYPE_EAPOL_KEY;
    *(char *)&(pEStack28->keyMsg).hdr_8021x.pckt_body_len = (char)(uVar4 >> 8);
    *(undefined *)((int)&(pEStack28->keyMsg).hdr_8021x.pckt_body_len + 1) = (char)uVar4;
    UpdateEAPOLWcbLenAndTransmit(pBufDesc_00,(UINT16)(uVar3 * 0x10000 >> 0x10));
    SVar1 = FW_SUCCESS;
  }
  return SVar1;
}



Status_e GeneratePWKMsg3(cm_ConnectionInfo_t *connPtr,BufferDesc_t *pBufDesc)

{
  SecurityMode_t SVar1;
  UINT16 frameLen;
  BufferDesc_t *pBufDesc_00;
  apSpecificData_t *paVar2;
  apInfo_t *paVar3;
  BOOLEAN BVar4;
  uint8_t *pWPA2;
  UINT32 UVar5;
  Cipher_t_conflict *Cipher;
  EAPOL_KeyMsg_Tx_t *pEStack44;
  EAPOL_KeyMsg_Tx_t *tx_eapol_ptr;
  UINT32 replay_cnt [2];
  
  pBufDesc_00 = PrepDefaultEapolMsg(connPtr,&pEStack44,pBufDesc);
  if (pBufDesc_00 != (BufferDesc_t *)0x0) {
    paVar2 = cm_GetApData(connPtr);
    paVar3 = cm_GetApInfo(connPtr);
    UVar5 = (paVar2->staData).keyMgmtInfo.counterLo + 1;
    (paVar2->staData).keyMgmtInfo.counterLo = UVar5;
    if (UVar5 == 0) {
      (paVar2->staData).keyMgmtInfo.counterHi = (paVar2->staData).keyMgmtInfo.counterHi + 1;
    }
    tx_eapol_ptr = (EAPOL_KeyMsg_Tx_t *)(paVar2->staData).keyMgmtInfo.counterHi;
    Cipher = &(paVar2->staData).keyMgmtInfo.rom.staUcstCipher;
    PopulateKeyMsg(pEStack44,Cipher,
                   ((ushort)(paVar2->staData).keyMgmtInfo.rom.staSecType & 0x20) << 10 | 0x880,
                   (UINT32 *)&tx_eapol_ptr,(UINT8 *)&connPtr->TxRxCipherKeyBuf);
    SVar1 = (paVar2->staData).keyMgmtInfo.rom.staSecType;
    pWPA2 = (uint8_t *)0x0;
    if ((((ushort)SVar1 & 8) == 0) && (((ushort)SVar1 & 0x20) != 0)) {
      pWPA2 = int_rsn_ie;
    }
    BVar4 = KeyData_UpdateKeyMaterial
                      (pEStack44,&(paVar2->staData).keyMgmtInfo.rom.staSecType,(void *)0x0,pWPA2);
    if (BVar4 != 0) {
      if (((ushort)(paVar2->staData).keyMgmtInfo.rom.staSecType & 0x20) == 0) {
LAB_2305462c:
        frameLen = KeyMgmtSta_PopulateEAPOLLengthMic
                             (pEStack44,(paVar2->staData).keyMgmtInfo.EAPOL_MIC_Key,
                              (paVar2->staData).keyMgmtInfo.EAPOLProtoVersion,
                              *(byte *)&(pEStack44->keyMsg).key_info.field_0x1 & 7);
        UpdateEAPOLWcbLenAndTransmit(pBufDesc_00,frameLen);
        return FW_SUCCESS;
      }
      prepareKDE(pEStack44,&(paVar3->bssData).grpKeyData,
                 (Cipher_t_conflict *)&(paVar3->bssConfig).RsnConfig);
      BVar4 = Encrypt_keyData(pEStack44,(paVar2->staData).keyMgmtInfo.EAPOL_Encr_Key,Cipher);
      if (BVar4 != 0) goto LAB_2305462c;
    }
    vPortFree(pBufDesc_00->Buffer);
    vPortFree(pBufDesc_00);
  }
  return FAIL;
}



Status_e ProcessPWKMsg4(BufferDesc_t *pBufDesc)

{
  SecurityMode_t SVar1;
  cm_ConnectionInfo_t *connPtr;
  Status_e SVar2;
  apSpecificData_t *paVar3;
  BOOLEAN BVar4;
  
  connPtr = (cm_ConnectionInfo_t *)pBufDesc->intf;
  paVar3 = cm_GetApData(connPtr);
  BVar4 = IsEAPOL_MICValid((EAPOL_KeyMsg_t *)pBufDesc->Buffer,
                           (paVar3->staData).keyMgmtInfo.EAPOL_MIC_Key);
  if (BVar4 == 0) {
    SVar2 = FAIL;
  }
  else {
    (connPtr->TxRxCipherKeyBuf).cipher_key.ckd[0x44] = 1;
    (connPtr->TxRxCipherKeyBuf).cipher_key.ckd[0x45] = 0;
    (connPtr->TxRxCipherKeyBuf).cipher_key.ckd[0x40] = 0;
    (connPtr->TxRxCipherKeyBuf).cipher_key.ckd[0x41] = 0;
    (connPtr->TxRxCipherKeyBuf).cipher_key.ckd[0x42] = 0;
    (connPtr->TxRxCipherKeyBuf).cipher_key.ckd[0x43] = 0;
    add_key_to_mac(connPtr,'\x01');
    apm_sta_add(connPtr->staId);
    SVar1 = (paVar3->staData).keyMgmtInfo.rom.staSecType;
    (paVar3->staData).keyMgmtInfo.numHskTries = '\0';
    SVar2 = FW_SUCCESS;
    if (((ushort)SVar1 & 0x20) != 0) {
      (paVar3->staData).keyMgmtInfo.rom.keyMgmtState = HSK_END;
    }
  }
  return SVar2;
}



Status_e GenerateApEapolMsg(cm_ConnectionInfo_t *connPtr,keyMgmtState_e msgState,
                           BufferDesc_t *pBufDesc)

{
  IEEEtypes_PwrMgmtMode_e IVar1;
  uint uVar2;
  Status_e SVar3;
  apSpecificData_t *paVar4;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 in_register_0000202d;
  
  uVar2 = CONCAT31(in_register_0000202d,msgState);
  paVar4 = cm_GetApData(connPtr);
  if ((msgState & 1) == 0) {
    uVar2 = uVar2 - 1 & 0xff;
  }
  IVar1 = (paVar4->staData).pwrSaveInfo.mode;
  (paVar4->staData).keyMgmtInfo.rom.keyMgmtState = (keyMgmtState_e)uVar2;
  if (IVar1 != PWR_MODE_PWR_SAVE) {
    if (uVar2 == 1) {
      SVar3 = GeneratePWKMsg1(connPtr,pBufDesc);
      _SVar3 = CONCAT31(extraout_var,SVar3);
    }
    else {
      if (uVar2 != 3) {
        if (pBufDesc == (BufferDesc_t *)0x0) {
          return FAIL;
        }
        vPortFree(pBufDesc->Buffer);
        vPortFree(pBufDesc);
        return FAIL;
      }
      SVar3 = GeneratePWKMsg3(connPtr,pBufDesc);
      _SVar3 = CONCAT31(extraout_var_00,SVar3);
    }
    if (_SVar3 != 0) {
      return (Status_e)_SVar3;
    }
    (paVar4->staData).keyMgmtInfo.rom.keyMgmtState =
         (paVar4->staData).keyMgmtInfo.rom.keyMgmtState + MSG1_PENDING;
  }
  (paVar4->staData).keyMgmtInfo.numHskTries = (paVar4->staData).keyMgmtInfo.numHskTries + '\x01';
  return FW_SUCCESS;
}



Status_e ProcessPWKMsg2(BufferDesc_t *pBufDesc)

{
  cm_ConnectionInfo_t *connPtr;
  EAPOL_KeyMsg_t *pKeyMsg;
  Status_e SVar1;
  apSpecificData_t *paVar2;
  apInfo_t *paVar3;
  BOOLEAN BVar4;
  UINT8 *EAPOL_MIC_Key;
  BOOLEAN in_fa0;
  
  connPtr = (cm_ConnectionInfo_t *)pBufDesc->intf;
  paVar2 = cm_GetApData(connPtr);
  paVar3 = cm_GetApInfo(connPtr);
  pKeyMsg = (EAPOL_KeyMsg_t *)pBufDesc->Buffer;
  EAPOL_MIC_Key = (paVar2->staData).keyMgmtInfo.EAPOL_MIC_Key;
  KeyMgmtAp_DerivePTK((paVar3->bssConfig).RsnConfig.PSKValue,
                      (IEEEtypes_MacAddr_t *)connPtr->peerMacAddr,
                      (IEEEtypes_MacAddr_t *)(connPtr->comData).BssId,
                      (UINT8 *)&connPtr->TxRxCipherKeyBuf,pKeyMsg->key_nonce,EAPOL_MIC_Key,
                      (paVar2->staData).keyMgmtInfo.EAPOL_Encr_Key,
                      (KeyData_t *)((connPtr->TxRxCipherKeyBuf).cipher_key.ckd + 0x20),in_fa0);
  BVar4 = IsEAPOL_MICValid(pKeyMsg,EAPOL_MIC_Key);
  if (BVar4 != 0) {
    (paVar2->staData).keyMgmtInfo.numHskTries = '\0';
    rsn_len = pKeyMsg[1].hdr_8021x.protocol_ver + '\x02';
    SVar1 = GenerateApEapolMsg(connPtr,MSG3_PENDING,(BufferDesc_t *)0x0);
    return SVar1;
  }
  return FAIL;
}



BOOLEAN SendEAPOLMsgUsingBufDesc(cm_ConnectionInfo_t *connPtr,BufferDesc_t *pBufDesc)

{
  keyMgmtState_e msgState;
  bool bVar1;
  apSpecificData_t *paVar2;
  
  paVar2 = cm_GetApData(connPtr);
  msgState = (paVar2->staData).keyMgmtInfo.rom.keyMgmtState;
  bVar1 = (msgState & 1) != 0;
  if (bVar1) {
    GenerateApEapolMsg(connPtr,msgState,pBufDesc);
  }
  return (uint)bVar1;
}



// WARNING: Variable defined which should be unmapped: rxCounterLo

Status_e ProcessKeyMgmtDataAp(BufferDesc_t *pBufDesc)

{
  keyMgmtState_e kVar1;
  Status_e SVar2;
  apSpecificData_t *paVar3;
  void *pvVar4;
  uint uStack24;
  UINT32 rxCounterHi;
  UINT32 rxCounterLo;
  
  paVar3 = cm_GetApData((cm_ConnectionInfo_t *)pBufDesc->intf);
  pvVar4 = pBufDesc->Buffer;
  if ((*(byte *)((int)pvVar4 + 5) & 4) == 0) {
    memcpy(&uStack24,(void *)((int)pvVar4 + 9),4);
    memcpy(&rxCounterHi,(void *)((int)pvVar4 + 0xd),4);
    if (((paVar3->staData).keyMgmtInfo.counterHi ==
         (uStack24 >> 8 & 0xff00) +
         (uStack24 & 0xff00) * 0x100 + uStack24 * 0x1000000 + (uStack24 >> 0x18)) &&
       ((paVar3->staData).keyMgmtInfo.counterLo ==
        (rxCounterHi >> 8 & 0xff00) +
        rxCounterHi * 0x1000000 + (rxCounterHi >> 0x18) + (rxCounterHi & 0xff00) * 0x100)) {
      kVar1 = (paVar3->staData).keyMgmtInfo.rom.keyMgmtState;
      if (kVar1 == WAITING_4_MSG2) {
        SVar2 = ProcessPWKMsg2(pBufDesc);
        return SVar2;
      }
      if (kVar1 == WAITING_4_MSG4) {
        SVar2 = ProcessPWKMsg4(pBufDesc);
        return SVar2;
      }
    }
  }
  return FAIL;
}



void InitStaKeyInfo(void *pConn,SecurityMode_t *secType,Cipher_t_conflict *pwCipher,UINT16 staRsnCap
                   ,UINT8 akmType)

{
  apKeyMgmtInfoSta_t *__s;
  apSpecificData_t *paVar1;
  
  paVar1 = cm_GetApData((cm_ConnectionInfo_t *)pConn);
  __s = &(paVar1->staData).keyMgmtInfo;
  memset(__s,0,0x48);
  InitKeyMgmtInfo((apKeyMgmtInfoStaRom_t *)__s,secType,pwCipher,staRsnCap,akmType);
  (paVar1->staData).keyMgmtInfo.EAPOLProtoVersion = '\x01';
  return;
}



void RemoveAPKeyInfo(void *pConn)

{
  if (*(uint8_t *)((int)pConn + 3) != -1) {
    mm_sec_machwkey_del(*(uint8_t *)((int)pConn + 3));
    return;
  }
  return;
}



void InitGroupKey(cm_ConnectionInfo_t *connPtr)

{
  uint8_t uVar1;
  apInfo_t *paVar2;
  int iVar3;
  undefined3 extraout_var;
  UINT32 UVar4;
  
  paVar2 = cm_GetApInfo(connPtr);
  (paVar2->bssData).grpRekeyBcnCntConfigured = 0;
  (paVar2->bssData).grpRekeyBcnCntRemaining = 0;
  KeyMgmtInit(connPtr);
  UVar4 = (paVar2->bssConfig).RsnConfig.GrpReKeyTime;
  if (UVar4 != 0) {
    iVar3 = UVar4 * 0x1e848 + -0x7d;
    __udivdi3();
    (paVar2->bssData).grpRekeyBcnCntConfigured = iVar3 + 1U;
    (paVar2->bssData).grpRekeyBcnCntRemaining = iVar3 + 1U;
  }
  uVar1 = add_key_to_mac(connPtr,'\0');
  connPtr->gtkHwKeyId = uVar1;
  printf("gtkHwKeyId is %d\r\n",CONCAT31(extraout_var,uVar1));
  return;
}



// WARNING: Variable defined which should be unmapped: inp_data

void GenerateGTK_internal(KeyData_t *grpKeyData,UINT8 *nonce,IEEEtypes_Addr_t *StaMacAddr)

{
  size_t prefix_len;
  uchar auStack140 [4];
  UINT8 prefix [20];
  UINT8 GTK [32];
  UINT8 grpMasterKey [32];
  UINT8 inp_data [38];
  
  memcpy(auStack140,"Group key expansion",0x14);
  if ((grpKeyData != (KeyData_t *)0x0) && (nonce != (UINT8 *)0x0)) {
    memcpy(grpMasterKey + 0x1c,StaMacAddr,6);
    supplicantGenerateRand(nonce,0x20);
    memcpy(inp_data + 2,nonce,0x20);
    supplicantGenerateRand(GTK + 0x1c,0x20);
    prefix_len = strlen((char *)auStack140);
    Bl_PRF(GTK + 0x1c,0x20,auStack140,prefix_len,grpMasterKey + 0x1c,0x26,prefix + 0x10,0x20);
    memcpy(grpKeyData,prefix + 0x10,0x10);
    memcpy(grpKeyData->TxMICKey,GTK + 0xc,8);
    memcpy(grpKeyData->RxMICKey,GTK + 0x14,8);
  }
  return;
}



void PopulateKeyMsg(EAPOL_KeyMsg_Tx_t *tx_eapol_ptr,Cipher_t_conflict *Cipher,UINT16 Type,
                   UINT32 *replay_cnt,UINT8 *Nonce)

{
  byte bVar1;
  undefined2 in_register_00002032;
  int iVar2;
  undefined uVar3;
  byte bVar4;
  uint uVar5;
  
  uVar5 = CONCAT22(in_register_00002032,Type);
  if ((tx_eapol_ptr == (EAPOL_KeyMsg_Tx_t *)0x0) || (Cipher == (Cipher_t_conflict *)0x0)) {
    return;
  }
  if (((byte)*Cipher & 4) == 0) {
    if (((byte)*Cipher & 8) != 0) {
      *(undefined *)&(tx_eapol_ptr->keyMsg).key_length = 0;
      uVar3 = 0x10;
      goto LAB_23054a3a;
    }
  }
  else {
    *(undefined *)&(tx_eapol_ptr->keyMsg).key_length = 0;
    uVar3 = 0x20;
LAB_23054a3a:
    *(undefined *)((int)&(tx_eapol_ptr->keyMsg).key_length + 1) = uVar3;
  }
  bVar1 = *(byte *)&(tx_eapol_ptr->keyMsg).key_info.field_0x1;
  *(byte *)&(tx_eapol_ptr->keyMsg).key_info.field_0x1 = bVar1 | 0x80;
  if ((int)(uVar5 << 0x14) < 0) {
    *(byte *)&(tx_eapol_ptr->keyMsg).key_info.field_0x1 = bVar1 | 0x88;
    if ((Type & 0x80) == 0) goto LAB_23054a84;
    bVar4 = *(byte *)&(tx_eapol_ptr->keyMsg).key_info;
    *(byte *)&(tx_eapol_ptr->keyMsg).key_info.field_0x1 = bVar1 | 200;
    bVar4 = bVar4 & 0xed | 1 | (byte)((uVar5 >> 0xf) << 1);
    bVar1 = (byte)((uVar5 >> 0xf) << 4);
  }
  else {
    bVar1 = (byte)((uVar5 >> 0xf) << 4);
    bVar4 = *(byte *)&(tx_eapol_ptr->keyMsg).key_info & 0xec | 3;
  }
  *(byte *)&(tx_eapol_ptr->keyMsg).key_info = bVar1 | bVar4;
LAB_23054a84:
  uVar5 = *replay_cnt;
  iVar2 = uVar5 * 0x1000000 + (uVar5 >> 0x18) + (uVar5 & 0xff00) * 0x100 + (uVar5 >> 8 & 0xff00);
  *(char *)(tx_eapol_ptr->keyMsg).replay_cnt = (char)iVar2;
  *(undefined *)((int)(tx_eapol_ptr->keyMsg).replay_cnt + 1) = (char)((uint)iVar2 >> 8);
  *(undefined *)((int)(tx_eapol_ptr->keyMsg).replay_cnt + 2) = (char)((uint)iVar2 >> 0x10);
  *(undefined *)((int)(tx_eapol_ptr->keyMsg).replay_cnt + 3) = (char)((uint)iVar2 >> 0x18);
  uVar5 = replay_cnt[1];
  iVar2 = uVar5 * 0x1000000 + (uVar5 >> 0x18) + (uVar5 & 0xff00) * 0x100 + (uVar5 >> 8 & 0xff00);
  *(char *)((tx_eapol_ptr->keyMsg).replay_cnt + 1) = (char)iVar2;
  *(undefined *)((int)(tx_eapol_ptr->keyMsg).replay_cnt + 5) = (char)((uint)iVar2 >> 8);
  *(undefined *)((int)(tx_eapol_ptr->keyMsg).replay_cnt + 6) = (char)((uint)iVar2 >> 0x10);
  *(undefined *)((int)(tx_eapol_ptr->keyMsg).replay_cnt + 7) = (char)((uint)iVar2 >> 0x18);
  memcpy((tx_eapol_ptr->keyMsg).key_nonce,Nonce,0x20);
  return;
}



void prepareKDE(EAPOL_KeyMsg_Tx_t *tx_eapol_ptr,KeyData_t *grKey,Cipher_t_conflict *cipher)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  UINT8 *pUVar4;
  UINT8 *__dest;
  
  if (tx_eapol_ptr != (EAPOL_KeyMsg_Tx_t *)0x0) {
    if ((grKey != (KeyData_t *)0x0) && (cipher != (Cipher_t_conflict *)0x0)) {
      pUVar4 = (tx_eapol_ptr->keyMsg).key_data + *(byte *)&(tx_eapol_ptr->keyMsg).key_material_len;
      *pUVar4 = -0x23;
      pUVar4[1] = '\x16';
      pUVar4[2] = '\0';
      pUVar4[3] = '\x0f';
      pUVar4[4] = -0x54;
      pUVar4[5] = '\x01';
      pUVar4[6] = pUVar4[6] & 0xfc | 1;
      memcpy(pUVar4 + 8,grKey,0x10);
      __dest = pUVar4 + 0x18;
      if (((byte)*cipher & 4) != 0) {
        pUVar4[1] = pUVar4[1] + '\x10';
        memcpy(__dest,grKey->TxMICKey,8);
        memcpy(pUVar4 + 0x20,grKey->RxMICKey,8);
        __dest = pUVar4 + 0x28;
      }
      uVar1 = (uint)(tx_eapol_ptr->keyMsg).key_material_len + 2 + (uint)pUVar4[1];
      uVar2 = uVar1 & 0xffff;
      *(char *)&(tx_eapol_ptr->keyMsg).key_material_len = (char)(uVar1 * 0x10000 >> 0x10);
      *(undefined *)((int)&(tx_eapol_ptr->keyMsg).key_material_len + 1) = (char)(uVar2 >> 8);
      uVar1 = -uVar2 & 7;
      if (uVar1 != 0) {
        *__dest = -0x23;
        memset(__dest + 1,0,uVar1 - 1);
        iVar3 = uVar1 + (tx_eapol_ptr->keyMsg).key_material_len;
        *(char *)&(tx_eapol_ptr->keyMsg).key_material_len = (char)((uint)(iVar3 * 0x10000) >> 0x10);
        *(undefined *)((int)&(tx_eapol_ptr->keyMsg).key_material_len + 1) = (char)((uint)iVar3 >> 8)
        ;
      }
    }
    return;
  }
  return;
}



BOOLEAN Encrypt_keyData(EAPOL_KeyMsg_Tx_t *tx_eapol_ptr,UINT8 *EAPOL_Encr_Key,
                       Cipher_t_conflict *cipher)

{
  void *pv;
  UINT8 *cipher_00;
  uint uVar1;
  uint __n;
  UINT8 *plain;
  UINT8 aUStack48 [4];
  UINT8 key [16];
  
  if (((tx_eapol_ptr != (EAPOL_KeyMsg_Tx_t *)0x0) && (EAPOL_Encr_Key != (UINT8 *)0x0)) &&
     (cipher != (Cipher_t_conflict *)0x0)) {
    if (((byte)*cipher & 8) == 0) {
      return (uint)((byte)*cipher >> 2) & 1;
    }
    pv = pvPortMalloc(0xc);
    if (pv != (void *)0x0) {
      cipher_00 = (UINT8 *)pvPortMalloc(400);
      *(UINT8 **)((int)pv + 8) = cipher_00;
      if (cipher_00 != (UINT8 *)0x0) {
        memcpy(aUStack48,EAPOL_Encr_Key,0x10);
        plain = (tx_eapol_ptr->keyMsg).key_data;
        BL_AesWrap(aUStack48,'\x02',(uint)((tx_eapol_ptr->keyMsg).key_material_len >> 3),plain,
                   (UINT8 *)0x0,cipher_00);
        uVar1 = (uint)(tx_eapol_ptr->keyMsg).key_material_len + 8;
        __n = uVar1 & 0xffff;
        *(char *)&(tx_eapol_ptr->keyMsg).key_material_len = (char)(uVar1 * 0x10000 >> 0x10);
        *(undefined *)((int)&(tx_eapol_ptr->keyMsg).key_material_len + 1) = (char)(__n >> 8);
        memcpy(plain,cipher_00,__n);
        vPortFree(*(void **)((int)pv + 8));
        vPortFree(pv);
        return 1;
      }
    }
    return 0;
  }
  return 0;
}



void KeyMgmtAp_DerivePTK(UINT8 *pPMK,IEEEtypes_MacAddr_t *da,IEEEtypes_MacAddr_t *sa,UINT8 *ANonce,
                        UINT8 *SNonce,UINT8 *EAPOL_MIC_Key,UINT8 *EAPOL_Encr_Key,KeyData_t *newPWKey
                        ,BOOLEAN use_kdf)

{
  undefined auStack24 [4];
  UINT8 tmp [8];
  
  KeyMgmtSta_DeriveKeys(pPMK,da,sa,ANonce,SNonce,EAPOL_MIC_Key,EAPOL_Encr_Key,newPWKey,use_kdf);
  memcpy(auStack24,newPWKey->RxMICKey,8);
  memcpy(newPWKey->RxMICKey,newPWKey->TxMICKey,8);
  memcpy(newPWKey->TxMICKey,auStack24,8);
  return;
}



BOOLEAN KeyData_CopyWPAWP2(EAPOL_KeyMsg_Tx_t *pTxEAPOL,void *pIe)

{
  size_t __n;
  
  if (pIe != (void *)0x0) {
    __n = (uint)*(byte *)((int)pIe + 1) + 2;
    *(char *)&(pTxEAPOL->keyMsg).key_material_len = (char)__n;
    *(undefined *)((int)&(pTxEAPOL->keyMsg).key_material_len + 1) = (char)(__n >> 8);
    memcpy((pTxEAPOL->keyMsg).key_data,pIe,__n);
    return 1;
  }
  return 0;
}



BOOLEAN KeyData_UpdateKeyMaterial
                  (EAPOL_KeyMsg_Tx_t *pTxEAPOL,SecurityMode_t *pSecType,void *pWPA,void *pWPA2)

{
  BOOLEAN BVar1;
  uint uVar2;
  
  if (((*(byte *)pSecType & 0x18) != 0) ||
     (uVar2 = 1, pWPA = pWPA2, (*(byte *)pSecType & 0x20) != 0)) {
    BVar1 = KeyData_CopyWPAWP2(pTxEAPOL,pWPA);
    uVar2 = (uint)(BVar1 != 0);
  }
  return uVar2;
}



void ROM_InitGTK(KeyData_t *grpKeyData,UINT8 *nonce,IEEEtypes_Addr_t *StaMacAddr)

{
  grpKeyData->TxIV32 = 0;
  *(undefined4 *)&grpKeyData->TxIV16 = 0x10001;
  GenerateGTK_internal(grpKeyData,nonce,StaMacAddr);
  return;
}



void InitKeyMgmtInfo(apKeyMgmtInfoStaRom_t *pKeyMgmtInfo,SecurityMode_t *secType,
                    Cipher_t_conflict *pwCipher,UINT16 staRsnCap,UINT8 akmType)

{
  pKeyMgmtInfo->keyMgmtState = MSG1_PENDING;
  memcpy(&pKeyMgmtInfo->staSecType,secType,2);
  memcpy(&pKeyMgmtInfo->staUcstCipher,pwCipher,1);
  pKeyMgmtInfo->staAkmType = akmType;
  if ((*(byte *)secType & 0x20) != 0) {
    pKeyMgmtInfo->staRsnCap = staRsnCap;
  }
  return;
}



apInfo_t * cm_GetApInfo(cm_ConnectionInfo_t *connPtr)

{
  if (connPtr != (cm_ConnectionInfo_t *)0x0) {
    if (connPtr->conType == '\x02') {
      return *(apInfo_t **)connPtr->specDat;
    }
    connPtr = (cm_ConnectionInfo_t *)0x0;
  }
  return (apInfo_t *)connPtr;
}



apSpecificData_t * cm_GetApData(cm_ConnectionInfo_t *connPtr)

{
  if (connPtr != (cm_ConnectionInfo_t *)0x0) {
    if (connPtr->conType == '\x02') {
      return (apSpecificData_t *)connPtr->specDat;
    }
    connPtr = (cm_ConnectionInfo_t *)0x0;
  }
  return (apSpecificData_t *)connPtr;
}



Status_e cm_AllocAPResources(cm_ConnectionInfo_t *connPtr)

{
  apSpecificData_t *paVar1;
  BufferDesc_t *pBVar2;
  void *pvVar3;
  
  paVar1 = cm_GetApData(connPtr);
  if (paVar1->apInfoBuffDesc == (BufferDesc_t *)0x0) {
    pBVar2 = (BufferDesc_t *)pvPortMalloc(0xc);
    if (pBVar2 == (BufferDesc_t *)0x0) {
      return FAIL;
    }
    pvVar3 = pvPortMalloc(0x120);
    pBVar2->Buffer = pvVar3;
    paVar1->apInfoBuffDesc = pBVar2;
    paVar1->apInfo = (apInfo_t *)pBVar2->Buffer;
    InitializeAp(connPtr);
  }
  return FW_SUCCESS;
}



Status_e cm_AllocResources(cm_ConnectionInfo_t *connPtr)

{
  Status_e SVar1;
  
  if (connPtr->conType == '\x02') {
    SVar1 = cm_AllocAPResources(connPtr);
    return SVar1;
  }
  return FW_SUCCESS;
}



cm_ConnectionInfo_t *
cm_InitConnection(UINT8 conType,UINT8 bssType,UINT8 bssNum,IEEEtypes_MacAddr_t *bssId,
                 IEEEtypes_MacAddr_t *peerMacAddr,UINT8 channel,unkbyte0 *hostMdev)

{
  cm_ConnectionInfo_t *connPtr;
  Status_e SVar1;
  undefined3 extraout_var;
  IEEEtypes_Addr_t *__s;
  
  connPtr = (cm_ConnectionInfo_t *)pvPortMalloc(0xec);
  if (connPtr != (cm_ConnectionInfo_t *)0x0) {
    memset(connPtr,0,0xec);
    connPtr->conType = conType;
    SVar1 = cm_AllocResources(connPtr);
    if (CONCAT31(extraout_var,SVar1) == 1) {
      vPortFree(connPtr);
      connPtr = (cm_ConnectionInfo_t *)0x0;
    }
    else {
      if (peerMacAddr != (IEEEtypes_MacAddr_t *)0x0) {
        memcpy(connPtr->peerMacAddr,peerMacAddr,6);
      }
      __s = (connPtr->comData).BssId;
      memset(__s,0,6);
      memset(&connPtr->comData,0,0x20);
      (connPtr->comData).SsIdLen = '\0';
      if (bssId != (IEEEtypes_MacAddr_t *)0x0) {
        memcpy(__s,bssId,6);
        memcpy(connPtr->localMacAddr,bssId,6);
      }
    }
  }
  return connPtr;
}



void cm_DeleteConnection(cm_ConnectionInfo_t *connPtr)

{
  apSpecificData_t *paVar1;
  
  if (connPtr->conType == '\x02') {
    paVar1 = cm_GetApData(connPtr);
    if (paVar1->apInfoBuffDesc != (BufferDesc_t *)0x0) {
      vPortFree(paVar1->apInfoBuffDesc->Buffer);
      vPortFree(paVar1->apInfoBuffDesc);
      paVar1->apInfoBuffDesc = (BufferDesc_t *)0x0;
      paVar1->apInfo = (apInfo_t *)0x0;
    }
  }
  vPortFree(connPtr);
  return;
}



void cm_SetPeerAddr(cm_ConnectionInfo_t *connPtr,IEEEtypes_MacAddr_t *bssId,
                   IEEEtypes_MacAddr_t *peerMacAddr)

{
  if (bssId != (IEEEtypes_MacAddr_t *)0x0) {
    memcpy((connPtr->comData).BssId,bssId,6);
  }
  if (peerMacAddr != (IEEEtypes_MacAddr_t *)0x0) {
    memcpy(connPtr->peerMacAddr,peerMacAddr,6);
    return;
  }
  return;
}



void cm_SetComData(cm_ConnectionInfo_t *connPtr,char *ssid)

{
  byte bVar1;
  size_t sVar2;
  
  if (ssid != (char *)0x0) {
    sVar2 = strlen(ssid);
    (connPtr->comData).SsIdLen = (IEEEtypes_Len_t)sVar2;
    memcpy(&connPtr->comData,ssid,0x20);
    bVar1 = (connPtr->comData).SsIdLen;
    if (bVar1 < 0x20) {
      (connPtr->comData).SsId[bVar1] = '\0';
    }
    return;
  }
  return;
}


/*
Unable to decompile 'assert_rec'
Cause: Exception while decompiling 23054fb4: Decompiler process died

*/


void assert_err(char *condition,char *file,int line)

{
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void assert_warn(char *condition,char *file,int line)

{
  return;
}



void coex_wifi_rf_forece_enable(int enable)

{
  if (enable != 0) {
    enable = 1;
  }
  rfc_coex_force_to(enable,0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void coex_wifi_pti_forece_enable(int enable)

{
  if (enable == 0) {
    _DAT_44b00400 = _DAT_44b00400 & 0xffffffef;
  }
  else {
    _DAT_44b00400 = _DAT_44b00400 | 0xf0000010;
  }
  if ((int)(_DAT_44b00400 << 4) < 0) {
    _DAT_44b00400 = _DAT_44b00400 & 0xfbffffff;
  }
  else {
    _DAT_44b00400 = _DAT_44b00400 & 0xfbffffff | 0x4000000;
  }
  return;
}


/*
Unable to decompile 'coex_wifi_pta_forece_enable'
Cause: Exception while decompiling 23055054: Decompiler process died

*/


// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void wifi_main(void)

{
  int iVar1;
  uint uVar2;
  
  rfc_init(40000000);
  _DAT_44b00400 = _DAT_44b00400 | 1;
  mpif_clk_init();
  sysctrl_init();
  intc_init();
  ipc_emb_init();
  bl_init();
  _DAT_44b00404 = 0x24f037;
  _DAT_44b00400 = 0x49;
  _DAT_44920004 = 0x5010001f;
  do {
    if (_DAT_44b00120 << 0xc < 0) {
      _DAT_44900084 = _DAT_44900084 | 1;
    }
    else {
      _DAT_44900084 = _DAT_44900084 & 0xfffffffe;
    }
    if (ke_env.evt_field == 0) {
      ipc_emb_wait();
    }
    if ((packets_num_12624 & 0xf) == 0) {
      uVar2 = _DAT_40007018 >> 0x18 & 7;
      if (uVar2 != 0) {
        if (uVar2 != 3) {
          _DAT_40000014 = _DAT_40000014 | 0x40000;
        }
        if ((uVar2 != 0) && (uVar2 != 3)) {
          _DAT_40002040 = _DAT_40002040 & 0xfffffffc;
          _DAT_40002044 = _DAT_40002044 & 0xfffffffe;
        }
      }
      if ((_DAT_40007018 >> 0x18 & 4) != 0) {
        _DAT_40000014 = _DAT_40000014 | 0x5c2000;
        _DAT_4000f90c = _DAT_4000f90c & 0xfffffffe | 4;
      }
    }
    packets_num_12624 = packets_num_12624 + 1;
    ke_evt_schedule();
    iVar1 = bl_sleep();
    coex_wifi_pta_forece_enable((uint)(iVar1 == 0));
  } while( true );
}



void ipc_emb_notify(void)

{
  BaseType_t BStack20;
  BaseType_t xHigherPriorityTaskWoken;
  
  if (xTaskToNotify == (TaskHandle_t)0x0) {
    assert_err("NULL != xTaskToNotify","module",0x93);
  }
  if (TrapNetCounter == 0) {
    xTaskGenericNotify(xTaskToNotify,0,eIncrement,(uint32_t *)0x0);
  }
  else {
    vTaskNotifyGiveFromISR(xTaskToNotify,&BStack20);
    if (BStack20 != 0) {
      vTaskSwitchContext();
    }
  }
  return;
}



void ipc_emb_wait(void)

{
  ulTaskNotifyTake(1,0xffffffff);
  ipc_emb_counter = ipc_emb_counter + 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_emb_init(void)

{
  xTaskToNotify = xTaskGetCurrentTaskHandle();
  memset(&ipc_emb_env,0,0x20);
  ipc_emb_env.txdesc = (txdesc_host *)ipc_shared_env.txdesc0;
  if (_DAT_44800140 != 0x49504332) {
    assert_err("ipc_emb_signature_get() == IPC_EMB_SIGNATURE_RESET","module",0xbb);
  }
  _DAT_4480010c = 0x1f03;
  _DAT_44800114 = 0x3ff2a04;
  _DAT_44800118 = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_emb_tx_irq(void)

{
  uint uVar1;
  
  uVar1 = _DAT_4480011c & 0x1f00;
  if (uVar1 != 0) {
    ke_evt_set(uVar1 >> 1);
    _DAT_44800108 = uVar1;
    _DAT_44800110 = uVar1;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_emb_tx_evt(int queue_idx)

{
  txdesc_host *ptVar1;
  txdesc_host *ptVar2;
  hostdesc *phVar3;
  hostdesc *phVar4;
  uint event;
  hostdesc *__s;
  
  event = ipc_emb_evt_bit[queue_idx];
  ke_evt_clear(event);
  ptVar1 = ipc_emb_env.txdesc;
  while( true ) {
    ptVar2 = ptVar1 + (ipc_emb_env.txdesc_idx & 3);
    if (ptVar2->ready != 0xffffffff) {
      _DAT_4480010c = 0x100;
      return;
    }
    if (((event & 0x800) == 0) && ((ke_env.evt_field & 0x440800) != 0)) break;
    __s = (hostdesc *)ptVar2->pad_txdesc;
    _DAT_44800108 = 0x100;
    memset(__s,0,0x2cc);
    *(uint32_t **)(ptVar2->pad_txdesc + 0x1c) = ptVar2->pad_txdesc + 0x2e;
    *(uint32_t **)(ptVar2->pad_txdesc + 0x1b) = ptVar2->pad_txdesc + 0x1c;
    phVar3 = &ptVar2->host;
    do {
      phVar4 = (hostdesc *)&phVar3->packet_addr;
      phVar3[1].packet_addr = phVar3->pbuf_addr;
      phVar3 = phVar4;
    } while (__s != phVar4);
    ptVar2->pad_txdesc[0x19] = 0;
    *(undefined4 *)(*(int *)ptVar2->pad_txdesc[0x1b] + 0x10) = 0;
    ptVar2->pad_txdesc[0x27] = 0;
    ptVar2->pad_txdesc[0x28] = 0;
    ptVar2->pad_txdesc[0x29] = 0;
    ptVar2->pad_txdesc[0x15] = 0;
    txu_cntrl_push(__s,0);
    ptVar2->ready = 1;
    ipc_emb_env.txdesc_idx = ipc_emb_env.txdesc_idx + 1;
  }
  ke_evt_set(event);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_emb_cfmback_irq(void)

{
  uint uVar1;
  
  uVar1 = _DAT_4480011c;
  if ((_DAT_4480011c & 0x20) != 0) {
    _DAT_44800110 = 0x20;
    _DAT_44800108 = 0x20;
    ke_evt_set(0x40000);
  }
  if ((uVar1 & 0x10) != 0) {
    _DAT_44800110 = 0x10;
    _DAT_44800108 = 0x10;
    ke_evt_set(0x80000);
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_emb_txcfm_ind(uint32_t queue_bits)

{
  _DAT_44800100 = queue_bits << 7;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_emb_msg_irq(void)

{
  if ((_DAT_4480011c & 2) != 0) {
    ke_evt_set(0x2000000);
    _DAT_44800110 = 2;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_emb_msg_evt(void)

{
  undefined4 *puVar1;
  uint8_t uVar2;
  undefined4 *puVar3;
  undefined4 *puVar4;
  int iVar5;
  
  do {
    if ((_DAT_44800104 & 2) == 0) {
      ke_evt_clear(0x2000000);
      _DAT_4480010c = 2;
      return;
    }
    _DAT_44800108 = 2;
    puVar1 = (undefined4 *)ke_malloc((uint)ipc_shared_env.msg_a2e_buf.msg[1]._2_2_ + 0xc);
    if (puVar1 == (undefined4 *)0x0) {
      assert_err("kmsg_dst != NULL","module",0x1d9);
    }
    *puVar1 = 0;
    *(undefined2 *)(puVar1 + 1) = (undefined2)ipc_shared_env.msg_a2e_buf.msg[0];
    *(undefined2 *)((int)puVar1 + 6) = ipc_shared_env.msg_a2e_buf.msg[0]._2_2_;
    *(undefined2 *)(puVar1 + 2) = 0xd;
    *(ushort *)((int)puVar1 + 10) = ipc_shared_env.msg_a2e_buf.msg[1]._2_2_;
    iVar5 = 0xc;
    while (iVar5 + -0xc < (int)(uint)*(ushort *)((int)puVar1 + 10)) {
      puVar3 = (undefined4 *)((int)&ipc_shared_env.msg_a2e_buf.dummy_word + iVar5);
      puVar4 = (undefined4 *)((int)puVar1 + iVar5);
      iVar5 = iVar5 + 4;
      *puVar4 = *puVar3;
    }
    uVar2 = ipc_emb_env.ipc_msgacke2a_cnt + '\x01';
    ipc_shared_env.msg_a2e_buf.msg[1]._0_2_ = (ushort)ipc_emb_env.ipc_msgacke2a_cnt;
    ipc_emb_env.ipc_msgacke2a_cnt = uVar2;
    if (*(ushort *)((int)puVar1 + 6) < 0xf) {
      if (0xc < *(ushort *)((int)puVar1 + 6)) goto LAB_230556b8;
    }
    else {
      assert_err("id <= TASK_MAX","module",0xb6);
LAB_230556b8:
      assert_err("ke_task_local(kmsg_dst->dest_id)","module",0x1ed);
    }
    _DAT_44800100 = 4;
    ke_msg_send(puVar1 + 3);
  } while( true );
}



void ipc_emb_msg_dma_int_handler(void)

{
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_emb_dbg_dma_int_handler(void)

{
  _DAT_44800100 = 1;
  _DAT_44a00020 = 0x80;
  return;
}



void ipc_emb_dump(void)

{
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mdm_txcbwmax_setf(uint8_t txcbwmax)

{
  if ((txcbwmax & 0xfc) != 0) {
    assert_err("(((uint32_t)txcbwmax << 24) & ~((uint32_t)0x03000000)) == 0","module",0xb58);
  }
  _DAT_44c00824 = _DAT_44c00824 & 0xfcffffff | (uint)txcbwmax << 0x18;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void phy_config_rxgain(int offset)

{
  if ((int)rxgain_offset_vs_temperature != offset) {
    rxgain_offset_vs_temperature = (int8_t)offset;
    _DAT_44c0c080 =
         ((int)rxgain_offset_vs_temperature + 0x19) * 0x1000000 |
         ((int)rxgain_offset_vs_temperature + 0x12) * 0x10000 & 0xff0000U |
         ((int)rxgain_offset_vs_temperature + 0xb) * 0x100 & 0xffffU |
         (int)rxgain_offset_vs_temperature + 3U & 0xff;
    _DAT_44c0c084 =
         ((int)rxgain_offset_vs_temperature + 0x35) * 0x1000000 |
         ((int)rxgain_offset_vs_temperature + 0x2d) * 0x10000 & 0xff0000U |
         ((int)rxgain_offset_vs_temperature + 0x27) * 0x100 & 0xffffU |
         (int)rxgain_offset_vs_temperature + 0x20U & 0xff;
    _DAT_44c0c088 = (int)rxgain_offset_vs_temperature + 0x3bU & 0xff | _DAT_44c0c088 & 0xffffff00;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void agc_config(void)

{
  _DAT_44c0b390 = _DAT_44c0b390 & 0xfffefbff;
  _DAT_44c0b3a4 = _DAT_44c0b3a4 & 0xffff0000;
  _DAT_44c0b394 = _DAT_44c0b394 & 0xff00ffff | 0xf80000;
  _DAT_44c0b398 = _DAT_44c0b398 & 0xffff00ff | 0x9e00;
  _DAT_44c0b3c4 = _DAT_44c0b3c4 & 0xffffff00 | 0xce;
  _DAT_44c0b364 = _DAT_44c0b364 & 0xe0c0c0c0 | 0x83c3839;
  _DAT_44c0b368 = _DAT_44c0b368 & 0xffc00c00 | 0x70070;
  _DAT_44c0b36c = _DAT_44c0b36c & 0xf800f800 | 0x7280512;
  _DAT_44c0b370 = _DAT_44c0b370 & 0xff80ffff | 0x580000;
  _DAT_44c0b3c0 = _DAT_44c0b3c0 & 0xffffff | 0x18000000;
  _DAT_44c0b380 = _DAT_44c0b380 & 0x3ff | 0x77f8400;
  _DAT_44c0b384 = _DAT_44c0b384 & 0x3ff | 0xe7750800;
  _DAT_44c0b388 = _DAT_44c0b388 & 0x3ff | 0x3d7a9400;
  _DAT_44c0b38c = _DAT_44c0b38c & 0x23ff | 0x64038800;
  _DAT_44c0c830 = _DAT_44c0c830 & 0x23ff | 0xfc1d9400;
  _DAT_44c0c814 = _DAT_44c0c814 & 0xffffffc0 | 8;
  _DAT_44c0c040 = _DAT_44c0c040 & 0xfe007fff | 0xc18000;
  _DAT_44c0c044 = _DAT_44c0c044 & 0xffff0000 | 0x800;
  phy_config_rxgain(0);
  _DAT_44c0b3a0 = _DAT_44c0b3a0 & 0xffffff00 | 0x9e;
  _DAT_44c0b3c0 = _DAT_44c0b3c0 & 0xffff0000 | 0xa3a4;
  _DAT_44c0c82c = _DAT_44c0c82c & 0xff007700 | 0x2009b5;
  _DAT_44c0c838 = _DAT_44c0c838 & 0x7ff80000 | 0x80000100;
  _DAT_44c0c83c = _DAT_44c0c83c & 0x7ff00000 | 0x8000017c;
  _DAT_44c0c840 = _DAT_44c0c840 & 0x7fc00000 | 0x80000100;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mdm_reset(void)

{
  _DAT_44c00888 = 0;
  return;
}



void phy_powroffset_set(int8_t *power_offset)

{
  int8_t *piVar1;
  int8_t *piVar2;
  int iVar3;
  
  iVar3 = 0;
  do {
    piVar1 = power_offset + iVar3;
    piVar2 = poweroffset + iVar3;
    iVar3 = iVar3 + 1;
    *piVar2 = *piVar1;
  } while (iVar3 != 0xe);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void phy_hw_set_channel(uint8_t band,uint16_t freq,uint16_t freq1,uint8_t chantype)

{
  uint8_t channel;
  undefined3 in_register_00002029;
  int iVar1;
  undefined2 in_register_0000202e;
  int iVar2;
  undefined3 in_register_00002035;
  
  iVar2 = CONCAT22(in_register_0000202e,freq);
  iVar1 = CONCAT31(in_register_00002029,band);
  if (CONCAT31(in_register_00002035,chantype) != 0) {
    assert_err("chantype == PHY_CHNL_BW_20","module",0x144);
  }
  if (iVar1 != 0) {
    assert_err("band == PHY_BAND_2G4","module",0x145);
  }
  _DAT_44c0b390 = _DAT_44c0b390 & 0xfffffeff;
  _DAT_44c00820 = _DAT_44c00820 | 1;
  _DAT_44c00800 = 0;
  mdm_reset();
  _DAT_44c00838 = 0xb4;
  _DAT_44c0088c = 0x1c13;
  _DAT_44c00898 = 0x2d00438;
  _DAT_44c00858 = _DAT_44c00858 & 0xffffff00;
  _DAT_44c0081c = 0xf07;
  _DAT_44c00834 = _DAT_44c00834 & 0xffffff | 0x6000000;
  _DAT_44c00818 = 0x1880c06;
  _DAT_44c00860 = 0x7f03;
  _DAT_44c0b340 = 0;
  _DAT_44c0b344 = 0;
  _DAT_44c0b348 = 0;
  mdm_txcbwmax_setf(chantype);
  if (_DAT_44c0b000 << 10 < 0) {
    _DAT_44c0b118 = 1;
  }
  rf_set_channel(chantype,freq1);
  if (iVar1 == 0) {
    channel = '\0';
    if ((0x48 < (iVar2 - 0x96cU & 0xffff)) || (channel = '\x0e', iVar2 == 0x9b4)) goto LAB_23055e36;
    iVar1 = -0x967;
  }
  else {
    channel = '\0';
    if ((iVar1 != 1) || (channel = '\0', 0x334 < (iVar2 - 0x138dU & 0xffff))) goto LAB_23055e36;
    iVar1 = -5000;
  }
  channel = (uint8_t)((iVar2 + iVar1) / 5);
LAB_23055e36:
  rfc_apply_tx_power_offset(channel,poweroffset);
  trpc_update_vs_channel((int8_t)freq1);
  return;
}



void phy_get_channel(phy_channel_info *info,uint8_t index)

{
  info->info1 = (uint)phy_env[0].chnl_type << 8 | (uint)phy_env[0].chnl_prim20_freq << 0x10 |
                (uint)phy_env[0].band;
  info->info2 = phy_env[0]._6_4_;
  return;
}



void phy_set_channel(uint8_t band,uint8_t type,uint16_t prim20_freq,uint16_t center1_freq,
                    uint16_t center2_freq,uint8_t index)

{
  undefined3 in_register_00002029;
  
  if ((((ushort)(center1_freq - 0x96c) < 0x49) || (CONCAT31(in_register_00002029,band) != 0)) &&
     (CONCAT31(in_register_00002029,band) < 2)) {
    phy_hw_set_channel(band,prim20_freq,center1_freq,type);
    phy_env[0].chnl_prim20_freq = prim20_freq;
    phy_env[0].chnl_center1_freq = center1_freq;
    phy_env[0].band = band;
    phy_env[0].chnl_type = type;
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void phy_get_version(uint32_t *version_1,uint32_t *version_2)

{
  *version_1 = _DAT_44c00000;
  *version_2 = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

_Bool phy_vht_supported(void)

{
  byte bVar1;
  
  bVar1 = 1;
  if (-1 < _DAT_44c00000 << 9) {
    bVar1 = (byte)((uint)_DAT_44c00000 >> 0x19) & 1;
  }
  return (_Bool)bVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void phy_init(phy_cfg_tag *config)

{
  uint uVar1;
  _Bool _Var2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  uint32_t uVar3;
  uint32_t *puVar4;
  uint32_t *puVar5;
  uint32_t *puVar6;
  
  _DAT_44c00800 = 0;
  mdm_reset();
  _DAT_44c00820 = 0x20d;
  uVar1 = ((_DAT_44c00000 >> 8 & 0xf) - 1 & 0xff) << 4;
  if ((uVar1 & 0xffffff8f) != 0) {
    assert_err("(((uint32_t)rxnssmax << 4) & ~((uint32_t)0x00000070)) == 0","module",0xa09);
  }
  _DAT_44c00820 = uVar1 | _DAT_44c00820 & 0xffffff8f;
  uVar1 = ((_DAT_44c00000 >> 0xc & 0xf) - 1 & 0xff) << 0xc;
  if ((uVar1 & 0xf8000) != 0) {
    assert_err("(((uint32_t)rxndpnstsmax << 12) & ~((uint32_t)0x00007000)) == 0","module",0x987);
  }
  _DAT_44c00820 = _DAT_44c00000 >> 0x13 & 0x100 | uVar1 | _DAT_44c00820 & 0xffff8eff;
  _Var2 = phy_vht_supported();
  _DAT_44c00820 =
       (_DAT_44c00000 >> 0x1e & 1) << 0x14 |
       (_DAT_44c00000 >> 0x1e & 1) << 0x10 |
       (CONCAT31(extraout_var,_Var2) << 1 | _DAT_44c00820 & 0xfffffffd) & 0xffeeffff;
  _DAT_44c03024 = _DAT_44c03024 & 0xffc0ffff | 0x2d0000;
  _DAT_44c0089c = 0xffffffff;
  _DAT_44c00824 = 0x20d;
  uVar1 = ((_DAT_44c00000 >> 8 & 0xf) - 1 & 0xff) << 4;
  if ((uVar1 & 0xffffff8f) != 0) {
    assert_err("(((uint32_t)txnssmax << 4) & ~((uint32_t)0x00000070)) == 0","module",0xc0e);
  }
  _DAT_44c00824 = uVar1 | _DAT_44c00824 & 0xffffff8f;
  uVar1 = ((_DAT_44c00000 >> 4 & 0xf) - 1 & 0xff) << 0x14;
  if ((uVar1 & 0xf800000) != 0) {
    assert_err("(((uint32_t)ntxmax << 20) & ~((uint32_t)0x00700000)) == 0","module",0xb72);
  }
  _DAT_44c00824 = uVar1 | _DAT_44c00824 & 0xff8fffff;
  mdm_txcbwmax_setf((byte)(_DAT_44c00000 >> 0x18) & 3);
  _DAT_44c00824 = _DAT_44c00000 >> 0x12 & 0x100 | _DAT_44c00824 & 0xfffffeff;
  _Var2 = phy_vht_supported();
  _DAT_44c00824 =
       (_DAT_44c00000 >> 0x1f) << 0x10 |
       (CONCAT31(extraout_var_00,_Var2) << 1 | _DAT_44c00824 & 0xfffffffd) & 0xfffeffff;
  _DAT_44c00834 = _DAT_44c00834 | 1;
  _DAT_44c00818 = _DAT_44c00818 & 0xfffbffff;
  _DAT_44c00830 = _DAT_44c00830 & 0xffff0000 | 0x1b0f;
  _DAT_44c0083c = 0x4920492;
  _DAT_44c00874 = _DAT_44c00874 & 0xf7ffffff | 0x8000000;
  _DAT_44c0b500 = _DAT_44c0b500 & 0xffffcfff | 0x2000;
  if (_DAT_44c0b000 << 10 < 0) {
    _DAT_44c0b110 = _DAT_44c0b110 & 0xfffffff0;
    _DAT_44c0b118 = 0;
  }
  _DAT_44c0b004 = 1;
  _DAT_44c0b390 = _DAT_44c0b390 & 0xfffffffc | 1;
  _DAT_44c0b3bc = 4000000;
  _DAT_44c0b414 = _DAT_44c0b414 | 0x100;
  agc_config();
  _DAT_44c0b390 = _DAT_44c0b390 & 0xffffefff | 0x1000;
  _DAT_44c00874 = _DAT_44c00874 & 0xdfffffff | 0x20000000;
  puVar6 = agcmem;
  puVar4 = (uint32_t *)&DAT_54c0a000;
  do {
    uVar3 = *puVar6;
    puVar5 = puVar4 + 1;
    puVar6 = puVar6 + 1;
    *puVar4 = uVar3;
    puVar4 = puVar5;
  } while (puVar5 != (uint32_t *)0x54c0a800);
  _DAT_44c00874 = _DAT_44c00874 & 0xdfffffff;
  _DAT_44c0b390 = _DAT_44c0b390 & 0xffffefff;
  _DAT_44c0c020 = _DAT_44c0c020 & 0xfc00ffff | 0x140000;
  phy_env[0].cfg = config->parameters[0];
  phy_env[0]._4_4_ = 0xff00ff;
  phy_env[0]._8_4_ = 0x50000ff;
  trpc_init();
  pa_init();
  phy_tcal_reset();
  phy_tcal_start();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t phy_get_nss(void)

{
  return (uint8_t)(((byte)((uint)_DAT_44c00000 >> 8) & 0xf) - 1);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t phy_get_ntx(void)

{
  return (uint8_t)(((byte)(_DAT_44c00000 >> 4) & 0xf) - 1);
}



void phy_stop(void)

{
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

_Bool phy_ldpc_tx_supported(void)

{
  return (_Bool)((byte)((uint)_DAT_44c00000 >> 0x1a) & 1);
}



uint8_t phy_get_mac_freq(void)

{
  return '(';
}



void phy_get_rf_gain_idx(int8_t *power,uint8_t *idx)

{
  uint32_t uVar1;
  
  uVar1 = rfc_get_power_level(2,(int)*power * 10);
  *idx = (uint8_t)uVar1;
  return;
}



void phy_get_rf_gain_capab(int8_t *max,int8_t *min)

{
  int8_t iVar1;
  
  iVar1 = trpc_get_rf_max_power();
  *max = iVar1;
  iVar1 = trpc_get_rf_min_power();
  *min = iVar1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void bz_phy_reset(void)

{
  _DAT_40002808 = _DAT_40002808 & 0x7fffff | 0x8800000;
  _DAT_4000280c = _DAT_4000280c & 0x7fff00 | 0x4800000;
  _DAT_40002810 = _DAT_40002810 & 0xfffffffe | 2;
  _DAT_40002854 = 0x1e0a201e;
  _DAT_40002cac = _DAT_40002cac & 0xffffffe0 | 4;
  return;
}



void mpif_clk_init(void)

{
  return;
}



void phy_mdm_isr(void)

{
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void phy_rc_isr(void)

{
  _DAT_44c0b420 = _DAT_44c0b41c;
  if ((_DAT_44c0b41c & 0x100) != 0) {
    mdm_reset();
    return;
  }
  _DAT_44c0b420 = _DAT_44c0b41c;
  return;
}



void pa_init(void)

{
  int iVar1;
  pa_state_t *ppVar2;
  pa_state_t *ppVar3;
  
  ppVar3 = pa_env;
  do {
    ppVar3->rss_state = '\0';
    ppVar3->rss_count = 0;
    ppVar3->last_update = 0;
    ppVar3->input_buffer_ptr = '\0';
    ppVar3->ce_state = '\0';
    ppVar3->ce = 0.00000000;
    ppVar3->ce_num_up_cmds = '\0';
    ppVar3->ce_num_dn_cmds = '\0';
    iVar1 = 8;
    ppVar2 = ppVar3;
    do {
      ppVar2->input_buffer[0].new = '\0';
      ppVar2->input_buffer[0].rssi = '\0';
      ppVar2->input_buffer[0].lna = '\0';
      ppVar2->input_buffer[0].ppm = 0.00000000;
      iVar1 = iVar1 + -1;
      ppVar2 = (pa_state_t *)&ppVar2->input_buffer[0].ppm;
    } while (iVar1 != 0);
    ppVar3 = ppVar3 + 1;
  } while (ppVar3 != (pa_state_t *)&tcal_env);
  return;
}



// WARNING: Control flow encountered bad instruction data

void pa_input(uint8_t id,rx_hd *rhd)

{
  undefined3 in_register_00002029;
  uint uVar1;
  int iVar2;
  
  uVar1 = CONCAT31(in_register_00002029,id);
  if (uVar1 < 4) {
    iVar2 = (int)pa_env[uVar1].input_buffer_ptr;
    pa_env[uVar1].last_update = rhd->tsflo;
    pa_env[uVar1].input_buffer[iVar2].new = '\x01';
    pa_env[uVar1].input_buffer[iVar2].rssi = *(int8_t *)((int)&rhd->recvec1c + 3);
    pa_env[uVar1].input_buffer[iVar2].lna = (char)((int)(rhd->recvec1d << 0x14) >> 0x1c);
    if (((rhd->recvec1b & 0x70000) == 0) && ((rhd->recvec1a >> 0xc & 0xf) < 4)) {
      __floatsidf((int)*(char *)((int)&rhd->recvec2a + 3));
      __muldf3();
    }
    else {
      __floatsidf(-(int)*(short *)((int)&rhd->recvec2a + 3));
      __muldf3();
      __divdf3();
    }
    __truncdfsf2();
                    // WARNING: Bad instruction - Truncating control flow here
    halt_baddata();
  }
  return;
}


/*
Unable to decompile 'pa_adapt'
Cause: Exception while decompiling 23056596: Decompiler process died

*/


// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t hal_get_capcode(void)

{
  return (uint8_t)((byte)(_DAT_4000f884 >> 0x16) & 0x3f);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void hal_set_capcode(uint32_t capcode)

{
  _DAT_4000f884 = capcode << 0x10 | capcode << 0x16 | _DAT_4000f884 & 0xf000ffff;
  return;
}



_Bool hal_get_temperature(int16_t *temperature)

{
  *temperature = hal_env.temperature;
  return true;
}



void hal_set_temperature(int16_t temperature)

{
  hal_env.temperature = temperature;
  return;
}



void trpc_update_power(int8_t (*power_rate_table) [8])

{
  int iVar1;
  int iVar2;
  int iVar3;
  int8_t *piVar4;
  int8_t *piVar5;
  
  piVar4 = txpwr_vs_rate_table;
  iVar2 = 0;
  do {
    iVar3 = 0;
    do {
      iVar1 = iVar3 + iVar2;
      piVar5 = piVar4 + iVar3;
      iVar3 = iVar3 + 1;
      *piVar5 = (*power_rate_table)[iVar1];
    } while (iVar3 != 8);
    iVar2 = iVar2 + 8;
    piVar4 = piVar4 + 8;
  } while (iVar2 != 0x18);
  return;
}



void trpc_power_get(int8_t *power_rate_table)

{
  memcpy(power_rate_table,txpwr_vs_rate_table,0x18);
  return;
}



void trpc_update_power_11b(int8_t *power_rate_table)

{
  int8_t *piVar1;
  int8_t *piVar2;
  int iVar3;
  
  iVar3 = 0;
  do {
    piVar1 = power_rate_table + iVar3;
    piVar2 = txpwr_vs_rate_table + iVar3;
    iVar3 = iVar3 + 1;
    *piVar2 = *piVar1;
  } while (iVar3 != 4);
  return;
}



void trpc_update_power_11g(int8_t *power_rate_table)

{
  int8_t *piVar1;
  int iVar2;
  int8_t *piVar3;
  
  iVar2 = 0;
  piVar3 = txpwr_vs_rate_table;
  do {
    piVar1 = power_rate_table + iVar2;
    iVar2 = iVar2 + 1;
    piVar3[8] = *piVar1;
    piVar3 = piVar3 + 1;
  } while (iVar2 != 8);
  return;
}



void trpc_update_power_11n(int8_t *power_rate_table)

{
  int8_t *piVar1;
  int iVar2;
  int8_t *piVar3;
  
  iVar2 = 0;
  piVar3 = txpwr_vs_rate_table;
  do {
    piVar1 = power_rate_table + iVar2;
    iVar2 = iVar2 + 1;
    piVar3[0x10] = *piVar1;
    piVar3 = piVar3 + 1;
  } while (iVar2 != 8);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void trpc_init(void)

{
  int32_t iVar1;
  
  DAT_4201e240 = 0x98a;
  iVar1 = rf_pri_get_txgain_max();
  trpc_env = (undefined)iVar1;
  iVar1 = rf_pri_get_txgain_min();
  pwr_dbm_bottom = (int8_t)iVar1;
  DAT_4201e23e = 0x1e;
  _DAT_4201e242 = 0x19;
  return;
}



int8_t trpc_get_rf_max_power(void)

{
  return trpc_env;
}



int8_t trpc_get_rf_min_power(void)

{
  return pwr_dbm_bottom;
}



uint8_t trpc_get_power_idx(uint8_t formatmod,uint8_t mcs,int8_t pwr_dbm)

{
  int8_t pwr_dbm_bottom;
  undefined3 in_register_00002029;
  uint uVar1;
  undefined3 in_register_0000202d;
  int iVar2;
  undefined3 in_register_00002031;
  char cVar3;
  uint uVar4;
  char cVar5;
  int iVar6;
  
  uVar1 = CONCAT31(in_register_00002029,formatmod);
  uVar4 = 2;
  if (uVar1 < 3) {
    uVar4 = (uint)formatmod;
  }
  iVar6 = 3;
  if (uVar1 != 0) {
    iVar6 = 7;
  }
  cVar5 = DAT_4201e23e;
  if ((int)trpc_env < (int)DAT_4201e23e) {
    cVar5 = trpc_env;
  }
  if (CONCAT31(in_register_00002031,pwr_dbm) < (int)cVar5) {
    cVar5 = pwr_dbm;
  }
  iVar2 = CONCAT31(in_register_0000202d,mcs);
  if (iVar6 < CONCAT31(in_register_0000202d,mcs)) {
    iVar2 = iVar6;
  }
  cVar3 = txpwr_vs_rate_table[iVar2 + uVar4 * 8];
  if (cVar5 < txpwr_vs_rate_table[iVar2 + uVar4 * 8]) {
    cVar3 = cVar5;
  }
  if (pwr_dbm_bottom < cVar3) {
    pwr_dbm_bottom = cVar3;
  }
  __floatsidf(((int)pwr_dbm_bottom * -0x1fe + (int)trpc_env) / 0x200);
  __adddf3();
  uVar4 = __fixdfsi();
  iVar6 = 3;
  if (uVar1 != 0) {
    iVar6 = 0;
  }
  uVar4 = iVar6 + (uVar4 & 0xff) & 0xff;
  if (0xf < uVar4) {
    uVar4 = 0xf;
  }
  return (uint8_t)(uVar4 << 2);
}



uint8_t trpc_get_default_power_idx(uint8_t formatmod,uint8_t mcs)

{
  uint8_t uVar1;
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  int iVar2;
  uint uVar3;
  int iVar4;
  
  uVar3 = (uint)formatmod;
  if (2 < CONCAT31(in_register_00002029,formatmod)) {
    uVar3 = 2;
  }
  iVar4 = 3;
  if (CONCAT31(in_register_00002029,formatmod) != 0) {
    iVar4 = 7;
  }
  iVar2 = CONCAT31(in_register_0000202d,mcs);
  if (iVar4 < CONCAT31(in_register_0000202d,mcs)) {
    iVar2 = iVar4;
  }
  uVar1 = trpc_get_power_idx((uint8_t)uVar3,(uint8_t)iVar2,txpwr_vs_rate_table[iVar2 + uVar3 * 8]);
  return uVar1;
}



void trpc_update_vs_channel(int8_t channel_MHz)

{
  undefined3 in_register_00002029;
  int32_t iVar1;
  
  DAT_4201e240 = (undefined2)CONCAT31(in_register_00002029,channel_MHz);
  iVar1 = rf_pri_get_txgain_max();
  trpc_env = (undefined)iVar1;
  iVar1 = rf_pri_get_txgain_min();
  pwr_dbm_bottom = (int8_t)iVar1;
  return;
}



void trpc_update_vs_temperature(int8_t temperature)

{
  int32_t iVar1;
  
  DAT_4201e242 = temperature;
  iVar1 = rf_pri_get_txgain_max();
  trpc_env = (undefined)iVar1;
  iVar1 = rf_pri_get_txgain_min();
  pwr_dbm_bottom = (int8_t)iVar1;
  return;
}



void phy_tcal_reset(void)

{
  memset(&tcal_env,0,0x38);
  tcal_env.prev_temperature = 0x19;
  tcal_env.last_action_temperature[0] = 0x19;
  tcal_env.last_action_temperature[1] = 0x19;
  tcal_env.last_action_temperature[2] = 0x19;
  tcal_env.last_action_temperature[3] = 0x19;
  tcal_env.enabled = true;
  return;
}



void phy_tcal_start(void)

{
  tcal_env.enabled = true;
  return;
}



void phy_tcal_txpwr(int16_t curr_temperature)

{
  undefined2 in_register_0000202a;
  
  rf_pri_tx_gain_comp(CONCAT22(in_register_0000202a,curr_temperature));
  trpc_update_vs_temperature((int8_t)curr_temperature);
  return;
}


/*
Unable to decompile 'phy_tcal_handle'
Cause: Exception while decompiling 23056b44: Decompiler process died

*/


void phy_tcal_callback(int16_t temperature)

{
  hal_set_temperature(temperature);
  if (tcal_env.enabled != false) {
    phy_tcal_handle();
    return;
  }
  return;
}



int bl60x_check_mac_status(int *is_ok)

{
  int iVar1;
  dump_data_t *pdVar2;
  
  iVar1 = 0;
  pdVar2 = dump_data_poll;
  while( true ) {
    if ((int)(uint)dump_data_ptr <= iVar1) {
      *is_ok = 0;
      return 0;
    }
    if (pdVar2->mac_debugRegHWSM2 != 0x8801e000) break;
    iVar1 = iVar1 + 1;
    pdVar2 = pdVar2 + 1;
  }
  *is_ok = 1;
  return 0;
}



void helper_record_dump(void)

{
  uint32_t *puVar1;
  dump_data_t *pdVar2;
  int iVar3;
  
  pdVar2 = dump_data_poll;
  puts("========= helper_record_dump\r\n");
  iVar3 = 0;
  while (iVar3 < (int)(uint)dump_data_ptr) {
    printf("[%d] time %ld, func %s\r\n",iVar3,pdVar2->time,pdVar2->func_name);
    printf("MAC: %08lx: rxControlCs %d,txControlCs %d,macControlCs %d\r\n",pdVar2->mac_debugRegHWSM2
           ,pdVar2->mac_debugRegHWSM2 & 0x3f,pdVar2->mac_debugRegHWSM2 >> 8 & 0x1ff,
           (uint)*(byte *)((int)&pdVar2->mac_debugRegHWSM2 + 3));
    iVar3 = iVar3 + 1;
    printf("MAC: Coex %04x,Backoff %04x,MPIF %04x,MPIF2 %04x\r\n",(uint)pdVar2->mac_debugPortCoex,
           (uint)pdVar2->mac_debugPortBackoff,(uint)pdVar2->mac_debugPortMacPhyIf,
           (uint)pdVar2->mac_debugPortMacPhyIf2);
    printf("PHY: MainFSM %04x,TDTX %04x,DSSSCCK1 %04x,DSSSCCKTx %04x\r\n",
           (uint)pdVar2->phy_debugPortMainFSM,(uint)pdVar2->phy_debugPortTDTX,
           (uint)pdVar2->phy_debugPortDSSSCCK1,(uint)pdVar2->phy_debugPortDSSSCCKTx);
    puVar1 = &pdVar2->rf_state;
    pdVar2 = pdVar2 + 1;
    printf("RFC: RC %s, RF %s\r\n",rf_state_str[*puVar1]);
  }
  printf("\r\n\r\n");
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void helper_record_rc_rf_states(uint *param_1,uint *param_2)

{
  uint uVar1;
  
  _DAT_40001220 = _DAT_40001220 & 0xfffffff | 0x20000000;
  uVar1 = _DAT_40001224 >> 0x19;
  *param_1 = _DAT_40001224 >> 0x1c & 7;
  *param_2 = uVar1 & 7;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void helper_record_all_states(char *func_name)

{
  uint32_t uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  
  uVar1 = _DAT_44b00120;
  uVar4 = (uint)dump_data_ptr;
  dump_data_poll[uVar4].func_name = func_name;
  dump_data_poll[uVar4].time = uVar1;
  helper_record_rc_rf_states(uVar4 * 0x28 + 0x42016704,uVar4 * 0x28 + 0x42016708);
  dump_data_poll[uVar4].mac_debugRegHWSM1 = _DAT_44b00500;
  dump_data_poll[uVar4].mac_debugRegHWSM2 = _DAT_44b00504;
  _DAT_44b00510 = _DAT_44b00510 & 0xffff0000 | 0x31;
  *(undefined4 *)&dump_data_poll[uVar4].mac_debugPortCoex = _DAT_44b0050c;
  _DAT_44b00510 = _DAT_44b00510 & 0xffff0000 | 0x2f0b;
  *(undefined4 *)&dump_data_poll[uVar4].mac_debugPortMacPhyIf = _DAT_44b0050c;
  _DAT_44900068 = _DAT_44900068 & 0xffff0000 | 0x14;
  _DAT_400000d0 = 4;
  _DAT_400000d4 = 0x40000004;
  _DAT_400000d8 = 0x80000004;
  _DAT_400000dc = 0xc0000004;
  uVar2 = _DAT_400000e0 & 0xfffffffe;
  uVar3 = _DAT_400000e0 >> 1;
  _DAT_400000e0 = uVar2;
  dump_data_poll[uVar4].phy_debugPortTDTX = (uint16_t)uVar3;
  dump_data_poll[uVar4].phy_debugPortMainFSM = (ushort)(uVar2 >> 0x11);
  _DAT_44900074 = 0xb09;
  uVar2 = _DAT_400000e0 & 0xfffffffe;
  uVar3 = _DAT_400000e0 >> 1;
  _DAT_400000e0 = uVar2;
  dump_data_poll[uVar4].phy_debugPortDSSSCCK1 = (uint16_t)uVar3;
  dump_data_poll[uVar4].phy_debugPortDSSSCCKTx = (ushort)(uVar2 >> 0x11);
  dump_data_ptr = dump_data_ptr + 1 & 0xf;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_fsm_ctrl_en_setf(uint32_t x)

{
  _DAT_40001004 = x << 1 | _DAT_40001004 & 0xfffffffd;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_gc_tbb_setf(uint32_t x)

{
  _DAT_40001048 = (x & 0x1f) << 0x14 | _DAT_40001048 & 0xfe0fffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_gc_tmx_setf(uint32_t x)

{
  _DAT_40001048 = (x & 7) << 0x10 | _DAT_40001048 & 0xfff8ffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pa_ib_fix_setf(uint32_t x)

{
  _DAT_40001064 = x << 0x10 | _DAT_40001064 & 0xfffeffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pa_vbcas_setf(uint32_t x)

{
  _DAT_40001064 = x << 0xc | _DAT_40001064 & 0xffff8fff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pa_vbcore_setf(uint32_t x)

{
  _DAT_40001064 = x << 8 | _DAT_40001064 & 0xfffff0ff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tmx_cs_setf(uint32_t x)

{
  _DAT_4000106c = x | _DAT_4000106c & 0xfffffff8;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_fsm_st_dbg_en_setf(uint32_t x)

{
  _DAT_4000126c = x << 3 | _DAT_4000126c & 0xfffffff7;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc3_setf(uint32_t x)

{
  _DAT_40001630 = (x & 0x7f) << 0x18 | _DAT_40001630 & 0x80ffffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc2_setf(uint32_t x)

{
  _DAT_40001630 = (x & 0x7f) << 0x10 | _DAT_40001630 & 0xff80ffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc1_setf(uint32_t x)

{
  _DAT_40001630 = (x & 0x7f) << 8 | _DAT_40001630 & 0xffff80ff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc0_setf(uint32_t x)

{
  _DAT_40001630 = x & 0x7f | _DAT_40001630 & 0xffffff80;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc7_setf(uint32_t x)

{
  _DAT_40001634 = (x & 0x7f) << 0x18 | _DAT_40001634 & 0x80ffffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc6_setf(uint32_t x)

{
  _DAT_40001634 = (x & 0x7f) << 0x10 | _DAT_40001634 & 0xff80ffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc5_setf(uint32_t x)

{
  _DAT_40001634 = (x & 0x7f) << 8 | _DAT_40001634 & 0xffff80ff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc4_setf(uint32_t x)

{
  _DAT_40001634 = x & 0x7f | _DAT_40001634 & 0xffffff80;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc11_setf(uint32_t x)

{
  _DAT_40001638 = (x & 0x7f) << 0x18 | _DAT_40001638 & 0x80ffffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc10_setf(uint32_t x)

{
  _DAT_40001638 = (x & 0x7f) << 0x10 | _DAT_40001638 & 0xff80ffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc9_setf(uint32_t x)

{
  _DAT_40001638 = (x & 0x7f) << 8 | _DAT_40001638 & 0xffff80ff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc8_setf(uint32_t x)

{
  _DAT_40001638 = x & 0x7f | _DAT_40001638 & 0xffffff80;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc15_setf(uint32_t x)

{
  _DAT_4000163c = (x & 0x7f) << 0x18 | _DAT_4000163c & 0x80ffffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc14_setf(uint32_t x)

{
  _DAT_4000163c = (x & 0x7f) << 0x10 | _DAT_4000163c & 0xff80ffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc13_setf(uint32_t x)

{
  _DAT_4000163c = (x & 0x7f) << 8 | _DAT_4000163c & 0xffff80ff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc12_setf(uint32_t x)

{
  _DAT_4000163c = x & 0x7f | _DAT_4000163c & 0xffffff80;
  return;
}



void wait_us(uint32_t us)

{
  bool bVar1;
  uint32_t n;
  int iStack4;
  
  iStack4 = us << 4;
  do {
    bVar1 = iStack4 != 0;
    iStack4 = iStack4 + -1;
  } while (bVar1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pa_etb_en_setf(void)

{
  _DAT_40001064 = _DAT_40001064 & 0xfffffff7;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pa_half_on_setf(void)

{
  _DAT_40001064 = _DAT_40001064 & 0xffff7fff | 0x8000;
  return;
}



void _print_channel_info(void)

{
  int iVar1;
  
  iVar1 = 8;
  do {
    iVar1 = iVar1 + -1;
    wait_us(1000);
  } while (iVar1 != 0);
  iVar1 = 8;
  do {
    iVar1 = iVar1 + -1;
    wait_us(1000);
  } while (iVar1 != 0);
  return;
}



// WARNING: Control flow encountered bad instruction data

void rfc_init(uint32_t xtalfreq_hz)

{
  uint32_t rfg_index;
  uint32_t dg;
  
                    // WARNING: Bad instruction - Truncating control flow here
  halt_baddata();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rfc_rxdfe_set_notch0(uint8_t en,uint8_t alpha,int8_t nrmfc)

{
  _DAT_40001700 =
       ((uint)en & 1) << 6 | (uint)(byte)nrmfc << 8 | (uint)alpha & 7 | _DAT_40001700 & 0xffff00b8;
  return;
}



// WARNING: Variable defined which should be unmapped: ncf_freq_hz
// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rfc_config_channel(uint32_t channel_freq)

{
  SItype SVar1;
  uint8_t uStack21;
  uint8_t ncf_on;
  SItype SStack20;
  int32_t ncf_freq_hz;
  
  _DAT_40001228 = _DAT_40001228 | 8;
  _DAT_4000100c = _DAT_4000100c | 0x241;
  _DAT_40001264 = channel_freq & 0xfff | _DAT_40001264 & 0xfffff000;
  _DAT_40001268 = _DAT_40001268 & 0xfffdffff | 0x20000;
  wait_us(10);
  _DAT_40001268 = _DAT_40001268 & 0xfffdffff;
  wait_us(10);
  rf_fsm_ctrl_en_setf(0);
  wait_us(10);
  rf_fsm_ctrl_en_setf(1);
  wait_us(10);
  _DAT_4000126c = _DAT_4000126c & 0xfffffff8 | 1;
  wait_us(10);
  rf_fsm_st_dbg_en_setf(1);
  wait_us(10);
  _DAT_4000126c = _DAT_4000126c & 0xfffffff8 | 2;
  wait_us(100);
  rf_fsm_st_dbg_en_setf(0);
  wait_us(10);
  _print_channel_info();
  rf_pri_update_param(channel_freq);
  rf_pri_get_notch_param(channel_freq,&uStack21,(int32_t *)&stack0xffffffec);
  __floatsidf(SStack20);
  __divdf3();
  __muldf3();
  __adddf3();
  SVar1 = __fixdfsi();
  rfc_rxdfe_set_notch0(uStack21,'\x01',(int8_t)SVar1);
  _DAT_40001228 = _DAT_40001228 & 0xfffffff7;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rfc_coex_force_to(uint32_t force_enable,uint32_t bbmode)

{
  rf_fsm_ctrl_en_setf(0);
  wait_us(10);
  _DAT_40001220 =
       (uint)(force_enable != 0) << 0x1b | (bbmode & 1) << 0x1a | _DAT_40001220 & 0xf3ffffff;
  wait_us(10);
  rf_fsm_ctrl_en_setf(1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

_Bool rfc_config_power_ble(int32_t pwr_dbm)

{
  int iVar1;
  uint uVar2;
  
  if ((uint)pwr_dbm < 0x10) {
    if (pwr_dbm < 4) {
      rf_pa_ib_fix_setf(1);
      rf_pa_half_on_setf();
      rf_pa_vbcas_setf(4);
      rf_pa_vbcore_setf(9);
      rf_pa_etb_en_setf();
      rf_tmx_cs_setf(5);
      rf_gc_tbb_setf(2);
      rf_gc_tmx_setf(5);
      iVar1 = pwr_dbm * 4 + -0x12;
    }
    else {
      if (pwr_dbm < 7) {
        rf_pa_ib_fix_setf(1);
        rf_pa_half_on_setf();
        rf_pa_vbcas_setf(4);
        rf_pa_vbcore_setf(9);
        rf_pa_etb_en_setf();
        rf_tmx_cs_setf(5);
        rf_gc_tbb_setf(2);
        rf_gc_tmx_setf(7);
        iVar1 = pwr_dbm * 4 + -0x1e;
      }
      else {
        if (pwr_dbm < 10) {
          rf_pa_ib_fix_setf(1);
          rf_pa_half_on_setf();
          rf_pa_vbcas_setf(4);
          rf_pa_vbcore_setf(9);
          rf_pa_etb_en_setf();
          rf_tmx_cs_setf(5);
          rf_gc_tbb_setf(3);
          rf_gc_tmx_setf(7);
          iVar1 = pwr_dbm + -10;
        }
        else {
          if (pwr_dbm < 0xc) {
            rf_pa_ib_fix_setf(1);
            rf_pa_half_on_setf();
            rf_pa_vbcas_setf(4);
            rf_pa_vbcore_setf(9);
            rf_pa_etb_en_setf();
            rf_tmx_cs_setf(5);
            rf_gc_tbb_setf(4);
            rf_gc_tmx_setf(7);
            iVar1 = pwr_dbm + -0xc;
          }
          else {
            rf_pa_ib_fix_setf(1);
            rf_pa_half_on_setf();
            rf_pa_vbcas_setf(4);
            rf_pa_vbcore_setf(9);
            rf_pa_etb_en_setf();
            rf_tmx_cs_setf(5);
            rf_gc_tbb_setf(6);
            rf_gc_tmx_setf(7);
            iVar1 = pwr_dbm + -0xf;
          }
        }
        iVar1 = iVar1 << 2;
      }
    }
    uVar2 = iVar1 - 1;
    _DAT_40001648 =
         uVar2 * 0x10000 & 0x7f0000 |
         uVar2 * 0x100 & 0x7f00 | uVar2 & 0x7f | _DAT_40001648 & 0xff808080;
    return true;
  }
  return false;
}



uint32_t rfc_get_power_level(uint32_t formatmod,int32_t power)

{
  uint32_t mode;
  
  mode = 0;
  if ((formatmod != 0) && (mode = 1, formatmod != 1)) {
    mode = 2;
  }
  mode = rf_pri_get_txgain_index(power,mode);
  return mode << 2;
}



void rfc_apply_tx_dvga(int8_t *dvga_qdb)

{
  rf_tx_dvga_gain_qdb_gc0_setf((int)*dvga_qdb);
  rf_tx_dvga_gain_qdb_gc1_setf((int)dvga_qdb[1]);
  rf_tx_dvga_gain_qdb_gc2_setf((int)dvga_qdb[2]);
  rf_tx_dvga_gain_qdb_gc3_setf((int)dvga_qdb[3]);
  rf_tx_dvga_gain_qdb_gc4_setf((int)dvga_qdb[4]);
  rf_tx_dvga_gain_qdb_gc5_setf((int)dvga_qdb[5]);
  rf_tx_dvga_gain_qdb_gc6_setf((int)dvga_qdb[6]);
  rf_tx_dvga_gain_qdb_gc7_setf((int)dvga_qdb[7]);
  rf_tx_dvga_gain_qdb_gc8_setf((int)dvga_qdb[8]);
  rf_tx_dvga_gain_qdb_gc9_setf((int)dvga_qdb[9]);
  rf_tx_dvga_gain_qdb_gc10_setf((int)dvga_qdb[10]);
  rf_tx_dvga_gain_qdb_gc11_setf((int)dvga_qdb[0xb]);
  rf_tx_dvga_gain_qdb_gc12_setf((int)dvga_qdb[0xc]);
  rf_tx_dvga_gain_qdb_gc13_setf((int)dvga_qdb[0xd]);
  rf_tx_dvga_gain_qdb_gc14_setf((int)dvga_qdb[0xe]);
  rf_tx_dvga_gain_qdb_gc15_setf((int)dvga_qdb[0xf]);
  return;
}



// WARNING: Variable defined which should be unmapped: dg
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rfc_apply_tx_power_offset(uint8_t channel,int8_t *power_offset)

{
  uint32_t uStack56;
  uint32_t rfg_index;
  uint32_t dg;
  
  rf_pri_update_tx_power_offset(channel,power_offset);
  rf_pri_query_txgain_table(0,&uStack56,&rfg_index);
  _DAT_40001640 = uStack56 & 7 | _DAT_40001640 & 0xfffffff8;
  rf_tx_dvga_gain_qdb_gc0_setf(rfg_index);
  rf_pri_query_txgain_table(1,&uStack56,&rfg_index);
  _DAT_40001640 = (uStack56 & 7) << 4 | _DAT_40001640 & 0xffffff8f;
  rf_tx_dvga_gain_qdb_gc1_setf(rfg_index);
  rf_pri_query_txgain_table(2,&uStack56,&rfg_index);
  _DAT_40001640 = (uStack56 & 7) << 8 | _DAT_40001640 & 0xfffff8ff;
  rf_tx_dvga_gain_qdb_gc2_setf(rfg_index);
  rf_pri_query_txgain_table(3,&uStack56,&rfg_index);
  _DAT_40001640 = (uStack56 & 7) << 0xc | _DAT_40001640 & 0xffff8fff;
  rf_tx_dvga_gain_qdb_gc3_setf(rfg_index);
  rf_pri_query_txgain_table(4,&uStack56,&rfg_index);
  _DAT_40001640 = (uStack56 & 7) << 0x10 | _DAT_40001640 & 0xfff8ffff;
  rf_tx_dvga_gain_qdb_gc4_setf(rfg_index);
  rf_pri_query_txgain_table(5,&uStack56,&rfg_index);
  _DAT_40001640 = (uStack56 & 7) << 0x14 | _DAT_40001640 & 0xff8fffff;
  rf_tx_dvga_gain_qdb_gc5_setf(rfg_index);
  rf_pri_query_txgain_table(6,&uStack56,&rfg_index);
  _DAT_40001640 = (uStack56 & 7) << 0x18 | _DAT_40001640 & 0xf8ffffff;
  rf_tx_dvga_gain_qdb_gc6_setf(rfg_index);
  rf_pri_query_txgain_table(7,&uStack56,&rfg_index);
  _DAT_40001640 = (uStack56 & 7) << 0x1c | _DAT_40001640 & 0x8fffffff;
  rf_tx_dvga_gain_qdb_gc7_setf(rfg_index);
  rf_pri_query_txgain_table(8,&uStack56,&rfg_index);
  _DAT_40001644 = uStack56 & 7 | _DAT_40001644 & 0xfffffff8;
  rf_tx_dvga_gain_qdb_gc8_setf(rfg_index);
  rf_pri_query_txgain_table(9,&uStack56,&rfg_index);
  _DAT_40001644 = (uStack56 & 7) << 4 | _DAT_40001644 & 0xffffff8f;
  rf_tx_dvga_gain_qdb_gc9_setf(rfg_index);
  rf_pri_query_txgain_table(10,&uStack56,&rfg_index);
  _DAT_40001644 = (uStack56 & 7) << 8 | _DAT_40001644 & 0xfffff8ff;
  rf_tx_dvga_gain_qdb_gc10_setf(rfg_index);
  rf_pri_query_txgain_table(0xb,&uStack56,&rfg_index);
  _DAT_40001644 = (uStack56 & 7) << 0xc | _DAT_40001644 & 0xffff8fff;
  rf_tx_dvga_gain_qdb_gc11_setf(rfg_index);
  rf_pri_query_txgain_table(0xc,&uStack56,&rfg_index);
  _DAT_40001644 = (uStack56 & 7) << 0x10 | _DAT_40001644 & 0xfff8ffff;
  rf_tx_dvga_gain_qdb_gc12_setf(rfg_index);
  rf_pri_query_txgain_table(0xd,&uStack56,&rfg_index);
  _DAT_40001644 = (uStack56 & 7) << 0x14 | _DAT_40001644 & 0xff8fffff;
  rf_tx_dvga_gain_qdb_gc13_setf(rfg_index);
  rf_pri_query_txgain_table(0xe,&uStack56,&rfg_index);
  _DAT_40001644 = (uStack56 & 7) << 0x18 | _DAT_40001644 & 0xf8ffffff;
  rf_tx_dvga_gain_qdb_gc14_setf(rfg_index);
  rf_pri_query_txgain_table(0xf,&uStack56,&rfg_index);
  _DAT_40001644 = (uStack56 & 7) << 0x1c | _DAT_40001644 & 0x8fffffff;
  rf_tx_dvga_gain_qdb_gc15_setf(rfg_index);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_set_gain_table_regs(void)

{
  _DAT_40001118 =
       ((tx_pwr_table[12][2] << 0x18 |
        (tx_pwr_table[12][3] << 0x10 |
        (tx_pwr_table[14][0] << 0xe |
        (tx_pwr_table[14][1] << 0xc |
        (tx_pwr_table[14][2] << 8 | (_DAT_40001118 & 0xffffffe0 | tx_pwr_table[14][3]) & 0xfffff8ff)
        & 0xffffcfff) & 0xffff3fff) & 0xffe0ffff) & 0xf8ffffff) & 0xcfffffff |
       tx_pwr_table[12][1] << 0x1c) & 0x3fffffff | tx_pwr_table[12][0] << 0x1e;
  _DAT_4000111c =
       (tx_pwr_table[8][1] << 0x1c |
       (tx_pwr_table[8][2] << 0x18 |
       (tx_pwr_table[8][3] << 0x10 |
       (tx_pwr_table[10][0] << 0xe |
       (tx_pwr_table[10][1] << 0xc |
       (tx_pwr_table[10][2] << 8 | (_DAT_4000111c & 0xffffffe0 | tx_pwr_table[10][3]) & 0xfffff8ff)
       & 0xffffcfff) & 0xffff3fff) & 0xffe0ffff) & 0xf8ffffff) & 0xcfffffff) & 0x3fffffff |
       tx_pwr_table[8][0] << 0x1e;
  _DAT_40001120 =
       tx_pwr_table[4][0] << 0x1e |
       (tx_pwr_table[4][1] << 0x1c |
       (tx_pwr_table[4][2] << 0x18 |
       (tx_pwr_table[4][3] << 0x10 |
       (tx_pwr_table[6][0] << 0xe |
       (tx_pwr_table[6][1] << 0xc |
       (tx_pwr_table[6][2] << 8 | (_DAT_40001120 & 0xffffffe0 | tx_pwr_table[6][3]) & 0xfffff8ff) &
       0xffffcfff) & 0xffff3fff) & 0xffe0ffff) & 0xf8ffffff) & 0xcfffffff) & 0x3fffffff;
  _DAT_40001124 =
       (tx_pwr_table[0][1] << 0x1c |
       ((tx_pwr_table[0][3] << 0x10 |
        (tx_pwr_table[2][0] << 0xe |
        ((tx_pwr_table[2][2] << 8 | (_DAT_40001124 & 0xffffffe0 | tx_pwr_table[2][3]) & 0xfffff8ff)
         & 0xffffcfff | tx_pwr_table[2][1] << 0xc) & 0xffff3fff) & 0xffe0ffff) & 0xf8ffffff |
       tx_pwr_table[0][2] << 0x18) & 0xcfffffff) & 0x3fffffff | tx_pwr_table[0][0] << 0x1e;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_manu_pu(uint32_t mode)

{
  int iVar1;
  uint uVar2;
  
  if (mode == 5) {
    _DAT_40001030 = _DAT_40001030 & 0xcefff8ff;
    iVar1 = -0x39009000;
  }
  else {
    if (5 < mode) {
      if (7 < mode) goto LAB_23058062;
      _DAT_40001030 = _DAT_40001030 & 0x8f090ff;
      uVar2 = 0xf00000;
      goto LAB_23058096;
    }
    if (mode != 4) {
LAB_23058062:
      _DAT_40001004 = _DAT_40001004 & 0xfffffffd;
      _DAT_4000100c = 0;
      _DAT_40001030 = _DAT_40001030 & 0x2df0feff | 0x25f06e00;
      return;
    }
    _DAT_40001030 = _DAT_40001030 & 0x2cf8f8ff;
    iVar1 = 0x24f87000;
  }
  uVar2 = iVar1 - 0x800;
LAB_23058096:
  _DAT_40001004 = _DAT_40001004 & 0xfffffffd;
  _DAT_4000100c = 0;
  _DAT_40001030 = _DAT_40001030 | uVar2;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_save_state_for_cal(void)

{
  state_adda1 = _DAT_4000108c;
  state_dfe_ctrl_0 = _DAT_40001600;
  state_dfe_ctrl_3 = _DAT_4000160c;
  state_dfe_ctrl_6 = _DAT_40001618;
  state_dfe_ctrl_7 = _DAT_4000161c;
  state_fbdv = _DAT_400010b8;
  state_pa1 = _DAT_40001064;
  state_pucr1 = _DAT_40001030;
  state_rbb3 = _DAT_40001084;
  state_rf_fsm_ctrl_hw = _DAT_40001004;
  state_rf_resv_reg_1 = _DAT_400010f0;
  state_rfcal_ctrlen = _DAT_4000101c;
  state_rfctrl_hw_en = _DAT_4000100c;
  state_rfif_dfe_ctrl0 = _DAT_40001220;
  state_sdm1 = _DAT_400010c0;
  state_sdm2 = _DAT_400010c4;
  state_singen_ctrl0 = _DAT_4000120c;
  state_singen_ctrl2 = _DAT_40001214;
  state_singen_ctrl3 = _DAT_40001218;
  state_sram_ctrl0 = _DAT_4000123c;
  state_sram_ctrl1 = _DAT_40001240;
  state_sram_ctrl2 = _DAT_40001244;
  state_tbb = _DAT_40001070;
  state_ten_ac = _DAT_40001058;
  state_trx_gain1 = _DAT_40001048;
  state_vco2 = _DAT_400010a4;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_restore_state_for_cal(void)

{
  _DAT_40001004 = state_rf_fsm_ctrl_hw;
  _DAT_4000100c = state_rfctrl_hw_en;
  _DAT_4000101c = state_rfcal_ctrlen;
  _DAT_40001030 = state_pucr1;
  _DAT_40001048 = state_trx_gain1;
  _DAT_40001058 = state_ten_ac;
  _DAT_40001064 = state_pa1;
  _DAT_40001070 = state_tbb;
  _DAT_40001084 = state_rbb3;
  _DAT_4000108c = state_adda1;
  _DAT_400010a4 = state_vco2;
  _DAT_400010b8 = state_fbdv;
  _DAT_400010c0 = state_sdm1;
  _DAT_400010c4 = state_sdm2;
  _DAT_400010f0 = state_rf_resv_reg_1;
  _DAT_4000120c = state_singen_ctrl0;
  _DAT_40001214 = state_singen_ctrl2;
  _DAT_40001218 = state_singen_ctrl3;
  _DAT_40001220 = state_rfif_dfe_ctrl0;
  _DAT_4000123c = state_sram_ctrl0;
  _DAT_40001240 = state_sram_ctrl1;
  _DAT_40001244 = state_sram_ctrl2;
  _DAT_40001600 = state_dfe_ctrl_0;
  _DAT_4000160c = state_dfe_ctrl_3;
  _DAT_40001618 = state_dfe_ctrl_6;
  _DAT_4000161c = state_dfe_ctrl_7;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_singen_start(void)

{
  _DAT_4000120c = _DAT_4000120c & 0x7fffffff | 0x80000000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t rf_pri_pm_pwr(void)

{
  int iVar1;
  int iVar2;
  
  do {
  } while (-1 < (int)((_DAT_40001618 & 0xdfefffff | 0x20100000) << 3));
  iVar1 = (_DAT_40001620 << 7) >> 0x10;
  iVar2 = (_DAT_40001624 << 7) >> 0x10;
  _DAT_40001618 = _DAT_40001618 & 0xdfefffff;
  return iVar1 * iVar1 + iVar2 * iVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_start_txdfe(void)

{
  _DAT_40001220 = _DAT_40001220 & 0xffffe67f | 0x1182;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int32_t rf_pri_pm_pwr_avg(uint32_t iq,uint32_t acc_len)

{
  int iVar1;
  
  do {
  } while (-1 < (int)((_DAT_40001618 & 0xdfefffff) << 3));
  iVar1 = _DAT_40001624;
  if (iq != 0) {
    iVar1 = _DAT_40001620;
  }
  _DAT_40001618 = _DAT_40001618 & 0xdfefffff;
  _DAT_4000161c = acc_len << 0x10 | _DAT_4000161c & 0xffff;
  return (iVar1 << 7) >> 7;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_txcal_config_hw(void)

{
  _DAT_40001180 =
       (*(uint *)(rf_calib_data->txcal + 1) >> 6 & 0x3f) << 0x18 |
       (*(uint *)rf_calib_data->txcal >> 6 & 0x3f) << 8 |
       *(uint *)rf_calib_data->txcal & 0x3f | _DAT_40001180 & 0xc0c0c0c0 |
       (*(uint *)(rf_calib_data->txcal + 1) & 0x3f) << 0x10;
  _DAT_40001184 =
       (*(uint *)(rf_calib_data->txcal + 3) >> 6 & 0x3f) << 0x18 |
       (*(uint *)(rf_calib_data->txcal + 2) >> 6 & 0x3f) << 8 |
       *(uint *)(rf_calib_data->txcal + 2) & 0x3f | _DAT_40001184 & 0xc0c0c0c0 |
       (*(uint *)(rf_calib_data->txcal + 3) & 0x3f) << 0x10;
  _DAT_40001188 =
       (*(uint *)(rf_calib_data->txcal + 5) >> 6 & 0x3f) << 0x18 |
       (*(uint *)(rf_calib_data->txcal + 4) >> 6 & 0x3f) << 8 |
       *(uint *)(rf_calib_data->txcal + 4) & 0x3f | _DAT_40001188 & 0xc0c0c0c0 |
       (*(uint *)(rf_calib_data->txcal + 5) & 0x3f) << 0x10;
  _DAT_4000118c =
       (*(uint *)(rf_calib_data->txcal + 7) >> 6 & 0x3f) << 0x18 |
       (*(uint *)(rf_calib_data->txcal + 6) >> 6 & 0x3f) << 8 |
       *(uint *)(rf_calib_data->txcal + 6) & 0x3f | _DAT_4000118c & 0xc0c0c0c0 |
       (*(uint *)(rf_calib_data->txcal + 7) & 0x3f) << 0x10;
  _DAT_40001190 =
       (*(uint *)rf_calib_data->txcal >> 0xc & 0x7ff) << 0x10 | _DAT_40001190 & 0xf800fc00 |
       *(uint *)&rf_calib_data->txcal[0].field_0x4 & 0x3ff;
  _DAT_40001194 =
       (*(uint *)(rf_calib_data->txcal + 1) >> 0xc & 0x7ff) << 0x10 | _DAT_40001194 & 0xf800fc00 |
       *(uint *)&rf_calib_data->txcal[1].field_0x4 & 0x3ff;
  _DAT_40001198 =
       (*(uint *)(rf_calib_data->txcal + 2) >> 0xc & 0x7ff) << 0x10 | _DAT_40001198 & 0xf800fc00 |
       *(uint *)&rf_calib_data->txcal[2].field_0x4 & 0x3ff;
  _DAT_4000119c =
       (*(uint *)(rf_calib_data->txcal + 3) >> 0xc & 0x7ff) << 0x10 | _DAT_4000119c & 0xf800fc00 |
       *(uint *)&rf_calib_data->txcal[3].field_0x4 & 0x3ff;
  _DAT_400011a0 =
       (*(uint *)(rf_calib_data->txcal + 4) >> 0xc & 0x7ff) << 0x10 | _DAT_400011a0 & 0xf800fc00 |
       *(uint *)&rf_calib_data->txcal[4].field_0x4 & 0x3ff;
  _DAT_400011a4 =
       (*(uint *)(rf_calib_data->txcal + 5) >> 0xc & 0x7ff) << 0x10 | _DAT_400011a4 & 0xf800fc00 |
       *(uint *)&rf_calib_data->txcal[5].field_0x4 & 0x3ff;
  _DAT_400011a8 =
       (*(uint *)(rf_calib_data->txcal + 6) >> 0xc & 0x7ff) << 0x10 | _DAT_400011a8 & 0xf800fc00 |
       *(uint *)&rf_calib_data->txcal[6].field_0x4 & 0x3ff;
  _DAT_400011ac =
       (*(uint *)(rf_calib_data->txcal + 7) >> 0xc & 0x7ff) << 0x10 | _DAT_400011ac & 0xf800fc00 |
       *(uint *)&rf_calib_data->txcal[7].field_0x4 & 0x3ff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint16_t rf_pri_fcal_meas(uint32_t cw)

{
  _DAT_400010a0 = cw | _DAT_400010a0 & 0xffffff00;
  BL602_Delay_US(100);
  do {
  } while (-1 < (int)((_DAT_400010ac | 0x10) << 0xb));
  _DAT_400010ac = _DAT_400010ac & 0xffffffef;
  return (uint16_t)((uint)_DAT_400010a8 >> 0x10);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_rccal_config(uint32_t rbb_fc)

{
  _DAT_40001080 = rbb_fc << 8 | rbb_fc << 0x18 | _DAT_40001080 & 0xc0ffc0ff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_rccal_config(uint32_t iq,uint32_t rbb_fc)

{
  if (iq != 0) {
    rf_pri_rccal_config(rbb_fc);
    return;
  }
  _DAT_40001080 = rbb_fc << 0x10 | _DAT_40001080 & 0xffc0ffc0 | rbb_fc;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_txcal_config(uint32_t param_ind,int32_t val)

{
  uint uVar1;
  
  if (param_ind == 2) {
    _DAT_40001600 = val << 0xc | _DAT_40001600 & 0xff800fff | 0x800000;
    return;
  }
  if (param_ind != 3) {
    if (param_ind == 0) {
      _DAT_40001070 = _DAT_40001070 & 0xc0ffffff;
      uVar1 = val << 0x18;
    }
    else {
      if (param_ind != 1) {
        return;
      }
      _DAT_40001070 = _DAT_40001070 & 0xffc0ffff;
      uVar1 = val << 0x10;
    }
    _DAT_40001070 = uVar1 | _DAT_40001070;
    return;
  }
  if (val < 0) {
    val = val + 0x400;
  }
  _DAT_40001600 = val | _DAT_40001600 & 0xfffffc00 | 0x400;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int32_t rf_pri_txcal_search_core
                  (uint32_t param_ind,uint32_t center,uint32_t delta,uint32_t meas_freq)

{
  uint32_t val;
  uint32_t val_00;
  uint32_t uVar1;
  uint uVar2;
  uint32_t uVar3;
  
  rf_pri_txcal_config(param_ind,center);
  BL602_Delay_US(10);
  _DAT_40001618 = meas_freq << 10 | _DAT_40001618 & 0xfff00000;
  uVar1 = rf_pri_pm_pwr();
  do {
    val = center - delta;
    val_00 = center + delta;
    if (param_ind < 2) {
      if ((int)val < 0) {
        val = 0;
      }
      if (0x3f < (int)val_00) {
        val_00 = 0x3f;
      }
    }
    else {
      if (param_ind == 2) {
        if ((int)val < 0) {
          val = 0;
        }
        if (0x7ff < (int)val_00) {
          val_00 = 0x7ff;
        }
      }
      else {
        if ((int)val < -0x200) {
          val = 0xfffffe00;
        }
        if (0x1ff < (int)val_00) {
          val_00 = 0x1ff;
        }
      }
    }
    rf_pri_txcal_config(param_ind,val);
    delta = (int)delta >> 1;
    BL602_Delay_US(10);
    uVar2 = rf_pri_pm_pwr();
    if (uVar1 <= uVar2) {
      rf_pri_txcal_config(param_ind,val_00);
      BL602_Delay_US(10);
      uVar3 = rf_pri_pm_pwr();
      val = center;
      uVar2 = uVar1;
      if (uVar3 < uVar1) {
        val = val_00;
        uVar2 = uVar3;
      }
    }
    center = val;
    uVar1 = uVar2;
  } while (delta != 0);
  return val;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_singen_config(uint32_t fcw)

{
  _DAT_4000120c = fcw << 0x10 | _DAT_4000120c & 0xfc00ffff;
  _DAT_40001214 = _DAT_40001214 & 0x3fffff;
  _DAT_40001218 = _DAT_40001218 & 0x3fffff | 0xc0000000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t rf_pri_rccal_iq(uint32_t iq)

{
  uint uVar1;
  uint32_t i;
  USItype UVar2;
  uint32_t uVar3;
  uint uVar4;
  int iVar5;
  undefined4 uVar6;
  
  if (iq == 0) {
    _DAT_4000160c = _DAT_4000160c & 0xfbffffff | 0x400;
  }
  else {
    _DAT_4000160c = _DAT_4000160c & 0xfffffbff | 0x4000000;
  }
  _DAT_40001048 = _DAT_40001048 & 0xffff8cff | 0x3100;
  rf_pri_singen_config(3);
  _DAT_40001214 = _DAT_40001214 & 0xfffff800 | 0x3ff;
  _DAT_40001218 = _DAT_40001218 & 0xfffff800 | 0x3ff;
  uVar6 = rf_pri_singen_start();
  rf_pri_start_txdfe(uVar6);
  _DAT_40001618 = _DAT_40001618 & 0xfff00000 | 0xc00;
  rf_pri_pm_pwr_avg(iq,0x400);
  i = rf_pri_pm_pwr();
  __floatunsidf(i);
  __muldf3();
  UVar2 = __fixunsdfsi();
  _DAT_40001048 = _DAT_40001048 & 0xffff8cff | 0x6200;
  rf_pri_singen_config(0xb5);
  uVar6 = rf_pri_singen_start();
  rf_pri_start_txdfe(uVar6);
  _DAT_40001618 = _DAT_40001618 & 0xfff00000 | 0x2d400;
  i = 0;
  uVar1 = 6;
  uVar4 = 0x20;
  do {
    rf_pri_rccal_config(iq,uVar4 + i);
    uVar3 = rf_pri_pm_pwr();
    if (UVar2 < uVar3) {
      i = uVar4 + i;
    }
    uVar1 = uVar1 - 1;
    uVar4 = uVar4 >> 1;
  } while (uVar1 != 0);
  iVar5 = 0x3f;
  do {
    rf_pri_rccal_config(iq,i);
    uVar3 = rf_pri_pm_pwr();
    if (UVar2 < uVar3) {
      uVar1 = uVar1 * 2 + 1 & 0xf;
      i = i + 1;
      if (uVar1 == 5) {
        return 3;
      }
    }
    else {
      uVar1 = uVar1 * 2 & 0xf;
      i = i - 1;
      if (uVar1 == 10) {
        return 3;
      }
    }
    iVar5 = iVar5 + -1;
  } while (iVar5 != 0);
  return 2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_config_channel(void)

{
  _DAT_400010a0 =
       ((uint)((ushort)rf_calib_data->lo[9] >> 8) & 0x1f) << 0x10 |
       (uint)(ushort)rf_calib_data->lo[9] & 0xff | _DAT_400010a0 & 0xffe0ff00;
  _DAT_400010bc =
       (((uint)(ushort)rf_calib_data->lo[9] & 0xff) >> 4) << 0x14 | _DAT_400010bc & 0xff0fffff;
  _DAT_400010c4 = _DAT_400010c4 & 0xc0000000 | channel_div_table[9];
  _DAT_400010c0 = _DAT_400010c0 & 0xffffefff;
  while( true ) {
    _DAT_400010b8 = _DAT_400010b8 | 0x10000;
    BL602_Delay_US(10);
    _DAT_400010b8 = _DAT_400010b8 & 0xfffeffff;
    BL602_Delay_US(0x32);
    _DAT_400010b0 = _DAT_400010b0 | 0x10000000;
    BL602_Delay_US(10);
    _DAT_400010b0 = _DAT_400010b0 & 0xefffffff;
    BL602_Delay_US(0x32);
    if ((_DAT_400010b4 & 0x1100000) == 0) break;
    printf(".");
  }
  printf("LO locked %ld %ld\r\n",(uint)(ushort)rf_calib_data->lo[9] & 0xff);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t rf_pri_roscal_iq(uint32_t iq)

{
  uint uVar1;
  int32_t iVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  
  uVar1 = 6;
  uVar3 = 0;
  uVar4 = 0x20;
  do {
    uVar6 = uVar4 + uVar3;
    if (iq == 0) {
      _DAT_4000107c = uVar6 | _DAT_4000107c & 0xffffffc0;
    }
    else {
      _DAT_4000107c = uVar6 * 0x100 | _DAT_4000107c & 0xffffc0ff;
    }
    iVar2 = rf_pri_pm_pwr_avg(iq,0x400);
    if (iVar2 < 1) {
      uVar3 = uVar6;
    }
    uVar1 = uVar1 - 1;
    uVar4 = uVar4 >> 1;
  } while (uVar1 != 0);
  iVar5 = 0x3f;
  do {
    if (iq == 0) {
      _DAT_4000107c = _DAT_4000107c & 0xffffffc0 | uVar3;
    }
    else {
      _DAT_4000107c = uVar3 << 8 | _DAT_4000107c & 0xffffc0ff;
    }
    iVar2 = rf_pri_pm_pwr_avg(iq,0x400);
    if (iVar2 < 1) {
      uVar1 = uVar1 * 2 & 0xf;
      uVar3 = uVar3 + 1;
      if (uVar1 == 10) {
        return uVar3;
      }
    }
    else {
      uVar1 = uVar1 * 2 + 1 & 0xf;
      uVar3 = uVar3 - 1;
      if (uVar1 == 5) {
        return uVar3;
      }
    }
    iVar5 = iVar5 + -1;
  } while (iVar5 != 0);
  return uVar3;
}



void rf_pri_chipv(uint8_t chipv)

{
  regs_to_opti *prVar1;
  undefined3 in_register_00002029;
  undefined4 *puVar2;
  undefined4 *puVar3;
  int iVar4;
  uint32_t *puVar5;
  void_fn **ppvVar6;
  int iVar7;
  uint32_t *puVar8;
  uint32_t *puVar9;
  int iVar10;
  void_fn **ppvVar11;
  void_fn **ppvVar12;
  
  if (CONCAT31(in_register_00002029,chipv) == 0) {
    tmxcss._0_4_ = 0x60003;
    tmxcss[2] = 6;
    iVar4 = 0x1c;
    do {
      iVar7 = iVar4 + -0x1c;
      do {
        *(undefined4 *)((int)tx_pwr_table + iVar7) = *(undefined4 *)((int)tx_pwr_table_a0 + iVar7);
        *(undefined4 *)((int)tx_pwr_table_origin + iVar7) =
             *(undefined4 *)((int)tx_pwr_table_a0 + iVar7);
        iVar7 = iVar7 + 4;
      } while (iVar4 != iVar7);
      iVar4 = iVar4 + 0x1c;
    } while (iVar4 != 0x1dc);
    iVar4 = 0;
    do {
      puVar2 = (undefined4 *)((int)tx_pwr_ch_os_a0 + iVar4);
      puVar3 = (undefined4 *)((int)tx_pwr_ch_os + iVar4);
      iVar4 = iVar4 + 4;
      *puVar3 = *puVar2;
    } while (iVar4 != 0x38);
    puVar5 = txcal_para;
    puVar8 = txcal_para_a0;
    do {
      puVar9 = puVar8 + 4;
      *puVar5 = *puVar8;
      puVar5[1] = puVar8[1];
      puVar5[2] = puVar8[2];
      puVar5[3] = puVar8[3];
      puVar5 = puVar5 + 4;
      puVar8 = puVar9;
    } while (puVar9 != txcal_para_a1);
    opti_regs->vbcore = 10;
    prVar1 = opti_regs;
    opti_regs->iet = 3;
    prVar1->vbcore_11n = 10;
    prVar1->iet_11n = 3;
    prVar1->vbcore_11g = 10;
    prVar1->iet_11g = 3;
    prVar1->vbcore_11b = 10;
    prVar1->iet_11b = 3;
    prVar1->lo_fbdv_halfstep_en = 0;
    prVar1->lo_fbdv_halfstep_en_tx = 0;
    prVar1->lo_fbdv_halfstep_en_tx = 0;
    prVar1->clkpll_reset_postdiv = 0;
    prVar1->clkpll_dither_sel = 0;
    return;
  }
  if (CONCAT31(in_register_00002029,chipv) == 1) {
    tmxcss._0_4_ = 0x50005;
    tmxcss[2] = 5;
    iVar4 = 0x1c;
    do {
      iVar7 = iVar4 + -0x1c;
      do {
        iVar10 = iVar7;
        *(undefined4 *)((int)tx_pwr_table + iVar10) = *(undefined4 *)((int)tx_pwr_table_a1 + iVar10)
        ;
        *(undefined4 *)((int)tx_pwr_table_origin + iVar10) =
             *(undefined4 *)((int)tx_pwr_table_a1 + iVar10);
        iVar7 = iVar10 + 4;
      } while (iVar10 + 4 != iVar4);
      iVar4 = iVar10 + 0x20;
    } while (iVar4 != 0x1dc);
    iVar4 = 0;
    do {
      puVar2 = (undefined4 *)((int)tx_pwr_ch_os_a1 + iVar4);
      puVar3 = (undefined4 *)((int)tx_pwr_ch_os + iVar4);
      iVar4 = iVar4 + 4;
      *puVar3 = *puVar2;
    } while (iVar4 != 0x38);
    ppvVar6 = (void_fn **)txcal_para;
    ppvVar11 = (void_fn **)txcal_para_a1;
    do {
      ppvVar12 = ppvVar11 + 4;
      *ppvVar6 = *ppvVar11;
      ppvVar6[1] = ppvVar11[1];
      ppvVar6[2] = ppvVar11[2];
      ppvVar6[3] = ppvVar11[3];
      ppvVar6 = ppvVar6 + 4;
      ppvVar11 = ppvVar12;
    } while (ppvVar12 != intc_irq_handlers);
    opti_regs->vbcore = 0xc;
    prVar1 = opti_regs;
    opti_regs->iet = 5;
    prVar1->vbcore_11n = 0xc;
    prVar1->iet_11n = 5;
    prVar1->vbcore_11g = 0xc;
    prVar1->iet_11g = 5;
    prVar1->vbcore_11b = 0xc;
    prVar1->iet_11b = 5;
    prVar1->lo_fbdv_halfstep_en = 1;
    prVar1->lo_fbdv_halfstep_en_tx = 1;
    prVar1->lo_fbdv_halfstep_en_tx = 1;
    prVar1->clkpll_reset_postdiv = 1;
    prVar1->clkpll_dither_sel = 2;
  }
  return;
}



void rf_pri_update_tx_power_offset(uint8_t channel,int8_t *power_offset)

{
  char cVar1;
  undefined3 in_register_00002029;
  int32_t *piVar2;
  int32_t *piVar3;
  
  cVar1 = power_offset[CONCAT31(in_register_00002029,channel)];
  memcpy(tx_pwr_table,tx_pwr_table_origin,0x1c0);
  piVar2 = tx_pwr_table;
  do {
    piVar3 = piVar2 + 7;
    piVar2[5] = piVar2[5] + (int)cVar1 % 4;
    piVar2[6] = piVar2[6] + ((int)cVar1 / 4) * -10;
    piVar2 = piVar3;
  } while (piVar3 != tx_pwr_table_origin);
  rf_pri_set_gain_table_regs();
  return;
}



void rf_pri_get_notch_param(uint32_t chanfreq_MHz,uint8_t *ncf_on,int32_t *ncf_freq_Hz)

{
  uint uVar1;
  int32_t iVar2;
  
  uVar1 = 0xd;
  if (chanfreq_MHz < 0x9a9) {
    uVar1 = (chanfreq_MHz - 0x96c) / 5;
  }
  iVar2 = rx_notch_para_40M[uVar1 * 2 + 1];
  *ncf_on = (uint8_t)rx_notch_para_40M[uVar1 * 2];
  *ncf_freq_Hz = iVar2;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_update_param(uint32_t chanfreq_MHz)

{
  ushort uVar1;
  int iVar2;
  int32_t *piVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int32_t iVar7;
  int iVar8;
  uint32_t uVar9;
  int32_t *piVar10;
  
  index_os_pre = 0;
  index_os_pre_mdb = 0;
  dvga_os_pre = 0;
  up_dn = 0;
  if ((chanfreq_MHz < 0x96c) || (chanfreq_MHz < 0x971)) {
    iVar5 = 0;
  }
  else {
    if (chanfreq_MHz < 0x97b) {
      iVar5 = 1;
    }
    else {
      if (chanfreq_MHz < 0x98a) {
        iVar5 = 2;
      }
      else {
        if (chanfreq_MHz < 0x999) {
          iVar5 = 3;
        }
        else {
          iVar4 = 8;
          iVar5 = 7;
          if (0x9a7 < chanfreq_MHz) goto LAB_23059024;
          iVar5 = 4;
        }
      }
    }
  }
  uVar9 = Tchannels[iVar5];
  iVar8 = 0;
  if (uVar9 != chanfreq_MHz) {
    iVar8 = chanfreq_MHz - uVar9;
  }
  iVar6 = iVar5 + 1;
  iVar4 = (uint)((Tchannel_os[iVar6] - Tchannel_os[iVar5]) * iVar8) / (Tchannels[iVar6] - uVar9) +
          Tchannel_os[iVar5];
  iVar5 = (uint)((Tchannel_os_low[iVar6] - Tchannel_os_low[iVar5]) * iVar8) /
          (Tchannels[iVar6] - uVar9) + Tchannel_os_low[iVar5];
LAB_23059024:
  piVar3 = temps;
  piVar10 = temps;
  iVar8 = 0;
  iVar6 = 10;
  do {
    iVar2 = (piVar10[4] + iVar8) - (0x14 - iVar5);
    iVar8 = 0;
    if (iVar6 < iVar2) {
      iVar8 = iVar2 - iVar6;
      iVar2 = iVar6;
    }
    piVar10[3] = iVar2;
    iVar6 = iVar6 + -5;
    piVar10 = piVar10 + -1;
  } while (iVar6 != -10);
  iVar8 = 0x38;
  iVar5 = 0;
  do {
    iVar7 = (piVar3[5] - iVar5) + (0x14 - iVar4);
    if (0x5f < iVar7) {
      iVar7 = iVar7 + (5 - iVar4 / 4);
    }
    piVar3[6] = iVar7;
    iVar6 = piVar3[6];
    iVar5 = 0;
    if (iVar6 < iVar8) {
      iVar5 = iVar8 - iVar6;
      iVar6 = iVar8;
    }
    piVar3[6] = iVar6;
    iVar8 = iVar8 + 5;
    piVar3 = piVar3 + 1;
  } while (iVar8 != 0x5b);
  uVar1 = tmxcss[2];
  if (chanfreq_MHz < 0x986) {
    uVar1 = tmxcss[1];
  }
  _DAT_4000106c = (uint)uVar1 | _DAT_4000106c & 0xfffffff8;
  tx_pwr_os = tx_pwr_ch_os[6];
  if (chanfreq_MHz != 0x98a) {
    if (chanfreq_MHz < 0x98b) {
      tx_pwr_os = tx_pwr_ch_os[2];
      if (chanfreq_MHz != 0x976) {
        if (chanfreq_MHz < 0x977) {
          tx_pwr_os = tx_pwr_ch_os[0];
          if ((chanfreq_MHz != 0x96c) && (tx_pwr_os = tx_pwr_ch_os[1], chanfreq_MHz != 0x971)) {
            temps[4] = 0xf;
            temps[5] = 0x33;
            tx_pwr_os = 0;
            return;
          }
        }
        else {
          tx_pwr_os = tx_pwr_ch_os[4];
          if (((chanfreq_MHz != 0x980) && (tx_pwr_os = tx_pwr_ch_os[5], chanfreq_MHz != 0x985)) &&
             (tx_pwr_os = tx_pwr_ch_os[3], chanfreq_MHz != 0x97b)) {
            temps[4] = 0xf;
            temps[5] = 0x33;
            tx_pwr_os = 0;
            return;
          }
        }
      }
    }
    else {
      tx_pwr_os = tx_pwr_ch_os[10];
      if (chanfreq_MHz != 0x99e) {
        if (chanfreq_MHz < 0x99f) {
          tx_pwr_os = tx_pwr_ch_os[8];
          if (((chanfreq_MHz != 0x994) && (tx_pwr_os = tx_pwr_ch_os[9], chanfreq_MHz != 0x999)) &&
             (tx_pwr_os = tx_pwr_ch_os[7], chanfreq_MHz != 0x98f)) {
            temps[4] = 0xf;
            temps[5] = 0x33;
            tx_pwr_os = 0;
            return;
          }
        }
        else {
          tx_pwr_os = tx_pwr_ch_os[12];
          if (((chanfreq_MHz != 0x9a8) && (tx_pwr_os = tx_pwr_ch_os[13], chanfreq_MHz != 0x9b4)) &&
             (tx_pwr_os = tx_pwr_ch_os[11], chanfreq_MHz != 0x9a3)) {
            temps[4] = 0xf;
            temps[5] = 0x33;
            tx_pwr_os = 0;
            return;
          }
        }
      }
    }
  }
  temps[4] = 0xf;
  temps[5] = 0x33;
  return;
}



void rf_pri_xtalfreq(uint32_t xtalfreq)

{
  if (xtalfreq == 0) {
    channel_div_table[0] = 0x21638e39;
    channel_div_table[1] = 0x2171c71c;
    channel_div_table[2] = 0x21800000;
    channel_div_table[3] = 0x218e38e4;
    channel_div_table[4] = 0x219c71c7;
    channel_div_table[5] = 0x21aaaaab;
    channel_div_table[6] = 0x21b8e38e;
    channel_div_table[7] = 0x21c71c72;
    channel_div_table[8] = 0x21d55555;
    channel_div_table[9] = 0x21e38e39;
    channel_div_table[10] = 0x21f1c71c;
    channel_div_table[11] = 0x22000000;
    channel_div_table[12] = 0x220e38e4;
    channel_div_table[13] = 0x221c71c7;
    channel_div_table[14] = 0x222aaaab;
    channel_div_table[15] = 0x2238e38e;
    channel_div_table[16] = 0x22471c72;
    channel_div_table[17] = 0x22555555;
    channel_div_table[18] = 0x22638e39;
    channel_div_table[19] = 0x2271c71c;
    channel_div_table[20] = 0x22800000;
    fcal_div = 0x500;
    rx_notch_para_40M[4][0] = 1;
    rx_notch_para_40M[6][0] = 1;
    rx_notch_para_40M[7][0] = 1;
    rx_notch_para_40M[12][0] = 1;
    rx_notch_para_40M[1][1] = 7000000;
    rx_notch_para_40M[2][1] = (int32_t)&DAT_001e8480;
    rx_notch_para_40M[3][1] = -3000000;
    rx_notch_para_40M[4][1] = -8000000;
    rx_notch_para_40M[6][1] = 6000000;
    rx_notch_para_40M[7][1] = 1000000;
    rx_notch_para_40M[8][1] = -4000000;
    rx_notch_para_40M[9][1] = -9000000;
    rx_notch_para_40M[0][0] = 0;
    rx_notch_para_40M[10][0] = 0;
    rx_notch_para_40M[0][1] = 0;
    rx_notch_para_40M[10][1] = 0;
    rx_notch_para_40M[11][1] = 5000000;
LAB_23059426:
    channel_cnt_range[2] = 0xace7;
    channel_cnt_range._0_4_ = 0xa6e7a6a7;
    rx_notch_para_40M[11][0] = 1;
    rx_notch_para_40M[9][0] = 1;
    rx_notch_para_40M[5][1] = 0;
    rx_notch_para_40M[5][0] = 0;
    rx_notch_para_40M[3][0] = 1;
    rx_notch_para_40M[2][0] = 1;
    rx_notch_para_40M[1][0] = 1;
    channel_cnt_table[20] = 0xac80;
    channel_cnt_table._36_4_ = 0xac39abf2;
    channel_cnt_table._32_4_ = 0xababab64;
    channel_cnt_table._28_4_ = 0xab1caad5;
    channel_cnt_table._24_4_ = 0xaa8eaa47;
    channel_cnt_table._20_4_ = 0xaa00a9b9;
    channel_cnt_table._16_4_ = 0xa972a92b;
    channel_cnt_table._12_4_ = 0xa8e4a89c;
    channel_cnt_table._8_4_ = 0xa855a80e;
    channel_cnt_table._4_4_ = 0xa7c7a780;
    channel_cnt_table._0_4_ = 0xa739a6f2;
LAB_23059428:
    rx_notch_para_40M[8][0] = 1;
    rx_notch_para_40M[12][1] = 0;
  }
  else {
    if (xtalfreq == 1) {
      channel_div_table[0] = 0x1ed20d21;
      channel_div_table[1] = 0x1edf2df3;
      channel_div_table[2] = 0x1eec4ec5;
      channel_div_table[3] = 0x1ef96f97;
      channel_div_table[4] = 0x1f069069;
      channel_div_table[5] = 0x1f13b13b;
      channel_div_table[6] = 0x1f20d20d;
      channel_div_table[7] = 0x1f2df2df;
      channel_div_table[8] = 0x1f3b13b1;
      channel_div_table[9] = 0x1f483483;
      channel_div_table[10] = 0x1f555555;
      channel_div_table[11] = 0x1f627627;
      channel_div_table[12] = 0x1f6f96f9;
      channel_div_table[13] = 0x1f7cb7cb;
      channel_div_table[14] = 0x1f89d89e;
      channel_div_table[15] = 0x1f96f970;
      channel_div_table[16] = 0x1fa41a42;
      channel_div_table[17] = 0x1fb13b14;
      channel_div_table[18] = 0x1fbe5be6;
      channel_div_table[19] = 0x1fcb7cb8;
      channel_div_table[20] = 0x1fd89d8a;
      channel_cnt_table._0_4_ = 0xa743a6fc;
      channel_cnt_table._4_4_ = 0xa7d1a78a;
      channel_cnt_table._8_4_ = 0xa860a819;
      channel_cnt_table._12_4_ = 0xa8eea8a7;
      channel_cnt_table._16_4_ = 0xa97ca935;
      channel_cnt_table._20_4_ = 0xaa0aa9c3;
      channel_cnt_table._24_4_ = 0xaa99aa52;
      channel_cnt_table._28_4_ = 0xab27aae0;
      channel_cnt_table._32_4_ = 0xabb5ab6e;
      channel_cnt_table._36_4_ = 0xac43abfc;
      channel_cnt_table[20] = 0xac8b;
      channel_cnt_range._0_4_ = 0xa6f1a6b1;
      channel_cnt_range[2] = 0xacf2;
      fcal_div = 0x56b;
      rx_notch_para_40M[0][1] = 6000000;
      rx_notch_para_40M[1][1] = 1000000;
      rx_notch_para_40M[2][1] = -4000000;
      rx_notch_para_40M[3][1] = -9000000;
      rx_notch_para_40M[5][1] = 7000000;
      rx_notch_para_40M[6][1] = (int32_t)&DAT_001e8480;
      rx_notch_para_40M[7][1] = -3000000;
      rx_notch_para_40M[8][1] = -8000000;
      rx_notch_para_40M[10][1] = 8000000;
      rx_notch_para_40M[11][1] = 3000000;
      rx_notch_para_40M[4][0] = 0;
      rx_notch_para_40M[9][0] = 0;
      rx_notch_para_40M[9][1] = 0;
      rx_notch_para_40M[12][1] = -2000000;
      rx_notch_para_40M[8][0] = xtalfreq;
      rx_notch_para_40M[12][0] = xtalfreq;
    }
    else {
      if (xtalfreq != 2) {
        if (xtalfreq == 3) {
          channel_div_table[0] = 0x14de38e4;
          channel_div_table[1] = 0x14e71c72;
          channel_div_table[2] = 0x14f00000;
          channel_div_table[3] = 0x14f8e38e;
          channel_div_table[4] = 0x1501c71c;
          channel_div_table[5] = 0x150aaaab;
          channel_div_table[6] = 0x15138e39;
          channel_div_table[7] = 0x151c71c7;
          channel_div_table[8] = 0x15255555;
          channel_div_table[9] = 0x152e38e4;
          channel_div_table[10] = 0x15371c72;
          channel_div_table[11] = 0x15400000;
          channel_div_table[12] = 0x1548e38e;
          channel_div_table[13] = 0x1551c71c;
          channel_div_table[14] = 0x155aaaab;
          channel_div_table[15] = 0x15638e39;
          channel_div_table[16] = 0x156c71c7;
          channel_div_table[17] = 0x15755555;
          channel_div_table[18] = 0x157e38e4;
          channel_div_table[19] = 0x15871c72;
          channel_div_table[20] = 0x15900000;
          fcal_div = 0x800;
          rx_notch_para_40M[0][0] = 1;
          rx_notch_para_40M[10][0] = 1;
          rx_notch_para_40M[0][1] = 7200000;
          rx_notch_para_40M[1][1] = 2200000;
          rx_notch_para_40M[2][1] = -2800000;
          rx_notch_para_40M[3][1] = -7800000;
          rx_notch_para_40M[8][1] = 5600000;
          rx_notch_para_40M[9][1] = 600000;
          rx_notch_para_40M[10][1] = -4400000;
          rx_notch_para_40M[4][0] = 0;
          rx_notch_para_40M[6][0] = 0;
          rx_notch_para_40M[7][0] = 0;
          rx_notch_para_40M[12][0] = 0;
          rx_notch_para_40M[4][1] = 0;
          rx_notch_para_40M[6][1] = 0;
          rx_notch_para_40M[7][1] = 0;
          rx_notch_para_40M[11][1] = -9400000;
          goto LAB_23059426;
        }
        if (xtalfreq == 4) {
          channel_cnt_table._0_4_ = 0xa732a6eb;
          channel_cnt_table._4_4_ = 0xa7c0a779;
          channel_cnt_table._8_4_ = 0xa84fa808;
          channel_cnt_table._12_4_ = 0xa8dda896;
          channel_cnt_table._16_4_ = 0xa96ba924;
          channel_cnt_table._20_4_ = 0xa9f9a9b2;
          channel_cnt_table._24_4_ = 0xaa87aa40;
          channel_cnt_table._28_4_ = 0xab16aacf;
          channel_cnt_table._32_4_ = 0xaba4ab5d;
          channel_cnt_table._36_4_ = 0xac32abeb;
          channel_cnt_table[20] = 0xac79;
          channel_div_table[0] = 0x14088889;
          channel_div_table[1] = 0x14111111;
          channel_div_table[2] = 0x1419999a;
          channel_div_table[3] = 0x14222222;
          channel_div_table[4] = 0x142aaaab;
          channel_div_table[5] = 0x14333333;
          channel_div_table[6] = 0x143bbbbc;
          channel_div_table[7] = 0x14444444;
          channel_div_table[8] = 0x144ccccd;
          channel_div_table[9] = 0x14555555;
          channel_div_table[10] = 0x145dddde;
          channel_div_table[11] = 0x14666666;
          channel_div_table[12] = 0x146eeeef;
          channel_div_table[13] = 0x14777777;
          channel_div_table[14] = 0x14800000;
          channel_div_table[15] = 0x14888889;
          channel_div_table[16] = 0x14911111;
          channel_div_table[17] = 0x1499999a;
          channel_div_table[18] = 0x14a22222;
          channel_div_table[19] = 0x14aaaaab;
          channel_div_table[20] = 0x14b33333;
          rx_notch_para_40M[0][0] = 0;
          rx_notch_para_40M[0][1] = 0;
          rx_notch_para_40M[1][0] = 0;
          rx_notch_para_40M[1][1] = 0;
          rx_notch_para_40M[2][0] = 0;
          rx_notch_para_40M[2][1] = 0;
          rx_notch_para_40M[3][0] = 0;
          rx_notch_para_40M[3][1] = 0;
          rx_notch_para_40M[4][0] = 1;
          rx_notch_para_40M[4][1] = 8000000;
          rx_notch_para_40M[5][0] = 1;
          rx_notch_para_40M[5][1] = 3000000;
          rx_notch_para_40M[6][0] = 1;
          rx_notch_para_40M[6][1] = -2000000;
          rx_notch_para_40M[7][0] = 1;
          rx_notch_para_40M[7][1] = -7000000;
          rx_notch_para_40M[8][0] = 0;
          rx_notch_para_40M[8][1] = 0;
          rx_notch_para_40M[9][0] = 0;
          rx_notch_para_40M[9][1] = 0;
          rx_notch_para_40M[10][0] = 0;
          rx_notch_para_40M[10][1] = 0;
          rx_notch_para_40M[11][0] = 0;
          rx_notch_para_40M[11][1] = 0;
          rx_notch_para_40M[12][0] = 1;
          rx_notch_para_40M[12][1] = 8000000;
          rx_notch_para_40M[13][0] = 1;
          rx_notch_para_40M[13][1] = -4000000;
          channel_cnt_range._0_4_ = 0xa6e0a6a0;
          channel_cnt_range[2] = 0xace0;
          fcal_div = 0x855;
          return;
        }
        if (xtalfreq != 5) {
          return;
        }
        channel_div_table[0] = 0xf690690;
        channel_div_table[1] = 0xf6f96f9;
        channel_div_table[2] = 0xf762762;
        channel_div_table[3] = 0xf7cb7cb;
        channel_div_table[4] = 0xf834835;
        channel_div_table[5] = 0xf89d89e;
        channel_div_table[6] = 0xf906907;
        channel_div_table[7] = 0xf96f970;
        channel_div_table[8] = 0xf9d89d9;
        channel_div_table[9] = 0xfa41a42;
        channel_div_table[10] = 0xfaaaaab;
        channel_div_table[11] = 0xfb13b14;
        channel_div_table[12] = 0xfb7cb7d;
        channel_div_table[13] = 0xfbe5be6;
        channel_div_table[14] = 0xfc4ec4f;
        channel_div_table[15] = 0xfcb7cb8;
        channel_div_table[16] = 0xfd20d21;
        channel_div_table[17] = 0xfd89d8a;
        channel_div_table[18] = 0xfdf2df3;
        channel_div_table[19] = 0xfe5be5c;
        channel_div_table[20] = 0xfec4ec5;
        channel_cnt_table._0_4_ = 0xa734a6ed;
        channel_cnt_table._4_4_ = 0xa7c2a77b;
        channel_cnt_table._8_4_ = 0xa850a809;
        channel_cnt_table._12_4_ = 0xa8dea897;
        channel_cnt_table._16_4_ = 0xa96da925;
        channel_cnt_table._20_4_ = 0xa9fba9b4;
        channel_cnt_table._24_4_ = 0xaa89aa42;
        channel_cnt_table._28_4_ = 0xab17aad0;
        channel_cnt_table._32_4_ = 0xaba5ab5e;
        channel_cnt_table._36_4_ = 0xac34abec;
        channel_cnt_table[20] = 0xac7b;
        channel_cnt_range._0_4_ = 0xa6e2a6a2;
        channel_cnt_range[2] = 0xace2;
        fcal_div = 0xad5;
        rx_notch_para_40M[5][0] = 1;
        rx_notch_para_40M[6][0] = 1;
        rx_notch_para_40M[7][0] = 1;
        rx_notch_para_40M[5][1] = 7000000;
        rx_notch_para_40M[6][1] = (int32_t)&DAT_001e8480;
        rx_notch_para_40M[7][1] = -3000000;
        rx_notch_para_40M[0][0] = 0;
        rx_notch_para_40M[1][0] = 0;
        rx_notch_para_40M[2][0] = 0;
        rx_notch_para_40M[3][0] = 0;
        rx_notch_para_40M[4][0] = 0;
        rx_notch_para_40M[9][0] = 0;
        rx_notch_para_40M[10][0] = 0;
        rx_notch_para_40M[11][0] = 0;
        rx_notch_para_40M[12][0] = 0;
        rx_notch_para_40M[0][1] = 0;
        rx_notch_para_40M[1][1] = 0;
        rx_notch_para_40M[2][1] = 0;
        rx_notch_para_40M[3][1] = 0;
        rx_notch_para_40M[4][1] = 0;
        rx_notch_para_40M[8][1] = -8000000;
        rx_notch_para_40M[9][1] = 0;
        rx_notch_para_40M[10][1] = 0;
        rx_notch_para_40M[11][1] = 0;
        goto LAB_23059428;
      }
      channel_div_table[0] = 0x190aaaab;
      channel_div_table[1] = 0x19155555;
      channel_div_table[2] = 0x19200000;
      channel_div_table[3] = 0x192aaaab;
      channel_div_table[4] = 0x19355555;
      channel_div_table[5] = 0x19400000;
      channel_div_table[6] = 0x194aaaab;
      channel_div_table[7] = 0x19555555;
      channel_div_table[8] = 0x19600000;
      channel_div_table[9] = 0x196aaaab;
      channel_div_table[10] = 0x19755555;
      channel_div_table[11] = 0x19800000;
      channel_div_table[12] = 0x198aaaab;
      channel_div_table[13] = 0x19955555;
      channel_div_table[14] = 0x19a00000;
      channel_div_table[15] = 0x19aaaaab;
      channel_div_table[16] = 0x19b55555;
      channel_div_table[17] = 0x19c00000;
      channel_div_table[18] = 0x19caaaab;
      channel_div_table[19] = 0x19d55555;
      channel_div_table[20] = 0x19e00000;
      channel_cnt_table._0_4_ = 0xa741a6fa;
      channel_cnt_table._4_4_ = 0xa7d0a788;
      channel_cnt_table._8_4_ = 0xa85ea817;
      channel_cnt_table._12_4_ = 0xa8eca8a5;
      channel_cnt_table._16_4_ = 0xa97aa933;
      channel_cnt_table._20_4_ = 0xaa09a9c1;
      channel_cnt_table._24_4_ = 0xaa97aa50;
      channel_cnt_table._28_4_ = 0xab25aade;
      channel_cnt_table._32_4_ = 0xabb3ab6c;
      channel_cnt_table._36_4_ = 0xac42abfa;
      channel_cnt_table[20] = 0xac89;
      channel_cnt_range._0_4_ = 0xa6efa6af;
      channel_cnt_range[2] = 0xacf0;
      fcal_div = 0x6ab;
      rx_notch_para_40M[4][0] = 1;
      rx_notch_para_40M[9][0] = 1;
      rx_notch_para_40M[12][0] = 1;
      rx_notch_para_40M[2][1] = 10000000;
      rx_notch_para_40M[3][1] = 5000000;
      rx_notch_para_40M[5][1] = -5000000;
      rx_notch_para_40M[6][1] = -10000000;
      rx_notch_para_40M[9][1] = 7000000;
      rx_notch_para_40M[10][1] = (int32_t)&DAT_001e8480;
      rx_notch_para_40M[11][1] = -3000000;
      rx_notch_para_40M[8][0] = 0;
      rx_notch_para_40M[0][1] = 0;
      rx_notch_para_40M[1][1] = 0;
      rx_notch_para_40M[7][1] = 0;
      rx_notch_para_40M[8][1] = 0;
      rx_notch_para_40M[12][1] = -8000000;
    }
    rx_notch_para_40M[4][1] = 0;
    rx_notch_para_40M[0][0] = rx_notch_para_40M[8][0];
    rx_notch_para_40M[1][0] = rx_notch_para_40M[8][0];
    rx_notch_para_40M[2][0] = rx_notch_para_40M[12][0];
    rx_notch_para_40M[3][0] = rx_notch_para_40M[12][0];
    rx_notch_para_40M[5][0] = rx_notch_para_40M[12][0];
    rx_notch_para_40M[6][0] = rx_notch_para_40M[12][0];
    rx_notch_para_40M[7][0] = rx_notch_para_40M[8][0];
    rx_notch_para_40M[10][0] = rx_notch_para_40M[12][0];
    rx_notch_para_40M[11][0] = rx_notch_para_40M[12][0];
  }
  rx_notch_para_40M[13][0] = 0;
  rx_notch_para_40M[13][1] = 0;
  return;
}



uint32_t rf_pri_get_vco_freq_cw(uint32_t chanfreq_MHz)

{
  int iVar1;
  
  __floatunsidf(chanfreq_MHz - 0x964 >> 2);
  __adddf3();
  iVar1 = __fixdfsi();
  if (0x14 < iVar1) {
    iVar1 = 0x14;
  }
  return (uint)*(ushort *)(&(rf_calib_data->cal).field_0x8 + (iVar1 + 8) * 2) & 0xff;
}



uint32_t rf_pri_get_vco_idac_cw(uint32_t chanfreq_MHz)

{
  int iVar1;
  
  __floatunsidf(chanfreq_MHz - 0x964 >> 2);
  __adddf3();
  iVar1 = __fixdfsi();
  if (0x14 < iVar1) {
    iVar1 = 0x14;
  }
  return (uint)(*(ushort *)(&(rf_calib_data->cal).field_0x8 + (iVar1 + 8) * 2) >> 8) & 0x1f;
}



int32_t rf_pri_get_txgain_max(void)

{
  return tx_pwr_os_temperature + tx_pwr_table[0][6] + tx_pwr_os;
}



int32_t rf_pri_get_txgain_min(void)

{
  return tx_pwr_os_temperature + tx_pwr_table[15][6] + tx_pwr_os;
}



uint32_t rf_pri_get_txgain_index(int32_t pwr,uint32_t mode)

{
  int32_t *piVar1;
  uint32_t uVar2;
  
  if (mode == 0) {
    pwr = pwr + -0x1e;
  }
  piVar1 = tx_pwr_table;
  uVar2 = 0;
  do {
    if (piVar1[6] + tx_pwr_os + tx_pwr_os_temperature <= pwr) {
      return uVar2;
    }
    uVar2 = uVar2 + 1;
    piVar1 = piVar1 + 7;
  } while (uVar2 != 0x10);
  return 0xf;
}



void rf_pri_query_txgain_table(uint32_t index,uint32_t *rfg_index,uint32_t *dg)

{
  if (0xf < index) {
    index = 0xf;
  }
  *rfg_index = 7 - (index >> 1);
  *dg = tx_pwr_table[index * 7 + 5];
  return;
}



void rf_pri_update_dvga_os(int8_t dvga_os)

{
  int iVar1;
  int32_t *piVar2;
  int8_t *piVar3;
  
  piVar2 = tx_pwr_table;
  iVar1 = 0;
  do {
    piVar3 = temps_dvga + iVar1;
    iVar1 = iVar1 + 1;
    *piVar3 = (char)piVar2[5] + dvga_os;
    piVar2 = piVar2 + 7;
  } while (iVar1 != 0x10);
  return;
}



void rf_pri_tx_gain_comp(int32_t Tsens)

{
  int iVar1;
  int iVar2;
  int32_t *piVar3;
  uint uVar4;
  
  if (up_dn == 1) {
    if ((Tthr <= Tsens) || (Tsens <= Tthr + -5)) {
LAB_2305a016:
      piVar3 = temps;
      iVar2 = 0xc;
      do {
        if (piVar3[0xc] <= Tsens) break;
        iVar2 = iVar2 + -1;
        piVar3 = piVar3 + -1;
      } while (iVar2 != -1);
      if (iVar2 < 0) {
        iVar2 = 0;
      }
      uVar4 = iVar2 - 4;
      iVar1 = temps[iVar2];
      Tthr = iVar1;
      if (Tsens < 0x23) {
        if (iVar1 < Tsens) {
          Tthr = temps[iVar2 + 1];
          if (0x22 < temps[iVar2 + 1]) {
            Tthr = iVar1;
          }
        }
        else {
          uVar4 = iVar2 - 5;
        }
      }
      else {
        if (iVar1 < 0x24) {
          Tthr = temps[iVar2 + 1];
        }
      }
      if (index_os_pre_mdb < (int)uVar4) {
        up_dn = 1;
      }
      else {
        if ((int)uVar4 < index_os_pre_mdb) {
          up_dn = -1;
        }
      }
      if ((int)uVar4 < 1) {
        dvga_os_pre = 0;
        index_os_pre = uVar4;
        if (uVar4 != 0) {
          dvga_os_pre = 0xffffffff;
          if ((uVar4 & 1) != 0) {
            dvga_os_pre = 1;
          }
          index_os_pre = (int)(uVar4 - 1) / 2;
        }
      }
      else {
        dvga_os_pre = uVar4 + 1 & 1;
        if (dvga_os_pre == 0) {
          dvga_os_pre = 0xffffffff;
        }
        index_os_pre = (int)(uVar4 + 1) >> 1;
      }
      tx_pwr_os_temperature = index_os_pre * -10;
      index_os_pre_mdb = uVar4;
      goto LAB_23059fea;
    }
  }
  else {
    if (((up_dn != -1) || (Tsens <= Tthr)) || (Tthr + 5 <= Tsens)) goto LAB_2305a016;
  }
  tx_pwr_os_temperature = index_os_pre * -10;
LAB_23059fea:
  rf_pri_update_dvga_os((int8_t)dvga_os_pre);
  rfc_apply_tx_dvga(temps_dvga);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_txcal(void)

{
  int32_t val;
  uint32_t center;
  uint val_00;
  uint val_01;
  uint32_t *puVar1;
  int iVar2;
  uint32_t *puVar3;
  int32_t *piVar4;
  uint val_02;
  uint uVar5;
  int iVar6;
  
  _DAT_40001014 = _DAT_40001014 & 0xff0fffff | 0x500000;
  rf_pri_save_state_for_cal();
  rf_pri_manu_pu(5);
  rf_pri_config_channel();
  _DAT_4000101c = _DAT_4000101c | 0x3000;
  _DAT_40001084 = _DAT_40001084 | 0x80000000;
  _DAT_40001064 = _DAT_40001064 | 0x400000;
  iVar2 = 7;
  _DAT_4000106c = (uint)tmxcss[0] | _DAT_4000106c & 0xfffffff8;
  rf_pri_singen_config(0x3d);
  puVar3 = txcal_para;
  piVar4 = tx_pwr_table;
  do {
    _DAT_40001064 = *puVar3 << 0x1c | _DAT_40001064 & 0xfc3ffff | puVar3[2] << 0x12;
    _DAT_40001058 = puVar3[1] << 0x10 | _DAT_40001058 & 0xfff8ffff;
    _DAT_40001048 = *piVar4 << 0x1c | _DAT_40001048 & 0xce08ffff | piVar4[3] << 0x14 | 0x70000;
    BL602_Delay_US(10);
    val_02 = puVar3[3];
    uVar5 = val_02;
    do {
      uVar5 = uVar5 >> 1;
      _DAT_40001214 = val_02 | _DAT_40001214 & 0xfffff800;
      _DAT_40001218 = val_02 | _DAT_40001218 & 0xfffff800;
      rf_pri_singen_start();
      rf_pri_start_txdfe();
      BL602_Delay_US(10);
      val = rf_pri_pm_pwr_avg(1,0x400);
      iVar6 = val >> 10;
      printf("amp=%ld,step=%ld,adc_mean_i=%ld\r\n",val_02,uVar5,iVar6);
      if (iVar6 < 0x141) {
        val_00 = uVar5;
        if (0xbf < iVar6) break;
      }
      else {
        val_00 = -uVar5;
      }
      val_02 = val_02 + val_00;
    } while (uVar5 != 0);
    rf_pri_pm_pwr_avg(1,0x1000);
    center = rf_pri_txcal_search_core(0,0x20,0x10,0x3d);
    rf_pri_txcal_config(0,center);
    uVar5 = rf_pri_txcal_search_core(1,0x20,0x10,0x3d);
    _DAT_40001070 = uVar5 << 0x10 | _DAT_40001070 & 0xffc0ffff;
    val_02 = rf_pri_txcal_search_core(0,center,2,0x3d);
    rf_pri_txcal_config(0,val_02);
    center = rf_pri_txcal_search_core(2,0x400,0x80,0x7a);
    rf_pri_txcal_config(2,center);
    val = rf_pri_txcal_search_core(3,0,0x40,0x7a);
    rf_pri_txcal_config(3,val);
    val_00 = rf_pri_txcal_search_core(2,center,0x40,0x7a);
    rf_pri_txcal_config(2,val_00);
    val_01 = rf_pri_txcal_search_core(3,0,0x20,0x7a);
    rf_pri_txcal_config(3,val_01);
    puVar1 = &rf_calib_data->inited + (iVar2 + 0xc) * 2;
    puVar1[2] = puVar1[2] & 0xffffffc0 | val_02 & 0x3f;
    puVar1[2] = puVar1[2] & 0xfffff03f | (uVar5 & 0x3f) << 6;
    puVar1[2] = puVar1[2] & 0xff800fff | (val_00 & 0x7ff) << 0xc;
    puVar1[3] = puVar1[3] & 0xfffffc00 | val_01 & 0x3ff;
    printf("tosdac_i=%ld,tosdac_q=%ld,tx_iq_gain_comp=%ld,tx_iq_phase_comp=%ld\r\n",val_02,uVar5,
           val_00);
    iVar2 = iVar2 + -1;
    puVar3 = puVar3 + 4;
    piVar4 = piVar4 + 0xe;
    if (iVar2 == -1) {
      rf_pri_txcal_config_hw();
      _DAT_4000101c = _DAT_4000101c & 0xffffcfff;
      rf_pri_restore_state_for_cal();
      _DAT_40001014 = _DAT_40001014 | 0xf00000;
      _DAT_40001070 =
           (*(uint *)(rf_calib_data->txcal + 3) >> 6 & 0x3f) << 0x10 |
           (*(uint *)(rf_calib_data->txcal + 3) & 0x3f) << 0x18 | _DAT_40001070 & 0xc0c0ffff;
      _DAT_40001600 =
           *(uint *)&rf_calib_data->txcal[3].field_0x4 & 0x3ff |
           *(uint *)(rf_calib_data->txcal + 3) & 0x7ff000 | _DAT_40001600 & 0xff800c00;
      return;
    }
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_roscal(void)

{
  uint32_t uVar1;
  uint uVar2;
  
  _DAT_40001014 = _DAT_40001014 & 0xffff3fff;
  if ((_DAT_40001020 & 0x100) != 0) {
    _DAT_40001014 = _DAT_40001014 | 0x4000;
    rf_pri_save_state_for_cal();
    rf_pri_manu_pu(3);
    _DAT_4000101c = _DAT_4000101c | 0x200;
    rf_pri_config_channel();
    _DAT_40001048 = _DAT_40001048 & 0xffff8fff | 0x6300;
    uVar1 = rf_pri_roscal_iq(1);
    uVar2 = uVar1 & 0x3f;
    *(uint *)(rf_calib_data->rxcal + 3) = *(uint *)(rf_calib_data->rxcal + 3) & 0xffffffc0 | uVar2;
    _DAT_4000116c = _DAT_4000116c & 0xffc0ffff | uVar1 << 0x10;
    printf("rosdac_i_gc3=%ld\r\n",uVar1);
    *(uint *)(rf_calib_data->rxcal + 2) = *(uint *)(rf_calib_data->rxcal + 2) & 0xffffffc0 | uVar2;
    _DAT_4000116c = uVar1 | _DAT_4000116c & 0xffffffc0;
    printf("rosdac_i_gc2=%ld\r\n",uVar1);
    *(uint *)(rf_calib_data->rxcal + 1) = *(uint *)(rf_calib_data->rxcal + 1) & 0xffffffc0 | uVar2;
    _DAT_40001168 = uVar1 << 0x10 | _DAT_40001168 & 0xffc0ffff;
    printf("rosdac_i_gc1=%ld\r\n",uVar1);
    *(uint *)rf_calib_data->rxcal = *(uint *)rf_calib_data->rxcal & 0xffffffc0 | uVar2;
    _DAT_40001168 = uVar1 | _DAT_40001168 & 0xffffffc0;
    printf("rosdac_i_gc0=%ld\r\n",uVar1);
    uVar1 = rf_pri_roscal_iq(0);
    uVar2 = (uVar1 & 0x3f) << 6;
    *(uint *)(rf_calib_data->rxcal + 3) = *(uint *)(rf_calib_data->rxcal + 3) & 0xfffff03f | uVar2;
    _DAT_4000116c = _DAT_4000116c & 0xc0ffffff | uVar1 << 0x18;
    printf("rosdac_q_gc3=%ld\r\n",uVar1);
    *(uint *)(rf_calib_data->rxcal + 2) = *(uint *)(rf_calib_data->rxcal + 2) & 0xfffff03f | uVar2;
    _DAT_4000116c = _DAT_4000116c & 0xffffc0ff | uVar1 << 8;
    printf("rosdac_q_gc2=%ld\r\n",uVar1);
    *(uint *)(rf_calib_data->rxcal + 1) = *(uint *)(rf_calib_data->rxcal + 1) & 0xfffff03f | uVar2;
    _DAT_40001168 = uVar1 << 0x18 | _DAT_40001168 & 0xc0ffffff;
    printf("rosdac_q_gc1=%ld\r\n",uVar1);
    *(uint *)rf_calib_data->rxcal = *(uint *)rf_calib_data->rxcal & 0xfffff03f | uVar2;
    _DAT_40001168 = uVar1 << 8 | _DAT_40001168 & 0xffffc0ff;
    printf("rosdac_q_gc0=%ld\r\n",uVar1);
    rf_pri_restore_state_for_cal();
    _DAT_40001014 = _DAT_40001014 | 0xc000;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_rccal(void)

{
  rf_calib_data_tag *prVar1;
  uint32_t uVar2;
  uint32_t uVar3;
  uint uVar4;
  uint uVar5;
  
  _DAT_40001014 = _DAT_40001014 & 0xfff3ffff;
  if ((_DAT_40001020 & 0x400) != 0) {
    _DAT_40001014 = _DAT_40001014 | 0x40000;
    rf_pri_save_state_for_cal();
    rf_pri_manu_pu(4);
    _DAT_40001084 = _DAT_40001084 & 0xfcffffff | 0x2000000;
    _DAT_4000108c = _DAT_4000108c | 0x1000;
    _DAT_4000101c = _DAT_4000101c | 0x800;
    uVar2 = rf_pri_rccal_iq(1);
    uVar3 = rf_pri_rccal_iq(0);
    prVar1 = rf_calib_data;
    uVar5 = _DAT_40001080;
    *(uint *)&(rf_calib_data->cal).field_0x4 =
         *(uint *)&(rf_calib_data->cal).field_0x4 & 0xffffffc0 | _DAT_40001080 >> 0x18 & 0x3f;
    *(uint *)&(prVar1->cal).field_0x4 =
         *(uint *)&(prVar1->cal).field_0x4 & 0xfffff03f | (uVar5 >> 0x10 & 0x3f) << 6;
    *(uint *)&(prVar1->cal).field_0x4 =
         *(uint *)&(prVar1->cal).field_0x4 & 0xfffc0fff | (uVar5 >> 8 & 0x3f) << 0xc;
    *(uint *)&(prVar1->cal).field_0x4 =
         (uVar5 & 0x3f) << 0x12 | *(uint *)&(prVar1->cal).field_0x4 & 0xff03ffff;
    printf("rbb_cap1_fc_i=%ld,rbb_cap2_fc_i=%ld,rbb_cap1_fc_q=%ld,rbb_cap2_fc_q=%ld\r\n",
           *(uint *)&(prVar1->cal).field_0x4 & 0x3f,*(uint *)&(prVar1->cal).field_0x4 >> 0xc & 0x3f,
           *(uint *)&(prVar1->cal).field_0x4 >> 6 & 0x3f,
           *(uint *)&(prVar1->cal).field_0x4 >> 0x12 & 0x3f);
    prVar1 = rf_calib_data;
    uVar5 = *(uint *)&(rf_calib_data->cal).field_0x4 & 0x3f;
    if (uVar5 < (*(uint *)&(rf_calib_data->cal).field_0x4 >> 6 & 0x3f)) {
      uVar5 = *(uint *)&(rf_calib_data->cal).field_0x4 >> 6 & 0x3f;
    }
    if (uVar5 < (*(uint *)&(rf_calib_data->cal).field_0x4 >> 0xc & 0x3f)) {
      uVar5 = *(uint *)&(rf_calib_data->cal).field_0x4 >> 0xc & 0x3f;
    }
    if (uVar5 < (*(uint *)&(rf_calib_data->cal).field_0x4 >> 0x12 & 0x3f)) {
      uVar5 = *(uint *)&(rf_calib_data->cal).field_0x4 >> 0x12 & 0x3f;
    }
    uVar4 = 0x18;
    if (0x27 < uVar5) {
      uVar4 = 0x3f - uVar5;
    }
    uVar4 = uVar4 & 0xff;
    *(uint *)&(rf_calib_data->cal).field_0x4 =
         *(uint *)&(rf_calib_data->cal).field_0x4 & 0xffffffc0 |
         *(int *)&(rf_calib_data->cal).field_0x4 + uVar4 & 0x3f;
    *(uint *)&(prVar1->cal).field_0x4 =
         ((*(uint *)&(prVar1->cal).field_0x4 >> 6) + uVar4 & 0x3f) << 6 |
         *(uint *)&(prVar1->cal).field_0x4 & 0xfffff03f;
    *(uint *)&(prVar1->cal).field_0x4 =
         ((*(uint *)&(prVar1->cal).field_0x4 >> 0xc) + uVar4 & 0x3f) << 0xc |
         *(uint *)&(prVar1->cal).field_0x4 & 0xfffc0fff;
    *(uint *)&(prVar1->cal).field_0x4 =
         ((*(uint *)&(prVar1->cal).field_0x4 >> 0x12) + uVar4 & 0x3f) << 0x12 |
         *(uint *)&(prVar1->cal).field_0x4 & 0xff03ffff;
    rf_pri_rccal_config(*(uint *)&(prVar1->cal).field_0x4 & 0x3f);
    rf_pri_rccal_config(0,*(uint *)&(rf_calib_data->cal).field_0x4 >> 6 & 0x3f);
    printf("new rbb_cap1_fc_i=%ld,rbb_cap2_fc_i=%ld,rbb_cap1_fc_q=%ld,rbb_cap2_fc_q=%ld\r\n",
           *(uint *)&(rf_calib_data->cal).field_0x4 & 0x3f,
           *(uint *)&(rf_calib_data->cal).field_0x4 >> 0xc & 0x3f,
           *(uint *)&(rf_calib_data->cal).field_0x4 >> 6 & 0x3f,
           *(uint *)&(rf_calib_data->cal).field_0x4 >> 0x12 & 0x3f);
    rf_pri_restore_state_for_cal();
    if ((uVar2 == 2) || (uVar3 == 2)) {
      _DAT_40001014 = _DAT_40001014 & 0xfff3ffff | 0x80000;
    }
    else {
      _DAT_40001014 = _DAT_40001014 | 0xc0000;
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_lo_acal(void)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  uint32_t *puVar4;
  uint32_t *puVar5;
  uint uVar6;
  
  _DAT_40001014 = _DAT_40001014 & 0xffffff3f | 0x40;
  rf_pri_save_state_for_cal();
  rf_pri_manu_pu(6);
  puVar4 = channel_div_table;
  iVar3 = 0;
  do {
    _DAT_4000101c = _DAT_4000101c | 0x10;
    _DAT_400010a4 = _DAT_400010a4 & 0xfffff8ff | 0x400;
    uVar6 = 3;
    uVar1 = 0x10;
    _DAT_400010a0 =
         (uint)*(ushort *)(&(rf_calib_data->cal).field_0x8 + (iVar3 + 8) * 2) & 0xff |
         _DAT_400010a0 & 0xffe0ff00 | 0x100000;
    _DAT_400010c4 = *puVar4;
    BL602_Delay_US(1);
    while (_DAT_400010a0 = _DAT_400010a0 & 0xffe0ffff | uVar1 << 0x10, uVar6 != 0xffffffff) {
      BL602_Delay_US(1);
      iVar2 = 1 << (uVar6 & 0x1f);
      if ((int)(_DAT_400010a4 << 0x13) < 0) {
        iVar2 = -iVar2;
      }
      uVar1 = uVar1 + iVar2;
      uVar6 = uVar6 - 1;
    }
    BL602_Delay_US(1);
    if ((-1 < (int)(_DAT_400010a4 << 0x13)) && (uVar1 < 0x1f)) {
      uVar1 = uVar1 + 1;
    }
    puVar5 = (uint32_t *)((int)&rf_calib_data->inited + (iVar3 + 8) * 2);
    *(ushort *)(puVar5 + 3) = *(ushort *)(puVar5 + 3) & 0xe0ff | (ushort)((uVar1 & 0x1f) << 8);
    printf("%ldth channel,vco_idac_cw=%ld\r\n",iVar3,uVar1);
    iVar3 = iVar3 + 1;
    puVar4 = puVar4 + 1;
  } while (iVar3 != 0x15);
  rf_pri_restore_state_for_cal();
  _DAT_40001014 = _DAT_40001014 | 0xc0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_fcal(void)

{
  uint cw;
  uint16_t uVar1;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  int iVar2;
  uint32_t *puVar3;
  uint uVar4;
  uint uVar5;
  uint cw_00;
  uint16_t *puVar6;
  uint uVar7;
  
  cw_00 = (uint)channel_cnt_range[0];
  uVar7 = (uint)channel_cnt_range[1];
  uVar5 = (uint)channel_cnt_range[2];
  _DAT_40001014 = _DAT_40001014 & 0xffffffcf | 0x10;
  rf_pri_save_state_for_cal();
  rf_pri_manu_pu(7);
  _DAT_4000101c = _DAT_4000101c | 8;
  _DAT_400010a0 = _DAT_400010a0 & 0xffffff00 | 0x80;
  _DAT_400010a8 = (uint)fcal_div | _DAT_400010a8 & 0xffff0000;
  _DAT_400010c4 = 0x1000000;
  _DAT_400010c0 = _DAT_400010c0 & 0xfffeffff | 0x1000;
  _DAT_400010b8 = _DAT_400010b8 & 0xffffcfff | 0x10000;
  BL602_Delay_US(10);
  _DAT_400010c0 = _DAT_400010c0 | 0x10000;
  _DAT_400010b8 = _DAT_400010b8 & 0xfffeffff;
  BL602_Delay_US(0x32);
  _DAT_400010a4 = _DAT_400010a4 & 0xfffffffc | 2;
  BL602_Delay_US(0x32);
  do {
    uVar4 = 6;
    cw = 0x80;
    while (uVar4 != 0xffffffff) {
      uVar1 = rf_pri_fcal_meas(cw);
      if (CONCAT22(extraout_var,uVar1) < cw_00) {
        iVar2 = -(1 << (uVar4 & 0x1f));
      }
      else {
        if (CONCAT22(extraout_var,uVar1) <= uVar7) break;
        iVar2 = 1 << (uVar4 & 0x1f);
      }
      cw = cw + iVar2 & 0xffff;
      uVar4 = uVar4 - 1;
    }
    if (0xe < cw) break;
    printf("Unexpected cw %ld\r\n",cw);
    _DAT_400010c0 = _DAT_400010c0 & 0xfffeffff;
    _DAT_400010b8 = _DAT_400010b8 | 0x10000;
    BL602_Delay_US(0x32);
    _DAT_400010c0 = _DAT_400010c0 | 0x10000;
    _DAT_400010b8 = _DAT_400010b8 & 0xfffeffff;
    BL602_Delay_US(0x32);
  } while( true );
  cw_00 = cw + 1 & 0xffff;
  channel_cnt_opt_table[0] = rf_pri_fcal_meas(cw_00);
  puVar6 = channel_cnt_opt_table;
  do {
    cw_00 = cw_00 - 1 & 0xffff;
    uVar1 = rf_pri_fcal_meas(cw_00);
    puVar6[1] = uVar1;
    if (uVar5 < CONCAT22(extraout_var_00,uVar1)) break;
    puVar6 = puVar6 + 1;
  } while (cw_00 != (cw - 0x26 & 0xffff));
  iVar2 = 0;
  uVar5 = 0;
  puVar6 = channel_cw_table;
  do {
    while (cw_00 = uVar5 & 0xffff,
          channel_cnt_opt_table[uVar5] < *(ushort *)((int)channel_cnt_table + iVar2)) {
      uVar5 = (int)((cw_00 + 1) * 0x10000) >> 0x10;
    }
    *(short *)((int)channel_cw_table + iVar2) = ((short)cw + 2) - (short)cw_00;
    if ((int)uVar5 < 1) {
      uVar5 = 0;
    }
    else {
      uVar5 = (int)((cw_00 - 1) * 0x10000) >> 0x10;
    }
    iVar2 = iVar2 + 2;
  } while (iVar2 != 0x2a);
  rf_pri_restore_state_for_cal();
  iVar2 = 0;
  do {
    puVar3 = (uint32_t *)((int)&rf_calib_data->inited + (iVar2 + 8) * 2);
    iVar2 = iVar2 + 1;
    *(ushort *)(puVar3 + 3) = *(ushort *)(puVar3 + 3) & 0xff00 | *puVar6 & 0xff;
    printf("%ldth channel,lo_vco_freq_cw=%ld\r\n");
    puVar6 = puVar6 + 1;
  } while (iVar2 != 0x15);
  _DAT_40001014 = _DAT_40001014 | 0x30;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_full_cal(void)

{
  _DAT_40001220 = _DAT_40001220 & 0xffffff9f | 0x61;
  rf_pri_start_txdfe();
  rf_pri_fcal();
  rf_pri_lo_acal();
  rf_pri_roscal();
  rf_pri_rccal();
  rf_pri_txcal();
  _DAT_4000100c = _DAT_4000100c | 6;
  _DAT_40001220 = _DAT_40001220 & 0xffffe61c;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_restore_cal_reg(void)

{
  _DAT_40001168 =
       (*(uint *)(rf_calib_data->rxcal + 1) >> 6 & 0x3f) << 0x18 |
       (*(uint *)rf_calib_data->rxcal >> 6 & 0x3f) << 8 |
       *(uint *)rf_calib_data->rxcal & 0x3f | _DAT_40001168 & 0xc0c0c0c0 |
       (*(uint *)(rf_calib_data->rxcal + 1) & 0x3f) << 0x10;
  _DAT_4000116c =
       (*(uint *)(rf_calib_data->rxcal + 3) >> 6 & 0x3f) << 0x18 |
       (*(uint *)(rf_calib_data->rxcal + 2) >> 6 & 0x3f) << 8 |
       *(uint *)(rf_calib_data->rxcal + 2) & 0x3f | _DAT_4000116c & 0xc0c0c0c0 |
       (*(uint *)(rf_calib_data->rxcal + 3) & 0x3f) << 0x10;
  _DAT_40001080 =
       (*(uint *)&(rf_calib_data->cal).field_0x4 >> 6 & 0x3f) << 0x10 |
       (*(uint *)&(rf_calib_data->cal).field_0x4 >> 0xc & 0x3f) << 8 |
       (*(uint *)&(rf_calib_data->cal).field_0x4 & 0x3f) << 0x18 | _DAT_40001080 & 0xc0c0c0c0 |
       *(uint *)&(rf_calib_data->cal).field_0x4 >> 0x12 & 0x3f;
  rf_pri_txcal_config_hw();
  _DAT_40001070 =
       (*(uint *)(rf_calib_data->txcal + 3) >> 6 & 0x3f) << 0x10 |
       (*(uint *)(rf_calib_data->txcal + 3) & 0x3f) << 0x18 | _DAT_40001070 & 0xc0c0ffff;
  _DAT_40001600 =
       *(uint *)(rf_calib_data->txcal + 3) & 0x7ff000 | _DAT_40001600 & 0xff800c00 |
       *(uint *)&rf_calib_data->txcal[3].field_0x4 & 0x3ff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_init(uint8_t reset,uint8_t chipv)

{
  undefined3 in_register_00002029;
  int iVar1;
  
  iVar1 = CONCAT31(in_register_00002029,reset);
  rf_pri_chipv(chipv);
  init_fast = (uint32_t)(iVar1 == 0);
  _DAT_4000f814 = _DAT_4000f814 & 0xfffff0ff | 0x300;
  _DAT_4000f030 = _DAT_4000f030 & 0xf0ffffff | 0x8000000;
  _DAT_40001030 = _DAT_40001030 | 0x1001;
  _DAT_4000f884 = _DAT_4000f884 | 4;
  if (iVar1 != 0) {
    BL602_Delay_MS(10);
  }
  _DAT_40001064 = _DAT_40001064 & 0xffff8008 | opti_regs->vbcore << 8 | opti_regs->iet << 4 | 0x4002
  ;
  _DAT_40001128 =
       _DAT_40001128 & 0xff800fff | opti_regs->vbcore_11n << 0x10 | opti_regs->iet_11n << 0xc |
       0x400000;
  _DAT_4000112c =
       (_DAT_4000112c & 0xfffff800 | opti_regs->vbcore_11g << 4 | opti_regs->iet_11g) & 0xff800fff |
       0x400 | opti_regs->vbcore_11b << 0x10 | opti_regs->iet_11b << 0xc | 0x400000;
  _DAT_40001090 = _DAT_40001090 | 0x10000;
  _DAT_400010b8 = opti_regs->lo_fbdv_halfstep_en << 4 | _DAT_400010b8 & 0xffffffef;
  _DAT_40001138 =
       (_DAT_40001138 & 0xfffffffc | opti_regs->lo_fbdv_halfstep_en_tx << 1 |
       opti_regs->lo_fbdv_halfstep_en_tx) & 0xfffcfff7 | 0x300;
  _DAT_40001130 = _DAT_40001130 & 0xfffefffe;
  _DAT_4000e400 = opti_regs->clkpll_reset_postdiv << 1 | _DAT_4000e400 & 0xfffffffd;
  _DAT_4000e418 = opti_regs->clkpll_dither_sel << 0x18 | _DAT_4000e418 & 0xfcffffff;
  _DAT_4000108c = _DAT_4000108c & 0xfffffffc | 2;
  _DAT_4000f030 = _DAT_4000f030 & 0xfff0ffff | 0xc0000;
  rf_pri_set_gain_table_regs();
  _DAT_4000e404 = _DAT_4000e404 | 0x10000;
  _DAT_4000e41c = _DAT_4000e41c | 0xff;
  if (iVar1 == 0) {
    rf_pri_restore_cal_reg();
    return;
  }
  rf_pri_full_cal();
  return;
}



void rf_pri_update_power_offset(int32_t *power_offset)

{
  undefined4 uVar1;
  int iVar2;
  
  iVar2 = 0;
  do {
    uVar1 = *(undefined4 *)((int)power_offset + iVar2);
    *(undefined4 *)((int)tx_pwr_ch_os_a1 + iVar2) = uVar1;
    *(undefined4 *)((int)tx_pwr_ch_os + iVar2) = uVar1;
    iVar2 = iVar2 + 4;
  } while (iVar2 != 0x38);
  return;
}



int phyif_utils_decode(phyif_utils_recvtable_t *vec,int8_t *ppm)

{
  char cVar1;
  int8_t iVar2;
  SItype SVar3;
  
  cVar1 = *(char *)((int)&vec->recvtable5 + 3);
  if (((*(ushort *)((int)&vec->recvtable2 + 2) & 7) < 2) && ((vec->recvtable1 >> 0xc & 0xf) < 4)) {
    __floatsidf(-(int)cVar1);
    __muldf3();
    SVar3 = __fixdfsi();
    iVar2 = (int8_t)SVar3;
  }
  else {
    iVar2 = (int8_t)((int)CONCAT11(*(undefined *)&vec->recvtable6,cVar1) / 0x7a);
  }
  *ppm = iVar2;
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void sysctrl_init(void)

{
  _DAT_44900068 = 0x8000000c;
  _DAT_449000e0 = _DAT_449000e0 | 0x1ff00;
  return;
}



void intc_spurious(void)

{
  assert_err("0","module",0x36);
  return;
}



void intc_enable_irq(int index)

{
  *(int *)(((index >> 5) + 0x11244004) * 4) = 1 << (index & 0x1fU);
  return;
}



void intc_init(void)

{
  intc_enable_irq(0x3f);
  intc_enable_irq(0x3e);
  intc_enable_irq(0x3d);
  intc_enable_irq(0x18);
  intc_enable_irq(0x19);
  intc_enable_irq(0x1a);
  intc_enable_irq(0x1b);
  intc_enable_irq(0x1c);
  intc_enable_irq(0x1d);
  intc_enable_irq(0x1e);
  intc_enable_irq(0x1f);
  intc_enable_irq(0x20);
  intc_enable_irq(0x21);
  intc_enable_irq(0x23);
  intc_enable_irq(0x37);
  intc_enable_irq(0x35);
  intc_enable_irq(0x32);
  intc_enable_irq(0x34);
  intc_enable_irq(0x36);
  intc_enable_irq(10);
  intc_enable_irq(0xb);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mac_irq(void)

{
  void_fn *pvVar1;
  
  if ((_DAT_44910000 == 0) && (_DAT_44910004 == 0)) {
    return;
  }
  pvVar1 = intc_irq_handlers[_DAT_44910040];
  if (pvVar1 == (void_fn *)0x0) {
    assert_err("intc_irq_handlers[irq_idx] != NULL","module",0x9d);
  }
  (*pvVar1)();
  ipc_emb_notify();
  return;
}



void bl_irq_handler(void)

{
  ipc_host_disable_irq_e2a();
  ke_evt_set(0x40000000);
  ipc_emb_notify();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void blmac_pwr_mgt_setf(uint8_t pwrmgt)

{
  uint uVar1;
  undefined3 in_register_00002029;
  
  uVar1 = CONCAT31(in_register_00002029,pwrmgt) << 2;
  if ((uVar1 & 0xfffffffb) != 0) {
    assert_err("(((uint32_t)pwrmgt << 2) & ~((uint32_t)0x00000004)) == 0","module",0x952);
  }
  _DAT_44b0004c = _DAT_44b0004c & 0xfffffffb | uVar1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

chan_ctxt_tag * chan_get_next_chan(void)

{
  int iVar1;
  int iVar2;
  chan_ctxt_tag *pcVar3;
  uint uVar4;
  ushort uVar5;
  
  iVar2 = _DAT_44b00120;
  iVar1 = DAT_4201e2e0;
  if (DAT_4201e2f0 != (chan_ctxt_tag *)0x0) {
    if ((DAT_4201e2e0 != 0) && (*(char *)(DAT_4201e2e0 + 10) == '\x02')) {
      return DAT_4201e2f0;
    }
    if (-1 < (_DAT_44b00120 + 0x1400) - DAT_4201e314) {
      return DAT_4201e2f0;
    }
    if (DAT_4201e2f0->status == '\x04') {
      return DAT_4201e2f0;
    }
  }
  pcVar3 = DAT_4201e2f0;
  if ((DAT_4201e2e0 != 0) && (*(int *)(DAT_4201e2e0 + 4) - DAT_4201e314 < 0)) {
    pcVar3 = vif_info_tab[*(byte *)(DAT_4201e2e0 + 8)].chan_ctxt;
    if (pcVar3 == (chan_ctxt_tag *)0x0) {
      assert_err("p_next_chan_entry","module",0x129);
    }
    if (-1 < (iVar2 + 0x1400) - *(int *)(iVar1 + 4)) goto LAB_2305b3e0;
    uVar4 = 0;
    if (pcVar3->nb_res_slots < pcVar3->nb_rem_slots) {
      uVar4 = (uint)(ushort)(pcVar3->nb_rem_slots - pcVar3->nb_res_slots);
    }
    if (((uint)(*(int *)(iVar1 + 4) - iVar2) >> 10 & 0xffff) <= uVar4) {
      return pcVar3;
    }
  }
  uVar5 = 0;
  if (chan_ctxt_pool[0].status != '\0') {
    pcVar3 = chan_ctxt_pool;
    uVar5 = chan_ctxt_pool[0].nb_rem_slots;
  }
  if ((chan_ctxt_pool[1].status != '\0') && (uVar5 <= chan_ctxt_pool[1].nb_rem_slots)) {
    pcVar3 = chan_ctxt_pool + 1;
    uVar5 = chan_ctxt_pool[1].nb_rem_slots;
  }
  if ((chan_ctxt_pool[2].status != '\0') && (uVar5 <= chan_ctxt_pool[2].nb_rem_slots)) {
    return chan_ctxt_pool + 2;
  }
LAB_2305b3e0:
  if (pcVar3 == (chan_ctxt_tag *)0x0) {
    assert_err("p_next_chan_entry","module",0x175);
  }
  return pcVar3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void chan_conn_less_delay_prog(void)

{
  DAT_4201e340 = DAT_4201e340 | 0x10;
  mm_timer_set((mm_timer_tag *)&DAT_4201e328,_DAT_44b00120 + 30000);
  return;
}



void chan_upd_nb_rem_slots(uint32_t current_time)

{
  ushort uVar1;
  ushort uVar2;
  int in_a1;
  uint uVar3;
  
  uVar1 = *(ushort *)current_time;
  uVar3 = (uint)(in_a1 - DAT_4201e33c) >> 10 & 0xffff;
  uVar2 = (ushort)uVar3;
  if (uVar1 < uVar3) {
    uVar2 = uVar1;
  }
  *(ushort *)current_time = uVar1 - uVar2;
  return;
}



_Bool chan_tbtt_detect_conflict(void)

{
  byte bVar1;
  int in_a0;
  int in_a1;
  
  if (((in_a0 - in_a1 < 0) || (bVar1 = 1, (in_a1 + 0x2800) - in_a0 < 0)) &&
     (bVar1 = 0, -1 < in_a1 - in_a0)) {
    bVar1 = ~(byte)((uint)((in_a0 - in_a1) + 0x2800) >> 0x18) >> 7;
  }
  return (_Bool)bVar1;
}



void chan_tbtt_insert(chan_tbtt_tag *p_tbtt_entry)

{
  bool bVar1;
  co_list_hdr list_hdr;
  char cVar2;
  _Bool _Var3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  co_list_hdr cVar4;
  uint uVar5;
  uint uVar6;
  co_list_hdr prev_element;
  co_list_hdr cVar7;
  
  list_hdr = (co_list_hdr)0x0;
  cVar2 = '\0';
  cVar4 = DAT_4201e2e0;
  prev_element = (co_list_hdr)0x0;
  while (cVar4 != (co_list_hdr)0x0) {
    if (cVar4 == (co_list_hdr)p_tbtt_entry) {
      assert_err("p_elem != p_tbtt_entry","module",0x668);
    }
    uVar5 = p_tbtt_entry->time;
    uVar6 = *(uint *)((int)cVar4 + 4);
    cVar7 = cVar4;
    if (*(char *)((int)cVar4 + 10) == '\x02') {
      if ((uVar5 < uVar6) ||
         (_Var3 = chan_tbtt_detect_conflict(), CONCAT31(extraout_var_00,_Var3) != 0)) {
LAB_2305b550:
        cVar2 = '\x01';
        bVar1 = false;
        list_hdr = (co_list_hdr)p_tbtt_entry;
        goto LAB_2305b598;
      }
    }
    else {
      _Var3 = chan_tbtt_detect_conflict();
      if (CONCAT31(extraout_var,_Var3) == 0) {
        if (uVar5 < uVar6) break;
      }
      else {
        if (p_tbtt_entry->priority <= *(byte *)((int)cVar4 + 9)) goto LAB_2305b550;
        if (list_hdr == (co_list_hdr)0x0) {
          list_hdr = cVar4;
        }
        cVar2 = cVar2 + '\x01';
        cVar7 = prev_element;
      }
    }
    cVar4 = *(co_list_hdr *)cVar4;
    prev_element = cVar7;
  }
  bVar1 = true;
LAB_2305b598:
  while (cVar2 = cVar2 + -1, cVar2 != -1) {
    if (list_hdr == (co_list_hdr)0x0) {
      assert_err("p_delay_elem","module",0x6b1);
    }
    if (list_hdr != (co_list_hdr)p_tbtt_entry) {
      if (*(char *)((int)list_hdr + 10) == '\x01') {
        mm_timer_clear((mm_timer_tag *)&DAT_4201e2f8);
        *(undefined *)((int)list_hdr + 10) = 0;
      }
      co_list_extract((co_list *)&DAT_4201e2e0,(co_list_hdr *)list_hdr);
    }
    co_list_push_back((co_list *)&DAT_4201e2e8,(co_list_hdr *)list_hdr);
    list_hdr = *(co_list_hdr *)list_hdr;
  }
  if (!bVar1) {
    return;
  }
  co_list_insert_after
            ((co_list *)&DAT_4201e2e0,(co_list_hdr *)prev_element,(co_list_hdr *)p_tbtt_entry);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void chan_upd_ctxt_status(chan_ctxt_tag *p_chan_entry,uint8_t next_status)

{
  undefined3 in_register_0000202d;
  int iVar1;
  ushort uVar2;
  int iVar3;
  uint32_t value;
  
  iVar1 = CONCAT31(in_register_0000202d,next_status);
  if (iVar1 == 2) {
    value = 0;
    if (2 < p_chan_entry->idx) goto LAB_2305b610;
    iVar3 = 4000;
  }
  else {
    value = 0;
    if (iVar1 != 4) goto LAB_2305b610;
    if (p_chan_entry->idx < 3) {
      if (1 < DAT_4201e342) {
        if ((p_chan_entry->nb_res_slots < p_chan_entry->nb_rem_slots) &&
           (uVar2 = p_chan_entry->nb_rem_slots - p_chan_entry->nb_res_slots, 4 < uVar2)) {
          iVar3 = (uint)uVar2 << 10;
          DAT_4201e33c = _DAT_44b00120;
          goto LAB_2305b60e;
        }
      }
      iVar1 = 5;
      value = 0;
      goto LAB_2305b610;
    }
    iVar3 = (uint)p_chan_entry->nb_rem_slots << 10;
  }
LAB_2305b60e:
  value = iVar3 + _DAT_44b00120;
LAB_2305b610:
  p_chan_entry->status = (uint8_t)iVar1;
  if (value != 0) {
    DAT_4201e320 = p_chan_entry;
    mm_timer_set((mm_timer_tag *)&DAT_4201e318,value);
    return;
  }
  if (iVar1 != 3) {
    mm_timer_clear((mm_timer_tag *)&DAT_4201e318);
    return;
  }
  return;
}



void chan_switch_start(chan_ctxt_tag *p_chan_entry)

{
  undefined4 *puVar1;
  
  if (DAT_4201e2f0 == p_chan_entry) {
    if ((1 < DAT_4201e342) && (DAT_4201e2f0->idx < 3)) {
      chan_upd_ctxt_status(p_chan_entry,'\x04');
      return;
    }
  }
  else {
    if (DAT_4201e2f4 == (chan_ctxt_tag *)0x0) {
      DAT_4201e2f4 = p_chan_entry;
      chan_upd_ctxt_status(p_chan_entry,'\x02');
      puVar1 = (undefined4 *)ke_msg_alloc(0x60,0,0xff,4);
      *puVar1 = 0x2305bcd8;
      ke_msg_send();
      return;
    }
  }
  return;
}



void chan_conn_less_delay_evt(void *env)

{
  chan_ctxt_tag *p_chan_entry;
  
  if ((DAT_4201e340 & 1) == 0) {
    if ((DAT_4201e340 & 2) == 0) {
      return;
    }
    if ((DAT_4201e340 & 8) != 0) {
      assert_err("(chan_env.status & CO_BIT(CHAN_ENV_SCAN_BIT)) == 0","module",0x2ce);
    }
    p_chan_entry = chan_ctxt_pool + 3;
    DAT_4201e340 = DAT_4201e340 & 0xfd | 8;
  }
  else {
    if ((DAT_4201e340 & 4) != 0) {
      assert_err("(chan_env.status & CO_BIT(CHAN_ENV_ROC_BIT)) == 0","module",0x2c0);
    }
    p_chan_entry = chan_ctxt_pool + 4;
    DAT_4201e340 = DAT_4201e340 & 0xfe | 4;
  }
  if (DAT_4201e2f4 != 0) {
    return;
  }
  chan_switch_start(p_chan_entry);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void chan_tbtt_switch_evt(void *env)

{
  ushort uVar1;
  undefined4 uVar2;
  ushort uVar3;
  chan_ctxt_tag *p_chan_entry;
  
  uVar2 = _DAT_44b00120;
  if ((1 < DAT_4201e342) && ((DAT_4201e340 & 0xc) == 0)) {
    p_chan_entry = vif_info_tab[*(byte *)((int)env + 8)].chan_ctxt;
    if ((DAT_4201e2f4 == (chan_ctxt_tag *)0x0) || (DAT_4201e2f4 == p_chan_entry)) {
      *(undefined *)((int)env + 9) = 0;
      chan_upd_nb_rem_slots(DAT_4201e2f0 + 0x12);
      uVar1 = p_chan_entry->nb_res_slots;
      uVar3 = uVar1;
      if (10 < uVar1) {
        uVar3 = 10;
      }
      p_chan_entry->nb_res_slots = uVar1 - uVar3;
      DAT_4201e33c = uVar2;
      *(undefined *)((int)env + 10) = 2;
      if (DAT_4201e2f4 == (chan_ctxt_tag *)0x0) {
        chan_switch_start(p_chan_entry);
        return;
      }
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void chan_tbtt_schedule(chan_tbtt_tag *p_tbtt_entry)

{
  void *pvVar1;
  chan_tbtt_tag *p_tbtt_entry_00;
  uint uVar2;
  uint32_t uVar3;
  
  if (p_tbtt_entry != (chan_tbtt_tag *)0x0) {
    chan_tbtt_insert(p_tbtt_entry);
    while (DAT_4201e2e8 != 0) {
      p_tbtt_entry_00 = (chan_tbtt_tag *)co_list_pop_front((co_list *)&DAT_4201e2e8);
      uVar2 = (uint)p_tbtt_entry_00->vif_index;
      if (vif_info_tab[uVar2].type == '\0') {
        uVar3 = sta_info_tab[vif_info_tab[uVar2].u[4]].bcn_int;
      }
      else {
        uVar3 = (uint)*(ushort *)(vif_info_tab[uVar2].u + 0x2e2) << 10;
      }
      p_tbtt_entry_00->time = uVar3 + p_tbtt_entry_00->time;
      if (p_tbtt_entry_00->priority < 5) {
        p_tbtt_entry_00->priority = p_tbtt_entry_00->priority + 1;
      }
      chan_tbtt_insert(p_tbtt_entry_00);
    }
  }
  pvVar1 = DAT_4201e2e0;
  if ((DAT_4201e2e0 != (void *)0x0) && (*(char *)((int)DAT_4201e2e0 + 10) == '\0')) {
    if ((*(int *)((int)DAT_4201e2e0 + 4) - _DAT_44b00120) + -2000 < 0) {
      chan_tbtt_switch_evt(DAT_4201e2e0);
      return;
    }
    DAT_4201e300 = DAT_4201e2e0;
    *(undefined *)((int)DAT_4201e2e0 + 10) = 1;
    mm_timer_set((mm_timer_tag *)&DAT_4201e2f8,*(uint32_t *)((int)pvVar1 + 4));
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void chan_cde_evt(void *env)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  chan_ctxt_tag *p_chan_entry;
  int iVar4;
  co_list_hdr *pcVar5;
  co_list_hdr cVar6;
  undefined2 uVar7;
  ushort uVar8;
  uint uVar9;
  
  iVar4 = _DAT_44b00120;
  p_chan_entry = DAT_4201e2f4;
  if ((1 < DAT_4201e342) && (uVar2 = (uint)DAT_4201e340 & 0x2c, (DAT_4201e340 & 0x2c) == 0)) {
    mm_timer_set((mm_timer_tag *)&DAT_4201e308,DAT_4201e338 + _DAT_44b00120);
    DAT_4201e33c = iVar4;
    uVar9 = 0;
    cVar6 = (co_list_hdr)vif_mgmt_env.used_list.first;
    while (cVar6 != (co_list_hdr)0x0) {
      pcVar5 = ((co_list_hdr *)((int)cVar6 + 0x40))->next;
      if (pcVar5 != (co_list_hdr *)0x0) {
        uVar2 = uVar2 + 1 & 0xff;
        if (((td_env[*(byte *)((int)cVar6 + 0x57)].status & 3) != 0) ||
           (*(char *)&((co_list_hdr *)((int)cVar6 + 0x58))->next == '\0')) {
          uVar9 = uVar9 + 1 & 0xff;
        }
        *(undefined2 *)&pcVar5[4].next = 0;
        *(undefined2 *)&pcVar5[5].next = 0;
      }
      cVar6 = *(co_list_hdr *)cVar6;
    }
    if (uVar2 != DAT_4201e338 / 0xc800) {
      assert_warn("nb_vifs == (chan_env.cde_dur_us / (CHAN_VIF_NB_SLOTS * CHAN_SLOT_DURATION_US))",
                  "module",0x268);
    }
    if ((uVar9 == 0) || (uVar2 == uVar9)) {
      iVar3 = 0;
      iVar4 = 0x32;
    }
    else {
      iVar4 = 10;
      iVar3 = (int)((uVar2 - uVar9) * 0x280000 >> 0x10) / (int)uVar9;
    }
    cVar6 = (co_list_hdr)vif_mgmt_env.used_list.first;
    while (cVar6 != (co_list_hdr)0x0) {
      pcVar5 = ((co_list_hdr *)((int)cVar6 + 0x40))->next;
      if (pcVar5 != (co_list_hdr *)0x0) {
        if (((td_env[*(byte *)((int)cVar6 + 0x57)].status & 3) != 0) ||
           (iVar1 = iVar4, *(char *)&((co_list_hdr *)((int)cVar6 + 0x58))->next == '\0')) {
          iVar1 = iVar3 + 0x32;
        }
        uVar7 = (undefined2)(((uint)*(ushort *)&pcVar5[4].next + iVar1) * 0x10000 >> 0x10);
        *(undefined2 *)&pcVar5[4].next = uVar7;
        *(undefined2 *)((int)&pcVar5[4].next + 2) = uVar7;
        if (*(char *)((int)cVar6 + 0x56) == '\0') {
          uVar2 = sta_info_tab[*(byte *)&((co_list_hdr *)((int)cVar6 + 0x60))->next].bcn_int;
        }
        else {
          uVar2 = (uint)*(ushort *)((int)cVar6 + 0x33e) << 10;
        }
        uVar8 = (ushort)(DAT_4201e338 / uVar2);
        if (DAT_4201e338 / uVar2 == 0) {
          uVar8 = 1;
        }
        *(ushort *)&pcVar5[5].next = (uVar8 & 0xff) * 10 + *(short *)&pcVar5[5].next;
      }
      cVar6 = *(co_list_hdr *)cVar6;
    }
    if (DAT_4201e2f0 != (chan_ctxt_tag *)0x0) {
      chan_upd_ctxt_status(DAT_4201e2f0,'\x01');
    }
    p_chan_entry = chan_get_next_chan();
    if (env == (void *)0x0) {
      chan_switch_start(p_chan_entry);
      return;
    }
  }
  DAT_4201e2f4 = p_chan_entry;
  return;
}


/*
Unable to decompile 'chan_pre_switch_channel'
Cause: Exception while decompiling 2305bae4: Decompiler process died

*/


void chan_goto_idle_cb(void)

{
  undefined uVar1;
  co_list_hdr *pcVar2;
  co_list_hdr cVar3;
  uint8_t uVar4;
  undefined3 extraout_var;
  int iVar5;
  
  mm_force_idle_req();
  pcVar2 = DAT_4201e2f0;
  cVar3 = (co_list_hdr)vif_mgmt_env.used_list.first;
  if (((DAT_4201e2f0 != (co_list_hdr *)0x0) && ((DAT_4201e340 & 0x20) == 0)) &&
     ((ps_env.ps_on == false || ((ps_env.prevent_sleep & 8) != 0)))) {
    iVar5 = 0;
    blmac_pwr_mgt_setf('\x01');
    while (cVar3 != (co_list_hdr)0x0) {
      if ((((pcVar2 == ((co_list_hdr *)((int)cVar3 + 0x40))->next) &&
           (*(char *)((int)cVar3 + 0x56) == '\0')) &&
          (*(char *)&((co_list_hdr *)((int)cVar3 + 0x58))->next != '\0')) &&
         (*(char *)&((co_list_hdr *)((int)cVar3 + 0x60))->next != -1)) {
        uVar1 = *(undefined *)((int)&pcVar2[5].next + 2);
        *(undefined *)((int)&pcVar2[5].next + 2) = 6;
        uVar4 = txl_frame_send_null_frame
                          (*(uint8_t *)&((co_list_hdr *)((int)cVar3 + 0x60))->next,chan_tx_cfm,
                           (void *)0x0);
        if (CONCAT31(extraout_var,uVar4) == 0) {
          iVar5 = iVar5 + 1;
        }
        *(undefined *)((int)&pcVar2[5].next + 2) = uVar1;
      }
      cVar3 = *(co_list_hdr *)cVar3;
    }
    DAT_4201e341 = (undefined)iVar5;
    if (iVar5 != 0) {
      chan_upd_ctxt_status(DAT_4201e2f4,'\x03');
      mm_active();
      return;
    }
  }
  chan_pre_switch_channel();
  return;
}



void chan_tx_cfm(void *dummy,uint32_t status)

{
  if (DAT_4201e341 == '\0') {
    assert_err("chan_env.cfm_cnt","module",0x48f);
  }
  DAT_4201e341 = DAT_4201e341 + -1;
  if (DAT_4201e341 == '\0') {
    mm_force_idle_req();
    chan_pre_switch_channel();
    return;
  }
  return;
}


/*
Unable to decompile 'chan_ctxt_op_evt'
Cause: Exception while decompiling 2305be10: Decompiler process died

*/


void chan_init(void)

{
  chan_ctxt_tag *__s;
  int iVar1;
  
  __s = chan_ctxt_pool;
  memset(&chan_env,0,0x74);
  iVar1 = 0;
  do {
    memset(__s,0,0x1c);
    *(undefined2 *)(&__s->channel + 1) = 0xff;
    *(undefined *)((int)&__s->nb_res_slots + 3) = 0xff;
    if (iVar1 < 3) {
      co_list_push_back((co_list *)&chan_env,(co_list_hdr *)__s);
    }
    else {
      if (iVar1 == 3) {
        chan_ctxt_pool[3].channel.center2_freq = 0;
        chan_ctxt_pool[3].channel.type = '\0';
      }
    }
    iVar1 = iVar1 + 1;
    __s = __s + 1;
  } while (iVar1 != 5);
  DAT_4201e2fc = chan_tbtt_switch_evt;
  DAT_4201e30c = chan_cde_evt;
  DAT_4201e310 = 0;
  DAT_4201e31c = chan_ctxt_op_evt;
  DAT_4201e32c = chan_conn_less_delay_evt;
  return;
}



void chan_scan_req(uint8_t band,uint16_t freq,int8_t pwr,uint32_t duration_us,uint8_t vif_index)

{
  if (chan_ctxt_pool[3].idx != -1) {
    assert_err("p_scan_chan->idx == CHAN_CTXT_UNUSED","module",0x8a1);
  }
  chan_ctxt_pool[3].taskid = 0xff;
  chan_ctxt_pool[3]._22_2_ = 0x301;
  chan_ctxt_pool[3].nb_rem_slots = (uint16_t)(duration_us >> 10);
  if ((DAT_4201e340 & 0x10) == 0) {
    chan_ctxt_pool[3].channel.band = band;
    chan_ctxt_pool[3].channel.prim20_freq = freq;
    chan_ctxt_pool[3].channel.center1_freq = freq;
    chan_ctxt_pool[3].channel.tx_power = pwr;
    chan_ctxt_pool[3].vif_index = vif_index;
    DAT_4201e340 = DAT_4201e340 | 2;
    chan_conn_less_delay_prog();
    return;
  }
  chan_ctxt_pool[3].channel.band = band;
  chan_ctxt_pool[3].channel.prim20_freq = freq;
  chan_ctxt_pool[3].channel.center1_freq = freq;
  chan_ctxt_pool[3].channel.tx_power = pwr;
  chan_ctxt_pool[3].taskid = 0xff;
  chan_ctxt_pool[3]._22_2_ = 0x301;
  chan_ctxt_pool[3].vif_index = vif_index;
  DAT_4201e340 = DAT_4201e340 | 2;
  return;
}



uint8_t chan_roc_req(mm_remain_on_channel_req *req,ke_task_id_t taskid)

{
  byte bVar1;
  undefined2 in_register_0000202e;
  
  if (req->op_code == '\0') {
    if (chan_ctxt_pool[4].idx == -1) {
      chan_ctxt_pool[4].idx = '\x04';
      chan_ctxt_pool[4].channel.band = req->band;
      chan_ctxt_pool[4].channel.type = req->type;
      chan_ctxt_pool[4].channel.prim20_freq = req->prim20_freq;
      chan_ctxt_pool[4].channel.center1_freq = req->center1_freq;
      chan_ctxt_pool[4].channel.center2_freq = req->center2_freq;
      chan_ctxt_pool[4].status = '\x01';
      chan_ctxt_pool[4].nb_rem_slots = (uint16_t)(req->duration_ms * 1000 >> 10);
      chan_ctxt_pool[4].vif_index = req->vif_index;
      chan_ctxt_pool[4].channel.tx_power = req->tx_power;
      chan_ctxt_pool[4].taskid = taskid;
      if (CONCAT22(in_register_0000202e,taskid) != 0) {
        bVar1 = DAT_4201e340 & 0x10;
        if ((DAT_4201e340 & 0x10) != 0) {
          chan_ctxt_pool[4].status = '\x01';
          chan_ctxt_pool[4].idx = '\x04';
          DAT_4201e340 = DAT_4201e340 | 1;
          return '\0';
        }
        DAT_4201e340 = DAT_4201e340 | 1;
        chan_conn_less_delay_prog();
        return bVar1;
      }
      DAT_4201e340 = DAT_4201e340 | 4;
      if (DAT_4201e2f4 != 0) {
        chan_ctxt_pool[4].status = '\x01';
        chan_ctxt_pool[4].idx = '\x04';
        return '\0';
      }
      chan_switch_start(chan_ctxt_pool + 4);
      return '\0';
    }
  }
  else {
    if (req->op_code == '\x01') {
      if (chan_ctxt_pool[4].idx != -1) {
        if (chan_ctxt_pool[4].status < 4) {
          if (chan_ctxt_pool[4].status < 2) {
            if (chan_ctxt_pool[4].status == '\x01') {
              DAT_4201e340 = DAT_4201e340 & 0xfe;
            }
          }
          else {
            DAT_4201e2f4 = 0;
            DAT_4201e340 = DAT_4201e340 & 0xfb;
          }
        }
        else {
          if (chan_ctxt_pool[4].status == '\x04') {
            mm_timer_clear((mm_timer_tag *)&DAT_4201e318);
            chan_ctxt_op_evt(chan_ctxt_pool + 4);
          }
        }
        chan_ctxt_pool[4].idx = -1;
        if ((DAT_4201e340 & 0x12) == 0x10) {
          DAT_4201e340 = DAT_4201e340 & 0xef;
          mm_timer_clear((mm_timer_tag *)&DAT_4201e328);
          DAT_4201e340 = DAT_4201e340 & 0xef;
        }
      }
      return '\0';
    }
  }
  return '\x01';
}



uint8_t chan_ctxt_add(mm_chan_ctxt_add_req *p_add_req,uint8_t *idx)

{
  uint8_t uVar1;
  int iVar2;
  co_list_hdr *pcVar3;
  int iVar4;
  chan_ctxt_tag *pcVar5;
  
  pcVar5 = chan_ctxt_pool;
  iVar4 = 0;
  do {
    if (pcVar5->idx != -1) {
      iVar2 = memcmp(p_add_req,&pcVar5->channel,8);
      if (iVar2 == 0) {
        *idx = (uint8_t)iVar4;
        return (uint8_t)iVar2;
      }
    }
    iVar4 = iVar4 + 1;
    pcVar5 = pcVar5 + 1;
  } while (iVar4 != 3);
  pcVar3 = co_list_pop_front((co_list *)&chan_env);
  if (pcVar3 != (co_list_hdr *)0x0) {
    uVar1 = (char)((int)(pcVar3 + -0x10807891) >> 2) * -0x49;
    *(uint8_t *)((int)&pcVar3[5].next + 3) = uVar1;
    *idx = uVar1;
    *(uint8_t *)&pcVar3[1].next = p_add_req->band;
    *(uint8_t *)((int)&pcVar3[1].next + 1) = p_add_req->type;
    *(uint16_t *)&pcVar3[2].next = p_add_req->center1_freq;
    *(uint16_t *)((int)&pcVar3[2].next + 2) = p_add_req->center2_freq;
    *(uint16_t *)((int)&pcVar3[1].next + 2) = p_add_req->prim20_freq;
    *(int8_t *)&pcVar3[3].next = p_add_req->tx_power;
  }
  return (uint8_t)(pcVar3 == (co_list_hdr *)0x0);
}



void chan_ctxt_del(uint8_t chan_idx)

{
  undefined3 in_register_00002029;
  int iVar1;
  
  iVar1 = CONCAT31(in_register_00002029,chan_idx);
  if (chan_ctxt_pool[iVar1].idx == -1) {
    assert_err("p_chan_entry->idx != CHAN_CTXT_UNUSED","module",0x989);
  }
  if (chan_ctxt_pool[iVar1].nb_linked_vif != '\0') {
    assert_err("p_chan_entry->nb_linked_vif == 0","module",0x98b);
  }
  co_list_push_back((co_list *)&chan_env,(co_list_hdr *)(chan_ctxt_pool + iVar1));
  memset(chan_ctxt_pool + iVar1,0,0x1c);
  chan_ctxt_pool[iVar1].taskid = 0xff;
  chan_ctxt_pool[iVar1].idx = -1;
  return;
}


/*
Unable to decompile 'chan_ctxt_update'
Cause: Exception while decompiling 2305c3ae: Decompiler process died

*/


void chan_tbtt_switch_update(vif_info_tag *p_vif_entry,uint32_t tbtt_time)

{
  if ((((p_vif_entry->chan_ctxt != (chan_ctxt_tag *)0x0) && (p_vif_entry->chan_ctxt->status != '\0')
       ) && ((p_vif_entry->tbtt_switch).time != tbtt_time - 0x9c4)) &&
     (((p_vif_entry->tbtt_switch).time = tbtt_time - 0x9c4, 1 < DAT_4201e342 &&
      ((p_vif_entry->tbtt_switch).status != '\x02')))) {
    (p_vif_entry->tbtt_switch).status = '\0';
    co_list_extract((co_list *)&DAT_4201e2e0,(co_list_hdr *)&p_vif_entry->tbtt_switch);
    chan_tbtt_schedule(&p_vif_entry->tbtt_switch);
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void chan_bcn_to_evt(vif_info_tag *p_vif_entry)

{
  ushort uVar1;
  int iVar2;
  chan_ctxt_tag *p_chan_entry;
  ushort uVar3;
  uint uVar4;
  
  iVar2 = _DAT_44b00120;
  if ((p_vif_entry->tbtt_switch).status == '\x02') {
    (p_vif_entry->tbtt_switch).status = '\0';
    p_chan_entry = DAT_4201e2f0;
    co_list_extract((co_list *)&DAT_4201e2e0,(co_list_hdr *)&p_vif_entry->tbtt_switch);
    if (((1 < DAT_4201e342) &&
        (chan_tbtt_schedule(&p_vif_entry->tbtt_switch), (DAT_4201e340 & 0xc) == 0)) &&
       (DAT_4201e2f4 == 0)) {
      chan_upd_nb_rem_slots((uint32_t)&p_chan_entry->nb_rem_slots);
      uVar1 = p_chan_entry->nb_res_slots;
      if (uVar1 != 0) {
        uVar4 = (uint)(iVar2 - DAT_4201e33c) >> 10 & 0xffff;
        uVar3 = (ushort)uVar4;
        if (uVar1 < uVar4) {
          uVar3 = uVar1;
        }
        p_chan_entry->nb_res_slots = uVar1 - uVar3;
      }
      DAT_4201e33c = iVar2;
      p_chan_entry = chan_get_next_chan();
      if (DAT_4201e2f0 != p_chan_entry) {
        chan_switch_start(p_chan_entry);
        return;
      }
    }
  }
  return;
}



void chan_bcn_detect_start(vif_info_tag *p_vif_entry)

{
  byte bVar1;
  chan_ctxt_tag *pcVar2;
  undefined *puVar3;
  
  pcVar2 = p_vif_entry->chan_ctxt;
  if (pcVar2 == (chan_ctxt_tag *)0x0) {
    assert_err("p_chan_entry","module",0xb19);
  }
  if (((DAT_4201e340 & 0x40) == 0) && (1 < DAT_4201e342)) {
    bVar1 = p_vif_entry->u[4];
    puVar3 = (undefined *)ke_msg_alloc(0x46,0,0,0x14);
    *puVar3 = 0;
    puVar3[1] = p_vif_entry->index;
    puVar3[2] = (pcVar2->channel).band;
    puVar3[3] = (pcVar2->channel).type;
    *(uint16_t *)(puVar3 + 4) = (pcVar2->channel).prim20_freq;
    *(uint16_t *)(puVar3 + 6) = (pcVar2->channel).center1_freq;
    *(uint16_t *)(puVar3 + 8) = (pcVar2->channel).center2_freq;
    *(uint *)(puVar3 + 0xc) = (sta_info_tab[bVar1].bcn_int - 5000) / 1000;
    puVar3[0x10] = (pcVar2->channel).tx_power;
    ke_msg_send();
    DAT_4201e340 = DAT_4201e340 | 0x40;
  }
  return;
}



_Bool chan_is_on_channel(vif_info_tag *p_vif_entry)

{
  chan_ctxt_tag *pcVar1;
  
  if (DAT_4201e2f0 != 0) {
    if (*(byte *)(DAT_4201e2f0 + 0x17) < 3) {
      pcVar1 = (chan_ctxt_tag *)((int)p_vif_entry->chan_ctxt - DAT_4201e2f0);
    }
    else {
      pcVar1 = (chan_ctxt_tag *)((uint)*(byte *)(DAT_4201e2f0 + 0x19) - (uint)p_vif_entry->index);
    }
    return (_Bool)(pcVar1 == (chan_ctxt_tag *)0x0);
  }
  return false;
}



_Bool chan_is_tx_allowed(vif_info_tag *p_vif_entry)

{
  bool bVar1;
  undefined3 extraout_var;
  
  bVar1 = (bool)chan_is_on_channel(p_vif_entry);
  if ((CONCAT31(extraout_var,bVar1) != 0) && (DAT_4201e2f4 != 0)) {
    bVar1 = *(char *)(DAT_4201e2f0 + 0x16) == '\x06';
  }
  return (_Bool)bVar1;
}



_Bool chan_is_on_operational_channel(vif_info_tag *p_vif_entry)

{
  bool bVar1;
  
  bVar1 = false;
  if ((DAT_4201e2f0 != (chan_ctxt_tag *)0x0) && (bVar1 = false, DAT_4201e2f0->idx < 3)) {
    bVar1 = p_vif_entry->chan_ctxt == DAT_4201e2f0;
  }
  return (_Bool)bVar1;
}



void chan_update_tx_power(chan_ctxt_tag *p_chan_entry)

{
  int8_t iVar1;
  int8_t iVar2;
  char cVar3;
  
  if (p_chan_entry->nb_linked_vif == '\0') {
    return;
  }
  iVar2 = '\x7f';
  if ((p_chan_entry == vif_info_tab[0].chan_ctxt) &&
     (iVar2 = vif_info_tab[0].user_tx_power,
     vif_info_tab[0].tx_power < vif_info_tab[0].user_tx_power)) {
    iVar2 = vif_info_tab[0].tx_power;
  }
  iVar1 = iVar2;
  if (p_chan_entry == vif_info_tab[1].chan_ctxt) {
    iVar1 = vif_info_tab[1].user_tx_power;
    if (iVar2 < vif_info_tab[1].user_tx_power) {
      iVar1 = iVar2;
    }
    cVar3 = vif_info_tab[1].tx_power;
    if (vif_info_tab[1].tx_power < iVar1) goto LAB_2305c726;
  }
  cVar3 = iVar1;
  if (iVar1 == '\x7f') {
    return;
  }
LAB_2305c726:
  (p_chan_entry->channel).tx_power = cVar3;
  return;
}



void chan_ctxt_link(uint8_t vif_idx,uint8_t chan_idx)

{
  uint8_t uVar1;
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  int iVar2;
  chan_ctxt_tag *p_chan_entry;
  
  iVar2 = CONCAT31(in_register_0000202d,chan_idx);
  p_chan_entry = chan_ctxt_pool + iVar2;
  if (vif_info_tab[CONCAT31(in_register_00002029,vif_idx)].chan_ctxt != (chan_ctxt_tag *)0x0) {
    assert_err("p_vif_entry->chan_ctxt == NULL","module",0x99c);
  }
  if (chan_ctxt_pool[iVar2].idx == -1) {
    assert_err("p_chan_entry->idx != CHAN_CTXT_UNUSED","module",0x99d);
  }
  uVar1 = chan_ctxt_pool[iVar2].nb_linked_vif + '\x01';
  DAT_4201e338 = DAT_4201e338 + 0xc800;
  vif_info_tab[CONCAT31(in_register_00002029,vif_idx)].chan_ctxt = p_chan_entry;
  chan_ctxt_pool[iVar2].nb_linked_vif = uVar1;
  if (uVar1 == '\x01') {
    chan_ctxt_pool[iVar2].status = '\x01';
    DAT_4201e342 = DAT_4201e342 + '\x01';
    co_list_push_back((co_list *)&p_chan_entry,(co_list_hdr *)p_chan_entry);
    if (DAT_4201e2f4 == 0) {
      if ((DAT_4201e340 & 0xc) == 0) {
        if (DAT_4201e342 == '\x01') {
          chan_switch_start(p_chan_entry);
        }
        else {
          chan_cde_evt((void *)0x0);
        }
      }
    }
    else {
      *(undefined *)(DAT_4201e2f4 + 0x16) = 1;
      DAT_4201e2f4 = 0;
    }
  }
  chan_update_tx_power(p_chan_entry);
  return;
}



void chan_ctxt_unlink(uint8_t vif_idx)

{
  chan_ctxt_tag *pcVar1;
  chan_ctxt_tag *p_chan_entry;
  undefined3 in_register_00002029;
  int iVar2;
  
  iVar2 = CONCAT31(in_register_00002029,vif_idx);
  p_chan_entry = vif_info_tab[iVar2].chan_ctxt;
  if (p_chan_entry == (chan_ctxt_tag *)0x0) {
    assert_err("p_chan_entry != NULL","module",0x9e4);
  }
  co_list_extract((co_list *)&DAT_4201e2e0,(co_list_hdr *)&vif_info_tab[iVar2].tbtt_switch);
  vif_info_tab[iVar2].tbtt_switch.status = '\0';
  vif_info_tab[iVar2].chan_ctxt = (chan_ctxt_tag *)0x0;
  p_chan_entry->nb_linked_vif = p_chan_entry->nb_linked_vif + -1;
  pcVar1 = DAT_4201e2f4;
  if (p_chan_entry->status != '\0') {
    DAT_4201e338 = DAT_4201e338 + -0xc800;
    if (p_chan_entry->nb_linked_vif != '\0') goto LAB_2305c942;
    co_list_extract((co_list *)&p_chan_entry,(co_list_hdr *)p_chan_entry);
    p_chan_entry->status = '\0';
    DAT_4201e342 = DAT_4201e342 - 1;
    if (DAT_4201e2f0 == p_chan_entry) {
      DAT_4201e2f0 = (chan_ctxt_tag *)0x0;
LAB_2305c90e:
      if (pcVar1 == (chan_ctxt_tag *)0x0) {
        if (DAT_4201e342 < 2) {
          if (DAT_4201e342 == 1) {
            chan_switch_start(p_chan_entry);
          }
        }
        else {
          chan_cde_evt((void *)0x0);
        }
        goto LAB_2305c934;
      }
    }
    else {
      if (pcVar1 != p_chan_entry) goto LAB_2305c90e;
      DAT_4201e2f4 = (chan_ctxt_tag *)0x0;
    }
    DAT_4201e340 = DAT_4201e340 | 0x20;
  }
LAB_2305c934:
  if (p_chan_entry->nb_linked_vif == '\0') {
    chan_ctxt_del(p_chan_entry->idx);
  }
LAB_2305c942:
  chan_tbtt_schedule((chan_tbtt_tag *)0x0);
  chan_update_tx_power(p_chan_entry);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void hal_dma_init(void)

{
  co_list_init((co_list *)&hal_dma_env);
  hal_dma_env.lli_cnt[0] = (uint16_t)_DAT_44a000a4;
  co_list_init(hal_dma_env.prog + 1);
  hal_dma_env.lli_cnt[1] = (uint16_t)_DAT_44a000ac;
  return;
}


/*
Unable to decompile 'hal_dma_push'
Cause: Exception while decompiling 2305c9a6: Decompiler process died

*/

/*
Unable to decompile 'hal_dma_evt'
Cause: Exception while decompiling 2305ca36: Decompiler process died

*/


// WARNING: Globals starting with '_' overlap smaller symbols at the same address

u8_l blmac_soft_reset_getf(void)

{
  uint uVar1;
  
  uVar1 = _DAT_44b08050;
  if ((_DAT_44b08050 & 0xfffffffe) != 0) {
    assert_err("(localVal & ~((uint32_t)0x00000001)) == 0","module",0x11d);
  }
  return (u8_l)uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void blmac_wt_2_crypt_clk_ratio_setf(u8_l wt2cryptclkratio)

{
  undefined3 in_register_00002029;
  
  _DAT_44b000f0 = CONCAT31(in_register_00002029,wt2cryptclkratio) | _DAT_44b000f0 & 0xfffffffc;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void blmac_rx_flow_cntrl_en_setf(void)

{
  _DAT_44b00054 = _DAT_44b00054 & 0xfffeffff | 0x10000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void blmac_key_sto_ram_reset_setf(void)

{
  _DAT_44b0004c = _DAT_44b0004c & 0xffffdfff | 0x2000;
  return;
}


/*
Unable to decompile 'hal_machw_idle_req'
Cause: Exception while decompiling 2305caf8: Decompiler process died

*/


// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void hal_machw_stop(void)

{
  u8_l uVar1;
  undefined3 extraout_var;
  
  _DAT_44b08050 = 1;
  do {
    uVar1 = blmac_soft_reset_getf();
  } while (CONCAT31(extraout_var,uVar1) != 0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void hal_machw_init(void)

{
  uint uVar1;
  u8_l wt2cryptclkratio;
  uint8_t uVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  uint uVar3;
  uint uVar4;
  
  _DAT_44b08050 = 1;
  do {
    wt2cryptclkratio = blmac_soft_reset_getf();
  } while (CONCAT31(extraout_var,wt2cryptclkratio) != 0);
  _DAT_44b00404 = 0x24f637;
  _DAT_44b00400 = 0x49;
  _DAT_44920004 = 0x5010001f;
  uVar2 = phy_get_mac_freq();
  _uVar2 = CONCAT31(extraout_var_00,uVar2);
  uVar1 = _DAT_44b000e4 & 0xff;
  uVar3 = _DAT_44b000e4 & 0xffffff00 | 0x28;
  uVar4 = (((_DAT_44b000e4 & 0x3ff00) >> 8) * _uVar2) / uVar1 << 8;
  _DAT_44b000e4 = uVar3;
  if ((uVar4 & 0xfc0000) != 0) {
    assert_err("(((uint32_t)txrfdelayinmacclk << 8) & ~((uint32_t)0x0003FF00)) == 0","module",0x1d59
              );
  }
  _DAT_44b000e4 = (_DAT_44b000e4 & 0xfffc00ff | uVar4 & 0xffff00) & 0xf003ffff | 0x2200000;
  _DAT_44b000e8 =
       (((_DAT_44b000e8 >> 8 & 0xffff) * _uVar2) / uVar1 & 0xffff) << 8 | _DAT_44b000e8 & 0xff0000ff
  ;
  uVar3 = _DAT_44b000ec & 0xc00fffff | 0x2700000;
  uVar4 = (((_DAT_44b000ec & 0xffc00) >> 10) * _uVar2) / uVar1 << 10;
  _DAT_44b000ec = uVar3;
  if ((uVar4 & 0x3f00000) != 0) {
    assert_err("(((uint32_t)txdelayrfoninmacclk << 10) & ~((uint32_t)0x000FFC00)) == 0","module",
               0x1ea2);
  }
  wt2cryptclkratio = '\x03';
  _DAT_44b000ec = _DAT_44b000ec & 0xfff00000 | uVar4 & 0x3fffc00 | 0xb4;
  if ((0x1d < _uVar2) && (wt2cryptclkratio = '\x02', 0x3b < _uVar2)) {
    wt2cryptclkratio = '\x01';
  }
  blmac_wt_2_crypt_clk_ratio_setf(wt2cryptclkratio);
  _DAT_44b000f4 =
       (((_DAT_44b000f4 >> 8 & 0xffff) * _uVar2) / uVar1 & 0xffff) << 8 | _DAT_44b000f4 & 0xff0000ff
  ;
  _DAT_44b000f8 =
       (((_DAT_44b000f8 >> 8 & 0xffff) * _uVar2) / uVar1 & 0xffff) << 8 | _DAT_44b000f8 & 0xff0000ff
  ;
  uVar3 = ((_DAT_44b00104 >> 0x14 & 0x3ff) * _uVar2) / uVar1 << 0x14;
  if ((uVar3 & 0xc0000000) != 0) {
    assert_err("(((uint32_t)rifstoinmacclk << 20) & ~((uint32_t)0x3FF00000)) == 0","module",0x228a);
  }
  uVar3 = _DAT_44b00104 & 0xc00fffff | uVar3;
  uVar4 = (((_DAT_44b00104 & 0xffc00) >> 10) * _uVar2) / uVar1 << 10;
  _DAT_44b00104 = uVar3;
  if ((uVar4 & 0x3f00000) != 0) {
    assert_err("(((uint32_t)rifsinmacclk << 10) & ~((uint32_t)0x000FFC00)) == 0","module",0x22a4);
  }
  uVar3 = _DAT_44b00104 & 0xfff003ff | uVar4 & 0x3fffc00;
  uVar1 = ((_DAT_44b00104 & 0x3ff) * _uVar2) / uVar1;
  _DAT_44b00104 = uVar3;
  if ((uVar1 & 0xfc00) != 0) {
    assert_err("(((uint32_t)txdmaprocdlyinmacclk << 0) & ~((uint32_t)0x000003FF)) == 0","module",
               0x22be);
  }
  _DAT_44b00104 = _DAT_44b00104 & 0xfffffc00 | uVar1 & 0xffff;
  _DAT_44b08074 = 0x8373f14c;
  _DAT_44b0004c = _DAT_44b0004c & 0xfffff7ff;
  if (_DAT_44b000d8 >> 0x18 < 0x11) {
    assert_err("MM_STA_TO_KEY(NX_REMOTE_STA_MAX - 1) <= blmac_sta_key_max_index_getf()","module",
               0x124);
  }
  printf("[WF] [KEY] [CFG] nVAP is %d, endidx %d, startidx %d\r\n",2,0x11,8);
  _DAT_44b000d8 = 0x21108;
  _DAT_44b08080 = 0x800a07c0;
  _DAT_44b0004c = _DAT_44b0004c | 0x4000780;
  blmac_rx_flow_cntrl_en_setf();
  _DAT_44b00060 = 0x7fffffde;
  _DAT_44b00114 = 0x3010a;
  _DAT_44b00064 = 0xff900064;
  _DAT_44b00150 = 0x1000;
  _DAT_44b00224 = 0;
  _DAT_44b000a0 = 0x2020;
  _DAT_44b0004c = _DAT_44b0004c & 0xffffefff | 0x1000;
  blmac_key_sto_ram_reset_setf();
  _DAT_44b00510 = 0x1c25;
  _DAT_44b00310 = _DAT_44b00310 | 0x80;
  uVar2 = phy_get_ntx();
  uVar1 = (CONCAT31(extraout_var_01,uVar2) + 1) * 0x4000000;
  if ((uVar1 & 0xe0000000) != 0) {
    assert_err("(((uint32_t)maxphyntx << 26) & ~((uint32_t)0x1C000000)) == 0","module",0x1539);
  }
  _DAT_44b0004c = _DAT_44b0004c & 0xfdffffff | 0x2000000;
  _DAT_44b0009c = _DAT_44b0009c & 0xe3ffffff | uVar1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void hal_machw_disable_int(void)

{
  _DAT_44b08074 = _DAT_44b08074 & 0x7fffffff;
  _DAT_44b08080 = _DAT_44b08080 & 0x7fffffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void hal_machw_reset(void)

{
  char "hal_machw_reset" [16];
  
  if ((_DAT_44b00038 & 0xf) != 0) {
    helper_record_all_states("hal_machw_reset");
  }
  _DAT_44b0004c = _DAT_44b0004c & 0xffffff7f;
  _DAT_44b00038 = 0;
  _DAT_44b00054 = 0x7c;
  ps_env.prevent_sleep = ps_env.prevent_sleep & 0xfffffffb;
  blmac_rx_flow_cntrl_en_setf();
  _DAT_44b0004c = _DAT_44b0004c | 0x80;
  _DAT_44b08070 = 0x37ff187;
  _DAT_44b08074 = _DAT_44b08074 & 0x7fffffff | 0x80000000;
  _DAT_44b0807c = 0xffffffff;
  _DAT_44b08080 = _DAT_44b08080 & 0x7fffffff | 0x80000000;
  _DAT_44b0808c = _DAT_44b0808c & 0xffffffc0;
  return;
}



// WARNING: Removing unreachable block (ram,0x2305d0b8)
// WARNING: Removing unreachable block (ram,0x2305d0c4)
// WARNING: Removing unreachable block (ram,0x2305d0ce)

u8_l hal_machw_search_addr(mac_addr_conflict171 *addr)

{
                    // WARNING: Do nothing block with infinite loop
  do {
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void hal_machw_monitor_mode(void)

{
  _DAT_44b08074 = _DAT_44b08074 & 0xfffffffc;
  mm_env.rx_filter_umac = 0x7fffffde;
  _DAT_44b00060 = mm_env.rx_filter_lmac_enable | 0x7fffffde;
  _DAT_44b0004c = _DAT_44b0004c & 0xfffe3fff | 0xc700;
  blmac_key_sto_ram_reset_setf();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

_Bool hal_machw_sleep_check(void)

{
  uint uVar1;
  
  uVar1 = 0;
  while (((1 << (uVar1 & 0x1f) & _DAT_44b0808c) == 0 ||
         (-1 < (-2000 - _DAT_44b00120) + *(int *)(&DAT_44b00128 + uVar1 * 4)))) {
    uVar1 = uVar1 + 1;
    if (uVar1 == 9) {
      return true;
    }
  }
  if (-1 < (5000 - _DAT_44b00120) + *(int *)(&DAT_44b00128 + uVar1 * 4)) {
    return false;
  }
  assert_err("!hal_machw_time_past(blmac_abs_timer_get(i) + 5000)","module",0x208);
  return false;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void hal_machw_gen_handler(void)

{
  uint uVar1;
  uint uVar2;
  char *condition;
  int line;
  
  uVar2 = _DAT_44b08074 & _DAT_44b0806c;
  _DAT_44b08070 = uVar2;
  if ((uVar2 & 0x40001) != 0) {
    ke_evt_set(0x400000);
  }
  if ((uVar2 & 0x80002) != 0) {
    ke_evt_set(0x200000);
  }
  if ((uVar2 & 4) != 0) {
    if ((_DAT_44b00038 & 0xf) == 0) {
      _DAT_44b0808c = _DAT_44b0808c & 0xffffffdf;
      ps_env.prevent_sleep = ps_env.prevent_sleep & 0xfffffffb;
      ke_evt_set(0x800000);
    }
    else {
      assert_rec("blmac_current_state_getf() == HW_IDLE","module",0x8c);
    }
  }
  uVar1 = _DAT_44b08084;
  if ((uVar2 & 8) != 0) {
    _DAT_44b08088 = _DAT_44b08084;
    if ((_DAT_44b08084 & 0x100) != 0) {
      ke_evt_set(0x4000000);
    }
    if ((uVar1 & 0x40) != 0) {
      rxl_timeout_int_handler();
    }
    if ((uVar1 & 0x80) != 0) {
      ke_evt_set(0x8000000);
    }
    if ((uVar1 & 1) != 0) {
      assert_rec("HAL_AC0_TIMER_BIT timeout ","module",0x22f);
    }
    if ((uVar1 & 2) == 0) {
      if ((uVar1 & 4) == 0) {
        if ((uVar1 & 8) == 0) {
          if ((uVar1 & 0x10) == 0) {
            if ((uVar1 & 0x20) == 0) goto LAB_2305d26c;
            line = 0x236;
            condition = "!(timer_pending & HAL_IDLE_TIMER_BIT)";
          }
          else {
            line = 0x235;
            condition = "!(timer_pending & HAL_BCN_TIMER_BIT)";
          }
        }
        else {
          line = 0x234;
          condition = "!(timer_pending & HAL_AC3_TIMER_BIT)";
        }
      }
      else {
        line = 0x233;
        condition = "!(timer_pending & HAL_AC2_TIMER_BIT)";
      }
    }
    else {
      line = 0x232;
      condition = "!(timer_pending & HAL_AC1_TIMER_BIT)";
    }
    assert_rec(condition,"module",line);
  }
LAB_2305d26c:
  if ((uVar2 & 0x80) == 0) {
    if ((uVar2 & 0x100) == 0) {
      if ((int)(uVar2 << 0x13) < 0) {
        line = 0x27a;
        condition = "!(genirq_pending & NXMAC_PT_ERROR_BIT)";
      }
      else {
        if ((int)(uVar2 << 0x12) < 0) {
          line = 0x27b;
          condition = "!(genirq_pending & NXMAC_AC_0_TX_DMA_DEAD_BIT)";
        }
        else {
          if ((int)(uVar2 << 0x11) < 0) {
            line = 0x27c;
            condition = "!(genirq_pending & NXMAC_AC_1_TX_DMA_DEAD_BIT)";
          }
          else {
            if ((int)(uVar2 << 0x10) < 0) {
              line = 0x27d;
              condition = "!(genirq_pending & NXMAC_AC_2_TX_DMA_DEAD_BIT)";
            }
            else {
              if ((int)(uVar2 << 0xf) < 0) {
                line = 0x27e;
                condition = "!(genirq_pending & NXMAC_AC_3_TX_DMA_DEAD_BIT)";
              }
              else {
                if ((int)(uVar2 << 0xe) < 0) {
                  line = 0x27f;
                  condition = "!(genirq_pending & NXMAC_BCN_TX_DMA_DEAD_BIT)";
                }
                else {
                  if ((int)(uVar2 << 10) < 0) {
                    line = 0x280;
                    condition = "!(genirq_pending & NXMAC_MAC_PHYIF_UNDER_RUN_BIT)";
                  }
                  else {
                    if ((int)(uVar2 << 9) < 0) {
                      line = 0x281;
                      condition = "!(genirq_pending & NXMAC_PHY_ERR_BIT)";
                    }
                    else {
                      if ((int)(uVar2 << 7) < 0) {
                        line = 0x282;
                        condition = "!(genirq_pending & NXMAC_RX_HEADER_DMA_DEAD_BIT)";
                      }
                      else {
                        if ((int)(uVar2 << 6) < 0) {
                          line = 0x283;
                          condition = "!(genirq_pending & NXMAC_RX_PAYLOAD_DMA_DEAD_BIT)";
                        }
                        else {
                          if (-1 < (int)(uVar2 << 0xb)) {
                            return;
                          }
                          line = 0x284;
                          condition = "!(genirq_pending & NXMAC_HW_ERR_BIT)";
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    else {
      line = 0x279;
      condition = "!(genirq_pending & NXMAC_RX_FIFO_OVER_FLOW_BIT)";
    }
  }
  else {
    line = 0x278;
    condition = "!(genirq_pending & NXMAC_RX_DMA_EMPTY_BIT)";
  }
  assert_rec(condition,"module",line);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_rx_filter_set(void)

{
  _DAT_44b00060 = mm_env.rx_filter_lmac_enable | mm_env.rx_filter_umac;
  return;
}



int element_notify_status_enabled
              (cfg_element_entry *entry,void *arg1,void *arg2,CFG_ELEMENT_TYPE_OPS ops)

{
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void blmac_ap_setf(uint8_t ap)

{
  undefined3 in_register_00002029;
  
  _DAT_44b0004c = CONCAT31(in_register_00002029,ap) << 1 | _DAT_44b0004c & 0xfffffffd;
  return;
}



uchar ascii_to_hex(char asccode)

{
  char cVar1;
  byte bVar2;
  
  bVar2 = asccode - 0x30;
  if (9 < bVar2) {
    if ((byte)(asccode + 0x9fU) < 6) {
      cVar1 = -0x57;
    }
    else {
      if (5 < (byte)(asccode + 0xbfU)) {
        return '\0';
      }
      cVar1 = -0x37;
    }
    bVar2 = asccode + cVar1;
  }
  return (uchar)bVar2;
}



undefined4 element_notify_time_last_received_set(void)

{
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void blmac_encr_cntrl_pack
               (uint8_t newread,uint8_t newwrite,uint16_t keyindexram,uint8_t ctyperam,
               uint8_t vlanidram,uint8_t sppram,uint8_t usedefkeyram,uint8_t clenram)

{
  uint uVar1;
  undefined3 in_register_00002035;
  undefined3 in_register_00002039;
  undefined3 in_register_0000203d;
  undefined3 in_register_00002041;
  undefined3 in_register_00002045;
  uint uVar2;
  
  uVar2 = CONCAT31(in_register_00002039,vlanidram) << 4;
  if ((uVar2 & 0xffffff0f) != 0) {
    assert_err("(((uint32_t)vlanidram << 4) & ~((uint32_t)0x000000F0)) == 0","module",0x1873);
  }
  uVar1 = CONCAT31(in_register_0000203d,sppram) << 2;
  if ((uVar1 & 0xfffffff3) != 0) {
    assert_err("(((uint32_t)sppram << 2) & ~((uint32_t)0x0000000C)) == 0","module",0x1874);
  }
  _DAT_44b000c4 =
       (uint)newread << 0x1f | CONCAT31(in_register_00002045,clenram) |
       CONCAT31(in_register_00002041,usedefkeyram) << 1 | uVar1 | uVar2 |
       CONCAT31(in_register_00002035,ctyperam) << 8 | (uint)keyindexram << 0x10 |
       (uint)newwrite << 0x1e;
  return;
}



undefined4 element_notify_keepalive_received(void)

{
  return 0;
}



// WARNING: Removing unreachable block (ram,0x2305d62a)
// WARNING: Removing unreachable block (ram,0x2305d634)
// WARNING: Removing unreachable block (ram,0x2305d65c)
// WARNING: Removing unreachable block (ram,0x2305d650)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t hal_machw_rx_duration(rx_hd *rhd,uint16_t len)

{
  if ((""[rhd->recvec1a >> 0xc & 0xf] & 0x80) != 0) {
    assert_err("(((uint32_t)ppdumcsindex << 0) & ~((uint32_t)0x0000007F)) == 0","module",0x1a99);
  }
  do {
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_env_max_ampdu_duration_set(void)

{
  mm_env.ampdu_max_dur[0] = 0x96;
  if (((_DAT_44b00200 >> 0xc & 0xffff) != 0) && ((_DAT_44b00200 >> 0xc & 0xffff) < 0x97)) {
    mm_env.ampdu_max_dur[0] = (uint16_t)(_DAT_44b00200 >> 0xc);
  }
  mm_env.ampdu_max_dur[1] = 0x96;
  if (((_DAT_44b00204 >> 0xc & 0xffff) != 0) && ((_DAT_44b00204 >> 0xc & 0xffff) < 0x97)) {
    mm_env.ampdu_max_dur[1] = (uint16_t)(_DAT_44b00204 >> 0xc);
  }
  mm_env.ampdu_max_dur[2] = 0x96;
  if (((_DAT_44b00208 >> 0xc & 0xffff) != 0) && ((_DAT_44b00208 >> 0xc & 0xffff) < 0x97)) {
    mm_env.ampdu_max_dur[2] = (uint16_t)(_DAT_44b00208 >> 0xc);
  }
  mm_env.ampdu_max_dur[3] = 0x96;
  if (((_DAT_44b0020c >> 0xc & 0xffff) != 0) && ((_DAT_44b0020c >> 0xc & 0xffff) < 0x97)) {
    mm_env.ampdu_max_dur[3] = (uint16_t)(_DAT_44b0020c >> 0xc);
  }
  mm_env.ampdu_max_dur[4] = mm_env.ampdu_max_dur[3];
  return;
}



void mm_env_init(void)

{
  memset(&mm_env,0,0x2c);
  mm_env._34_2_ = 0x101;
  mm_env._18_2_ = 0;
  mm_env.rx_filter_lmac_enable = 0;
  mm_env.rx_filter_umac = 0x7fffffde;
  mm_rx_filter_set();
  mm_env_max_ampdu_duration_set();
  return;
}



void mm_init(void)

{
  hal_machw_init();
  mm_env_init();
  vif_mgmt_init();
  sta_mgmt_init();
  td_init();
  ps_init();
  txl_cntrl_init();
  rxl_init();
  mm_timer_init();
  scan_init();
  chan_init();
  hal_dma_init();
  mm_bcn_init();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_active(void)

{
  _DAT_44b00038 = 0x30;
  ke_state_set(0,1);
  return;
}



void mm_reset(void)

{
  ke_state_t kVar1;
  undefined3 extraout_var;
  
  kVar1 = ke_state_get(0);
  if (CONCAT31(extraout_var,kVar1) == 1) {
    mm_active();
    return;
  }
  ke_state_set(0,0);
  return;
}


/*
Unable to decompile 'mm_tbtt_evt'
Cause: Exception while decompiling 2305d7ec: Decompiler process died

*/


// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t mm_sec_machwaddr_wr(uint8_t sta_idx,uint8_t inst_nbr)

{
  uint uVar1;
  undefined3 in_register_00002029;
  int iVar2;
  
  iVar2 = CONCAT31(in_register_00002029,sta_idx);
  uVar1 = iVar2 + 8U & 0xff;
  _DAT_44b000bc = *(undefined4 *)sta_info_tab[iVar2].mac_addr.array;
  _DAT_44b000c0 = (uint)sta_info_tab[iVar2].mac_addr.array[2];
  _DAT_44b000ac = 0;
  _DAT_44b000b0 = 0;
  _DAT_44b000b4 = 0;
  _DAT_44b000b8 = 0;
  blmac_encr_cntrl_pack('\0','\x01',(uint16_t)uVar1,'\0',inst_nbr,'\0','\x01','\0');
  do {
  } while (_DAT_44b000c4 << 1 < 0);
  return (uint8_t)uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t mm_sec_machwkey_wr(mm_key_add_req *param)

{
  byte bVar1;
  byte vlanidram;
  uint16_t keyindexram;
  uint uVar2;
  uint8_t ctyperam;
  uint8_t clenram;
  uint uVar3;
  
  bVar1 = param->sta_idx;
  uVar3 = (uint)bVar1;
  vlanidram = param->inst_nbr;
  if (bVar1 == 0xff) {
    uVar3 = (uint)vlanidram * 4 + (uint)param->key_idx & 0xff;
    keyindexram = (uint16_t)uVar3;
    _DAT_44b000bc = 0xffffffff;
    _DAT_44b000c0 = 0xffffffff;
    vif_mgmt_add_key(param,(uint8_t)uVar3);
  }
  else {
    if (0xb < bVar1) {
      assert_err("sta_idx < STA_MAX","module",0x3e4);
    }
    uVar2 = uVar3 + 8 & 0xff;
    keyindexram = (uint16_t)uVar2;
    sta_mgmt_add_key(param,(uint8_t)uVar2);
    _DAT_44b000bc = *(undefined4 *)sta_info_tab[uVar3].mac_addr.array;
    _DAT_44b000c0 = (uint)sta_info_tab[uVar3].mac_addr.array[2];
  }
  bVar1 = param->cipher_suite;
  if (bVar1 < 4) {
    clenram = *(uint8_t *)((int)&CSWTCH_22 + (uint)bVar1);
    ctyperam = *(uint8_t *)((int)&CSWTCH_23 + (uint)bVar1);
  }
  else {
    assert_err("0","module",0x429);
    ctyperam = '\0';
    clenram = '\x01';
  }
  _DAT_44b000ac = (param->key).array[0];
  _DAT_44b000b0 = (param->key).array[1];
  _DAT_44b000b4 = (param->key).array[2];
  _DAT_44b000b8 = (param->key).array[3];
  blmac_encr_cntrl_pack('\0','\x01',keyindexram,ctyperam,vlanidram,param->spp,'\0',clenram);
  do {
  } while (_DAT_44b000c4 << 1 < 0);
  return (uint8_t)keyindexram;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_sec_machwkey_del(uint8_t hw_key_idx)

{
  undefined3 in_register_00002029;
  uint uVar1;
  uint uVar2;
  
  uVar1 = CONCAT31(in_register_00002029,hw_key_idx);
  if (uVar1 < 8) {
    _DAT_44b000bc = 0xffffffff;
    _DAT_44b000c0 = 0xffffffff;
    vif_mgmt_del_key(vif_info_tab + ((int)uVar1 >> 2),hw_key_idx & 3);
  }
  else {
    uVar2 = uVar1 - 8 & 0xff;
    _DAT_44b000bc = *(undefined4 *)sta_info_tab[uVar2].mac_addr.array;
    _DAT_44b000c0 = (uint)sta_info_tab[uVar2].mac_addr.array[2];
    sta_mgmt_del_key(sta_info_tab + uVar2);
  }
  _DAT_44b000ac = 0;
  _DAT_44b000b0 = 0;
  _DAT_44b000b4 = 0;
  _DAT_44b000b8 = 0;
  blmac_encr_cntrl_pack('\0','\x01',(uint16_t)uVar1,'\0','\0','\0','\0','\0');
  do {
  } while (_DAT_44b000c4 << 1 < 0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_sec_machwaddr_del(uint8_t sta_idx)

{
  _DAT_44b000bc = 0xffffffff;
  _DAT_44b000c0 = 0xffffffff;
  _DAT_44b000ac = 0;
  _DAT_44b000b0 = 0;
  _DAT_44b000b4 = 0;
  _DAT_44b000b8 = 0;
  blmac_encr_cntrl_pack('\0','\x01',(ushort)sta_idx + 8 & 0xff,'\0','\0','\0','\0','\0');
  do {
  } while (_DAT_44b000c4 << 1 < 0);
  return;
}



void mm_hw_idle_evt(int dummy)

{
  ke_evt_clear(0x800000);
  ke_state_set(0,0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_hw_info_set(mac_addr_conflict171 *mac_addr)

{
  blmac_ap_setf('\0');
  _DAT_44b0001c = 0x100;
  _DAT_44b080a4 = 0;
  _DAT_44b080a8 = 0;
  _DAT_44b00010 = *(undefined4 *)mac_addr->array;
  _DAT_44b00014 = (uint)mac_addr->array[2];
  _DAT_44b0004c = _DAT_44b0004c & 0xfffff8ff | 1;
  mm_env.rx_filter_umac = 0x3503858c;
  mm_rx_filter_set();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_hw_ap_info_set(void)

{
  blmac_ap_setf('\x01');
  mm_env.rx_filter_umac = 0x3507a58c;
  mm_rx_filter_set();
  _DAT_44b08070 = 0x40001;
  _DAT_44b08074 = _DAT_44b08074 | 0x40001;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_hw_ap_info_reset(void)

{
  blmac_ap_setf('\0');
  mm_env.rx_filter_umac = 0x3503858c;
  mm_rx_filter_set();
  _DAT_44b08070 = 0x40001;
  _DAT_44b08074 = _DAT_44b08074 & 0xfffbfffe;
  return;
}



void mm_back_to_host_idle(void)

{
  ke_state_t kVar1;
  undefined3 extraout_var;
  
  kVar1 = ke_state_get(0);
  if (CONCAT31(extraout_var,kVar1) != 3) {
    assert_err("ke_state_get(TASK_MM) == MM_HOST_BYPASSED","module",0x52a);
  }
  if (mm_env.host_idle == '\0') {
    mm_active();
    return;
  }
  ke_state_set(0,0);
  return;
}


/*
Unable to decompile 'mm_force_idle_req'
Cause: Exception while decompiling 2305dca8: Decompiler process died

*/


// WARNING: Type propagation algorithm not settling
// WARNING: Could not reconcile some variable overlaps

uint8_t mm_sta_add(mm_sta_add_req *param,uint8_t *sta_idx,uint8_t *hw_sta_idx)

{
  uint uVar1;
  uint8_t uVar2;
  uint8_t uVar3;
  uchar uVar4;
  uchar uVar5;
  undefined3 extraout_var;
  size_t sVar6;
  int security_mode;
  uint8_t *phrase;
  int iVar7;
  int iVar8;
  _Bool is_pmf_required;
  uint uVar9;
  undefined2 uStack92;
  mm_key_add_req key_add_req;
  
  uVar2 = sta_mgmt_register(param,sta_idx);
  if (CONCAT31(extraout_var,uVar2) != 0) {
    return uVar2;
  }
  uVar1 = (uint)param->inst_nbr;
  uVar3 = mm_sec_machwaddr_wr(*sta_idx,param->inst_nbr);
  *hw_sta_idx = uVar3;
  if (vif_info_tab[uVar1].type != '\0') {
    return uVar2;
  }
  if (vif_info_tab[uVar1].bss_info.is_supplicant_enabled == false) goto LAB_2305dd2e;
  sta_conn_info.staId = *sta_idx;
  if ((*(uint *)&vif_info_tab[uVar1].bss_info.is_supplicant_enabled & 0x12800) == 0) {
    if ((*(byte *)&vif_info_tab[uVar1].bss_info.wpa_wpa2_wep & 2) != 0) {
      sVar6 = strlen((char *)(sm_env.connect_param)->phrase);
      printf("wep:len:%d,password:%s\n",sVar6,(sm_env.connect_param)->phrase);
      memset(&uStack92,0,0x2c);
      key_add_req.key.array[7]._1_1_ = param->inst_nbr;
      uStack92 = 0xff00;
      sVar6 = strlen((char *)(sm_env.connect_param)->phrase);
      uVar9 = sVar6 & 0xff;
      key_add_req.key_idx = (uint8_t)uVar9;
      if (uVar9 == 5) {
        key_add_req.key.array[7]._0_1_ = '\0';
LAB_2305de62:
        memcpy(&key_add_req.key,(sm_env.connect_param)->phrase,sVar6 & 0xff);
      }
      else {
        if (uVar9 == 0xd) {
          key_add_req.key.array[7]._0_1_ = '\x03';
          goto LAB_2305de62;
        }
        if (uVar9 == 10) {
          key_add_req.key.array[7]._0_1_ = '\0';
        }
        else {
          if (uVar9 != 0x1a) {
            printf("password length is not correct for wep\n");
            sta_mgmt_unregister(*sta_idx);
            return '\x01';
          }
          key_add_req.key.array[7]._0_1_ = '\x03';
        }
        uVar9 = sVar6 & 0xff;
        if ((sVar6 & 1) != 0) {
          uVar9 = sVar6 & 0xfe;
        }
        if (uVar9 != 0) {
          iVar7 = 0;
          phrase = (sm_env.connect_param)->phrase;
          do {
            uVar4 = ascii_to_hex(*phrase);
            uVar5 = ascii_to_hex(phrase[1]);
            (&key_add_req.key.length)[iVar7 >> 1] = uVar4 * '\x10' + uVar5;
            iVar7 = iVar7 + 2;
            phrase = phrase + 2;
          } while (iVar7 < (int)uVar9);
        }
        key_add_req.key_idx = key_add_req.key_idx >> 1;
      }
      wep_hw_keyid = mm_sec_machwkey_wr((mm_key_add_req *)&uStack92);
    }
  }
  else {
    if ((sm_env.connect_param)->phrase_pmk[0] == '\0') {
      phrase = (sm_env.connect_param)->phrase;
    }
    else {
      phrase = (sm_env.connect_param)->phrase_pmk;
    }
    set_psk((char *)vif_info_tab[uVar1].bss_info.ssid.array,vif_info_tab[uVar1].bss_info.ssid.length
            ,(char *)phrase);
  }
  iVar7 = uVar1 * 0x5d8;
  if ((*(uint *)&vif_info_tab[uVar1].bss_info.is_supplicant_enabled & 0x12000) == 0) {
    if ((*(byte *)&vif_info_tab[uVar1].bss_info.wpa_wpa2_wep & 8) != 0) {
      iVar8 = iVar7 + 0x3ec;
      iVar7 = iVar7 + 0x3eb;
      is_pmf_required = vif_info_tab[uVar1].bss_info.is_pmf_required;
      security_mode = 3;
      goto LAB_2305ddc4;
    }
  }
  else {
    is_pmf_required = vif_info_tab[uVar1].bss_info.is_pmf_required;
    iVar8 = iVar7 + 0x3ee;
    iVar7 = iVar7 + 0x3ed;
    security_mode = 4;
LAB_2305ddc4:
    supplicantEnable(&sta_conn_info,security_mode,
                     (void *)((int)&vif_info_tab[0].list_hdr.next + iVar7),
                     (void *)((int)&vif_info_tab[0].list_hdr.next + iVar8),is_pmf_required);
  }
  if (vif_info_tab[uVar1].type != '\0') {
    return uVar2;
  }
LAB_2305dd2e:
  vif_info_tab[uVar1].u[4] = *sta_idx;
  return '\0';
}



void mm_sta_del(uint8_t sta_idx)

{
  uint uVar1;
  undefined3 in_register_00002029;
  undefined *puVar2;
  byte bVar3;
  uint uVar4;
  
  uVar4 = (uint)sta_info_tab[CONCAT31(in_register_00002029,sta_idx)].inst_nbr;
  if (vif_info_tab[uVar4].type == '\0') {
    vif_info_tab[uVar4].u[4] = 0xff;
    if (vif_info_tab[uVar4].bss_info.is_supplicant_enabled != false) {
      if ((*(uint *)&vif_info_tab[uVar4].bss_info.is_supplicant_enabled & 0x12800) == 0) {
        if (((*(byte *)&vif_info_tab[uVar4].bss_info.wpa_wpa2_wep & 2) != 0) && (wep_hw_keyid != -1)
           ) {
          mm_sec_machwkey_del(wep_hw_keyid);
        }
      }
      else {
        mm_sec_machwkey_del(sta_conn_info.ptkHwKeyId);
        mm_sec_machwkey_del(sta_conn_info.gtkHwKeyId);
        mm_sec_machwkey_del(sta_conn_info.mfpHwKeyId);
        supplicantDisable(&sta_conn_info);
        memset(&(sta_conn_info.suppData)->hashSsId,0,0x22);
        remove_psk((char *)vif_info_tab[uVar4].bss_info.ssid.array,
                   vif_info_tab[uVar4].bss_info.ssid.length);
      }
      vif_info_tab[uVar4].bss_info.is_supplicant_enabled = false;
    }
  }
  else {
    if ((sta_info_tab[CONCAT31(in_register_00002029,sta_idx)].ps_state == '\x01') &&
       (bVar3 = vif_info_tab[uVar4].u[0x2ee] - 1, vif_info_tab[uVar4].u[0x2ee] = bVar3, bVar3 == 0))
    {
      uVar1 = (uint)vif_info_tab[uVar4].index + 10 & 0xff;
      puVar2 = (undefined *)ke_msg_alloc(0x49,0xd,0,2);
      sta_info_tab[uVar1].ps_state = '\0';
      *puVar2 = (char)uVar1;
      puVar2[1] = 0;
      ke_msg_send();
      apm_tx_int_ps_clear(vif_info_tab + uVar4,vif_info_tab[uVar4].index + '\n');
    }
  }
  mm_sec_machwaddr_del(sta_idx);
  sta_mgmt_unregister(sta_idx);
  return;
}



void mm_cfg_element_keepalive_timestamp_update(void)

{
  mm_env.keep_alive_time_last_received = xTaskGetTickCount();
  mm_env.keep_alive_packet_counter = mm_env.keep_alive_packet_counter + 1;
  return;
}



void mm_send_connection_loss_ind(vif_info_tag *p_vif_entry)

{
  uint8_t *puVar1;
  
  puVar1 = (uint8_t *)ke_msg_alloc(0x43,6,0,1);
  *puVar1 = p_vif_entry->index;
  ke_msg_send();
  return;
}



void mm_ap_probe_cfm(void *env,uint32_t status)

{
  if ((int)(status << 8) < 0) {
    *(undefined *)((int)env + 0x74) = 0;
    return;
  }
  mm_send_connection_loss_ind((vif_info_tag *)env);
  return;
}



// WARNING: Variable defined which should be unmapped: cur_us
// WARNING: Could not reconcile some variable overlaps

void mm_check_rssi(vif_info_tag *vif_entry,int8_t rssi)

{
  byte bVar1;
  uint8_t uVar2;
  int iVar3;
  uint8_t *puVar4;
  undefined3 in_register_0000202d;
  int iVar5;
  uint uVar6;
  bool bVar7;
  int iVar8;
  uint uStack40;
  longlong cur_us;
  
  iVar5 = CONCAT31(in_register_0000202d,rssi);
  iVar8 = (int)(char)vif_entry->u[0x19];
  iVar3 = (int)(char)vif_entry->u[0x1a];
  bVar1 = vif_entry->u[0x1b];
  bVar7 = (bool)vif_entry->u[0x1c];
  vif_entry->u[0x19] = rssi;
  uStack40 = 0;
  cur_us._0_4_ = 0;
  bl60x_current_time_us((longlong *)&uStack40);
  if (iVar8 != 0) {
    uVar6 = (uint)(uStack40 < uStack40 - (uint)last_us);
    if (((int)(((int)cur_us - last_us._4_4_) - uVar6) < 1) &&
       (((int)cur_us - last_us._4_4_ != uVar6 || (uStack40 - (uint)last_us < 0x1e8481))))
    goto LAB_2305e162;
  }
  puVar4 = (uint8_t *)ke_msg_alloc(0x57,0xd,0,3);
  uVar2 = vif_entry->index;
  *(bool *)(puVar4 + 1) = bVar7;
  puVar4[2] = rssi;
  *puVar4 = uVar2;
  last_us._0_4_ = uStack40;
  last_us._4_4_ = (int)cur_us;
  ke_msg_send();
LAB_2305e162:
  if (iVar3 != 0) {
    if (bVar7 == false) {
      if (iVar5 < iVar8) {
        bVar7 = iVar5 < iVar3 - (char)bVar1;
      }
    }
    else {
      if (iVar8 < iVar5) {
        bVar7 = iVar5 <= iVar3 + (char)bVar1;
      }
    }
    if ((bool)vif_entry->u[0x1c] != bVar7) {
      puVar4 = (uint8_t *)ke_msg_alloc(0x57,0xd,0,3);
      uVar2 = vif_entry->index;
      *(bool *)(puVar4 + 1) = bVar7;
      puVar4[2] = rssi;
      *puVar4 = uVar2;
      ke_msg_send();
    }
    *(bool *)(vif_entry->u + 0x1c) = bVar7;
  }
  return;
}



void mm_send_csa_traffic_ind(uint8_t vif_index,_Bool enable)

{
  uint8_t *puVar1;
  
  puVar1 = (uint8_t *)ke_msg_alloc(0x59,0xd,0,2);
  *puVar1 = vif_index;
  *(_Bool *)(puVar1 + 1) = enable;
  ke_msg_send();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint mm_check_beacon(rx_hd *param_1,vif_info_tag *param_2,int param_3,char **param_4)

{
  ushort len;
  ushort uVar1;
  ushort uVar2;
  uint uVar3;
  int iVar4;
  uint8_t uVar5;
  undefined3 extraout_var;
  uint32_t crc;
  uint32_t uVar6;
  uint32_t uVar7;
  uint uVar8;
  uint uVar9;
  char *pcVar10;
  uint uVar11;
  int iVar12;
  int iVar13;
  uint len_00;
  int iVar14;
  uint uVar15;
  
  len = param_1->frmlen;
  iVar13 = *(int *)(param_1->first_pbd_ptr + 8);
  param_2->u[0x18] = 0;
  beacon_rx_count = beacon_rx_count + 1;
  iVar14 = *(int *)(param_2->u + 0x14);
  if (param_2->u[0x1e] != 0) {
    mm_send_csa_traffic_ind(param_2->index,true);
    param_2->u[0x1e] = 0;
  }
  if ((((30000000 - _DAT_44b00120) + *(int *)(param_2->u + 0x10) < 0) &&
      (mm_env.keep_alive_status_enabled != false)) &&
     (uVar5 = txl_frame_send_null_frame(param_2->u[4],(cfm_func_ptr *)0x0,(void *)0x0),
     CONCAT31(extraout_var,uVar5) == 0)) {
    *(int *)(param_2->u + 0x10) = _DAT_44b00120;
  }
  uVar3 = (uint)len - 0x24;
  mm_check_rssi(param_2,*(int8_t *)((int)&param_1->recvec1c + 3));
  crc = co_crc32(iVar13 + 0x20,4,0);
  pcVar10 = (char *)(iVar13 + 0x24);
  *param_4 = (char *)0x0;
  while (uVar3 = uVar3 & 0xffff, 1 < uVar3) {
    len_00 = (uint)(byte)pcVar10[1];
    if (uVar3 <= len_00 + 1) break;
    if (*pcVar10 == '\x05') {
      *param_4 = pcVar10;
    }
    else {
      crc = co_crc32((uint32_t)(pcVar10 + 2),len_00,crc);
    }
    uVar3 = uVar3 + (-2 - len_00);
    pcVar10 = pcVar10 + 2 + len_00;
  }
  *(uint32_t *)(param_2->u + 0x14) = crc;
  uVar1 = *(ushort *)(param_3 + 0x16);
  uVar2 = *(ushort *)(iVar13 + 0x20);
  uVar3 = *(uint *)(iVar13 + 0x18);
  crc = param_1->tsflo;
  iVar4 = (uint)uVar2 * 0x400;
  iVar13 = *(int *)(iVar13 + 0x1c);
  len_00 = (uint)*(ushort *)param_2->u;
  if (*(ushort *)param_2->u == 0) {
    pcVar10 = *param_4;
    len_00 = 1;
    if ((pcVar10 != (char *)0x0) && (len_00 = (uint)(byte)pcVar10[2], pcVar10[2] == 0)) {
      len_00 = (uint)(byte)pcVar10[3];
    }
  }
  uVar6 = hal_machw_rx_duration(param_1,len);
  uVar7 = hal_machw_rx_duration(param_1,0x18);
  uVar8 = uVar3;
  iVar12 = iVar13;
  __udivdi3();
  uVar11 = uVar3 - uVar7;
  uVar15 = iVar13 - (uint)(uVar3 < uVar11);
  uVar9 = iVar12 * iVar4 + (int)((ulonglong)uVar8 * (ulonglong)uVar2 * 0x400 >> 0x20);
  if ((uVar9 < uVar15) || ((uVar15 == uVar9 && (uVar8 * iVar4 < uVar11)))) {
    uVar11 = uVar8 * iVar4;
  }
  iVar12 = ((uVar11 + len_00 * iVar4) - ((uVar3 - crc) + (uVar6 - uVar7))) - uVar1 * len_00;
  iVar13 = iVar12 + -400;
  if (iVar12 + (-0xc80 - _DAT_44b00120) < 0) {
    iVar13 = iVar13 + iVar4;
  }
  crc = (_DAT_44b00120 - _DAT_44b080a4) + iVar13;
  if (crc != (param_2->tbtt_timer).time) {
    mm_timer_set(&param_2->tbtt_timer,crc);
  }
  return (uint)(*(int *)(param_2->u + 0x14) != iVar14);
}



void mm_sta_tbtt(void *env)

{
  uint32_t value;
  _Bool _Var1;
  undefined3 extraout_var;
  byte bVar2;
  
  if (*(char *)((int)env + 0x58) == '\0') {
    return;
  }
  if (*(char *)((int)env + 0x79) != '\0') {
    bVar2 = *(char *)((int)env + 0x79) - 1;
    *(byte *)((int)env + 0x79) = bVar2;
    if (bVar2 < 2) {
      vif_mgmt_switch_channel((vif_info_tag *)env);
      return;
    }
    if (bVar2 == 2) {
      mm_send_csa_traffic_ind(*(uint8_t *)((int)env + 0x57),false);
    }
  }
  value = sta_info_tab[*(byte *)((int)env + 0x60)].bcn_int + *(int *)((int)env + 0x24);
  mm_timer_set((mm_timer_tag *)((int)env + 0x18),value);
  vif_mgmt_bcn_to_prog((vif_info_tag *)env);
  chan_tbtt_switch_update((vif_info_tag *)env,value);
  _Var1 = chan_is_on_channel((vif_info_tag *)env);
  if (CONCAT31(extraout_var,_Var1) != 0) {
    *(uint *)((int)env + 4) = *(uint *)((int)env + 4) | 1;
    bVar2 = *(char *)((int)env + 0x74) + 1;
    *(byte *)((int)env + 0x74) = bVar2;
    if (100 < bVar2) {
      txl_frame_send_null_frame(*(uint8_t *)((int)env + 0x60),mm_ap_probe_cfm,env);
      return;
    }
    if (bVar2 == 100) {
      chan_bcn_detect_start((vif_info_tag *)env);
      return;
    }
  }
  return;
}



uint16_t mm_get_rsn_wpa_ie(uint8_t sta_id,uint8_t *wpa_ie)

{
  undefined3 in_register_00002029;
  uint uVar1;
  
  uVar1 = (uint)sta_info_tab[CONCAT31(in_register_00002029,sta_id)].inst_nbr;
  memcpy(wpa_ie,vif_info_tab[uVar1].bss_info.rsn_wpa_ie,
         (uint)vif_info_tab[uVar1].bss_info.rsn_wpa_ie_len);
  return (uint16_t)(ushort)vif_info_tab[uVar1].bss_info.rsn_wpa_ie_len;
}



void mm_tim_update_proceed(ushort *param_1)

{
  byte bVar1;
  ushort uVar2;
  uint uVar3;
  uint8_t *puVar4;
  uint uVar5;
  int iVar6;
  uint uVar7;
  int iVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  byte *pbVar12;
  
  uVar2 = *param_1;
  uVar9 = (uint)*(byte *)((int)param_1 + 3);
  if (uVar2 == 0) {
    if (*(char *)(param_1 + 1) == '\0') {
      vif_info_tab[uVar9].u[0x2ea] = 0;
    }
    else {
      vif_info_tab[uVar9].u[0x2ea] = 1;
    }
  }
  else {
    iVar8 = uVar9 * 8;
    uVar10 = (uint)(uVar2 >> 3);
    uVar11 = uVar10 & 0xff;
    puVar4 = txl_tim_bitmap_pool + uVar9 * 0xfc;
    pbVar12 = puVar4 + uVar11;
    bVar1 = *pbVar12;
    uVar7 = 1 << ((uint)uVar2 & 7);
    uVar5 = uVar7 & 0xff;
    uVar3 = uVar5 & bVar1;
    if (*(char *)(param_1 + 1) == '\0') {
      if (uVar3 != 0) {
        *pbVar12 = ~(byte)uVar7 & bVar1;
        uVar3 = (uint)*(ushort *)(vif_info_tab[uVar9].u + 0x2e0) - 1;
        *(short *)(vif_info_tab[uVar9].u + 0x2e0) = (short)(uVar3 * 0x10000 >> 0x10);
        if ((uVar3 & 0xffff) == 0) {
          *(undefined2 *)(vif_info_tab[uVar9].u + 0x2de) = 6;
          *(undefined2 *)(vif_info_tab[uVar9].u + 0x2e8) = 0xff;
          bVar1 = vif_info_tab[uVar9].u[0x2de];
          txl_tim_ie_pool[iVar8 + 4] = '\0';
          txl_tim_ie_pool[iVar8 + 1] = bVar1 - 2;
          txl_tim_desc[uVar9 * 2].dataendptr = iVar8 + 0x42045365;
          *(tx_pbd **)&txl_tim_desc[uVar9 * 2].next = txl_bcn_end_desc + *(byte *)((int)param_1 + 3)
          ;
          *(uint8_t **)&txl_tim_desc[uVar9 * 2 + 1].dataendptr =
               puVar4 + vif_info_tab[uVar9].u[0x2e9];
        }
        else {
          if ((uint)vif_info_tab[uVar9].u[0x2e8] == (uVar10 & 0xfe)) {
            while( true ) {
              bVar1 = vif_info_tab[uVar9].u[0x2e8];
              if ((bVar1 == 0xfb) || (puVar4[(uint)bVar1] != '\0')) break;
              vif_info_tab[uVar9].u[0x2e8] = bVar1 + 1;
            }
            uVar3 = (uint)bVar1 & 0xfe;
            vif_info_tab[uVar9].u[0x2e8] = (byte)uVar3;
            *(uint8_t **)&txl_tim_desc[uVar9 * 2 + 1].datastartptr = puVar4 + uVar3;
          }
          if ((uint)vif_info_tab[uVar9].u[0x2e9] == uVar11) {
            while( true ) {
              bVar1 = vif_info_tab[uVar9].u[0x2e9];
              if ((bVar1 == 0) || (puVar4[bVar1] != '\0')) break;
              vif_info_tab[uVar9].u[0x2e9] = bVar1 - 1;
            }
            *(uint8_t **)&txl_tim_desc[uVar9 * 2 + 1].dataendptr = puVar4 + bVar1;
          }
          iVar6 = (((uint)vif_info_tab[uVar9].u[0x2e9] + 6) - (uint)vif_info_tab[uVar9].u[0x2e8]) *
                  0x10000;
          *(short *)(vif_info_tab[uVar9].u + 0x2de) = (short)((uint)iVar6 >> 0x10);
          txl_tim_ie_pool[iVar8 + 1] = (char)((uint)iVar6 >> 0x10) + -2;
          txl_tim_ie_pool[iVar8 + 4] = vif_info_tab[uVar9].u[0x2e8];
        }
      }
    }
    else {
      if (uVar3 == 0) {
        *pbVar12 = (byte)uVar5 | bVar1;
        bVar1 = vif_info_tab[uVar9].u[0x2e8];
        *(short *)(vif_info_tab[uVar9].u + 0x2e0) = *(short *)(vif_info_tab[uVar9].u + 0x2e0) + 1;
        if (uVar11 < bVar1) {
          vif_info_tab[uVar9].u[0x2e8] = (byte)(uVar10 & 0xfe);
          *(uint8_t **)&txl_tim_desc[uVar9 * 2 + 1].datastartptr = puVar4 + (uVar10 & 0xfe);
        }
        if (vif_info_tab[uVar9].u[0x2e9] < uVar11) {
          vif_info_tab[uVar9].u[0x2e9] = (byte)uVar11;
          *(byte **)&txl_tim_desc[uVar9 * 2 + 1].dataendptr = pbVar12;
        }
        iVar6 = (((uint)vif_info_tab[uVar9].u[0x2e9] + 6) - (uint)vif_info_tab[uVar9].u[0x2e8]) *
                0x10000;
        *(short *)(vif_info_tab[uVar9].u + 0x2de) = (short)((uint)iVar6 >> 0x10);
        txl_tim_ie_pool[iVar8 + 1] = (char)((uint)iVar6 >> 0x10) + -2;
        txl_tim_ie_pool[iVar8 + 4] = vif_info_tab[uVar9].u[0x2e8];
        txl_tim_desc[uVar9 * 2].dataendptr = iVar8 + 0x42045364;
        txl_tim_desc[uVar9 * 2].next = uVar9 * 0x28 + 0x42045aa4;
      }
    }
  }
  ke_msg_send_basic(0x42,param_1[-2],0);
  ke_msg_free(param_1 + -6);
  return;
}



void mm_bcn_init(void)

{
  memset(&mm_bcn_env,0,0x24);
  mm_bcn_env.dma.dma_desc = &bcn_dwnld_desc;
  mm_bcn_env.dma.cb = mm_bcn_updated;
  co_list_init(&mm_bcn_env.tim_list);
  return;
}



void mm_bcn_init_vif(vif_info_tag *vif_entry)

{
  byte bVar1;
  tx_pbd *ptVar2;
  uint uVar3;
  int iVar4;
  
  uVar3 = (uint)vif_entry->index;
  txl_frame_init_desc((txl_frame_desc_tag *)(vif_entry->u + 4),
                      (txl_buffer_tag *)(txl_bcn_pool + uVar3 * 0xd3),txl_bcn_hwdesc_pool + uVar3,
                      txl_bcn_buf_ctrl + uVar3);
  txl_bcn_hwdesc_pool[uVar3].cfm_ptr = txl_bcn_hwdesc_cfms + vif_entry->index;
  uVar3 = (uint)vif_entry->index;
  iVar4 = uVar3 * 8;
  vif_entry->u[0x2e7] = 0;
  *(undefined2 *)(vif_entry->u + 0x2e0) = 0;
  vif_entry->u[0x2ea] = 0;
  *(undefined2 *)(vif_entry->u + 0x2de) = 6;
  *(undefined2 *)(vif_entry->u + 0x2e8) = 0xff;
  txl_tim_desc[uVar3 * 2].dataendptr = iVar4 + 0x42045365;
  txl_tim_desc[uVar3 * 2].upatterntx = 0xcafefade;
  *(uint8_t **)&txl_tim_desc[uVar3 * 2].datastartptr = txl_tim_ie_pool + iVar4;
  txl_tim_desc[uVar3 * 2].bufctrlinfo = 0;
  ptVar2 = txl_bcn_end_desc + uVar3;
  *(tx_pbd **)&txl_tim_desc[uVar3 * 2].next = ptVar2;
  txl_tim_ie_pool[iVar4] = '\x05';
  txl_tim_ie_pool[iVar4 + 1] = '\x04';
  bVar1 = vif_entry->u[0x2e7];
  txl_tim_ie_pool[iVar4 + 4] = '\0';
  txl_tim_ie_pool[iVar4 + 2] = bVar1;
  txl_tim_ie_pool[iVar4 + 3] = '\x01';
  txl_tim_ie_pool[iVar4 + 5] = -1;
  txl_tim_desc[uVar3 * 2 + 1].upatterntx = 0xcafefade;
  bVar1 = vif_entry->u[0x2e9];
  *(tx_pbd **)&txl_tim_desc[uVar3 * 2 + 1].next = ptVar2;
  *(uint8_t **)&txl_tim_desc[uVar3 * 2 + 1].dataendptr = txl_tim_bitmap_pool + uVar3 * 0xfc + bVar1;
  memset(txl_tim_bitmap_pool + uVar3 * 0xfc,0,0xfc);
  ptVar2->upatterntx = 0xcafefade;
  txl_bcn_end_desc[uVar3].next = 0;
  txl_bcn_end_desc[uVar3].bufctrlinfo = 0;
  iVar4 = *(int *)(vif_entry->u + 0x70);
  *(undefined4 *)(iVar4 + 0x24) = 0;
  *(undefined4 *)(iVar4 + 0x3c) = 0;
  *(undefined4 *)(iVar4 + 0x10) = 0;
  *(undefined4 *)(vif_entry->u + 0x2d0) = 0x2305edbc;
  *(vif_info_tag **)(vif_entry->u + 0x2d4) = vif_entry;
  return;
}



void mm_tim_update(mm_tim_update_req *param)

{
  if (mm_bcn_env.tx_cfm != 0) {
    co_list_push_back(&mm_bcn_env.tim_list,(co_list_hdr *)(param + -3));
    return;
  }
  mm_tim_update_proceed();
  return;
}



// WARNING: Type propagation algorithm not settling

void mm_bcn_transmit(void)

{
  byte bVar1;
  uint8_t uVar2;
  uint8_t uVar3;
  vif_info_tag *vif;
  txl_frame_desc_tag *frame;
  _Bool _Var4;
  undefined3 extraout_var;
  char *pcVar5;
  undefined3 extraout_var_00;
  uint8_t *puVar6;
  int iVar7;
  byte bVar8;
  uint uVar9;
  char cVar10;
  int iVar11;
  
  vif = (vif_info_tag *)vif_mgmt_env.used_list.first;
  if (mm_bcn_env.tx_cfm != 0) {
    assert_err("!mm_bcn_env.tx_cfm","module",0x339);
  }
  if (mm_bcn_env.update_ongoing == false) {
    mm_bcn_env.tx_pending = false;
    while (vif != (vif_info_tag *)0x0) {
      if (((vif->type == '\x02') && (*(char *)((int)vif->u + 0x2e6) != '\0')) &&
         (*(char *)((int)vif->u + 0x2e5) == *(char *)((int)vif->u + 0x2e4))) {
        iVar7 = *(int *)((int)vif->u + 0x70);
        iVar11 = (uint)vif->index * 8;
        bVar1 = txl_tim_ie_pool[iVar11 + 4];
        *(int *)(iVar7 + 0x1c) =
             (uint)*(ushort *)((int)vif->u + 0x2dc) + (uint)*(ushort *)((int)vif->u + 0x2de) + 4;
        uVar9 = (uint)txl_cntrl_env.seqnbr;
        frame = (txl_frame_desc_tag *)((int)vif->u + 4);
        txl_cntrl_env.seqnbr = (uint16_t)((uVar9 + 1) * 0x10000 >> 0x10);
        *(undefined2 *)(*(int *)(iVar7 + 0x14) + 0x16) = (short)((uVar9 + 1 & 0xffff) << 4);
        uVar2 = *(uint8_t *)((int)vif->u + 0x2e7);
        txl_tim_ie_pool[iVar11 + 2] = uVar2;
        if (uVar2 == '\0') {
          if ((*(char *)((int)vif->u + 0x2ea) != '\0') ||
             (bVar8 = bVar1 & 0xfe, ipc_emb_env.txdesc[ipc_emb_env.txdesc_idx & 3].ready != 0)) {
            bVar8 = bVar1 | 1;
          }
          *(uint8_t *)((int)vif->u + 0x2e7) = txl_tim_ie_pool[iVar11 + 3];
        }
        else {
          bVar8 = bVar1 & 0xfe;
          if ((*(byte *)((int)vif->u + 0x2ea) & 2) != 0) {
            bVar8 = bVar1 | 1;
          }
        }
        txl_tim_ie_pool[iVar11 + 4] = bVar8 | 1;
        *(char *)((int)vif->u + 0x2e7) = *(char *)((int)vif->u + 0x2e7) + -1;
        cVar10 = *(char *)((int)vif->u + 0x2eb);
        if (cVar10 != '\0') {
          bVar1 = *(byte *)((int)vif->u + 0x2ec);
          cVar10 = cVar10 + -1;
          *(char *)((int)vif->u + 0x2eb) = cVar10;
          if (bVar1 != 0) {
            *(char *)(*(int *)(iVar7 + 0x14) + (uint)bVar1) = cVar10;
            bVar1 = *(byte *)((int)vif->u + 0x2ed);
            if (bVar1 != 0) {
              *(undefined *)(*(int *)(iVar7 + 0x14) + (uint)bVar1) =
                   *(undefined *)((int)vif->u + 0x2eb);
            }
          }
          uVar2 = *(uint8_t *)((int)vif->u + 0x2eb);
          if (uVar2 != '\0') {
            uVar3 = vif->index;
            puVar6 = (uint8_t *)ke_msg_alloc(0x4e,0xd,0,2);
            *puVar6 = uVar3;
            puVar6[1] = uVar2;
            ke_msg_send();
            if (*(char *)((int)vif->u + 0x2eb) != '\0') goto LAB_2305eb34;
          }
          *(undefined *)((int)vif->u + 0x2eb) = 1;
        }
LAB_2305eb34:
        tpc_update_frame_tx_power(vif,frame);
        _Var4 = chan_is_on_operational_channel(vif);
        if (CONCAT31(extraout_var,_Var4) != 0) {
          uVar2 = vif->index;
          pcVar5 = (char *)ke_msg_alloc(0x4a,0xd,0,3);
          *pcVar5 = uVar2 + '\n';
          pcVar5[1] = '\0';
          pcVar5[2] = '\0';
          ke_msg_send();
          *(uint8_t *)((int)vif->u + 0x33) = vif->index;
          *(undefined *)((int)vif->u + 0x34) = 0xff;
          _Var4 = txl_frame_push(frame,'\x04');
          if (CONCAT31(extraout_var_00,_Var4) != 0) {
            mm_bcn_env.tx_cfm = mm_bcn_env.tx_cfm + 1;
          }
          iVar7 = (uint)vif->index + 10;
          if ((sta_info_tab[iVar7].traffic_avail & PS_TRAFFIC_INT) != 0) {
            sta_info_tab[iVar7].ps_service_period = 9;
            sta_mgmt_send_postponed_frame(vif,sta_info_tab + iVar7,0);
            sta_info_tab[iVar7].ps_service_period = 0;
          }
        }
      }
      vif = *(vif_info_tag **)&vif->list_hdr;
    }
  }
  else {
    mm_bcn_env.tx_pending = true;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_bcn_updated(void *env,int dma_queue)

{
  ushort uVar1;
  ushort uVar2;
  mm_bcn_change_req *pmVar3;
  int iVar4;
  uint32_t uVar5;
  int iVar6;
  txl_buffer_control *ptVar7;
  mm_bcn_change_req *mem_ptr;
  int iVar8;
  uint uVar9;
  int iVar10;
  
  mem_ptr = mm_bcn_env.param + -1;
  ke_msg_send_basic(0x40,*(ke_task_id_t *)&mm_bcn_env.param[-1].tim_len,0);
  pmVar3 = mm_bcn_env.param;
  uVar9 = (uint)*(byte *)((int)env + 0x57);
  iVar4 = *(int *)((int)env + 0xcc);
  uVar1 = (mm_bcn_env.param)->tim_oft;
  iVar10 = (uint)(mm_bcn_env.param)->bcn_len - (uint)(mm_bcn_env.param)->tim_len;
  iVar8 = *(int *)(iVar4 + 0x14);
  *(undefined2 *)((int)env + 0x338) = (short)iVar10;
  me_beacon_check(*(byte *)((int)env + 0x57),pmVar3->bcn_len,*(uint32_t *)(iVar4 + 0x14));
  iVar6 = *(int *)(iVar4 + 0x14) + ((uint)pmVar3->tim_oft - 1);
  *(int *)(iVar4 + 0x18) = iVar6;
  uVar5 = (uint)pmVar3->tim_len + 1 + iVar6;
  txl_bcn_end_desc[uVar9].datastartptr = uVar5;
  uVar2 = pmVar3->tim_oft;
  txl_bcn_end_desc[uVar9].bufctrlinfo = 0;
  txl_bcn_end_desc[uVar9].dataendptr = ~(uint)uVar2 + iVar10 + uVar5;
  if (*(char *)(*(int *)((int)env + 0x40) + 4) == '\0') {
    ptVar7 = &txl_buffer_control_24G;
  }
  else {
    ptVar7 = &txl_buffer_control_5G;
  }
  *(uint *)(ptVar7->field_0 + 0x24) = _DAT_44b000a0 & 0xff;
  *(txl_buffer_control **)(iVar4 + 0x28) = ptVar7;
  *(undefined4 *)(iVar4 + 0x24) = 0;
  *(undefined4 *)(iVar4 + 0x3c) = 0;
  *(tx_pbd **)(iVar4 + 0x10) = txl_tim_desc + (uint)*(byte *)((int)env + 0x57) * 2;
  *(undefined *)((int)env + 0x342) = 1;
  txl_tim_ie_pool[uVar9 * 8 + 3] = *(uint8_t *)(iVar8 + (uint)uVar1 + 3);
  pmVar3 = mm_bcn_env.param;
  *(undefined *)((int)env + 0x347) = 0;
  *(uint8_t *)((int)env + 0x348) = pmVar3->csa_oft[0];
  *(uint8_t *)((int)env + 0x349) = pmVar3->csa_oft[1];
  if (pmVar3->csa_oft[0] != 0) {
    *(char *)((int)env + 0x347) =
         *(char *)(*(int *)(*(int *)((int)env + 0xcc) + 0x14) + (uint)pmVar3->csa_oft[0]) + '\x01';
  }
  mm_bcn_env.update_ongoing = false;
  if (mm_bcn_env.tx_pending != false) {
    mm_bcn_transmit();
  }
  mm_bcn_env.param = (mm_bcn_change_req *)0x0;
  ke_msg_free(mem_ptr);
  return;
}



void mm_bcn_update(mm_bcn_change_req *param)

{
  byte bVar1;
  
  bVar1 = param->inst_nbr;
  memcpy(txl_bcn_pool + (uint)bVar1 * 0xd3 + 0x53,param + 1,(uint)param->bcn_len);
  mm_bcn_env.update_pending = false;
  mm_bcn_env.update_ongoing = true;
  mm_bcn_updated(vif_info_tab + (uint)bVar1,0);
  return;
}



void mm_bcn_transmitted(vif_info_tag *param_1)

{
  co_list_hdr *pcVar1;
  
  if (mm_bcn_env.tx_cfm == 0) {
    assert_err("mm_bcn_env.tx_cfm","module",0x244);
  }
  mm_bcn_env.tx_cfm = mm_bcn_env.tx_cfm + -1;
  if (mm_bcn_env.tx_cfm == 0) {
    if (mm_bcn_env.update_pending != false) {
      mm_bcn_update(mm_bcn_env.param);
    }
    while (mm_bcn_env.tim_list.first != (co_list_hdr *)0x0) {
      pcVar1 = co_list_pop_front(&mm_bcn_env.tim_list);
      mm_tim_update_proceed(pcVar1 + 3);
    }
    if (param_1->u[0x2eb] == 1) {
      vif_mgmt_switch_channel(param_1);
      return;
    }
  }
  return;
}



void mm_bcn_change(mm_bcn_change_req *param)

{
  if (mm_bcn_env.tx_cfm != 0) {
    mm_bcn_env.param = param;
    mm_bcn_env.update_pending = true;
    return;
  }
  mm_bcn_env.param = param;
  mm_bcn_update(param);
  return;
}



void bl_init(void)

{
  fw_nap_chain_ptr = &fw_nap_chain;
  bl_env.hw_in_doze = 0;
  dbg_init();
  me_init();
  mm_init();
  ke_init();
  memset(&sta_conn_info,0,0xec);
  sta_conn_info._4_2_ = 0xffff;
  sta_conn_info.conType = '\0';
  sta_conn_info.gtkHwKeyId = -1;
  supplicantFuncInit();
  allocSupplicantData(&sta_conn_info);
  return;
}


/*
Unable to decompile 'bl_reset_evt'
Cause: Exception while decompiling 2305eec0: Decompiler process died

*/


// WARNING: Type propagation algorithm not settling

int bl_sleep(void)

{
  vif_info_tag *p_vif_entry;
  ke_state_t kVar1;
  _Bool _Var2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  
  if (ke_env.evt_field != 0) {
    return 0;
  }
  kVar1 = ke_state_get(4);
  if (((CONCAT31(extraout_var,kVar1) == 0) && (ps_env.ps_on != false)) &&
     (p_vif_entry = (vif_info_tag *)vif_mgmt_env.used_list.first, ps_env.prevent_sleep == 0)) {
    while (p_vif_entry != (vif_info_tag *)0x0) {
      _Var2 = chan_is_on_channel(p_vif_entry);
      if ((CONCAT31(extraout_var_01,_Var2) != 0) && (p_vif_entry->prevent_sleep != 0)) {
        return 0;
      }
      p_vif_entry = *(vif_info_tag **)&p_vif_entry->list_hdr;
    }
    if (txl_cntrl_env.pck_cnt == 0) {
      _Var2 = hal_machw_sleep_check();
      return CONCAT31(extraout_var_00,_Var2);
    }
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t bl_nap_calculate(void)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  
  uVar2 = 0;
  uVar1 = 0xffffffff;
  do {
    if ((1 << (uVar2 & 0x1f) & _DAT_44b0808c) != 0) {
      uVar3 = *(uint *)(&DAT_44b00128 + uVar2 * 4);
      if (_DAT_44b00120 < uVar3) {
        uVar3 = uVar3 - _DAT_44b00120;
      }
      else {
        uVar3 = (_DAT_44b00120 - 1) - uVar3;
      }
      if (uVar3 < uVar1) {
        uVar1 = uVar3;
      }
    }
    uVar2 = uVar2 + 1;
  } while (uVar2 != 9);
  return uVar1;
}



void rx_swdesc_init(void)

{
  rx_swdesc_tab[0].dma_hdrdesc = rx_dma_hdrdesc;
  rx_swdesc_tab[1].dma_hdrdesc = &DAT_42041064;
  rx_swdesc_tab[2].dma_hdrdesc = &DAT_420410c8;
  rx_swdesc_tab[3].dma_hdrdesc = &DAT_4204112c;
  rx_swdesc_tab[4].dma_hdrdesc = &DAT_42041190;
  rx_swdesc_tab[5].dma_hdrdesc = &DAT_420411f4;
  rx_swdesc_tab[6].dma_hdrdesc = &DAT_42041258;
  rx_swdesc_tab[7].dma_hdrdesc = &DAT_420412bc;
  rx_swdesc_tab[8].dma_hdrdesc = &DAT_42041320;
  rx_swdesc_tab[9].dma_hdrdesc = &DAT_42041384;
  rx_swdesc_tab[10].dma_hdrdesc = &DAT_420413e8;
  rx_swdesc_tab[11].dma_hdrdesc = &DAT_4204144c;
  rx_swdesc_tab[12].dma_hdrdesc = &DAT_420414b0;
  return;
}



void scan_search_ds(void)

{
  scan_start_req *param;
  
  DAT_4201e578 = mac_ie_find(0x42045d04,(uint)param->add_ie_len,3);
  return;
}



void scan_init(void)

{
  memset(&scan_env,0,0x1c);
  ke_state_set(2,0);
  DAT_4201e568 = &scan_probe_req_ie;
  DAT_4201e56c = dma_cb;
  DAT_4201e570 = 0;
  scan_probe_req_ie.dma_desc.dest = 0x42045d04;
  scan_probe_req_ie.pbd.upatterntx = 0xcafefade;
  scan_probe_req_ie.pbd.next = 0;
  scan_probe_req_ie.pbd.datastartptr = 0x42045d04;
  scan_probe_req_ie.pbd.bufctrlinfo = 0;
  return;
}



void scan_set_channel_request(void)

{
  scan_chan_tag *psVar1;
  uint uVar2;
  undefined uVar3;
  int iVar4;
  
  psVar1 = param->chan + DAT_4201e57e;
  chan_scan_req(*(uint8_t *)(&psVar1->freq + 1),psVar1->freq,*(int8_t *)(&psVar1->freq + 2),110000,
                param->vif_idx);
  if (DAT_4201e578 == 0) goto LAB_2305f13c;
  uVar2 = (uint)psVar1->freq;
  if (*(char *)(&psVar1->freq + 1) == '\0') {
    uVar3 = 0;
    if (((uVar2 - 0x96c & 0xffff) < 0x49) && (uVar3 = 0xe, psVar1->freq != 0x9b4)) {
      iVar4 = -0x967;
LAB_2305f130:
      uVar3 = (undefined)((int)(uVar2 + iVar4) / 5);
    }
  }
  else {
    uVar3 = 0;
    if ((*(char *)(&psVar1->freq + 1) == '\x01') && ((uVar2 - 0x138d & 0xffff) < 0x335)) {
      iVar4 = -5000;
      goto LAB_2305f130;
    }
  }
  *(undefined *)(DAT_4201e578 + 2) = uVar3;
LAB_2305f13c:
  ke_state_set(2,2);
  return;
}



void dma_cb(void *env,int dma_queue)

{
  scan_search_ds();
  scan_set_channel_request();
  return;
}



void scan_ie_download(scan_start_req *param)

{
  scan_search_ds();
  scan_set_channel_request();
  scan_probe_req_ie.pbd.dataendptr =
       (scan_probe_req_ie.pbd.datastartptr - 1) + (uint)param->add_ie_len;
  scan_probe_req_ie.pbd.bufctrlinfo = 0;
  return;
}



void scan_probe_req_tx(void)

{
  byte bVar1;
  byte bVar2;
  scan_start_req *psVar3;
  txl_buffer_tag *ptVar4;
  uint type;
  txl_frame_desc_tag *frame;
  int iVar5;
  int iVar6;
  uint uVar7;
  u8_l *puVar8;
  tx_hw_desc *ptVar9;
  
  psVar3 = param;
  uVar7 = (uint)DAT_4201e57e;
  bVar1 = param->vif_idx;
  puVar8 = param->ssid[0].array;
  iVar6 = 0;
  while( true ) {
    if ((int)(uint)psVar3->ssid_cnt <= iVar6) {
      return;
    }
    type = 1;
    if (psVar3->chan[uVar7].band == '\0') {
      type = (uint)psVar3->no_cck;
    }
    frame = txl_frame_get(type,(uint)psVar3->add_ie_len + (uint)puVar8[-1] + 0x1a);
    if (frame == (txl_frame_desc_tag *)0x0) break;
    ptVar4 = (frame->txdesc).lmac.buffer;
    ptVar9 = (frame->txdesc).lmac.hw_desc;
    *(undefined *)&ptVar4[1].length = 0x40;
    *(undefined *)((int)&ptVar4[1].length + 1) = 0;
    *(undefined *)((int)&ptVar4[1].length + 2) = 0;
    *(undefined *)((int)&ptVar4[1].length + 3) = 0;
    memcpy(&ptVar4[1].lenheader,&mac_addr_bcst,6);
    memcpy((void *)((int)&ptVar4[1].lenpad + 2),&vif_info_tab[bVar1].mac_addr,6);
    memcpy(&ptVar4[1].next,&psVar3->bssid,6);
    type = (uint)txl_cntrl_env.seqnbr;
    *(undefined *)&ptVar4[1].dma_desc[0].src = 0;
    txl_cntrl_env.seqnbr = (uint16_t)((type + 1) * 0x10000 >> 0x10);
    iVar5 = (type + 1) * 0x100000;
    *(undefined *)((int)&ptVar4[1].txdesc + 2) = (char)((uint)iVar5 >> 0x10);
    *(undefined *)((int)&ptVar4[1].txdesc + 3) = (char)((uint)iVar5 >> 0x18);
    bVar2 = puVar8[-1];
    *(byte *)((int)&ptVar4[1].dma_desc[0].src + 1) = bVar2;
    type = 0;
    while ((uint)bVar2 != type) {
      *(u8_l *)((int)&ptVar4[1].dma_desc[0].src + type + 2) = puVar8[type];
      type = type + 1;
    }
    (ptVar9->thd).field_3 = 0x42045cf0;
    (ptVar9->thd).field_5 = (ptVar9->thd).field_5 - (uint)psVar3->add_ie_len;
    (frame->cfm).cfm_func = (cfm_func_ptr *)0x0;
    (frame->cfm).env = (void *)0x0;
    iVar6 = iVar6 + 1;
    puVar8 = puVar8 + 0x22;
    (frame->txdesc).host.vif_idx = psVar3->vif_idx;
    (frame->txdesc).host.staid = -1;
    txl_frame_push(frame,'\x03');
  }
  return;
}



void scan_send_cancel_cfm(uint8_t status,ke_task_id_t dest_id)

{
  uint8_t *puVar1;
  
  puVar1 = (uint8_t *)ke_msg_alloc(0x804,dest_id,2,1);
  *puVar1 = status;
  ke_msg_send();
  return;
}



int scan_cancel_req_handler(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined3 extraout_var;
  
  kVar1 = ke_state_get(2);
  if (CONCAT31(extraout_var,kVar1) == 0) {
    scan_send_cancel_cfm('\x01',src_id);
  }
  else {
    DAT_4201e57f = 1;
  }
  return 0;
}



int scan_start_req_handler
              (ke_msg_id_t msgid,scan_start_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  int iVar1;
  ke_state_t kVar2;
  undefined *puVar3;
  undefined3 extraout_var;
  
  puVar3 = (undefined *)ke_msg_alloc(0x801,src_id,dest_id,1);
  kVar2 = ke_state_get(2);
  if (CONCAT31(extraout_var,kVar2) == 0) {
    if (param->chan_cnt == '\0') {
      assert_err("param->chan_cnt > 0","module",0x46);
    }
    *puVar3 = 0;
    DAT_4201e57e = 0;
    iVar1 = 1;
    param = param;
    DAT_4201e57c = src_id;
    scan_ie_download(param);
  }
  else {
    *puVar3 = 8;
    iVar1 = 0;
  }
  ke_msg_send(puVar3);
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 mm_scan_channel_end_ind_handler(void)

{
  ke_state_t kVar1;
  undefined3 extraout_var;
  
  kVar1 = ke_state_get(2);
  if (CONCAT31(extraout_var,kVar1) != 3) {
    assert_err("ke_state_get(TASK_SCAN) == SCAN_WAIT_BEACON_PROBE_RSP","module",0xc4);
  }
  mm_env.rx_filter_lmac_enable = mm_env.rx_filter_lmac_enable & 0xffffddff;
  _DAT_44b00060 = mm_env.rx_filter_lmac_enable | mm_env.rx_filter_umac;
  DAT_4201e57e = DAT_4201e57e + 1;
  if ((DAT_4201e57e < param->chan_cnt) && (DAT_4201e57f == '\0')) {
    scan_set_channel_request();
  }
  else {
    ke_msg_free(&param[-1].add_ies);
    if (DAT_4201e57f == '\0') {
      ke_msg_send_basic(0x802,DAT_4201e57c,2);
    }
    else {
      scan_send_cancel_cfm('\0',DAT_4201e57c);
      DAT_4201e57f = '\0';
    }
    ke_state_set(2,0);
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int mm_scan_channel_start_ind_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  scan_start_req *psVar1;
  uint uVar2;
  ke_state_t kVar3;
  undefined3 extraout_var;
  
  psVar1 = param;
  uVar2 = (uint)DAT_4201e57e;
  kVar3 = ke_state_get(2);
  if (CONCAT31(extraout_var,kVar3) != 2) {
    assert_err("ke_state_get(TASK_SCAN) == SCAN_WAIT_CHANNEL","module",0x9d);
  }
  mm_env.rx_filter_lmac_enable = mm_env.rx_filter_lmac_enable | 0x2200;
  _DAT_44b00060 = mm_env.rx_filter_lmac_enable | mm_env.rx_filter_umac;
  if ((psVar1->chan[uVar2].flags & 1) == 0) {
    scan_probe_req_tx();
  }
  ke_state_set(2,3);
  return 0;
}



void txl_buffer_reinit(void)

{
  txl_buffer_env.list[0].first = (txl_buffer_tag *)0x0;
  txl_buffer_env.list[0].last = (txl_buffer_tag *)0x0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void txl_buffer_init(void)

{
  uint uVar1;
  txl_buffer_control *ptVar2;
  txl_buffer_control *ptVar3;
  uint8_t uVar4;
  byte bVar5;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  
  txl_buffer_reinit();
  ptVar3 = txl_buffer_control_desc;
  do {
    *(undefined4 *)ptVar3->field_0 = 0xbadcab1e;
    uVar4 = phy_get_ntx();
    *(int *)(ptVar3->field_0 + 4) = CONCAT31(extraout_var,uVar4) << 0xe;
    bVar5 = phy_get_ntx();
    *(int *)(ptVar3->field_0 + 8) = (1 << ((uint)bVar5 + 1 & 0x1f)) + -1;
    *(undefined4 *)(ptVar3->field_0 + 0xc) = 0;
    *(undefined4 *)(ptVar3->field_0 + 0x10) = 0xffff0704;
    *(undefined4 *)(ptVar3->field_0 + 0x14) = 0;
    *(undefined4 *)(ptVar3->field_0 + 0x18) = 0;
    *(undefined4 *)(ptVar3->field_0 + 0x1c) = 0;
    *(undefined4 *)(ptVar3->field_0 + 0x20) = 0;
    ptVar2 = ptVar3 + 1;
    *(uint *)(ptVar3->field_0 + 0x24) = _DAT_44b000a0 & 0xff;
    *(uint *)(ptVar3->field_0 + 0x28) = _DAT_44b000a0 & 0xff;
    *(uint *)(ptVar3->field_0 + 0x2c) = _DAT_44b000a0 & 0xff;
    uVar1 = _DAT_44b000a0;
    ptVar3->mac_control_info = 0x2200;
    ptVar3->phy_control_info = 0x3f0000;
    *(uint *)(ptVar3->field_0 + 0x30) = uVar1 & 0xff;
    ptVar3 = ptVar2;
  } while (ptVar2 != txl_frame_buf_ctrl);
  ptVar3 = txl_buffer_control_desc_bcmc;
  do {
    *(undefined4 *)ptVar3->field_0 = 0xbadcab1e;
    uVar4 = phy_get_ntx();
    *(int *)(ptVar3->field_0 + 4) = CONCAT31(extraout_var_00,uVar4) << 0xe;
    bVar5 = phy_get_ntx();
    *(int *)(ptVar3->field_0 + 8) = (1 << ((uint)bVar5 + 1 & 0x1f)) + -1;
    *(undefined4 *)(ptVar3->field_0 + 0xc) = 0;
    *(undefined4 *)(ptVar3->field_0 + 0x10) = 0xffff0704;
    *(undefined4 *)(ptVar3->field_0 + 0x14) = 0;
    *(undefined4 *)(ptVar3->field_0 + 0x18) = 0;
    *(undefined4 *)(ptVar3->field_0 + 0x1c) = 0;
    *(undefined4 *)(ptVar3->field_0 + 0x20) = 0;
    uVar1 = _DAT_44b000a0;
    ptVar2 = ptVar3 + 1;
    *(undefined4 *)(ptVar3->field_0 + 0x28) = 0;
    *(uint *)(ptVar3->field_0 + 0x24) = uVar1 & 0xff;
    *(undefined4 *)(ptVar3->field_0 + 0x2c) = 0;
    *(undefined4 *)(ptVar3->field_0 + 0x30) = 0;
    ptVar3->mac_control_info = 0;
    ptVar3->phy_control_info = 0x3f0000;
    ptVar3 = ptVar2;
  } while (ptVar2 != txl_buffer_control_desc);
  return;
}



void txl_buffer_reset(void)

{
  txl_buffer_env.list[0].first = (txl_buffer_tag *)0x0;
  txl_buffer_env.list[0].last = (txl_buffer_tag *)0x0;
  return;
}



txl_buffer_tag * txl_buffer_alloc(txdesc *txdesc,uint8_t access_category,uint8_t user_idx)

{
  ushort uVar1;
  txl_buffer_tag *ptVar2;
  txl_buffer_tag *ptVar3;
  txl_buffer_control *ptVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  
  uVar5 = (uint)(txdesc->umac).head_len;
  *(uint8_t *)(txdesc->buf + 0x3b) = user_idx;
  txdesc->buf[2] = (uVar5 + 0xf & 0xfffffff0) - uVar5;
  txdesc->buf[0xe] = 0xcafefade;
  uVar1 = (txdesc->host).flags;
  txdesc->buf[1] = uVar5;
  ptVar3 = (txl_buffer_tag *)txdesc->buf;
  if ((uVar1 & 8) == 0) {
    txu_cntrl_frame_build(txdesc,(int)txdesc->buf + uVar5 + 0x14c);
  }
  ptVar4 = (txdesc->umac).buf_control;
  iVar6 = 0;
  do {
    iVar7 = iVar6 + 4;
    *(undefined4 *)((int)txdesc->buf + iVar6 + 0xf0) = *(undefined4 *)(ptVar4->field_0 + iVar6);
    iVar6 = iVar7;
  } while (iVar7 != 0x3c);
  ptVar2 = ptVar3;
  if (txl_buffer_env.list[0].first != (txl_buffer_tag *)0x0) {
    (txl_buffer_env.list[0].last)->next = ptVar3;
    ptVar2 = txl_buffer_env.list[0].first;
  }
  txl_buffer_env.list[0].first = ptVar2;
  txl_buffer_env.list[0].last = ptVar3;
  txdesc->buf[4] = 0;
  return ptVar3;
}



void txl_buffer_update_thd(txdesc *txdesc)

{
  char "txl_buffer_update_thd" [22];
  uint32_t *puVar1;
  int iVar2;
  tx_pbd *in_a2;
  tx_pbd *ptVar3;
  uint32_t uVar4;
  txl_buffer_tag *ptVar5;
  tx_hw_desc *ptVar6;
  uint32_t uVar7;
  
  ptVar5 = (txdesc->lmac).buffer;
  ptVar6 = (txdesc->lmac).hw_desc;
  puVar1 = (txdesc->host).pbuf_chained_ptr;
  iVar2 = 0;
  ptVar3 = ptVar5->tbd_body;
  while (*puVar1 != 0) {
    ptVar3->upatterntx = 0xcafefade;
    uVar4 = *puVar1;
    ptVar3->datastartptr = uVar4;
    uVar7 = puVar1[4];
    ptVar3->bufctrlinfo = 0;
    iVar2 = iVar2 + 1;
    ptVar3->dataendptr = (uVar4 + uVar7) - 1;
    *(tx_pbd **)&ptVar3->next = ptVar3 + 1;
    puVar1 = puVar1 + 1;
    in_a2 = ptVar3;
    ptVar3 = ptVar3 + 1;
  }
  if (iVar2 == 0) {
    printf("%s: assert when set add_pbd chain\r\n","txl_buffer_update_thd");
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  uVar4 = ptVar5->lenheader;
  (ptVar5->tbd).upatterntx = 0xcafefade;
  *(txl_buffer_tag **)&(ptVar5->tbd).datastartptr = ptVar5 + 1;
  *(uint8_t **)&(ptVar5->tbd).dataendptr = ptVar5->tkip_mic_icv + uVar4 + 0xb;
  *(tx_pbd **)&(ptVar5->tbd).next = ptVar5->tbd_body;
  (ptVar5->tbd).bufctrlinfo = 0;
  *(tx_pbd **)&(ptVar6->thd).field_3 = &ptVar5->tbd;
  in_a2->bufctrlinfo = 0;
  (ptVar6->thd).macctrlinfo2 = 0x100;
  in_a2->next = 0;
  return;
}



void txl_cfm_init(void)

{
  memset(&txl_cfm_env,0,0x28);
  co_list_init((co_list *)&txl_cfm_env);
  co_list_init(txl_cfm_env.cfmlist + 1);
  co_list_init(txl_cfm_env.cfmlist + 2);
  co_list_init(txl_cfm_env.cfmlist + 3);
  co_list_init(txl_cfm_env.cfmlist + 4);
  return;
}



void txl_cfm_push(txdesc *txdesc,u32_l status,u8_l access_category)

{
  undefined3 in_register_00002031;
  
  ((txdesc->lmac).hw_desc)->cfm_ptr->status = status;
  co_list_push_back(txl_cfm_env.cfmlist + CONCAT31(in_register_00002031,access_category),
                    (co_list_hdr *)txdesc);
  ke_evt_set(txl_cfm_evt_bit[CONCAT31(in_register_00002031,access_category)]);
  return;
}


/*
Unable to decompile 'txl_cfm_evt'
Cause: Exception while decompiling 2305f834: Decompiler process died

*/


void txl_cfm_flush(u8_l access_category,co_list *list,u32_l status)

{
  txdesc *txdesc;
  tx_cfm_tag *ptVar1;
  
  while (txdesc = (txdesc *)co_list_pop_front(list), txdesc != (txdesc *)0x0) {
    ptVar1 = ((txdesc->lmac).hw_desc)->cfm_ptr;
    if ((txdesc->lmac).agg_desc == (tx_agg_desc *)0x0) {
      if (-1 < (int)ptVar1->status) {
        ptVar1->status = status;
      }
    }
    else {
      ptVar1->status = status | 0x3c000000;
    }
    if ((txdesc->host).packet_addr == 0) {
      txl_frame_cfm(txdesc);
    }
    else {
      txu_cntrl_cfm(txdesc);
      txl_cntrl_env.pck_cnt = txl_cntrl_env.pck_cnt - 1;
      if ((txdesc->lmac).buffer != (txl_buffer_tag *)0x0) {
        (txdesc->lmac).buffer = (txl_buffer_tag *)0x0;
      }
    }
  }
  txl_frame_evt(0);
  ipc_emb_txcfm_ind(1 << ((uint)access_category & 0x1f));
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void txl_cfm_dma_int_handler(void)

{
  ps_env.prevent_sleep = ps_env.prevent_sleep & 0xfffffffe;
  _DAT_44a00020 = _DAT_44a00024 & 0x100;
  return;
}



void txl_cfm_dump(void)

{
  txl_cfm_env_tag *list;
  uint32_t uVar1;
  uint32_t **ppuVar2;
  
  list = &txl_cfm_env;
  do {
    uVar1 = co_list_cnt((co_list *)list);
    if (uVar1 != 0) {
      ppuVar2 = (uint32_t **)((bam_env_tag *)list)->pkt_cnt;
      while (ppuVar2 != (uint32_t **)0x0) {
        ppuVar2 = (uint32_t **)*ppuVar2;
      }
    }
    list = (txl_cfm_env_tag *)&((bam_env_tag *)list)->ssn;
  } while ((bam_env_tag *)list != bam_env);
  return;
}



void bam_init(void)

{
  bam_env[0].sta_idx = -1;
  ke_state_set(8,0);
  return;
}



void bam_send_air_action_frame
               (int param_1,bam_env_tag *param_2,int param_3,uint8_t param_4,int param_5,
               uint16_t param_6,cfm_func_ptr *param_7)

{
  byte bVar1;
  uint8_t ac;
  uint16_t uVar2;
  txl_frame_desc_tag *frame;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  txl_buffer_tag *ptVar3;
  tx_hw_desc *ptVar4;
  int iVar5;
  uint uVar6;
  char acStack72 [20];
  
  bVar1 = sta_info_tab[param_1].inst_nbr;
  uVar6 = (uint)bVar1;
  phy_get_channel((phy_channel_info *)acStack72,'\0');
  frame = txl_frame_get((uint)(acStack72[0] != '\0'),0x100);
  if (frame == (txl_frame_desc_tag *)0x0) {
    return;
  }
  tpc_update_frame_tx_power(vif_info_tab + uVar6,frame);
  ptVar3 = (frame->txdesc).lmac.buffer;
  *(undefined *)&ptVar3[1].length = 0xd0;
  *(undefined *)((int)&ptVar3[1].length + 1) = 0;
  *(undefined *)((int)&ptVar3[1].length + 2) = 0;
  *(undefined *)((int)&ptVar3[1].length + 3) = 0;
  *(uint16_t *)&ptVar3[1].lenheader = sta_info_tab[param_1].mac_addr.array[0];
  *(uint16_t *)((int)&ptVar3[1].lenheader + 2) = sta_info_tab[param_1].mac_addr.array[1];
  *(uint16_t *)&ptVar3[1].lenpad = sta_info_tab[param_1].mac_addr.array[2];
  *(uint16_t *)((int)&ptVar3[1].lenpad + 2) = vif_info_tab[uVar6].mac_addr.array[0];
  *(uint16_t *)&ptVar3[1].flags = vif_info_tab[uVar6].mac_addr.array[1];
  *(uint16_t *)((int)&ptVar3[1].flags + 2) = vif_info_tab[uVar6].mac_addr.array[2];
  if (vif_info_tab[uVar6].type == '\x02') {
    *(uint16_t *)&ptVar3[1].next = vif_info_tab[uVar6].mac_addr.array[0];
    *(uint16_t *)((int)&ptVar3[1].next + 2) = vif_info_tab[uVar6].mac_addr.array[1];
    uVar2 = vif_info_tab[uVar6].mac_addr.array[2];
  }
  else {
    *(uint16_t *)&ptVar3[1].next = sta_info_tab[param_1].mac_addr.array[0];
    *(uint16_t *)((int)&ptVar3[1].next + 2) = sta_info_tab[param_1].mac_addr.array[1];
    uVar2 = sta_info_tab[param_1].mac_addr.array[2];
  }
  *(uint16_t *)&ptVar3[1].txdesc = uVar2;
  uVar6 = (uint)txl_cntrl_env.seqnbr;
  txl_cntrl_env.seqnbr = (uint16_t)((uVar6 + 1) * 0x10000 >> 0x10);
  iVar5 = (uVar6 + 1) * 0x100000;
  *(undefined *)((int)&ptVar3[1].txdesc + 2) = (char)((uint)iVar5 >> 0x10);
  *(undefined *)((int)&ptVar3[1].txdesc + 3) = (char)((uint)iVar5 >> 0x18);
  (frame->txdesc).host.vif_idx = bVar1;
  (frame->txdesc).host.staid = (uint8_t)param_1;
  if (param_3 == 1) {
    uVar2 = me_build_add_ba_rsp((uint32_t)ptVar3[1].dma_desc,param_2,(uint16_t)param_5,param_4,
                                param_6);
    iVar5 = CONCAT22(extraout_var_00,uVar2);
LAB_2305fb96:
    iVar5 = iVar5 + 0x18;
  }
  else {
    if (param_3 == 0) {
      ac = "\x01"[param_5 >> 2 & 0xf];
      uVar2 = me_build_add_ba_req((uint32_t)ptVar3[1].dma_desc,param_2);
      iVar5 = CONCAT22(extraout_var,uVar2) + 0x18;
      goto LAB_2305fb48;
    }
    if (param_3 == 2) {
      uVar2 = me_build_del_ba((uint32_t)ptVar3[1].dma_desc,param_2,param_6);
      iVar5 = CONCAT22(extraout_var_01,uVar2);
      goto LAB_2305fb96;
    }
    assert_warn("0","module",0x25d);
    iVar5 = 0x18;
  }
  ac = '\x03';
LAB_2305fb48:
  ptVar4 = (frame->txdesc).lmac.hw_desc;
  (ptVar4->thd).field_5 = (ptVar4->thd).field_4 + -1 + iVar5;
  (ptVar4->thd).frmlen = iVar5 + 4;
  if (param_7 != (cfm_func_ptr *)0x0) {
    (frame->cfm).cfm_func = param_7;
    *(bam_env_tag **)&(frame->cfm).env = param_2;
  }
  txl_frame_push(frame,ac);
  return;
}



undefined4 rxu_mgt_ind_handler(int param_1)

{
  int iVar1;
  int iVar2;
  byte bVar3;
  byte bVar4;
  ushort uVar5;
  uint uVar6;
  uint uVar7;
  
  if (*(char *)(param_1 + 0x1d) == '\0') {
    uVar5 = *(ushort *)(param_1 + 0x1f);
    bVar3 = *(byte *)(param_1 + 7);
    bVar4 = *(byte *)(param_1 + 0x1e);
    iVar1 = -0x4fc;
    if ((uVar5 & 1) != 0) {
      iVar1 = -0x4f8;
    }
    iVar2 = -0x4ec;
    if ((uVar5 & 2) == 0) {
      iVar2 = -0x4d8;
    }
    uVar7 = (uint)(uVar5 >> 6);
    printf(
           "-----------------> AABA Request:\r\n    A-MSDU: %s\r\n    Block Ack Policy: %s\r\n    TID: %u\r\n    Number of Buffers: %u\r\n"
           ,iVar1 + 0x2307f000,iVar2 + 0x2307f000,(int)(uint)uVar5 >> 2 & 0xf,uVar7);
    if (8 < uVar5 >> 6) {
      uVar7 = 8;
    }
    uVar6 = SEXT24((short)((ushort)(uVar7 << 6) | uVar5 & 0x3e | 2));
    uVar7 = uVar6 & 0xffff;
    printf(
           "-----------------> AABA Response:\r\n    A-MSDU: %s\r\n    Block Ack Policy: %s\r\n    TID: %u\r\n    Number of Buffers: %u\r\n"
           ,"Not Permitted","Immediate Block Ack",(int)uVar6 >> 2 & 0xf,uVar7 >> 6);
    bam_send_air_action_frame((uint)bVar3,0,1,(uint)bVar4,uVar7,0,0);
    return 0;
  }
  return 0;
}



void co_pack8p(uint32_t dst,uint8_t *src,uint32_t len)

{
  uint8_t *puVar1;
  uint8_t *puVar2;
  uint32_t uVar3;
  
  uVar3 = 0;
  while (len != uVar3) {
    puVar1 = src + uVar3;
    puVar2 = (uint8_t *)(dst + uVar3);
    uVar3 = uVar3 + 1;
    *puVar2 = *puVar1;
  }
  return;
}



int phy_freq_to_channel(uint8_t band,uint16_t freq)

{
  undefined3 in_register_00002029;
  undefined2 in_register_0000202e;
  int iVar1;
  int iVar2;
  
  iVar1 = CONCAT22(in_register_0000202e,freq);
  if (CONCAT31(in_register_00002029,band) == 0) {
    if (0x48 < (iVar1 - 0x96cU & 0xffff)) {
      return 0;
    }
    if (iVar1 == 0x9b4) {
      return 0xe;
    }
    iVar2 = -0x967;
  }
  else {
    if (CONCAT31(in_register_00002029,band) != 1) {
      return 0;
    }
    if (0x334 < (iVar1 - 0x138dU & 0xffff)) {
      return 0;
    }
    iVar2 = -5000;
  }
  return (iVar1 + iVar2) / 5;
}



uint16_t phy_channel_to_freq(uint8_t band,int channel)

{
  undefined3 in_register_00002029;
  int iVar1;
  
  if (CONCAT31(in_register_00002029,band) == 0) {
    if (0xd < channel - 1U) {
      return 0xffff;
    }
    if (channel == 0xe) {
      return 0x9b4;
    }
    iVar1 = 0x967;
  }
  else {
    if (0xa4 < channel - 1U) {
      return 0xffff;
    }
    iVar1 = 5000;
  }
  return (uint16_t)((uint)((channel * 5 + iVar1) * 0x10000) >> 0x10);
}



uint32_t me_add_ie_ssid(uint32_t *frame_addr,uint8_t ssid_len,uint8_t *p_ssid)

{
  undefined3 in_register_0000202d;
  uint32_t len;
  
  len = CONCAT31(in_register_0000202d,ssid_len);
  *(undefined *)*frame_addr = 0;
  *(uint8_t *)(*frame_addr + 1) = ssid_len;
  if (len != 0) {
    co_pack8p(*frame_addr + 2,p_ssid,len);
  }
  *frame_addr = *frame_addr + len + 2;
  return len + 2;
}



uint32_t me_add_ie_supp_rates(uint32_t *frame_addr,mac_rateset *p_rateset)

{
  uint32_t len;
  byte bVar1;
  
  bVar1 = p_rateset->length;
  len = 8;
  if (bVar1 < 9) {
    len = (uint)bVar1;
  }
  *(undefined *)*frame_addr = 1;
  if (8 < bVar1) {
    bVar1 = 8;
  }
  *(byte *)(*frame_addr + 1) = bVar1;
  co_pack8p(*frame_addr + 2,p_rateset->array,len);
  *frame_addr = *frame_addr + len + 2;
  return len + 2;
}



uint32_t me_add_ie_ext_supp_rates(uint32_t *frame_addr,mac_rateset *p_rateset)

{
  byte bVar1;
  uint32_t uVar2;
  uint32_t len;
  
  bVar1 = p_rateset->length;
  *(undefined *)*frame_addr = 0x32;
  uVar2 = (uint)bVar1 - 6;
  len = (uint)bVar1 - 8;
  *(undefined *)(*frame_addr + 1) = (char)len;
  co_pack8p(*frame_addr + 2,p_rateset->array + 8,len);
  *frame_addr = *frame_addr + uVar2;
  return uVar2;
}



uint32_t me_add_ie_ds(uint32_t *frame_addr,uint8_t channel)

{
  *(undefined *)*frame_addr = 3;
  *(undefined *)(*frame_addr + 1) = 1;
  *(uint8_t *)(*frame_addr + 2) = channel;
  *frame_addr = *frame_addr + 3;
  return 3;
}



uint32_t me_add_ie_erp(uint32_t *frame_addr,uint8_t erp_info)

{
  *(undefined *)*frame_addr = 0x2a;
  *(undefined *)(*frame_addr + 1) = 1;
  *(uint8_t *)(*frame_addr + 2) = erp_info;
  *frame_addr = *frame_addr + 3;
  return 3;
}



uint32_t me_add_ie_rsn(uint32_t *frame_addr,uint8_t enc_type)

{
  undefined3 in_register_0000202d;
  uint32_t uVar1;
  uint32_t uVar2;
  
  if (CONCAT31(in_register_0000202d,enc_type) == 1) {
    *(undefined *)*frame_addr = 0x30;
    *(undefined *)(*frame_addr + 1) = 0x14;
    uVar1 = *frame_addr;
    *(uint8_t *)(uVar1 + 2) = enc_type;
    *(undefined *)(uVar1 + 3) = 0;
    uVar1 = *frame_addr;
    *(undefined *)(uVar1 + 6) = 0xac;
    *(undefined *)(uVar1 + 7) = 4;
    *(undefined *)(uVar1 + 4) = 0;
    *(undefined *)(uVar1 + 5) = 0xf;
    uVar1 = *frame_addr;
    *(uint8_t *)(uVar1 + 8) = enc_type;
    *(undefined *)(uVar1 + 9) = 0;
    uVar1 = *frame_addr;
    *(undefined *)(uVar1 + 0xc) = 0xac;
    *(undefined *)(uVar1 + 0xd) = 4;
    *(undefined *)(uVar1 + 10) = 0;
    *(undefined *)(uVar1 + 0xb) = 0xf;
    uVar2 = *frame_addr;
    uVar1 = 0x16;
    *(uint8_t *)(uVar2 + 0xe) = enc_type;
    *(undefined *)(uVar2 + 0xf) = 0;
    uVar2 = *frame_addr;
    *(undefined *)(uVar2 + 0x12) = 0xac;
    *(undefined *)(uVar2 + 0x10) = 0;
    *(undefined *)(uVar2 + 0x11) = 0xf;
    *(undefined *)(uVar2 + 0x13) = 2;
    uVar2 = *frame_addr;
    *(undefined *)(uVar2 + 0x14) = 0;
    *(undefined *)(uVar2 + 0x15) = 0;
  }
  else {
    uVar1 = 0;
    if (CONCAT31(in_register_0000202d,enc_type) == 2) {
      *(undefined *)*frame_addr = 0x30;
      *(undefined *)(*frame_addr + 1) = 0x18;
      uVar1 = *frame_addr;
      *(undefined *)(uVar1 + 2) = 1;
      *(undefined *)(uVar1 + 3) = 0;
      uVar1 = *frame_addr;
      *(undefined *)(uVar1 + 4) = 0;
      *(undefined *)(uVar1 + 5) = 0xf;
      *(undefined *)(uVar1 + 6) = 0xac;
      *(uint8_t *)(uVar1 + 7) = enc_type;
      uVar1 = *frame_addr;
      *(uint8_t *)(uVar1 + 8) = enc_type;
      *(undefined *)(uVar1 + 9) = 0;
      uVar1 = *frame_addr;
      *(undefined *)(uVar1 + 10) = 0;
      *(undefined *)(uVar1 + 0xb) = 0xf;
      *(undefined *)(uVar1 + 0xc) = 0xac;
      *(uint8_t *)(uVar1 + 0xd) = enc_type;
      uVar1 = *frame_addr;
      *(undefined *)(uVar1 + 0x11) = 4;
      *(undefined *)(uVar1 + 0xe) = 0;
      *(undefined *)(uVar1 + 0xf) = 0xf;
      *(undefined *)(uVar1 + 0x10) = 0xac;
      uVar2 = *frame_addr;
      uVar1 = 0x1a;
      *(undefined *)(uVar2 + 0x12) = 1;
      *(undefined *)(uVar2 + 0x13) = 0;
      uVar2 = *frame_addr;
      *(undefined *)(uVar2 + 0x14) = 0;
      *(undefined *)(uVar2 + 0x15) = 0xf;
      *(undefined *)(uVar2 + 0x16) = 0xac;
      *(uint8_t *)(uVar2 + 0x17) = enc_type;
      uVar2 = *frame_addr;
      *(undefined *)(uVar2 + 0x18) = 0;
      *(undefined *)(uVar2 + 0x19) = 0;
    }
  }
  *frame_addr = *frame_addr + uVar1;
  return uVar1;
}



uint32_t me_add_ie_wpa(uint32_t *frame_addr,uint8_t enc_type)

{
  uint32_t uVar1;
  undefined3 in_register_0000202d;
  uint32_t uVar2;
  
  uVar1 = 0;
  if (CONCAT31(in_register_0000202d,enc_type) == 2) {
    *(undefined *)*frame_addr = 0xdd;
    *(undefined *)(*frame_addr + 1) = 0x1c;
    uVar1 = *frame_addr;
    *(undefined *)(uVar1 + 5) = 1;
    *(undefined *)(uVar1 + 2) = 0;
    *(undefined *)(uVar1 + 3) = 0x50;
    *(undefined *)(uVar1 + 4) = 0xf2;
    uVar1 = *frame_addr;
    *(undefined *)(uVar1 + 6) = 1;
    *(undefined *)(uVar1 + 7) = 0;
    uVar1 = *frame_addr;
    *(undefined *)(uVar1 + 8) = 0;
    *(undefined *)(uVar1 + 9) = 0x50;
    *(undefined *)(uVar1 + 10) = 0xf2;
    *(uint8_t *)(uVar1 + 0xb) = enc_type;
    uVar1 = *frame_addr;
    *(uint8_t *)(uVar1 + 0xc) = enc_type;
    *(undefined *)(uVar1 + 0xd) = 0;
    uVar1 = *frame_addr;
    *(undefined *)(uVar1 + 0xe) = 0;
    *(undefined *)(uVar1 + 0xf) = 0x50;
    *(undefined *)(uVar1 + 0x10) = 0xf2;
    *(uint8_t *)(uVar1 + 0x11) = enc_type;
    uVar1 = *frame_addr;
    *(undefined *)(uVar1 + 0x12) = 0;
    *(undefined *)(uVar1 + 0x13) = 0x50;
    *(undefined *)(uVar1 + 0x14) = 0xf2;
    *(undefined *)(uVar1 + 0x15) = 4;
    uVar1 = *frame_addr;
    *(undefined *)(uVar1 + 0x16) = 1;
    *(undefined *)(uVar1 + 0x17) = 0;
    uVar2 = *frame_addr;
    uVar1 = 0x1e;
    *(undefined *)(uVar2 + 0x18) = 0;
    *(undefined *)(uVar2 + 0x19) = 0x50;
    *(undefined *)(uVar2 + 0x1a) = 0xf2;
    *(uint8_t *)(uVar2 + 0x1b) = enc_type;
  }
  *frame_addr = *frame_addr + uVar1;
  return uVar1;
}



uint32_t me_add_ie_tim(uint32_t *frame_addr,uint8_t dtim_period)

{
  *(undefined *)*frame_addr = 5;
  *(undefined *)(*frame_addr + 1) = 4;
  *(uint8_t *)(*frame_addr + 3) = dtim_period;
  *frame_addr = *frame_addr + 6;
  return 6;
}



uint32_t me_add_ie_ht_capa(uint32_t *frame_addr)

{
  u16_l uVar1;
  uint32_t uVar2;
  uint uVar3;
  
  uVar3 = (uint)me_env.ht_cap.ht_capa_info;
  *(undefined *)*frame_addr = 0x2d;
  *(undefined *)(*frame_addr + 1) = 0x1a;
  uVar2 = *frame_addr;
  *(byte *)(uVar2 + 2) = (byte)(uVar3 & 0xfffffff3) | 0xc;
  *(undefined *)(uVar2 + 3) = (char)((uVar3 & 0xfffffff3) >> 8);
  *(u8_l *)(*frame_addr + 4) = me_env.ht_cap.a_mpdu_param;
  co_pack8p(*frame_addr + 5,me_env.ht_cap.mcs_rate,0x10);
  uVar1 = me_env.ht_cap.ht_extended_capa;
  uVar2 = *frame_addr;
  *(undefined *)(uVar2 + 0x15) = (char)me_env.ht_cap.ht_extended_capa;
  *(undefined *)(uVar2 + 0x16) = (char)(uVar1 >> 8);
  co_pack8p(*frame_addr + 0x17,(uint8_t *)&me_env.ht_cap.tx_beamforming_capa,4);
  *(u8_l *)(*frame_addr + 0x1b) = me_env.ht_cap.asel_capa;
  *frame_addr = *frame_addr + 0x1c;
  return 0x1c;
}



uint32_t me_add_ie_ht_oper(uint32_t *frame_addr,vif_info_tag *p_vif_entry)

{
  chan_ctxt_tag *pcVar1;
  int iVar2;
  uint8_t uVar3;
  uint32_t uVar4;
  
  pcVar1 = p_vif_entry->chan_ctxt;
  *(undefined *)*frame_addr = 0x3d;
  *(undefined *)(*frame_addr + 1) = 0x16;
  iVar2 = phy_freq_to_channel((pcVar1->channel).band,(pcVar1->channel).prim20_freq);
  *(undefined *)(*frame_addr + 2) = (char)iVar2;
  uVar3 = (pcVar1->channel).type;
  if ((uVar3 != '\0') &&
     (uVar3 = '\a', (pcVar1->channel).prim20_freq <= (pcVar1->channel).center1_freq)) {
    uVar3 = '\x05';
  }
  *(uint8_t *)(*frame_addr + 3) = uVar3;
  uVar4 = *frame_addr;
  *(undefined *)(uVar4 + 4) = 3;
  *(undefined *)(uVar4 + 5) = 0;
  uVar4 = *frame_addr;
  *(undefined *)(uVar4 + 6) = 0;
  *(undefined *)(uVar4 + 7) = 0;
  *(undefined *)(*frame_addr + 8) = 0xff;
  *frame_addr = *frame_addr + 0x18;
  return 0x18;
}



uint16_t me_build_authenticate
                   (uint32_t frame,uint16_t algo_type,uint16_t seq_nbr,uint16_t status_code,
                   uint32_t *challenge_array_ptr)

{
  undefined *puVar1;
  undefined *puVar2;
  int iVar3;
  
  *(char *)frame = (char)algo_type;
  *(undefined *)(frame + 2) = (char)seq_nbr;
  *(undefined *)(frame + 4) = (char)status_code;
  *(undefined *)(frame + 1) = (char)(algo_type >> 8);
  *(undefined *)(frame + 3) = (char)(seq_nbr >> 8);
  *(undefined *)(frame + 5) = (char)(status_code >> 8);
  if (challenge_array_ptr != (uint32_t *)0x0) {
    *(undefined *)(frame + 6) = 0x10;
    *(undefined *)(frame + 7) = 0x80;
    iVar3 = 0;
    do {
      puVar1 = (undefined *)((int)challenge_array_ptr + iVar3);
      puVar2 = (undefined *)(frame + 8 + iVar3);
      iVar3 = iVar3 + 1;
      *puVar2 = *puVar1;
    } while (iVar3 != 0x80);
    return 0x88;
  }
  return 6;
}



uint16_t me_build_deauthenticate(uint32_t frame,uint16_t reason_code)

{
  *(char *)frame = (char)reason_code;
  *(undefined *)(frame + 1) = (char)(reason_code >> 8);
  return 2;
}



// WARNING: Could not reconcile some variable overlaps

uint16_t me_build_associate_req
                   (uint32_t frame,mac_bss_info *bss,mac_addr_conflict171 *old_ap_addr_ptr,
                   uint8_t vif_idx,uint32_t *ie_addr,uint16_t *ie_len,sm_connect_req *con_par)

{
  byte bVar1;
  u32_l *puVar2;
  u8_l uVar3;
  ushort uVar4;
  mac_ssid *pmVar5;
  int8_t *piVar6;
  uint uVar7;
  u16_l uVar8;
  short sVar9;
  int iVar10;
  uint16_t uVar11;
  uint32_t uVar12;
  uint32_t uVar13;
  uint uVar14;
  char *pcVar15;
  int8_t *dst;
  uint uVar16;
  uint uVar17;
  uint uVar18;
  uint uVar19;
  me_chan_config_req *pmVar20;
  char cVar21;
  char cVar22;
  uint uVar23;
  u8_l uVar24;
  int8_t *apiStack100 [4];
  int8_t iStack81;
  undefined2 uStack80;
  undefined uStack78;
  s8_l min;
  s8_l max;
  
  uVar8 = con_par->listen_interval;
  uVar4 = con_par->ie_len;
  if (uVar8 == 0) {
    uVar8 = 5;
  }
  apiStack100[0] = (int8_t *)frame;
  uVar11 = me_build_capability(vif_idx);
  *apiStack100[0] = (int8_t)uVar11;
  apiStack100[0][1] = (int8_t)(uVar11 >> 8);
  apiStack100[0][2] = (int8_t)uVar8;
  apiStack100[0][3] = (int8_t)(uVar8 >> 8);
  iVar10 = 4;
  if (old_ap_addr_ptr != (mac_addr_conflict171 *)0x0) {
    iVar10 = 10;
    *(uint16_t *)(apiStack100[0] + 4) = old_ap_addr_ptr->array[0];
    *(uint16_t *)(apiStack100[0] + 6) = old_ap_addr_ptr->array[1];
    *(uint16_t *)(apiStack100[0] + 8) = old_ap_addr_ptr->array[2];
  }
  apiStack100[0] = apiStack100[0] + iVar10;
  *(int8_t **)ie_addr = apiStack100[0];
  uVar12 = me_add_ie_ssid((uint32_t *)apiStack100,(bss->ssid).length,(bss->ssid).array);
  uVar13 = me_add_ie_supp_rates((uint32_t *)apiStack100,&bss->rate_set);
  sVar9 = (short)iVar10 + (short)uVar13 + (short)uVar12;
  if (8 < (bss->rate_set).length) {
    uVar12 = me_add_ie_ext_supp_rates((uint32_t *)apiStack100,&bss->rate_set);
    sVar9 = sVar9 + (short)uVar12;
  }
  if ((uVar11 & 0x100) != 0) {
    dst = apiStack100[0] + 1;
    *apiStack100[0] = '!';
    apiStack100[0] = apiStack100[0] + 2;
    *dst = '\x02';
    phy_get_rf_gain_capab((int8_t *)&uStack80,&iStack81);
    bVar1 = bss->chan->tx_power;
    if ((char)bVar1 < (char)uStack80) {
      uStack80 = uStack80 & 0xff00 | (ushort)bVar1;
    }
    *apiStack100[0] = iStack81;
    apiStack100[0][1] = (char)uStack80;
    dst = apiStack100[0] + 3;
    apiStack100[0][2] = '$';
    apiStack100[0] = apiStack100[0] + 4;
    if (bss->chan->band == '\0') {
      pmVar20 = &me_env.chan;
      iVar10 = 1;
      uVar3 = me_env.chan.chan2G4_cnt;
    }
    else {
      pmVar20 = (me_chan_config_req *)me_env.chan.chan5G;
      iVar10 = 4;
      uVar3 = me_env.chan.chan5G_cnt;
    }
    uVar19 = 0;
    cVar21 = '\0';
    uVar24 = '\0';
    uVar7 = 0;
    uVar17 = 0;
    while( true ) {
      piVar6 = apiStack100[0];
      uVar23 = uVar19 + 2 & 0xff;
      pcVar15 = apiStack100[0] + 1;
      if (uVar24 == uVar3) break;
      uVar16 = uVar7;
      uVar18 = uVar17;
      if ((pmVar20->chan2G4[0].flags & 2) == 0) {
        uVar14 = phy_freq_to_channel(pmVar20->chan2G4[0].band,pmVar20->chan2G4[0].freq);
        uVar16 = uVar14 & 0xff;
        uVar18 = uVar16;
        cVar22 = cVar21;
        if ((cVar21 != '\0') && (uVar18 = uVar17, (uVar14 & 0xff) - uVar7 != iVar10)) {
          cVar22 = cVar21 + '\x01';
          *piVar6 = (int8_t)uVar17;
          apiStack100[0] = piVar6 + 2;
          *pcVar15 = cVar21;
          uVar19 = uVar23;
        }
        cVar21 = cVar22 + '\x01';
        pmVar20 = (me_chan_config_req *)(pmVar20->chan2G4 + 1);
      }
      uVar24 = uVar24 + '\x01';
      uVar7 = uVar16;
      uVar17 = uVar18;
    }
    *apiStack100[0] = (int8_t)uVar17;
    sVar9 = sVar9 + 6 + (short)uVar23;
    apiStack100[0] = apiStack100[0] + 2;
    *pcVar15 = cVar21;
    *dst = (int8_t)uVar23;
  }
  pmVar5 = &con_par->ssid;
  iVar10 = -(int)con_par;
  while ((sm_connect_req *)(&pmVar5->length + uVar4) != con_par) {
    puVar2 = con_par->ie_buf;
    dst = apiStack100[0] + iVar10 + (int)con_par;
    con_par = (sm_connect_req *)(con_par->ssid).array;
    *dst = *(int8_t *)puVar2;
  }
  uVar11 = sVar9 + uVar4;
  dst = apiStack100[0] + uVar4;
  apiStack100[0] = dst;
  if ((bss->valid_flags & 1) != 0) {
    memset(&uStack78,0,0xe);
    uStack80 = 0x7dd;
    min = 'P';
    co_pack8p((uint32_t)dst,(uint8_t *)&uStack80,9);
    uVar11 = uVar11 + (ushort)uStack80._1_1_ + 2;
    apiStack100[0] = apiStack100[0] + (uint)uStack80._1_1_ + 2;
  }
  if (((bss->valid_flags & 2) != 0) && (me_env.ht_supported != false)) {
    uVar12 = me_add_ie_ht_capa((uint32_t *)apiStack100);
    uVar11 = uVar11 + (short)uVar12;
  }
  *ie_len = (short)apiStack100[0] - (short)*ie_addr;
  return uVar11;
}



uint16_t me_build_add_ba_req(uint32_t frame,bam_env_tag *bam_env)

{
  uint16_t uVar1;
  uint uVar2;
  int iVar3;
  
  *(undefined *)frame = 3;
  *(undefined *)(frame + 1) = 0;
  *(uint8_t *)(frame + 2) = bam_env->dialog_token;
  uVar2 = (uint)bam_env->ba_policy << 1 | (uint)bam_env->tid << 2 | (uint)bam_env->buffer_size << 6;
  *(undefined *)(frame + 3) = (char)uVar2;
  *(undefined *)(frame + 4) = (char)(uVar2 >> 8);
  uVar1 = bam_env->ba_timeout;
  *(undefined *)(frame + 5) = (char)uVar1;
  *(undefined *)(frame + 6) = (char)(uVar1 >> 8);
  iVar3 = (uint)bam_env->ssn << 0x14;
  *(undefined *)(frame + 7) = (char)((uint)iVar3 >> 0x10);
  *(undefined *)(frame + 8) = (char)((uint)iVar3 >> 0x18);
  return 9;
}



uint16_t me_build_add_ba_rsp(uint32_t frame,bam_env_tag *bam_env,uint16_t param,uint8_t dialog_token
                            ,uint16_t status_code)

{
  undefined2 in_register_0000203a;
  
  *(undefined *)frame = 3;
  *(undefined *)(frame + 1) = 1;
  *(undefined *)(frame + 5) = (char)param;
  *(undefined *)(frame + 4) = (char)(status_code >> 8);
  *(uint8_t *)(frame + 2) = dialog_token;
  *(undefined *)(frame + 3) = (char)status_code;
  *(undefined *)(frame + 6) = (char)(param >> 8);
  if (CONCAT22(in_register_0000203a,status_code) == 0) {
    *(undefined *)(frame + 7) = 0xd0;
    *(undefined *)(frame + 8) = 7;
  }
  else {
    *(undefined *)(frame + 7) = 0;
    *(undefined *)(frame + 8) = 0;
  }
  return 9;
}



uint16_t me_build_del_ba(uint32_t frame,bam_env_tag *bam_env,uint16_t reason_code)

{
  byte bVar1;
  
  *(undefined *)frame = 3;
  *(undefined *)(frame + 1) = 2;
  bVar1 = (byte)(((uint)bam_env->tid << 0x1c) >> 0x18);
  if (bam_env->dev_type == '\x01') {
    bVar1 = bVar1 | 8;
  }
  *(undefined *)(frame + 2) = 0;
  *(byte *)(frame + 3) = bVar1;
  *(undefined *)(frame + 4) = (char)reason_code;
  *(undefined *)(frame + 5) = (char)(reason_code >> 8);
  return 6;
}



void me_extract_rate_set(uint32_t buffer,uint16_t buflen,mac_rateset *mac_rate_set_ptr)

{
  byte bVar1;
  byte bVar2;
  int iVar3;
  undefined2 in_register_0000202e;
  uint uVar4;
  u8_l *puVar5;
  uint uVar6;
  
  mac_rate_set_ptr->length = '\0';
  iVar3 = mac_ie_find(CONCAT22(in_register_0000202e,buflen),1);
  if (iVar3 != 0) {
    bVar1 = *(byte *)(iVar3 + 1);
    uVar4 = (uint)bVar1;
    if (bVar1 < 0xd) {
      puVar5 = mac_rate_set_ptr->array;
      while (uVar4 = uVar4 - 1, uVar4 != 0xffffffff) {
        *puVar5 = (puVar5 + 1)[iVar3 - (int)mac_rate_set_ptr];
        puVar5 = puVar5 + 1;
      }
      mac_rate_set_ptr->length = bVar1;
      iVar3 = mac_ie_find(buffer,CONCAT22(in_register_0000202e,buflen),0x32);
      if (iVar3 != 0) {
        bVar1 = *(byte *)(iVar3 + 1);
        uVar4 = (uint)bVar1;
        if (0xc < mac_rate_set_ptr->length + uVar4) {
          assert_err("mac_rate_set_ptr->length + elmt_length <= MAC_RATESET_LEN","module",0x396);
        }
        bVar2 = mac_rate_set_ptr->length;
        if (bVar2 + uVar4 < 0xd) {
          uVar6 = 0;
          while (uVar4 != uVar6) {
            mac_rate_set_ptr->array[bVar2 + uVar6] = *(u8_l *)(iVar3 + 2 + uVar6);
            uVar6 = uVar6 + 1;
          }
          mac_rate_set_ptr->length = bVar1 + mac_rate_set_ptr->length;
        }
      }
    }
  }
  return;
}



void me_extract_power_constraint(uint32_t buffer,uint16_t buflen,mac_bss_info *bss)

{
  int iVar1;
  uint8_t uVar2;
  
  iVar1 = mac_ie_find(0x20);
  uVar2 = '\0';
  if (iVar1 != 0) {
    uVar2 = *(uint8_t *)(iVar1 + 2);
  }
  bss->power_constraint = uVar2;
  return;
}



void me_extract_country_reg(int param_1)

{
  uint16_t *puVar1;
  int iVar2;
  uint uVar3;
  byte *pbVar4;
  uint uVar5;
  byte bVar6;
  uint uVar7;
  int iVar8;
  
  iVar2 = mac_ie_find(7);
  if (iVar2 != 0) {
    puVar1 = *(uint16_t **)(param_1 + 0x4c);
    iVar8 = 1;
    if (*(uint8_t *)(puVar1 + 1) != '\0') {
      iVar8 = 4;
    }
    uVar3 = phy_freq_to_channel(*(uint8_t *)(puVar1 + 1),*puVar1);
    uVar7 = 5;
    while (uVar7 <= (uint)*(byte *)(iVar2 + 1) + 1) {
      pbVar4 = (byte *)(uVar7 + iVar2);
      uVar5 = (uint)*pbVar4;
      bVar6 = 0;
      while (bVar6 != pbVar4[1]) {
        if (uVar5 == (uVar3 & 0xff)) {
          *(byte *)(puVar1 + 2) = pbVar4[2];
          return;
        }
        bVar6 = bVar6 + 1;
        uVar5 = uVar5 + iVar8 & 0xff;
      }
      uVar7 = uVar7 + 3 & 0xff;
    }
  }
  return;
}



void me_extract_mobility_domain(uint32_t buffer,uint16_t buflen,mac_bss_info *bss)

{
  int iVar1;
  
  iVar1 = mac_ie_find(0x36);
  if (iVar1 == 0) {
    (bss->mde).mdid = 0;
    (bss->mde).ft_capability_policy = '\0';
  }
  else {
    (bss->mde).mdid = *(uint16_t *)(iVar1 + 2);
    (bss->mde).ft_capability_policy = *(uint8_t *)(iVar1 + 4);
  }
  return;
}



uint me_extract_csa(undefined4 param_1,undefined4 param_2,undefined *param_3,int param_4)

{
  byte bVar1;
  byte bVar2;
  bool band;
  short sVar3;
  uint16_t uVar4;
  uint16_t uVar5;
  uint16_t uVar6;
  uint uVar7;
  uint uVar8;
  int iVar9;
  int iVar10;
  undefined uVar11;
  
  uVar7 = mac_ie_find(0x25);
  uVar8 = mac_ie_find(param_1,param_2,0x3c);
  if ((uVar7 | uVar8) == 0) {
    return 0;
  }
  iVar9 = mac_ie_find(param_1,param_2,0x3e);
  iVar10 = mac_ie_find(param_1,param_2,0xc4);
  if (iVar10 != 0) {
    iVar10 = mac_ie_find(iVar10 + 2,(uint)*(byte *)(iVar10 + 1),0xc2);
  }
  if (uVar7 == 0) {
    bVar1 = *(byte *)(uVar8 + 5);
    *param_3 = *(undefined *)(uVar8 + 2);
    bVar2 = *(byte *)(uVar8 + 4);
  }
  else {
    bVar1 = *(byte *)(uVar7 + 4);
    *param_3 = *(undefined *)(uVar7 + 2);
    bVar2 = *(byte *)(uVar7 + 3);
  }
  uVar7 = (uint)bVar1;
  if (bVar1 == 0) {
    uVar7 = 2;
  }
  band = 0xe < bVar2;
  uVar4 = phy_channel_to_freq(band,(uint)bVar2);
  if (iVar10 != 0) {
    uVar8 = (uint)*(byte *)(iVar10 + 2) - 1 & 0xff;
    bVar1 = *(byte *)(iVar10 + 4);
    uVar11 = 1;
    if (uVar8 < 3) {
      uVar11 = *(undefined *)((int)&CSWTCH_115 + uVar8);
    }
    uVar5 = phy_channel_to_freq(band,(uint)*(byte *)(iVar10 + 3));
    uVar6 = 0;
    if (bVar1 != 0) {
      uVar6 = phy_channel_to_freq(band,(uint)bVar1);
    }
    goto LAB_230607fe;
  }
  if (iVar9 == 0) {
LAB_23060860:
    uVar6 = 0;
    uVar11 = 0;
    uVar5 = uVar4;
  }
  else {
    sVar3 = 10;
    if (*(char *)(iVar9 + 2) != '\x01') {
      if (*(char *)(iVar9 + 2) != '\x03') goto LAB_23060860;
      sVar3 = -10;
    }
    uVar6 = 0;
    uVar11 = 1;
    uVar5 = uVar4 + sVar3;
  }
LAB_230607fe:
  *(uint16_t *)(param_4 + 6) = uVar6;
  *(bool *)param_4 = band;
  *(undefined *)(param_4 + 1) = uVar11;
  *(uint16_t *)(param_4 + 2) = uVar4;
  *(uint16_t *)(param_4 + 4) = uVar5;
  return uVar7;
}



// WARNING: Could not reconcile some variable overlaps

uint16_t me_build_beacon(uint32_t frame,uint8_t vif_idx,uint16_t *tim_oft,uint8_t *tim_len,
                        uint8_t hidden_ssid)

{
  uint8_t enc_type;
  short sVar1;
  uint16_t uVar2;
  uint32_t uVar3;
  uint32_t uVar4;
  uint32_t uVar5;
  uint32_t uVar6;
  u8_l ssid_len;
  undefined3 in_register_0000202d;
  int iVar7;
  uint8_t *p_ssid;
  undefined3 in_register_00002039;
  uint uVar8;
  int iVar9;
  undefined *puVar10;
  mac_rateset *p_rateset;
  uint32_t uStack68;
  undefined2 uStack64;
  undefined uStack62;
  undefined uStack61;
  u8_l wme_ie [16];
  
  iVar7 = CONCAT31(in_register_0000202d,vif_idx);
  enc_type = vif_info_tab[iVar7].bss_info.sec_type;
  *(undefined *)frame = 0x80;
  *(undefined *)(frame + 1) = 0;
  *(undefined *)(frame + 2) = 0;
  *(undefined *)(frame + 3) = 0;
  uStack68 = frame;
  memcpy((void *)(frame + 4),&mac_addr_bcst,6);
  memcpy((void *)(frame + 10),&vif_info_tab[iVar7].mac_addr,6);
  memcpy((void *)(frame + 0x10),&vif_info_tab[iVar7].mac_addr,6);
  uVar8 = (uint)txl_cntrl_env.seqnbr;
  txl_cntrl_env.seqnbr = (uint16_t)((uVar8 + 1) * 0x10000 >> 0x10);
  iVar9 = (uVar8 + 1) * 0x100000;
  *(undefined *)(frame + 0x16) = (char)((uint)iVar9 >> 0x10);
  *(undefined *)(frame + 0x17) = (char)((uint)iVar9 >> 0x18);
  uVar2 = vif_info_tab[iVar7].bss_info.beacon_interval;
  *(undefined *)(uStack68 + 0x20) = (char)uVar2;
  *(undefined *)(uStack68 + 0x21) = (char)(uVar2 >> 8);
  uVar2 = me_build_capability(vif_idx);
  if (enc_type != '\0') {
    uVar2 = uVar2 | 0x10;
  }
  p_ssid = vif_info_tab[iVar7].bss_info.ssid.array;
  *(undefined *)(uStack68 + 0x22) = (char)uVar2;
  *(undefined *)(uStack68 + 0x23) = (char)(uVar2 >> 8);
  uStack68 = uStack68 + 0x24;
  if (CONCAT31(in_register_00002039,hidden_ssid) == 0) {
    ssid_len = vif_info_tab[iVar7].bss_info.ssid.length;
  }
  else {
    printf("Using Hidden SSID [%s]\r\n",p_ssid);
    p_ssid = (uint8_t *)0x0;
    ssid_len = '\0';
  }
  uVar3 = me_add_ie_ssid(&uStack68,ssid_len,p_ssid);
  p_rateset = &vif_info_tab[iVar7].bss_info.rate_set;
  uVar4 = me_add_ie_supp_rates(&uStack68,p_rateset);
  uVar8 = (uVar3 + 0x24 & 0xffff) + uVar4 & 0xffff;
  if (8 < vif_info_tab[iVar7].bss_info.rate_set.length) {
    uVar3 = me_add_ie_ext_supp_rates(&uStack68,p_rateset);
    uVar8 = uVar8 + uVar3 & 0xffff;
  }
  uVar3 = me_add_ie_ds(&uStack68,
                       (char)((int)((uint)(vif_info_tab[iVar7].bss_info.chan)->freq - 0x96c) / 5) +
                       '\x01');
  *tim_oft = (uint16_t)((uVar8 + uVar3) * 0x10000 >> 0x10);
  uVar4 = me_add_ie_tim(&uStack68,*(uint8_t *)&vif_info_tab[iVar7].bss_info.beacon_period);
  *tim_len = (uint8_t)(uVar4 & 0xff);
  uVar5 = me_add_ie_rsn(&uStack68,enc_type);
  memcpy(int_rsn_ie,(void *)(uStack68 - (uVar5 & 0xff)),uVar5 & 0xff);
  uVar6 = me_add_ie_erp(&uStack68,'\0');
  sVar1 = (short)(uVar8 + uVar3) + (short)(uVar4 & 0xff) + (short)uVar6 + ((ushort)uVar5 & 0xff);
  if ((vif_info_tab[iVar7].bss_info.valid_flags & 2) != 0) {
    uVar3 = me_add_ie_ht_capa(&uStack68);
    uVar4 = me_add_ie_ht_oper(&uStack68,vif_info_tab + iVar7);
    sVar1 = sVar1 + (short)uVar4 + (short)uVar3;
  }
  uVar3 = me_add_ie_wpa(&uStack68,enc_type);
  uVar2 = sVar1 + (short)uVar3;
  if ((vif_info_tab[iVar7].bss_info.valid_flags & 1) != 0) {
    memset(&uStack62,0,0xe);
    uStack64 = 0x7dd;
    uStack61 = 0x50;
    wme_ie._0_2_ = 0x2f2;
    wme_ie[3] = '\x01';
    wme_ie[4] = vif_info_tab[iVar7].bss_info.edca_param.qos_info;
    co_pack8p(uStack68,(uint8_t *)&uStack64,9);
    *(char *)(uStack68 + 1) = *(char *)(uStack68 + 1) + '\x11';
    puVar10 = (undefined *)(uStack68 + 2 + (uint)uStack64._1_1_);
    *puVar10 = 0;
    uVar3 = vif_info_tab[iVar7].txq_params[1];
    puVar10[1] = (char)uVar3;
    puVar10[2] = (char)(uVar3 >> 8);
    puVar10[3] = (char)(uVar3 >> 0x10);
    puVar10[4] = (char)(uVar3 >> 0x18);
    uVar3 = vif_info_tab[iVar7].txq_params[0];
    puVar10[5] = (char)uVar3;
    puVar10[6] = (char)(uVar3 >> 8);
    puVar10[7] = (char)(uVar3 >> 0x10);
    puVar10[8] = (char)(uVar3 >> 0x18);
    uVar3 = vif_info_tab[iVar7].txq_params[2];
    puVar10[9] = (char)uVar3;
    puVar10[10] = (char)(uVar3 >> 8);
    puVar10[0xb] = (char)(uVar3 >> 0x10);
    puVar10[0xc] = (char)(uVar3 >> 0x18);
    uVar3 = vif_info_tab[iVar7].txq_params[3];
    puVar10[0xd] = (char)uVar3;
    puVar10[0xe] = (char)(uVar3 >> 8);
    puVar10[0xf] = (char)(uVar3 >> 0x10);
    puVar10[0x10] = (char)(uVar3 >> 0x18);
    uVar2 = uVar2 + (ushort)uStack64._1_1_ + 0x13;
  }
  return uVar2;
}



// WARNING: Variable defined which should be unmapped: wme_ie
// WARNING: Could not reconcile some variable overlaps

uint16_t me_build_probe_rsp(uint32_t frame,uint8_t vif_idx)

{
  uint8_t enc_type;
  short sVar1;
  uint16_t uVar2;
  uint32_t uVar3;
  uint32_t uVar4;
  int iVar5;
  uint32_t uVar6;
  undefined3 in_register_0000202d;
  int iVar7;
  scan_chan_tag *psVar8;
  undefined *puVar9;
  mac_rateset *p_rateset;
  uint32_t uStack52;
  undefined2 uStack48;
  undefined uStack46;
  undefined uStack45;
  u8_l wme_ie [16];
  
  iVar7 = CONCAT31(in_register_0000202d,vif_idx);
  enc_type = vif_info_tab[iVar7].bss_info.sec_type;
  uVar2 = vif_info_tab[iVar7].bss_info.beacon_interval;
  *(undefined *)(frame + 8) = (char)uVar2;
  *(undefined *)(frame + 9) = (char)(uVar2 >> 8);
  uStack52 = frame;
  uVar2 = me_build_capability(vif_idx);
  if (enc_type != '\0') {
    uVar2 = uVar2 | 0x10;
  }
  *(undefined *)(uStack52 + 10) = (char)uVar2;
  *(undefined *)(uStack52 + 0xb) = (char)(uVar2 >> 8);
  uStack52 = uStack52 + 0xc;
  p_rateset = &vif_info_tab[iVar7].bss_info.rate_set;
  uVar3 = me_add_ie_ssid(&uStack52,vif_info_tab[iVar7].bss_info.ssid.length,
                         vif_info_tab[iVar7].bss_info.ssid.array);
  uVar4 = me_add_ie_supp_rates(&uStack52,p_rateset);
  sVar1 = (short)uVar3 + (short)uVar4 + 0xc;
  if (8 < vif_info_tab[iVar7].bss_info.rate_set.length) {
    uVar3 = me_add_ie_ext_supp_rates(&uStack52,p_rateset);
    sVar1 = sVar1 + (short)uVar3;
  }
  psVar8 = vif_info_tab[iVar7].bss_info.chan;
  iVar5 = phy_freq_to_channel(psVar8->band,psVar8->freq);
  uVar3 = me_add_ie_ds(&uStack52,(uint8_t)iVar5);
  uVar4 = me_add_ie_rsn(&uStack52,enc_type);
  uVar6 = me_add_ie_erp(&uStack52,'\0');
  sVar1 = sVar1 + (short)uVar4 + (short)uVar3 + (short)uVar6;
  if ((vif_info_tab[iVar7].bss_info.valid_flags & 2) != 0) {
    uVar3 = me_add_ie_ht_capa(&uStack52);
    uVar4 = me_add_ie_ht_oper(&uStack52,vif_info_tab + iVar7);
    sVar1 = sVar1 + (short)uVar4 + (short)uVar3;
  }
  uVar3 = me_add_ie_wpa(&uStack52,enc_type);
  uVar2 = sVar1 + (short)uVar3;
  if ((vif_info_tab[iVar7].bss_info.valid_flags & 1) != 0) {
    memset(&uStack46,0,0xe);
    uStack48 = 0x7dd;
    uStack45 = 0x50;
    wme_ie._0_2_ = 0x2f2;
    wme_ie[3] = '\x01';
    wme_ie[4] = vif_info_tab[iVar7].bss_info.edca_param.qos_info;
    co_pack8p(uStack52,(uint8_t *)&uStack48,9);
    *(char *)(uStack52 + 1) = *(char *)(uStack52 + 1) + '\x11';
    puVar9 = (undefined *)(uStack52 + 2 + (uint)uStack48._1_1_);
    *puVar9 = 0;
    uVar3 = vif_info_tab[iVar7].txq_params[1];
    puVar9[1] = (char)uVar3;
    puVar9[2] = (char)(uVar3 >> 8);
    puVar9[3] = (char)(uVar3 >> 0x10);
    puVar9[4] = (char)(uVar3 >> 0x18);
    uVar3 = vif_info_tab[iVar7].txq_params[0];
    puVar9[5] = (char)uVar3;
    puVar9[6] = (char)(uVar3 >> 8);
    puVar9[7] = (char)(uVar3 >> 0x10);
    puVar9[8] = (char)(uVar3 >> 0x18);
    uVar3 = vif_info_tab[iVar7].txq_params[2];
    puVar9[9] = (char)uVar3;
    puVar9[10] = (char)(uVar3 >> 8);
    puVar9[0xb] = (char)(uVar3 >> 0x10);
    puVar9[0xc] = (char)(uVar3 >> 0x18);
    uVar3 = vif_info_tab[iVar7].txq_params[3];
    puVar9[0xd] = (char)uVar3;
    puVar9[0xe] = (char)(uVar3 >> 8);
    puVar9[0xf] = (char)(uVar3 >> 0x10);
    puVar9[0x10] = (char)(uVar3 >> 0x18);
    uVar2 = uVar2 + (ushort)uStack48._1_1_ + 0x13;
  }
  return uVar2;
}



// WARNING: Could not reconcile some variable overlaps

uint16_t me_build_associate_rsp
                   (uint32_t frame,uint8_t vif_idx,uint16_t status_code,me_sta_add_req *req)

{
  uint8_t uVar1;
  ushort uVar2;
  uint16_t uVar3;
  uint32_t uVar4;
  uint32_t uVar5;
  undefined3 in_register_0000202d;
  int iVar6;
  undefined2 in_register_00002032;
  undefined *puStack52;
  undefined2 uStack48;
  undefined uStack46;
  undefined uStack45;
  u8_l wme_ie [16];
  
  iVar6 = CONCAT31(in_register_0000202d,vif_idx);
  uVar1 = vif_info_tab[iVar6].bss_info.sec_type;
  puStack52 = (undefined *)frame;
  uVar3 = me_build_capability(vif_idx);
  if (uVar1 != '\0') {
    uVar3 = uVar3 | 0x10;
  }
  *puStack52 = (char)uVar3;
  puStack52[1] = (char)(uVar3 >> 8);
  uVar3 = 6;
  puStack52[2] = (char)status_code;
  puStack52[3] = (char)(status_code >> 8);
  uVar2 = req->aid;
  puStack52[4] = (char)uVar2;
  puStack52[5] = (byte)((uint)uVar2 >> 8) | 0xc0;
  puStack52 = puStack52 + 6;
  if (CONCAT22(in_register_00002032,status_code) == 0) {
    uVar4 = me_add_ie_supp_rates((uint32_t *)&puStack52,&req->rate_set);
    uVar3 = (short)uVar4 + 6;
    if (8 < (req->rate_set).length) {
      uVar4 = me_add_ie_ext_supp_rates((uint32_t *)&puStack52,&req->rate_set);
      uVar3 = uVar3 + (short)uVar4;
    }
    if ((req->flags & 2) != 0) {
      uVar4 = me_add_ie_ht_capa((uint32_t *)&puStack52);
      uVar5 = me_add_ie_ht_oper((uint32_t *)&puStack52,vif_info_tab + iVar6);
      uVar3 = uVar3 + (short)uVar5 + (short)uVar4;
    }
    if ((req->flags & 1) != 0) {
      memset(&uStack46,0,0xe);
      uStack48 = 0x7dd;
      uStack45 = 0x50;
      wme_ie._0_2_ = 0x2f2;
      wme_ie[3] = '\x01';
      wme_ie[4] = vif_info_tab[iVar6].bss_info.edca_param.qos_info;
      co_pack8p((uint32_t)puStack52,(uint8_t *)&uStack48,9);
      puStack52[1] = puStack52[1] + '\x11';
      puStack52 = puStack52 + (uint)uStack48._1_1_ + 2;
      *puStack52 = 0;
      uVar4 = vif_info_tab[iVar6].txq_params[1];
      puStack52[1] = (char)uVar4;
      puStack52[2] = (char)(uVar4 >> 8);
      puStack52[3] = (char)(uVar4 >> 0x10);
      puStack52[4] = (char)(uVar4 >> 0x18);
      uVar4 = vif_info_tab[iVar6].txq_params[0];
      puStack52[5] = (char)uVar4;
      puStack52[6] = (char)(uVar4 >> 8);
      puStack52[7] = (char)(uVar4 >> 0x10);
      puStack52[8] = (char)(uVar4 >> 0x18);
      uVar4 = vif_info_tab[iVar6].txq_params[2];
      puStack52[9] = (char)uVar4;
      puStack52[10] = (char)(uVar4 >> 8);
      puStack52[0xb] = (char)(uVar4 >> 0x10);
      puStack52[0xc] = (char)(uVar4 >> 0x18);
      uVar4 = vif_info_tab[iVar6].txq_params[3];
      puStack52[0xd] = (char)uVar4;
      puStack52[0xe] = (char)(uVar4 >> 8);
      puStack52[0xf] = (char)(uVar4 >> 0x10);
      puStack52[0x10] = (char)(uVar4 >> 0x18);
      uVar3 = uVar3 + (ushort)uStack48._1_1_ + 0x13;
    }
  }
  return uVar3;
}



int me_rc_set_rate_req_handler
              (ke_msg_id_t msgid,me_rc_set_rate_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  byte bVar1;
  uint16_t fixed_rate_config;
  rc_sta_stats *rc_ss;
  _Bool _Var2;
  undefined3 extraout_var;
  
  bVar1 = param->sta_idx;
  rc_ss = sta_info_tab[bVar1].pol_tbl.sta_stats;
  if (rc_ss == (rc_sta_stats *)0x0) {
    assert_err("rc_ss != NULL","module",0x31d);
  }
  fixed_rate_config = param->fixed_rate_cfg;
  if (fixed_rate_config == 0xffff) {
    rc_ss->fixed_rate_cfg = 0xffff;
    rc_ss->info = rc_ss->info & 0x9f;
    rc_update_bw_nss_max(sta_info_tab[bVar1].staid,rc_ss->bw_max,rc_ss->no_ss);
  }
  else {
    _Var2 = rc_check_fixed_rate_config(rc_ss,fixed_rate_config);
    if (CONCAT31(extraout_var,_Var2) != 0) {
      rc_ss->fixed_rate_cfg = fixed_rate_config;
      rc_ss->info = rc_ss->info & 0x9f | 0x20;
    }
  }
  return 0;
}



int me_rc_stats_req_handler
              (ke_msg_id_t msgid,me_rc_stats_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  rc_sta_stats *rc_ss;
  byte *pbVar1;
  u32_l uVar2;
  uint uVar3;
  
  pbVar1 = (byte *)ke_msg_alloc(0x140f,src_id,dest_id,0xd0);
  rc_ss = sta_info_tab[param->sta_idx].pol_tbl.sta_stats;
  *pbVar1 = param->sta_idx;
  if (rc_ss == (rc_sta_stats *)0x0) {
    *(undefined2 *)(pbVar1 + 2) = 0;
  }
  else {
    *(uint16_t *)(pbVar1 + 2) = rc_ss->no_samples;
    uVar3 = 0;
    *(uint16_t *)(pbVar1 + 4) = rc_ss->ampdu_len;
    *(uint16_t *)(pbVar1 + 6) = rc_ss->ampdu_packets;
    *(uint32_t *)(pbVar1 + 8) = rc_ss->avg_ampdu_len;
    pbVar1[0xc] = rc_ss->sw_retry_step;
    pbVar1[0xd] = rc_ss->sample_wait;
    memcpy(pbVar1 + 0x10,rc_ss->retry,0x20);
    memcpy(pbVar1 + 0x30,rc_ss->rate_stats,0x78);
    while (uVar3 < rc_ss->no_samples) {
      uVar2 = rc_calc_tp(rc_ss,(u8_l)uVar3);
      *(u32_l *)(pbVar1 + (uVar3 + 0x28) * 4 + 8) = uVar2;
      uVar3 = uVar3 + 1 & 0xffff;
    }
  }
  ke_msg_send(pbVar1);
  return 0;
}



int me_traffic_ind_req_handler
              (ke_msg_id_t msgid,me_traffic_ind_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint uVar1;
  uint16_t *puVar2;
  sta_ps_traffic sVar3;
  sta_ps_traffic sVar4;
  
  uVar1 = (uint)param->sta_idx;
  sVar4 = sta_info_tab[uVar1].traffic_avail;
  if (param->uapsd == false) {
    if (param->tx_avail == '\0') {
      sVar4 = sVar4 & ~PS_TRAFFIC_HOST;
    }
    else {
      sVar4 = sVar4 | PS_TRAFFIC_HOST;
    }
    sta_info_tab[uVar1].traffic_avail = sVar4;
  }
  else {
    sVar3 = sVar4 & ~UAPSD_TRAFFIC_HOST;
    if (param->tx_avail != '\0') {
      sVar3 = sVar4 | UAPSD_TRAFFIC_HOST;
    }
    sta_info_tab[uVar1].traffic_avail = sVar3;
    if (sta_info_tab[uVar1].info.uapsd_queues != '\x0f') goto LAB_230611be;
  }
  puVar2 = (uint16_t *)ke_msg_alloc(0x41,0,5,4);
  *puVar2 = sta_info_tab[uVar1].aid;
  *(uint8_t *)((int)puVar2 + 3) = sta_info_tab[uVar1].inst_nbr;
  *(uint8_t *)(puVar2 + 1) = param->tx_avail;
  ke_msg_send();
LAB_230611be:
  ke_msg_send_basic(0x140d,src_id,dest_id);
  return 0;
}



int me_sta_del_req_handler
              (ke_msg_id_t msgid,me_sta_del_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint8_t *puVar1;
  undefined *puVar2;
  
  puVar1 = (uint8_t *)ke_msg_alloc(0xc,0,5,1);
  *puVar1 = param->sta_idx;
  ke_msg_send();
  if (param->tdls_sta != false) {
    puVar2 = (undefined *)ke_msg_alloc(0x1413,5,6,2);
    *puVar2 = 0;
    puVar2[1] = sta_info_tab[param->sta_idx].inst_nbr;
    ke_msg_send();
  }
  ke_msg_send_basic(0x140a,src_id,dest_id);
  return 0;
}



int me_set_control_port_req_handler
              (ke_msg_id_t msgid,me_set_control_port_req *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  byte bVar1;
  undefined *puVar2;
  uint8_t uVar3;
  uint uVar4;
  
  uVar4 = (uint)param->sta_idx;
  bVar1 = sta_info_tab[uVar4].inst_nbr;
  uVar3 = (param->control_port_open != false) + '\x01';
  sta_info_tab[uVar4].ctrl_port_state = uVar3;
  if ((vif_info_tab[bVar1].type == '\0') && (uVar3 == '\x02')) {
    puVar2 = (undefined *)ke_msg_alloc(0x1413,5,6,2);
    *puVar2 = 0;
    puVar2[1] = sta_info_tab[uVar4].inst_nbr;
    ke_msg_send();
  }
  ke_msg_send_basic(0x1405,src_id,dest_id);
  return 0;
}



int me_chan_config_req_handler
              (ke_msg_id_t msgid,me_chan_config_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  memcpy(&me_env.chan,param,0xfe);
  ke_msg_send_basic(0x1403,src_id,dest_id);
  return 0;
}



int mm_set_ps_mode_cfm_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined3 extraout_var;
  
  kVar1 = ke_state_get(dest_id);
  if (CONCAT31(extraout_var,kVar1) != 1) {
    assert_err("ke_state_get(dest_id) == ME_BUSY","module",699);
  }
  if (me_env.requester_id != 0xff) {
    ke_msg_send_basic(0x1414,me_env.requester_id,dest_id);
  }
  ke_state_set(dest_id,0);
  return 0;
}



int mm_set_idle_cfm_handler(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined3 extraout_var;
  
  kVar1 = ke_state_get(dest_id);
  if (CONCAT31(extraout_var,kVar1) != 1) {
    assert_err("ke_state_get(dest_id) == ME_BUSY","module",0x252);
  }
  if (me_env.requester_id != 0xff) {
    ke_msg_send_basic(0x1412,me_env.requester_id,dest_id);
  }
  ke_state_set(dest_id,0);
  return 0;
}



int me_config_req_handler
              (ke_msg_id_t msgid,me_config_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint8_t uVar1;
  undefined *puVar2;
  undefined3 extraout_var;
  
  puVar2 = (undefined *)ke_msg_alloc(0x31,0,5,1);
  me_env.ht_supported = (_Bool)param->ht_supp;
  memcpy(&me_env.ht_cap,param,0x20);
  ke_msg_send_basic(0x1401,src_id,dest_id);
  if (me_env.ht_supported == false) {
    me_env._302_2_ = 0;
  }
  else {
    uVar1 = phy_get_nss();
    me_env._302_2_ =
         CONCAT11((char)(me_env.ht_cap.ht_capa_info >> 1),
                  (char)(CONCAT31(extraout_var,uVar1) + 1 >> 1)) & 0x1ff;
  }
  me_env.tx_lft = param->tx_lft;
  me_env.ps_on = (_Bool)param->ps_on;
  if (me_env.ps_on != false) {
    me_env.requester_id = 0xff;
    *puVar2 = 2;
    ke_msg_send(puVar2);
    ke_state_set(5,1);
  }
  return 0;
}



int me_set_ps_disable_req_handler
              (ke_msg_id_t msgid,me_set_ps_disable_req *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined3 extraout_var;
  char *pcVar2;
  
  if (me_env.ps_on != false) {
    kVar1 = ke_state_get(5);
    if (CONCAT31(extraout_var,kVar1) == 1) {
      return 2;
    }
    if (me_env.ps_disable_vifs == 0) {
      if (param->ps_disable != false) goto LAB_23061504;
    }
    else {
      if (param->ps_disable == false) {
LAB_23061504:
        pcVar2 = (char *)ke_msg_alloc(0x31,0,dest_id,1);
        if (param->ps_disable == false) {
          me_env.ps_disable_vifs = ~(1 << ((uint)param->vif_idx & 0x1f)) & me_env.ps_disable_vifs;
        }
        else {
          me_env.ps_disable_vifs = 1 << ((uint)param->vif_idx & 0x1f) | me_env.ps_disable_vifs;
        }
        me_env.requester_id = src_id;
        *pcVar2 = (me_env.ps_disable_vifs == 0) << 1;
        ke_msg_send();
        ke_state_set(dest_id,1);
        return 0;
      }
      me_env.ps_disable_vifs = 1 << ((uint)param->vif_idx & 0x1f) | me_env.ps_disable_vifs;
    }
  }
  ke_msg_send_basic(0x1414,src_id,dest_id);
  return 0;
}



int me_set_active_req_handler
              (ke_msg_id_t msgid,me_set_active_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined3 extraout_var;
  void *pvVar2;
  
  kVar1 = ke_state_get(5);
  if (CONCAT31(extraout_var,kVar1) == 1) {
    return 2;
  }
  if (me_env.active_vifs == 0) {
    if (param->active != false) goto LAB_2306159e;
  }
  else {
    if (param->active == false) {
LAB_2306159e:
      pvVar2 = ke_msg_alloc(0x22,0,dest_id,1);
      if (param->active == false) {
        me_env.active_vifs = ~(1 << ((uint)param->vif_idx & 0x1f)) & me_env.active_vifs;
      }
      else {
        me_env.active_vifs = 1 << ((uint)param->vif_idx & 0x1f) | me_env.active_vifs;
      }
      me_env.requester_id = src_id;
      *(bool *)pvVar2 = me_env.active_vifs == 0;
      ke_msg_send();
      ke_state_set(dest_id,1);
      return 0;
    }
    me_env.active_vifs = 1 << ((uint)param->vif_idx & 0x1f) | me_env.active_vifs;
  }
  ke_msg_send_basic(0x1412,src_id,dest_id);
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

int me_sta_add_req_handler
              (ke_msg_id_t msgid,me_sta_add_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  byte bVar1;
  byte bVar2;
  _Bool _Var3;
  byte *sta_idx;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined *puVar4;
  undefined3 extraout_var_01;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  int iVar8;
  uint8_t uStack81;
  uint8_t hw_sta_idx;
  uint32_t uStack80;
  mm_sta_add_req sta_add_req;
  
  sta_idx = (byte *)ke_msg_alloc(0x1408,src_id,dest_id,3);
  bVar1 = rxu_cntrl_get_pm();
  sta_add_req.mac_addr.array[1]._1_1_ = param->vif_idx;
  uVar7 = (uint)sta_add_req.mac_addr.array[1]._1_1_;
  if ((param->flags & 2) == 0) {
    sta_add_req.mac_addr.array[1]._0_1_ = '\0';
    sta_add_req.paid_gid._0_2_ = 0;
  }
  else {
    uVar5 = (uint)(param->ht_cap).a_mpdu_param;
    sta_add_req.mac_addr.array[1]._0_1_ = '\x01';
    uVar6 = (int)uVar5 >> 2 & 7;
    if (2 < uVar6) {
      sta_add_req.mac_addr.array[1]._0_1_ = (uint8_t)(1 << (uVar6 - 3 & 0x1f));
    }
    sta_add_req.paid_gid._0_2_ = (short)(1 << (uVar5 & 3) + 0xd) - 1;
  }
  sta_add_req.ampdu_size_max_vht = 0;
  memcpy((void *)((int)&sta_add_req.paid_gid + 2),param,6);
  sta_add_req.mac_addr.array[2]._1_1_ = param->rssi;
  sta_add_req._16_4_ = param->tsflo;
  sta_add_req.tsflo = param->tsfhi;
  uStack80 = 0;
  sta_add_req.tsfhi._0_1_ = param->data_rate;
  bVar2 = mm_sta_add((mm_sta_add_req *)&stack0xffffffb0,sta_idx,&uStack81);
  sta_idx[1] = bVar2;
  if (CONCAT31(extraout_var_00,bVar2) != 0) goto LAB_23061802;
  uVar5 = (uint)*sta_idx;
  memcpy(&sta_info_tab[uVar5].info,&param->rate_set,0xd);
  if ((param->flags & 1) == 0) {
LAB_23061706:
    iVar8 = 0;
  }
  else {
    uVar6 = sta_info_tab[uVar5].info.capa_flags;
    sta_info_tab[uVar5].info.capa_flags = uVar6 | 1;
    if (((param->flags & 2) == 0) || (me_env.ht_supported == false)) goto LAB_23061706;
    sta_info_tab[uVar5].info.capa_flags = uVar6 | 3;
    memcpy(&sta_info_tab[uVar5].info.ht_cap,&param->ht_cap,0x20);
    _Var3 = me_set_sta_ht_vht_param(sta_info_tab + uVar5,&vif_info_tab[uVar7].bss_info);
    iVar8 = CONCAT31(extraout_var_01,_Var3);
  }
  sta_info_tab[uVar5].info.uapsd_queues = param->uapsd_queues;
  sta_info_tab[uVar5].info.max_sp_len = param->max_sp_len;
  sta_info_tab[uVar5].aid = param->aid;
  me_init_rate(sta_info_tab + uVar5);
  if (((param->flags & 0x10) != 0) && (bVar2 = param->opmode, -1 < (char)bVar2)) {
    me_sta_bw_nss_max_upd(sta_info_tab[uVar5].staid,bVar2 & 3,bVar2 >> 4);
  }
  if (iVar8 != 0) {
    me_sta_bw_nss_max_upd(sta_info_tab[uVar5].staid,-1,'\0');
  }
  sta_info_tab[uVar5].pol_tbl.upd_field = sta_info_tab[uVar5].pol_tbl.upd_field | 0x10;
  sta_info_tab[uVar5].ctrl_port_state = ((vif_info_tab[uVar7].flags & 1) == 0) + '\x01';
  sta_info_tab[uVar5].ctrl_port_ethertype =
       *(ushort *)(vif_info_tab[uVar7].u + 0x2f0) >> 8 |
       *(ushort *)(vif_info_tab[uVar7].u + 0x2f0) << 8;
  sta_idx[2] = bVar1;
  if (CONCAT31(extraout_var,bVar1) != 0) {
    sta_info_tab[uVar5].ps_state = bVar1;
    if (vif_info_tab[uVar7].u[0x2ee] == 0) {
      uVar5 = (uint)vif_info_tab[uVar7].index + 10 & 0xff;
      puVar4 = (undefined *)ke_msg_alloc(0x49,0xd,0,2);
      sta_info_tab[uVar5].ps_state = '\x01';
      *puVar4 = (char)uVar5;
      puVar4[1] = 1;
      ke_msg_send();
    }
    vif_info_tab[uVar7].u[0x2ee] = vif_info_tab[uVar7].u[0x2ee] + 1;
  }
LAB_23061802:
  ke_msg_send(sta_idx);
  return 0;
}



_Bool me_set_sta_ht_vht_param(sta_info_tag *sta,mac_bss_info *bss)

{
  ushort uVar1;
  uint uVar2;
  uint uVar3;
  uint8_t uVar4;
  uint uVar5;
  
  uVar1 = (sta->info).ht_cap.ht_capa_info;
  uVar3 = (uint)(uVar1 >> 1) & 1;
  uVar2 = (int)(uint)uVar1 >> 8 & 3;
  if ((uint)me_env.phy_bw_max < uVar3) {
    uVar3 = (uint)me_env.phy_bw_max;
  }
  (sta->info).phy_bw_max = (uint8_t)uVar3;
  uVar5 = (uint)bss->phy_bw;
  if (bss->phy_bw == 4) {
    uVar5 = 2;
  }
  uVar4 = (uint8_t)uVar5;
  if (uVar3 < uVar5) {
    uVar4 = (uint8_t)uVar3;
  }
  (sta->info).bw_cur = uVar4;
  uVar4 = me_env.stbc_nss;
  if (uVar2 < me_env.stbc_nss) {
    uVar4 = (uint8_t)uVar2;
  }
  (sta->info).stbc_nss = uVar4;
  return (_Bool)(((uint)uVar1 & 0xc) != 0xc);
}



uint8_t me_11n_nss_max(uint8_t *mcs_set)

{
  uint8_t uVar1;
  
  if (mcs_set[3] == '\0') {
    uVar1 = '\x02';
    if ((mcs_set[2] == '\0') && (uVar1 = mcs_set[1], uVar1 != '\0')) {
      uVar1 = '\x01';
    }
  }
  else {
    uVar1 = '\x03';
  }
  return uVar1;
}



uint8_t me_legacy_ridx_min(uint16_t rate_map)

{
  undefined2 in_register_0000202a;
  uint uVar1;
  
  uVar1 = 0;
  do {
    if ((CONCAT22(in_register_0000202a,rate_map) >> (uVar1 & 0x1f) & 1U) != 0) {
      return (uint8_t)uVar1;
    }
    uVar1 = uVar1 + 1;
  } while (uVar1 != 0xc);
  return '\f';
}



uint8_t me_legacy_ridx_max(uint16_t rate_map)

{
  undefined2 in_register_0000202a;
  char cVar1;
  uint uVar2;
  
  if (CONCAT22(in_register_0000202a,rate_map) == 0) {
    return '\f';
  }
  uVar2 = 0xb;
  do {
    cVar1 = '\v' - (char)uVar2;
    if ((CONCAT22(in_register_0000202a,rate_map) >> (uVar2 & 0x1f) & 1U) != 0) goto LAB_23061928;
    uVar2 = uVar2 - 1;
  } while (uVar2 != 0xffffffff);
  cVar1 = '\f';
LAB_23061928:
  return '\v' - cVar1;
}



uint8_t me_rate_translate(uint8_t rate)

{
  uint8_t uVar1;
  byte bVar2;
  byte bVar3;
  
  bVar3 = rate & 0x7f;
  if (bVar3 == 0x16) {
    uVar1 = '\x03';
  }
  else {
    if (bVar3 < 0x17) {
      if (bVar3 == 0xb) {
        return '\x02';
      }
      if (bVar3 < 0xc) {
        if (bVar3 == 2) {
          return '\0';
        }
        bVar2 = 4;
        uVar1 = '\x01';
      }
      else {
        if (bVar3 == 0xc) {
          return '\x04';
        }
        bVar2 = 0x12;
        uVar1 = '\x05';
      }
    }
    else {
      if (bVar3 == 0x30) {
        return '\b';
      }
      if (bVar3 < 0x31) {
        if (bVar3 == 0x18) {
          return '\x06';
        }
        bVar2 = 0x24;
        uVar1 = '\a';
      }
      else {
        if (bVar3 == 0x60) {
          return '\n';
        }
        if (bVar3 == 0x6c) {
          return '\v';
        }
        bVar2 = 0x48;
        uVar1 = '\t';
      }
    }
    if (bVar3 != bVar2) {
      return -1;
    }
  }
  return uVar1;
}



void me_get_basic_rates(mac_rateset *rateset,mac_rateset *basic_ratest)

{
  byte bVar1;
  int iVar2;
  
  basic_ratest->length = '\0';
  iVar2 = 0;
  while (iVar2 < (int)(uint)rateset->length) {
    if ((char)rateset->array[iVar2] < '\0') {
      bVar1 = basic_ratest->length;
      basic_ratest->array[bVar1] = rateset->array[iVar2];
      basic_ratest->length = bVar1 + 1;
    }
    iVar2 = iVar2 + 1;
  }
  return;
}



uint16_t me_legacy_rate_bitfield_build(mac_rateset *rateset,_Bool basic_only)

{
  uint uVar1;
  int iVar2;
  byte bVar3;
  undefined3 extraout_var;
  undefined3 in_register_0000202d;
  
  uVar1 = 0;
  iVar2 = 0;
  while (iVar2 < (int)(uint)rateset->length) {
    if ((CONCAT31(in_register_0000202d,basic_only) == 0) || ((char)rateset->array[iVar2] < '\0')) {
      bVar3 = me_rate_translate(rateset->array[iVar2]);
      if (CONCAT31(extraout_var,bVar3) < 0xc) {
        uVar1 = uVar1 | 1 << ((uint)bVar3 & 0x1f) & 0xffffU;
      }
      else {
        assert_warn("bit_pos < MAC_RATESET_LEN","module",0x1c6);
      }
    }
    iVar2 = iVar2 + 1;
  }
  return (uint16_t)uVar1;
}



uint16_t me_build_capability(uint8_t vif_idx)

{
  ushort uVar1;
  undefined3 in_register_00002029;
  int iVar2;
  ushort uVar3;
  
  iVar2 = CONCAT31(in_register_00002029,vif_idx);
  uVar3 = 0x11;
  if (((vif_info_tab[iVar2].type != '\0') && (uVar3 = 1, vif_info_tab[iVar2].type == '\x02')) &&
     ((*(uint *)&vif_info_tab[iVar2].bss_info.is_supplicant_enabled & 0x12a00) != 0)) {
    uVar3 = 0x11;
  }
  uVar1 = uVar3 | 0x520;
  if ((vif_info_tab[iVar2].bss_info.chan)->band != '\x01') {
    uVar1 = uVar3 | 0x420;
  }
  return (uint16_t)uVar1;
}



void me_init_bcmc_rate(sta_info_tag *sta_entry)

{
  byte bVar1;
  byte rate;
  uint8_t basic_rate_idx;
  int iVar2;
  
  if ((sta_entry->info).rate_set.length == '\0') {
    assert_err("rates->length != 0","module",0x229);
  }
  iVar2 = 0;
  rate = 0;
  while (iVar2 < (int)(uint)(sta_entry->info).rate_set.length) {
    bVar1 = (sta_entry->info).rate_set.array[iVar2];
    if (rate < (bVar1 & 0x7f)) {
      rate = bVar1 & 0x7f;
    }
    iVar2 = iVar2 + 1;
  }
  basic_rate_idx = me_rate_translate(rate);
  rc_init_bcmc_rate(sta_entry,basic_rate_idx);
  (sta_entry->pol_tbl).upd_field = '\0';
  return;
}



void me_tx_cfm_singleton(txdesc *txdesc)

{
  u8_l sta_idx;
  uint uVar1;
  uint uVar2;
  
  uVar1 = ((txdesc->lmac).hw_desc)->cfm_ptr->status;
  uVar2 = uVar1 & 0x10000;
  uVar1 = uVar1 >> 8 & 0xff;
  if (uVar2 == 0) {
    sta_idx = (txdesc->host).staid;
  }
  else {
    rf_dump_status();
    sta_idx = (txdesc->host).staid;
  }
  rc_update_counters(sta_idx,uVar1 + 1,uVar1 + (uVar2 != 0),false,false);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void me_check_rc(u8_l sta_idx,_Bool *tx_ampdu)

{
  ushort uVar1;
  ushort uVar2;
  ushort rate_config;
  ushort rate_config_00;
  uint16_t uVar3;
  bool bVar4;
  rc_sta_stats *rc_ss;
  uint uVar5;
  _Bool _Var6;
  u8_l uVar7;
  u8_l uVar8;
  undefined3 in_register_00002029;
  uint uVar9;
  undefined3 extraout_var;
  uint uVar10;
  uint32_t uVar11;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  uint32_t uVar12;
  uint8_t uVar13;
  byte bVar14;
  uint32_t *puVar15;
  uint uVar16;
  int iVar17;
  uint uVar18;
  uint uVar19;
  
  uVar9 = CONCAT31(in_register_00002029,sta_idx);
  if (9 < uVar9) {
    return;
  }
  rc_ss = sta_info_tab[uVar9].pol_tbl.sta_stats;
  if (rc_ss == (rc_sta_stats *)0x0) {
    assert_err("rc_ss != NULL","module",0x826);
  }
  iVar17 = 0;
  if ((int)((100000 - _DAT_44b00120) + rc_ss->last_rc_time) < 0) {
    _Var6 = rc_update_stats(rc_ss,false);
    iVar17 = CONCAT31(extraout_var,_Var6);
    rc_ss->trial_status = '\0';
    rc_ss->sw_retry_step = '\0';
    rc_ss->info = rc_ss->info & 0xef;
    rc_ss->last_rc_time = _DAT_44b00120;
  }
  if (rc_ss->trial_status == '\x01') {
    if ((rc_ss->info & 0x40) == 0) {
      bVar14 = rc_ss->format_mod;
      uVar1 = rc_ss->retry[0].idx;
      uVar16 = (uint)uVar1;
      if (bVar14 < 2) {
        if ((ushort)(rc_ss->rate_stats[uVar16].probability + 0xe667) < 0xd99b) {
          uVar13 = '\n';
        }
        else {
          uVar13 = '\x05';
        }
      }
      else {
        uVar13 = ((char)*(undefined2 *)((int)&rc_ss->avg_ampdu_len + 2) + '\b') * '\x02';
      }
      rc_ss->sample_wait = uVar13;
      next = next * 0x41c64e6d + 0x3039;
      uVar5 = (next >> 0x10) % (uint)rc_ss->no_samples;
      if (uVar5 != uVar16) {
        uVar2 = rc_ss->retry[1].idx;
        if (((uVar5 != (uint)uVar2) && (uVar19 = (uint)rc_ss->retry[2].idx, uVar5 != uVar19)) &&
           (puVar15 = &rc_ss->last_rc_time + uVar5 * 3, *(ushort *)(puVar15 + 2) < 0xf334)) {
          rate_config = *(ushort *)((int)puVar15 + 10);
          uVar10 = rc_get_duration((uint)rate_config);
          rate_config_00 = rc_ss->rate_stats[uVar16].rate_config;
          if (bVar14 < 2) {
            uVar16 = rc_get_duration((uint)rate_config_00);
            if (uVar16 < uVar10) {
              uVar11 = 0;
              bVar4 = 0x13 < *(byte *)(puVar15 + 3);
            }
            else {
              uVar11 = 0;
              bVar4 = true;
            }
          }
          else {
            uVar18 = 0x20;
            uVar16 = rc_get_duration((uint)rc_ss->rate_stats[(uint)uVar2].rate_config);
            if (*(char *)((int)puVar15 + 0xd) == '\0') {
              uVar18 = (uint)*(ushort *)((int)&rc_ss->avg_ampdu_len + 2);
            }
            if (uVar16 <= uVar10) {
              uVar7 = rc_get_nss(rate_config_00);
              uVar8 = rc_get_nss(rate_config);
              if ((CONCAT31(extraout_var_00,uVar7) - 1U < CONCAT31(extraout_var_01,uVar8)) ||
                 (uVar16 = rc_get_duration((uint)rc_ss->rate_stats[uVar19].rate_config),
                 uVar16 <= uVar10)) {
                if (uVar18 <= *(byte *)(puVar15 + 3)) {
                  bVar14 = rc_ss->sample_slow + 1;
                  rc_ss->sample_slow = bVar14;
                  if (bVar14 < 3) goto LAB_23063714;
                  if (0xf < bVar14) {
                    rc_ss->sample_slow = '\x0f';
                  }
                }
                goto LAB_230636ee;
              }
            }
LAB_23063714:
            uVar11 = rc_calc_tp(rc_ss,(u8_l)uVar5);
            bVar4 = true;
            if ((*(byte *)((int)puVar15 + 0xe) & 0xf) < 10) {
              bVar4 = uVar18 <= *(byte *)(puVar15 + 3);
            }
          }
          uVar12 = rc_ss->retry[1].tp;
          (rc_ss->max_tp_2_trial).idx = uVar2;
          (rc_ss->max_tp_2_trial).tp = uVar12;
          if (bVar4) {
            uVar12 = rc_ss->retry[0].tp;
            rc_ss->info = rc_ss->info & 0xfd;
            rc_ss->retry[1].tp = uVar12;
            rc_ss->retry[1].idx = uVar1;
            rc_ss->retry[0].tp = uVar11;
            rc_ss->retry[0].idx = (uint16_t)uVar5;
          }
          else {
            rc_ss->info = rc_ss->info | 2;
            rc_ss->retry[1].tp = uVar11;
            rc_ss->retry[1].idx = (uint16_t)uVar5;
          }
          rc_ss->trial_status = '\x02';
          goto LAB_23063654;
        }
      }
    }
LAB_230636ee:
    rc_ss->trial_status = '\0';
  }
  else {
    if (rc_ss->trial_status == '\x03') {
      if ((rc_ss->info & 2) == 0) {
        rc_ss->retry[0].idx = rc_ss->retry[1].idx;
        rc_ss->retry[0].tp = rc_ss->retry[1].tp;
      }
      uVar3 = (rc_ss->max_tp_2_trial).idx;
      rc_ss->trial_status = '\0';
      rc_ss->retry[1].idx = uVar3;
      uVar11 = (rc_ss->max_tp_2_trial).tp;
      (rc_ss->max_tp_2_trial).tp = 0;
      rc_ss->retry[1].tp = uVar11;
      (rc_ss->max_tp_2_trial).idx = 0xff;
      goto LAB_23063654;
    }
  }
  if (iVar17 == 0) {
    return;
  }
LAB_23063654:
  sta_info_tab[uVar9].pol_tbl.upd_field = sta_info_tab[uVar9].pol_tbl.upd_field | 1;
  return;
}


/*
Unable to decompile 'me_update_buffer_control'
Cause: Exception while decompiling 23061b7a: Decompiler process died

*/


void me_init_rate(sta_info_tag *sta_entry)

{
  rc_init(sta_entry);
  me_update_buffer_control(sta_entry);
  return;
}



void me_bw_check(int param_1,int param_2)

{
  short sVar1;
  short sVar2;
  byte bVar3;
  
  sVar2 = **(short **)(param_2 + 0x4c);
  bVar3 = 0;
  if ((param_1 != 0) && (bVar3 = me_env.phy_bw_max, me_env.phy_bw_max != '\0')) {
    bVar3 = *(byte *)(param_1 + 3) & 3;
    if ((*(byte *)(param_1 + 3) & 3) != 0) {
      sVar1 = 10;
      if (bVar3 != 1) {
        sVar1 = -10;
      }
      sVar2 = sVar2 + sVar1;
      bVar3 = 1;
    }
  }
  *(byte *)(param_2 + 0x82) = bVar3;
  *(byte *)(param_2 + 0x83) = bVar3;
  *(short *)(param_2 + 0x50) = sVar2;
  *(undefined2 *)(param_2 + 0x52) = 0;
  return;
}



void me_beacon_check(uint8_t vif_idx,uint16_t length,uint32_t bcn_addr)

{
  byte bVar1;
  uint8_t uVar2;
  uint8_t uVar3;
  undefined3 in_register_00002029;
  int iVar4;
  int iVar5;
  undefined4 uVar6;
  uint8_t *puVar7;
  undefined2 in_register_0000202e;
  uint uVar8;
  uint16_t uVar9;
  scan_chan_tag *psVar10;
  uint uVar11;
  byte bVar12;
  char cStack51;
  int8_t iStack50;
  uint8_t auStack49 [2];
  uint8_t csa_mode;
  int8_t pwr;
  uint8_t idx;
  
  iVar4 = CONCAT31(in_register_00002029,vif_idx);
  psVar10 = vif_info_tab[iVar4].bss_info.chan;
  vif_info_tab[iVar4].bss_info.prot_status = 0;
  uVar8 = CONCAT22(in_register_0000202e,length) - 0x24;
  bVar1 = vif_info_tab[iVar4].bss_info.phy_bw;
  uVar2 = vif_info_tab[iVar4].bss_info.power_constraint;
  bcn_addr = bcn_addr + 0x24;
  uVar11 = uVar8 & 0xffff;
  if ((psVar10->band == '\0') && (iVar5 = mac_ie_find(bcn_addr,uVar11,0x2a), iVar5 != 0)) {
    bVar12 = *(byte *)(iVar5 + 2);
    uVar9 = vif_info_tab[iVar4].bss_info.prot_status & 0xfff8;
    if ((bVar12 & 1) != 0) {
      uVar9 = uVar9 | 1;
    }
    vif_info_tab[iVar4].bss_info.prot_status = uVar9;
    if ((bVar12 & 2) != 0) {
      vif_info_tab[iVar4].bss_info.prot_status = vif_info_tab[iVar4].bss_info.prot_status | 2;
    }
    if ((bVar12 & 4) != 0) {
      vif_info_tab[iVar4].bss_info.prot_status = vif_info_tab[iVar4].bss_info.prot_status | 4;
    }
  }
  uVar6 = 0;
  if (me_env.ht_supported != false) {
    uVar6 = mac_ie_find(bcn_addr,uVar11,0x3d);
  }
  me_bw_check(uVar6,0,&vif_info_tab[iVar4].bss_info);
  uVar11 = me_extract_csa(bcn_addr,uVar11,&cStack51,iVar4 * 0x5d8 + 0x4201c2c0);
  if ((uVar11 & 0xff) != 0) {
    bVar12 = (byte)(uVar11 & 0xff);
    if (vif_info_tab[iVar4].type == '\0') {
      if ((vif_info_tab[iVar4].u[0x1d] == 0) && (cStack51 == '\x01')) {
        mm_send_csa_traffic_ind(vif_info_tab[iVar4].index,false);
      }
      vif_info_tab[iVar4].u[0x1d] = bVar12;
    }
    else {
      if (vif_info_tab[iVar4].type == '\x02') {
        vif_info_tab[iVar4].u[0x2eb] = bVar12;
      }
    }
  }
  me_extract_power_constraint
            (bcn_addr,(uint16_t)(uVar8 * 0x10000 >> 0x10),&vif_info_tab[iVar4].bss_info);
  uVar3 = vif_info_tab[iVar4].bss_info.power_constraint;
  if (uVar3 != uVar2) {
    iStack50 = (vif_info_tab[iVar4].bss_info.chan)->tx_power - uVar3;
    tpc_update_vif_tx_power(vif_info_tab + iVar4,&iStack50,auStack49);
  }
  if (bVar1 < vif_info_tab[iVar4].bss_info.phy_bw) {
    puVar7 = (uint8_t *)ke_msg_alloc(0x3b,0,5,0xc);
    if (vif_info_tab[iVar4].chan_ctxt == (chan_ctxt_tag *)0x0) {
      assert_err("vif->chan_ctxt != NULL","module",0x39);
    }
    *puVar7 = (vif_info_tab[iVar4].chan_ctxt)->idx;
    puVar7[1] = (vif_info_tab[iVar4].bss_info.chan)->band;
    puVar7[2] = vif_info_tab[iVar4].bss_info.phy_bw;
    *(u16_l *)(puVar7 + 4) = (vif_info_tab[iVar4].bss_info.chan)->freq;
    *(uint16_t *)(puVar7 + 6) = vif_info_tab[iVar4].bss_info.center_freq1;
    *(uint16_t *)(puVar7 + 8) = vif_info_tab[iVar4].bss_info.center_freq2;
    puVar7[10] = ((vif_info_tab[iVar4].chan_ctxt)->channel).tx_power;
    ke_msg_send(puVar7);
  }
  return;
}



void me_sta_bw_nss_max_upd(uint8_t sta_idx,uint8_t bw,uint8_t nss)

{
  byte bVar1;
  byte bVar2;
  u8_l sta_idx_00;
  uint8_t uVar3;
  uint8_t uVar4;
  u8_l nss_max;
  undefined3 in_register_00002029;
  int iVar5;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  u8_l bw_max;
  undefined3 in_register_0000202d;
  uint uVar6;
  undefined3 in_register_00002031;
  uint uVar7;
  
  iVar5 = CONCAT31(in_register_00002029,sta_idx);
  bVar1 = sta_info_tab[iVar5].inst_nbr;
  if (me_env.ht_supported == false) {
    assert_err("me_env.ht_supported","module",0x429);
  }
  uVar3 = me_11n_nss_max(sta_info_tab[iVar5].info.ht_cap.mcs_rate);
  uVar4 = me_11n_nss_max(me_env.ht_cap.mcs_rate);
  uVar7 = CONCAT31(extraout_var_00,uVar4);
  if (CONCAT31(extraout_var,uVar3) < CONCAT31(extraout_var_00,uVar4)) {
    uVar7 = CONCAT31(extraout_var,uVar3);
  }
  nss_max = (u8_l)uVar7;
  if (CONCAT31(in_register_00002031,nss) < uVar7) {
    nss_max = nss;
  }
  bVar2 = sta_info_tab[iVar5].info.phy_bw_max;
  uVar7 = (uint)bVar2;
  if (bVar2 == 4) {
    uVar7 = 3;
  }
  uVar6 = (uint)vif_info_tab[bVar1].bss_info.bw;
  if (CONCAT31(in_register_0000202d,bw) < uVar6) {
    uVar6 = CONCAT31(in_register_0000202d,bw);
  }
  bw_max = (u8_l)uVar6;
  if (uVar7 < uVar6) {
    bw_max = (u8_l)uVar7;
  }
  sta_idx_00 = sta_info_tab[iVar5].staid;
  sta_info_tab[iVar5].info.bw_cur = bw_max;
  rc_update_bw_nss_max(sta_idx_00,bw_max,nss_max);
  sta_info_tab[iVar5].pol_tbl.upd_field = sta_info_tab[iVar5].pol_tbl.upd_field | 8;
  return;
}



// WARNING: Could not reconcile some variable overlaps

uint8_t me_add_chan_ctx(uint8_t *p_chan_idx,scan_chan_tag *p_chan,uint32_t center_freq1,
                       uint32_t center_freq2,uint8_t ch_width)

{
  uint8_t uVar1;
  u8_l uStack28;
  uint8_t uStack27;
  u16_l uStack26;
  mm_chan_ctxt_add_req req;
  
  uStack28 = p_chan->band;
  req._0_2_ = (uint16_t)center_freq1;
  uStack26 = p_chan->freq;
  req.prim20_freq = (uint16_t)center_freq2;
  req.center1_freq._0_1_ = p_chan->tx_power;
  uStack27 = ch_width;
  uVar1 = chan_ctxt_add((mm_chan_ctxt_add_req *)&uStack28,p_chan_idx);
  return uVar1;
}



u8_l rc_get_nss(uint16_t rate_config)

{
  undefined2 in_register_0000202a;
  
  if ((CONCAT22(in_register_0000202a,rate_config) >> 0xb & 7U) - 2 < 2) {
    return (u8_l)((byte)(CONCAT22(in_register_0000202a,rate_config) >> 3) & 3);
  }
  return '\0';
}



u8_l rc_get_mcs_index(uint16_t rate_config)

{
  undefined2 in_register_0000202a;
  byte bVar1;
  uint uVar2;
  
  uVar2 = CONCAT22(in_register_0000202a,rate_config) >> 0xb & 7;
  if (uVar2 < 2) {
    bVar1 = (byte)rate_config & 0x7f;
  }
  else {
    bVar1 = 0;
    if (uVar2 < 4) {
      bVar1 = (byte)rate_config & 7;
    }
  }
  return (u8_l)bVar1;
}



uint16_t rc_set_previous_mcs_index(rc_sta_stats *rc_ss,uint16_t rate_config)

{
  uint uVar1;
  u8_l uVar2;
  undefined3 extraout_var;
  undefined2 in_register_0000202e;
  
  uVar2 = rc_get_mcs_index(rate_config);
  _uVar2 = CONCAT31(extraout_var,uVar2);
  uVar1 = CONCAT22(in_register_0000202e,rate_config) >> 0xb & 7;
  if (uVar1 < 2) {
    if (rc_ss->r_idx_min < _uVar2) {
      rate_config = rate_config & 0xff80 | (short)_uVar2 - 1U;
    }
  }
  else {
    if ((uVar1 < 4) && (_uVar2 != 0)) {
      rate_config = rate_config & 0xfff8 | (short)_uVar2 - 1U;
      if (rc_ss->short_gi != '\0') {
        rate_config = rate_config | 0x200;
      }
    }
  }
  return rate_config;
}



uint16_t rc_set_next_mcs_index(rc_sta_stats *rc_ss,uint16_t rate_config)

{
  u8_l uVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined2 in_register_0000202e;
  uint uVar2;
  
  uVar1 = rc_get_mcs_index(rate_config);
  _uVar1 = CONCAT31(extraout_var,uVar1);
  uVar2 = CONCAT22(in_register_0000202e,rate_config) >> 0xb & 7;
  if (uVar2 < 2) {
    if ((_uVar1 < rc_ss->r_idx_max) && ((rc_ss->rate_map_l >> (_uVar1 + 1 & 0x1f) & 1) != 0)) {
      rate_config = rate_config & 0xff80 | (ushort)(_uVar1 + 1);
    }
  }
  else {
    if ((uVar2 < 4) && (_uVar1 < rc_ss->mcs_max)) {
      uVar1 = rc_get_nss(rate_config);
      if ((*(byte *)((int)&rc_ss->rate_map + CONCAT31(extraout_var_00,uVar1)) >> (_uVar1 + 1 & 0x1f)
          & 1) != 0) {
        rate_config = rate_config & 0xfff8 | (ushort)(_uVar1 + 1);
        if (rc_ss->short_gi != '\0') {
          rate_config = rate_config | 0x200;
        }
      }
    }
  }
  return rate_config;
}



_Bool is_cck_group(uint16_t rate_config)

{
  u8_l uVar1;
  undefined3 extraout_var;
  
  if ((rate_config & 0x3000) == 0) {
    uVar1 = rc_get_mcs_index(rate_config);
    return (_Bool)(CONCAT31(extraout_var,uVar1) < 4);
  }
  return false;
}



void rc_update_retry_chain(rc_sta_stats *rc_ss,uint32_t *cur_tp)

{
  ushort uVar1;
  ushort uVar2;
  int iVar3;
  uint uVar4;
  _Bool _Var5;
  ushort uVar6;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  ushort *puVar7;
  int iVar8;
  uint32_t uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  
  uVar6 = rc_ss->no_samples;
  uVar13 = (uint)uVar6;
  if (((rc_ss->info & 4) == 0) && (cur_tp[uVar13 - 1] < *cur_tp)) {
    rc_ss->retry[0].idx = 0;
    rc_ss->retry[0].tp = 0;
    uVar4 = 1;
  }
  else {
    rc_ss->retry[0].idx = uVar6 - 1;
    uVar4 = 2;
    rc_ss->retry[0].tp = cur_tp[uVar13 - 1];
  }
  uVar1 = rc_ss->retry[0].idx;
  _Var5 = is_cck_group(*(uint16_t *)((int)(&rc_ss->last_rc_time + (uint)uVar1 * 3) + 10));
  if (CONCAT31(extraout_var,_Var5) == 0) {
    uVar12 = 0;
    while ((int)uVar12 < (int)(uVar13 - 1)) {
      _Var5 = is_cck_group(*(uint16_t *)((int)(&rc_ss->last_rc_time + uVar12 * 3) + 10));
      if (CONCAT31(extraout_var_00,_Var5) != 0) {
        *(undefined *)((int)(&rc_ss->last_rc_time + uVar12 * 3) + 0xf) = 0;
      }
      uVar12 = uVar12 + 1 & 0xffff;
    }
    *(undefined *)((int)(&rc_ss->last_rc_time + (uint)uVar1 * 3) + 0xf) = 1;
  }
  uVar9 = rc_ss->retry[0].tp;
  rc_ss->retry[1].idx = uVar1;
  rc_ss->retry[1].tp = uVar9;
  iVar3 = uVar13 - uVar4;
  do {
    iVar8 = iVar3;
    uVar12 = uVar4;
    uVar4 = uVar12 + 1 & 0xffff;
    if (uVar13 <= uVar12) goto LAB_2306228c;
    iVar3 = iVar8 + -1;
  } while (rc_ss->rate_stats[iVar8].rate_allowed == false);
  rc_ss->retry[1].idx = uVar6 - (short)uVar12;
  rc_ss->retry[1].tp = cur_tp[iVar8];
LAB_2306228c:
  uVar12 = (uint)rc_ss->retry[1].idx;
  uVar4 = uVar13 - uVar4;
  do {
    uVar10 = uVar4;
    uVar11 = uVar12;
    if (uVar13 <= (uVar13 - uVar10 & 0xffff)) break;
    uVar4 = uVar10 - 1;
    uVar11 = uVar10;
  } while (rc_ss->rate_stats[uVar10].rate_allowed == false);
  uVar13 = cur_tp[uVar11];
  puVar7 = &rc_ss->rate_stats[0].probability;
  uVar6 = rc_ss->rate_stats[uVar11].probability;
  uVar4 = 0;
  do {
    if (uVar12 <= (uVar4 & 0xffff)) {
      rc_ss->retry[2].idx = (uint16_t)uVar11;
      uVar9 = cur_tp[uVar11];
      rc_ss->retry[3].idx = 0;
      rc_ss->retry[2].tp = uVar9;
      rc_ss->retry[3].tp = *cur_tp;
      return;
    }
    if ((*(char *)((int)puVar7 + 7) != '\0') && ((uVar4 & 0xffff) != (uint)uVar1)) {
      uVar2 = *puVar7;
      if (uVar2 < 0xf333) {
        if (uVar6 <= uVar2) {
          uVar9 = cur_tp[uVar4];
          goto LAB_23062370;
        }
      }
      else {
        uVar9 = cur_tp[uVar4];
        if (uVar13 <= uVar9) {
LAB_23062370:
          uVar13 = uVar9;
          uVar11 = uVar4;
          uVar6 = uVar2;
        }
      }
    }
    uVar4 = uVar4 + 1;
    puVar7 = puVar7 + 6;
  } while( true );
}



uint16_t rc_get_lowest_rate_config(rc_sta_stats *rc_ss)

{
  byte bVar1;
  uint16_t uVar2;
  
  bVar1 = rc_ss->format_mod;
  if (bVar1 < 2) {
    uVar2 = (uint16_t)rc_ss->r_idx_min;
    if (rc_ss->r_idx_min == 0) {
      return 0x400;
    }
  }
  else {
    if (3 < bVar1) {
      return 0;
    }
    if (rc_ss->r_idx_min == '\0') {
      return 0x400;
    }
    uVar2 = (ushort)bVar1 << 0xb;
  }
  return uVar2;
}



// WARNING: Variable defined which should be unmapped: rc_ss_tmp

void rc_sort_samples_tp(rc_sta_stats *rc_ss,uint32_t *cur_tp)

{
  ushort uVar1;
  uint32_t *puVar2;
  ushort uVar3;
  uint32_t uVar4;
  ushort uVar5;
  rc_rate_stats *__src;
  ushort uVar6;
  rc_rate_stats *__src_00;
  undefined auStack44 [4];
  rc_rate_stats rc_ss_tmp;
  
  uVar5 = rc_ss->no_samples;
  uVar1 = uVar5 - 1;
  while (uVar6 = uVar1, uVar5 != 0) {
    puVar2 = cur_tp + 1;
    uVar5 = 0;
    uVar3 = 1;
    __src = rc_ss->rate_stats + 1;
    while (uVar1 = uVar5, uVar3 < uVar6) {
      __src_00 = __src + 1;
      if (puVar2[1] < *puVar2) {
        memmove(auStack44,__src,0xc);
        memmove(__src,__src_00,0xc);
        memmove(__src_00,auStack44,0xc);
        uVar4 = puVar2[1];
        puVar2[1] = *puVar2;
        *puVar2 = uVar4;
        uVar5 = uVar3;
      }
      uVar3 = uVar3 + 1;
      puVar2 = puVar2 + 1;
      __src = __src_00;
    }
  }
  return;
}



uint16_t rc_get_initial_rate_config(rc_sta_stats *rc_ss)

{
  byte bVar1;
  byte bVar2;
  ushort uVar3;
  int iVar4;
  ushort uVar5;
  
  bVar1 = rc_ss->format_mod;
  if (bVar1 < 2) {
    uVar3 = (ushort)rc_ss->r_idx_max;
    uVar5 = (ushort)bVar1 << 0xb | (ushort)rc_ss->p_type << 10;
  }
  else {
    if (3 < bVar1) {
      return 0;
    }
    bVar2 = rc_ss->no_ss;
    iVar4 = __clzsi2((uint)*(byte *)((int)&rc_ss->rate_map + (uint)bVar2));
    uVar5 = (ushort)rc_ss->short_gi << 9 | (ushort)bVar1 << 0xb | (ushort)rc_ss->bw_max << 7 |
            (ushort)bVar2 << 3;
    uVar3 = 0x1fU - (short)iVar4 & 0xff;
  }
  return (uint16_t)(uVar5 | uVar3);
}



void rc_calc_prob_ewma(rc_rate_stats *rc_rs)

{
  ushort uVar1;
  uint uVar2;
  uint uVar3;
  
  uVar1 = rc_rs->attempts;
  if (uVar1 != 0) {
    rc_rs->sample_skipped = '\0';
    uVar3 = (uint)rc_rs->success << 0x10;
    uVar2 = uVar3 / uVar1;
    if (rc_rs->old_prob_available == false) {
      if (uVar3 < uVar1) {
        rc_rs->probability = 0;
      }
      else {
        rc_rs->probability = (short)uVar2 - 1;
      }
    }
    else {
      rc_rs->probability = (uint16_t)((uint)rc_rs->probability * 0x60 + uVar2 * 0x20 >> 7);
    }
    rc_rs->old_prob_available = true;
    return;
  }
  if (rc_rs->sample_skipped != -1) {
    rc_rs->sample_skipped = rc_rs->sample_skipped + '\x01';
  }
  return;
}



_Bool rc_check_valid_rate(rc_sta_stats *rc_ss,uint16_t rate_config)

{
  u8_l uVar1;
  byte bVar2;
  undefined3 extraout_var;
  undefined2 in_register_0000202e;
  uint uVar3;
  
  uVar3 = CONCAT22(in_register_0000202e,rate_config) >> 0xb & 7;
  if (uVar3 < 2) {
    bVar2 = rc_get_mcs_index(rate_config);
    uVar3 = (uint)rc_ss->rate_map_l;
  }
  else {
    if (3 < uVar3) {
      return true;
    }
    uVar1 = rc_get_nss(rate_config);
    bVar2 = rc_get_mcs_index(rate_config);
    uVar3 = (uint)*(byte *)((int)&rc_ss->rate_map + CONCAT31(extraout_var,uVar1));
  }
  return (_Bool)((byte)(uVar3 >> ((uint)bVar2 & 0x1f)) & 1);
}



uint16_t rc_new_random_rate(rc_sta_stats *rc_ss)

{
  byte bVar1;
  byte bVar2;
  uint uVar3;
  int iVar4;
  uint16_t uVar5;
  uint uVar6;
  ushort uVar7;
  uint uVar8;
  
  bVar1 = rc_ss->bw_max;
  uVar8 = 0;
  next = next * 0x41c64e6d + 0x3039;
  bVar2 = rc_ss->format_mod;
  uVar6 = next >> 0x10;
  uVar5 = (uint16_t)(((uint)bVar2 << 0x1b) >> 0x10);
  if (bVar1 != 0) {
    uVar8 = (uint)bVar1 - 1 & 0xff;
  }
  uVar7 = (ushort)(next >> 0x10);
  if (bVar2 < 2) {
    uVar8 = (int)(uVar6 & 0x7f) % (((uint)rc_ss->r_idx_max - (uint)rc_ss->r_idx_min) + 1) +
            (uint)rc_ss->r_idx_min;
    uVar6 = uVar8 & 0xff;
    if ((rc_ss->rate_map_l >> (uVar8 & 0x1f) & 1) == 0) {
      uVar6 = (uint)rc_ss->r_idx_max;
    }
    uVar5 = uVar5 | (ushort)uVar6;
    if (uVar6 == 0) {
      uVar5 = uVar5 | 0x400;
    }
    else {
      if ((uVar6 - 1 & 0xff) < 3) {
        uVar5 = uVar5 | uVar7 & 0x400 | (ushort)rc_ss->p_type << 10;
      }
    }
  }
  else {
    if (bVar2 < 4) {
      bVar2 = rc_ss->r_idx_min;
      if ((bVar2 < 4) && ((int)(uVar6 << 0x14) < 0)) {
        uVar8 = (int)(uVar6 & 0x7f) % (((uint)rc_ss->r_idx_max - (uint)bVar2) + 1) + (uint)bVar2;
        uVar6 = uVar8 & 0xff;
        if ((rc_ss->rate_map_l >> (uVar8 & 0x1f) & 1) == 0) {
          uVar6 = (uint)rc_ss->r_idx_max;
        }
        uVar5 = 0x400;
        if (uVar6 != 0) {
          uVar5 = (ushort)rc_ss->p_type << 10 | uVar7 & 0x400 | (ushort)uVar6;
        }
      }
      else {
        uVar7 = (ushort)rc_ss->mcs_max;
        iVar4 = (int)((int)uVar6 >> 3 & 3U) % ((uint)rc_ss->no_ss + 1);
        uVar3 = (int)(uVar6 & 7) % ((uint)rc_ss->mcs_max + 1);
        if ((*(byte *)((int)&rc_ss->rate_map + iVar4) >> (uVar3 & 0x1f) & 1) != 0) {
          uVar7 = (ushort)uVar3 & 0xff;
        }
        uVar5 = uVar5 | (ushort)((int)((int)uVar6 >> 9 & 1U) % ((uint)rc_ss->short_gi + 1) << 9) |
                        (ushort)(iVar4 << 3) |
                ((short)((int)((int)uVar6 >> 7 & 3U) % (((uint)bVar1 - uVar8) + 1)) + (short)uVar8)
                * 0x80 | uVar7;
      }
    }
  }
  return uVar5;
}



void rc_update_counters(u8_l sta_idx,u32_l attempts,u32_l failures,_Bool tx_ampdu,
                       _Bool retry_required)

{
  short sVar1;
  rc_sta_stats *prVar2;
  undefined3 in_register_00002029;
  uint uVar3;
  uint8_t uVar4;
  uint32_t *puVar5;
  ushort *puVar6;
  
  uVar3 = CONCAT31(in_register_00002029,sta_idx);
  if (9 < uVar3) {
    return;
  }
  if (sta_info_tab[uVar3].inst_nbr != -1) {
    prVar2 = sta_info_tab[uVar3].pol_tbl.sta_stats;
    if (prVar2 == (rc_sta_stats *)0x0) {
      assert_err("rc_ss != NULL","module",0x7ce);
    }
    puVar6 = &prVar2->retry[0].idx;
    prVar2->ampdu_packets = prVar2->ampdu_packets + 1;
    prVar2->ampdu_len = prVar2->ampdu_len + 1;
    do {
      if (attempts == 0) break;
      puVar5 = &prVar2->last_rc_time + (uint)*puVar6 * 3;
      if (failures < 4) {
        *(short *)(puVar5 + 1) = *(short *)(puVar5 + 1) + (short)attempts;
        sVar1 = (short)failures;
        failures = 0;
        *(short *)((int)puVar5 + 6) = ((short)attempts - sVar1) + *(short *)((int)puVar5 + 6);
        attempts = 0;
      }
      else {
        *(short *)(puVar5 + 1) = *(short *)(puVar5 + 1) + 4;
        attempts = attempts - 4;
        failures = failures - 4;
      }
      if (*(ushort *)(puVar5 + 1) < *(ushort *)((int)puVar5 + 6)) {
        assert_err("rc_rs->attempts >= rc_rs->success","module",0x7fa);
      }
      puVar6 = puVar6 + 4;
    } while (puVar6 != &(prVar2->max_tp_2_trial).idx);
    if (prVar2->trial_status == '\0') {
      if (prVar2->sample_wait != '\0') {
        prVar2->sample_wait = prVar2->sample_wait + -1;
        return;
      }
      uVar4 = '\x01';
    }
    else {
      if (prVar2->trial_status != '\x02') {
        return;
      }
      if ((sta_info_tab[uVar3].pol_tbl.upd_field & 1) != 0) {
        return;
      }
      uVar4 = '\x03';
    }
    prVar2->trial_status = uVar4;
  }
  return;
}



uint32_t rc_get_duration(uint param_1)

{
  u8_l uVar1;
  undefined3 extraout_var;
  uint32_t uVar2;
  undefined3 extraout_var_00;
  uint uVar3;
  
  uVar1 = rc_get_mcs_index((uint16_t)param_1);
  _uVar1 = CONCAT31(extraout_var,uVar1);
  uVar3 = (int)param_1 >> 0xb & 7;
  if (uVar3 < 2) {
    if (_uVar1 < 4) {
      uVar2 = rc_duration_cck[(int)param_1 >> 10 & 1U | _uVar1 << 1];
    }
    else {
      uVar2 = rc_duration_non_ht[_uVar1 - 4];
    }
  }
  else {
    uVar2 = 0;
    if (uVar3 < 4) {
      uVar1 = rc_get_nss((uint16_t)param_1);
      uVar2 = rc_duration_ht_ampdu[_uVar1 << 3 | param_1 >> 9 & 1 | param_1 >> 6 & 6] /
              (CONCAT31(extraout_var_00,uVar1) + 1U);
    }
  }
  return uVar2;
}



void rc_update_bw_nss_max(u8_l sta_idx,u8_l bw_max,u8_l nss_max)

{
  ushort uVar1;
  rc_sta_stats *rc_ss;
  uint16_t uVar2;
  undefined3 in_register_00002029;
  int iVar3;
  undefined2 extraout_var;
  undefined3 in_register_0000202d;
  undefined3 in_register_00002031;
  uint32_t *puVar4;
  uint uVar5;
  ushort *puVar6;
  uint16_t *puVar7;
  uint uVar8;
  uint32_t local_48;
  uint32_t cur_tp [10];
  
  iVar3 = CONCAT31(in_register_00002029,sta_idx);
  rc_ss = sta_info_tab[iVar3].pol_tbl.sta_stats;
  if (rc_ss == (rc_sta_stats *)0x0) {
    assert_err("rc_ss != NULL","module",0x969);
  }
  if (((uint)rc_ss->bw_max != CONCAT31(in_register_0000202d,bw_max)) ||
     ((uint)rc_ss->no_ss != CONCAT31(in_register_00002031,nss_max))) {
    rc_ss->bw_max = bw_max;
    if (3 < CONCAT31(in_register_0000202d,bw_max)) {
      assert_err("rc_ss->bw_max <= BW_160MHZ","module",0x96f);
    }
    rc_ss->no_ss = nss_max;
    if (7 < CONCAT31(in_register_00002031,nss_max)) {
      assert_err("rc_ss->no_ss < 8","module",0x971);
    }
    if (rc_ss->fixed_rate_cfg == 0xffff) {
      uVar2 = rc_get_lowest_rate_config(rc_ss);
      rc_ss->rate_stats[0].rate_config = uVar2;
      uVar2 = rc_get_initial_rate_config(rc_ss);
      rc_ss->rate_stats[(uint)rc_ss->no_samples - 1].rate_config = uVar2;
      uVar5 = 1;
LAB_23062974:
      uVar1 = rc_ss->no_samples;
      if ((int)uVar5 < (int)((uint)uVar1 - 1)) {
        do {
          uVar2 = rc_new_random_rate(rc_ss);
          uVar8 = 0;
          puVar6 = &rc_ss->rate_stats[0].rate_config;
          while( true ) {
            if (rc_ss->no_samples <= uVar8) {
              rc_ss->rate_stats[uVar5].rate_config = uVar2;
              uVar5 = uVar5 + 1 & 0xffff;
              goto LAB_23062974;
            }
            if ((uint)*puVar6 == CONCAT22(extraout_var,uVar2)) break;
            uVar8 = uVar8 + 1;
            puVar6 = puVar6 + 6;
          }
        } while( true );
      }
      puVar7 = &rc_ss->rate_stats[0].probability;
      uVar5 = 0;
      puVar4 = &local_48;
      while ((uint)uVar1 != uVar5) {
        *(undefined *)(puVar7 + 3) = 0;
        *(undefined *)((int)puVar7 + 7) = 1;
        *puVar7 = 0;
        *(undefined *)((int)puVar7 + 5) = 0;
        *puVar4 = 0;
        uVar5 = uVar5 + 1 & 0xffff;
        puVar7 = puVar7 + 6;
        puVar4 = puVar4 + 1;
      }
      rc_sort_samples_tp(rc_ss,&local_48);
      rc_update_retry_chain(rc_ss,&local_48);
      sta_info_tab[iVar3].pol_tbl.upd_field = sta_info_tab[iVar3].pol_tbl.upd_field | 1;
    }
  }
  return;
}



void rc_init_bcmc_rate(sta_info_tag *sta_entry,u8_l basic_rate_idx)

{
  undefined3 in_register_0000202d;
  txl_buffer_control *ptVar1;
  uint uVar2;
  
  ptVar1 = (sta_entry->pol_tbl).buf_ctrl;
  uVar2 = 0;
  if (CONCAT31(in_register_0000202d,basic_rate_idx) < 4) {
    uVar2 = SEXT24((short)((sta_entry->pol_tbl).ppdu_tx_cfg & 0x400));
  }
  uVar2 = CONCAT31(in_register_0000202d,basic_rate_idx) | uVar2 | 0x20000000;
  *(uint *)(ptVar1->field_0 + 0x14) = uVar2;
  *(uint *)(ptVar1->field_0 + 0x18) = uVar2;
  *(uint *)(ptVar1->field_0 + 0x1c) = uVar2;
  *(uint *)(ptVar1->field_0 + 0x20) = uVar2;
  return;
}



_Bool rc_check_fixed_rate_config(rc_sta_stats *rc_ss,uint16_t fixed_rate_config)

{
  u8_l uVar1;
  _Bool _Var2;
  undefined3 extraout_var;
  undefined2 in_register_0000202e;
  uint uVar3;
  uint uVar4;
  
  uVar4 = (uint)rc_ss->format_mod;
  uVar3 = ((uint)fixed_rate_config & 0x3800) >> 0xb;
  if (uVar4 < uVar3) {
    return false;
  }
  if (rc_ss->format_mod == 4) {
    if (uVar3 != uVar4) {
      return false;
    }
LAB_23062a66:
    if ((fixed_rate_config & 0x3000) == 0) {
LAB_23062abe:
      if (((CONCAT22(in_register_0000202e,fixed_rate_config) >> 10 & 1U) == 0) &&
         (rc_ss->p_type == '\x01')) {
        return false;
      }
      goto LAB_23062a98;
    }
  }
  else {
    if (1 < (uVar4 - 2 & 0xff)) goto LAB_23062a66;
    if ((fixed_rate_config & 0x3000) == 0) {
      if (3 < rc_ss->r_idx_min) {
        return false;
      }
      goto LAB_23062abe;
    }
  }
  if (((((fixed_rate_config & 0x200) != 0) && (rc_ss->short_gi == '\0')) ||
      ((uint)rc_ss->bw_max < (CONCAT22(in_register_0000202e,fixed_rate_config) >> 7 & 3U))) ||
     (uVar1 = rc_get_nss(fixed_rate_config), (uint)rc_ss->no_ss < CONCAT31(extraout_var,uVar1))) {
    return false;
  }
LAB_23062a98:
  _Var2 = rc_check_valid_rate(rc_ss,fixed_rate_config);
  return _Var2;
}



u32_l rc_calc_tp(rc_sta_stats *rc_ss,u8_l sample_idx)

{
  ushort uVar1;
  ushort rate_config;
  uint uVar2;
  _Bool _Var3;
  undefined3 extraout_var;
  int iVar4;
  u32_l uVar5;
  undefined3 in_register_0000202d;
  
  uVar1 = *(ushort *)(&rc_ss->last_rc_time + CONCAT31(in_register_0000202d,sample_idx) * 3 + 2);
  if (uVar1 < 0x1999) {
    uVar5 = 0;
  }
  else {
    rate_config = *(ushort *)
                   ((int)(&rc_ss->last_rc_time + CONCAT31(in_register_0000202d,sample_idx) * 3) + 10
                   );
    uVar2 = 0;
    _Var3 = is_cck_group(rate_config);
    if (CONCAT31(extraout_var,_Var3) == 0) {
      uVar2 = 0x35390 / (uint)*(ushort *)((int)&rc_ss->avg_ampdu_len + 2);
    }
    iVar4 = rc_get_duration((uint)rate_config);
    uVar5 = (((uint)uVar1 * 1000) / (iVar4 + uVar2)) * 1000000 >> 0x10;
  }
  return uVar5;
}



_Bool rc_update_stats(rc_sta_stats *rc_ss,_Bool init)

{
  byte bVar1;
  ushort rate_config;
  _Bool _Var2;
  uint16_t rate_config_00;
  u32_l uVar3;
  undefined2 extraout_var_03;
  undefined3 extraout_var;
  undefined2 extraout_var_04;
  undefined3 extraout_var_00;
  undefined2 extraout_var_05;
  undefined3 extraout_var_01;
  undefined2 extraout_var_06;
  undefined3 extraout_var_02;
  uint uVar4;
  undefined3 in_register_0000202d;
  rc_rate_stats *prVar5;
  uint32_t *cur_tp_00;
  uint32_t *puVar6;
  uint uVar7;
  ushort rate_config_01;
  uint16_t uVar8;
  uint8_t *puVar9;
  uint16_t *puVar10;
  uint16_t *puVar11;
  uint uVar12;
  char cVar13;
  uint16_t uStack148;
  ushort uStack146;
  uint16_t new_rate_cfg_array [6];
  step old_retry [4];
  uint32_t cur_tp [10];
  
  memcpy(new_rate_cfg_array + 4,rc_ss->retry,0x20);
  if (rc_ss->ampdu_packets != 0) {
    rate_config = rc_ss->ampdu_len;
    *(undefined4 *)&rc_ss->ampdu_len = 0;
    rc_ss->avg_ampdu_len =
         ((int)((uint)rate_config << 0x10) / (int)(uint)rc_ss->ampdu_packets) * 0x20 +
         rc_ss->avg_ampdu_len * 0x60 >> 7;
  }
  rate_config = rc_ss->no_samples;
  cur_tp_00 = (uint32_t *)&old_retry[3].idx;
  rc_ss->sample_slow = '\0';
  puVar9 = &rc_ss->rate_stats[0].n_retry;
  uVar7 = 0;
  puVar6 = cur_tp_00;
  while ((uint)rate_config != uVar7) {
    *puVar6 = 0;
    *puVar9 = '\0';
    puVar9[1] = '\x01';
    uVar7 = uVar7 + 1 & 0xffff;
    puVar6 = puVar6 + 1;
    puVar9 = puVar9 + 0xc;
  }
  rate_config_00 = rc_ss->fixed_rate_cfg;
  uVar12 = 0;
  if (rate_config_00 == 0xffff) {
    while (uVar12 < rc_ss->no_samples) {
      rc_calc_prob_ewma(rc_ss->rate_stats + uVar12);
      uVar3 = rc_calc_tp(rc_ss,(u8_l)uVar12);
      *(u32_l *)(&old_retry[3].idx + uVar12 * 2) = uVar3;
      uVar12 = uVar12 + 1 & 0xffff;
    }
    rc_sort_samples_tp(rc_ss,cur_tp_00);
    rc_update_retry_chain(rc_ss,cur_tp_00);
    if (CONCAT31(in_register_0000202d,init) == 0) {
      rate_config = rc_ss->no_samples;
      if (9 < rate_config) {
        cVar13 = '\0';
        rate_config = rc_ss->rate_stats[rc_ss->retry[0].idx].rate_config;
        uVar7 = (uint)rate_config;
        rate_config_01 = rc_ss->rate_stats[rc_ss->retry[1].idx].rate_config;
        memset(&uStack148,-1,0xc);
        do {
          switch(cVar13) {
          case '\x01':
            if ((((int)uVar7 >> 0xb & 6U) != 0) && (rc_ss->short_gi == '\x01')) {
              if ((rate_config & 0x200) == 0) {
                uStack146 = rate_config | 0x200;
              }
              else {
                uStack146 = rate_config & 0xfdff;
              }
            }
            break;
          case '\x02':
            rate_config_00 = rc_set_next_mcs_index(rc_ss,rate_config);
            if ((uVar7 != CONCAT22(extraout_var_03,rate_config_00)) &&
               (_Var2 = rc_check_valid_rate(rc_ss,rate_config_00), CONCAT31(extraout_var,_Var2) != 0
               )) {
              new_rate_cfg_array[0] = rate_config_00;
            }
            break;
          case '\x03':
            rate_config_00 = rc_set_previous_mcs_index(rc_ss,rate_config);
            if ((uVar7 != CONCAT22(extraout_var_04,rate_config_00)) &&
               (_Var2 = rc_check_valid_rate(rc_ss,rate_config_00),
               CONCAT31(extraout_var_00,_Var2) != 0)) {
              new_rate_cfg_array[1] = rate_config_00;
            }
            break;
          case '\x04':
            rate_config_00 = rc_set_next_mcs_index(rc_ss,rate_config_01);
            if (((uint)rate_config_01 != CONCAT22(extraout_var_05,rate_config_00)) &&
               (_Var2 = rc_check_valid_rate(rc_ss,rate_config_00),
               CONCAT31(extraout_var_01,_Var2) != 0)) {
              new_rate_cfg_array[2] = rate_config_00;
            }
            break;
          case '\x05':
            rate_config_00 = rc_set_previous_mcs_index(rc_ss,rate_config_01);
            if (((uint)rate_config_01 != CONCAT22(extraout_var_06,rate_config_00)) &&
               (_Var2 = rc_check_valid_rate(rc_ss,rate_config_00),
               CONCAT31(extraout_var_02,_Var2) != 0)) {
              new_rate_cfg_array[3] = rate_config_00;
            }
            break;
          default:
            uStack148 = rc_new_random_rate(rc_ss);
          }
          cVar13 = cVar13 + '\x01';
        } while (cVar13 != '\x06');
        rate_config = rc_ss->no_samples;
        uVar12 = 1;
        uVar7 = 0;
        while (uVar12 < rate_config) {
          puVar6 = &rc_ss->last_rc_time + uVar12 * 3;
          if ((((*(short *)(puVar6 + 2) < 0) && (*(byte *)(puVar6 + 3) < 0xb)) ||
              ((uint)rc_ss->retry[0].idx == uVar12)) ||
             ((((uint)rc_ss->retry[1].idx == uVar12 || ((uint)rc_ss->retry[2].idx == uVar12)) ||
              (5 < uVar7)))) {
            uVar12 = uVar12 + 1 & 0xffff;
          }
          else {
            rate_config_00 = (&uStack148)[uVar7];
            if (rate_config_00 != 0xffff) {
              uVar4 = 0;
              puVar11 = &rc_ss->rate_stats[0].rate_config;
              while (uVar4 < rate_config) {
                if (*puVar11 == rate_config_00) goto LAB_23062e56;
                uVar4 = uVar4 + 1;
                puVar11 = puVar11 + 6;
              }
              *(uint16_t *)((int)puVar6 + 10) = rate_config_00;
              *(undefined2 *)(puVar6 + 2) = 0;
              *(undefined *)((int)puVar6 + 0xd) = 0;
              uVar12 = uVar12 + 1 & 0xffff;
            }
LAB_23062e56:
            uVar7 = uVar7 + 1;
          }
          *(undefined2 *)(puVar6 + 1) = 0;
          *(undefined2 *)((int)puVar6 + 6) = 0;
        }
        *(undefined4 *)rc_ss->rate_stats = 0;
        goto LAB_23062d1c;
      }
      prVar5 = rc_ss->rate_stats;
      rate_config_01 = 0;
      while (rate_config != rate_config_01) {
        rate_config_01 = rate_config_01 + 1;
        prVar5->attempts = 0;
        prVar5->success = 0;
        prVar5 = prVar5 + 1;
      }
    }
  }
  else {
    bVar1 = rc_ss->info;
    uVar12 = 0;
    if ((bVar1 & 0x20) != 0) {
      while (uVar8 = (uint16_t)uVar12, uVar12 < uVar7) {
        if (rc_ss->rate_stats[uVar12].rate_config == rate_config_00) goto LAB_23062eb0;
        uVar12 = uVar12 + 1 & 0xff;
      }
      if (uVar7 == uVar12) {
        uVar12 = uVar12 - 1 & 0xff;
        uVar8 = (uint16_t)uVar12;
        *(uint16_t *)((int)(&rc_ss->last_rc_time + uVar12 * 3) + 10) = rate_config_00;
        *(undefined2 *)(&rc_ss->last_rc_time + uVar12 * 3 + 2) = 0;
      }
LAB_23062eb0:
      rc_ss->retry[0].idx = uVar8;
      rc_ss->retry[1].idx = uVar8;
      rc_ss->retry[2].idx = uVar8;
      rc_ss->retry[0].tp = 0;
      rc_ss->retry[1].tp = 0;
      rc_ss->retry[2].tp = 0;
      prVar5 = rc_ss->rate_stats;
      uVar12 = 0;
      while (uVar7 != uVar12) {
        prVar5->attempts = 0;
        prVar5->success = 0;
        uVar12 = uVar12 + 1 & 0xffff;
        prVar5 = prVar5 + 1;
      }
      rc_ss->info = bVar1 & 0x9f | 0x40;
      init = true;
      goto LAB_23062d1c;
    }
    uVar7 = (uint)*(byte *)&rc_ss->retry[0].idx;
    rc_calc_prob_ewma(rc_ss->rate_stats + uVar7);
    *(undefined2 *)(&rc_ss->last_rc_time + uVar7 * 3 + 1) = 0;
    *(undefined2 *)((int)(&rc_ss->last_rc_time + uVar7 * 3) + 6) = 0;
    *(undefined4 *)rc_ss->rate_stats = 0;
  }
  init = false;
LAB_23062d1c:
  puVar10 = &rc_ss->retry[0].idx;
  puVar11 = new_rate_cfg_array;
  do {
    if (puVar11[6] != *puVar10) {
      return true;
    }
    puVar10 = puVar10 + 4;
    puVar11 = puVar11 + 4;
  } while (puVar10 != &(rc_ss->max_tp_2_trial).idx);
  return init;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rc_init(sta_info_tag *sta_entry)

{
  byte bVar1;
  ushort uVar2;
  uint uVar3;
  step *psVar4;
  uint8_t uVar5;
  uint8_t uVar6;
  _Bool _Var7;
  byte bVar8;
  uint16_t rate_map;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  undefined3 extraout_var_05;
  undefined3 extraout_var_06;
  undefined2 extraout_var_07;
  int iVar9;
  short sVar10;
  uint *puVar11;
  uint *puVar12;
  uint uVar13;
  ushort *puVar14;
  uint uVar15;
  uint uVar16;
  rc_sta_stats *__s;
  txl_buffer_control *ptVar17;
  uint uVar18;
  rc_sta_stats *rc_ss;
  uint uVar19;
  uint8_t *mcs_set;
  ushort *puVar20;
  
  bVar8 = sta_entry->staid;
  ptVar17 = (sta_entry->pol_tbl).buf_ctrl;
  if (9 < bVar8) {
    assert_err("sta_entry->staid < NX_REMOTE_STA_MAX","module",0x85f);
  }
  uVar16 = (uint)sta_entry->staid;
  __s = sta_stats + uVar16;
  (sta_entry->pol_tbl).sta_stats = __s;
  uVar5 = phy_get_ntx();
  uVar18 = CONCAT31(extraout_var,uVar5) << 0xe;
  memset(__s,0,200);
  if (((sta_entry->info).capa_flags & 2) == 0) {
    rate_map = me_legacy_rate_bitfield_build((mac_rateset *)&sta_entry->info,false);
    sta_stats[uVar16].rate_map_l = rate_map;
    uVar5 = me_legacy_ridx_min(rate_map);
    sta_stats[uVar16].r_idx_min = uVar5;
    if (0xb < CONCAT31(extraout_var_05,uVar5)) {
      assert_err("rc_ss->r_idx_min < MAC_RATESET_LEN","module",0x8f4);
    }
    uVar5 = me_legacy_ridx_max(sta_stats[uVar16].rate_map_l);
    sta_stats[uVar16].r_idx_max = uVar5;
    if (0xb < CONCAT31(extraout_var_06,uVar5)) {
      assert_err("rc_ss->r_idx_max < MAC_RATESET_LEN","module",0x8f6);
    }
    sta_stats[uVar16].mcs_max = -1;
    uVar5 = (sta_entry->info).bw_cur;
    sta_stats[uVar16].bw_max = uVar5;
    if (uVar5 != '\0') {
      assert_err("rc_ss->bw_max == BW_20MHZ","module",0x8f9);
    }
    sta_stats[uVar16].p_type = (byte)((int)(uint)(sta_entry->pol_tbl).ppdu_tx_cfg >> 10) & 1;
  }
  else {
    rate_map = me_legacy_rate_bitfield_build((mac_rateset *)&sta_entry->info,false);
    mcs_set = (sta_entry->info).ht_cap.mcs_rate;
    sta_stats[uVar16].format_mod = '\x02';
    sta_stats[uVar16].rate_map_l = rate_map;
    uVar5 = me_11n_nss_max(mcs_set);
    uVar6 = me_11n_nss_max(me_env.ht_cap.mcs_rate);
    uVar19 = CONCAT31(extraout_var_00,uVar5);
    if (CONCAT31(extraout_var_01,uVar6) < CONCAT31(extraout_var_00,uVar5)) {
      uVar19 = CONCAT31(extraout_var_01,uVar6);
    }
    sta_stats[uVar16].no_ss = (uint8_t)uVar19;
    if (3 < uVar19) {
      assert_err("rc_ss->no_ss <= 3","module",0x8a6);
    }
    memcpy(&sta_stats[uVar16].rate_map,mcs_set,4);
    rate_map = sta_stats[uVar16].rate_map_l;
    *(undefined *)&sta_stats[uVar16].rate_map = 0xff;
    sta_stats[uVar16].mcs_max = '\a';
    uVar5 = me_legacy_ridx_min(rate_map);
    sta_stats[uVar16].r_idx_min = uVar5;
    if (0xc < CONCAT31(extraout_var_02,uVar5)) {
      assert_err("(rc_ss->r_idx_min <= HW_RATE_54MBPS) || (rc_ss->r_idx_min == MAC_RATESET_LEN)",
                 "module",0x8b8);
    }
    uVar5 = me_legacy_ridx_max(sta_stats[uVar16].rate_map_l);
    sta_stats[uVar16].r_idx_max = uVar5;
    if (0xc < CONCAT31(extraout_var_03,uVar5)) {
      assert_err("(rc_ss->r_idx_max <= HW_RATE_54MBPS) || (rc_ss->r_idx_max == MAC_RATESET_LEN)",
                 "module",0x8be);
    }
    sta_stats[uVar16].p_type = (byte)((int)(uint)(sta_entry->pol_tbl).ppdu_tx_cfg >> 10) & 1;
    _Var7 = phy_ldpc_tx_supported();
    uVar2 = (sta_entry->info).ht_cap.ht_capa_info;
    if ((CONCAT31(extraout_var_04,_Var7) != 0) && ((uVar2 & 1) != 0)) {
      uVar18 = uVar18 | 0x40;
    }
    if ((int)((uint)uVar2 << 0x14) < 0) {
      sVar10 = 0x2000;
    }
    else {
      sVar10 = 0x1000;
    }
    sta_stats[uVar16].max_amsdu_len = sVar10 - 0x101;
    bVar1 = (sta_entry->info).bw_cur;
    sta_stats[uVar16].bw_max = bVar1;
    if (3 < bVar1) {
      assert_err("rc_ss->bw_max <= BW_160MHZ","module",0x8d5);
    }
    uVar5 = (sta_entry->info).bw_cur;
    if (uVar5 == '\0') {
      if (((sta_entry->info).ht_cap.ht_capa_info & 0x20) != 0) {
        uVar5 = '\x01';
        goto LAB_23063162;
      }
    }
    else {
      if ((uVar5 == '\x01') && (((sta_entry->info).ht_cap.ht_capa_info & 0x40) != 0)) {
LAB_23063162:
        sta_stats[uVar16].short_gi = uVar5;
      }
    }
  }
  if (sta_stats[uVar16].format_mod < 2) {
    uVar19 = (uint)sta_stats[uVar16].rate_map_l;
    uVar15 = 1 - (uint)sta_stats[uVar16].p_type;
    uVar13 = (((int)uVar19 >> 1 & 1U) + ((int)uVar19 >> 2 & 1U) << (uVar15 & 0x1f)) + (uVar19 & 1) +
             (((int)uVar19 >> 3 & 1U) << (uVar15 & 0x1f)) & 0xffff;
    uVar15 = 4;
    do {
      uVar3 = uVar15 & 0x1f;
      uVar15 = uVar15 + 1;
      uVar13 = uVar13 + ((int)uVar19 >> uVar3 & 1U) & 0xffff;
    } while (uVar15 != 0xc);
LAB_2306327c:
    if (10 < uVar13) {
      sta_stats[uVar16].no_samples = 10;
      goto LAB_23063290;
    }
    sta_stats[uVar16].no_samples = (uint16_t)uVar13;
    if (uVar13 != 0) goto LAB_23063290;
  }
  else {
    if (sta_stats[uVar16].format_mod < 4) {
      uVar19 = (uint)*(byte *)&sta_stats[uVar16].rate_map;
      iVar9 = 8;
      uVar15 = 0;
      do {
        uVar13 = uVar19 & 1;
        iVar9 = iVar9 + -1;
        uVar19 = uVar19 >> 1;
        uVar15 = uVar15 + (1 << ((uint)sta_stats[uVar16].short_gi & 0x1f)) * uVar13 & 0xffff;
      } while (iVar9 != 0);
      uVar13 = (uint)sta_stats[uVar16].rate_map_l;
      uVar19 = 1 - (uint)sta_stats[uVar16].p_type;
      uVar13 = uVar15 + (((int)uVar13 >> 1 & 1U) + ((int)uVar13 >> 2 & 1U) << (uVar19 & 0x1f)) +
                        (uVar13 & 1) + (((int)uVar13 >> 3 & 1U) << (uVar19 & 0x1f)) & 0xffff;
      goto LAB_2306327c;
    }
    sta_stats[uVar16].no_samples = 0;
  }
  assert_err("rc_ss->no_samples >= 1","module",0x8ff);
  if (10 < sta_stats[uVar16].no_samples) {
    assert_err("rc_ss->no_samples <= RC_MAX_N_SAMPLE","module",0x900);
  }
LAB_23063290:
  rc_ss = sta_info_tab[sta_entry->staid].pol_tbl.sta_stats;
  if (rc_ss == (rc_sta_stats *)0x0) {
    assert_err("rc_ss != NULL","module",0x6e4);
  }
  uVar2 = rc_ss->no_samples;
  puVar20 = &rc_ss->rate_stats[0].rate_config;
  uVar19 = 0;
  puVar14 = puVar20;
  while (uVar19 != (uint)uVar2) {
    *puVar14 = 0xffff;
    uVar19 = uVar19 + 1 & 0xffff;
    puVar14 = puVar14 + 6;
  }
  rate_map = rc_get_lowest_rate_config(rc_ss);
  rc_ss->rate_stats[0].rate_config = rate_map;
  rate_map = rc_get_initial_rate_config(rc_ss);
  rc_ss->rate_stats[uVar19 - 1].rate_config = rate_map;
  uVar19 = 1;
LAB_230632fa:
  do {
    uVar2 = rc_ss->no_samples;
    if ((int)((uint)uVar2 - 1) <= (int)uVar19) {
      rc_ss->retry[0].idx = (uint16_t)((uint)uVar2 - 1);
      rc_ss->retry[2].idx = uVar2 - 3;
      rc_ss->avg_ampdu_len = 0x10000;
      rc_ss->retry[1].idx = uVar2 - 2;
      rc_ss->fixed_rate_cfg = 0xffff;
      rc_ss->retry[0].tp = 0;
      rc_ss->retry[1].tp = 0;
      rc_ss->retry[2].tp = 0;
      rc_ss->retry[3].idx = 0;
      rc_ss->retry[3].tp = 0;
      rc_ss->info = '\0';
      rc_update_stats(rc_ss,true);
      rc_ss->sample_wait = '\x05';
      puVar11 = (uint *)(ptVar17->field_0 + 0x14);
      do {
        psVar4 = __s->retry;
        puVar12 = puVar11 + 1;
        __s = (rc_sta_stats *)&__s->rate_stats[0].probability;
        *puVar11 = (uint)sta_stats[uVar16].rate_stats[*(byte *)&psVar4->idx].rate_config |
                   0x80000000;
        puVar11 = puVar12;
      } while (puVar12 != (uint *)(ptVar17->field_0 + 0x24));
      sta_stats[uVar16].last_rc_time = _DAT_44b00120;
      *(undefined4 *)ptVar17->field_0 = 0xbadcab1e;
      *(uint *)(ptVar17->field_0 + 0xc) = ((uint)bVar8 + 8 & 0xff) << 10;
      *(undefined4 *)(ptVar17->field_0 + 0x10) = 0xffff0704;
      *(uint *)(ptVar17->field_0 + 4) = uVar18;
      bVar8 = phy_get_ntx();
      *(int *)(ptVar17->field_0 + 8) = (1 << ((uint)bVar8 + 1 & 0x1f)) + -1;
      ((sta_entry->pol_tbl).buf_ctrl)->mac_control_info = 0x2200;
      ((sta_entry->pol_tbl).buf_ctrl)->phy_control_info = sta_entry->paid_gid;
      (sta_entry->pol_tbl).upd_field = (sta_entry->pol_tbl).upd_field | 0x11;
      return;
    }
    rate_map = rc_new_random_rate(rc_ss);
    uVar15 = 0;
    puVar14 = puVar20;
    while (uVar15 < rc_ss->no_samples) {
      if ((uint)*puVar14 == CONCAT22(extraout_var_07,rate_map)) goto LAB_230632fa;
      uVar15 = uVar15 + 1;
      puVar14 = puVar14 + 6;
    }
    rc_ss->rate_stats[uVar19].rate_config = rate_map;
    uVar19 = uVar19 + 1 & 0xffff;
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rc_check(u8_l sta_idx,_Bool *tx_ampdu)

{
  ushort uVar1;
  ushort uVar2;
  ushort rate_config;
  ushort rate_config_00;
  uint16_t uVar3;
  bool bVar4;
  rc_sta_stats *rc_ss;
  uint uVar5;
  _Bool _Var6;
  u8_l uVar7;
  u8_l uVar8;
  undefined3 in_register_00002029;
  uint uVar9;
  undefined3 extraout_var;
  uint uVar10;
  uint32_t uVar11;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  uint32_t uVar12;
  uint8_t uVar13;
  byte bVar14;
  uint32_t *puVar15;
  uint uVar16;
  int iVar17;
  uint uVar18;
  uint uVar19;
  
  uVar9 = CONCAT31(in_register_00002029,sta_idx);
  if (9 < uVar9) {
    return;
  }
  rc_ss = sta_info_tab[uVar9].pol_tbl.sta_stats;
  if (rc_ss == (rc_sta_stats *)0x0) {
    assert_err("rc_ss != NULL","module",0x826);
  }
  iVar17 = 0;
  if ((int)((100000 - _DAT_44b00120) + rc_ss->last_rc_time) < 0) {
    _Var6 = rc_update_stats(rc_ss,false);
    iVar17 = CONCAT31(extraout_var,_Var6);
    rc_ss->trial_status = '\0';
    rc_ss->sw_retry_step = '\0';
    rc_ss->info = rc_ss->info & 0xef;
    rc_ss->last_rc_time = _DAT_44b00120;
  }
  if (rc_ss->trial_status == '\x01') {
    if ((rc_ss->info & 0x40) == 0) {
      bVar14 = rc_ss->format_mod;
      uVar1 = rc_ss->retry[0].idx;
      uVar16 = (uint)uVar1;
      if (bVar14 < 2) {
        if ((ushort)(rc_ss->rate_stats[uVar16].probability + 0xe667) < 0xd99b) {
          uVar13 = '\n';
        }
        else {
          uVar13 = '\x05';
        }
      }
      else {
        uVar13 = ((char)*(undefined2 *)((int)&rc_ss->avg_ampdu_len + 2) + '\b') * '\x02';
      }
      rc_ss->sample_wait = uVar13;
      next = next * 0x41c64e6d + 0x3039;
      uVar5 = (next >> 0x10) % (uint)rc_ss->no_samples;
      if (uVar5 != uVar16) {
        uVar2 = rc_ss->retry[1].idx;
        if (((uVar5 != (uint)uVar2) && (uVar19 = (uint)rc_ss->retry[2].idx, uVar5 != uVar19)) &&
           (puVar15 = &rc_ss->last_rc_time + uVar5 * 3, *(ushort *)(puVar15 + 2) < 0xf334)) {
          rate_config = *(ushort *)((int)puVar15 + 10);
          uVar10 = rc_get_duration((uint)rate_config);
          rate_config_00 = rc_ss->rate_stats[uVar16].rate_config;
          if (bVar14 < 2) {
            uVar16 = rc_get_duration((uint)rate_config_00);
            if (uVar16 < uVar10) {
              uVar11 = 0;
              bVar4 = 0x13 < *(byte *)(puVar15 + 3);
            }
            else {
              uVar11 = 0;
              bVar4 = true;
            }
          }
          else {
            uVar18 = 0x20;
            uVar16 = rc_get_duration((uint)rc_ss->rate_stats[(uint)uVar2].rate_config);
            if (*(char *)((int)puVar15 + 0xd) == '\0') {
              uVar18 = (uint)*(ushort *)((int)&rc_ss->avg_ampdu_len + 2);
            }
            if (uVar16 <= uVar10) {
              uVar7 = rc_get_nss(rate_config_00);
              uVar8 = rc_get_nss(rate_config);
              if ((CONCAT31(extraout_var_00,uVar7) - 1U < CONCAT31(extraout_var_01,uVar8)) ||
                 (uVar16 = rc_get_duration((uint)rc_ss->rate_stats[uVar19].rate_config),
                 uVar16 <= uVar10)) {
                if (uVar18 <= *(byte *)(puVar15 + 3)) {
                  bVar14 = rc_ss->sample_slow + 1;
                  rc_ss->sample_slow = bVar14;
                  if (bVar14 < 3) goto LAB_23063714;
                  if (0xf < bVar14) {
                    rc_ss->sample_slow = '\x0f';
                  }
                }
                goto LAB_230636ee;
              }
            }
LAB_23063714:
            uVar11 = rc_calc_tp(rc_ss,(u8_l)uVar5);
            bVar4 = true;
            if ((*(byte *)((int)puVar15 + 0xe) & 0xf) < 10) {
              bVar4 = uVar18 <= *(byte *)(puVar15 + 3);
            }
          }
          uVar12 = rc_ss->retry[1].tp;
          (rc_ss->max_tp_2_trial).idx = uVar2;
          (rc_ss->max_tp_2_trial).tp = uVar12;
          if (bVar4) {
            uVar12 = rc_ss->retry[0].tp;
            rc_ss->info = rc_ss->info & 0xfd;
            rc_ss->retry[1].tp = uVar12;
            rc_ss->retry[1].idx = uVar1;
            rc_ss->retry[0].tp = uVar11;
            rc_ss->retry[0].idx = (uint16_t)uVar5;
          }
          else {
            rc_ss->info = rc_ss->info | 2;
            rc_ss->retry[1].tp = uVar11;
            rc_ss->retry[1].idx = (uint16_t)uVar5;
          }
          rc_ss->trial_status = '\x02';
          goto LAB_23063654;
        }
      }
    }
LAB_230636ee:
    rc_ss->trial_status = '\0';
  }
  else {
    if (rc_ss->trial_status == '\x03') {
      if ((rc_ss->info & 2) == 0) {
        rc_ss->retry[0].idx = rc_ss->retry[1].idx;
        rc_ss->retry[0].tp = rc_ss->retry[1].tp;
      }
      uVar3 = (rc_ss->max_tp_2_trial).idx;
      rc_ss->trial_status = '\0';
      rc_ss->retry[1].idx = uVar3;
      uVar11 = (rc_ss->max_tp_2_trial).tp;
      (rc_ss->max_tp_2_trial).tp = 0;
      rc_ss->retry[1].tp = uVar11;
      (rc_ss->max_tp_2_trial).idx = 0xff;
      goto LAB_23063654;
    }
  }
  if (iVar17 == 0) {
    return;
  }
LAB_23063654:
  sta_info_tab[uVar9].pol_tbl.upd_field = sta_info_tab[uVar9].pol_tbl.upd_field | 1;
  return;
}



void cfm_raw_send(void *env,uint32_t status)

{
  printf("send complete, status is %08lX\r\n");
  return;
}



int scanu_raw_send_req_handler
              (ke_msg_id_t msgid,scanu_raw_send_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  size_t __n;
  txl_frame_desc_tag *frame;
  tx_hw_desc *ptVar1;
  void *__src;
  
  printf("[FW] pkt address is %p, len is %lu\r\n",param->pkt,param->len);
  scanu_raw_send_cfm('\0',src_id);
  __src = param->pkt;
  __n = param->len;
  frame = txl_frame_get(0,0x100);
  if (frame != (txl_frame_desc_tag *)0x0) {
    memcpy((frame->txdesc).lmac.buffer + 1,__src,__n);
    (frame->txdesc).host.staid = -1;
    (frame->cfm).cfm_func = cfm_raw_send;
    ptVar1 = (frame->txdesc).lmac.hw_desc;
    (frame->txdesc).host.vif_idx = '\0';
    (frame->txdesc).umac.head_len = '\0';
    (frame->txdesc).umac.tail_len = '\0';
    *(txl_frame_desc_tag **)&(frame->cfm).env = frame;
    (ptVar1->thd).field_5 = (ptVar1->thd).field_4 + (__n - 1);
    (ptVar1->thd).frmlen = __n + 4;
    txl_frame_push_force(frame,'\x03');
  }
  return 0;
}



int scanu_join_req_handler
              (ke_msg_id_t msgid,scanu_start_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  vif_info_tab[param->vif_idx].bss_info.valid_flags = 0;
  scanu_env._362_2_ = 1;
  scanu_env.bssid.array._0_4_ = *(undefined4 *)(param->bssid).array;
  scanu_env.bssid.array[2] = *(uint16_t *)((param->bssid).array + 4);
  scanu_env.param = param;
  scanu_env.src_id = src_id;
  if (((param->bssid).array[0] & 1) != 0) {
    assert_err("!MAC_ADDR_GROUP(&param->bssid)","module",0xb6);
  }
  scanu_start();
  return 1;
}



int scanu_start_req_handler
              (ke_msg_id_t msgid,scanu_start_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  undefined2 in_register_0000202a;
  
  scanu_env._362_2_ = 0;
  scanu_env.bssid.array._0_4_ = *(undefined4 *)(param->bssid).array;
  scanu_env.bssid.array[2] = *(uint16_t *)((param->bssid).array + 4);
  scanu_env.param = param;
  scanu_env.src_id = src_id;
  scanu_start(CONCAT22(in_register_0000202a,msgid));
  return 1;
}



int rxu_mgt_ind_handler(ke_msg_id_t msgid,rxu_mgt_ind *param,ke_task_id_t dest_id,
                       ke_task_id_t src_id)

{
  int iVar1;
  
  iVar1 = scanu_frame_handler(param);
  return iVar1;
}



int scan_done_ind_handler(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  undefined2 in_register_0000202a;
  
  scanu_env.band = scanu_env.band + '\x01';
  scanu_scan_next(CONCAT22(in_register_0000202a,msgid));
  return 0;
}



int scan_start_cfm_handler
              (ke_msg_id_t msgid,scan_start_cfm *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  if (param->status != '\0') {
    scanu_confirm(param->status);
    return 0;
  }
  return 0;
}



int me_set_ps_disable_cfm_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  
  kVar1 = ke_state_get(6);
  if (((CONCAT31(extraout_var,kVar1) != 4) &&
      (kVar1 = ke_state_get(6), CONCAT31(extraout_var_00,kVar1) != 0)) &&
     (kVar1 = ke_state_get(6), CONCAT31(extraout_var_01,kVar1) != 8)) {
    assert_err(
               "(ke_state_get(TASK_SM) == SM_BSS_PARAM_SETTING) || (ke_state_get(TASK_SM) == SM_IDLE) || (ke_state_get(TASK_SM) == SM_DISCONNECTING)"
               ,"module",0x1db);
  }
  kVar1 = ke_state_get(6);
  if (CONCAT31(extraout_var_02,kVar1) == 4) {
    sm_send_next_bss_param();
  }
  return 0;
}



int mm_bss_param_setting_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined3 extraout_var;
  
  kVar1 = ke_state_get(6);
  if (CONCAT31(extraout_var,kVar1) != 4) {
    assert_err("ke_state_get(TASK_SM) == SM_BSS_PARAM_SETTING","module",0x1fa);
  }
  sm_send_next_bss_param();
  return 0;
}



int sm_rsp_timeout_ind_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  
  kVar1 = ke_state_get(6);
  if ((CONCAT31(extraout_var,kVar1) == 5) ||
     (kVar1 = ke_state_get(6), CONCAT31(extraout_var_00,kVar1) == 6)) {
    sm_connect_ind(0xb);
  }
  return 0;
}



int scanu_start_cfm_handler(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined3 extraout_var;
  mac_addr_conflict67 *pmStack24;
  mac_addr_conflict171 *bssid;
  scan_chan_tag *chan;
  
  pmStack24 = (mac_addr_conflict67 *)0x0;
  bssid = (mac_addr_conflict171 *)0x0;
  kVar1 = ke_state_get(6);
  if (CONCAT31(extraout_var,kVar1) != 1) {
    assert_err("ke_state_get(TASK_SM) == SM_SCANNING","module",0x10a);
  }
  sm_get_bss_params(&pmStack24,(scan_chan_tag **)&bssid);
  if ((pmStack24 == (mac_addr_conflict67 *)0x0) || ((scan_chan_tag *)bssid == (scan_chan_tag *)0x0))
  {
    sm_connect_ind(0xc);
  }
  else {
    sm_join_bss(pmStack24,(scan_chan_tag *)bssid,false);
  }
  return 0;
}



int mm_connection_loss_ind_handler
              (ke_msg_id_t msgid,mm_connection_loss_ind *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  int iVar1;
  ke_state_t kVar2;
  undefined3 extraout_var;
  uint uVar3;
  
  uVar3 = (uint)param->inst_nbr;
  kVar2 = ke_state_get(6);
  iVar1 = 2;
  if (CONCAT31(extraout_var,kVar2) == 0) {
    iVar1 = 0;
    if ((vif_info_tab[uVar3].type == '\0') && (vif_info_tab[uVar3].active != false)) {
      ke_state_set(6,8);
      sm_disconnect_process(vif_info_tab + uVar3,0x10);
    }
  }
  return iVar1;
}



int scanu_join_cfm_handler(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  sm_connect_req *psVar1;
  ke_state_t kVar2;
  uint8_t uVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  void *pvVar4;
  undefined uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint8_t auStack33 [4];
  u8_l chan_idx;
  
  psVar1 = sm_env.connect_param;
  kVar2 = ke_state_get(6);
  if (CONCAT31(extraout_var,kVar2) != 2) {
    assert_err("ke_state_get(TASK_SM) == SM_JOINING","module",0x134);
  }
  uVar8 = (uint)psVar1->vif_idx;
  if ((int)vif_info_tab[uVar8].bss_info.valid_flags < 0) {
    uVar3 = sm_add_chan_ctx(auStack33);
    if (CONCAT31(extraout_var_00,uVar3) == 0) {
      pvVar4 = ke_msg_alloc(10,0,6,0x20);
      chan_ctxt_link(psVar1->vif_idx,auStack33[0]);
      *(u8_l *)((int)pvVar4 + 0x11) = psVar1->vif_idx;
      memcpy((void *)((int)pvVar4 + 10),&vif_info_tab[uVar8].bss_info.bssid,6);
      *(undefined *)((int)pvVar4 + 0x12) = 0;
      if ((vif_info_tab[uVar8].bss_info.valid_flags & 2) != 0) {
        uVar6 = (uint)vif_info_tab[uVar8].bss_info.ht_cap.a_mpdu_param;
        uVar5 = 1;
        uVar7 = (int)uVar6 >> 2 & 7;
        if (2 < uVar7) {
          uVar5 = (undefined)(1 << (uVar7 - 3 & 0x1f));
        }
        *(undefined *)((int)pvVar4 + 0x10) = uVar5;
        *(short *)((int)pvVar4 + 8) = (short)(1 << (uVar6 & 3) + 0xd) + -1;
      }
      *(undefined4 *)((int)pvVar4 + 4) = 0;
      ke_msg_send(pvVar4);
      ke_state_set(6,3);
    }
    else {
      sm_connect_ind(0xd);
    }
    vif_info_tab[uVar8].flags = psVar1->flags;
    if ((psVar1->flags & 4) != 0) {
      vif_info_tab[uVar8].bss_info.valid_flags =
           vif_info_tab[uVar8].bss_info.valid_flags & 0xfffffff9;
    }
  }
  else {
    if (sm_env.join_passive == false) {
      sm_connect_ind(0xe);
    }
    else {
      sm_join_bss((mac_addr_conflict67 *)&vif_info_tab[uVar8].bss_info.bssid,
                  vif_info_tab[uVar8].bss_info.chan,true);
    }
  }
  return 0;
}



// WARNING: Variable defined which should be unmapped: chan

int sm_connect_req_handler
              (ke_msg_id_t msgid,sm_connect_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  int iVar1;
  ke_state_t kVar2;
  undefined3 extraout_var;
  undefined *puVar3;
  undefined3 extraout_var_00;
  undefined uVar4;
  uint uVar5;
  mac_addr_conflict67 *pmStack40;
  mac_addr_conflict171 *bssid;
  scan_chan_tag *chan;
  
  pmStack40 = (mac_addr_conflict67 *)0x0;
  bssid = (mac_addr_conflict171 *)0x0;
  uVar5 = (uint)param->vif_idx;
  kVar2 = ke_state_get(6);
  if (CONCAT31(extraout_var,kVar2) == 8) {
    return 2;
  }
  puVar3 = (undefined *)ke_msg_alloc(0x1801,src_id,dest_id,1);
  kVar2 = ke_state_get(6);
  if (CONCAT31(extraout_var_00,kVar2) == 0) {
    if ((vif_info_tab[uVar5].type == '\0') && (vif_info_tab[uVar5].active == false)) {
      if (param->auth_type != '\x02') {
        if (vif_info_tab[uVar5].u[4] != 0xff) {
          assert_err("vif->u.sta.ap_id == INVALID_STA_IDX","module",0x59);
        }
        if (vif_info_tab[uVar5].chan_ctxt != (chan_ctxt_tag *)0x0) {
          assert_err("vif->chan_ctxt == NULL","module",0x5a);
        }
      }
    }
    else {
      if (param->auth_type != '\x02') {
        iVar1 = 0;
        uVar4 = 9;
        goto LAB_23063cee;
      }
    }
    if (sm_env.connect_param != (sm_connect_req *)0x0) {
      assert_err("NULL == sm_env.connect_param","module",0x5d);
    }
    sm_env.connect_param = param;
    if (sm_env.connect_ind != (sm_connect_ind *)0x0) {
      assert_err("NULL == sm_env.connect_ind","module",0x61);
    }
    sm_env.connect_ind = (sm_connect_ind *)ke_msg_alloc(0x1802,src_id,dest_id,0x354);
    sm_env.exist_ssid_idx = -1;
    sm_env.ft_over_ds = false;
    printf("connecting using vif_idx %u\r\n",(uint)param->vif_idx);
    if (param->auth_type == '\x02') {
      sm_env.ft_over_ds = true;
      memcpy(&sm_env.ft_old_bssid,&vif_info_tab[param->vif_idx].bssid,6);
      ke_state_set(6,8);
      sm_disconnect_process(vif_info_tab + param->vif_idx,0);
    }
    else {
      if ((param->chan).freq == 0xffff) {
        sm_get_bss_params(&pmStack40,(scan_chan_tag **)&bssid);
      }
      else {
        pmStack40 = (mac_addr_conflict67 *)&param->bssid;
        bssid = (mac_addr_conflict171 *)&param->chan;
      }
      if ((pmStack40 == (mac_addr_conflict67 *)0x0) ||
         ((scan_chan_tag *)bssid == (scan_chan_tag *)0x0)) {
        sm_scan_bss(pmStack40,(scan_chan_tag *)bssid);
      }
      else {
        sm_join_bss(pmStack40,(scan_chan_tag *)bssid,false);
      }
    }
    iVar1 = 1;
    uVar4 = 0;
  }
  else {
    iVar1 = 0;
    uVar4 = 8;
  }
LAB_23063cee:
  *puVar3 = uVar4;
  ke_msg_send(puVar3);
  return iVar1;
}



int rxu_mgt_ind_handler(ke_msg_id_t msgid,rxu_mgt_ind *param,ke_task_id_t dest_id,
                       ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  int iVar2;
  ushort uVar3;
  
  uVar3 = param->framectrl & 0xfc;
  if (uVar3 == 0xb0) {
    kVar1 = ke_state_get(6);
    if (CONCAT31(extraout_var,kVar1) == 5) {
      sm_auth_handler(param);
    }
  }
  else {
    if ((uVar3 == 0x10) || (uVar3 == 0x30)) {
      kVar1 = ke_state_get(6);
      if (CONCAT31(extraout_var_00,kVar1) == 6) {
        sm_assoc_rsp_handler(param);
      }
    }
    else {
      if (((uVar3 == 0xc0) || (uVar3 == 0xa0)) &&
         (kVar1 = ke_state_get(6), CONCAT31(extraout_var_01,kVar1) == 0)) {
        iVar2 = sm_deauth_handler(param);
        return iVar2;
      }
    }
  }
  return 0;
}



int mm_set_vif_state_cfm_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  byte bVar1;
  sm_connect_req *psVar2;
  ke_state_t kVar3;
  undefined3 extraout_var;
  u8_l *puVar4;
  undefined *puVar5;
  uint8_t uVar6;
  uint uVar7;
  
  kVar3 = ke_state_get(6);
  psVar2 = sm_env.connect_param;
  if (CONCAT31(extraout_var,kVar3) == 7) {
    uVar7 = (uint)(sm_env.connect_param)->vif_idx;
    bVar1 = vif_info_tab[uVar7].u[4];
    puVar4 = (u8_l *)ke_msg_alloc(0x4b,0,6,6);
    *(bool_l *)(puVar4 + 4) = psVar2->dont_wait_bcmc;
    *(u16_l *)(puVar4 + 2) = psVar2->listen_interval;
    *puVar4 = psVar2->vif_idx;
    ke_msg_send();
    uVar6 = ((vif_info_tab[uVar7].flags & 1) == 0) + '\x01';
    sta_info_tab[bVar1].ctrl_port_state = uVar6;
    sta_info_tab[bVar1].ctrl_port_ethertype =
         psVar2->ctrl_port_ethertype >> 8 | psVar2->ctrl_port_ethertype << 8;
    if (uVar6 == '\x02') {
      puVar5 = (undefined *)ke_msg_alloc(0x1413,5,6,2);
      *puVar5 = 0;
      puVar5[1] = psVar2->vif_idx;
      ke_msg_send();
    }
    if ((*(uint *)&vif_info_tab[uVar7].bss_info.is_supplicant_enabled & 0x12800) == 0) {
      sm_connect_ind(0);
    }
  }
  return 0;
}



int me_set_active_cfm_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  mac_addr_conflict67 *pmStack24;
  mac_addr_conflict171 *bssid;
  scan_chan_tag *chan;
  
  kVar1 = ke_state_get(6);
  if ((CONCAT31(extraout_var,kVar1) != 4) &&
     (kVar1 = ke_state_get(6), CONCAT31(extraout_var_00,kVar1) != 8)) {
    assert_err(
               "(ke_state_get(TASK_SM) == SM_BSS_PARAM_SETTING) || (ke_state_get(TASK_SM) == SM_DISCONNECTING)"
               ,"module",0x216);
  }
  kVar1 = ke_state_get(6);
  if (CONCAT31(extraout_var_01,kVar1) == 8) {
    if (sm_env.ft_over_ds == false) {
      ke_state_set(6,0);
    }
    else {
      pmStack24 = (mac_addr_conflict67 *)0x0;
      bssid = (mac_addr_conflict171 *)0x0;
      sm_get_bss_params(&pmStack24,(scan_chan_tag **)&bssid);
      sm_join_bss(pmStack24,(scan_chan_tag *)bssid,false);
    }
  }
  else {
    if (sm_env.ft_over_ds == false) {
      sm_auth_send(1,(uint32_t *)0x0);
    }
    else {
      sm_assoc_req_send();
    }
  }
  return 0;
}



int mm_sta_add_cfm_handler
              (ke_msg_id_t msgid,mm_sta_add_cfm *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint uVar1;
  ke_state_t kVar2;
  undefined3 extraout_var;
  uint uVar3;
  uint uVar4;
  
  kVar2 = ke_state_get(6);
  if (CONCAT31(extraout_var,kVar2) != 3) {
    assert_err("ke_state_get(TASK_SM) == SM_STA_ADDING","module",0x19c);
  }
  if (param->status == '\0') {
    uVar4 = (uint)param->sta_idx;
    uVar1 = (uint)sta_info_tab[uVar4].inst_nbr;
    memcpy(&sta_info_tab[uVar4].info,&vif_info_tab[uVar1].bss_info.rate_set,0xd);
    uVar3 = vif_info_tab[uVar1].bss_info.valid_flags;
    if ((uVar3 & 1) != 0) {
      sta_info_tab[uVar4].info.capa_flags = sta_info_tab[uVar4].info.capa_flags | 1;
    }
    if ((uVar3 & 2) != 0) {
      sta_info_tab[uVar4].info.capa_flags = sta_info_tab[uVar4].info.capa_flags | 2;
      memcpy(&sta_info_tab[uVar4].info.ht_cap,&vif_info_tab[uVar1].bss_info,0x20);
      me_set_sta_ht_vht_param(sta_info_tab + uVar4,&vif_info_tab[uVar1].bss_info);
    }
    sm_set_bss_param();
  }
  else {
    sm_connect_ind(0xf);
  }
  return 0;
}



int sm_disconnect_req_handler
              (ke_msg_id_t msgid,sm_disconnect_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined3 extraout_var;
  int iVar2;
  
  kVar1 = ke_state_get(6);
  iVar2 = 2;
  if (CONCAT31(extraout_var,kVar1) == 0) {
    sm_disconnect(param->vif_idx,param->reason_code);
    ke_msg_send_basic(0x1804,0xd,6);
    iVar2 = 0;
  }
  return iVar2;
}



int apm_sta_connect_timeout_ind_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  u8_l sta_idx;
  sta_info_tag *psVar1;
  TickType_t TVar2;
  
  TVar2 = xTaskGetTickCount();
  psVar1 = sta_info_tab;
  sta_idx = '\0';
  do {
    if ((psVar1->time_last_seen != 0) && (30000 < (int)(TVar2 - psVar1->time_last_seen))) {
      apm_sta_fw_delete(sta_idx);
    }
    sta_idx = sta_idx + '\x01';
    psVar1 = psVar1 + 1;
  } while (sta_idx != '\f');
  ke_timer_set(0x1c0a,7,5000000);
  return 0;
}



int rxu_mgt_ind_handler(ke_msg_id_t msgid,rxu_mgt_ind *param,ke_task_id_t dest_id,
                       ke_task_id_t src_id)

{
  undefined4 uVar1;
  ushort uVar2;
  
  uVar2 = param->framectrl & 0xfc;
  if (uVar2 == 0x40) {
    apm_probe_req_handler();
  }
  else {
    if (uVar2 == 0xb0) {
      apm_auth_handler(param);
    }
    else {
      uVar1 = 0;
      if ((param->framectrl & 0xfc) != 0) {
        if (uVar2 != 0x20) {
          if (uVar2 == 0xc0) {
            apm_deauth_handler(param);
            return 0;
          }
          if (uVar2 == 0xa0) {
            apm_disassoc_handler(param);
            return 0;
          }
          if (uVar2 != 0x80) {
            return 0;
          }
          apm_beacon_handler(param);
          return 0;
        }
        uVar1 = 1;
      }
      apm_assoc_req_handler(uVar1);
    }
  }
  return 0;
}



int apm_sta_add_cfm_handler
              (ke_msg_id_t msgid,me_sta_add_cfm *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  if (uap_conn_info == (cm_ConnectionInfo_t *)0x0) {
    apm_sta_add(param->sta_idx);
  }
  else {
    uap_conn_info->staId = param->sta_idx;
    SendEAPOLMsgUsingBufDesc(uap_conn_info,(BufferDesc_t *)0x0);
  }
  return 0;
}



int apm_sta_del_req_handler
              (ke_msg_id_t msgid,apm_sta_del_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  undefined *puVar1;
  
  puVar1 = (undefined *)ke_msg_alloc(0x1c0c,src_id,dest_id,3);
  if ((vif_info_tab[param->vif_idx].type == '\x02') && (param->sta_idx < 0xd)) {
    apm_sta_remove(param->vif_idx,param->sta_idx);
    *puVar1 = 0;
  }
  else {
    *puVar1 = 0xff;
  }
  ke_msg_send(puVar1);
  return 0;
}


/*
Unable to decompile 'apm_stop_cac_req_handler'
Cause: Exception while decompiling 2306423a: Decompiler process died

*/


int apm_conf_max_sta_req_handler
              (ke_msg_id_t msgid,apm_conf_max_sta_req *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  apm_env.max_sta_supported = param->max_sta_supported;
  if (0xc < apm_env.max_sta_supported) {
    apm_env.max_sta_supported = 0xc;
  }
  ke_msg_send_basic(0x1c0e,src_id,dest_id);
  return 0;
}


/*
Unable to decompile 'apm_start_cac_req_handler'
Cause: Exception while decompiling 230642e0: Decompiler process died

*/


int me_set_ps_disable_cfm_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  
  kVar1 = ke_state_get(7);
  if ((CONCAT31(extraout_var,kVar1) != 1) &&
     (kVar1 = ke_state_get(7), CONCAT31(extraout_var_00,kVar1) != 0)) {
    assert_err(
               "(ke_state_get(TASK_APM) == APM_BSS_PARAM_SETTING) || (ke_state_get(TASK_APM) == APM_IDLE)"
               ,"module",0xee);
  }
  kVar1 = ke_state_get(7);
  if (CONCAT31(extraout_var_01,kVar1) == 1) {
    apm_send_next_bss_param();
  }
  return 0;
}



int mm_bss_param_setting_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined3 extraout_var;
  
  kVar1 = ke_state_get(7);
  if (CONCAT31(extraout_var,kVar1) != 1) {
    assert_err("ke_state_get(TASK_APM) == APM_BSS_PARAM_SETTING","module",0x110);
  }
  apm_send_next_bss_param();
  return 0;
}



int mm_bcn_change_cfm_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined3 extraout_var;
  
  kVar1 = ke_state_get(7);
  if (CONCAT31(extraout_var,kVar1) != 2) {
    assert_err("ke_state_get(TASK_APM) == APM_BCN_SETTING","module",0x156);
  }
  apm_start_cfm(0);
  return 0;
}



int apm_stop_req_handler
              (ke_msg_id_t msgid,apm_stop_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint uVar1;
  ke_state_t kVar2;
  undefined3 extraout_var;
  
  uVar1 = (uint)param->vif_idx;
  if ((vif_info_tab[uVar1].type == '\x02') && (vif_info_tab[uVar1].active != false)) {
    kVar2 = ke_state_get(7);
    if (CONCAT31(extraout_var,kVar2) != 0) {
      return 2;
    }
    if (apm_env.apm_emb_enabled != false) {
      apm_env.apm_emb_enabled = false;
    }
    apm_stop(vif_info_tab + uVar1);
    if (uap_conn_info != (cm_ConnectionInfo_t *)0x0) {
      RemoveAPKeyInfo(uap_conn_info);
      cm_DeleteConnection(uap_conn_info);
      uap_conn_info = (cm_ConnectionInfo_t *)0x0;
    }
  }
  ke_msg_send_basic(0x1c03,src_id,dest_id);
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int apm_start_req_handler
              (ke_msg_id_t msgid,apm_start_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint32_t uVar1;
  char "apm_start_req_handler" [22];
  ke_state_t kVar2;
  uint8_t uVar3;
  _Bool _Var4;
  uint16_t uVar5;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  scan_chan_tag *psVar6;
  undefined3 extraout_var_01;
  int iVar7;
  undefined *puVar8;
  uint uVar9;
  undefined uVar10;
  u8_l *ssid;
  uint8_t uStack51;
  int8_t iStack50;
  uint8_t auStack49 [2];
  u8_l chan_idx;
  s8_l pwr;
  u8_l idx;
  
  printf("[WF] received APM Start %s:%d\r\n","apm_start_req_handler",0x4c);
  uVar9 = (uint)param->vif_idx;
  uVar10 = 4;
  if (vif_info_tab[uVar9].type == '\x02') {
    kVar2 = ke_state_get(7);
    if (CONCAT31(extraout_var,kVar2) == 0) {
      if (vif_info_tab[uVar9].active == false) {
        if (vif_info_tab[uVar9].chan_ctxt != (chan_ctxt_tag *)0x0) {
          assert_err("vif->chan_ctxt == NULL","module",0x67);
        }
        apm_env.param = param;
        uVar3 = me_add_chan_ctx(&uStack51,&param->chan,param->center_freq1,param->center_freq2,
                                param->ch_width);
        uVar10 = 1;
        if (CONCAT31(extraout_var_00,uVar3) == 0) {
          psVar6 = me_freq_to_chan_ptr((param->chan).band,(param->chan).freq);
          vif_info_tab[uVar9].bss_info.chan = psVar6;
          psVar6->tx_power = (param->chan).tx_power;
          vif_info_tab[uVar9].bss_info.center_freq1 = (uint16_t)param->center_freq1;
          vif_info_tab[uVar9].bss_info.center_freq2 = (uint16_t)param->center_freq2;
          uVar3 = param->ch_width;
          if (uVar3 == '\x04') {
            uVar3 = '\x03';
          }
          vif_info_tab[uVar9].bss_info.bw = uVar3;
          uVar3 = param->ch_width;
          vif_info_tab[uVar9].bss_info.power_constraint = '\0';
          vif_info_tab[uVar9].bss_info.phy_bw = uVar3;
          chan_ctxt_link(param->vif_idx,uStack51);
          apm_env.apm_emb_enabled = param->apm_emb_enabled;
          apm_env.hidden_ssid = param->hidden_ssid;
          _Var4 = apm_embedded_enabled(vif_info_tab + uVar9);
          if (CONCAT31(extraout_var_01,_Var4) != 0) {
            me_get_basic_rates(&param->rate_set,(mac_rateset *)param);
            if (param->qos_supported != '\0') {
              vif_info_tab[uVar9].bss_info.valid_flags =
                   vif_info_tab[uVar9].bss_info.valid_flags | 1;
            }
            if (me_env.ht_supported != false) {
              vif_info_tab[uVar9].bss_info.valid_flags =
                   vif_info_tab[uVar9].bss_info.valid_flags | 2;
            }
            vif_info_tab[uVar9].bss_info.beacon_interval = param->bcn_int;
            vif_info_tab[uVar9].bss_info.beacon_period = (ushort)param->beacon_period;
            vif_info_tab[uVar9].bss_info.sec_type = param->ap_sec_type;
            memcpy(&vif_info_tab[uVar9].bss_info.ssid,&param->ssid,0x22);
            vif_info_tab[uVar9].bss_info.ssid.array[vif_info_tab[uVar9].bss_info.ssid.length] = '\0'
            ;
            *(undefined4 *)vif_info_tab[uVar9].bss_info.bssid.array =
                 *(undefined4 *)vif_info_tab[uVar9].mac_addr.array;
            vif_info_tab[uVar9].bss_info.bssid.array[2] = vif_info_tab[uVar9].mac_addr.array[2];
            memcpy(&vif_info_tab[uVar9].bss_info.rate_set,&param->rate_set,0xd);
            vif_info_tab[uVar9].txq_params[0] = _DAT_44b00200;
            vif_info_tab[uVar9].txq_params[1] = _DAT_44b00204;
            vif_info_tab[uVar9].txq_params[2] = _DAT_44b00208;
            uVar1 = _DAT_44b0020c;
            vif_info_tab[uVar9].bss_info.edca_param.qos_info = '\0';
            vif_info_tab[uVar9].txq_params[3] = uVar1;
            *(undefined4 *)&vif_info_tab[uVar9].bss_info.aid_bitmap = 0xffff0000;
            apm_env.bcn_buf = (uint8_t *)ke_malloc(0x14d);
            uVar5 = me_build_beacon((uint32_t)apm_env.bcn_buf,vif_info_tab[uVar9].index,
                                    &param->tim_oft,&param->tim_len,apm_env.hidden_ssid);
            param->bcn_len = uVar5;
            if (param->ap_sec_type == '\0') {
              uap_conn_info = (cm_ConnectionInfo_t *)0x0;
            }
            else {
              uap_conn_info =
                   cm_InitConnection('\x02','\0','\0',
                                     (IEEEtypes_MacAddr_t *)&vif_info_tab[uVar9].bss_info.bssid,
                                     (IEEEtypes_MacAddr_t *)0x0,'\0',(unkbyte0 *)0x0);
              ssid = vif_info_tab[uVar9].bss_info.ssid.array;
              ap_setpsk(uap_conn_info,(CHAR *)ssid,(CHAR *)param->phrase);
              cm_SetComData(uap_conn_info,(char *)ssid);
              uap_conn_info->instNbr = param->vif_idx;
              printf("%s:uap_conn_info->instNbr = %d\r\n",0x2307f464,(uint)uap_conn_info->instNbr);
              InitGroupKey(uap_conn_info);
            }
          }
          if ((param->chan).band == '\0') {
            uVar5 = me_legacy_rate_bitfield_build(&vif_info_tab[uVar9].bss_info.rate_set,true);
            if ((uVar5 & 0xf) == 0) {
              vif_info_tab[uVar9].bss_info.high_11b_rate = '\x01';
            }
            else {
              iVar7 = __clzsi2((uint)uVar5 & 0xf);
              vif_info_tab[uVar9].bss_info.high_11b_rate = '\x1f' - (char)iVar7;
            }
          }
          apm_set_bss_param();
          iStack50 = (vif_info_tab[uVar9].bss_info.chan)->tx_power;
          tpc_update_vif_tx_power(vif_info_tab + uVar9,&iStack50,auStack49);
          printf("[WF] return with other handler\r\n");
          return 1;
        }
      }
      else {
        uVar10 = 9;
      }
    }
    else {
      uVar10 = 8;
    }
  }
  printf("[WF] Sending APM CFM %s:%d\r\n",0x2307f464,0xcc);
  puVar8 = (undefined *)ke_msg_alloc(0x1c01,src_id,dest_id,4);
  *puVar8 = uVar10;
  puVar8[1] = param->vif_idx;
  ke_msg_send();
  return 0;
}



int me_set_active_cfm_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  
  kVar1 = ke_state_get(7);
  if ((CONCAT31(extraout_var,kVar1) != 1) &&
     (kVar1 = ke_state_get(7), CONCAT31(extraout_var_00,kVar1) != 0)) {
    assert_err(
               "(ke_state_get(TASK_APM) == APM_BSS_PARAM_SETTING) || (ke_state_get(TASK_APM) == APM_IDLE)"
               ,"module",0x12f);
  }
  kVar1 = ke_state_get(7);
  if (CONCAT31(extraout_var_01,kVar1) == 1) {
    if (apm_env.bss_config.first != (co_list_hdr *)0x0) {
      assert_err("co_list_is_empty(&apm_env.bss_config)","module",0x135);
    }
    apm_bcn_set();
  }
  return 0;
}



int hostapd_mgt_ind_handler
              (ke_msg_id_t msgid,rxu_mgt_ind *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ushort uVar1;
  
  uVar1 = param->framectrl & 0xfc;
  if ((uVar1 != 0x40) && (uVar1 != 0xb0)) {
    return 0;
  }
  ke_state_get(10);
  return 0;
}



void dump_cfg_entries(void)

{
  cfg_element_entry *pcVar1;
  char *pcVar2;
  char acStack64 [4];
  char strs [16];
  
  puts("================= CFG TASK =================\r\n");
  pcVar1 = cfg_entrys_mm;
  while (pcVar1 < &_fsymc_info_bloop) {
    printf("entry %p\r\n",pcVar1);
    printf("    task    : %lu\r\n",(blog_level_t *)pcVar1->task);
    printf("    element : %u\r\n",(uint)pcVar1->element);
    printf("    type    : %u\r\n",(uint)pcVar1->type);
    printf("    name    : %s\r\n",pcVar1->name);
    pcVar2 = cfg_api_element_dump(pcVar1->val,*(CFG_ELEMENT_TYPE *)&pcVar1->type,acStack64);
    printf("    type    : %s\r\n",pcVar2);
    printf("    val     : %s\r\n");
    puts("------------------------\r\n");
    pcVar1 = pcVar1 + 1;
  }
  puts("---------------------------------------------\r\n");
  return;
}



// WARNING: Variable defined which should be unmapped: val

int cfg_start_req_handler
              (ke_msg_id_t msgid,cfg_start_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  undefined2 in_register_0000202a;
  undefined *puVar1;
  int iVar2;
  undefined4 uStack20;
  uint32_t val [1];
  
  if (param->ops == 0) {
    iVar2 = utils_tlv_bl_unpack_auto
                      ((uint32_t *)(param + 5),param[4].ops,*(uint16_t *)&param[3].ops,&uStack20);
    printf("unpack ret is %d, result is %lu\r\n",iVar2,uStack20);
    cfg_api_element_set(param[1].ops,param[2].ops,param[3].ops,&uStack20,(void *)0x0);
  }
  else {
    if (2 < param->ops) {
      dump_cfg_entries(CONCAT22(in_register_0000202a,msgid));
    }
  }
  puVar1 = (undefined *)ke_msg_alloc(0x3001,src_id,dest_id,1);
  *puVar1 = 0;
  ke_msg_send();
  return 0;
}



char * cfg_api_element_dump(void *val,CFG_ELEMENT_TYPE type,char *strs)

{
  int iVar1;
  char *pcVar2;
  
  switch((uint)type - 1 & 0xff) {
  case 0:
    if (*(char *)val == '\0') {
      pcVar2 = "False";
    }
    else {
      pcVar2 = "True";
    }
    iVar1 = snprintf(strs,0xf,"%s",pcVar2);
    if (iVar1 < 0) {
      iVar1 = 0;
    }
    strs[iVar1] = '\0';
    pcVar2 = "Boolean";
    break;
  case 1:
    iVar1 = snprintf(strs,0xf,"%d",(int)*(char *)val);
    if (iVar1 < 0) {
      iVar1 = 0;
    }
    strs[iVar1] = '\0';
    pcVar2 = "SINT8";
    break;
  case 2:
    iVar1 = snprintf(strs,0xf,"%u",(uint)*(byte *)val);
    if (iVar1 < 0) {
      iVar1 = 0;
    }
    strs[iVar1] = '\0';
    pcVar2 = "UINT8";
    break;
  case 3:
    iVar1 = snprintf(strs,0xf,"%d",(int)*(short *)val);
    if (iVar1 < 0) {
      iVar1 = 0;
    }
    strs[iVar1] = '\0';
    pcVar2 = "SINT16";
    break;
  case 4:
    iVar1 = snprintf(strs,0xf,"%u",(uint)*(ushort *)val);
    if (iVar1 < 0) {
      iVar1 = 0;
    }
    strs[iVar1] = '\0';
    pcVar2 = "UINT16";
    break;
  case 5:
    iVar1 = snprintf(strs,0xf,"%ld",*(undefined4 *)val);
    if (iVar1 < 0) {
      iVar1 = 0;
    }
    strs[iVar1] = '\0';
    pcVar2 = "SINT32";
    break;
  case 6:
    iVar1 = snprintf(strs,0xf,"%lu",*(undefined4 *)val);
    if (iVar1 < 0) {
      iVar1 = 0;
    }
    strs[iVar1] = '\0';
    pcVar2 = "UINT32";
    break;
  case 7:
    iVar1 = snprintf(strs,0xf,"%lu",*(undefined4 *)val);
    if (iVar1 < 0) {
      iVar1 = 0;
    }
    strs[iVar1] = '\0';
    pcVar2 = "STRING";
    break;
  default:
    return (char *)0x0;
  }
  return pcVar2;
}



int cfg_api_element_general_set(cfg_element_entry *entry,void *arg1,void *arg2)

{
  undefined uVar1;
  undefined2 uVar2;
  uint uVar3;
  undefined4 *puVar4;
  
  printf("  updating element: %s\r\n",entry->name);
  uVar3 = (uint)entry->type - 1 & 0xffff;
  if (6 < uVar3) {
    return 0;
  }
  puVar4 = (undefined4 *)entry->val;
  switch(uVar3) {
  default:
    uVar1 = *(undefined *)arg1;
    break;
  case 1:
    uVar1 = *(undefined *)arg1;
    break;
  case 3:
    uVar2 = *(undefined2 *)arg1;
    goto LAB_23064c28;
  case 4:
    uVar2 = *(undefined2 *)arg1;
LAB_23064c28:
    *(undefined2 *)puVar4 = uVar2;
    return 0;
  case 5:
  case 6:
    *puVar4 = *(undefined4 *)arg1;
    return 0;
  }
  *(undefined *)puVar4 = uVar1;
  return 0;
}



int cfg_api_element_general_get(cfg_element_entry *entry,void *arg1,void *arg2)

{
  return 0;
}



int cfg_api_element_set(uint32_t task,uint32_t element,uint32_t type,void *arg1,void *arg2)

{
  cfg_element_entry *pcVar1;
  
  pcVar1 = cfg_entrys_mm;
  while (pcVar1 < &_fsymc_info_bloop) {
    if ((pcVar1->task == task) && ((uint)pcVar1->element == element)) {
      if ((uint)pcVar1->type == type) goto LAB_23064c90;
      printf("type %lu NOT matched on element: %lu %lu %u\r\n",type,task,element);
    }
    pcVar1 = pcVar1 + 1;
  }
  if (pcVar1 != (cfg_element_entry *)&_fsymc_info_bloop) {
LAB_23064c90:
    (*pcVar1->set)(pcVar1,arg1,arg2);
  }
  return 0;
}



uint32_t co_crc32(uint32_t addr,uint32_t len,uint32_t crc)

{
  uint32_t uVar1;
  byte *pbVar2;
  
  uVar1 = 0;
  while (uVar1 != len) {
    pbVar2 = (byte *)(uVar1 + addr);
    uVar1 = uVar1 + 1;
    crc = crc << 8 ^ crc_tab[crc >> 0x18 ^ (uint)*pbVar2];
  }
  return crc;
}



void dbg_init(void)

{
  memset(&dbg_env,0,8);
  dbg_env.filter_module = 0xffffffff;
  dbg_env.filter_severity = 2;
  return;
}



void dbg_test_print(char *fmt,...)

{
  byte bVar1;
  uint uVar2;
  byte *pbVar3;
  va_list args;
  
  if (dbg_env.filter_severity != 0) {
    pbVar3 = (byte *)(fmt + 2);
    do {
      bVar1 = *fmt;
      uVar2 = (uint)bVar1;
      if (-1 < (char)bVar1) {
        return;
      }
      if (bVar1 < 0x88) {
        if ((~dbg_env.filter_module >> (uVar2 - 0x80 & 0x1f) & 1) != 0) {
          return;
        }
      }
      else {
        if (5 < (uVar2 + 0x66 & 0xff)) {
          assert_err("DBG_SEV_MIN <= prefix && prefix < DBG_SEV_MAX","module",0x297);
        }
        if (dbg_env.filter_severity <= uVar2 - 0x9a) {
          return;
        }
      }
      fmt = (char *)((byte *)fmt + 1);
    } while (pbVar3 != (byte *)fmt);
  }
  return;
}



int dbg_get_sys_stat_req_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  undefined4 *puVar1;
  
  puVar1 = (undefined4 *)ke_msg_alloc(0x40a,src_id,dest_id,0xc);
  *puVar1 = 0;
  puVar1[1] = 0;
  puVar1[2] = 0;
  ke_msg_send();
  return 0;
}



int dbg_mem_write_req_handler
              (ke_msg_id_t msgid,dbg_mem_write_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint32_t **ppuVar1;
  uint32_t **ppuVar2;
  
  ppuVar1 = (uint32_t **)ke_msg_alloc(0x403,src_id,dest_id,8);
  *(uint32_t *)param->memaddr = param->memdata;
  ppuVar2 = (uint32_t **)param->memaddr;
  *(uint32_t ***)ppuVar1 = ppuVar2;
  ppuVar1[1] = *ppuVar2;
  ke_msg_send();
  return 0;
}



int dbg_mem_read_req_handler
              (ke_msg_id_t msgid,dbg_mem_read_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint32_t *puVar1;
  
  puVar1 = (uint32_t *)ke_msg_alloc(0x401,src_id,dest_id,8);
  puVar1[1] = *(uint32_t *)param->memaddr;
  *puVar1 = param->memaddr;
  ke_msg_send();
  return 0;
}



int dbg_set_sev_filter_req_handler
              (ke_msg_id_t msgid,dbg_set_sev_filter_req *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  dbg_env.filter_severity = param->sev_filter;
  ke_msg_send_basic(0x407,src_id,dest_id);
  return 0;
}



int dbg_set_mod_filter_req_handler
              (ke_msg_id_t msgid,dbg_set_mod_filter_req *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  dbg_env.filter_module = param->mod_filter;
  ke_msg_send_basic(0x405,src_id,dest_id);
  return 0;
}



// WARNING: Type propagation algorithm not settling

co_list_hdr *
ke_queue_extract(co_list *queue,anon_subr__Bool_co_list_hdr_ptr_uint32_t_conflict2 *func,
                uint32_t arg)

{
  co_list_hdr cVar1;
  co_list_hdr cVar2;
  _Bool _Var3;
  undefined3 extraout_var;
  co_list_hdr cVar4;
  
  cVar4 = (co_list_hdr)queue->first;
  cVar1 = (co_list_hdr)0x0;
  do {
    cVar2 = cVar1;
    cVar1 = cVar4;
    if (cVar1 == (co_list_hdr)0x0) {
      return (co_list_hdr *)0;
    }
    _Var3 = (*func)((co_list_hdr *)cVar1,arg);
    cVar4 = *(co_list_hdr *)cVar1;
  } while (CONCAT31(extraout_var,_Var3) == 0);
  if (cVar2 == (co_list_hdr)0x0) {
    *(co_list_hdr *)&queue->first = cVar4;
  }
  else {
    *(co_list_hdr *)cVar2 = cVar4;
  }
  if (*(int *)cVar1 == 0) {
    *(co_list_hdr *)&queue->last = cVar2;
  }
  else {
    *(undefined4 *)cVar1 = 0;
  }
  return (co_list_hdr *)cVar1;
}



void bl_aes_128(UINT8 *key,UINT8 *input,UINT8 *output)

{
  BL_AesEncrypt(key,'\x02',input,output);
  return;
}



void xor_128(UINT8 *a,UINT8 *b,UINT8 *out)

{
  byte *pbVar1;
  int iVar2;
  byte *pbVar3;
  byte *pbVar4;
  
  iVar2 = 0;
  do {
    pbVar1 = a + iVar2;
    pbVar4 = b + iVar2;
    pbVar3 = out + iVar2;
    iVar2 = iVar2 + 1;
    *pbVar3 = *pbVar1 ^ *pbVar4;
  } while (iVar2 != 0x10);
  return;
}



void leftshift_onebit(UINT8 *input,UINT8 *output)

{
  byte *pbVar1;
  int iVar2;
  byte bVar3;
  byte *pbVar4;
  
  bVar3 = 0;
  iVar2 = 0xf;
  do {
    pbVar1 = input + iVar2;
    pbVar4 = output + iVar2;
    iVar2 = iVar2 + -1;
    *pbVar4 = bVar3 | *pbVar1 << 1;
    bVar3 = *pbVar1 >> 7;
  } while (iVar2 != -1);
  return;
}



// WARNING: Variable defined which should be unmapped: tmp

void generate_subkey(UINT8 *key,UINT8 *K1,UINT8 *K2)

{
  UINT8 local_40 [4];
  UINT8 L [16];
  UINT8 Z [16];
  UINT8 tmp [16];
  
  memset(L + 0xc,0,0x10);
  bl_aes_128(key,L + 0xc,local_40);
  if ((char)local_40[0] < '\0') {
    leftshift_onebit(local_40,Z + 0xc);
    xor_128(Z + 0xc,"",K1);
  }
  else {
    leftshift_onebit(local_40,K1);
  }
  if ((char)*K1 < '\0') {
    leftshift_onebit(K1,Z + 0xc);
    xor_128(Z + 0xc,"",K2);
  }
  else {
    leftshift_onebit(K1,K2);
  }
  return;
}



void padding(UINT8 *lastb,UINT8 *pad,int length)

{
  int iVar1;
  
  iVar1 = 0;
  do {
    if (iVar1 < length) {
      pad[iVar1] = lastb[iVar1];
    }
    else {
      if (length == iVar1) {
        pad[length] = -0x80;
      }
      else {
        pad[iVar1] = '\0';
      }
    }
    iVar1 = iVar1 + 1;
  } while (iVar1 != 0x10);
  return;
}



void bl_aes_cmac(UINT8 *key,UINT8 *input,int length,UINT8 *mac)

{
  int iVar1;
  int iVar2;
  UINT8 *a;
  UINT8 *pUVar3;
  UINT8 local_80 [4];
  UINT8 X [16];
  UINT8 Y [16];
  UINT8 M_last [16];
  UINT8 padded [16];
  UINT8 K1 [16];
  UINT8 K2 [16];
  
  generate_subkey(key,padded + 0xc,K1 + 0xc);
  iVar1 = (length + 0xf) / 0x10;
  if (iVar1 == 0) {
    iVar1 = 1;
  }
  else {
    if ((length & 0xfU) == 0) {
      pUVar3 = padded;
      a = input + (iVar1 + -1) * 0x10;
      goto LAB_2306503c;
    }
  }
  padding(input + (iVar1 + -1) * 0x10,M_last + 0xc,length % 0x10);
  pUVar3 = K1;
  a = M_last + 0xc;
LAB_2306503c:
  xor_128(a,pUVar3 + 0xc,Y + 0xc);
  memset(local_80,0,0x10);
  iVar2 = 0;
  while (iVar2 < iVar1 + -1) {
    xor_128(local_80,input + iVar2 * 0x10,X + 0xc);
    bl_aes_128(key,X + 0xc,local_80);
    iVar2 = iVar2 + 1;
  }
  xor_128(local_80,Y + 0xc,X + 0xc);
  bl_aes_128(key,X + 0xc,local_80);
  iVar1 = 0;
  do {
    pUVar3 = local_80 + iVar1;
    a = mac + iVar1;
    iVar1 = iVar1 + 1;
    *a = *pUVar3;
  } while (iVar1 != 0x10);
  return;
}



int BL_AES_MEMCMP(UINT8 *dst,UINT8 *src,int len)

{
  int iVar1;
  int iVar2;
  
  iVar2 = 0;
  iVar1 = len;
  while (len != iVar2) {
    if (dst[iVar2] == src[iVar2]) {
      iVar1 = iVar1 + -1;
    }
    iVar2 = iVar2 + 1;
  }
  return -(uint)(iVar1 != 0);
}



void BL_AES_MEMSET(UINT8 *dst,UINT8 val,int size)

{
  UINT8 *pUVar1;
  
  pUVar1 = dst;
  while (pUVar1 != dst + size) {
    *pUVar1 = val;
    pUVar1 = pUVar1 + 1;
  }
  return;
}



void BL_AES_MEMCPY(UINT8 *dst,UINT8 *src,int size)

{
  UINT8 *pUVar1;
  UINT8 *pUVar2;
  int iVar3;
  
  if (dst < src) {
    iVar3 = 0;
    while (iVar3 != size) {
      pUVar1 = src + iVar3;
      pUVar2 = dst + iVar3;
      iVar3 = iVar3 + 1;
      *pUVar2 = *pUVar1;
    }
    return;
  }
  while (size = size + -1, size != -1) {
    dst[size] = src[size];
  }
  return;
}



int BL_AesEncrypt(UINT8 *kek,UINT8 kekLen,UINT8 *data,UINT8 *ret)

{
  undefined3 in_register_0000202d;
  undefined auStack416 [4];
  UINT8 pBuf [400];
  
  rijndael_set_key((rijndael_ctx *)auStack416,kek,CONCAT31(in_register_0000202d,kekLen) << 6,1);
  rijndael_encrypt((rijndael_ctx *)auStack416,data,ret);
  return 0;
}



int BL_AesWrap(UINT8 *kek,UINT8 kekLen,UINT32 n,UINT8 *plain,UINT8 *keyIv,UINT8 *cipher)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  UINT8 aUStack72 [4];
  UINT8 a [8];
  UINT8 b [16];
  
  if (n != 0) {
    BL_AES_MEMSET(a + 4,'\0',0x10);
    if (keyIv == (UINT8 *)0x0) {
      keyIv = BL_DEFAULT_IV;
    }
    BL_AES_MEMCPY(aUStack72,keyIv,8);
    BL_AES_MEMCPY(cipher + 8,plain,n << 3);
    uVar2 = 0;
    iVar4 = 6;
    do {
      iVar1 = 1;
      while (iVar3 = iVar1 * 8, iVar1 != n + 1) {
        BL_AES_MEMCPY(a + 4,aUStack72,8);
        BL_AES_MEMCPY(b + 4,cipher + iVar3,8);
        BL_AesEncrypt(kek,kekLen,a + 4,a + 4);
        BL_AES_MEMCPY(aUStack72,a + 4,8);
        a[3] = (char)uVar2 + (char)iVar1 ^ a[3];
        iVar1 = iVar1 + 1;
        BL_AES_MEMCPY(cipher + iVar3,b + 4,8);
      }
      iVar4 = iVar4 + -1;
      uVar2 = uVar2 + (n & 0xff) & 0xff;
    } while (iVar4 != 0);
    BL_AES_MEMCPY(cipher,aUStack72,8);
    return 0;
  }
  return -1;
}



int BL_AesUnWrap(UINT8 *kek,UINT8 kekLen,UINT32 n,UINT8 *cipher,UINT8 *keyIv,UINT8 *plain)

{
  uint uVar1;
  undefined3 in_register_0000202d;
  UINT32 UVar2;
  UINT8 *src;
  int iVar3;
  UINT8 aUStack472 [4];
  UINT8 a [8];
  UINT8 b [16];
  UINT8 pBuf [400];
  
  if (n != 0) {
    BL_AES_MEMSET(aUStack472,'\0',8);
    BL_AES_MEMSET(a + 4,'\0',0x10);
    BL_AES_MEMCPY(aUStack472,cipher,8);
    uVar1 = (n & 0xff) * 5;
    BL_AES_MEMCPY(plain,cipher + 8,n * 8);
    rijndael_set_key((rijndael_ctx *)(b + 0xc),kek,CONCAT31(in_register_0000202d,kekLen) << 6,0);
    iVar3 = 6;
    do {
      UVar2 = n;
      src = plain + n * 8 + -8;
      while (0 < (int)UVar2) {
        BL_AES_MEMCPY(a + 4,aUStack472,8);
        b[3] = (char)(uVar1 & 0xff) + (char)UVar2 ^ b[3];
        BL_AES_MEMCPY(b + 4,src,8);
        rijndael_decrypt((rijndael_ctx *)(b + 0xc),a + 4,a + 4);
        BL_AES_MEMCPY(aUStack472,a + 4,8);
        BL_AES_MEMCPY(src,b + 4,8);
        src = src + -8;
        UVar2 = UVar2 - 1;
      }
      uVar1 = (uVar1 & 0xff) - (n & 0xff);
      iVar3 = iVar3 + -1;
    } while (iVar3 != 0);
    if (keyIv == (UINT8 *)0x0) {
      keyIv = BL_DEFAULT_IV;
    }
    iVar3 = BL_AES_MEMCMP(keyIv,aUStack472,8);
    return -(uint)(iVar3 != 0);
  }
  return -1;
}



// WARNING: Variable defined which should be unmapped: pBuf

void Bl_hmac_md5(UINT8 *text_data,int text_len,UINT8 *key,int key_len,void *digest)

{
  ulong *puVar1;
  Bl_MD5_CTX *pBVar2;
  Bl_MD5_CTX *context;
  Bl_MD5_CTX *context_00;
  undefined auStack584 [4];
  Bl_MD5_CTX tctx;
  uchar pBuf [400];
  
  if (0x40 < key_len) {
    wpa_MD5Init((Bl_MD5_CTX *)auStack584);
    wpa_MD5Update((Bl_MD5_CTX *)auStack584,key,key_len);
    wpa_MD5Final(pBuf + 0x94,(Bl_MD5_CTX *)auStack584);
    key_len = 0x10;
    key = pBuf + 0x94;
  }
  memset(tctx.buffer + 0x3c,0,0x40);
  memcpy(tctx.buffer + 0x3c,key,key_len);
  context_00 = (Bl_MD5_CTX *)(pBuf + 0x3c);
  pBVar2 = (Bl_MD5_CTX *)(tctx.buffer + 0x3c);
  do {
    puVar1 = pBVar2->state;
    pBVar2->state[0] = pBVar2->state[0] ^ 0x36363636;
    pBVar2 = (Bl_MD5_CTX *)(puVar1 + 1);
  } while ((Bl_MD5_CTX *)(puVar1 + 1) != context_00);
  wpa_MD5Init(context_00);
  wpa_MD5Update(context_00,tctx.buffer + 0x3c,0x40);
  wpa_MD5Update(context_00,text_data,text_len);
  wpa_MD5Final((uchar *)digest,context_00);
  memset(tctx.buffer + 0x3c,0,0x40);
  memcpy(tctx.buffer + 0x3c,key,key_len);
  pBVar2 = (Bl_MD5_CTX *)(tctx.buffer + 0x3c);
  do {
    context = (Bl_MD5_CTX *)(pBVar2->state + 1);
    pBVar2->state[0] = pBVar2->state[0] ^ 0x5c5c5c5c;
    pBVar2 = context;
  } while (context != context_00);
  wpa_MD5Init(context);
  wpa_MD5Update(context,tctx.buffer + 0x3c,0x40);
  wpa_MD5Update(context,(UINT8 *)digest,0x10);
  wpa_MD5Final((uchar *)digest,context);
  return;
}



void Bl_hmac_sha1(uchar **ppText,int *pTextLen,int textNum,uchar *key,int key_len,uchar *output,
                 int outputLen)

{
  uint *puVar1;
  uint *__src;
  uchar **ppuVar2;
  int iVar3;
  uint *Message_Digest;
  uint local_1c0;
  uchar pBuf [400];
  
  if (0x40 < key_len) {
    Bl_SHA1Init((Bl_SHA1_CTX *)(pBuf + 0x50));
    Bl_SHA1Update((Bl_SHA1_CTX *)(pBuf + 0x50),key,key_len);
    Bl_SHA1Final((Bl_SHA1_CTX *)(pBuf + 0x50),key);
    key_len = 0x14;
  }
  memset(&local_1c0,0,0x40);
  memcpy(&local_1c0,key,key_len);
  Message_Digest = (uint *)(pBuf + 0x3c);
  puVar1 = &local_1c0;
  do {
    __src = puVar1 + 2;
    *puVar1 = *puVar1 ^ 0x36363636;
    puVar1[1] = puVar1[1] ^ 0x36363636;
    puVar1 = __src;
  } while (__src != Message_Digest);
  Bl_SHA1Init((Bl_SHA1_CTX *)(pBuf + 0x50));
  Bl_SHA1Update((Bl_SHA1_CTX *)(pBuf + 0x50),(UINT8 *)&local_1c0,0x40);
  iVar3 = 0;
  while (iVar3 < textNum) {
    puVar1 = (uint *)(pTextLen + iVar3);
    ppuVar2 = ppText + iVar3;
    iVar3 = iVar3 + 1;
    Bl_SHA1Update((Bl_SHA1_CTX *)(pBuf + 0x50),*ppuVar2,*puVar1);
  }
  Bl_SHA1Final((Bl_SHA1_CTX *)(pBuf + 0x50),(UINT8 *)Message_Digest);
  memset(&local_1c0,0,0x40);
  memcpy(&local_1c0,key,key_len);
  puVar1 = &local_1c0;
  do {
    __src = puVar1 + 2;
    *puVar1 = *puVar1 ^ 0x5c5c5c5c;
    puVar1[1] = puVar1[1] ^ 0x5c5c5c5c;
    puVar1 = __src;
  } while (__src != Message_Digest);
  Bl_SHA1Init((Bl_SHA1_CTX *)(pBuf + 0x50));
  Bl_SHA1Update((Bl_SHA1_CTX *)(pBuf + 0x50),(UINT8 *)&local_1c0,0x40);
  Bl_SHA1Update((Bl_SHA1_CTX *)(pBuf + 0x50),(UINT8 *)__src,0x14);
  Bl_SHA1Final((Bl_SHA1_CTX *)(pBuf + 0x50),(UINT8 *)__src);
  memcpy(output,__src,outputLen);
  return;
}



void Bl_PRF(uchar *key,int key_len,uchar *prefix,int prefix_len,uchar *data,int data_len,
           uchar *output,int len)

{
  char cVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int local_b0;
  int total_len;
  uchar *pText;
  UINT8 prf_input [120];
  
  total_len = (int)&pText;
  memset(&pText,0,0x78);
  if (prefix == (uchar *)0x0) {
    memcpy(&pText,data,data_len);
    local_b0 = data_len;
  }
  else {
    memcpy(&pText,prefix,prefix_len);
    local_b0 = prefix_len + 1 + data_len;
    *(undefined *)((int)&pText + prefix_len) = 0;
    memcpy((void *)((int)&pText + prefix_len + 1),data,data_len);
  }
  *(undefined *)((int)&pText + local_b0) = 0;
  iVar4 = 0;
  iVar3 = 0;
  local_b0 = local_b0 + 1;
  while( true ) {
    iVar2 = (iVar3 * -0x14 + len) * 0x1000000;
    cVar1 = (char)((uint)iVar2 >> 0x18);
    if ((len + 0x13) / 0x14 <= iVar3) break;
    if (0x14 < iVar2 >> 0x18) {
      cVar1 = '\x14';
    }
    Bl_hmac_sha1((uchar **)&total_len,&local_b0,1,key,key_len,output + iVar4,(int)cVar1);
    iVar4 = iVar4 + (int)cVar1;
    iVar3 = iVar3 + 1;
    *(char *)((int)&total_len + local_b0 + 3) = *(char *)((int)&total_len + local_b0 + 3) + '\x01';
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void set_psk(char *pSsid,UINT8 ssidLen,char *phrase)

{
  char "set_psk" [8];
  size_t sVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"set_psk");
  memset(&nohostParams,0xff,0x43);
  sVar1 = strlen(phrase);
  pmkCacheSetPassphrase((UINT8 *)pSsid,ssidLen,(UINT8 *)phrase,(UINT8)sVar1);
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x230828a4);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void remove_psk(char *pSsid,UINT8 ssidLen)

{
  char "remove_psk" [11];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"remove_psk");
  pmkCacheDeletePSK((UINT8 *)pSsid,ssidLen);
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x2307fc84);
  return;
}



void wpa_MD5Transform(UINT32 *state,ulong *block)

{
  ulong uVar1;
  ulong uVar2;
  ulong uVar3;
  ulong uVar4;
  ulong uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  ulong uVar13;
  ulong uVar14;
  ulong uVar15;
  ulong uVar16;
  ulong uVar17;
  ulong uVar18;
  ulong uVar19;
  uint uVar20;
  uint uVar21;
  ulong uVar22;
  ulong uVar23;
  ulong uVar24;
  ulong uVar25;
  
  uVar19 = *block;
  uVar20 = state[2];
  uVar21 = state[3];
  uVar12 = state[1];
  uVar5 = block[1];
  uVar8 = ((uVar20 ^ uVar21) & uVar12 ^ uVar21) + *state + uVar19 + 0xd76aa478;
  uVar9 = (uVar8 >> 0x19 | uVar8 * 0x80) + uVar12;
  uVar22 = block[2];
  uVar8 = ((uVar12 ^ uVar20) & uVar9 ^ uVar20) + uVar5 + 0xe8c7b756 + uVar21;
  uVar6 = (uVar8 >> 0x14 | uVar8 * 0x1000) + uVar9;
  uVar8 = ((uVar12 ^ uVar9) & uVar6 ^ uVar12) + uVar22 + 0x242070db + uVar20;
  uVar14 = block[3];
  uVar8 = (uVar8 * 0x20000 | uVar8 >> 0xf) + uVar6;
  uVar7 = ((uVar9 ^ uVar6) & uVar8 ^ uVar9) + uVar14 + 0xc1bdceee + uVar12;
  uVar24 = block[4];
  uVar7 = (uVar7 * 0x400000 | uVar7 >> 10) + uVar8;
  uVar9 = ((uVar6 ^ uVar8) & uVar7 ^ uVar6) + uVar24 + 0xf57c0faf + uVar9;
  uVar16 = block[5];
  uVar9 = (uVar9 >> 0x19 | uVar9 * 0x80) + uVar7;
  uVar6 = ((uVar8 ^ uVar7) & uVar9 ^ uVar8) + uVar16 + 0x4787c62a + uVar6;
  uVar1 = block[6];
  uVar6 = (uVar6 >> 0x14 | uVar6 * 0x1000) + uVar9;
  uVar8 = ((uVar7 ^ uVar9) & uVar6 ^ uVar7) + uVar1 + 0xa8304613 + uVar8;
  uVar18 = block[7];
  uVar8 = (uVar8 * 0x20000 | uVar8 >> 0xf) + uVar6;
  uVar7 = ((uVar9 ^ uVar6) & uVar8 ^ uVar9) + uVar18 + 0xfd469501 + uVar7;
  uVar4 = block[8];
  uVar7 = (uVar7 * 0x400000 | uVar7 >> 10) + uVar8;
  uVar9 = ((uVar6 ^ uVar8) & uVar7 ^ uVar6) + uVar4 + 0x698098d8 + uVar9;
  uVar2 = block[9];
  uVar9 = (uVar9 >> 0x19 | uVar9 * 0x80) + uVar7;
  uVar6 = ((uVar8 ^ uVar7) & uVar9 ^ uVar8) + uVar2 + 0x8b44f7af + uVar6;
  uVar13 = block[10];
  uVar6 = (uVar6 >> 0x14 | uVar6 * 0x1000) + uVar9;
  uVar8 = ((uVar7 ^ uVar9) & uVar6 ^ uVar7) + (uVar13 - 0xa44f) + uVar8;
  uVar23 = block[0xb];
  uVar8 = (uVar8 * 0x20000 | uVar8 >> 0xf) + uVar6;
  uVar7 = ((uVar9 ^ uVar6) & uVar8 ^ uVar9) + uVar23 + 0x895cd7be + uVar7;
  uVar15 = block[0xc];
  uVar7 = (uVar7 * 0x400000 | uVar7 >> 10) + uVar8;
  uVar9 = ((uVar6 ^ uVar8) & uVar7 ^ uVar6) + uVar15 + 0x6b901122 + uVar9;
  uVar25 = block[0xd];
  uVar9 = (uVar9 >> 0x19 | uVar9 * 0x80) + uVar7;
  uVar6 = ((uVar8 ^ uVar7) & uVar9 ^ uVar8) + uVar25 + 0xfd987193 + uVar6;
  uVar17 = block[0xe];
  uVar6 = (uVar6 >> 0x14 | uVar6 * 0x1000) + uVar9;
  uVar8 = ((uVar7 ^ uVar9) & uVar6 ^ uVar7) + uVar17 + 0xa679438e + uVar8;
  uVar3 = block[0xf];
  uVar8 = (uVar8 * 0x20000 | uVar8 >> 0xf) + uVar6;
  uVar7 = ((uVar9 ^ uVar6) & uVar8 ^ uVar9) + uVar3 + 0x49b40821 + uVar7;
  uVar7 = (uVar7 * 0x400000 | uVar7 >> 10) + uVar8;
  uVar9 = ((uVar8 ^ uVar7) & uVar6 ^ uVar8) + uVar5 + 0xf61e2562 + uVar9;
  uVar9 = (uVar9 >> 0x1b | uVar9 * 0x20) + uVar7;
  uVar6 = ((uVar7 ^ uVar9) & uVar8 ^ uVar7) + uVar1 + 0xc040b340 + uVar6;
  uVar6 = (uVar6 >> 0x17 | uVar6 * 0x200) + uVar9;
  uVar8 = ((uVar9 ^ uVar6) & uVar7 ^ uVar9) + uVar23 + 0x265e5a51 + uVar8;
  uVar8 = (uVar8 >> 0x12 | uVar8 * 0x4000) + uVar6;
  uVar7 = ((uVar6 ^ uVar8) & uVar9 ^ uVar6) + uVar19 + 0xe9b6c7aa + uVar7;
  uVar7 = (uVar7 * 0x100000 | uVar7 >> 0xc) + uVar8;
  uVar9 = ((uVar8 ^ uVar7) & uVar6 ^ uVar8) + uVar16 + 0xd62f105d + uVar9;
  uVar9 = (uVar9 >> 0x1b | uVar9 * 0x20) + uVar7;
  uVar6 = ((uVar7 ^ uVar9) & uVar8 ^ uVar7) + uVar13 + 0x2441453 + uVar6;
  uVar6 = (uVar6 >> 0x17 | uVar6 * 0x200) + uVar9;
  uVar8 = ((uVar9 ^ uVar6) & uVar7 ^ uVar9) + uVar3 + 0xd8a1e681 + uVar8;
  uVar8 = (uVar8 >> 0x12 | uVar8 * 0x4000) + uVar6;
  uVar7 = ((uVar6 ^ uVar8) & uVar9 ^ uVar6) + uVar24 + 0xe7d3fbc8 + uVar7;
  uVar7 = (uVar7 * 0x100000 | uVar7 >> 0xc) + uVar8;
  uVar9 = ((uVar8 ^ uVar7) & uVar6 ^ uVar8) + uVar2 + 0x21e1cde6 + uVar9;
  uVar9 = (uVar9 >> 0x1b | uVar9 * 0x20) + uVar7;
  uVar6 = ((uVar7 ^ uVar9) & uVar8 ^ uVar7) + uVar17 + 0xc33707d6 + uVar6;
  uVar6 = (uVar6 >> 0x17 | uVar6 * 0x200) + uVar9;
  uVar8 = ((uVar9 ^ uVar6) & uVar7 ^ uVar9) + uVar14 + 0xf4d50d87 + uVar8;
  uVar8 = (uVar8 >> 0x12 | uVar8 * 0x4000) + uVar6;
  uVar7 = ((uVar6 ^ uVar8) & uVar9 ^ uVar6) + uVar4 + 0x455a14ed + uVar7;
  uVar7 = (uVar7 * 0x100000 | uVar7 >> 0xc) + uVar8;
  uVar9 = ((uVar8 ^ uVar7) & uVar6 ^ uVar8) + uVar25 + 0xa9e3e905 + uVar9;
  uVar9 = (uVar9 >> 0x1b | uVar9 * 0x20) + uVar7;
  uVar6 = ((uVar7 ^ uVar9) & uVar8 ^ uVar7) + uVar22 + 0xfcefa3f8 + uVar6;
  uVar6 = (uVar6 >> 0x17 | uVar6 * 0x200) + uVar9;
  uVar8 = ((uVar9 ^ uVar6) & uVar7 ^ uVar9) + uVar8 + uVar18 + 0x676f02d9;
  uVar8 = (uVar8 >> 0x12 | uVar8 * 0x4000) + uVar6;
  uVar7 = (uVar9 & (uVar6 ^ uVar8) ^ uVar6) + uVar15 + 0x8d2a4c8a + uVar7;
  uVar7 = (uVar7 * 0x100000 | uVar7 >> 0xc) + uVar8;
  uVar9 = uVar9 + (uVar16 - 0x5c6be) + (uVar6 ^ uVar8 ^ uVar7);
  uVar10 = (uVar9 >> 0x1c | uVar9 * 0x10) + uVar7;
  uVar6 = (uVar8 ^ uVar7 ^ uVar10) + uVar4 + 0x8771f681 + uVar6;
  uVar6 = (uVar6 >> 0x15 | uVar6 * 0x800) + uVar10;
  uVar8 = (uVar7 ^ uVar10 ^ uVar6) + uVar23 + 0x6d9d6122 + uVar8;
  uVar8 = (uVar8 >> 0x10 | uVar8 * 0x10000) + uVar6;
  uVar7 = (uVar10 ^ uVar6 ^ uVar8) + uVar17 + 0xfde5380c + uVar7;
  uVar9 = (uVar7 * 0x800000 | uVar7 >> 9) + uVar8;
  uVar7 = (uVar6 ^ uVar8 ^ uVar9) + uVar5 + 0xa4beea44 + uVar10;
  uVar10 = (uVar7 >> 0x1c | uVar7 * 0x10) + uVar9;
  uVar6 = (uVar8 ^ uVar9 ^ uVar10) + uVar6 + uVar24 + 0x4bdecfa9;
  uVar6 = (uVar6 >> 0x15 | uVar6 * 0x800) + uVar10;
  uVar8 = (uVar9 ^ uVar10 ^ uVar6) + uVar8 + uVar18 + 0xf6bb4b60;
  uVar7 = (uVar8 >> 0x10 | uVar8 * 0x10000) + uVar6;
  uVar8 = (uVar10 ^ uVar6 ^ uVar7) + uVar13 + 0xbebfbc70 + uVar9;
  uVar9 = (uVar8 * 0x800000 | uVar8 >> 9) + uVar7;
  uVar8 = (uVar6 ^ uVar7 ^ uVar9) + uVar10 + uVar25 + 0x289b7ec6;
  uVar8 = (uVar8 >> 0x1c | uVar8 * 0x10) + uVar9;
  uVar6 = (uVar7 ^ uVar9 ^ uVar8) + uVar6 + uVar19 + 0xeaa127fa;
  uVar10 = (uVar6 >> 0x15 | uVar6 * 0x800) + uVar8;
  uVar6 = (uVar9 ^ uVar8 ^ uVar10) + uVar14 + 0xd4ef3085 + uVar7;
  uVar7 = (uVar6 >> 0x10 | uVar6 * 0x10000) + uVar10;
  uVar6 = (uVar8 ^ uVar10 ^ uVar7) + uVar9 + uVar1 + 0x4881d05;
  uVar6 = (uVar6 * 0x800000 | uVar6 >> 9) + uVar7;
  uVar8 = (uVar10 ^ uVar7 ^ uVar6) + uVar8 + uVar2 + 0xd9d4d039;
  uVar9 = (uVar8 >> 0x1c | uVar8 * 0x10) + uVar6;
  uVar8 = (uVar7 ^ uVar6 ^ uVar9) + uVar10 + uVar15 + 0xe6db99e5;
  uVar8 = (uVar8 >> 0x15 | uVar8 * 0x800) + uVar9;
  uVar7 = (uVar6 ^ uVar9 ^ uVar8) + uVar3 + 0x1fa27cf8 + uVar7;
  uVar7 = (uVar7 >> 0x10 | uVar7 * 0x10000) + uVar8;
  uVar6 = (uVar9 ^ uVar8 ^ uVar7) + uVar6 + uVar22 + 0xc4ac5665;
  uVar10 = (uVar6 * 0x800000 | uVar6 >> 9) + uVar7;
  uVar6 = ((~uVar8 | uVar10) ^ uVar7) + uVar19 + 0xf4292244 + uVar9;
  uVar9 = (uVar6 >> 0x1a | uVar6 * 0x40) + uVar10;
  uVar8 = ((~uVar7 | uVar9) ^ uVar10) + uVar18 + 0x432aff97 + uVar8;
  uVar8 = (uVar8 >> 0x16 | uVar8 * 0x400) + uVar9;
  uVar6 = ((~uVar10 | uVar8) ^ uVar9) + uVar17 + 0xab9423a7 + uVar7;
  uVar7 = (uVar6 >> 0x11 | uVar6 * 0x8000) + uVar8;
  uVar6 = ((~uVar9 | uVar7) ^ uVar8) + uVar10 + uVar16 + 0xfc93a039;
  uVar6 = (uVar6 * 0x200000 | uVar6 >> 0xb) + uVar7;
  uVar9 = ((~uVar8 | uVar6) ^ uVar7) + uVar9 + uVar15 + 0x655b59c3;
  uVar11 = (uVar9 >> 0x1a | uVar9 * 0x40) + uVar6;
  uVar8 = ((~uVar7 | uVar11) ^ uVar6) + uVar8 + uVar14 + 0x8f0ccc92;
  uVar10 = (uVar8 >> 0x16 | uVar8 * 0x400) + uVar11;
  uVar8 = ((~uVar6 | uVar10) ^ uVar11) + (uVar13 - 0x100b83) + uVar7;
  uVar7 = (uVar8 >> 0x11 | uVar8 * 0x8000) + uVar10;
  uVar8 = ((~uVar11 | uVar7) ^ uVar10) + uVar5 + 0x85845dd1 + uVar6;
  uVar9 = (uVar8 * 0x200000 | uVar8 >> 0xb) + uVar7;
  uVar8 = ((~uVar10 | uVar9) ^ uVar7) + uVar11 + uVar4 + 0x6fa87e4f;
  uVar6 = (uVar8 >> 0x1a | uVar8 * 0x40) + uVar9;
  uVar8 = ((~uVar7 | uVar6) ^ uVar9) + uVar10 + uVar3 + 0xfe2ce6e0;
  uVar8 = (uVar8 >> 0x16 | uVar8 * 0x400) + uVar6;
  uVar7 = ((~uVar9 | uVar8) ^ uVar6) + uVar7 + uVar1 + 0xa3014314;
  uVar7 = (uVar7 >> 0x11 | uVar7 * 0x8000) + uVar8;
  uVar9 = ((~uVar6 | uVar7) ^ uVar8) + uVar25 + 0x4e0811a1 + uVar9;
  uVar9 = (uVar9 * 0x200000 | uVar9 >> 0xb) + uVar7;
  uVar6 = ((~uVar8 | uVar9) ^ uVar7) + uVar6 + uVar24 + 0xf7537e82;
  uVar11 = (uVar6 >> 0x1a | uVar6 * 0x40) + uVar9;
  uVar8 = ((~uVar7 | uVar11) ^ uVar9) + uVar8 + uVar23 + 0xbd3af235;
  uVar10 = (uVar8 >> 0x16 | uVar8 * 0x400) + uVar11;
  uVar8 = ((~uVar9 | uVar10) ^ uVar11) + uVar7 + uVar22 + 0x2ad7d2bb;
  uVar6 = (uVar8 >> 0x11 | uVar8 * 0x8000) + uVar10;
  uVar8 = ((~uVar11 | uVar6) ^ uVar10) + uVar2 + 0xeb86d391 + uVar9;
  *state = uVar11 + *state;
  state[2] = uVar20 + uVar6;
  state[3] = uVar21 + uVar10;
  state[1] = uVar12 + uVar6 + (uVar8 * 0x200000 | uVar8 >> 0xb);
  memset(block,0,0x40);
  return;
}



void wpa_MD5Init(Bl_MD5_CTX *context)

{
  context->state[0] = 0x67452301;
  context->state[1] = 0xefcdab89;
  context->state[2] = 0x98badcfe;
  context->count[1] = 0;
  context->count[0] = 0;
  context->state[3] = 0x10325476;
  return;
}



void wpa_MD5Update(Bl_MD5_CTX *context,UINT8 *input,UINT32 inputLen)

{
  uint uVar1;
  uint __n;
  
  uVar1 = context->count[0];
  __n = uVar1 + inputLen * 8;
  context->count[0] = __n;
  uVar1 = uVar1 >> 3 & 0x3f;
  if (__n < inputLen * 8) {
    context->count[1] = context->count[1] + 1;
  }
  context->count[1] = (inputLen >> 0x1d) + context->count[1];
  __n = 0x40 - uVar1;
  if (inputLen < __n) {
    __n = 0;
  }
  else {
    memcpy(context->buffer + uVar1,input,__n);
    wpa_MD5Transform((UINT32 *)context,(ulong *)context->buffer);
    while (__n + 0x3f < inputLen) {
      memcpy(context->scratch,input + __n,0x40);
      wpa_MD5Transform((UINT32 *)context,context->scratch);
      __n = __n + 0x40;
    }
    uVar1 = 0;
  }
  memcpy(context->buffer + uVar1,input + __n,inputLen - __n);
  return;
}



void wpa_MD5Final(uchar *digest,Bl_MD5_CTX *context)

{
  uint uVar1;
  int iVar2;
  UINT8 aUStack24 [4];
  uchar bits [8];
  
  memcpy(aUStack24,context->count,8);
  uVar1 = context->count[0] >> 3 & 0x3f;
  if (uVar1 < 0x38) {
    iVar2 = 0x38;
  }
  else {
    iVar2 = 0x78;
  }
  wpa_MD5Update(context,PADDING,iVar2 - uVar1);
  wpa_MD5Update(context,aUStack24,8);
  memcpy(digest,context,0x10);
  memset(context,0,0x98);
  return;
}



int rijndaelKeySetupEnc(u32_conflict *rk,u8 *cipherKey,int keyBits)

{
  uint uVar1;
  uint uVar2;
  u32_conflict *puVar3;
  u32_conflict *puVar4;
  
  *rk = (uint)*cipherKey << 0x18 ^ (uint)cipherKey[1] << 0x10 ^ (uint)cipherKey[3] ^
        (uint)cipherKey[2] << 8;
  rk[1] = (uint)cipherKey[4] << 0x18 ^ (uint)cipherKey[5] << 0x10 ^ (uint)cipherKey[7] ^
          (uint)cipherKey[6] << 8;
  rk[2] = (uint)cipherKey[8] << 0x18 ^ (uint)cipherKey[9] << 0x10 ^ (uint)cipherKey[0xb] ^
          (uint)cipherKey[10] << 8;
  rk[3] = (uint)cipherKey[0xc] << 0x18 ^ (uint)cipherKey[0xd] << 0x10 ^ (uint)cipherKey[0xf] ^
          (uint)cipherKey[0xe] << 8;
  if (keyBits == 0x80) {
    puVar3 = rcon;
    puVar4 = rk + 0x24;
    while( true ) {
      uVar1 = *puVar3;
      uVar2 = rk[3];
      puVar3 = puVar3 + 1;
      uVar1 = *rk ^ uVar1 ^ (uint)Te4[uVar2 >> 0x18] ^ (uint)Te4[uVar2 & 0xff] << 8 ^
              (uint)Te4[uVar2 >> 0x10 & 0xff] << 0x18 ^ (uint)Te4[uVar2 >> 8 & 0xff] << 0x10;
      rk[4] = uVar1;
      uVar1 = uVar1 ^ rk[1];
      rk[5] = uVar1;
      uVar1 = uVar1 ^ rk[2];
      rk[6] = uVar1;
      rk[7] = uVar1 ^ uVar2;
      if (rk == puVar4) break;
      rk = rk + 4;
    }
    return 10;
  }
  return 0;
}



void rijndael_set_key(rijndael_ctx *ctx,u8 *key,int bits,int encrypt)

{
  int iVar1;
  u32_conflict *rk;
  int iVar2;
  u32_conflict uVar3;
  u32_conflict *puVar4;
  uint uVar5;
  int *piVar6;
  
  rk = ctx->key;
  iVar2 = rijndaelKeySetupEnc(rk,key,bits);
  ctx->Nr = iVar2;
  if (encrypt == 0) {
    ctx->decrypt = 1;
    if (iVar2 == 0) {
      iVar2 = rijndaelKeySetupEnc(rk,key,bits);
    }
    puVar4 = rk;
    piVar6 = &ctx->decrypt + iVar2 * 4;
    while (encrypt < iVar2 * 4 - encrypt) {
      uVar3 = *puVar4;
      encrypt = encrypt + 4;
      *puVar4 = piVar6[2];
      piVar6[2] = uVar3;
      uVar3 = puVar4[1];
      puVar4[1] = piVar6[3];
      piVar6[3] = uVar3;
      uVar3 = puVar4[2];
      puVar4[2] = piVar6[4];
      piVar6[4] = uVar3;
      uVar3 = puVar4[3];
      puVar4[3] = piVar6[5];
      piVar6[5] = uVar3;
      puVar4 = puVar4 + 4;
      piVar6 = piVar6 + -4;
    }
    iVar1 = 1;
    while (iVar1 < iVar2) {
      puVar4 = rk + 4;
      uVar5 = *puVar4;
      iVar1 = iVar1 + 1;
      *puVar4 = Td2[Te4[uVar5 >> 8 & 0xff]] ^
                Td0[Te4[uVar5 >> 0x18]] ^ Td3[Te4[uVar5 & 0xff]] ^ Td1[Te4[uVar5 >> 0x10 & 0xff]];
      uVar5 = rk[5];
      rk[5] = Td2[Te4[uVar5 >> 8 & 0xff]] ^
              Td0[Te4[uVar5 >> 0x18]] ^ Td3[Te4[uVar5 & 0xff]] ^ Td1[Te4[uVar5 >> 0x10 & 0xff]];
      uVar5 = rk[6];
      rk[6] = Td2[Te4[uVar5 >> 8 & 0xff]] ^
              Td0[Te4[uVar5 >> 0x18]] ^ Td3[Te4[uVar5 & 0xff]] ^ Td1[Te4[uVar5 >> 0x10 & 0xff]];
      uVar5 = rk[7];
      rk[7] = Td2[Te4[uVar5 >> 8 & 0xff]] ^
              Td0[Te4[uVar5 >> 0x18]] ^ Td3[Te4[uVar5 & 0xff]] ^ Td1[Te4[uVar5 >> 0x10 & 0xff]];
      rk = puVar4;
    }
  }
  else {
    ctx->decrypt = 0;
  }
  return;
}



void rijndael_decrypt(rijndael_ctx *ctx,u8 *src,u8 *dst)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  u32_conflict *puVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  int iVar13;
  uint uVar14;
  int iVar15;
  uint uVar16;
  uint uVar17;
  uint uVar18;
  uint uVar19;
  
  uVar10 = (uint)*src << 0x18 ^ (uint)src[1] << 0x10 ^ (uint)src[3] ^ (uint)src[2] << 8 ^
           ctx->key[0];
  uVar16 = (uint)src[4] << 0x18 ^ (uint)src[5] << 0x10 ^ (uint)src[7] ^ (uint)src[6] << 8 ^
           ctx->key[1];
  uVar14 = (uint)src[8] << 0x18 ^ (uint)src[9] << 0x10 ^ (uint)src[0xb] ^ (uint)src[10] << 8 ^
           ctx->key[2];
  uVar11 = (uint)src[0xc] << 0x18 ^ (uint)src[0xd] << 0x10 ^ (uint)src[0xf] ^ (uint)src[0xe] << 8 ^
           ctx->key[3];
  iVar13 = ctx->Nr >> 1;
  puVar4 = ctx->key;
  iVar15 = iVar13;
  while( true ) {
    uVar5 = Td0[uVar10 >> 0x18] ^ Td3[uVar16 & 0xff] ^ puVar4[4] ^
            *(uint *)((int)Td1 + (uVar11 >> 0xe & 0x3fc)) ^
            *(uint *)((int)Td2 + (uVar14 >> 6 & 0x3fc));
    iVar15 = iVar15 + -1;
    uVar17 = uVar5 >> 0x10 & 0xff;
    uVar6 = Td0[uVar16 >> 0x18] ^ Td3[uVar14 & 0xff] ^ puVar4[5] ^
            *(uint *)((int)Td1 + (uVar10 >> 0xe & 0x3fc)) ^
            *(uint *)((int)Td2 + (uVar11 >> 6 & 0x3fc));
    uVar8 = Td0[uVar14 >> 0x18] ^ Td3[uVar11 & 0xff] ^ puVar4[6] ^
            *(uint *)((int)Td1 + (uVar16 >> 0xe & 0x3fc)) ^
            *(uint *)((int)Td2 + (uVar10 >> 6 & 0x3fc));
    uVar12 = Td0[uVar11 >> 0x18] ^ Td3[uVar10 & 0xff] ^ puVar4[7] ^
             *(uint *)((int)Td1 + (uVar14 >> 0xe & 0x3fc)) ^
             *(uint *)((int)Td2 + (uVar16 >> 6 & 0x3fc));
    uVar19 = uVar12 >> 0x10 & 0xff;
    uVar18 = uVar8 >> 8 & 0xff;
    uVar10 = puVar4[8];
    uVar16 = uVar12 >> 8 & 0xff;
    uVar11 = uVar6 >> 0x10 & 0xff;
    uVar14 = uVar5 >> 8 & 0xff;
    uVar9 = uVar8 >> 0x10 & 0xff;
    uVar7 = uVar6 >> 8 & 0xff;
    if (iVar15 == 0) break;
    uVar10 = Td0[uVar5 >> 0x18] ^ Td3[uVar6 & 0xff] ^ uVar10 ^ Td1[uVar19] ^ Td2[uVar18];
    uVar16 = Td0[uVar6 >> 0x18] ^ Td3[uVar8 & 0xff] ^ puVar4[9] ^ Td1[uVar17] ^ Td2[uVar16];
    uVar14 = Td0[uVar8 >> 0x18] ^ Td3[uVar12 & 0xff] ^ puVar4[10] ^ Td1[uVar11] ^ Td2[uVar14];
    uVar11 = Td0[uVar12 >> 0x18] ^ Td3[uVar5 & 0xff] ^ puVar4[0xb] ^ Td1[uVar9] ^ Td2[uVar7];
    puVar4 = puVar4 + 8;
  }
  puVar4 = ctx->key + iVar13 * 8;
  uVar10 = (uint)Td4[uVar5 >> 0x18] << 0x18 ^ (uint)Td4[uVar19] << 0x10 ^ (uint)Td4[uVar6 & 0xff] ^
           (uint)Td4[uVar18] << 8 ^ uVar10;
  *dst = (u8)(uVar10 >> 0x18);
  dst[1] = (u8)(uVar10 >> 0x10);
  dst[2] = (u8)(uVar10 >> 8);
  bVar1 = Td4[uVar17];
  bVar2 = Td4[uVar6 >> 0x18];
  bVar3 = Td4[uVar8 & 0xff];
  dst[3] = (u8)uVar10;
  uVar10 = (uint)bVar2 << 0x18 ^ (uint)bVar1 << 0x10 ^ (uint)bVar3 ^ (uint)Td4[uVar16] << 8 ^
           puVar4[1];
  dst[4] = (u8)(uVar10 >> 0x18);
  dst[5] = (u8)(uVar10 >> 0x10);
  dst[6] = (u8)(uVar10 >> 8);
  dst[7] = (u8)uVar10;
  bVar1 = Td4[uVar12 >> 0x18];
  uVar10 = (uint)Td4[uVar8 >> 0x18] << 0x18 ^ (uint)Td4[uVar11] << 0x10 ^ (uint)Td4[uVar12 & 0xff] ^
           (uint)Td4[uVar14] << 8 ^ puVar4[2];
  dst[8] = (u8)(uVar10 >> 0x18);
  dst[9] = (u8)(uVar10 >> 0x10);
  dst[0xb] = (u8)uVar10;
  bVar2 = Td4[uVar9];
  dst[10] = (u8)(uVar10 >> 8);
  uVar10 = (uint)bVar1 << 0x18 ^ (uint)bVar2 << 0x10 ^ (uint)Td4[uVar5 & 0xff] ^
           (uint)Td4[uVar7] << 8 ^ puVar4[3];
  dst[0xc] = (u8)(uVar10 >> 0x18);
  dst[0xd] = (u8)(uVar10 >> 0x10);
  dst[0xe] = (u8)(uVar10 >> 8);
  dst[0xf] = (u8)uVar10;
  return;
}



void rijndael_encrypt(rijndael_ctx *ctx,u8 *src,u8 *dst)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  u32_conflict *puVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  int iVar13;
  uint uVar14;
  int iVar15;
  uint uVar16;
  uint uVar17;
  uint uVar18;
  uint uVar19;
  
  uVar10 = (uint)*src << 0x18 ^ (uint)src[1] << 0x10 ^ (uint)src[3] ^ (uint)src[2] << 8 ^
           ctx->key[0];
  uVar16 = (uint)src[4] << 0x18 ^ (uint)src[5] << 0x10 ^ (uint)src[7] ^ (uint)src[6] << 8 ^
           ctx->key[1];
  uVar14 = (uint)src[8] << 0x18 ^ (uint)src[9] << 0x10 ^ (uint)src[0xb] ^ (uint)src[10] << 8 ^
           ctx->key[2];
  uVar11 = (uint)src[0xc] << 0x18 ^ (uint)src[0xd] << 0x10 ^ (uint)src[0xf] ^ (uint)src[0xe] << 8 ^
           ctx->key[3];
  iVar13 = ctx->Nr >> 1;
  puVar4 = ctx->key;
  iVar15 = iVar13;
  while( true ) {
    uVar8 = Te0[uVar10 >> 0x18] ^ Te3[uVar11 & 0xff] ^ puVar4[4] ^
            *(uint *)((int)Te1 + (uVar16 >> 0xe & 0x3fc)) ^
            *(uint *)((int)Te2 + (uVar14 >> 6 & 0x3fc));
    iVar15 = iVar15 + -1;
    uVar6 = Te0[uVar16 >> 0x18] ^ Te3[uVar10 & 0xff] ^ puVar4[5] ^
            *(uint *)((int)Te1 + (uVar14 >> 0xe & 0x3fc)) ^
            *(uint *)((int)Te2 + (uVar11 >> 6 & 0x3fc));
    uVar5 = Te0[uVar14 >> 0x18] ^ Te3[uVar16 & 0xff] ^ puVar4[6] ^
            *(uint *)((int)Te1 + (uVar11 >> 0xe & 0x3fc)) ^
            *(uint *)((int)Te2 + (uVar10 >> 6 & 0x3fc));
    uVar12 = Te0[uVar11 >> 0x18] ^ Te3[uVar14 & 0xff] ^ puVar4[7] ^
             *(uint *)((int)Te1 + (uVar10 >> 0xe & 0x3fc)) ^
             *(uint *)((int)Te2 + (uVar16 >> 6 & 0x3fc));
    uVar19 = uVar6 >> 0x10 & 0xff;
    uVar18 = uVar5 >> 8 & 0xff;
    uVar10 = puVar4[8];
    uVar17 = uVar5 >> 0x10 & 0xff;
    uVar16 = uVar12 >> 8 & 0xff;
    uVar11 = uVar12 >> 0x10 & 0xff;
    uVar14 = uVar8 >> 8 & 0xff;
    uVar9 = uVar8 >> 0x10 & 0xff;
    uVar7 = uVar6 >> 8 & 0xff;
    if (iVar15 == 0) break;
    uVar10 = Te0[uVar8 >> 0x18] ^ Te3[uVar12 & 0xff] ^ uVar10 ^ Te1[uVar19] ^ Te2[uVar18];
    uVar16 = Te0[uVar6 >> 0x18] ^ Te3[uVar8 & 0xff] ^ puVar4[9] ^ Te1[uVar17] ^ Te2[uVar16];
    uVar14 = Te0[uVar5 >> 0x18] ^ Te3[uVar6 & 0xff] ^ puVar4[10] ^ Te1[uVar11] ^ Te2[uVar14];
    uVar11 = Te0[uVar12 >> 0x18] ^ Te3[uVar5 & 0xff] ^ puVar4[0xb] ^ Te1[uVar9] ^ Te2[uVar7];
    puVar4 = puVar4 + 8;
  }
  puVar4 = ctx->key + iVar13 * 8;
  uVar10 = (uint)Te4[uVar8 >> 0x18] << 0x18 ^ (uint)Te4[uVar19] << 0x10 ^ (uint)Te4[uVar12 & 0xff] ^
           (uint)Te4[uVar18] << 8 ^ uVar10;
  *dst = (u8)(uVar10 >> 0x18);
  dst[1] = (u8)(uVar10 >> 0x10);
  dst[2] = (u8)(uVar10 >> 8);
  bVar1 = Te4[uVar17];
  bVar2 = Te4[uVar6 >> 0x18];
  bVar3 = Te4[uVar8 & 0xff];
  dst[3] = (u8)uVar10;
  uVar10 = (uint)bVar2 << 0x18 ^ (uint)bVar1 << 0x10 ^ (uint)bVar3 ^ (uint)Te4[uVar16] << 8 ^
           puVar4[1];
  dst[4] = (u8)(uVar10 >> 0x18);
  dst[5] = (u8)(uVar10 >> 0x10);
  dst[6] = (u8)(uVar10 >> 8);
  dst[7] = (u8)uVar10;
  bVar1 = Te4[uVar12 >> 0x18];
  uVar10 = (uint)Te4[uVar5 >> 0x18] << 0x18 ^ (uint)Te4[uVar11] << 0x10 ^ (uint)Te4[uVar6 & 0xff] ^
           (uint)Te4[uVar14] << 8 ^ puVar4[2];
  dst[8] = (u8)(uVar10 >> 0x18);
  dst[9] = (u8)(uVar10 >> 0x10);
  dst[0xb] = (u8)uVar10;
  bVar2 = Te4[uVar9];
  dst[10] = (u8)(uVar10 >> 8);
  uVar10 = (uint)bVar1 << 0x18 ^ (uint)bVar2 << 0x10 ^ (uint)Te4[uVar5 & 0xff] ^
           (uint)Te4[uVar7] << 8 ^ puVar4[3];
  dst[0xc] = (u8)(uVar10 >> 0x18);
  dst[0xd] = (u8)(uVar10 >> 0x10);
  dst[0xe] = (u8)(uVar10 >> 8);
  dst[0xf] = (u8)uVar10;
  return;
}



void Bl_SHA1ProcessMessageBlock(Bl_SHA1_CTX *context)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  UINT32 *pUVar4;
  uint uVar5;
  UINT32 *pUVar6;
  UINT32 *pUVar7;
  uint uVar8;
  UINT32 UVar9;
  uint uVar10;
  uint uVar11;
  UINT32 UVar12;
  uint uVar13;
  uint uVar14;
  uint uVar15;
  UINT32 UVar16;
  
  pUVar4 = context->Scratch;
  pUVar6 = pUVar4;
  do {
    pUVar7 = pUVar6 + 1;
    *pUVar6 = (uint)*(byte *)(pUVar6 + 0x10) << 0x18 | (uint)*(byte *)((int)pUVar6 + 0x41) << 0x10 |
              (uint)*(byte *)((int)pUVar6 + 0x42) << 8 | (uint)*(byte *)((int)pUVar6 + 0x43);
    pUVar6 = pUVar7;
  } while ((UINT32 *)context->Message_Block != pUVar7);
  uVar11 = 0;
  uVar8 = context->Intermediate_Hash[2];
  uVar10 = context->Intermediate_Hash[0];
  UVar12 = context->Intermediate_Hash[1];
  uVar2 = context->Intermediate_Hash[3];
  UVar16 = context->Intermediate_Hash[4];
  do {
    uVar13 = uVar2;
    uVar3 = uVar10;
    uVar2 = uVar8;
    if ((uVar11 & 0x30) == 0) {
      UVar9 = context->Scratch[uVar11];
    }
    else {
      uVar8 = pUVar4[uVar11 + 0xd & 0xf] ^ pUVar4[uVar11 + 8 & 0xf] ^ pUVar4[uVar11 & 0xf] ^
              pUVar4[uVar11 + 2 & 0xf];
      UVar9 = uVar8 >> 0x1f | uVar8 << 1;
      pUVar4[uVar11 & 0xf] = UVar9;
    }
    uVar11 = uVar11 + 1;
    uVar10 = UVar9 + ((uVar2 ^ uVar13) & UVar12 ^ uVar13) +
                     (uVar3 << 5 | uVar3 >> 0x1b) + 0x5a827999 + UVar16;
    uVar8 = UVar12 << 0x1e | UVar12 >> 2;
    UVar12 = uVar3;
    UVar16 = uVar13;
  } while (uVar11 != 0x14);
  do {
    uVar14 = uVar10;
    uVar1 = uVar2;
    uVar2 = uVar11 + 0xd;
    uVar10 = uVar11 + 8;
    uVar15 = uVar11 & 0xf;
    uVar5 = uVar11 + 2;
    uVar11 = uVar11 + 1;
    uVar2 = pUVar4[uVar2 & 0xf] ^ pUVar4[uVar10 & 0xf] ^ pUVar4[uVar15] ^ pUVar4[uVar5 & 0xf];
    uVar2 = uVar2 >> 0x1f | uVar2 << 1;
    pUVar4[uVar15] = uVar2;
    uVar10 = (uVar3 ^ uVar8 ^ uVar1) + (uVar14 << 5 | uVar14 >> 0x1b) + 0x6ed9eba1 + uVar2 + uVar13;
    uVar5 = uVar3 << 0x1e | uVar3 >> 2;
    uVar2 = uVar8;
    uVar3 = uVar14;
    uVar8 = uVar5;
    uVar13 = uVar1;
  } while (uVar11 != 0x28);
  do {
    uVar8 = uVar10;
    uVar13 = uVar11 + 0xd;
    uVar10 = uVar11 + 8;
    uVar15 = uVar11 & 0xf;
    uVar3 = uVar11 + 2;
    uVar11 = uVar11 + 1;
    uVar10 = pUVar4[uVar13 & 0xf] ^ pUVar4[uVar10 & 0xf] ^ pUVar4[uVar15] ^ pUVar4[uVar3 & 0xf];
    uVar10 = uVar10 >> 0x1f | uVar10 << 1;
    pUVar4[uVar15] = uVar10;
    uVar10 = ((uVar5 | uVar2) & uVar14 | uVar5 & uVar2) + (uVar8 << 5 | uVar8 >> 0x1b) + 0x8f1bbcdc
             + uVar10 + uVar1;
    uVar13 = uVar14 << 0x1e | uVar14 >> 2;
    uVar1 = uVar2;
    uVar14 = uVar8;
    uVar3 = uVar2;
    uVar2 = uVar5;
    uVar5 = uVar13;
  } while (uVar11 != 0x3c);
  do {
    uVar15 = uVar13;
    uVar5 = uVar2;
    uVar1 = uVar10;
    uVar10 = uVar11 + 0xd;
    uVar13 = uVar11 + 8;
    uVar2 = uVar11 & 0xf;
    uVar14 = uVar11 + 2;
    uVar11 = uVar11 + 1;
    uVar10 = pUVar4[uVar10 & 0xf] ^ pUVar4[uVar13 & 0xf] ^ pUVar4[uVar2] ^ pUVar4[uVar14 & 0xf];
    uVar10 = uVar10 >> 0x1f | uVar10 << 1;
    pUVar4[uVar2] = uVar10;
    uVar10 = uVar10 + (uVar8 ^ uVar15 ^ uVar5) + (uVar1 << 5 | uVar1 >> 0x1b) + 0xca62c1d6 + uVar3;
    uVar13 = uVar8 << 0x1e | uVar8 >> 2;
    uVar8 = uVar1;
    uVar3 = uVar5;
    uVar2 = uVar15;
  } while (uVar11 != 0x50);
  context->Message_Block_Index = 0;
  UVar12 = context->Intermediate_Hash[1];
  context->Intermediate_Hash[0] = uVar10 + context->Intermediate_Hash[0];
  context->Intermediate_Hash[1] = uVar1 + UVar12;
  context->Intermediate_Hash[2] = uVar13 + context->Intermediate_Hash[2];
  context->Intermediate_Hash[3] = uVar15 + context->Intermediate_Hash[3];
  context->Intermediate_Hash[4] = uVar5 + context->Intermediate_Hash[4];
  return;
}



int Bl_SHA1Init(Bl_SHA1_CTX *context)

{
  if (context != (Bl_SHA1_CTX *)0x0) {
    context->Intermediate_Hash[0] = 0x67452301;
    context->Intermediate_Hash[1] = 0xefcdab89;
    context->Intermediate_Hash[2] = 0x98badcfe;
    context->Intermediate_Hash[3] = 0x10325476;
    context->Length_Low = 0;
    context->Length_High = 0;
    context->Intermediate_Hash[4] = 0xc3d2e1f0;
    *(undefined4 *)&context->Message_Block_Index = 0;
    return 0;
  }
  return 1;
}



int Bl_SHA1Final(Bl_SHA1_CTX *context,UINT8 *Message_Digest)

{
  short sVar1;
  ushort uVar2;
  int iVar3;
  uint uVar4;
  UINT32 UVar5;
  SINT16 *pSVar6;
  
  uVar4 = 1;
  if (((context != (Bl_SHA1_CTX *)0x0) && (Message_Digest != (UINT8 *)0x0)) &&
     (uVar4 = (uint)context->Corrupted, context->Corrupted == 0)) {
    if (context->Computed == '\0') {
      iVar3 = (int)context->Message_Block_Index;
      context->Message_Block_Index = (SINT16)((uint)((iVar3 + 1) * 0x10000) >> 0x10);
      context->Message_Block[iVar3] = -0x80;
      if (iVar3 < 0x38) {
        while( true ) {
          sVar1 = context->Message_Block_Index;
          if (0x37 < (int)sVar1) break;
          context->Message_Block_Index = sVar1 + 1;
          context->Message_Block[(int)sVar1] = '\0';
        }
      }
      else {
        while( true ) {
          sVar1 = context->Message_Block_Index;
          if (0x3f < (int)sVar1) break;
          context->Message_Block_Index = sVar1 + 1;
          context->Message_Block[(int)sVar1] = '\0';
        }
        Bl_SHA1ProcessMessageBlock(context);
        while( true ) {
          sVar1 = context->Message_Block_Index;
          if (0x37 < (int)sVar1) break;
          context->Message_Block_Index = sVar1 + 1;
          context->Message_Block[(int)sVar1] = '\0';
        }
      }
      UVar5 = context->Length_High;
      *(ushort *)(context->Message_Block + 0x3a) =
           *(ushort *)&context->Length_High << 8 | *(ushort *)&context->Length_High >> 8;
      context->Message_Block[0x39] = (UINT8)(UVar5 >> 0x10);
      uVar2 = *(ushort *)&context->Length_Low;
      context->Message_Block[0x38] = (UINT8)(UVar5 >> 0x18);
      UVar5 = context->Length_Low;
      *(ushort *)(context->Message_Block + 0x3e) = uVar2 << 8 | uVar2 >> 8;
      context->Message_Block[0x3d] = (UINT8)(UVar5 >> 0x10);
      context->Message_Block[0x3c] = (UINT8)(UVar5 >> 0x18);
      Bl_SHA1ProcessMessageBlock(context);
      pSVar6 = (SINT16 *)context->Message_Block;
      do {
        *(UINT8 *)pSVar6 = '\0';
        pSVar6 = (SINT16 *)((int)pSVar6 + 1);
      } while (&context->Message_Block_Index != pSVar6);
      context->Length_Low = 0;
      context->Length_High = 0;
      context->Computed = '\x01';
    }
    uVar4 = 0;
    do {
      Message_Digest[uVar4] =
           (UINT8)(*(uint *)((int)context->Intermediate_Hash + (uVar4 & 0xfffffffc)) >>
                  ((~uVar4 & 3) << 3));
      uVar4 = uVar4 + 1;
    } while (uVar4 != 0x14);
    memset(context,0,0xa0);
    return 0;
  }
  return uVar4;
}



int Bl_SHA1Update(Bl_SHA1_CTX *context,UINT8 *message_array,uint length)

{
  short sVar1;
  UINT8 *pUVar2;
  uint uVar3;
  UINT32 UVar4;
  int iVar5;
  
  if (length == 0) {
    return 0;
  }
  uVar3 = 1;
  if ((context != (Bl_SHA1_CTX *)0x0) && (message_array != (UINT8 *)0x0)) {
    if (context->Computed == '\0') {
      uVar3 = (uint)context->Corrupted;
      if (context->Corrupted == 0) {
        pUVar2 = message_array + length;
        while ((message_array != pUVar2 && (context->Corrupted == '\0'))) {
          sVar1 = context->Message_Block_Index;
          iVar5 = ((int)sVar1 + 1) * 0x10000;
          context->Message_Block_Index = (SINT16)((uint)iVar5 >> 0x10);
          context->Message_Block[(int)sVar1] = *message_array;
          UVar4 = context->Length_Low + 8;
          context->Length_Low = UVar4;
          if ((UVar4 == 0) &&
             (UVar4 = context->Length_High + 1, context->Length_High = UVar4, UVar4 == 0)) {
            context->Corrupted = '\x01';
          }
          if (iVar5 >> 0x10 == 0x40) {
            Bl_SHA1ProcessMessageBlock(context);
          }
          message_array = message_array + 1;
        }
        uVar3 = 0;
      }
    }
    else {
      context->Corrupted = '\x03';
      uVar3 = 3;
    }
  }
  return uVar3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

Status_e supplicantRestoreDefaults(void)

{
  char "supplicantRestoreDefaults" [26];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantRestoreDefaults");
  pmkCacheInit();
  pmkCacheRomInit();
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,0x23081ef8);
  return FW_SUCCESS;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void supplicantFuncInit(void)

{
  char "supplicantFuncInit" [19];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantFuncInit");
  supplicantRestoreDefaults();
  dbg_test_print("%dms : Leave: %s\n",0x23081f14);
  return;
}



void ap_setpsk(cm_ConnectionInfo_t *connPtr,CHAR *ssid,CHAR *passphrase)

{
  apInfo_t *paVar1;
  size_t sVar2;
  
  paVar1 = cm_GetApInfo(connPtr);
  if (paVar1 != (apInfo_t *)0x0) {
    sVar2 = strlen(ssid);
    (paVar1->bssConfig).comData.SsIdLen = (IEEEtypes_Len_t)sVar2;
    memcpy(&(paVar1->bssConfig).comData,ssid,0x20);
    sVar2 = strlen(passphrase);
    (paVar1->bssConfig).RsnConfig.PSKPassPhraseLen = (UINT8)sVar2;
    memcpy((paVar1->bssConfig).RsnConfig.PSKPassPhrase,passphrase,0x40);
    return;
  }
  return;
}



void ap_resetConfiguration(cm_ConnectionInfo_t *connPtr)

{
  ushort uVar1;
  apInfo_t *paVar2;
  apSpecificData_t *paVar3;
  size_t sVar4;
  
  paVar2 = cm_GetApInfo(connPtr);
  paVar3 = cm_GetApData(connPtr);
  if ((paVar2 != (apInfo_t *)0x0) && (paVar3 != (apSpecificData_t *)0x0)) {
    sVar4 = strlen("Marvell Micro AP");
    (paVar2->bssConfig).comData.SsIdLen = (IEEEtypes_Len_t)sVar4;
    memcpy(&(paVar2->bssConfig).comData,"Marvell Micro AP",0x20);
    (paVar2->bssData).updatePassPhrase = 1;
    memset(&(paVar2->bssConfig).RsnConfig,0,0x7c);
    uVar1 = *(ushort *)&(paVar2->bssConfig).RsnConfig;
    (paVar2->bssConfig).RsnConfig.AuthKeyCount = 1;
    *(ushort *)&(paVar2->bssConfig).RsnConfig = uVar1 & 0xf7 | 0x108;
    *(ushort *)&(paVar2->bssConfig).RsnConfig.wpa2UcstCipher =
         *(ushort *)&(paVar2->bssConfig).RsnConfig.wpa2UcstCipher & 0xf7 | 0x108;
    (paVar2->bssConfig).RsnConfig.MaxPwsHskRetries = '\x03';
    (paVar2->bssConfig).RsnConfig.MaxGrpHskRetries = '\x03';
    (paVar2->bssConfig).RsnConfig.PwsHskTimeOut = 100;
    (paVar2->bssConfig).RsnConfig.GrpHskTimeOut = 100;
    (paVar2->bssConfig).RsnConfig.GrpReKeyTime = 0x15180;
  }
  return;
}



void InitializeAp(cm_ConnectionInfo_t *connPtr)

{
  ushort uVar1;
  apInfo_t *paVar2;
  apSpecificData_t *paVar3;
  size_t sVar4;
  
  paVar2 = cm_GetApInfo(connPtr);
  paVar3 = cm_GetApData(connPtr);
  if ((paVar2 != (apInfo_t *)0x0) && (paVar3 != (apSpecificData_t *)0x0)) {
    sVar4 = strlen("Marvell Micro AP");
    (paVar2->bssConfig).comData.SsIdLen = (IEEEtypes_Len_t)sVar4;
    memcpy(&(paVar2->bssConfig).comData,"Marvell Micro AP",0x20);
    (paVar2->bssData).updatePassPhrase = 1;
    memset(&(paVar2->bssConfig).RsnConfig,0,0x7c);
    uVar1 = *(ushort *)&(paVar2->bssConfig).RsnConfig;
    (paVar2->bssConfig).RsnConfig.AuthKeyCount = 1;
    *(ushort *)&(paVar2->bssConfig).RsnConfig = uVar1 & 0xf7 | 0x108;
    *(ushort *)&(paVar2->bssConfig).RsnConfig.wpa2UcstCipher =
         *(ushort *)&(paVar2->bssConfig).RsnConfig.wpa2UcstCipher & 0xf7 | 0x108;
    (paVar2->bssConfig).RsnConfig.MaxPwsHskRetries = '\x03';
    (paVar2->bssConfig).RsnConfig.MaxGrpHskRetries = '\x03';
    (paVar2->bssConfig).RsnConfig.PwsHskTimeOut = 100;
    (paVar2->bssConfig).RsnConfig.GrpHskTimeOut = 100;
    (paVar2->bssConfig).RsnConfig.GrpReKeyTime = 0x15180;
  }
  return;
}



void rf_set_channel(uint8_t bandwidth,uint16_t channel_freq)

{
  undefined2 in_register_0000202e;
  
  rfc_config_channel(CONCAT22(in_register_0000202e,channel_freq));
  return;
}



void rf_dump_status(void)

{
  return;
}



int bt_hcionchip_recv(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint8_t uVar1;
  
  switch((uint)msgid - 0x801 & 0xffff) {
  case 0:
    uVar1 = '\x02';
    break;
  case 1:
    uVar1 = '\x03';
    break;
  case 2:
    uVar1 = '\x05';
    break;
  case 3:
    uVar1 = '\x04';
    break;
  default:
    return 0;
  case 5:
    uVar1 = '\x01';
  }
  (*hci_rx_cb)(uVar1,src_id,(uint8_t *)param,*(uint8_t *)((int)param + -2),(void *)0x0);
  return 0;
}



uint8_t bt_onchiphci_interface_init(bt_hci_recv_cb *cb)

{
  uint8_t uVar1;
  
  hci_rx_cb = cb;
  uVar1 = ble_ke_task_create('\x04',&TASK_DESC_HCI_ONCHIP);
  return uVar1;
}


/*
Unable to decompile 'bt_onchiphci_send'
Cause: Exception while decompiling 230674a4: Decompiler process died

*/


uint bt_onchiphci_hanlde_rx_acl(int param_1,void *param_2)

{
  uint uVar1;
  uint8_t *puVar2;
  
  puVar2 = hci_build_acl_rx_data((ke_msg *)(param_1 + -0xc));
  uVar1 = (uint)puVar2[2] + 4 & 0xff;
  (*ble_memcpy_ptr)(param_2,puVar2,uVar1);
  em_buf_rx_free(*(uint8_t *)(param_1 + 6));
  return uVar1;
}



int bl_mtd_open(char *name,bl_mtd_handle_t *handle,uint flags)

{
  char *__dest;
  int iVar1;
  uint32_t uStack40;
  uint32_t addr;
  uint32_t size;
  
  uStack40 = 0;
  addr = 0;
  __dest = (char *)pvPortMalloc(0x20);
  if (__dest == (char *)0x0) {
    iVar1 = -1;
  }
  else {
    memset(__dest,0,0x20);
    strncpy(__dest,name,0x10);
    if ((flags & 1) == 0) {
      if ((flags & 2) == 0) {
        *(undefined4 *)(__dest + 0x1c) = 0;
      }
      else {
        iVar1 = hal_boot2_partition_bus_addr_active(name,&uStack40,&addr);
        if ((iVar1 != 0) || (uStack40 == 0)) {
          printf("[MTD] [PART] [XIP] error when get %s partition %d\r\n",name,iVar1);
          printf("[MTD] [PART] [XIP] Dead Loop. Reason: no Valid %s partition found\r\n",name);
          do {
                    // WARNING: Do nothing block with infinite loop
          } while( true );
        }
        *(uint32_t *)(__dest + 0x1c) = uStack40;
      }
      iVar1 = hal_boot2_partition_addr_active(name,&uStack40,&addr);
      if ((iVar1 != 0) || (uStack40 == 0)) {
        printf("[MTD] [PART] [XIP] error when get %s partition %d\r\n",name,iVar1);
        printf("[MTD] [PART] [XIP] Dead Loop. Reason: no Valid %s partition found\r\n",name);
        do {
                    // WARNING: Do nothing block with infinite loop
        } while( true );
      }
    }
    else {
      if ((flags & 2) == 0) {
        *(undefined4 *)(__dest + 0x1c) = 0;
      }
      else {
        iVar1 = hal_boot2_partition_bus_addr_inactive(name,&uStack40,&addr);
        if ((iVar1 != 0) || (uStack40 == 0)) {
          printf("[MTD] [PART] [XIP] error when get %s partition %d\r\n",name,iVar1);
          printf("[MTD] [PART] [XIP] Dead Loop. Reason: no Valid %s partition found\r\n",name);
          do {
                    // WARNING: Do nothing block with infinite loop
          } while( true );
        }
        *(uint32_t *)(__dest + 0x1c) = uStack40;
      }
      iVar1 = hal_boot2_partition_addr_inactive(name,&uStack40,&addr);
      if ((iVar1 != 0) || (uStack40 == 0)) {
        printf("[MTD] [PART] [XIP] error when get %s partition %d\r\n",name,iVar1);
        printf("[MTD] [PART] [XIP] Dead Loop. Reason: no Valid %s partition found\r\n",name);
        do {
                    // WARNING: Do nothing block with infinite loop
        } while( true );
      }
    }
    *(uint32_t *)(__dest + 0x14) = uStack40;
    *(uint32_t *)(__dest + 0x18) = addr;
    puts("[MTD] >>>>>> Hanlde info Dump >>>>>>\r\n");
    printf("      name %s\r\n",__dest);
    printf("      id %d\r\n",*(undefined4 *)(__dest + 0x10));
    printf("      offset %p(%u)\r\n",*(undefined4 *)(__dest + 0x14));
    printf("      size %p(%uKbytes)\r\n",*(uint *)(__dest + 0x18),*(uint *)(__dest + 0x18) >> 10);
    printf("      xip_addr %p\r\n",*(undefined4 *)(__dest + 0x1c));
    puts("[MTD] <<<<<< Hanlde info End <<<<<<\r\n");
    iVar1 = 0;
    *(char **)handle = __dest;
  }
  return iVar1;
}



int bl_mtd_info(bl_mtd_handle_t handle,bl_mtd_info_t *info)

{
  strcpy((char *)info,(char *)handle);
  info->offset = *(uint *)((int)handle + 0x14);
  info->size = *(uint *)((int)handle + 0x18);
  info->xip_addr = *(void **)((int)handle + 0x1c);
  return 0;
}



int bl_mtd_erase(bl_mtd_handle_t handle,uint addr,uint size)

{
  bl_flash_erase(*(int *)((int)handle + 0x14) + addr,size);
  return 0;
}



int bl_mtd_write(bl_mtd_handle_t handle,uint addr,uint size,uint8_t *data)

{
  uint32_t addr_00;
  int iVar1;
  TickType_t TVar2;
  uint __n;
  uint8_t auStack96 [4];
  uint8_t buf_tmp [64];
  
  addr_00 = *(int *)((int)handle + 0x14) + addr;
  iVar1 = bl_sys_isxipaddr((uint32_t)data);
  if (iVar1 == 0) {
    bl_flash_write(addr_00,data,size);
  }
  else {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] addr@%p is xip flash, size %d\r\n",TVar2,&DAT_230781b4,"bl_mtd.c",
              0xc9,data,size);
    while (size != 0) {
      __n = size;
      if (0x40 < size) {
        __n = 0x40;
      }
      memcpy(auStack96,data,__n);
      bl_flash_write(addr_00,auStack96,__n);
      addr_00 = addr_00 + __n;
      data = data + __n;
      size = size - __n;
    }
  }
  return 0;
}



int bl_mtd_read(bl_mtd_handle_t handle,uint addr,uint size,uint8_t *data)

{
  bl_flash_read(*(int *)((int)handle + 0x14) + addr,data,size);
  return 0;
}



int bloop_init(loop_ctx *loop)

{
  loop_evt_handler_statistic *list;
  loop_evt_handler_statistic *plVar1;
  
  memset(loop,0,0x4a0);
  list = (loop_evt_handler_statistic *)loop->list;
  do {
    plVar1 = (loop_evt_handler_statistic *)&list->time_accumulated;
    utils_list_init((utils_list *)list);
    list = plVar1;
  } while (plVar1 != loop->statistic);
  *(utils_dlist_t **)&(loop->timer_dlist).next = &loop->timer_dlist;
  *(utils_dlist_t **)&(loop->timer_dlist).prev = &loop->timer_dlist;
  *(utils_dlist_t **)&(loop->timer_dued).next = &loop->timer_dued;
  *(utils_dlist_t **)&(loop->timer_dued).prev = &loop->timer_dued;
  printf("=== %d task inited\r\n",0x20);
  return 0;
}



int bloop_handler_register(loop_ctx *loop,loop_evt_handler *handler,int priority)

{
  if (((uint)priority < 0x20) && ((&loop->looper + priority)[0x104] == (TaskHandle_t)0x0)) {
    *(loop_evt_handler **)(&loop->looper + priority + 0x104) = handler;
    return 0;
  }
  return -1;
}



void bloop_timer_init(loop_timer *timer,int use_auto_free)

{
  memset(timer,0,0x24);
  *(loop_timer **)&(timer->dlist_item).prev = timer;
  *(loop_timer **)&(timer->dlist_item).next = timer;
  timer->flags = (use_auto_free != 0) << 1;
  return;
}



void bloop_timer_configure
               (loop_timer *timer,uint delay_ms,
               anon_subr_void_loop_ctx_ptr_loop_timer_ptr_void_ptr *cb,void *arg,int idx_task,
               uint32_t evt_type_map)

{
  TickType_t TVar1;
  
  TVar1 = xTaskGetTickCount();
  timer->time_added = TVar1;
  timer->time_target = TVar1 + delay_ms;
  *(anon_subr_void_loop_ctx_ptr_loop_timer_ptr_void_ptr **)&timer->cb = cb;
  timer->arg = arg;
  timer->idx_task = idx_task;
  timer->evt_type_map = evt_type_map;
  return;
}



void bloop_timer_repeat_enable(loop_timer *timer)

{
  timer->flags = timer->flags | 1;
  return;
}



void bloop_timer_repeat_reconfigure(loop_timer *timer)

{
  uint uVar1;
  uint uVar2;
  TickType_t TVar3;
  
  uVar1 = timer->time_target;
  uVar2 = timer->time_added;
  TVar3 = xTaskGetTickCount();
  timer->time_target = (uVar1 - uVar2) + TVar3;
  timer->time_added = TVar3;
  return;
}



void bloop_timer_register(loop_ctx *loop,loop_timer *timer)

{
  utils_dlist_s *puVar1;
  utils_dlist_s *puVar2;
  utils_dlist_s *puVar3;
  utils_dlist_s *puVar4;
  utils_dlist_s *puVar5;
  
  puVar2 = (loop->timer_dlist).next;
  puVar3 = (utils_dlist_s *)&loop->timer_dlist;
  if (puVar3 == puVar2) {
    (timer->dlist_item).next = puVar3;
    (timer->dlist_item).prev = puVar3;
    *(loop_timer **)&(loop->timer_dlist).next = timer;
    *(loop_timer **)&(loop->timer_dlist).prev = timer;
    return;
  }
  puVar1 = puVar2;
  puVar5 = (utils_dlist_s *)0x0;
  do {
    puVar4 = puVar1;
    if (puVar3 == puVar4) {
LAB_23067a0a:
      puVar2 = puVar5->next;
      (timer->dlist_item).prev = puVar5;
      (timer->dlist_item).next = puVar2;
      *(loop_timer **)&puVar5->next = timer;
      *(loop_timer **)&puVar2->prev = timer;
      return;
    }
    if ((int)(timer->time_target - (int)puVar4[2].prev) < 1) {
      if (puVar5 == (utils_dlist_s *)0x0) {
        (timer->dlist_item).next = puVar2;
        (timer->dlist_item).prev = puVar3;
        *(loop_timer **)&(loop->timer_dlist).next = timer;
        *(loop_timer **)&puVar2->prev = timer;
        return;
      }
      goto LAB_23067a0a;
    }
    puVar1 = puVar4->next;
    puVar5 = puVar4;
  } while( true );
}



void bloop_wait_startup(loop_ctx *loop)

{
  while (loop->looper == (TaskHandle_t)0x0) {
    vTaskDelay(1);
  }
  return;
}



void bloop_evt_set_async(loop_ctx *loop,uint evt,uint32_t evt_map)

{
  if (0x1f < evt) {
    printf("[ASSERT] [ERR] %s:%d\r\n","bloop_base.c",0x15a);
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  vTaskEnterCritical();
  loop->bitmap_evt_async = loop->bitmap_evt_async | 1 << (evt & 0x1f);
  (&loop->looper + evt)[4] = (TaskHandle_t)((uint)(&loop->looper + evt)[4] | evt_map);
  vTaskExitCritical();
  xTaskGenericNotify(loop->looper,0,eIncrement,(uint32_t *)0x0);
  return;
}



void bloop_evt_set_sync(loop_ctx *loop,uint evt,uint32_t evt_map)

{
  if (0x1f < evt) {
    printf("[ASSERT] [ERR] %s:%d\r\n","bloop_base.c",0x177);
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  loop->bitmap_evt_sync = loop->bitmap_evt_sync | 1 << (evt & 0x1f);
  (&loop->looper + evt)[4] = (TaskHandle_t)((uint)(&loop->looper + evt)[4] | evt_map);
  return;
}



void bloop_evt_unset_sync(loop_ctx *loop,uint evt)

{
  if (0x1f < evt) {
    printf("[ASSERT] [ERR] %s:%d\r\n","bloop_base.c",0x17f);
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  loop->bitmap_evt_sync = ~(1 << (evt & 0x1f)) & loop->bitmap_evt_sync;
  return;
}



void bloop_run(loop_ctx *param_1)

{
  loop_timer *plVar1;
  utils_dlist_t *puVar2;
  loop_timer *timer;
  TaskHandle_t ptVar3;
  TickType_t TVar4;
  uint32_t uVar5;
  uint32_t uVar6;
  int iVar7;
  int iVar8;
  utils_list_hdr *puVar9;
  utils_dlist_s *xTicksToWait;
  uint evt;
  TaskHandle_t ptVar10;
  utils_dlist_s *puVar11;
  utils_dlist_s *puVar12;
  TaskHandle_t *pptVar13;
  loop_timer *plVar14;
  utils_dlist_t *puVar15;
  
  ptVar3 = xTaskGetCurrentTaskHandle();
  param_1->looper = ptVar3;
LAB_23067b3e:
  do {
    puVar15 = &param_1->timer_dlist;
    while( true ) {
      vTaskEnterCritical();
      evt = param_1->bitmap_evt_async;
      param_1->bitmap_evt_async = 0;
      param_1->bitmap_evt_sync = param_1->bitmap_evt_sync | evt;
      vTaskExitCritical();
      if (param_1->bitmap_evt_sync != 0) break;
      puVar2 = (utils_dlist_t *)(param_1->timer_dlist).next;
      xTicksToWait = (utils_dlist_s *)0xffffffff;
      if (puVar2 != puVar15) {
        xTicksToWait = puVar2[2].prev;
        TVar4 = xTaskGetTickCount();
        xTicksToWait = (utils_dlist_s *)((int)xTicksToWait - TVar4);
        if ((int)xTicksToWait < 1) break;
      }
      ulTaskNotifyTake(1,(TickType_t)xTicksToWait);
    }
    if ((utils_dlist_t *)(param_1->timer_dlist).next != puVar15) {
      TVar4 = xTaskGetTickCount();
      puVar2 = (utils_dlist_t *)(param_1->timer_dlist).next;
      xTicksToWait = (utils_dlist_s *)0x0;
      if (puVar2 != (utils_dlist_t *)0x0) {
        xTicksToWait = (&puVar2->prev)[1];
      }
      while ((puVar11 = xTicksToWait, puVar2 != puVar15 && (-1 < (int)(TVar4 - (int)puVar2[2].prev))
             )) {
        bloop_evt_set_sync(param_1,(uint)puVar2[2].next,(uint32_t)puVar2[3].prev);
        if (puVar2[3].next != (utils_dlist_s *)0x0) {
          (*(code *)puVar2[3].next)(param_1,puVar2,puVar2[4].prev);
        }
        puVar12 = (&puVar2->prev)[1];
        xTicksToWait = puVar2->prev;
        xTicksToWait->next = puVar12;
        puVar12->prev = xTicksToWait;
        xTicksToWait = (param_1->timer_dued).next;
        *(loop_timer **)&puVar2->prev = (loop_timer *)&param_1->timer_dued;
        (&puVar2->prev)[1] = xTicksToWait;
        *(utils_dlist_t **)&(param_1->timer_dued).next = puVar2;
        *(utils_dlist_t **)&xTicksToWait->prev = puVar2;
        puVar2 = (utils_dlist_t *)puVar11;
        xTicksToWait = (utils_dlist_s *)0x0;
        if (puVar11 != (utils_dlist_s *)0x0) {
          xTicksToWait = (&puVar11->prev)[1];
        }
      }
      timer = (loop_timer *)(param_1->timer_dued).next;
      plVar1 = (loop_timer *)0x0;
      if (timer != (loop_timer *)0x0) {
        plVar1 = (loop_timer *)(timer->dlist_item).next;
      }
      while (plVar14 = plVar1, timer != (loop_timer *)&param_1->timer_dued) {
        xTicksToWait = (timer->dlist_item).prev;
        puVar11 = (timer->dlist_item).next;
        xTicksToWait->next = puVar11;
        puVar11->prev = xTicksToWait;
        if ((timer->flags & 2) == 0) {
          if ((timer->flags & 1) != 0) {
            if ((_fsymc_level_bloop < BLOG_LEVEL_INFO) &&
               (_fsymf_level_bloopbloop_base < BLOG_LEVEL_INFO)) {
              if (TrapNetCounter == 0) {
                TVar4 = xTaskGetTickCount();
              }
              else {
                TVar4 = xTaskGetTickCountFromISR();
              }
              bl_printk("[%10u][%s: %s:%4d] Repeat timer\r\n",TVar4,"DEBUG ","bloop_base.c",0xbb);
            }
            bloop_timer_repeat_reconfigure(timer);
            bloop_timer_register(param_1,timer);
          }
        }
        else {
          if ((_fsymc_level_bloop < BLOG_LEVEL_INFO) &&
             (_fsymf_level_bloopbloop_base < BLOG_LEVEL_INFO)) {
            if (TrapNetCounter == 0) {
              TVar4 = xTaskGetTickCount();
            }
            else {
              TVar4 = xTaskGetTickCountFromISR();
            }
            bl_printk("[%10u][%s: %s:%4d] Free now\r\n",TVar4,"DEBUG ","bloop_base.c",0xb8);
          }
          vPortFree(timer);
        }
        timer = plVar14;
        plVar1 = (loop_timer *)0x0;
        if (plVar14 != (loop_timer *)0x0) {
          plVar1 = (loop_timer *)(plVar14->dlist_item).next;
        }
      }
    }
    iVar7 = __clzsi2(param_1->bitmap_evt_sync);
    iVar8 = __clzsi2(param_1->bitmap_msg);
    if (iVar7 <= iVar8) {
      evt = -iVar7 + 0x1f;
      if (evt != 0xffffffff) {
        pptVar13 = &param_1->looper + evt;
        ptVar3 = pptVar13[0x104];
        if (ptVar3 == (TaskHandle_t)0x0) {
          printf("[ASSERT] [ERR] %s:%d\r\n","bloop_base.c",0x105);
          do {
                    // WARNING: Do nothing block with infinite loop
          } while( true );
        }
        vTaskEnterCritical();
        ptVar10 = pptVar13[4];
        pptVar13[4] = (TaskHandle_t)0x0;
        pptVar13[0x24] = (TaskHandle_t)((uint)pptVar13[0x24] | (uint)ptVar10);
        vTaskExitCritical();
        uVar5 = bl_timer_now_us();
        (*(code *)(ptVar3->xStateListItem).xItemValue)
                  (param_1,(loop_evt_handler *)ptVar3,&param_1->bitmap_evt_sync,
                   (uint32_t *)(&param_1->looper + -iVar7 + 0x43));
        uVar6 = bl_timer_now_us();
        pptVar13 = &param_1->looper + evt * 4;
        ptVar3 = (TaskHandle_t)(uVar6 - uVar5);
        pptVar13[0x85] = ptVar3;
        pptVar13[0x86] = (TaskHandle_t)((int)pptVar13[0x86] + (int)ptVar3);
        if (pptVar13[0x84] < ptVar3) {
          pptVar13[0x84] = ptVar3;
        }
        pptVar13[0x87] = (TaskHandle_t)((int)&pptVar13[0x87]->pxTopOfStack + 1);
        bloop_evt_unset_sync(param_1,evt);
        goto LAB_23067b3e;
      }
    }
    if ((-iVar8 != -0x20) &&
       (puVar9 = utils_list_pop_front((utils_list *)(&param_1->looper + (-iVar8 + 0x41) * 2)),
       puVar9 == (utils_list_hdr *)0x0)) {
      printf("[ASSERT] [ERR] %s:%d\r\n","bloop_base.c",0x124);
      do {
                    // WARNING: Do nothing block with infinite loop
      } while( true );
    }
  } while( true );
}



int bloop_status_dump(loop_ctx *loop)

{
  loop_evt_handler_statistic *plVar1;
  utils_dlist_s *puVar2;
  uint32_t *puVar3;
  TickType_t TVar4;
  char *pcVar5;
  uint32_t uVar6;
  int iVar7;
  uint32_t uVar8;
  uint32_t uVar9;
  
  puts("====== bloop dump ======\r\n");
  printf("  bitmap_evt %lx\r\n",loop->bitmap_evt_sync);
  printf("  bitmap_msg %lx\r\n",loop->bitmap_msg);
  TVar4 = xTaskGetTickCount();
  puts("--->>> timer list:\r\n");
  puVar2 = (loop->timer_dlist).next;
  iVar7 = 0;
  while ((utils_dlist_s *)&loop->timer_dlist != puVar2) {
    printf("    timer[%02d]: %u(diff %d)ms, \t\t task idx %02d, evt map %08lx, ptr %p\r\n",iVar7,
           puVar2[2].prev,TVar4 - (int)puVar2[2].prev,puVar2[2].next,puVar2[3].prev,puVar2[3].next);
    iVar7 = iVar7 + 1;
    puVar2 = puVar2->next;
  }
  puVar3 = loop->evt_type_map_async + 0x1f;
  printf("  %d task:\r\n",0x20);
  plVar1 = loop->statistic + 0x1f;
  iVar7 = 0x1f;
  do {
    pcVar5 = "empty";
    if ((char **)puVar3[0x100] != (char **)0x0) {
      pcVar5 = *(char **)puVar3[0x100];
    }
    printf("    task[%02d] : %s\r\n",iVar7,pcVar5);
    uVar8 = puVar3[0x100];
    if (uVar8 != 0) {
      uVar6 = puVar3[0x20];
      uVar9 = *puVar3;
      printf("      evt handler %p,",*(undefined4 *)(uVar8 + 4));
      printf(" msg handler %p,",*(undefined4 *)(uVar8 + 8));
      printf(" trigged cnt %u,",plVar1->count_triggered);
      printf(" bitmap async %lx sync %lx,",uVar9,uVar6);
      printf(" time consumed %dus acc %dms, max %uus\r\n",plVar1->time_consumed,
             plVar1->time_accumulated / 1000,plVar1->time_max);
    }
    iVar7 = iVar7 + -1;
    puVar3 = puVar3 + -1;
    plVar1 = plVar1 + -1;
  } while (iVar7 != -1);
  return 0;
}



int loop_evt_entity_sys_handler(loop_ctx *loop,loop_evt_handler *handler,loop_msg *msg)

{
  printf(
         "[SYS] [MSG] called with msg info\r\n    priority %u\r\n    dst %u\r\n    msgid %u\r\n    src %u\r\n    arg1 %p\r\n    arg2 %p\r\n"
         ,(uint)*(byte *)&msg->u,(uint)*(byte *)((int)&msg->u + 1),(uint)*(byte *)((int)&msg->u + 2)
         ,(uint)*(byte *)((int)&msg->u + 3),msg->arg1,msg->arg2);
  return 0;
}



int loop_evt_entity_sys_evt
              (loop_ctx *loop,loop_evt_handler *handler,uint32_t *bitmap_evt,uint32_t *evt_type_map)

{
  uint uVar1;
  
  uVar1 = *evt_type_map;
  printf("[SYS] [EVT] called with bitmap_evt %08lx, bitmap_task %08lx\r\n",*bitmap_evt,uVar1);
  do {
    if ((uVar1 & 1) == 0) {
      if (uVar1 != 0) {
        printf("[ASSERT] [ERR] %s:%d\r\n","bloop_handler_sys.c",0x2e);
        do {
                    // WARNING: Do nothing block with infinite loop
        } while( true );
      }
      break;
    }
    uVar1 = uVar1 & 0xfffffffe;
    bloop_status_dump(loop);
  } while (uVar1 != 0);
  *evt_type_map = 0;
  return 0;
}



int bl_sys_time_sync_state(uint32_t *xTicksToJump)

{
  bool bVar1;
  TickType_t TVar2;
  TickType_t TVar3;
  uint uVar4;
  uint64_t uVar5;
  
  if (sync_init != 0) {
    vTaskEnterCritical();
    TVar2 = xTaskGetTickCount();
    TVar3 = TVar2;
    uVar5 = bl_rtc_get_timestamp_ms();
    vTaskExitCritical((int)uVar5);
    uVar4 = TVar3 - init_tick_rtc;
    bVar1 = TVar2 - init_tick_rtos < uVar4;
    if (bVar1) {
      *xTicksToJump = (init_tick_rtos - TVar2) + uVar4;
    }
    return (uint)bVar1;
  }
  return -1;
}


/*
Unable to decompile 'misaligned_load_trap'
Cause: Exception while decompiling 23067fdc: Decompiler process died

*/

/*
Unable to decompile 'misaligned_store_trap'
Cause: Exception while decompiling 2306812e: Decompiler process died

*/


void get_f32_reg(void)

{
  uint in_t0;
  
                    // WARNING: Could not recover jumptable at 0x2306827e. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)(in_t0 & 0xfffffffe))();
  return;
}



void put_f32_reg(void)

{
  uint in_t0;
  
                    // WARNING: Could not recover jumptable at 0x2306837e. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)(in_t0 & 0xfffffffe))();
  return;
}



int backtrace_riscv(anon_subr_int_char_ptr *print_func,uintptr_t *regs)

{
  return -1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t bl_timer_now_us(void)

{
  uint32_t uVar1;
  
  uVar1 = _DAT_0200bff8;
  __udivdi3();
  return uVar1;
}



uint64_t bl_rtc_get_counter(void)

{
  uint64_t in_fa0;
  uint32_t uStack24;
  uint32_t valLow;
  uint32_t valHigh;
  
  HBN_Get_RTC_Timer_Val(&uStack24,&valLow);
  return in_fa0;
}



uint64_t bl_rtc_get_timestamp_ms(void)

{
  uint64_t uVar1;
  
  uVar1 = bl_rtc_get_counter();
  return uVar1;
}



// WARNING: Variable defined which should be unmapped: addr

void set_if(netif *netif,char *ip_addr,char *gw_addr,char *nm_addr)

{
  int iVar1;
  ip4_addr_t iStack20;
  ip4_addr_t addr;
  
  if ((ip_addr != (char *)0x0) && (iVar1 = ip4addr_aton(ip_addr,&iStack20), iVar1 != 0)) {
    netif_set_ipaddr(netif,&iStack20);
  }
  if ((gw_addr != (char *)0x0) && (iVar1 = ip4addr_aton(gw_addr,&iStack20), iVar1 != 0)) {
    netif_set_gw(netif,&iStack20);
  }
  if ((nm_addr != (char *)0x0) && (iVar1 = ip4addr_aton(nm_addr,&iStack20), iVar1 != 0)) {
    netif_set_netmask(netif,&iStack20);
  }
  return;
}



// WARNING: Variable defined which should be unmapped: pTemp

void Bl_F_fast(uchar *digest,uchar *digest1,char *password,uchar *ssid,int ssidlength,int count,
              uchar *output)

{
  int iVar1;
  size_t key_len;
  byte *pbVar2;
  uchar *puVar3;
  byte *pbVar4;
  int iVar5;
  int iStack40;
  int tmpLen;
  uchar *pTemp;
  
  key_len = strlen(password);
  iStack40 = ssidlength + 4;
  tmpLen = (int)digest;
  memcpy(digest,ssid,ssidlength);
  puVar3 = digest + ssidlength;
  *puVar3 = '\0';
  puVar3[3] = (uchar)count;
  puVar3[1] = '\0';
  puVar3[2] = '\0';
  bl_sha_mutex_take();
  utils_hmac_sha1_fast((uchar **)&tmpLen,&iStack40,1,(uchar *)password,key_len,digest1,0x14);
  memcpy(output,digest1,0x14);
  iVar1 = 0xfff;
  tmpLen = (int)digest1;
  do {
    iStack40 = 0x14;
    utils_hmac_sha1_fast((uchar **)&tmpLen,&iStack40,1,(uchar *)password,key_len,digest,0x14);
    memcpy(digest1,digest,0x14);
    iVar5 = 0;
    do {
      pbVar2 = output + iVar5;
      pbVar4 = digest + iVar5;
      iVar5 = iVar5 + 1;
      *pbVar2 = *pbVar4 ^ *pbVar2;
    } while (iVar5 != 0x14);
    iVar1 = iVar1 + -1;
  } while (iVar1 != 0);
  bl_sha_mutex_give();
  return;
}



int utils_wifi_psk_cal_fast_bin(char *password,uchar *ssid,int ssidlength,uchar *output)

{
  size_t sVar1;
  int iVar2;
  uchar auStack88 [4];
  uchar digest1 [20];
  uchar digest [36];
  
  sVar1 = strlen(password);
  if (sVar1 < 0x40) {
    iVar2 = -1;
    if (ssidlength < 0x21) {
      Bl_F_fast(digest1 + 0x10,auStack88,password,ssid,ssidlength,2,output);
      memcpy(output + 0x14,output,0xc);
      Bl_F_fast(digest1 + 0x10,auStack88,password,ssid,ssidlength,1,output);
      iVar2 = 0;
    }
  }
  else {
    iVar2 = -1;
  }
  return iVar2;
}



void utils_hmac_sha1_fast
               (uchar **ppText,int *pTextLen,int textNum,uchar *key,int key_len,uchar *output,
               int outputLen)

{
  uint *puVar1;
  uint32_t *puVar2;
  uint *__src;
  uchar **ppuVar3;
  int iVar4;
  uint *hash;
  uint local_120;
  uint64_t pBuf [11];
  undefined auStack196 [4];
  bl_sha_ctx_t sha_ctx;
  
  if (0x40 < key_len) {
    bl_sha_init((bl_sha_ctx_t *)auStack196,BL_SHA1);
    bl_sha_update((bl_sha_ctx_t *)auStack196,key,key_len);
    bl_sha_finish((bl_sha_ctx_t *)auStack196,key);
    key_len = 0x14;
  }
  memset(&local_120,0,0x40);
  memcpy(&local_120,key,key_len);
  hash = (uint *)((int)pBuf + 0x3c);
  puVar1 = &local_120;
  do {
    __src = puVar1 + 2;
    *puVar1 = *puVar1 ^ 0x36363636;
    puVar1[1] = puVar1[1] ^ 0x36363636;
    puVar1 = __src;
  } while (__src != hash);
  bl_sha_init((bl_sha_ctx_t *)auStack196,BL_SHA1);
  bl_sha_update((bl_sha_ctx_t *)auStack196,(uint8_t *)&local_120,0x40);
  iVar4 = 0;
  while (iVar4 < textNum) {
    puVar2 = (uint32_t *)(pTextLen + iVar4);
    ppuVar3 = ppText + iVar4;
    iVar4 = iVar4 + 1;
    bl_sha_update((bl_sha_ctx_t *)auStack196,*ppuVar3,*puVar2);
  }
  bl_sha_finish((bl_sha_ctx_t *)auStack196,(uint8_t *)hash);
  memset(&local_120,0,0x40);
  memcpy(&local_120,key,key_len);
  puVar1 = &local_120;
  do {
    __src = puVar1 + 2;
    *puVar1 = *puVar1 ^ 0x5c5c5c5c;
    puVar1[1] = puVar1[1] ^ 0x5c5c5c5c;
    puVar1 = __src;
  } while (__src != hash);
  bl_sha_init((bl_sha_ctx_t *)auStack196,BL_SHA1);
  bl_sha_update((bl_sha_ctx_t *)auStack196,(uint8_t *)&local_120,0x40);
  bl_sha_update((bl_sha_ctx_t *)auStack196,(uint8_t *)__src,0x14);
  bl_sha_finish((bl_sha_ctx_t *)auStack196,(uint8_t *)__src);
  memcpy(output,__src,outputLen);
  return;
}



int bl_sha_mutex_take(void)

{
  BaseType_t BVar1;
  TickType_t TVar2;
  int iVar3;
  
  BVar1 = xQueueSemaphoreTake((QueueHandle_t)g_bl_sec_sha_mutex,0xffffffff);
  iVar3 = 0;
  if (((BVar1 != 1) && (iVar3 = -1, _fsymc_level_hal_drv < BLOG_LEVEL_ASSERT)) &&
     (_fsymf_level_hal_drvbl_sec_sha < BLOG_LEVEL_ASSERT)) {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] sha semphr take failed\r\n",TVar2,&DAT_23078e4c,"bl_sec_sha.c",
              0x36);
    iVar3 = -1;
  }
  return iVar3;
}



int bl_sha_mutex_give(void)

{
  BaseType_t BVar1;
  TickType_t TVar2;
  int iVar3;
  
  BVar1 = xQueueGenericSend((QueueHandle_t)g_bl_sec_sha_mutex,(void *)0x0,0,0);
  iVar3 = 0;
  if (((BVar1 != 1) && (iVar3 = -1, _fsymc_level_hal_drv < BLOG_LEVEL_ASSERT)) &&
     (_fsymf_level_hal_drvbl_sec_sha < BLOG_LEVEL_ASSERT)) {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] sha semphr give failed\\n",TVar2,&DAT_23078e4c,"bl_sec_sha.c",0x3f
             );
    iVar3 = -1;
  }
  return iVar3;
}



void bl_sha_init(bl_sha_ctx_t *ctx,bl_sha_type_t type)

{
  Sec_Eng_SHA256_Init((SEC_Eng_SHA256_Ctx *)ctx,SEC_ENG_SHA_ID0,type,ctx->tmp,ctx->pad);
  Sec_Eng_SHA_Start(SEC_ENG_SHA_ID0);
  return;
}



int bl_sha_update(bl_sha_ctx_t *ctx,uint8_t *input,uint32_t len)

{
  BL_Err_Type BVar1;
  undefined3 extraout_var;
  
  BVar1 = Sec_Eng_SHA256_Update((SEC_Eng_SHA256_Ctx *)ctx,SEC_ENG_SHA_ID0,input,len);
  return CONCAT31(extraout_var,BVar1);
}



int bl_sha_finish(bl_sha_ctx_t *ctx,uint8_t *hash)

{
  BL_Err_Type BVar1;
  undefined3 extraout_var;
  
  BVar1 = Sec_Eng_SHA256_Finish((SEC_Eng_SHA256_Ctx *)ctx,SEC_ENG_SHA_ID0,hash);
  return CONCAT31(extraout_var,BVar1);
}



double fabs(double __x)

{
  double in_fa0;
  
  return in_fa0;
}



double floor(double __x)

{
  uint uVar1;
  uint in_a0;
  uint in_a1;
  uint uVar2;
  double in_fa0;
  
  uVar2 = (int)in_a1 >> 0x14 & 0x7ff;
  uVar1 = uVar2 - 0x3ff;
  if ((int)uVar1 < 0x14) {
    if ((int)uVar1 < 0) {
      in_fa0 = (double)__adddf3();
      __gedf2();
    }
    else {
      if ((0xfffff >> (uVar1 & 0x1f) & in_a1 | in_a0) != 0) {
        in_fa0 = (double)__adddf3();
        __gedf2();
      }
    }
  }
  else {
    if ((int)uVar1 < 0x34) {
      if ((0xffffffffU >> (uVar2 - 0x413 & 0x1f) & in_a0) != 0) {
        in_fa0 = (double)__adddf3();
        __gedf2();
      }
    }
    else {
      if (uVar1 == 0x400) {
        in_fa0 = (double)__adddf3();
      }
    }
  }
  return in_fa0;
}



double modf(double __x,double *__iptr)

{
  double *in_a1;
  double **in_a2;
  uint uVar1;
  uint uVar2;
  double in_fa0;
  DFtype DVar3;
  
  uVar1 = (int)in_a1 >> 0x14 & 0x7ff;
  uVar2 = uVar1 - 0x3ff;
  if ((int)uVar2 < 0x14) {
    if ((int)uVar2 < 0) {
      *in_a2 = (double *)0x0;
      in_a2[1] = (double *)((uint)in_a1 & 0x80000000);
      return in_fa0;
    }
    uVar1 = 0xfffff >> (uVar2 & 0x1f);
    if ((uVar1 & (uint)in_a1 | (uint)__iptr) != 0) {
      in_a1 = (double *)(~uVar1 & (uint)in_a1);
      __iptr = (double *)0x0;
LAB_23068bc0:
      *in_a2 = __iptr;
      in_a2[1] = in_a1;
      DVar3 = __subdf3();
      return (double)DVar3;
    }
  }
  else {
    if (((int)uVar2 < 0x34) &&
       (uVar1 = 0xffffffff >> (uVar1 - 0x413 & 0x1f), (uVar1 & (uint)__iptr) != 0)) {
      __iptr = (double *)(~uVar1 & (uint)__iptr);
      goto LAB_23068bc0;
    }
  }
  in_a2[1] = in_a1;
  *in_a2 = __iptr;
  return in_fa0;
}



DItype __lshrdi3(shift_count_type b)

{
  DItype in_fa0;
  
  return in_fa0;
}



int __clzsi2(USItype x)

{
  int iVar1;
  
  if (x < 0x10000) {
    iVar1 = (uint)(0xff < x) << 3;
  }
  else {
    iVar1 = 0x10;
    if (0xffffff < x) {
      iVar1 = 0x18;
    }
  }
  return (0x20 - iVar1) - (uint)""[x >> iVar1];
}



// WARNING: Type propagation algorithm not settling

DItype __divdi3(void)

{
  DItype in_fa0;
  
  return in_fa0;
}



// WARNING: Type propagation algorithm not settling

DItype __moddi3(void)

{
  DItype in_fa0;
  
  return in_fa0;
}



// WARNING: Type propagation algorithm not settling

UDItype __udivdi3(void)

{
  UDItype in_fa0;
  
  return in_fa0;
}



// WARNING: Type propagation algorithm not settling

UDItype __umoddi3(void)

{
  UDItype in_fa0;
  
  return in_fa0;
}


/*
Unable to decompile '__adddf3'
Cause: Exception while decompiling 23069da8: Decompiler process died

*/

/*
Unable to decompile '__divdf3'
Cause: 
Low-level Error: Assignment to constant at r0x2306af2c
*/


__gcc_CMPtype __eqdf2(void)

{
  uint in_a0;
  uint in_a1;
  uint in_a2;
  uint in_a3;
  uint uVar1;
  uint uVar2;
  uint uVar3;
  
  uVar1 = in_a1 >> 0x14 & 0x7ff;
  uVar2 = in_a1 & 0xfffff;
  uVar3 = in_a3 >> 0x14 & 0x7ff;
  if (uVar1 == 0x7ff) {
    if ((uVar2 | in_a0) != 0) {
      return 1;
    }
    if (uVar3 != 0x7ff) {
      return 1;
    }
  }
  else {
    if (uVar3 != 0x7ff) goto LAB_2306b1fc;
  }
  if ((in_a3 & 0xfffff | in_a2) != 0) {
    return 1;
  }
LAB_2306b1fc:
  if (((uVar1 == uVar3) && (uVar2 == (in_a3 & 0xfffff))) && (in_a2 == in_a0)) {
    if (in_a1 >> 0x1f == in_a3 >> 0x1f) {
      return 0;
    }
    if (uVar1 == 0) {
      return (uint)((uVar2 | in_a2) != 0);
    }
  }
  return 1;
}



__gcc_CMPtype __gedf2(void)

{
  bool bVar1;
  uint in_a0;
  uint in_a1;
  int iVar2;
  uint in_a2;
  uint in_a3;
  int iVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  
  uVar6 = in_a1 >> 0x14 & 0x7ff;
  uVar7 = in_a1 & 0xfffff;
  uVar5 = in_a3 & 0xfffff;
  iVar2 = -((int)in_a1 >> 0x1f);
  uVar4 = in_a3 >> 0x14 & 0x7ff;
  iVar3 = -((int)in_a3 >> 0x1f);
  if (uVar6 == 0x7ff) {
    if ((uVar7 | in_a0) != 0) {
      return -2;
    }
    if (uVar4 == 0x7ff) {
LAB_2306b2c0:
      if ((uVar5 | in_a2) != 0) {
        return -2;
      }
      goto LAB_2306b2c8;
    }
LAB_2306b34c:
    if (uVar4 == 0) {
      bVar1 = false;
LAB_2306b2d8:
      if ((uVar5 | in_a2) == 0) {
        if (bVar1) {
          return 0;
        }
        goto LAB_2306b2ec;
      }
      goto LAB_2306b2e0;
    }
  }
  else {
    if (uVar4 == 0x7ff) goto LAB_2306b2c0;
LAB_2306b2c8:
    if (uVar6 != 0) goto LAB_2306b34c;
    bVar1 = (uVar7 | in_a0) == 0;
    if (uVar4 == 0) goto LAB_2306b2d8;
LAB_2306b2e0:
    if (bVar1) {
      if (iVar3 != 0) {
        return iVar3;
      }
      return -1;
    }
  }
  if ((iVar2 == iVar3) && (uVar6 <= uVar4)) {
    if (uVar4 <= uVar6) {
      if (uVar5 < uVar7) goto LAB_2306b2ec;
      if (uVar7 == uVar5) {
        if (in_a2 < in_a0) goto LAB_2306b2ec;
        if (in_a2 <= in_a0) {
          return 0;
        }
      }
      else {
        if (uVar5 <= uVar7) {
          return 0;
        }
      }
    }
    if (iVar2 == 0) {
      return -1;
    }
    return iVar2;
  }
LAB_2306b2ec:
  if (iVar2 != 0) {
    return -1;
  }
  return 1;
}



__gcc_CMPtype __ledf2(void)

{
  bool bVar1;
  uint in_a0;
  uint in_a1;
  int iVar2;
  uint in_a2;
  uint in_a3;
  int iVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  
  uVar6 = in_a1 >> 0x14 & 0x7ff;
  uVar7 = in_a1 & 0xfffff;
  uVar5 = in_a3 & 0xfffff;
  iVar2 = -((int)in_a1 >> 0x1f);
  uVar4 = in_a3 >> 0x14 & 0x7ff;
  iVar3 = -((int)in_a3 >> 0x1f);
  if (uVar6 == 0x7ff) {
    if ((uVar7 | in_a0) != 0) {
      return 2;
    }
    if (uVar4 == 0x7ff) {
LAB_2306b3ac:
      if ((uVar5 | in_a2) != 0) {
        return 2;
      }
      goto LAB_2306b3b4;
    }
LAB_2306b438:
    if (uVar4 == 0) {
      bVar1 = false;
LAB_2306b3c4:
      if ((uVar5 | in_a2) == 0) {
        if (bVar1) {
          return 0;
        }
        goto LAB_2306b3d8;
      }
      goto LAB_2306b3cc;
    }
  }
  else {
    if (uVar4 == 0x7ff) goto LAB_2306b3ac;
LAB_2306b3b4:
    if (uVar6 != 0) goto LAB_2306b438;
    bVar1 = (uVar7 | in_a0) == 0;
    if (uVar4 == 0) goto LAB_2306b3c4;
LAB_2306b3cc:
    if (bVar1) {
      if (iVar3 != 0) {
        return iVar3;
      }
      return -1;
    }
  }
  if ((iVar2 == iVar3) && (uVar6 <= uVar4)) {
    if (uVar4 <= uVar6) {
      if (uVar5 < uVar7) goto LAB_2306b3d8;
      if (uVar7 == uVar5) {
        if (in_a2 < in_a0) goto LAB_2306b3d8;
        if (in_a2 <= in_a0) {
          return 0;
        }
      }
      else {
        if (uVar5 <= uVar7) {
          return 0;
        }
      }
    }
    if (iVar2 == 0) {
      return -1;
    }
    return iVar2;
  }
LAB_2306b3d8:
  if (iVar2 != 0) {
    return -1;
  }
  return 1;
}


/*
Unable to decompile '__muldf3'
Cause: 
Low-level Error: Assignment to constant at r0x2306b6ec
*/

/*
Unable to decompile '__subdf3'
Cause: Exception while decompiling 2306bbe0: Decompiler process died

*/


SItype __fixdfsi(void)

{
  uint in_a0;
  uint in_a1;
  uint uVar1;
  uint uVar2;
  
  uVar1 = in_a1 >> 0x14 & 0x7ff;
  if (uVar1 < 0x3ff) {
    if ((uVar1 != 0) || (uVar2 = in_a1 & 0xfffff | in_a0, uVar2 != 0)) {
      uVar2 = 0;
    }
  }
  else {
    if (uVar1 < 0x41e) {
      uVar2 = in_a1 & 0xfffff | 0x100000;
      if ((int)(0x433 - uVar1) < 0x20) {
        uVar2 = uVar2 << (uVar1 - 0x413 & 0x1f) | in_a0 >> (0x433 - uVar1 & 0x1f);
      }
      else {
        uVar2 = uVar2 >> (0x413 - uVar1 & 0x1f);
      }
      if (-((int)in_a1 >> 0x1f) != 0) {
        uVar2 = -uVar2;
      }
    }
    else {
      uVar2 = -((int)in_a1 >> 0x1f) + 0x7fffffff;
    }
  }
  return uVar2;
}



USItype __fixunsdfsi(void)

{
  uint in_a0;
  USItype UVar1;
  uint in_a1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  
  uVar3 = in_a1 >> 0x14 & 0x7ff;
  if (uVar3 < 0x3ff) {
    if ((uVar3 == 0) && ((in_a1 & 0xfffff | in_a0) == 0)) {
      return 0;
    }
    UVar1 = 0;
  }
  else {
    if ((int)in_a1 < 0) {
      UVar1 = 0;
    }
    else {
      if (uVar3 < 0x41f) {
        uVar5 = in_a1 & 0xfffff | 0x100000;
        uVar2 = 0x433 - uVar3;
        if ((int)uVar2 < 0x20) {
          uVar4 = in_a0 << (uVar3 - 0x413 & 0x1f);
          UVar1 = uVar5 << (uVar3 - 0x413 & 0x1f) | in_a0 >> (uVar2 & 0x1f);
        }
        else {
          uVar4 = 0;
          if (uVar2 != 0x20) {
            uVar4 = uVar5 << (uVar3 - 0x3f3 & 0x1f);
          }
          uVar4 = uVar4 | in_a0;
          UVar1 = uVar5 >> (0x413 - uVar3 & 0x1f);
        }
        if (uVar4 == 0) {
          return UVar1;
        }
      }
      else {
        UVar1 = 0xffffffff;
      }
    }
  }
  return UVar1;
}



DFtype __floatsidf(SItype i)

{
  DFtype in_fa0;
  
  if (i != 0) {
    __clzsi2((i >> 0x1f ^ i) - (i >> 0x1f));
  }
  return in_fa0;
}



DFtype __floatunsidf(USItype i)

{
  DFtype in_fa0;
  
  if (i != 0) {
    __clzsi2(i);
  }
  return in_fa0;
}


/*
Unable to decompile '__extendsfdf2'
Cause: Exception while decompiling 2306ca0c: Decompiler process died

*/


SFtype __truncdfsf2(void)

{
  uint uVar1;
  SFtype in_a0;
  uint in_a1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;
  int in_frm;
  
  uVar1 = in_a1 >> 0x14 & 0x7ff;
  uVar3 = (uint)in_a0 >> 0x1d | (in_a1 & 0xfffff) << 3;
  uVar5 = (int)in_a0 << 3;
  if ((uVar1 + 1 & 0x7fe) == 0) {
    uVar3 = uVar3 | uVar5;
    if (uVar1 == 0) {
      uVar1 = (uint)(uVar3 != 0);
LAB_2306cc6c:
      if (uVar1 == 0) {
        return in_a0;
      }
LAB_2306cc70:
      if (((((uVar1 * 2 & 7) != 0) && (in_frm != 2)) && (in_frm != 3)) && (in_frm == 0)) {
        in_a0 = 0.00000000;
      }
    }
    else {
      if (uVar3 == 0) {
        return in_a0;
      }
      uVar1 = 0;
    }
  }
  else {
    iVar6 = uVar1 - 0x380;
    if (0xfe < iVar6) {
      if (in_frm == 0) {
        return in_a0;
      }
      if (in_frm == 3) {
        if (-1 < (int)in_a1) {
          return in_a0;
        }
      }
      else {
        if ((in_frm == 2) && ((int)in_a1 < 0)) {
          return in_a0;
        }
      }
      goto LAB_2306cb7c;
    }
    if (iVar6 < 1) {
      if (-0x18 < iVar6) {
        uVar3 = uVar3 | 0x800000;
        uVar2 = 0x1e - iVar6;
        if ((int)uVar2 < 0x20) {
          uVar1 = uVar5 >> (uVar2 & 0x1f) |
                  (uint)(uVar5 << (uVar1 - 0x37e & 0x1f) != 0) | uVar3 << (uVar1 - 0x37e & 0x1f);
        }
        else {
          in_a0 = 0.00000000;
          uVar4 = 0;
          if (uVar2 != 0x20) {
            uVar4 = uVar3 << (uVar1 - 0x35e & 0x1f);
          }
          uVar1 = uVar3 >> (-iVar6 - 2U & 0x1f) | (uint)((uVar4 | uVar5) != 0);
        }
        goto LAB_2306cc6c;
      }
      uVar1 = 1;
      goto LAB_2306cc70;
    }
    in_a0 = (SFtype)(uint)(((uint)in_a0 & 0x3ffffff) != 0);
    uVar1 = (uint)in_a0 | uVar5 >> 0x1d;
  }
  if ((uVar1 & 7) == 0) {
    return in_a0;
  }
LAB_2306cb7c:
  if (((in_frm != 2) && (in_frm != 3)) && (in_frm == 0)) {
    in_a0 = 0.00000000;
  }
  return in_a0;
}



int atoi(char *__nptr)

{
  long lVar1;
  
  lVar1 = strtol(__nptr,(char **)0x0,10);
  return lVar1;
}



void _atoi_r(void)

{
  _strtol_r(0,10);
  return;
}



undefined * __errno(void)

{
  return _impure_ptr;
}



void * memchr(void *__s,int __c,size_t __n)

{
  byte bVar1;
  uint uVar2;
  uint uVar3;
  uint *puVar4;
  uint uVar5;
  
  uVar5 = __c & 0xff;
  if (((uint)__s & 3) != 0) {
    if (__n == 0) {
      return (void *)0x0;
    }
    bVar1 = *(byte *)__s;
    __n = __n - 1;
    while( true ) {
      if ((uint)bVar1 == uVar5) {
        return (uint *)__s;
      }
      __s = (void *)((int)__s + 1);
      if (((uint)__s & 3) == 0) break;
      __n = __n - 1;
      if (__n == 0xffffffff) {
        return (void *)0x0;
      }
      bVar1 = *(byte *)__s;
    }
  }
  if (3 < __n) {
    uVar2 = (__c & 0xffU) << 8 | __c & 0xffU;
    do {
      uVar3 = (uVar2 << 0x10 | uVar2) ^ *(uint *)__s;
      if ((uVar3 + 0xfefefeff & ~uVar3 & 0x80808080) != 0) goto LAB_2306ce68;
      __n = __n - 4;
      __s = (uint *)__s + 1;
    } while (3 < __n);
  }
  if (__n != 0) {
LAB_2306ce68:
    if ((uint)*(byte *)__s == uVar5) {
      return (uint *)__s;
    }
    puVar4 = (uint *)((int)__s + __n);
    while (__s = (void *)((int)__s + 1), puVar4 != (uint *)__s) {
      if ((uint)*(byte *)__s == uVar5) {
        return (uint *)__s;
      }
    }
  }
  return (void *)0x0;
}



int memcmp(void *__s1,void *__s2,size_t __n)

{
  int *piVar1;
  uint uVar2;
  uint uVar3;
  
  if (3 < __n) {
    if ((((uint)__s1 | (uint)__s2) & 3) != 0) goto LAB_2306cf34;
    do {
      if (*(int *)__s1 != *(int *)__s2) goto LAB_2306cf34;
      __n = __n - 4;
      __s1 = (int *)__s1 + 1;
      __s2 = (int *)__s2 + 1;
    } while (3 < __n);
  }
  if (__n == 0) {
    return 0;
  }
LAB_2306cf34:
  uVar3 = (uint)*(byte *)__s1;
  uVar2 = (uint)*(byte *)__s2;
  if (uVar3 == uVar2) {
    piVar1 = (int *)((int)__s1 + __n);
    do {
      __s1 = (void *)((int)__s1 + 1);
      __s2 = (void *)((int)__s2 + 1);
      if ((int *)__s1 == piVar1) {
        return 0;
      }
      uVar3 = (uint)*(byte *)__s1;
      uVar2 = (uint)*(byte *)__s2;
    } while (uVar3 == uVar2);
  }
  return uVar3 - uVar2;
}



void * memcpy(void *__dest,void *__src,size_t __n)

{
  undefined uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 *puVar4;
  undefined4 *puVar5;
  undefined4 uVar6;
  undefined4 *puVar7;
  uint uVar8;
  undefined4 *puVar9;
  undefined4 *puVar10;
  int iVar11;
  undefined4 uVar12;
  undefined4 *puVar13;
  undefined4 uVar14;
  undefined4 uVar15;
  undefined4 uVar16;
  undefined4 uVar17;
  
  puVar13 = (undefined4 *)((int)__dest + __n);
  if (((((uint)__src ^ (uint)__dest) & 3) == 0) && (3 < __n)) {
    uVar8 = (uint)__dest & 3;
    puVar5 = (undefined4 *)__dest;
    while (puVar4 = (undefined4 *)__src, puVar7 = puVar5, uVar8 != 0) {
      puVar7 = (undefined4 *)((int)puVar5 + 1);
      *(undefined *)puVar5 = *(undefined *)__src;
      puVar4 = (undefined4 *)((int)__src + 1);
      if (((uint)puVar7 & 3) == 0) break;
      uVar8 = (uint)(undefined4 *)((int)puVar5 + 2) & 3;
      *(undefined *)((int)puVar5 + 1) = *(undefined *)puVar4;
      __src = (void *)((int)__src + 2);
      puVar5 = (undefined4 *)((int)puVar5 + 2);
    }
    puVar5 = (undefined4 *)((uint)puVar13 & 0xfffffffc);
    __src = puVar4;
    while (puVar7 < puVar5 + -8) {
      uVar2 = ((undefined4 *)__src)[1];
      uVar17 = ((undefined4 *)__src)[2];
      uVar16 = ((undefined4 *)__src)[3];
      uVar15 = ((undefined4 *)__src)[4];
      uVar14 = ((undefined4 *)__src)[5];
      uVar3 = ((undefined4 *)__src)[6];
      uVar12 = ((undefined4 *)__src)[7];
      *puVar7 = *(undefined4 *)__src;
      uVar6 = ((undefined4 *)__src)[8];
      puVar7[1] = uVar2;
      puVar7[2] = uVar17;
      puVar7[3] = uVar16;
      puVar7[4] = uVar15;
      puVar7[5] = uVar14;
      puVar7[6] = uVar3;
      puVar7[7] = uVar12;
      puVar7[8] = uVar6;
      __src = (undefined4 *)__src + 9;
      puVar7 = puVar7 + 9;
    }
    puVar4 = (undefined4 *)__src;
    puVar9 = puVar7;
    if (puVar7 < puVar5) {
      do {
        puVar10 = puVar9 + 1;
        *puVar9 = *puVar4;
        puVar4 = puVar4 + 1;
        puVar9 = puVar10;
      } while (puVar10 < puVar5);
      iVar11 = ((int)puVar5 + (-1 - (int)puVar7) & 0xfffffffcU) + 4;
      puVar7 = (undefined4 *)((int)puVar7 + iVar11);
      __src = (void *)((int)__src + iVar11);
    }
    if (puVar7 < puVar13) {
LAB_2306cff8:
      do {
        uVar1 = *(undefined *)__src;
        puVar5 = (undefined4 *)((int)puVar7 + 1);
        __src = (void *)((int)__src + 1);
        *(undefined *)puVar7 = uVar1;
        puVar7 = puVar5;
      } while (puVar5 < puVar13);
      return __dest;
    }
  }
  else {
    puVar7 = (undefined4 *)__dest;
    if (__dest < puVar13) goto LAB_2306cff8;
  }
  return __dest;
}



void * memmove(void *__dest,void *__src,size_t __n)

{
  int iVar1;
  undefined *puVar2;
  undefined4 *puVar3;
  undefined *puVar4;
  undefined4 *puVar5;
  undefined4 *puVar6;
  uint uVar7;
  
  if ((__src < __dest) && (puVar4 = (undefined *)((int)__src + __n), __dest < puVar4)) {
    puVar2 = (undefined *)((int)__dest + __n);
    if (__n == 0) {
      return __dest;
    }
    do {
      puVar4 = puVar4 + -1;
      puVar2 = puVar2 + -1;
      *puVar2 = *puVar4;
    } while ((undefined *)__src != puVar4);
    return __dest;
  }
  uVar7 = __n;
  puVar5 = (undefined4 *)__dest;
  if (0xf < __n) {
    if ((((uint)__src | (uint)__dest) & 3) != 0) {
      iVar1 = __n - 1;
      goto LAB_2306d0dc;
    }
    iVar1 = (__n - 0x10 & 0xfffffff0) + 0x10;
    puVar3 = (undefined4 *)__src;
    puVar6 = (undefined4 *)__dest;
    do {
      puVar5 = puVar6 + 4;
      *puVar6 = *puVar3;
      puVar6[1] = puVar3[1];
      puVar6[2] = puVar3[2];
      puVar6[3] = puVar3[3];
      puVar3 = puVar3 + 4;
      puVar6 = puVar5;
    } while ((undefined4 *)((int)__dest + iVar1) != puVar5);
    __src = (void *)((int)__src + iVar1);
    uVar7 = __n & 0xf;
    puVar3 = (undefined4 *)__src;
    if ((__n & 0xc) != 0) {
      do {
        puVar3 = puVar3 + 1;
        *puVar6 = *puVar3;
        puVar3 = puVar3;
        puVar6 = puVar6 + 1;
      } while (3 < (int)__src + (uVar7 - (int)puVar3));
      iVar1 = (uVar7 - 4 & 0xfffffffc) + 4;
      __src = (void *)((int)__src + iVar1);
      uVar7 = __n & 3;
      puVar5 = (undefined4 *)((int)puVar5 + iVar1);
    }
  }
  iVar1 = uVar7 - 1;
  if (uVar7 == 0) {
    return __dest;
  }
LAB_2306d0dc:
  puVar3 = puVar5;
  do {
    puVar6 = (undefined4 *)((int)puVar3 + 1);
    *(undefined *)puVar3 = *(undefined *)__src;
    __src = (undefined4 *)((int)__src + 1);
    puVar3 = puVar6;
  } while (puVar6 != (undefined4 *)((int)puVar5 + iVar1 + 1));
  return __dest;
}



void * memset(void *__s,int __c,size_t __n)

{
  uint uVar1;
  uint extraout_a1;
  uint *puVar2;
  uint *puVar3;
  void *pvVar4;
  uint uVar5;
  
  uVar1 = 0xf;
  if (0xf < __n) {
    uVar5 = (uint)__s & 0xf;
    puVar3 = (uint *)__s;
    if (uVar5 != 0) {
      pvVar4 = __s;
      __s = (void *)(*(code *)(uVar5 * 4 + 0x2306d210))();
      puVar3 = (uint *)((int)pvVar4 - (uVar5 - 0x10));
      __n = __n + (uVar5 - 0x10);
      __c = extraout_a1;
      if (__n <= uVar1) goto LAB_2306d200;
    }
    if (__c != 0) {
      uVar5 = __c & 0xffU | (__c & 0xffU) << 8;
      __c = uVar5 | uVar5 << 0x10;
    }
    uVar5 = __n & 0xfffffff0;
    __n = __n & 0xf;
    puVar2 = (uint *)(uVar5 + (int)puVar3);
    do {
      *puVar3 = __c;
      puVar3[1] = __c;
      puVar3[2] = __c;
      puVar3[3] = __c;
      puVar3 = puVar3 + 4;
    } while (puVar3 < puVar2);
    if (__n == 0) {
      return __s;
    }
  }
LAB_2306d200:
                    // WARNING: Could not recover jumptable at 0x2306d210. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar4 = (void *)(*(code *)(&UNK_2306d214 + (uVar1 - __n) * 4))();
  return pvVar4;
}



char * strchr(char *__s,int __c)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  
  uVar3 = __c & 0xff;
  if (uVar3 == 0) {
    if (((uint)__s & 3) != 0) {
      if (*__s == '\0') {
        return __s;
      }
      while (__s = (char *)((int)__s + 1), ((uint)__s & 3) != 0) {
        if (*__s == '\0') {
          return (char *)(uint *)__s;
        }
      }
    }
    uVar3 = *(uint *)__s + 0xfefefeff & ~*(uint *)__s;
    while ((uVar3 & 0x80808080) == 0) {
      __s = (char *)((uint *)__s + 1);
      uVar3 = *(uint *)__s + 0xfefefeff & ~*(uint *)__s;
    }
    if (*__s != '\0') {
      do {
        __s = (char *)((int)__s + 1);
      } while (*__s != '\0');
      return __s;
    }
    return (char *)(uint *)__s;
  }
  if (((uint)__s & 3) != 0) {
    if (*__s == 0) {
      return (char *)0x0;
    }
    if (uVar3 == (uint)(byte)*__s) {
      return __s;
    }
    while (__s = (char *)((int)__s + 1), ((uint)__s & 3) != 0) {
      if (*__s == 0) {
        return (char *)0x0;
      }
      if ((uint)(byte)*__s == uVar3) {
        return (char *)(uint *)__s;
      }
    }
  }
  uVar1 = __c & 0xffU | (__c & 0xffU) << 8;
  uVar4 = *(uint *)__s;
  uVar1 = uVar1 << 0x10 | uVar1;
  uVar2 = uVar1 ^ uVar4;
  uVar2 = ~uVar4 & uVar4 + 0xfefefeff | ~uVar2 & uVar2 + 0xfefefeff;
  while ((uVar2 & 0x80808080) == 0) {
    __s = (char *)((uint *)__s + 1);
    uVar4 = *(uint *)__s;
    uVar2 = uVar4 ^ uVar1;
    uVar2 = uVar4 + 0xfefefeff & ~uVar4 | uVar2 + 0xfefefeff & ~uVar2;
  }
  if (*__s != 0) {
    if (uVar3 == (uint)(byte)*__s) {
      return (char *)(uint *)__s;
    }
    while( true ) {
      __s = (char *)((int)__s + 1);
      if (*__s == 0) break;
      if ((uint)(byte)*__s == uVar3) {
        return __s;
      }
    }
  }
  return (char *)0x0;
}



int strcmp(char *__s1,char *__s2)

{
  byte bVar1;
  byte bVar2;
  uint uVar3;
  uint uVar4;
  
  if ((((uint)__s1 | (uint)__s2) & 3) == 0) {
    do {
      uVar3 = *(uint *)__s1;
      uVar4 = *(uint *)__s2;
      if (((uVar3 & 0x7f7f7f7f) + 0x7f7f7f7f | uVar3 | 0x7f7f7f7f) != 0xffffffff) {
LAB_2306d538:
        if (uVar3 == uVar4) {
          return 0;
        }
        goto LAB_2306d510;
      }
      if (uVar3 != uVar4) break;
      uVar3 = ((uint *)__s1)[1];
      uVar4 = ((uint *)__s2)[1];
      if (((uVar3 & 0x7f7f7f7f) + 0x7f7f7f7f | uVar3 | 0x7f7f7f7f) != 0xffffffff) {
        __s1 = (char *)((uint *)__s1 + 1);
        __s2 = (char *)((uint *)__s2 + 1);
        goto LAB_2306d538;
      }
      if (uVar3 != uVar4) break;
      uVar3 = ((uint *)__s1)[2];
      uVar4 = ((uint *)__s2)[2];
      if (((uVar3 & 0x7f7f7f7f) + 0x7f7f7f7f | uVar3 | 0x7f7f7f7f) != 0xffffffff) {
        __s1 = (char *)((uint *)__s1 + 2);
        __s2 = (char *)((uint *)__s2 + 2);
        if (uVar3 == uVar4) {
          return 0;
        }
        goto LAB_2306d510;
      }
      if (uVar3 != uVar4) break;
      uVar3 = ((uint *)__s1)[3];
      uVar4 = ((uint *)__s2)[3];
      if (((uVar3 & 0x7f7f7f7f) + 0x7f7f7f7f | uVar3 | 0x7f7f7f7f) != 0xffffffff) {
        __s1 = (char *)((uint *)__s1 + 3);
        __s2 = (char *)((uint *)__s2 + 3);
        if (uVar3 == uVar4) {
          return 0;
        }
        goto LAB_2306d510;
      }
      if (uVar3 != uVar4) break;
      uVar3 = ((uint *)__s1)[4];
      uVar4 = ((uint *)__s2)[4];
      if (((uVar3 & 0x7f7f7f7f) + 0x7f7f7f7f | uVar3 | 0x7f7f7f7f) != 0xffffffff) {
        __s1 = (char *)((uint *)__s1 + 4);
        __s2 = (char *)((uint *)__s2 + 4);
        if (uVar3 == uVar4) {
          return 0;
        }
        goto LAB_2306d510;
      }
      __s1 = (char *)((uint *)__s1 + 5);
      __s2 = (char *)((uint *)__s2 + 5);
    } while (uVar3 == uVar4);
    if (uVar3 << 0x10 == uVar4 << 0x10) {
      uVar3 = uVar3 >> 0x10;
      uVar4 = uVar4 >> 0x10;
      if ((uVar3 - uVar4 & 0xff) == 0) {
        return uVar3 - uVar4;
      }
    }
    else {
      uVar3 = uVar3 & 0xffff;
      uVar4 = uVar4 & 0xffff;
      if ((uVar3 - uVar4 & 0xff) == 0) {
        return uVar3 - uVar4;
      }
    }
    return (uVar3 & 0xff) - (uVar4 & 0xff);
  }
LAB_2306d510:
  do {
    bVar1 = *__s1;
    bVar2 = *__s2;
    __s1 = (char *)((int)__s1 + 1);
    __s2 = (char *)((int)__s2 + 1);
    if ((uint)bVar1 != (uint)bVar2) break;
  } while (bVar1 != 0);
  return (uint)bVar1 - (uint)bVar2;
}



char * strcpy(char *__dest,char *__src)

{
  char cVar1;
  char cVar2;
  char cVar3;
  uint *puVar4;
  uint uVar5;
  uint uVar6;
  char *pcVar7;
  
  pcVar7 = __dest;
  if ((((uint)__dest | (uint)__src) & 3) != 0) {
    do {
      cVar1 = *__src;
      __src = __src + 1;
      *pcVar7 = cVar1;
      pcVar7 = pcVar7 + 1;
    } while (cVar1 != '\0');
    return __dest;
  }
  uVar5 = *(uint *)__src;
  uVar6 = (uVar5 & 0x7f7f7f7f) + 0x7f7f7f7f | uVar5;
  puVar4 = (uint *)__dest;
  while ((uVar6 | 0x7f7f7f7f) == 0xffffffff) {
    __src = (char *)((uint *)__src + 1);
    *puVar4 = uVar5;
    uVar5 = *(uint *)__src;
    uVar6 = (uVar5 & 0x7f7f7f7f) + 0x7f7f7f7f | uVar5;
    puVar4 = puVar4 + 1;
  }
  cVar1 = *__src;
  cVar2 = *(char *)((int)__src + 1);
  cVar3 = *(char *)((int)__src + 2);
  *(char *)puVar4 = cVar1;
  if (((cVar1 != '\0') && (*(char *)((int)puVar4 + 1) = cVar2, cVar2 != '\0')) &&
     (*(char *)((int)puVar4 + 2) = cVar3, cVar3 != '\0')) {
    *(char *)((int)puVar4 + 3) = '\0';
    return __dest;
  }
  return __dest;
}



size_t strlen(char *__s)

{
  char cVar1;
  uint *puVar2;
  uint *puVar3;
  uint uVar4;
  
  uVar4 = (uint)__s & 3;
  puVar3 = (uint *)__s;
  while (uVar4 != 0) {
    cVar1 = *(char *)puVar3;
    puVar3 = (uint *)((int)puVar3 + 1);
    uVar4 = (uint)puVar3 & 3;
    if (cVar1 == '\0') {
      return (int)puVar3 + (-1 - (int)__s);
    }
  }
  do {
    puVar2 = puVar3;
    puVar3 = puVar2 + 1;
  } while (((*puVar2 & 0x7f7f7f7f) + 0x7f7f7f7f | *puVar2 | 0x7f7f7f7f) == 0xffffffff);
  puVar3 = (uint *)((int)(puVar2 + 1) - (int)__s);
  if (*(char *)puVar2 != '\0') {
    if (*(char *)((int)puVar2 + 1) != '\0') {
      return (int)puVar3 + ((uint)(*(char *)((int)puVar2 + 2) != '\0') - 2);
    }
    return (size_t)((int)puVar3 + -3);
  }
  return (size_t)(puVar3 + -1);
}



int strncmp(char *__s1,char *__s2,size_t __n)

{
  int iVar1;
  uint *puVar2;
  uint uVar3;
  uint uVar4;
  
  if (__n == 0) {
    return 0;
  }
  if (((((uint)__s1 | (uint)__s2) & 3) == 0) && (3 < __n)) {
    uVar4 = *(uint *)__s1;
    if (uVar4 != *(uint *)__s2) {
LAB_2306d798:
      uVar3 = (uint)(byte)*__s1;
      uVar4 = (uint)(byte)*__s2;
      iVar1 = __n - 1;
      if (uVar4 == uVar3) goto LAB_2306d75c;
      goto LAB_2306d788;
    }
    __n = __n - 4;
    if (__n == 0) {
      return 0;
    }
    uVar4 = uVar4 + 0xfefefeff & ~uVar4;
    while( true ) {
      if ((uVar4 & 0x80808080) != 0) {
        return 0;
      }
      __s1 = (char *)((uint *)__s1 + 1);
      __s2 = (char *)((uint *)__s2 + 1);
      if (__n < 4) break;
      uVar3 = *(uint *)__s1;
      uVar4 = uVar3 + 0xfefefeff & ~uVar3;
      if (uVar3 != *(uint *)__s2) goto LAB_2306d798;
      __n = __n - 4;
      if (__n == 0) {
        return 0;
      }
    }
  }
  uVar3 = (uint)(byte)*__s1;
  uVar4 = (uint)(byte)*__s2;
  iVar1 = __n - 1;
  if (uVar4 == uVar3) {
    if (iVar1 == 0) {
      return 0;
    }
LAB_2306d75c:
    if (uVar3 != 0) {
      puVar2 = (uint *)((int)__s1 + iVar1);
      do {
        __s1 = (char *)((int)__s1 + 1);
        __s2 = (char *)((int)__s2 + 1);
        uVar3 = (uint)(byte)*__s1;
        uVar4 = (uint)(byte)*__s2;
        if (uVar3 != uVar4) goto LAB_2306d788;
      } while ((puVar2 != (uint *)__s1) && (*__s1 != 0));
    }
    return 0;
  }
LAB_2306d788:
  return uVar3 - uVar4;
}



char * strncpy(char *__dest,char *__src,size_t __n)

{
  char cVar1;
  uint uVar2;
  uint *puVar3;
  uint *puVar4;
  char *pcVar5;
  char *pcVar6;
  char *pcVar7;
  int iVar8;
  
  puVar3 = (uint *)__dest;
  if (((((uint)__src | (uint)__dest) & 3) == 0) && (puVar4 = (uint *)__dest, 3 < __n)) {
    do {
      uVar2 = *(uint *)__src;
      if ((uVar2 + 0xfefefeff & ~uVar2 & 0x80808080) != 0) goto LAB_2306d7c8;
      puVar3 = puVar4 + 1;
      __n = __n - 4;
      *puVar4 = uVar2;
      __src = (char *)((uint *)__src + 1);
      puVar4 = puVar3;
    } while (3 < __n);
  }
  puVar4 = puVar3;
  if (__n != 0) {
LAB_2306d7c8:
    cVar1 = *__src;
    *(char *)puVar4 = cVar1;
    pcVar5 = (char *)((int)puVar4 + 1);
    iVar8 = __n - 1;
    if (cVar1 != '\0') {
      pcVar6 = pcVar5;
      do {
        __src = (char *)((int)__src + 1);
        iVar8 = (__n - 1) - (int)pcVar6;
        if (pcVar6 == (char *)((int)puVar4 + __n)) {
          return __dest;
        }
        cVar1 = *__src;
        pcVar5 = pcVar6 + 1;
        *pcVar6 = cVar1;
        pcVar6 = pcVar5;
        iVar8 = (int)puVar4 + iVar8;
      } while (cVar1 != '\0');
    }
    pcVar6 = pcVar5;
    if (iVar8 == 0) {
      return __dest;
    }
    do {
      pcVar7 = pcVar6 + 1;
      *pcVar6 = '\0';
      pcVar6 = pcVar7;
    } while (pcVar7 != pcVar5 + iVar8);
  }
  return __dest;
}



size_t strnlen(char *__string,size_t __maxlen)

{
  char *pcVar1;
  
  if (__maxlen != 0) {
    if (*__string == '\0') {
      __maxlen = 0;
    }
    else {
      pcVar1 = __string;
      while (pcVar1 = pcVar1 + 1, pcVar1 != __string + __maxlen) {
        if (*pcVar1 == '\0') {
          return (size_t)(pcVar1 + -(int)__string);
        }
      }
    }
  }
  return __maxlen;
}



char * strrchr(char *__s,int __c)

{
  char *pcVar1;
  char *pcVar2;
  
  if (__c != 0) {
    pcVar2 = (char *)0x0;
    while (pcVar1 = strchr(__s,__c), pcVar1 != (char *)0x0) {
      __s = pcVar1 + 1;
      pcVar2 = pcVar1;
    }
    return pcVar2;
  }
  pcVar2 = strchr(__s,0);
  return pcVar2;
}



byte * two_way_long_needle(int param_1,int param_2,byte *param_3,byte *param_4)

{
  byte bVar1;
  byte bVar2;
  int iVar3;
  size_t sVar4;
  byte *pbVar5;
  byte *pbVar6;
  byte *__n;
  byte *pbVar7;
  byte *pbVar8;
  byte **ppbVar9;
  byte *pbVar10;
  byte *pbVar11;
  byte *pbVar12;
  byte *pbVar13;
  byte *pbVar14;
  byte *local_440 [256];
  byte *apbStack64 [3];
  
  pbVar13 = (byte *)0x1;
  pbVar6 = (byte *)0x1;
  __n = (byte *)0x0;
  pbVar11 = (byte *)0xffffffff;
  do {
    pbVar14 = pbVar6 + (int)pbVar11;
    pbVar10 = pbVar6 + (int)__n;
    pbVar12 = __n;
    while( true ) {
      __n = pbVar10;
      if (param_4 <= __n) {
        pbVar6 = (byte *)0x1;
        __n = (byte *)0x1;
        pbVar14 = (byte *)0xffffffff;
        pbVar12 = (byte *)0x0;
        goto LAB_2306d9bc;
      }
      if (param_3[(int)pbVar14] <= param_3[(int)__n]) break;
      pbVar6 = (byte *)0x1;
      pbVar13 = __n + -(int)pbVar11;
      pbVar14 = pbVar11 + 1;
      pbVar10 = __n + 1;
      pbVar12 = __n;
    }
    if (param_3[(int)__n] == param_3[(int)pbVar14]) {
      if (pbVar6 == pbVar13) {
        pbVar6 = (byte *)0x1;
      }
      else {
        pbVar6 = pbVar6 + 1;
        __n = pbVar12;
      }
    }
    else {
      pbVar13 = (byte *)0x1;
      pbVar6 = (byte *)0x1;
      __n = pbVar12 + 1;
      pbVar11 = pbVar12;
    }
  } while( true );
LAB_2306d9bc:
  pbVar5 = __n + (int)pbVar14;
  pbVar7 = __n + (int)pbVar12;
  pbVar10 = pbVar12;
  while (pbVar12 = pbVar7, pbVar12 < param_4) {
    if (param_3[(int)pbVar12] <= param_3[(int)pbVar5]) goto LAB_2306db90;
    __n = (byte *)0x1;
    pbVar6 = pbVar12 + -(int)pbVar14;
    pbVar5 = pbVar14 + 1;
    pbVar7 = pbVar12 + 1;
    pbVar10 = pbVar12;
  }
  __n = pbVar11 + 1;
  if (pbVar11 + 1 <= pbVar14 + 1) {
    pbVar13 = pbVar6;
    __n = pbVar14 + 1;
  }
  ppbVar9 = local_440;
  do {
    *ppbVar9 = param_4;
    ppbVar9 = ppbVar9 + 1;
  } while (apbStack64 != ppbVar9);
  pbVar11 = param_4 + -1;
  pbVar6 = param_3;
  if (param_4 != (byte *)0x0) {
    do {
      bVar1 = *pbVar6;
      iVar3 = -(int)pbVar6;
      pbVar6 = pbVar6 + 1;
      local_440[bVar1] = param_3 + (int)(pbVar11 + iVar3);
    } while (pbVar6 != param_3 + (int)param_4);
  }
  iVar3 = memcmp(param_3,param_3 + (int)pbVar13,(size_t)__n);
  if (iVar3 != 0) {
    pbVar13 = param_4 + -(int)__n;
    if (param_4 + -(int)__n < __n) {
      pbVar13 = __n;
    }
    pbVar6 = __n + -1;
    pbVar12 = (byte *)0x0;
LAB_2306dc50:
    pbVar14 = pbVar12 + param_1;
    pbVar10 = local_440[pbVar11[(int)pbVar14]];
    if (pbVar10 == (byte *)0x0) goto LAB_2306dcb4;
    do {
      pbVar12 = pbVar10 + (int)pbVar12;
      while( true ) {
        if (pbVar12 <= (byte *)(param_2 - (int)param_4)) goto LAB_2306dc50;
        sVar4 = strnlen((char *)(param_1 + param_2),(uint)param_4 | 0x800);
        param_2 = param_2 + sVar4;
        if ((byte *)(param_2 - (int)param_4) < pbVar12) {
          return (byte *)0;
        }
        pbVar14 = pbVar12 + param_1;
        pbVar10 = local_440[pbVar11[(int)pbVar14]];
        if (pbVar10 != (byte *)0x0) break;
LAB_2306dcb4:
        if (__n < pbVar11) {
          pbVar10 = __n;
          if (__n[(int)pbVar14] == param_3[(int)__n]) {
            do {
              pbVar10 = pbVar10 + 1;
              if (pbVar11 <= pbVar10) goto LAB_2306dcf4;
            } while (param_3[(int)pbVar10] == pbVar10[(int)(pbVar12 + param_1)]);
          }
          pbVar12 = pbVar10 + (int)(pbVar12 + (1 - (int)__n));
        }
        else {
LAB_2306dcf4:
          if (pbVar6 == (byte *)0xffffffff) {
            return pbVar14;
          }
          if (pbVar6[(int)pbVar14] == param_3[(int)pbVar6]) {
            pbVar5 = param_3 + (int)(__n + -2);
            pbVar10 = __n + -2 + (int)(pbVar12 + param_1);
            do {
              if (pbVar5 == param_3 + -1) {
                return pbVar14;
              }
              bVar1 = *pbVar5;
              bVar2 = *pbVar10;
              pbVar5 = pbVar5 + -1;
              pbVar10 = pbVar10 + -1;
            } while (bVar1 == bVar2);
          }
          pbVar12 = pbVar13 + (int)(pbVar12 + 1);
        }
      }
    } while( true );
  }
  pbVar6 = __n + -1;
  pbVar12 = (byte *)0x0;
  pbVar14 = (byte *)0x0;
  do {
    pbVar5 = pbVar14 + param_1;
    pbVar10 = local_440[pbVar11[(int)pbVar5]];
    if (pbVar10 == (byte *)0x0) {
      pbVar10 = pbVar12;
      if (pbVar12 < __n) {
        pbVar10 = __n;
      }
      if (pbVar10 < pbVar11) {
        pbVar7 = pbVar10 + (int)(pbVar14 + param_1);
        pbVar8 = param_3 + (int)pbVar10;
        do {
          if (*pbVar7 != *pbVar8) {
            pbVar14 = pbVar14 + (1 - (int)__n);
            goto LAB_2306dac8;
          }
          pbVar10 = pbVar10 + 1;
          pbVar7 = param_3 + (int)pbVar10;
          pbVar8 = pbVar10 + (int)(pbVar14 + param_1);
        } while (pbVar10 < pbVar11);
      }
      if ((pbVar12 < __n) &&
         (pbVar10 = pbVar6, pbVar6[(int)(pbVar14 + param_1)] == param_3[(int)pbVar6])) {
        do {
          pbVar7 = pbVar10;
          pbVar10 = pbVar7 + -1;
          if (pbVar12 == pbVar7) break;
        } while (param_3[(int)pbVar10] == pbVar10[(int)(pbVar14 + param_1)]);
        if (pbVar7 < pbVar12 + 1) {
          return pbVar5;
        }
      }
      else {
        if (__n < pbVar12 + 1) {
          return pbVar5;
        }
      }
      pbVar14 = pbVar13 + (int)pbVar14;
      pbVar12 = param_4 + -(int)pbVar13;
    }
    else {
      if ((pbVar12 != (byte *)0x0) && (pbVar10 < pbVar13)) {
        pbVar10 = param_4 + -(int)pbVar13;
      }
LAB_2306dac8:
      pbVar14 = pbVar10 + (int)pbVar14;
      pbVar12 = (byte *)0x0;
    }
    if ((byte *)(param_2 - (int)param_4) < pbVar14) {
      sVar4 = strnlen((char *)(param_1 + param_2),(uint)param_4 | 0x800);
      param_2 = param_2 + sVar4;
      if ((byte *)(param_2 - (int)param_4) < pbVar14) {
        return (byte *)0;
      }
    }
  } while( true );
LAB_2306db90:
  if (param_3[(int)pbVar12] == param_3[(int)pbVar5]) {
    if (__n == pbVar6) {
      __n = (byte *)0x1;
    }
    else {
      __n = __n + 1;
      pbVar12 = pbVar10;
    }
  }
  else {
    pbVar6 = (byte *)0x1;
    __n = (byte *)0x1;
    pbVar14 = pbVar10;
    pbVar12 = pbVar10 + 1;
  }
  goto LAB_2306d9bc;
}



char * strstr(char *__haystack,char *__needle)

{
  byte bVar1;
  byte bVar2;
  char cVar3;
  size_t __n;
  size_t sVar4;
  int iVar5;
  uint __c;
  char *pcVar6;
  uint uVar7;
  byte *pbVar8;
  uint uVar9;
  char *pcVar10;
  byte abStack96 [68];
  
  __c = (uint)(byte)*__needle;
  if (*__needle != 0) {
    uVar7 = (uint)(byte)__needle[1];
    if (__needle[1] == 0) {
      __haystack = strchr(__haystack,__c);
    }
    else {
      bVar1 = __needle[2];
      if (bVar1 == 0) {
        uVar9 = (uint)(byte)*__haystack;
        if (*__haystack != 0) {
          bVar1 = __haystack[1];
          pcVar10 = __haystack + 1;
          while (pcVar6 = pcVar10, uVar9 = (uint)bVar1 | uVar9 << 0x10, bVar1 != 0) {
            bVar1 = pcVar6[1];
            pcVar10 = pcVar6 + 1;
            if ((__c << 0x10 | uVar7) == uVar9) {
              return pcVar6 + -1;
            }
          }
        }
      }
      else {
        if (__needle[3] == 0) {
          if (*__haystack != 0) {
            uVar9 = (uint)(byte)*__haystack << 8;
            bVar2 = __haystack[1];
            pcVar10 = __haystack + 1;
            while (pcVar6 = pcVar10, uVar9 = (bVar2 | uVar9) << 8, bVar2 != 0) {
              bVar2 = pcVar6[1];
              pcVar10 = pcVar6 + 1;
              if ((__c << 0x18 | uVar7 << 0x10 | (uint)bVar1 << 8) == uVar9) {
                return pcVar6 + -2;
              }
            }
          }
        }
        else {
          if (__needle[4] == '\0') {
            bVar2 = *__haystack;
            __c = __c << 0x18 | uVar7 << 0x10 | (uint)(byte)__needle[3] | (uint)bVar1 << 8;
            if (bVar2 != 0) {
              uVar7 = 0;
              do {
                pcVar10 = __haystack;
                uVar7 = (uint)bVar2 | uVar7 << 8;
                bVar2 = pcVar10[1];
                if (bVar2 == 0) {
                  if (__c != uVar7) goto LAB_2306df5c;
                  break;
                }
                __haystack = pcVar10 + 1;
              } while (__c != uVar7);
              return pcVar10 + -3;
            }
          }
          else {
            __n = strlen(__needle);
            sVar4 = strnlen(__haystack,__n | 0x200);
            if (__n <= sVar4) {
              if (0xfe < __n) {
                pcVar10 = (char *)two_way_long_needle(__haystack,sVar4,__needle,__n);
                return pcVar10;
              }
              pcVar10 = __haystack + (sVar4 - __n);
              memset(abStack96,__n + 1,0x40);
              if (__n != 0) {
                pbVar8 = (byte *)__needle;
                do {
                  bVar1 = *pbVar8;
                  cVar3 = (char)pbVar8;
                  pbVar8 = pbVar8 + 1;
                  abStack96[(uint)bVar1 & 0x3f] = ((char)__needle + (char)__n) - cVar3;
                } while ((byte *)(__needle + __n) != pbVar8);
              }
              while( true ) {
                __haystack = __haystack + -1 + abStack96[(uint)(byte)(__haystack + -1)[__n] & 0x3f];
                while (__haystack <= pcVar10) {
                  bVar1 = abStack96[(uint)(byte)__haystack[__n] & 0x3f];
                  iVar5 = memcmp(__haystack,__needle,__n);
                  if (iVar5 == 0) {
                    return __haystack;
                  }
                  __haystack = __haystack + bVar1;
                }
                if (pcVar10[__n] == '\0') break;
                sVar4 = strnlen(pcVar10 + __n,0x800);
                pcVar10 = pcVar10 + sVar4;
                if (pcVar10 < __haystack) {
                  return (char *)0x0;
                }
              }
            }
          }
        }
      }
LAB_2306df5c:
      __haystack = (char *)0x0;
    }
  }
  return __haystack;
}



uint _strtol_l_isra_0(undefined4 *param_1,byte *param_2,byte **param_3,uint param_4)

{
  byte bVar1;
  bool bVar2;
  uint uVar3;
  byte *pbVar4;
  uint uVar5;
  byte *pbVar6;
  uint uVar7;
  uint uVar8;
  int iVar9;
  uint uVar10;
  
  pbVar6 = param_2;
  do {
    pbVar4 = pbVar6;
    pbVar6 = pbVar4 + 1;
    bVar1 = *pbVar4;
    uVar7 = (uint)bVar1;
  } while ((_ctype_[uVar7 + 1] & 8) != 0);
  if (bVar1 == 0x2d) {
    uVar7 = (uint)*pbVar6;
    bVar2 = true;
    pbVar6 = pbVar4 + 2;
LAB_2306e05c:
    if (param_4 != 0) goto LAB_2306e060;
LAB_2306e0e4:
    if (uVar7 != 0x30) {
      uVar10 = 10;
      param_4 = 10;
      goto LAB_2306e06c;
    }
    if ((*pbVar6 & 0xdf) != 0x58) {
      uVar10 = 8;
      param_4 = 8;
      goto LAB_2306e06c;
    }
  }
  else {
    if (bVar1 != 0x2b) {
      bVar2 = false;
      goto LAB_2306e05c;
    }
    uVar7 = (uint)*pbVar6;
    bVar2 = false;
    pbVar6 = pbVar4 + 2;
    if (param_4 == 0) goto LAB_2306e0e4;
LAB_2306e060:
    uVar10 = param_4;
    if (param_4 != 0x10) goto LAB_2306e06c;
    if ((uVar7 != 0x30) || ((*pbVar6 & 0xdf) != 0x58)) {
      uVar10 = 0x10;
      goto LAB_2306e06c;
    }
  }
  uVar7 = (uint)pbVar6[1];
  uVar10 = 0x10;
  pbVar6 = pbVar6 + 2;
  param_4 = 0x10;
LAB_2306e06c:
  uVar3 = 0x80000000;
  if (!bVar2) {
    uVar3 = 0x7fffffff;
  }
  iVar9 = 0;
  uVar5 = 0;
  do {
    uVar8 = uVar7 - 0x30;
    if (9 < uVar8) {
      if (uVar7 - 0x41 < 0x1a) {
        uVar8 = uVar7 - 0x37;
      }
      else {
        if (0x19 < uVar7 - 0x61) break;
        uVar8 = uVar7 - 0x57;
      }
    }
    if ((int)param_4 <= (int)uVar8) break;
    if (((iVar9 != -1) && (iVar9 = -1, uVar5 <= uVar3 / uVar10)) &&
       ((uVar3 / uVar10 != uVar5 || ((int)uVar8 <= (int)(uVar3 % uVar10))))) {
      iVar9 = 1;
      uVar5 = uVar8 + uVar10 * uVar5;
    }
    uVar7 = (uint)*pbVar6;
    pbVar6 = pbVar6 + 1;
  } while( true );
  if (iVar9 == -1) {
    *param_1 = 0x22;
    if (param_3 == (byte **)0x0) {
      return uVar3;
    }
  }
  else {
    uVar3 = uVar5;
    if (bVar2) {
      uVar3 = -uVar5;
    }
    if (param_3 == (byte **)0x0) {
      return uVar3;
    }
    if (iVar9 == 0) goto LAB_2306e120;
  }
  param_2 = pbVar6 + -1;
LAB_2306e120:
  *param_3 = param_2;
  return uVar3;
}



uint _strtol_r(undefined4 *param_1,byte *param_2,byte **param_3,uint param_4)

{
  byte bVar1;
  bool bVar2;
  uint uVar3;
  byte *pbVar4;
  uint uVar5;
  byte *pbVar6;
  uint uVar7;
  uint uVar8;
  int iVar9;
  uint uVar10;
  
  pbVar6 = param_2;
  do {
    pbVar4 = pbVar6;
    pbVar6 = pbVar4 + 1;
    bVar1 = *pbVar4;
    uVar7 = (uint)bVar1;
  } while ((_ctype_[uVar7 + 1] & 8) != 0);
  if (bVar1 == 0x2d) {
    uVar7 = (uint)*pbVar6;
    bVar2 = true;
    pbVar6 = pbVar4 + 2;
LAB_2306e05c:
    if (param_4 != 0) goto LAB_2306e060;
LAB_2306e0e4:
    if (uVar7 != 0x30) {
      uVar10 = 10;
      param_4 = 10;
      goto LAB_2306e06c;
    }
    if ((*pbVar6 & 0xdf) != 0x58) {
      uVar10 = 8;
      param_4 = 8;
      goto LAB_2306e06c;
    }
  }
  else {
    if (bVar1 != 0x2b) {
      bVar2 = false;
      goto LAB_2306e05c;
    }
    uVar7 = (uint)*pbVar6;
    bVar2 = false;
    pbVar6 = pbVar4 + 2;
    if (param_4 == 0) goto LAB_2306e0e4;
LAB_2306e060:
    uVar10 = param_4;
    if (param_4 != 0x10) goto LAB_2306e06c;
    if ((uVar7 != 0x30) || ((*pbVar6 & 0xdf) != 0x58)) {
      uVar10 = 0x10;
      goto LAB_2306e06c;
    }
  }
  uVar7 = (uint)pbVar6[1];
  uVar10 = 0x10;
  pbVar6 = pbVar6 + 2;
  param_4 = 0x10;
LAB_2306e06c:
  uVar3 = 0x80000000;
  if (!bVar2) {
    uVar3 = 0x7fffffff;
  }
  iVar9 = 0;
  uVar5 = 0;
  do {
    uVar8 = uVar7 - 0x30;
    if (9 < uVar8) {
      if (uVar7 - 0x41 < 0x1a) {
        uVar8 = uVar7 - 0x37;
      }
      else {
        if (0x19 < uVar7 - 0x61) break;
        uVar8 = uVar7 - 0x57;
      }
    }
    if ((int)param_4 <= (int)uVar8) break;
    if (((iVar9 != -1) && (iVar9 = -1, uVar5 <= uVar3 / uVar10)) &&
       ((uVar3 / uVar10 != uVar5 || ((int)uVar8 <= (int)(uVar3 % uVar10))))) {
      iVar9 = 1;
      uVar5 = uVar8 + uVar10 * uVar5;
    }
    uVar7 = (uint)*pbVar6;
    pbVar6 = pbVar6 + 1;
  } while( true );
  if (iVar9 == -1) {
    *param_1 = 0x22;
    if (param_3 == (byte **)0x0) {
      return uVar3;
    }
  }
  else {
    uVar3 = uVar5;
    if (bVar2) {
      uVar3 = -uVar5;
    }
    if (param_3 == (byte **)0x0) {
      return uVar3;
    }
    if (iVar9 == 0) goto LAB_2306e120;
  }
  param_2 = pbVar6 + -1;
LAB_2306e120:
  *param_3 = param_2;
  return uVar3;
}



long strtol_l(char *__nptr,char **__endptr,int __base,__locale_t __loc)

{
  long lVar1;
  
  lVar1 = _strtol_l_isra_0(_impure_ptr,__nptr,__endptr,__base);
  return lVar1;
}



long strtol(char *__nptr,char **__endptr,int __base)

{
  long lVar1;
  
  lVar1 = _strtol_l_isra_0(_impure_ptr,__nptr,__endptr,__base);
  return lVar1;
}



int stat(char *__file,stat *__buf)

{
  int iVar1;
  
  iVar1 = _stat_r(_impure_ptr,__file,__buf);
  return iVar1;
}



void _stat_r(int *param_1,undefined4 param_2,undefined4 param_3)

{
  int iVar1;
  
  errno = 0;
  iVar1 = _stat(param_2,param_3);
  if ((iVar1 == -1) && (errno != 0)) {
    *param_1 = errno;
    return;
  }
  return;
}



int _stat(int param_1,undefined4 param_2)

{
  int *piVar1;
  undefined auStack144 [132];
  
  ecall();
  if (param_1 < 0) {
    piVar1 = (int *)__errno(auStack144,0,0,0,0,0x40e);
    *piVar1 = -param_1;
    param_1 = -1;
  }
  _conv_stat(param_2,auStack144);
  return param_1;
}



void _conv_stat(undefined2 *param_1,undefined4 *param_2)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  undefined4 uVar10;
  undefined4 uVar11;
  undefined4 uVar12;
  undefined4 uVar13;
  undefined4 uVar14;
  undefined4 uVar15;
  
  uVar3 = param_2[5];
  uVar1 = param_2[6];
  uVar15 = param_2[7];
  uVar14 = param_2[8];
  uVar13 = param_2[0xc];
  uVar12 = param_2[0x10];
  uVar2 = param_2[0xe];
  uVar10 = param_2[0x12];
  uVar11 = param_2[0x13];
  uVar6 = param_2[0x16];
  uVar4 = param_2[4];
  uVar5 = param_2[2];
  uVar7 = param_2[0x17];
  uVar8 = param_2[0x1a];
  uVar9 = param_2[0x1b];
  *param_1 = (short)*param_2;
  param_1[1] = (short)uVar5;
  *(undefined4 *)(param_1 + 2) = uVar4;
  param_1[4] = (short)uVar3;
  param_1[5] = (short)uVar1;
  param_1[6] = (short)uVar15;
  param_1[7] = (short)uVar14;
  *(undefined4 *)(param_1 + 8) = uVar13;
  *(undefined4 *)(param_1 + 0x24) = uVar12;
  *(undefined4 *)(param_1 + 0x22) = uVar2;
  *(undefined4 *)(param_1 + 0xc) = uVar10;
  *(undefined4 *)(param_1 + 0xe) = uVar11;
  *(undefined4 *)(param_1 + 0x14) = uVar6;
  *(undefined4 *)(param_1 + 0x16) = uVar7;
  *(undefined4 *)(param_1 + 0x1c) = uVar8;
  *(undefined4 *)(param_1 + 0x1e) = uVar9;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_On_BG(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c4a0. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010828)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_Off_BG(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c4aa. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101082c)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_On_LDO11_SOC(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c4b4. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010830)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_Off_LDO11_SOC(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c4be. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010834)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_On_LDO15_RF(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c4c8. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010838)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_Off_LDO15_RF(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c4d2. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101083c)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_On_SFReg(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c4dc. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010840)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_Off_SFReg(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c4e6. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010844)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_LowPower_Enter_PDS0(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c4f0. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010848)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_LowPower_Exit_PDS0(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c4fa. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101084c)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ASM_Delay_Us(uint32_t core,uint32_t cnt)

{
                    // WARNING: Could not recover jumptable at 0x4200c504. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010850)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void BL602_Delay_US(uint32_t cnt)

{
                    // WARNING: Could not recover jumptable at 0x4200c50e. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010854)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void BL602_Delay_MS(uint32_t cnt)

{
                    // WARNING: Could not recover jumptable at 0x4200c518. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010858)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void * BL602_MemCpy(void *dst,void *src,uint32_t n)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c522. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*_DAT_2101085c)();
  return pvVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t * BL602_MemCpy4(uint32_t *dst,uint32_t *src,uint32_t n)

{
  uint32_t *puVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c52c. Too many branches
                    // WARNING: Treating indirect jump as call
  puVar1 = (uint32_t *)(*_DAT_21010860)();
  return puVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void * BL602_MemCpy_Fast(void *pdst,void *psrc,uint32_t n)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c536. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*_DAT_21010864)();
  return pvVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void * BL602_MemSet(void *s,uint8_t c,uint32_t n)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c540. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*_DAT_21010868)();
  return pvVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t * BL602_MemSet4(uint32_t *dst,uint32_t val,uint32_t n)

{
  uint32_t *puVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c54a. Too many branches
                    // WARNING: Treating indirect jump as call
  puVar1 = (uint32_t *)(*_DAT_2101086c)();
  return puVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int BL602_MemCmp(void *s1,void *s2,uint32_t n)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c554. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*_DAT_21010870)();
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void EF_Ctrl_Sw_AHB_Clk_0(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c55e. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010874)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void EF_Ctrl_Program_Efuse_0(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c568. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010878)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void EF_Ctrl_Load_Efuse_R0(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c572. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_2101087c)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Sts_Type EF_Ctrl_Busy(void)

{
  BL_Sts_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c57c. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010880)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Sts_Type EF_Ctrl_AutoLoad_Done(void)

{
  BL_Sts_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c586. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010884)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void EF_Ctrl_Clear(uint32_t index,uint32_t len)

{
                    // WARNING: Could not recover jumptable at 0x4200c590. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010894)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_SW_System_Reset(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c59a. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108bc)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_SW_CPU_Reset(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c5a4. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108c0)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_SW_POR_Reset(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c5ae. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108c4)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_Select_Internal_Flash(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c5b8. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108c8)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_Select_External_Flash(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c5c2. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108cc)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_Deswap_Flash_Pin(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c5cc. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108d0)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_Swap_Flash_Pin(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c5d6. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108d4)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_GPIO_Init(GLB_GPIO_Cfg_Type *cfg)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c5e0. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108d8)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_GPIO_OUTPUT_Enable(GLB_GPIO_Type gpioPin)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c5ea. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108dc)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_GPIO_OUTPUT_Disable(GLB_GPIO_Type gpioPin)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c5f4. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108e0)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_GPIO_Set_HZ(GLB_GPIO_Type gpioPin)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c5fe. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108e4)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t GLB_GPIO_Get_Fun(GLB_GPIO_Type gpioPin)

{
  uint8_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c608. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*_DAT_210108e8)();
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void HBN_Mode_Enter(HBN_APP_CFG_Type *cfg)

{
                    // WARNING: Could not recover jumptable at 0x4200c612. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210108ec)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void HBN_Power_Down_Flash(SPI_Flash_Cfg_Type *flashCfg)

{
                    // WARNING: Could not recover jumptable at 0x4200c61c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210108f0)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void HBN_Enable(uint8_t aGPIOIeCfg,HBN_LDO_LEVEL_Type ldoLevel,HBN_LEVEL_Type hbnLevel)

{
                    // WARNING: Could not recover jumptable at 0x4200c626. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210108f4)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Reset(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c630. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108f8)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Set_Ldo11_Aon_Vout(HBN_LDO_LEVEL_Type ldoLevel)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c63a. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108fc)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Set_Ldo11_Rt_Vout(HBN_LDO_LEVEL_Type ldoLevel)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c644. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010900)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Set_Ldo11_Soc_Vout(HBN_LDO_LEVEL_Type ldoLevel)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c64e. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010904)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Hw_Pu_Pd_Cfg(uint8_t enable)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c658. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010924)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Pin_WakeUp_Mask(uint8_t maskVal)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c662. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010928)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
HBN_GPIO7_Dbg_Pull_Cfg(BL_Fun_Type pupdEn,BL_Fun_Type iesmtEn,BL_Fun_Type dlyEn,uint8_t dlySec)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c66c. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101092c)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Set_Embedded_Flash_Pullup(uint8_t enable)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c676. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010930)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type L1C_Set_Wrap(BL_Fun_Type wrap)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c680. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010934)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type L1C_Set_Way_Disable(uint8_t disableVal)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c68a. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010938)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type L1C_IROM_2T_Access_Set(uint8_t enable)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c694. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101093c)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_Reset(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c69e. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010940)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_Force_Config(PDS_CTL2_Type_conflict4 *cfg2,PDS_CTL3_Type_conflict4 *cfg3)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c6a8. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010948)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_RAM_Config(PDS_RAM_CFG_Type_conflict1 *ramCfg)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c6b2. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101094c)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
PDS_Default_Level_Config
          (PDS_DEFAULT_LV_CFG_Type_conflict1 *defaultLvCfg,PDS_RAM_CFG_Type_conflict1 *ramCfg,
          uint32_t pdsSleepCnt)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c6bc. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010950)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SEC_Eng_Turn_On_Sec_Ring(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c6c6. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010978)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SEC_Eng_Turn_Off_Sec_Ring(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c6d0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_2101097c)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_Init(SF_Ctrl_Cfg_Type *pSfCtrlCfg)

{
                    // WARNING: Could not recover jumptable at 0x4200c6da. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010980)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SFlash_SetSPIMode(SF_Ctrl_Mode_Type mode)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c6e4. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010984)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
SFlash_Read_Reg(SPI_Flash_Cfg_Type *flashCfg,uint8_t regIndex,uint8_t *regValue,uint8_t regLen)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c6ee. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010988)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
SFlash_Write_Reg(SPI_Flash_Cfg_Type *flashCfg,uint8_t regIndex,uint8_t *regValue,uint8_t regLen)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c6f8. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101098c)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Sts_Type SFlash_Busy(SPI_Flash_Cfg_Type *flashCfg)

{
  BL_Sts_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c702. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010990)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SFlash_Write_Enable(SPI_Flash_Cfg_Type *flashCfg)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c70c. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010994)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SFlash_Qspi_Enable(SPI_Flash_Cfg_Type *flashCfg)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c716. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010998)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_Volatile_Reg_Write_Enable(SPI_Flash_Cfg_Type *flashCfg)

{
                    // WARNING: Could not recover jumptable at 0x4200c720. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_2101099c)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SFlash_Chip_Erase(SPI_Flash_Cfg_Type *flashCfg)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c72a. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109a0)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SFlash_Sector_Erase(SPI_Flash_Cfg_Type *flashCfg,uint32_t secNum)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c734. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109a4)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SFlash_Blk32_Erase(SPI_Flash_Cfg_Type *flashCfg,uint32_t blkNum)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c73e. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109a8)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SFlash_Blk64_Erase(SPI_Flash_Cfg_Type *flashCfg,uint32_t blkNum)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c748. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109ac)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SFlash_Erase(SPI_Flash_Cfg_Type *flashCfg,uint32_t startaddr,uint32_t endaddr)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c752. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109b0)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
SFlash_Program(SPI_Flash_Cfg_Type *flashCfg,SF_Ctrl_IO_Type ioMode,uint32_t addr,uint8_t *data,
              uint32_t len)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c75c. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109b4)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_GetUniqueId(uint8_t *data,uint8_t idLen)

{
                    // WARNING: Could not recover jumptable at 0x4200c766. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210109b8)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_GetJedecId(SPI_Flash_Cfg_Type *flashCfg,uint8_t *data)

{
                    // WARNING: Could not recover jumptable at 0x4200c770. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210109bc)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_GetDeviceId(uint8_t *data)

{
                    // WARNING: Could not recover jumptable at 0x4200c77a. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210109c0)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_Powerdown(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c784. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210109c4)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_Releae_Powerdown(SPI_Flash_Cfg_Type *flashCfg)

{
                    // WARNING: Could not recover jumptable at 0x4200c78e. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210109c8)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_SetBurstWrap(SPI_Flash_Cfg_Type *flashCfg)

{
                    // WARNING: Could not recover jumptable at 0x4200c798. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210109cc)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_DisableBurstWrap(SPI_Flash_Cfg_Type *flashCfg)

{
                    // WARNING: Could not recover jumptable at 0x4200c7a2. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210109d0)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SFlash_Software_Reset(SPI_Flash_Cfg_Type *flashCfg)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c7ac. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109d4)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_Reset_Continue_Read(SPI_Flash_Cfg_Type *flashCfg)

{
                    // WARNING: Could not recover jumptable at 0x4200c7b6. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210109d8)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
SFlash_Set_IDbus_Cfg
          (SPI_Flash_Cfg_Type *flashCfg,SF_Ctrl_IO_Type ioMode,uint8_t contRead,uint32_t addr,
          uint32_t len)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c7c0. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109dc)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
SFlash_IDbus_Read_Enable(SPI_Flash_Cfg_Type *flashCfg,SF_Ctrl_IO_Type ioMode,uint8_t contRead)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c7ca. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109e0)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SFlash_Cache_Enable_Set(uint8_t wayDisable)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c7d4. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109e4)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SFlash_Cache_Flush(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c7de. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109e8)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
SFlash_Cache_Read_Enable
          (SPI_Flash_Cfg_Type *flashCfg,SF_Ctrl_IO_Type ioMode,uint8_t contRead,uint8_t wayDisable)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c7e8. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109ec)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_Cache_Hit_Count_Get(uint32_t *hitCountLow,uint32_t *hitCountHigh)

{
                    // WARNING: Could not recover jumptable at 0x4200c7f2. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210109f0)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t SFlash_Cache_Miss_Count_Get(void)

{
  uint32_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c7fc. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*_DAT_210109f4)();
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_Cache_Read_Disable(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c806. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210109f8)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
SFlash_Read(SPI_Flash_Cfg_Type *flashCfg,SF_Ctrl_IO_Type ioMode,uint8_t contRead,uint32_t addr,
           uint8_t *data,uint32_t len)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c810. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109fc)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
SFlash_Read_Reg_With_Cmd
          (SPI_Flash_Cfg_Type *flashCfg,uint8_t readRegCmd,uint8_t *regValue,uint8_t regLen)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c81a. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010a00)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
SFlash_Write_Reg_With_Cmd
          (SPI_Flash_Cfg_Type *flashCfg,uint8_t writeRegCmd,uint8_t *regValue,uint8_t regLen)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c824. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010a04)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Cfg_Init_Ext_Flash_Gpio(uint8_t extFlashPin)

{
                    // WARNING: Could not recover jumptable at 0x4200c82e. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a0c)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Cfg_Init_Internal_Flash_Gpio(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c838. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a10)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Cfg_Deinit_Ext_Flash_Gpio(uint8_t extFlashPin)

{
                    // WARNING: Could not recover jumptable at 0x4200c842. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a14)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Cfg_Restore_GPIO17_Fun(uint8_t fun)

{
                    // WARNING: Could not recover jumptable at 0x4200c84c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a18)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SF_Cfg_Get_Flash_Cfg_Need_Lock(uint32_t flashID,SPI_Flash_Cfg_Type *pFlashCfg)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c856. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010a1c)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Cfg_Init_Flash_Gpio(uint8_t flashPinCfg,uint8_t restoreDefault)

{
                    // WARNING: Could not recover jumptable at 0x4200c860. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a20)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t SF_Cfg_Flash_Identify
                   (uint8_t callFromFlash,uint32_t autoScan,uint32_t flashPinCfg,
                   uint8_t restoreDefault,SPI_Flash_Cfg_Type *pFlashCfg)

{
  undefined3 in_register_00002029;
  uint32_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c86a. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*_DAT_21010a24)(CONCAT31(in_register_00002029,callFromFlash));
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_Enable(SF_Ctrl_Cfg_Type *cfg)

{
                    // WARNING: Could not recover jumptable at 0x4200c874. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a28)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_Select_Pad(SF_Ctrl_Pad_Sel sel)

{
                    // WARNING: Could not recover jumptable at 0x4200c87e. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a2c)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_Set_Owner(SF_Ctrl_Owner_Type owner)

{
                    // WARNING: Could not recover jumptable at 0x4200c888. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a30)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_Disable(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c892. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a34)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_AES_Enable_BE(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c89c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a38)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_AES_Enable_LE(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c8a6. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a3c)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_AES_Set_Region
               (uint8_t region,uint8_t enable,uint8_t hwKey,uint32_t startAddr,uint32_t endAddr,
               uint8_t locked)

{
                    // WARNING: Could not recover jumptable at 0x4200c8b0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a40)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_AES_Set_Key(uint8_t region,uint8_t *key,SF_Ctrl_AES_Key_Type keyType)

{
                    // WARNING: Could not recover jumptable at 0x4200c8ba. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a44)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_AES_Set_Key_BE(uint8_t region,uint8_t *key,SF_Ctrl_AES_Key_Type keyType)

{
                    // WARNING: Could not recover jumptable at 0x4200c8c4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a48)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_AES_Set_IV(uint8_t region,uint8_t *iv,uint32_t addrOffset)

{
                    // WARNING: Could not recover jumptable at 0x4200c8ce. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a4c)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_AES_Set_IV_BE(uint8_t region,uint8_t *iv,uint32_t addrOffset)

{
                    // WARNING: Could not recover jumptable at 0x4200c8d8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a50)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_AES_Enable(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c8e2. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a54)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_AES_Disable(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c8ec. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a58)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_Set_Flash_Image_Offset(uint32_t addrOffset)

{
                    // WARNING: Could not recover jumptable at 0x4200c8f6. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a5c)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t SF_Ctrl_Get_Flash_Image_Offset(void)

{
  uint32_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c900. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*_DAT_21010a60)();
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_Select_Clock(SF_Ctrl_Sahb_Type sahbType)

{
                    // WARNING: Could not recover jumptable at 0x4200c90a. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a64)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_SendCmd(SF_Ctrl_Cmd_Cfg_Type *cfg)

{
                    // WARNING: Could not recover jumptable at 0x4200c914. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a68)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_Icache_Set(SF_Ctrl_Cmd_Cfg_Type *cfg,uint8_t cmdValid)

{
                    // WARNING: Could not recover jumptable at 0x4200c91e. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a6c)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_Icache2_Set(SF_Ctrl_Cmd_Cfg_Type *cfg,uint8_t cmdValid)

{
                    // WARNING: Could not recover jumptable at 0x4200c928. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a70)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Sts_Type SF_Ctrl_GetBusyState(void)

{
  BL_Sts_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c932. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010a74)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t SF_Ctrl_Is_AES_Enable(void)

{
  uint8_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c93c. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*_DAT_21010a78)();
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t SF_Ctrl_Get_Clock_Delay(void)

{
  uint8_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c946. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*_DAT_21010a7c)();
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_Set_Clock_Delay(uint8_t delay)

{
                    // WARNING: Could not recover jumptable at 0x4200c950. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a80)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type XIP_SFlash_State_Save(SPI_Flash_Cfg_Type *pFlashCfg,uint32_t *offset)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c95a. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010a84)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type XIP_SFlash_State_Restore(SPI_Flash_Cfg_Type *pFlashCfg,uint32_t offset)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c964. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010a88)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
XIP_SFlash_Erase_Need_Lock(SPI_Flash_Cfg_Type *pFlashCfg,uint32_t startaddr,uint32_t endaddr)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c96e. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010a8c)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
XIP_SFlash_Write_Need_Lock(SPI_Flash_Cfg_Type *pFlashCfg,uint32_t addr,uint8_t *data,uint32_t len)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c978. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010a90)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
XIP_SFlash_Read_Need_Lock(SPI_Flash_Cfg_Type *pFlashCfg,uint32_t addr,uint8_t *data,uint32_t len)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c982. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010a94)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type XIP_SFlash_GetJedecId_Need_Lock(SPI_Flash_Cfg_Type *pFlashCfg,uint8_t *data)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c98c. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010a98)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type XIP_SFlash_GetDeviceId_Need_Lock(SPI_Flash_Cfg_Type *pFlashCfg,uint8_t *data)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c996. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010a9c)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
XIP_SFlash_GetUniqueId_Need_Lock(SPI_Flash_Cfg_Type *pFlashCfg,uint8_t *data,uint8_t idLen)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c9a0. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010aa0)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type XIP_SFlash_Read_Via_Cache_Need_Lock(uint32_t addr,uint8_t *data,uint32_t len)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c9aa. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010aa4)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int XIP_SFlash_Read_With_Lock(SPI_Flash_Cfg_Type *pFlashCfg,uint32_t addr,uint8_t *dst,int len)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c9b4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*_DAT_21010aa8)();
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int XIP_SFlash_Write_With_Lock(SPI_Flash_Cfg_Type *pFlashCfg,uint32_t addr,uint8_t *src,int len)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c9be. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*_DAT_21010aac)();
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int XIP_SFlash_Erase_With_Lock(SPI_Flash_Cfg_Type *pFlashCfg,uint32_t addr,int len)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c9c8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*_DAT_21010ab0)();
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void XIP_SFlash_Opt_Enter(uint8_t *aesEnable)

{
                    // WARNING: Could not recover jumptable at 0x4200c9d2. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010ab4)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void XIP_SFlash_Opt_Exit(uint8_t aesEnable)

{
                    // WARNING: Could not recover jumptable at 0x4200c9dc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010ab8)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t BFLB_Soft_CRC32(void *dataIn,uint32_t len)

{
  uint32_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c9e6. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*_DAT_21010abc)();
  return uVar1;
}



// WARNING: Control flow encountered bad instruction data

BL_Err_Type ADC_Trim_TSEN(uint16_t *tsen_offset)

{
  Efuse_TSEN_Refcode_Corner_Type_conflict trim;
  
                    // WARNING: Bad instruction - Truncating control flow here
  halt_baddata();
}



// WARNING: Control flow encountered bad instruction data

BL_Err_Type ADC_Gain_Trim(void)

{
  uint uVar1;
  uint8_t a;
  undefined3 extraout_var;
  Efuse_ADC_Gain_Coeff_Type_conflict3 EStack36;
  Efuse_ADC_Gain_Coeff_Type_conflict trim;
  
  EF_Ctrl_Read_ADC_Gain_Trim(&EStack36);
  if ((int)EStack36 << 0x12 < 0) {
    uVar1 = (uint)EStack36 >> 0xc;
    a = EF_Ctrl_Get_Trim_Parity((uint)EStack36 & 0xfff,'\f');
    _a = (SFtype)CONCAT31(extraout_var,a);
    if ((SFtype)(uVar1 & 1) == _a) {
      adcGainCoeffCal.adcGainCoeffEnable = ENABLE;
      adcGainCoeffCal.adcgainCoeffVal = SUB42(EStack36,0) & 0xfff;
      if (((uint)EStack36 & 0x800) == 0) {
        __extendsfdf2(_a);
        __muldf3();
        __subdf3();
      }
      else {
        __extendsfdf2(_a);
        __muldf3();
        __adddf3();
      }
      __truncdfsf2();
                    // WARNING: Bad instruction - Truncating control flow here
      halt_baddata();
    }
  }
  return ERROR;
}



uint8_t EF_Ctrl_Get_Trim_Parity(uint32_t val,uint8_t len)

{
  undefined3 in_register_0000202d;
  uint uVar1;
  byte bVar2;
  
  uVar1 = 0;
  bVar2 = 0;
  while ((uVar1 & 0xff) < CONCAT31(in_register_0000202d,len)) {
    if ((1 << (uVar1 & 0x1f) & val) != 0) {
      bVar2 = bVar2 + 1;
    }
    uVar1 = uVar1 + 1;
  }
  return (uint8_t)(bVar2 & 1);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void EF_Ctrl_Read_RC32M_Trim(Efuse_Ana_RC32M_Trim_Type_conflict1 *trim)

{
  uint uVar1;
  uint uVar2;
  
  EF_Ctrl_Sw_AHB_Clk_0();
  EF_Ctrl_Load_Efuse_R0();
  uVar1 = _DAT_4000700c;
  uVar2 = _DAT_4000700c >> 10;
  *(char *)trim = (char)uVar2;
  *(uint *)trim = (uint)*trim & 0xfffffcff | uVar2 & 0x100 | uVar1 >> 10 & 0x200;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void EF_Ctrl_Read_RC32K_Trim(Efuse_Ana_RC32K_Trim_Type_conflict3 *trim)

{
  EF_Ctrl_Sw_AHB_Clk_0();
  EF_Ctrl_Load_Efuse_R0();
  *(uint *)trim =
       (uint)*trim & 0xfffff000 | _DAT_4000700c >> 0x14 & 0x3ff | _DAT_4000700c >> 0x14 & 0x400 |
       (_DAT_4000700c >> 0x1f) << 0xb;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void EF_Ctrl_Read_TSEN_Trim(Efuse_TSEN_Refcode_Corner_Type_conflict3 *trim)

{
  uint uVar1;
  Efuse_TSEN_Refcode_Corner_Type_conflict3 EVar2;
  uint uVar3;
  uint uVar4;
  
  EF_Ctrl_Sw_AHB_Clk_0();
  EF_Ctrl_Load_Efuse_R0();
  uVar3 = (_DAT_40007078 & 1) << 0xd;
  EVar2 = *trim;
  *(uint *)trim = (uint)EVar2 & 0xffffdfff | uVar3;
  uVar4 = _DAT_4000707c & 0xfff;
  uVar1 = _DAT_4000707c & 0x1000;
  *(uint *)trim = (uint)EVar2 & 0xffffc000 | uVar3 | uVar4 | uVar1;
  *(uint *)trim =
       (uint)EVar2 & 0xffff8000 | uVar3 | uVar4 | uVar1 | (_DAT_40007070 >> 0x1e & 1) << 0xe;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void EF_Ctrl_Read_ADC_Gain_Trim(Efuse_ADC_Gain_Coeff_Type_conflict3 *trim)

{
  EF_Ctrl_Sw_AHB_Clk_0();
  EF_Ctrl_Load_Efuse_R0();
  *(uint *)trim =
       (uint)*trim & 0xffffc000 | (_DAT_40007078 << 0x13) >> 0x14 |
       (_DAT_40007078 >> 0xd & 1) << 0xc | (_DAT_40007078 >> 0xe & 1) << 0xd;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_On_MBG(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cd8e. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010810)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_Off_MBG(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cd98. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010814)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_On_XTAL(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cda2. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010818)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Set_Xtal_CapCode(uint8_t capIn,uint8_t capOut)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cdac. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101081c)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t AON_Get_Xtal_CapCode(void)

{
  uint8_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cdb6. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*_DAT_21010820)();
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_Off_XTAL(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cdc0. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010824)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t EF_Ctrl_Get_Trim_Parity(uint32_t val,uint8_t len)

{
  uint8_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cdca. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*_DAT_21010888)();
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void EF_Ctrl_Read_RC32M_Trim(Efuse_Ana_RC32M_Trim_Type_conflict4 *trim)

{
                    // WARNING: Could not recover jumptable at 0x4200cdd4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_2101088c)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void EF_Ctrl_Read_RC32K_Trim(Efuse_Ana_RC32K_Trim_Type_conflict6 *trim)

{
                    // WARNING: Could not recover jumptable at 0x4200cdde. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010890)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

GLB_ROOT_CLK_Type GLB_Get_Root_CLK_Sel(void)

{
  GLB_ROOT_CLK_Type GVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cde8. Too many branches
                    // WARNING: Treating indirect jump as call
  GVar1 = (*_DAT_21010898)();
  return GVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_Set_System_CLK_Div(uint8_t hclkDiv,uint8_t bclkDiv)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cdf2. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101089c)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t GLB_Get_BCLK_Div(void)

{
  uint8_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cdfc. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*_DAT_210108a0)();
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t GLB_Get_HCLK_Div(void)

{
  uint8_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce06. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*_DAT_210108a4)();
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type Update_SystemCoreClockWith_XTAL(GLB_PLL_XTAL_Type xtalType)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce10. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108a8)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_Set_System_CLK(GLB_PLL_XTAL_Type xtalType,GLB_SYS_CLK_Type clkFreq)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce1a. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108ac)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type System_Core_Clock_Update_From_RC32M(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce24. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108b0)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_Set_SF_CLK(uint8_t enable,GLB_SFLASH_CLK_Type clkSel,uint8_t div)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce2e. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108b4)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_Set_PKA_CLK_Sel(GLB_PKA_CLK_Type clkSel)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce38. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108b8)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_32K_Sel(HBN_32K_CLK_Type clkType)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce42. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010908)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Set_ROOT_CLK_Sel(HBN_ROOT_CLK_Type rootClk)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce4c. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101090c)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Power_On_Xtal_32K(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce56. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010910)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Power_Off_Xtal_32K(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce60. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010914)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Power_On_RC32K(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce6a. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010918)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Power_Off_RC32K(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce74. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101091c)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Trim_RC32K(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce7e. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010920)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_Trim_RC32M(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce88. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010954)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_Select_RC32M_As_PLL_Ref(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce92. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010958)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_Select_XTAL_As_PLL_Ref(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce9c. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101095c)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_Power_On_PLL(PDS_PLL_XTAL_Type xtalType)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cea6. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010960)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_Enable_PLL_All_Clks(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ceb0. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010964)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_Disable_PLL_All_Clks(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ceba. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010968)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_Enable_PLL_Clk(PDS_PLL_CLK_Type pllClk)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cec4. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101096c)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_Disable_PLL_Clk(PDS_PLL_CLK_Type pllClk)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cece. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010970)();
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_Power_Off_PLL(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ced8. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010974)();
  return BVar1;
}


